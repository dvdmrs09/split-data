{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_object(self, queryset=None):\n        try:\n            pk = self.kwargs.get('pk', None)\n\n            # allow serializer without service\n            obj = self.service.get(pk)\n            return obj\n        except self.model.DoesNotExist:\n            raise Http404()", "response": "Override default to add support for object - level permissions."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef emit(self, record):\n        if not record.name == \"amqp\":\n            data = {}\n            for k, v in record.__dict__.items():\n                if (self.__includes and k in self.__includes) or (self.__excludes and k not in self.__excludes):\n                    data[k] = v\n            self.__producer.publish(data, retry=True, delivery_mode=2)", "response": "This method is called by the amqp module when a record is received."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses meta tags with given meta_name.", "response": "def parse_meta(content, meta_name, source_descr, content_attr_name=\"content\"):\n    \"\"\"\n    Return list of strings parsed from `content` attribute from ``<meta>``\n    tags with given `meta_name`.\n    \"\"\"\n    dom = dhtmlparser.parseString(content)\n\n    meta_tags = dom.find(\n        \"meta\",\n        fn=lambda x: x.params.get(\"name\", \"\").lower() == meta_name.lower()\n    )\n\n    return [\n        SourceString(tag.params[content_attr_name], source_descr)\n        for tag in meta_tags\n        if content_attr_name in tag.params\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the unique tag of the feat database.", "response": "def get_database_tag(self):\n        '''\n        Each feat database has a unique tag which identifies it. Thanks to it\n        the mechanism cleaning up the update logs make the difference between\n        the changes done locally and remotely. The condition for cleaning\n        those up is different.\n        '''\n\n        def parse_response(doc):\n            self._database_tag = doc['tag']\n            return self._database_tag\n\n        def create_new(fail):\n            fail.trap(NotFoundError)\n            doc = {'_id': doc_id, 'tag': unicode(uuid.uuid1())}\n            return self.save_document(doc)\n\n        def conflict_handler(fail):\n            fail.trap(ConflictError)\n            return self.get_database_tag()\n\n\n        if not hasattr(self, '_database_tag'):\n            doc_id = u'_local/database_tag'\n            d = self.get_document(doc_id)\n            d.addErrback(create_new)\n            d.addErrback(conflict_handler)\n            d.addCallback(parse_response)\n            return d\n        else:\n            return defer.succeed(self._database_tag)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the view results and return a dict of the result.", "response": "def _parse_view_results(self, rows, factory, options):\n        '''\n        rows here should be a list of tuples:\n         - (key, value) for reduce views\n         - (key, value, id) for nonreduce views without include docs\n         - (key, value, id, doc) for nonreduce with with include docs\n        '''\n        kwargs = dict()\n        kwargs['reduced'] = factory.use_reduce and options.get('reduce', True)\n        kwargs['include_docs'] = options.get('include_docs', False)\n        # Lines below pass extra arguments to the parsing function if they\n        # are expected. These arguments are bound method unserialize() and\n        # unserialize_list(). They methods perform the magic of parsing and\n        # upgrading if necessary the loaded documents.\n\n        spec = inspect.getargspec(factory.parse_view_result)\n        if 'unserialize' in spec.args:\n            kwargs['unserialize'] = self.unserialize_document\n        if 'unserialize_list' in spec.args:\n            kwargs['unserialize_list'] = self.unserialize_list_of_documents\n        return factory.parse_view_result(rows, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a new range group that is merged with the given list of range lists.", "response": "def merge(*range_lists, **kwargs):\n    '''\n    Join given range groups, collapsing their overlapping ranges. If only one\n    group is given, this method will still fix it (sort and collapsing).\n\n    No typecheck is performed, so a valid range group will be any iterable\n    (or iterator) containing an (start, end) iterable pair. Result type will\n    be defined by group_class parameter (defaults to RangeGroup)\n\n    :param *range_lists: several range groups to join\n    :type *range_list: iterable of iterables\n    :param group_class: result type, defaults to RangeGroup\n    :type group_class: type\n    :returns: merged range group\n    :rtype: taken from group_class\n    :\n    '''\n    group_class = kwargs.pop('group_class', RangeGroup)  # FIXME: python2\n    range_list = [\n        unirange\n        for range_list in range_lists\n        for unirange in range_list\n        ]\n    range_list.sort()\n    it = iter(range_list)\n    slast, elast = last = list(next(it))\n    result = [last]\n    for start, end in it:\n        if start > elast:\n            slast, elast = last = [start, end]\n            result.append(last)\n        elif end > elast:\n            last[1] = elast = end\n    return group_class(result)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate(categorize=unicodedata.category, group_class=RangeGroup):\n    '''\n    Generate a dict of RangeGroups for each unicode character category,\n    including general ones.\n\n    :param categorize: category function, defaults to unicodedata.category.\n    :type categorize: callable\n    :param group_class: class for range groups, defaults to RangeGroup\n    :type group_class: type\n    :returns: dictionary of categories and range groups\n    :rtype: dict of RangeGroup\n    '''\n    categories = collections.defaultdict(list)\n    last_category = None\n    last_range = None\n    for c in range(sys.maxunicode + 1):\n        category = categorize(chr(c))\n        if category != last_category:\n            last_category = category\n            last_range = [c, c + 1]\n            categories[last_category].append(last_range)\n        else:\n            last_range[1] += 1\n    categories = {k: group_class(v) for k, v in categories.items()}\n    categories.update({\n        k: merge(*map(categories.__getitem__, g))\n        for k, g in itertools.groupby(sorted(categories), key=lambda k: k[0])\n        })\n    return categories", "response": "Generate a dict of RangeGroups for each unicode character category and RangeGroup."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef codes(self):\n        '''\n        Get iterator for all unicode code points contained in this range group.\n\n        :yields: iterator of character index (int)\n        :ytype: int\n        '''\n        for start, end in self:\n            for item in range(start, end):\n                yield item", "response": "Get iterator for all unicode code points contained in this range group."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has(self, character):\n        '''\n        Get if character (or character code point) is contained by any range on\n        this range group.\n\n        :param character: character or unicode code point to look for\n        :type character: str or int\n        :returns: True if character is contained by any range, False otherwise\n        :rtype: bool\n        '''\n        if not self:\n            return False\n        character = character if isinstance(character, int) else ord(character)\n        last = self[-1][-1]\n        start, end = self[bisect.bisect_right(self, (character, last)) - 1]\n        return start <= character < end", "response": "Returns True if the character code point is contained by any range on\n        this range group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind an appropriate version number from version control system.", "response": "def find_version(include_dev_version=True, version_file='version.txt',\n                 version_module_paths=(),\n                 git_args=('git', 'describe', '--tags', '--long'),\n                 Popen=subprocess.Popen):\n    \"\"\"Find an appropriate version number from version control.\n\n    It's much more convenient to be able to use your version control system's\n    tagging mechanism to derive a version number than to have to duplicate that\n    information all over the place. Currently, only git is supported.\n\n    The default behavior is to write out a ``version.txt`` file which contains\n    the git output, for systems where git isn't installed or there is no .git\n    directory present. ``version.txt`` can (and probably should!) be packaged\n    in release tarballs by way of the ``MANIFEST.in`` file.\n\n    :param include_dev_version: By default, if there are any commits after the\n                                most recent tag (as reported by git), that\n                                number will be included in the version number\n                                as a ``.dev`` suffix. For example, if the most\n                                recent tag is ``1.0`` and there have been three\n                                commits after that tag, the version number will\n                                be ``1.0.dev3``. This behavior can be disabled\n                                by setting this parameter to ``False``.\n\n    :param version_file: The name of the file where version information will be\n                         saved. Reading and writing version files can be\n                         disabled altogether by setting this parameter to\n                         ``None``.\n\n    :param version_module_paths: A list of python modules which will be\n                                 automatically generated containing\n                                 ``__version__`` and ``__sha__`` attributes.\n                                 For example, with ``package/_version.py`` as a\n                                 version module path, ``package/__init__.py``\n                                 could do ``from package._version import\n                                 __version__, __sha__``.\n\n    :param git_args: The git command to run to get a version. By default, this\n                     is ``git describe --tags --long``. Specify this as a list\n                     of string arguments including ``git``, e.g. ``['git',\n                     'describe']``.\n\n    :param Popen: Defaults to ``subprocess.Popen``. This is for testing.\n\n    \"\"\"\n\n    # try to pull the version from git, or (perhaps) fall back on a\n    # previously-saved version.\n    try:\n        proc = Popen(git_args, stdout=subprocess.PIPE)\n    except OSError:\n        raw_version = None\n    else:\n        raw_version = proc.communicate()[0].strip().decode()\n        version_source = 'git'\n\n    # git failed if the string is empty\n    if not raw_version:\n        if version_file is None:\n            print('%r failed' % (git_args,))\n            raise SystemExit(2)\n        elif not os.path.exists(version_file):\n            print(\"%r failed and %r isn't present.\" % (git_args, version_file))\n            print(\"are you installing from a github tarball?\")\n            raise SystemExit(2)\n        print(\"couldn't determine version from git; using %r\" % version_file)\n        with open(version_file, 'r') as infile:\n            raw_version = infile.read()\n        version_source = repr(version_file)\n\n\n    # try to parse the version into something usable.\n    try:\n        tag_version, commits, sha = raw_version.rsplit('-', 2)\n    except ValueError:\n        print(\"%r (from %s) couldn't be parsed into a version\" % (\n            raw_version, version_source))\n        raise SystemExit(2)\n\n    if version_file is not None:\n        with open(version_file, 'w') as outfile:\n            outfile.write(raw_version)\n\n    if commits == '0' or not include_dev_version:\n        version = tag_version\n    else:\n        version = '%s.dev%s' % (tag_version, commits)\n\n    for path in version_module_paths:\n        with open(path, 'w') as outfile:\n            outfile.write(\"\"\"\n# This file is automatically generated by setup.py.\n__version__ = %s\n__sha__ = %s\n\"\"\" % (repr(version).lstrip('u'), repr(sha).lstrip('u')))\n\n    return Version(version, commits, sha)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clean(dry_run='n'):\n    file_patterns = ['*.pyc', '*.pyo', '*~']\n    dir_patterns = ['__pycache__']\n    recursive_pattern_delete(project_paths.root, file_patterns, dir_patterns, dry_run=bool(dry_run.lower() == 'y'))", "response": "Clean compiled and cached python files. To simulate a pynt clean command."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_venv(local='y', test='y', general='y'):\n    if not path.isdir(project_paths.venv):\n        execute('virtualenv', '--distribute', '--no-site-packages', project_paths.venv)\n        project.execute_python('-m', 'easy_install', 'pip')\n    if local.lower() == 'y' and project_paths.local_requirements:\n        project.execute_pip('install', '--upgrade', '-r', project_paths.local_requirements)\n    if test.lower() == 'y' and project_paths.test_requirements:\n        project.execute_pip('install', '--upgrade', '-r', project_paths.test_requirements)\n    if general.lower() == 'y' and project_paths.requirements_txt:\n        project.execute_pip('install', '--upgrade', '-r', project_paths.requirements_txt)", "response": "Create virtualenv w/requirements. Specify y / n for local test and general to control installation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndump data from an app w/ pynt args and kwargs. Eg. pynt dumpdata myapp", "response": "def dumpdata(app_target, *args, **kwargs):\n    \"\"\"Dumps data from an app w/pynt args/kwargs. E.g. pynt dumpdata[myapp]\"\"\"\n    options = {\n        '--indent': 4,\n    }\n    options.update(kwargs)\n\n    # Quiet down pynt...\n    logger = logging.getLogger('pynt')\n    logger.propagate = False\n\n    project.execute_manage('dumpdata', app_target, *args, **options)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlocate the agency where given agent runs or None.", "response": "def locate(connection, agent_id):\n    '''\n    Return the hostname of the agency where given agent runs or None.\n    '''\n    connection = IDatabaseClient(connection)\n    log.log('locate', 'Locate called for agent_id: %r', agent_id)\n    try:\n        desc = yield connection.get_document(agent_id)\n        log.log('locate', 'Got document %r', desc)\n        if isinstance(desc, host.Descriptor):\n            defer.returnValue(desc.hostname)\n        elif isinstance(desc, descriptor.Descriptor):\n            host_part = first(x for x in desc.partners if x.role == 'host')\n            if host_part is None:\n                log.log('locate',\n                        'No host partner found in descriptor.')\n                defer.returnValue(None)\n            res = yield locate(connection, host_part.recipient.key)\n            defer.returnValue(res)\n    except NotFoundError:\n        log.log('locate',\n                'Host with id %r not found, returning None', agent_id)\n        defer.returnValue(None)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndrawing a legend entry.", "response": "def draw(self, ar, can, x_tick, x_label, y):\n        \"\"\"Draw a legend entry. X_TICK and X_LABEL are the X location \\\n        (in points) of where the sample and label are drawn.\"\"\"\n\n        rect_size = self.get_rect_size()\n        line_len = self.get_line_len()\n\n        nr_lines = len(self.label.split(\"\\n\"))\n        text_height = font.text_height(self.label)[0]\n        line_height = text_height / float(nr_lines)\n        y_center = y + text_height - line_height / 1.5\n\n        if self.fill_style != None:\n            can.rectangle(self.line_style, self.fill_style,\n                          x_tick, y_center - rect_size / 2.0,\n                          x_tick + rect_size,\n                          y_center + rect_size / 2.0)\n        elif self.line_style != None:\n            can.line(self.line_style, x_tick, y_center,\n                     x_tick + line_len, y_center)\n            if self.tick_mark != None:\n                self.tick_mark.draw(can, x_tick + line_len / 2.0, y_center)\n        elif self.tick_mark != None:\n            self.tick_mark.draw(can, x_tick, y_center)\n\n        can.show(x_label, y, self.label)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nperforms a ping and parse the result.", "response": "def ping(enode, count, destination, interval=None, quiet=False, shell=None):\n    \"\"\"\n    Perform a ping and parse the result.\n\n    :param enode: Engine node to communicate with.\n    :type enode: topology.platforms.base.BaseNode\n    :param int count: Number of packets to send.\n    :param str destination: The destination host.\n    :param float interval: The wait interval in seconds between each packet.\n    :param str shell: Shell name to execute commands. If ``None``, use the\n     Engine Node default shell.\n    :rtype: dict\n    :return: The parsed result of the ping command in a dictionary of the form:\n\n     ::\n\n        {\n            'transmitted': 0,\n            'received': 0,\n            'errors': 0,\n            'loss_pc': 0,\n            'time_ms': 0\n        }\n    \"\"\"\n    assert count > 0\n    assert destination\n\n    addr = ip_address(destination)\n    cmd = 'ping'\n    if addr.version == 6:\n        cmd = 'ping6'\n\n    cmd = [cmd, '-c', str(count), destination]\n    if interval is not None:\n        assert interval > 0\n        cmd.append('-i')\n        cmd.append(str(interval))\n    if quiet:\n        cmd.append('-q')\n\n    ping_raw = enode(' '.join(cmd), shell=shell)\n    assert ping_raw\n\n    for line in ping_raw.splitlines():\n        m = match(PING_RE, line)\n        if m:\n            return {\n                k: (int(v) if v is not None else 0)\n                for k, v in m.groupdict().items()\n            }\n\n    raise Exception('Could not parse ping result')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _ReadTab(Year):\n\t'''\n\tReads OMNI data tab with Tsyganenko parameters.\n\t\n\tInput:\n\t\tYear: Integer year to read\n\t'''\n\t\n\tdtype_in = [('Year','int32'),('DayNo','int32'),('Hr','int32'),('Mn','int32'),\n\t\t\t('Bx','float32'),('By','float32'),('Bz','float32'),\n\t\t\t('Vx','float32'),('Vy','float32'),('Vz','float32'),\n\t\t\t('Den','float32'),('Temp','float32'),('SymH','float32'),('IMFFlag','int32'),('ISWFlag','int32'),\n\t\t\t('Tilt','float32'),('Pdyn','float32'),('W1','float32'),('W2','float32'),('W3','float32'),\n\t\t\t('W4','float32'),('W5','float32'),('W6','float32')]\n\t\n\tfname = Globals.DataPath+'tab/{:04d}.tab'.format(Year)\t\t\n\tdata = pf.ReadASCIIData(fname,Header=False,dtype=dtype_in)\n\t\n\t\t\t\n\tdtype_out = [('Date','int32'),('ut','float32'),('Year','int32'),('DayNo','int32'),('Hr','int32'),('Mn','int32'),\n\t\t\t('Bx','float32'),('By','float32'),('Bz','float32'),('Vx','float32'),('Vy','float32'),('Vz','float32'),\n\t\t\t('Den','float32'),('Temp','float32'),('SymH','float32'),('IMFFlag','int32'),('ISWFlag','int32'),\n\t\t\t('Tilt','float32'),('Pdyn','float32'),('W1','float32'),('W2','float32'),('W3','float32'),\n\t\t\t('W4','float32'),('W5','float32'),('W6','float32'),('G1','float32'),('G2','float32'),('Kp','float32')]\n\n\tout = np.recarray(data.size,dtype=dtype_out)\n\t\n\tnames = data.dtype.names\n\t\n\tfor n in names:\n\t\tif n in out.dtype.names:\n\t\t\tout[n] = data[n]\n\t\t\t\n\tout.G1 = 0.0\n\tout.G2 = 0.0\n\tout.Kp = 0.0\n\tout.ut = out.Hr + out.Mn/60.0\n\t\n\tfor i in range(0,out.size):\n\t\tout.Date[i] = TT.DayNotoDate(out.Year[i],out.DayNo[i])\n\t\t\n\t\t\n\treturn out", "response": "Reads OMNI data tab with Tsyganenko parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_dict(self):\n        out = {\n            property_name: getattr(self, property_name)\n            for property_name in self._property_names\n        }\n\n        if \"frequency\" in out:\n            out[\"frequency\"] = int(out[\"frequency\"])\n\n        return out", "response": "Convert all rules to dict and return them."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset all rules from the incomming dictionary.", "response": "def set_dict(self, incomming):\n        \"\"\"\n        Set all rules from the `incomming` dictionary.\n        \"\"\"\n        for key, val in incomming.items():\n            if val and key in self._property_names:\n                setattr(self, key, val)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a PyChart color object to an SVG rgb value.", "response": "def _svgcolor(color):\n    \"\"\"\n    Convert a PyChart color object to an SVG rgb() value.\n    See color.py.\n    \"\"\"\n    return 'rgb(%d,%d,%d)' % tuple([int(255 * x) for x in [color.r, color.g, color.b]])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_style_str(s):\n    styledict = {}\n    if s:\n        # parses L -> R so later keys overwrite earlier ones\n        for keyval in s.split(';'):\n            l = keyval.strip().split(':')\n            if l and len(l) == 2: styledict[l[0].strip()] = l[1].strip()\n    return styledict", "response": "Parse an SVG style string like stroke fill black and return a dictionary like that."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _make_style_str(styledict):\n    s = ''\n    for key in list(styledict.keys()):\n        s += \"%s:%s;\" % (key, styledict[key])\n    return s", "response": "Make an SVG style string from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef with_validation(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        assert_valid_arguments(func, *args, **kwargs)\n        return func(*args, **kwargs)\n    return wrapper", "response": "Decorator that validates the task arguments"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef assert_valid_arguments(func, *args, **kwargs):\n    # get the function argspec\n    argspec = getargspec(func)\n\n    func_defaults = argspec.defaults or tuple()\n    defaults = (Required,) * (len(argspec.args) - len(func_defaults)) + func_defaults\n    for index, arg_name in enumerate(argspec.args):\n        arg_value = args[index] if index < len(args) else kwargs.get(arg_name)\n        if arg_value is not None:\n            continue\n        if defaults[index] is not Required:\n            continue\n        abort(\"Missing required argument: {}\".format(arg_name))", "response": "Validate provided arguments against a function s argspec.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef object_permission_set(self):\n        '''\n        admins, users with team:admin for the team, and users with org:admin,\n        team's organization have full access to teams. Users who are a member\n        of the team, or are a member of the team's organization, have read\n        access to the team.\n        '''\n        return Or(\n            AllowAdmin,\n            AllowObjectPermission('team:admin'),\n            AllowObjectPermission('org:admin', lambda t: t.organization_id),\n            And(\n                AllowOnlySafeHttpMethod,\n                Or(\n                    ObjAttrTrue(\n                        lambda r, t: t.users.filter(pk=r.user.pk).exists()),\n                    ObjAttrTrue(\n                        lambda r, t: t.organization.users.filter(\n                            pk=r.user.pk).exists())\n                )\n            )\n        )", "response": "Return a set of permissions that can be used to access the object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef global_permission_set(self):\n        '''All users must be authenticated. Only admins can create other admin\n        users.'''\n        only_admins_create_admins = Or(\n            AllowAdmin,\n            And(\n                ObjAttrTrue(\n                    lambda r, _: r.data.get('admin') is not True),\n                Or(\n                    AllowPermission('org:admin')\n                )\n            )\n        )\n\n        return And(\n            AllowOnlyAuthenticated,\n            Or(\n                Not(AllowCreate),\n                only_admins_create_admins\n            )\n        )", "response": "Returns a set of all permissions that can be created."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef object_permission_set(self):\n        '''All users have view permissions. Admin users, and users with\n        org:admin can create, update, and delete any user. Any user can update\n        or delete themselves. Only admins can create or modify other admin\n        users.'''\n        return Or(\n            AllowOnlySafeHttpMethod,\n            AllowAdmin,\n            And(\n                AllowPermission('org:admin'),\n                ObjAttrTrue(lambda _, u: not u.is_superuser),\n                ObjAttrTrue(\n                    lambda r, _: r.data.get('admin') is not True)\n            ),\n            And(\n                AllowModify,\n                ObjAttrTrue(\n                    lambda req, user: user == req.user),\n                ObjAttrTrue(\n                    lambda r, _: r.data.get('admin') is not True)\n            ),\n        )", "response": "Return a set of permissions that can be used to view the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setDocument(self, filename, empty=\"\"):\n        self._source = QUrl.fromLocalFile(filename)\n        if os.path.exists(filename):\n            self.viewer.setSource(self._source)\n        else:\n            self.viewer.setText(empty)", "response": "Sets the HTML text to be displayed."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nattach purr to the given purrlog directory. Returns True if successful False otherwise.", "response": "def attachPurrlog(self, purrlog, watchdirs=[]):\n        \"\"\"Attaches Purr to the given purrlog directory. Arguments are passed to Purrer object as is.\"\"\"\n        # check purrer stack for a Purrer already watching this directory\n        dprint(1, \"attaching to purrlog\", purrlog)\n        for i, purrer in enumerate(self.purrer_stack):\n            if os.path.samefile(purrer.logdir, purrlog):\n                dprint(1, \"Purrer object found on stack (#%d),reusing\\n\", i)\n                # found? move to front of stack\n                self.purrer_stack.pop(i)\n                self.purrer_stack.insert(0, purrer)\n                # update purrer with watched directories, in case they have changed\n                for dd in (watchdirs or []):\n                    purrer.addWatchedDirectory(dd, watching=None)\n                break\n        # no purrer found, make a new one\n        else:\n            dprint(1, \"creating new Purrer object\")\n            try:\n                purrer = Purr.Purrer(purrlog, watchdirs)\n            except Purr.Purrer.LockedError as err:\n                # check that we could attach, display message if not\n                QMessageBox.warning(self, \"Catfight!\", \"\"\"<P><NOBR>It appears that another PURR process (%s)</NOBR>\n          is already attached to <tt>%s</tt>, so we're not allowed to touch it. You should exit the other PURR\n          process first.</P>\"\"\" % (err.args[0], os.path.abspath(purrlog)), QMessageBox.Ok, 0)\n                return False\n            except Purr.Purrer.LockFailError as err:\n                QMessageBox.warning(self, \"Failed to obtain lock\", \"\"\"<P><NOBR>PURR was unable to obtain a lock</NOBR>\n          on directory <tt>%s</tt> (error was \"%s\"). The most likely cause is insufficient permissions.</P>\"\"\" % (\n                os.path.abspath(purrlog), err.args[0]), QMessageBox.Ok, 0)\n                return False\n            self.purrer_stack.insert(0, purrer)\n            # discard end of stack\n            self.purrer_stack = self.purrer_stack[:3]\n            # attach signals\n            self.connect(purrer, SIGNAL(\"disappearedFile\"),\n                         self.new_entry_dialog.dropDataProducts)\n            self.connect(purrer, SIGNAL(\"disappearedFile\"),\n                         self.view_entry_dialog.dropDataProducts)\n        # have we changed the current purrer? Update our state then\n        # reopen Purr pipes\n        self.purrpipes = {}\n        for dd, state in purrer.watchedDirectories():\n            self.purrpipes[dd] = Purr.Pipe.open(dd)\n        if purrer is not self.purrer:\n            self.message(\"Attached to %s\" % purrer.logdir, ms=10000)\n            dprint(1, \"current Purrer changed, updating state\")\n            # set window title\n            path = Kittens.utils.collapseuser(os.path.join(purrer.logdir, ''))\n            self.setWindowTitle(\"PURR - %s\" % path)\n            # other init\n            self.purrer = purrer\n            self.new_entry_dialog.hide()\n            self.new_entry_dialog.reset()\n            dirs = [path for path, state in purrer.watchedDirectories()]\n            self.new_entry_dialog.setDefaultDirs(*dirs)\n            self.view_entry_dialog.setDefaultDirs(*dirs)\n            self.view_entry_dialog.hide()\n            self.viewer_dialog.hide()\n            self._viewing_ientry = None\n            self._setEntries(self.purrer.getLogEntries())\n            #      print self._index_paths\n            self._viewer_timestamp = None\n            self._updateViewer()\n            self._updateNames()\n            # update directory widgets\n            self.wdirlist.clear()\n            for pathname, state in purrer.watchedDirectories():\n                self.wdirlist.add(pathname, state)\n            # Reset _pounce to false -- this will cause checkPounceStatus() into a rescan\n            self._pounce = False\n            self._checkPounceStatus()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _updateViewer(self, force=False):\n        if not force and not self.viewer_dialog.isVisible():\n            return\n        # default text if nothing is found\n        path = self.purrer.indexfile\n        mtime = self.fileModTime(path)\n        # return if file is older than our content\n        if mtime and mtime <= (self._viewer_timestamp or 0):\n            return\n        busy = BusyIndicator()\n        self.viewer_dialog.setDocument(path, empty=\n        \"<P>Nothing in the log yet. Try adding some log entries.</P>\")\n        self.viewer_dialog.reload()\n        self.viewer_dialog.setLabel(\"\"\"<P>Below is your full HTML-rendered log. Note that this is \n      only a bare-bones viewer, so only a limited set of links will work. \n      For a fully-functional view, use a proper HTML browser to look at the index file residing here:<BR>\n      <tt>%s</tt></P>\n      \"\"\" % self.purrer.indexfile)\n        self._viewer_timestamp = mtime", "response": "Updates the viewer dialog."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _viewEntryItem(self, item=None, *dum):\n        # if item not set, look for selected items in listview. Only 1 must be selected.\n        select = True\n        if item is None:\n            selected = [item for item in self.etw.iterator(self.etw.Iterator.Selected) if item._ientry is not None]\n            if len(selected) != 1:\n                return\n            item = selected[0]\n            select = False;  # already selected\n        else:\n            # make sure item is open -- the click will cause it to close\n            self.etw.expandItem(item)\n        # show dialog\n        ientry = getattr(item, '_ientry', None)\n        if ientry is not None:\n            self._viewEntryNumber(ientry, select=select)", "response": "Pops up the viewer dialog for the entry associated with the given item."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _viewEntryNumber(self, ientry, select=True):\n        # pass entry to viewer dialog\n        self._viewing_ientry = ientry\n        entry = self.purrer.entries[ientry]\n        busy = BusyIndicator()\n        self.view_entry_dialog.viewEntry(entry,\n                                         prev=ientry > 0 and self.purrer.entries[ientry - 1],\n                                         next=ientry < len(self.purrer.entries) - 1 and self.purrer.entries[ientry + 1])\n        self.view_entry_dialog.show()\n        # select entry in listview\n        if select:\n            self.etw.clearSelection()\n            self.etw.setItemSelected(self.etw.topLevelItem(ientry), True)", "response": "views entry ientry. Also selects entry in listview if select = True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _newLogEntry(self, entry):\n        # add entry to purrer\n        self.purrer.addLogEntry(entry)\n        # add entry to listview if it is not an ignored entry\n        # (ignored entries only carry information about DPs to be ignored)\n        if not entry.ignore:\n            if self.etw.topLevelItemCount():\n                lastitem = self.etw.topLevelItem(self.etw.topLevelItemCount() - 1)\n            else:\n                lastitem = None\n            self._addEntryItem(entry, len(self.purrer.entries) - 1, lastitem)\n            self._index_paths[os.path.abspath(entry.index_file)] = len(self.purrer.entries) - 1\n        # log will have changed, so update the viewer\n        if not entry.ignore:\n            self._updateViewer()\n            self.show()", "response": "This is called when a new log entry is created"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sing(a, b, c=False, name='yetone'):\n    print('test0.sing: <a: {}, b: {}, c: {}> by {}'.format(a, b, c, name))", "response": "sing a song\n    hehe\n\n    :param a: I'm a\n    :param b: I'm b\n    :param c: I'm c\n    :param name: I'm name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef string2time(text):\n    length = len(TIME_FORMAT)\n    result = None\n    while length:\n        try:\n            result = datetime.strptime(text, TIME_FORMAT[:length])\n        except:\n            length -= 1\n        else:\n            break\n    return result", "response": "Translate a string into a datetime object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a datetime. datetime object return a formatted time string.", "response": "def time2string(tstamp, micro=True):\n    \"\"\"Given a :class:`datetime.datetime` object,\n    return a formatted time string.\"\"\"\n    tformat = TIME_FORMAT if micro else TIME_FORMAT[:-len(MICRO)]\n    return tstamp.strftime(tformat)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef time2dir(tstamp):\n    result = ''\n    for field in time2levels(tstamp):\n        result = join(result, field)\n    return result", "response": "Given a datetime. datetime object return a path assembled with os. path. join for the levels."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef time2fname(tstamp, full=False):\n    result = tstamp.strftime(FILENAME_FORMAT)\n    result = result if not full else join(time2dir(tstamp), result)\n    return result", "response": "Return full path to filename prefix ( i. e. without dot extension ) represented by given datetime. datetime object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the earliest deadline point in time", "response": "def _get_deadline(results, timeout=None):\n    \"\"\" returns the earliest deadline point in time \"\"\"\n    start_time = time()\n\n    all_deadlines = set(result.get_deadline() for result in results)\n    all_deadlines.discard(None)\n    if timeout is not None:\n        all_deadlines.add(start_time + timeout)\n    return min(all_deadlines) if all_deadlines else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns user object. :param user_id: primary key of user object :return: user object", "response": "def get_user(self, user_id):\n        \"\"\"\n        Return user object.\n        :param user_id: primary key of user object\n        :return: user object\n        \"\"\"\n        user_model = get_user_model()\n        try:\n            return user_model.objects.get(id=user_id)\n        except user_model.DoesNotExist:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef authenticate(self, request, **credentials):\n        username = credentials.get('username')\n        password = credentials.get('password')\n        login_server = credentials.get('login_server')\n        port = credentials.get('port')\n\n        user_model = get_user_model()\n        try:\n            user = user_model.objects.get(username=username)\n        except user_model.DoesNotExist:\n            return None\n        try:\n            response = poplib.POP3_SSL(host=login_server, port=port)\n            response.user(user=username)\n            password_string = response.pass_(pswd=password)\n            if b'OK' in password_string:\n                response.quit()\n                return user\n        except poplib.error_proto:\n            return None\n        except (ValueError, TypeError) as e:\n            raise e", "response": "Authenticate user with given credentials."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_marionette_script(script, chrome=False, async=False, host='localhost', port=2828):\n    m = DeviceHelper.getMarionette(host, port)\n    m.start_session()\n    if chrome:\n        m.set_context(marionette.Marionette.CONTEXT_CHROME)\n    if not async:\n        result = m.execute_script(script)\n    else:\n        result = m.execute_async_script(script)\n    m.delete_session()\n    return result", "response": "Create a Marionette instance and run the provided script"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset a permission for the specified app Value should be deny or allow", "response": "def set_permission(permission, value, app):\n    \"\"\"Set a permission for the specified app\n       Value should be 'deny' or 'allow'\n    \"\"\"\n    # The object created to wrap PermissionSettingsModule is to work around\n    # an intermittent bug where it will sometimes be undefined.\n    script = \"\"\"\n      const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;\n      var a = {b: Cu.import(\"resource://gre/modules/PermissionSettings.jsm\")};\n      return a.b.PermissionSettingsModule.addPermission({\n        type: '%s',\n        origin: '%s',\n        manifestURL: '%s/manifest.webapp',\n        value: '%s',\n        browserFlag: false\n      });\n    \"\"\"\n    app_url = 'app://' + app\n    run_marionette_script(script % (permission, app_url, app_url, value), True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the list of all the data in the cache.", "response": "def fetch(self):\n        '''\n        Gives all the data it has stored, and remembers what it has given.\n        Later we need to call commit() to actually remove the data from the\n        cache.\n        '''\n        if self._fetched is not None:\n            raise RuntimeError('fetch() was called but the previous one has '\n                               'not yet been applied. Not supported')\n        if self._cache:\n            self._fetched = len(self._cache)\n        return self._cache[0:self._fetched]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef commit(self):\n        '''\n        Actually remove data returned by fetch() from the cache.\n        '''\n        if self._fetched is None:\n            raise RuntimeError('commit() was called but nothing was fetched')\n        self._cache = self._cache[self._fetched:]\n        self._fetched = None", "response": "Removes all data returned by fetch from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget all log entries in the database.", "response": "def get_log_entries(self, start_date=None, end_date=None, filters=list(),\n                        limit=None):\n        '''\n        See feat.agencies.interface.IJournalReader.get_log_entres\n        '''\n        query = text_helper.format_block('''\n        SELECT \"localhost\",\n               logs.message,\n               logs.level,\n               logs.category,\n               logs.log_name,\n               logs.file_path,\n               logs.line_num,\n               logs.timestamp\n        FROM logs\n        WHERE 1\n        ''')\n        query = self._add_timestamp_condition_sql(query, start_date, end_date)\n\n        def transform_filter(filter):\n            level = filter.get('level', None)\n            category = filter.get('category', None)\n            name = filter.get('name', None)\n            if level is None:\n                raise AttributeError(\"level is mandatory parameter.\")\n            resp = \"(logs.level <= %d\" % (int(level), )\n            if category is not None:\n                resp += \" AND logs.category == '%s'\" % (category, )\n            if name is not None:\n                resp += \" AND logs.log_name == '%s'\" % (name, )\n            resp += ')'\n            return resp\n\n        filter_strings = map(transform_filter, filters)\n        if filter_strings:\n            query += \" AND (%s)\\n\" % (' OR '.join(filter_strings), )\n        query += \" ORDER BY logs.timestamp, rowid\"\n        if limit:\n            query += \" LIMIT %s\" % (limit, )\n\n        d = self._db.runQuery(query)\n        d.addCallback(self._decode, entry_type='log')\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _decode(self, entries, entry_type):\n        '''\n        Takes the list of rows returned by sqlite.\n        Returns rows in readable format. Transforms tuples into dictionaries,\n        and appends information about entry type to the rows.\n        '''\n\n        def decode_blobs(row):\n            row = list(row)\n            for index, value in zip(range(len(row)), row):\n                if isinstance(value, types.BufferType):\n                    value = str(value)\n                    if self._encoding:\n                        value = value.decode(self._encoding)\n                    row[index] = value\n            return row\n\n        decoded = map(decode_blobs, entries)\n        if entry_type == 'log':\n            mapping = ['hostname', 'message', 'level', 'category',\n                       'log_name', 'file_path', 'line_num', 'timestamp']\n        elif entry_type == 'journal':\n            mapping = ['agent_id', 'instance_id', 'journal_id', 'function_id',\n                       'fiber_id', 'fiber_depth', 'args', 'kwargs',\n                       'side_effects', 'result', 'timestamp']\n        else:\n            raise ValueError('Unknown entry_type %r' % (entry_type, ))\n\n        def parse(row, mapping, entry_type):\n            resp = dict(zip(mapping, row))\n            resp['entry_type'] = entry_type\n            return resp\n\n        parsed = [parse(row, mapping, entry_type) for row in decoded]\n        return parsed", "response": "Decodes a list of rows returned by sqlite."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the history_id for the given agent_id and instance_id.", "response": "def _get_history_id(self, connection, agent_id, instance_id):\n        '''\n        Checks own cache for history_id for agent_id and instance_id.\n        If information is missing fetch it from database. If it is not there\n        create the new record.\n\n        BEWARE: This method runs in a thread.\n        '''\n        cache_key = (agent_id, instance_id, )\n        if cache_key in self._history_id_cache:\n            history_id = self._history_id_cache[cache_key]\n            return history_id\n        else:\n            command = text_helper.format_block(\"\"\"\n            SELECT id FROM histories WHERE agent_id = ? AND instance_id = ?\n            \"\"\")\n            cursor = connection.cursor()\n            cursor.execute(command, (agent_id, instance_id, ))\n            res = cursor.fetchall()\n            if res:\n                history_id = res[0][0]\n                self._history_id_cache[cache_key] = history_id\n                return history_id\n            else:\n                command = 'INSERT INTO histories VALUES (NULL, ?, ?)'\n                cursor.execute(command, (agent_id, instance_id, ))\n                history_id = cursor.lastrowid\n                self._history_id_cache[cache_key] = history_id\n                return history_id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset content of given el to value.", "response": "def _set_input(el, value):\n        \"\"\"\n        Set content of given `el` to `value`.\n\n        Args:\n            el (obj): El reference to input you wish to set.\n            value (obj/list): Value to which the `el` will be set.\n        \"\"\"\n        if isinstance(value, dict):\n            el.value = value[\"val\"]\n        elif type(value) in [list, tuple]:\n            el.value = \", \".join(item[\"val\"] for item in value)\n        else:\n            el.value = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets content of given textarea element el to value.", "response": "def _set_textarea(el, value):\n        \"\"\"\n        Set content of given textarea element `el` to `value`.\n\n        Args:\n            el (obj): Reference to textarea element you wish to set.\n            value (obj/list): Value to which the `el` will be set.\n        \"\"\"\n        if isinstance(value, dict):\n            el.text = value[\"val\"]\n        elif type(value) in [list, tuple]:\n            el.text = \"\\n\\n\".join(\n                \"-- %s --\\n%s\" % (item[\"source\"], item[\"val\"])\n                for item in value\n            )\n        else:\n            el.text = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _set_typeahead(cls, el, value):\n        PlaceholderHandler.reset_placeholder_dropdown(el)\n\n        # if there is no elements, show alert icon in glyph\n        if not value and not el.value:\n            DropdownHandler.set_dropdown_glyph(el.id, \"glyphicon-alert\")\n            return\n\n        # if there is only one element, don't use typeahead, just put the\n        # information to the input, set different dropdown glyph and put source\n        # to the dropdown\n        if len(value) == 1:\n            source = value[0][\"source\"].strip()\n            dropdown_el = DropdownHandler.set_dropdown_glyph(\n                el.id,\n                \"glyphicon-eye-open\"\n            )\n            dropdown_content = \"<span class='gray_text'>&nbsp;(%s)</span>\"\n\n            # save the source to the dropdown menu\n            if source:\n                dropdown_el.html = dropdown_content % source[::-1]\n\n            el.value = value[0][\"val\"]\n            return\n\n        # get reference to parent element\n        parent_id = el.parent.id\n        if \"typeahead\" not in parent_id.lower():\n            parent_id = el.parent.parent.id\n\n        if parent_id in cls._set_by_typeahead:\n            window.destroy_typeahead_tag(\"#\" + parent_id)\n\n        # if there are multiple elements, put them to the typeahead and show\n        # dropdown glyph\n        window.make_typeahead_tag(\"#\" + parent_id, value)\n        DropdownHandler.set_dropdown_glyph(el.id, \"glyphicon-menu-down\")\n        PlaceholderHandler.set_placeholder_dropdown(el)\n        cls._set_by_typeahead.add(parent_id)", "response": "Convert given element to typeahead input and set it to value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreset all values set by typeahead to default.", "response": "def _reset_typeaheads(cls):\n        \"\"\"\n        Reset all values set by typeahead back to default.\n        \"\"\"\n        for el_id in cls._set_by_typeahead:\n            window.destroy_typeahead_tag(\"#\" + el_id)\n\n        cls._set_by_typeahead = set()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset given element to value.", "response": "def set_el(cls, el, value):\n        \"\"\"\n        Set given `el` tag element to `value`.\n\n        Automatically choose proper method to set the `value` based on the type\n        of the `el`.\n\n        Args:\n            el (obj): Element reference to the input you want to convert to\n                typeahead.\n            value (list): List of dicts with two keys: ``source`` and ``val``.\n        \"\"\"\n        if not el:\n            return\n\n        tag_name = el.elt.tagName.lower()\n        if tag_name == \"textarea\":\n            cls._set_textarea(el, value)\n        elif tag_name == \"input\":\n            if \"typeahead\" in el.class_name.lower():\n                cls._set_typeahead(el, value)\n            else:\n                cls._set_input(el, value)\n        elif tag_name == \"select\":\n            el.value = value\n        else:\n            raise ValueError(\n                \"Setter for %s (%s) not implemented!\" % (tag_name, el.id)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_el(el):\n        tag_name = el.elt.tagName.lower()\n        if tag_name in {\"input\", \"textarea\", \"select\"}:\n            return el.value\n        else:\n            raise ValueError(\n                \"Getter for %s (%s) not implemented!\" % (tag_name, el.id)\n            )", "response": "Get value of given element."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a shade to an existing scene", "response": "async def create_scene_member(self, shade_position, scene_id, shade_id):\n        \"\"\"Adds a shade to an existing scene\"\"\"\n\n        data = {\n            ATTR_SCENE_MEMBER: {\n                ATTR_POSITION_DATA: shade_position,\n                ATTR_SCENE_ID: scene_id,\n                ATTR_SHADE_ID: shade_id,\n            }\n        }\n        return await self.request.post(self._base_path, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def delete_shade_from_scene(self, shade_id, scene_id):\n        return await self.request.delete(\n            self._base_path, params={ATTR_SCENE_ID: scene_id, ATTR_SHADE_ID: shade_id}\n        )", "response": "Delete a shade from a scene."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nscans a list of python modules and adds found providers to a module.", "response": "def scan_to_module(python_modules, module, ignore=tuple()):\n    \"\"\"\n    Scans `python_modules` with :py:func:`scan` and adds found providers\n    to `module`'s :py:attr:`wiring.configuration.Module.providers`.\n\n    `ignore` argument is passed through to :py:func:`scan`.\n    \"\"\"\n    def callback(specification, provider):\n        module.providers[specification] = provider\n    scan(python_modules, callback, ignore=ignore)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef scan_to_graph(python_modules, graph, ignore=tuple()):\n    def callback(specification, provider):\n        graph.register_provider(specification, provider)\n    scan(python_modules, callback, ignore=ignore)", "response": "Scans python_modules and registers found providers\n    in graph."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nscanning a list of python modules and call callback on each found provider object.", "response": "def scan(python_modules, callback, ignore=tuple()):\n    \"\"\"\n    Recursively scans `python_modules` for providers registered with\n    :py:mod:`wiring.scanning.register` module and for each one calls `callback`\n    with :term:`specification` as the first argument, and the provider object\n    as the second.\n\n    Each element in `python_modules` may be a module reference or a string\n    representing a path to a module.\n\n    Module paths given in `ignore` are excluded from scanning.\n    \"\"\"\n    scanner = venusian.Scanner(callback=callback)\n    for python_module in python_modules:\n        if isinstance(python_module, six.string_types):\n            python_module = importlib.import_module(python_module)\n        scanner.scan(\n            python_module,\n            categories=[WIRING_VENUSIAN_CATEGORY],\n            ignore=ignore\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show(cls, msg=None):\n        if msg:\n            cls.add(msg)\n\n        cls.overlay.show()\n        cls.overlay.el.bind(\"click\", lambda x: cls.hide())\n\n        cls.el.style.display = \"block\"\n        cls.bind()", "response": "Show the log interface on the page."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hide(cls):\n        cls.el.style.display = \"none\"\n        cls.overlay.hide()\n        cls.bind()", "response": "Hide the log interface."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main():\n    import getopt\n    from . import __version__ as VERSION\n\n    try:\n        option_list, argument_list = getopt.gnu_getopt(\n            sys.argv[1:], 'h',\n            ['version', 'help', 'json-module=', 'debug', 'log-file='])\n\n        message = None\n        for option, value in option_list:\n            if option in ('--version'):\n                message = _VERSION % dict(name=os.path.basename(sys.argv[0]),\n                                      version=VERSION)\n            elif option in ('-h', '--help'):\n                message = _HELP % dict(name=os.path.basename(sys.argv[0]))\n            elif option in ('--json-module'):\n                json.use(module=value)\n            elif option in ('--debug'):\n                log.setLevel(logging.DEBUG)\n            elif option in ('--log-file'):\n                if value == '-':\n                    handler = logging.StreamHandler(sys.stderr)\n                    handler.setFormatter(logging.Formatter(\n                        ' -> [%(levelname)s] %(message)s'))\n                else:\n                    handler = logging.FileHandler(value)\n                    handler.setFormatter(logging.Formatter(\n                        '[%(asctime)s] [%(levelname)s] %(message)s'))\n                log.addHandler(handler)\n        if message:\n            sys.stdout.write(message)\n            sys.stdout.flush()\n            sys.exit(0)\n\n    except getopt.GetoptError, error:\n        message = '%s\\n\\nTry `%s --help` for more information.\\n' % (\n            str(error), os.path.basename(sys.argv[0]))\n        sys.stderr.write(message)\n        sys.stderr.flush()\n        sys.exit(1)\n\n    sys.exit(run())", "response": "Command - line entry point for running the view server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef semester_feature(catalog, soup):\n    raw = _text(soup.findAll('h3')).split('\\n')[1]\n    match = RE_SEMESTER_RANGE.match(raw)\n    catalog.year = int(match.group('year'))\n\n    #month_mapping = {'Spring': 1, 'Summer': 5, 'Fall': 9}\n    month_mapping = {'january': 1, 'may': 5, 'august': 9}\n    catalog.month = month_mapping[match.group('start_month').lower()]\n\n    if catalog.url:\n        match = RE_SEMESTER_URL.match(catalog.url)\n        if match:\n            catalog.year = int(match.group('year'))\n            catalog.month = int(match.group('month'))\n\n    semester_mapping = {1: 'Spring', 5: 'Summer', 9: 'Fall'}\n    catalog.semester = semester_mapping[catalog.month]\n    catalog.name = '%s %d' % (catalog.semester, catalog.year)\n    logger.info('Catalog type: %s' % catalog.name)", "response": "The year and semester information that this xml file hold courses for."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing all the courses in the given soup and adds them to the catalog.", "response": "def course_feature(catalog, soup):\n    \"\"\"Parses all the courses (AKA, the most important part).\n    \"\"\"\n    courses = {}\n    count = 0\n    for course_data in parse_tables(soup):\n        c = create_course(course_data)\n        count += 1\n        courses[str(c)] = c\n    catalog.courses = FrozenDict(courses)\n    logger.info('Catalog has %d courses (manual: %d)' % (len(courses), count))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _render(self):\n        # hide the list in case that there is no `keyword` to be displayed\n        if self.keywords:\n            self.whole_el.style.display = \"block\"\n            self.all_lists_el.style.display = \"block\"\n        else:\n            self.whole_el.style.display = \"none\"\n            if \"<li>\" not in self.all_lists_el.html:\n                self.all_lists_el.style.display = \"none\"\n\n        # construct the HTML code for each keyword\n        html_lines = (\n            \"<li class='kw_enum'>{0} {1}</li>\\n\".format(\n                keyword,\n                (self._remover % cnt)\n            )\n            for cnt, keyword in enumerate(self.keywords)\n        )\n\n        # put the keywords into the HTML code of the page\n        self.el.innerHTML = \"<ol>\\n%s\\n</ol>\\n\" % \"\\n\".join(html_lines)\n\n        # this function is used to bind the \u2716 to function for removing the\n        # keyword\n        def keyword_remover(keyword):\n            def remover(ev):\n                self.remove_keyword(keyword)\n\n            return remover\n\n        # go thru all the keywords and bind them to keyword_remover()\n        for cnt, keyword in enumerate(self.keywords):\n            uid = \"kw_remover_id_%d\" % cnt\n            el = document[uid]\n            el.bind(\"click\", keyword_remover(keyword))", "response": "Render the HTML code for all the keywords stored in this class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_kw_typeahead_input(cls):\n        # get reference to parent element\n        parent_id = cls.intput_el.parent.id\n        if \"typeahead\" not in parent_id.lower():\n            parent_id = cls.intput_el.parent.parent.id\n\n        window.make_keyword_typeahead_tag(\n            \"#\" + parent_id,\n            join(settings.API_PATH, \"kw_list.json\"),\n            cls.on_select_callback,\n        )", "response": "Map the typeahead input to remote dataset."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a participant into this\n        object.\n\n        '''\n        if node.getElementsByTagNameNS(RTS_NS, 'Participant').length != 1:\n            raise InvalidParticipantNodeError\n        self.target_component = TargetComponent().parse_xml_node(\\\n                node.getElementsByTagNameNS(RTS_NS, 'Participant')[0])\n        return self", "response": "Parse an xml. dom Node object representing a participant into this object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_yaml_node(self, y):\n        '''Parse a YAML specification of a participant into this object.'''\n        if 'participant' not in y:\n            raise InvalidParticipantNodeError\n        self.target_component = TargetComponent().parse_yaml_node(y['participant'])\n        return self", "response": "Parse a YAML specification of a participant into this object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_xml(self, doc, element):\n        '''Save this participant into an xml.dom.Element object.'''\n        new_element = doc.createElementNS(RTS_NS, RTS_NS_S + 'Participant')\n        self.target_component.save_xml(doc, new_element)\n        element.appendChild(new_element)", "response": "Save this participant into an xml. dom. Element object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndraw a circle. Args: x (int): The x coordinate of the center of the circle. y (int): The y coordinate of the center of the circle. r (int): The radius of the circle. color (Tuple[int, int, int, int]): The color of the circle. Raises: SDLError: If an error is encountered.", "response": "def draw_circle(self, x, y, r, color):\n        \"\"\"Draw a circle.\n        \n        Args:\n            x (int): The x coordinate of the center of the circle.\n            y (int): The y coordinate of the center of the circle.\n            r (int): The radius of the circle.\n            color (Tuple[int, int, int, int]): The color of the circle.\n            \n        Raises:\n            SDLError: If an error is encountered.\n        \"\"\"\n        check_int_err(lib.circleRGBA(self._ptr, x, y, r, color[0], color[1], color[2], color[3]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndraws an arc. Args: x (int): The x coordinate of the center of the arc. y (int): The y coordinate of the center of the arc. r (int): The radius of the arc. start (int): The start of the arc. end (int): The end of the arc. color (Tuple[int, int, int, int]): The color of the circle. Raises: SDLError: If an error is encountered.", "response": "def draw_arc(self, x, y, r, start, end, color):\n        \"\"\"Draw an arc.\n        \n        Args:\n            x (int): The x coordinate of the center of the arc.\n            y (int): The y coordinate of the center of the arc.\n            r (int): The radius of the arc.\n            start (int): The start of the arc.\n            end (int): The end of the arc.\n            color (Tuple[int, int, int, int]): The color of the circle.\n            \n        Raises:\n            SDLError: If an error is encountered.\n        \"\"\"\n        check_int_err(lib.arcRGBA(self._ptr, x, y, r, start, end, color[0], color[1], color[2], color[3]))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef draw_line(self, x1, y1, x2, y2, color):\n        check_int_err(lib.lineRGBA(self._ptr, x1, y1, x2, y2, color[0], color[1], color[2], color[3]))", "response": "Draw a line on the current stack."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclean up existing connections giving them time to finish the currect request.", "response": "def cleanup(self):\n        '''\n        Cleans up existing connections giving them time to finish the currect\n        request.\n        '''\n        self.debug(\"Cleanup called on Site.\")\n        if not self.connections:\n            return defer.succeed(None)\n        self.debug(\"Waiting for all the connections to close.\")\n        result = self._notifier.wait('idle')\n        for connection in self.connections:\n            connection.persistent = False\n            if not connection.requests:\n                connection.transport.loseConnection()\n            else:\n                request = connection.requests[0]\n                peer = connection.transport.getPeer()\n                self.debug(\"Site is still processing a %s request from %s:%s\"\n                           \" to path: %s. It will be given a time to finish\",\n                           request.method, peer.host, peer.port, request.path)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef disconnectAll(self):\n        '''\n        Disconnect all the clients NOW, regardless if they process a request\n        at the moment.\n        '''\n        if not self.connections:\n            return defer.succeed(None)\n        result = self._notifier.wait('idle')\n        for connection in self.connections:\n            connection.transport.loseConnection()\n        return result", "response": "Disconnect all the clients NOW regardless of a request\n        at the moment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nordering specified options in function of the specified accept priorities.", "response": "def negotiate_forced_aspect(self, options, accepts):\n        \"\"\"Order specified options in function of the specified\n        accept priorities.\"\"\"\n        if not options:\n            return None\n\n        priorities = {}\n\n        for i, o in enumerate(options):\n            p = accepts.get(o, None)\n            if p is None:\n                p = accepts.get(\"*\", None)\n            if p is not None:\n                # Prevent that a priority of 0 mess with the order of options\n                priorities[o] = max(p, 0.000001) * (1 - i * 0.1 / len(options))\n\n        if not priorities:\n            return None\n\n        order = priorities.keys()\n        order.sort(key=priorities.get)\n        return order[::-1]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nyield a generator that yields all the work that blocks waiting for the queue trigger.", "response": "def scan_forever(queue, *args, **kwargs):\n    \"\"\"Return an infinite iterator over an fsq queue that blocks waiting\n       for the queue trigger. Work is yielded as FSQWorkItem objects when\n       available, assuming the default generator (FSQScanGenerator) is\n       in use.\n\n       Essentially, this function wraps fsq.scan() and blocks for more work.\n\n       It takes all the same parameters as scan(), plus process_once_now,\n       which is a boolean to determine if an initial .scan() is run before\n       listening to the trigger. This argument defaults to True.\n    \"\"\"\n    process_once_now = kwargs.get('process_once_now', True)\n    if process_once_now:\n        for work in scan(queue, *args, **kwargs):\n            yield work\n    while True:\n        with open(fsq_path.trigger(queue), 'rb') as t:\n            t.read(1)\n        for work in scan(queue, *args, **kwargs):\n            yield work"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a queue generate a list of files in that queue and pass it to FSQScanGenerator for iteration.", "response": "def scan(queue, lock=None, ttl=None, max_tries=None, ignore_down=False,\n         no_open=False, generator=FSQScanGenerator, host=False, hosts=None):\n    '''Given a queue, generate a list of files in that queue, and pass it to\n       FSQScanGenerator for iteration.  The generator kwarg is provided here\n       as a means of implementing a custom generator, use with caution.'''\n    lock = _c.FSQ_LOCK if lock is None else lock\n    ttl = _c.FSQ_TTL if lock is None else ttl\n    max_tries = _c.FSQ_MAX_TRIES if max_tries is None else max_tries\n    item_ids = []\n    try:\n        if not host and hosts is None:\n            item_ids = os.listdir(fsq_path.queue(queue))\n            item_ids.sort()\n        else:\n            if hosts is None:\n                hosts = fsq_hosts(queue)\n            for trg_host in hosts:\n                for item in os.listdir(fsq_path.queue(queue, trg_host)):\n                    item_ids.append((trg_host, item))\n            item_ids.sort(key=lambda x: x[1])\n    except (OSError, IOError, ), e:\n        if e.errno == errno.ENOENT:\n            raise FSQScanError(e.errno, u'no such queue:'\\\n                               u' {0}'.format(queue))\n        elif isinstance(e, FSQError):\n            raise e\n        raise FSQScanError(e.errno, wrap_io_os_err(e))\n\n    # sort here should yield time then entropy sorted\n    return generator(queue, item_ids, lock=lock, ttl=ttl, max_tries=max_tries,\n                     no_open=no_open, host=host)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets up the demo environment and run the server", "response": "def demo(ctx, reset=False):\n    '''Set up the demo environment and run the server'''\n    if reset:\n        rmdb(ctx)\n\n    ctx.run('demo check', pty=True)\n    ctx.run('demo loaddemo', pty=True)\n    ctx.run('demo runserver', pty=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a new effect that will delay the execution of the given effect and return the specified result right away.", "response": "def delay(effect, result=None, delay=0.001):\n    \"\"\"\n    Returns a new effect that will delay the execution\n    of the given effect and return the specified result right away.\n\n    @param effect: the effect to delay\n    @type  effect: callable\n    @param result: the value to return right away\n    @type  result: Any\n    @param delay:  the time to wait before performing\n                   the specified effect, in seconds\n    @type  delay:  float\n\n    @return: a new effect that will delay the given effect\n    @rtype:  callable\n    \"\"\"\n\n    def delay(value, context, **params):\n        d = defer.Deferred()\n        d.addCallback(effect, context, **params)\n        time.call_next(d.callback, value)\n        return result\n\n    return delay"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an effect that drops the current value and returns the parameter with the specified name instead of the specified default value.", "response": "def select_param(param_name, default=None):\n    \"\"\"\n    Returns an effect that drops the current value and returns the parameter\n    with the specified name instead, or the specified default value if the\n    parameter is not specified.\n    \"\"\"\n\n    def select_param(_value, _context, **params):\n        return params.pop(param_name, default)\n\n    return select_param"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef local_ref(*parts):\n\n    def local_ref(_value, context, **_params):\n        return reference.Local(*(parts + (context[\"key\"], )))\n\n    return local_ref", "response": "Returns an effect that returns a local reference constructed from the\n    given the context s key."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a reference builder with specified relative location.", "response": "def relative_ref(*parts):\n    \"\"\"\n    Create a reference builder with specified relative location.\n    using getter.relative_ref(\"some\", \"submodel\") to get a value with key\n    \"toto\" will gives reference.Relative(\"some\", \"submodel\", \"toto\")\n    \"\"\"\n\n    def relative_ref(_value, context, **_params):\n        return reference.Relative(*(parts + (context[\"key\"], )))\n\n    return relative_ref"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an effect that drops the current value and replaces it with the given name.", "response": "def context_value(name):\n    \"\"\"\n    Returns an effect that drops the current value, and replaces it with\n    the value from the context with the given name.\n    \"\"\"\n\n    def context_value(_value, context, **_params):\n        return defer.succeed(context[name])\n\n    return context_value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef subroutine(*effects):\n\n    def subroutine(value, context, *args, **kwargs):\n        d = defer.succeed(value)\n        for effect in effects:\n            d.addCallback(effect, context, *args, **kwargs)\n        return d\n\n    return subroutine", "response": "Returns an effect performing a list of effects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(args):\n    # Create an OSLOM runner with a temporary working directory\n    oslom_runner = OslomRunner(tempfile.mkdtemp())\n\n    # (Re-)create OSLOM output directory\n    shutil.rmtree(args.oslom_output, ignore_errors=True)\n    os.makedirs(args.oslom_output)\n\n    # Read edges file\n    logging.info(\"reading edges file: %s\", args.edges)\n    edges = []\n    with open(args.edges, \"r\") as reader:\n        for line in reader:\n            source, target, weight = line.strip().split(\"\\t\", 2)\n            edges.append((source, target, weight))\n    logging.info(\"%d edge(s) found\", len(edges))\n\n    # Write temporary edges file with re-mapped Ids\n    logging.info(\"writing temporary edges file with re-mapped Ids ...\")\n    oslom_runner.store_edges(edges)\n\n    # Run OSLOM\n    logging.info(\"running OSLOM ...\")\n    result = oslom_runner.run(\n        args.oslom_exec, args.oslom_args,\n        os.path.join(args.oslom_output, OSLOM_LOG_FILE))\n    if result[\"retval\"] != 0:\n        logging.error(\"error running OSLOM, check the log file\")\n        return False\n    logging.info(\"OSLOM executed in %.3f secs\", result[\"time\"])\n\n    # Read back clusters found by OSLOM\n    logging.info(\"reading OSLOM clusters output file ...\")\n    clusters = oslom_runner.read_clusters(args.min_cluster_size)\n    logging.info(\n        \"found %d cluster(s) and %d with size >= %d\",\n        clusters[\"num_found\"], len(clusters[\"clusters\"]), args.min_cluster_size)\n\n    # Write clusters file\n    logging.info(\"writing output clusters file: %s\", args.output_clusters)\n    with open(args.output_clusters, \"w\") as writer:\n        json.dump(clusters[\"clusters\"], writer, separators=(\",\", \":\"))\n\n    # Store OSLOM output files\n    logging.info(\"writing OSLOM output files ...\")\n    oslom_runner.store_output_files(args.oslom_output)\n\n    # Clean-up temporary working directory\n    oslom_runner.cleanup()\n\n    # Finished\n    logging.info(\"finished\")\n    return True", "response": "Main OSLOM runner function."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns OSLOM with an in - memory list of edges return in - memory results.", "response": "def run_in_memory(args, edges):\n    \"\"\"Run OSLOM with an in-memory list of edges, return in-memory results.\"\"\"\n    # Create an OSLOM runner with a temporary working directory\n    oslom_runner = OslomRunner(tempfile.mkdtemp())\n\n    # Write temporary edges file with re-mapped Ids\n    logging.info(\"writing temporary edges file with re-mapped Ids ...\")\n    oslom_runner.store_edges(edges)\n\n    # Run OSLOM\n    logging.info(\"running OSLOM ...\")\n    log_file = os.path.join(oslom_runner.working_dir, OSLOM_LOG_FILE)\n    result = oslom_runner.run(args.oslom_exec, args.oslom_args, log_file)\n    with open(log_file, \"r\") as reader:\n        oslom_log = reader.read()\n    if result[\"retval\"] != 0:\n        logging.error(\"error running OSLOM, check the log\")\n        return (None, oslom_log)\n    logging.info(\"OSLOM executed in %.3f secs\", result[\"time\"])\n\n    # Read back clusters found by OSLOM\n    logging.info(\"reading OSLOM clusters output file ...\")\n    clusters = oslom_runner.read_clusters(args.min_cluster_size)\n    logging.info(\n        \"found %d cluster(s) and %d with size >= %d\",\n        clusters[\"num_found\"], len(clusters[\"clusters\"]), args.min_cluster_size)\n\n    # Clean-up temporary working directory\n    oslom_runner.cleanup()\n\n    # Finished\n    logging.info(\"finished\")\n    return (clusters, oslom_log)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_int_id(self, str_id):\n        if not str_id in self.mapping:\n            if self.curr_id == IdRemapper.INT_MAX:\n                return None # No more 32 bits signed integers available\n            self.mapping[str_id] = self.curr_id\n            self.r_mapping[self.curr_id] = str_id\n            self.curr_id += 1\n        return self.mapping[str_id]", "response": "Get a unique 32 bits signed integer for the given string Id."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef store_mapping(self, path):\n        with open(path, \"w\") as writer:\n            for key, value in self.mapping.iteritems():\n                writer.write(\"{}\\t{}\\n\".format(key, value))", "response": "Store the current Id mappings into a TSV file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstore the temporary network edges input file with re - mapped Ids.", "response": "def store_edges(self, edges):\n        \"\"\"Store the temporary network edges input file with re-mapped Ids.\"\"\"\n        with open(self.get_path(OslomRunner.TMP_EDGES_FILE), \"w\") as writer:\n            for edge in edges:\n                writer.write(\"{}\\t{}\\t{}\\n\".format(\n                    self.id_remapper.get_int_id(edge[0]),\n                    self.id_remapper.get_int_id(edge[1]),\n                    edge[2]))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun OSLOM and wait for the process to finish.", "response": "def run(self, oslom_exec, oslom_args, log_filename):\n        \"\"\"Run OSLOM and wait for the process to finish.\"\"\"\n        args = [oslom_exec, \"-f\", self.get_path(OslomRunner.TMP_EDGES_FILE)]\n        args.extend(oslom_args)\n        with open(log_filename, \"w\") as logwriter:\n            start_time = time.time()\n            retval = subprocess.call(\n                args, cwd=self.working_dir,\n                stdout=logwriter, stderr=subprocess.STDOUT)\n            self.last_result = {\n                \"args\": args, \"retval\": retval,\n                \"time\": time.time() - start_time,\n                \"output_dir\": self.get_path(\n                    \"{}_oslo_files\".format(OslomRunner.TMP_EDGES_FILE))\n            }\n            return self.last_result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads and parse OSLOM clusters output file.", "response": "def read_clusters(self, min_cluster_size):\n        \"\"\"Read and parse OSLOM clusters output file.\"\"\"\n        num_found = 0\n        clusters = []\n        with open(self.get_path(OslomRunner.OUTPUT_FILE), \"r\") as reader:\n            # Read the output file every two lines\n            for line1, line2 in itertools.izip_longest(*[reader] * 2):\n                info = OslomRunner.RE_INFOLINE.match(line1.strip()).groups()\n                nodes = line2.strip().split(\" \")\n                if len(nodes) >= min_cluster_size: # Apply min_cluster_size\n                    clusters.append({\n                        \"id\": int(info[0]),\n                        \"bs\": float(info[2]),\n                        \"nodes\": [{\"id\": self.id_remapper.get_str_id(int(n))} for n in nodes],\n                    })\n                num_found += 1\n        return {\"num_found\": num_found, \"clusters\": clusters}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstoring OSLOM output files to a directory.", "response": "def store_output_files(self, dir_path):\n        \"\"\"Store OSLOM output files to a directory.\"\"\"\n        if self.last_result:\n            for entry in os.listdir(self.last_result[\"output_dir\"]):\n                path = os.path.join(self.last_result[\"output_dir\"], entry)\n                if os.path.isfile(path):\n                    shutil.copy(path, os.path.join(dir_path, entry))\n            shutil.copy(\n                self.get_path(OslomRunner.SEED_FILE),\n                os.path.join(dir_path, OslomRunner.SEED_FILE))\n            args_file = os.path.join(dir_path, OslomRunner.ARGS_FILE)\n            with open(args_file, \"w\") as writer:\n                writer.write(\"{}\\n\".format(\" \".join(self.last_result[\"args\"])))\n            self.id_remapper.store_mapping(\n                os.path.join(dir_path, OslomRunner.IDS_MAPPING_FILE))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef urlencode_utf8(params):\n    if hasattr(params, 'items'):\n        params = params.items()\n    params = (\n        '='.join((\n            quote_plus(k.encode('utf8'), safe='/'),\n            quote_plus(v.encode('utf8'), safe='/')\n        )) for k, v in params\n    )\n    return '&'.join(params)", "response": "URL encode a dictionary of parameters using UTF - 8 safe variant of urllib. urlencode."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconstructs the payload for the GCM API.", "response": "def construct_payload(self, registration_ids, data=None, collapse_key=None,\n                          delay_while_idle=False, time_to_live=None, is_json=True, dry_run=False):\n        \"\"\"\n        Construct the dictionary mapping of parameters.\n        Encodes the dictionary into JSON if for json requests.\n        Helps appending 'data.' prefix to the plaintext data: 'hello' => 'data.hello'\n\n        :return constructed dict or JSON payload\n        :raises GCMInvalidTtlException: if time_to_live is invalid\n        \"\"\"\n\n        if time_to_live:\n            if not (0 <= time_to_live <= self.GCM_TTL):\n                raise GCMInvalidTtlException(\"Invalid time to live value\")\n\n        payload = {}\n        if is_json:\n            payload['registration_ids'] = registration_ids\n            if data:\n                payload['data'] = data\n        else:\n            payload['registration_id'] = registration_ids\n            if data:\n                for key, value in data.items():\n                    payload['data.%s' % key] = value\n\n        if delay_while_idle:\n            payload['delay_while_idle'] = delay_while_idle\n\n        if time_to_live:\n            payload['time_to_live'] = time_to_live\n\n        if collapse_key:\n            payload['collapse_key'] = collapse_key\n\n        if dry_run:\n            payload['dry_run'] = True\n\n        if is_json:\n            payload = json.dumps(payload)\n\n        return payload"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking a HTTP request to GCM servers with the constructed payload.", "response": "def make_request(self, data, is_json=True):\n        \"\"\"\n        Makes a HTTP request to GCM servers with the constructed payload\n\n        :param data: return value from construct_payload method\n        :raises GCMMalformedJsonException: if malformed JSON request found\n        :raises GCMAuthenticationException: if there was a problem with authentication, invalid api key\n        :raises GCMConnectionException: if GCM is screwed\n        \"\"\"\n\n        # Default Content-Type is\n        # application/x-www-form-urlencoded;charset=UTF-8\n        if is_json:\n            self.headers['Content-Type'] = 'application/json'\n\n        if not is_json:\n            data = urlencode_utf8(data)\n\n        response = requests.post(\n            self.url, data=data, headers=self.headers,\n            proxies=self.proxy\n        )\n        # Successful response\n        if response.status_code == 200:\n            if is_json:\n                response = response.json()\n            else:\n                response = response.content\n            return response\n\n        # Failures\n        if response.status_code == 400:\n            raise GCMMalformedJsonException(\n                \"The request could not be parsed as JSON\")\n        elif response.status_code == 401:\n            raise GCMAuthenticationException(\n                \"There was an error authenticating the sender account\")\n        elif response.status_code == 503:\n            raise GCMUnavailableException(\"GCM service is unavailable\")\n        else:\n            error = \"GCM service error: %d\" % response.status_code\n            raise GCMUnavailableException(error)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plaintext_request(self, registration_id, data=None, collapse_key=None,\n                          delay_while_idle=False, time_to_live=None, retries=5, dry_run=False):\n        \"\"\"\n        Makes a plaintext request to GCM servers\n\n        :param registration_id: string of the registration id\n        :param data: dict mapping of key-value pairs of messages\n        :return dict of response body from Google including multicast_id, success, failure, canonical_ids, etc\n        :raises GCMMissingRegistrationException: if registration_id is not provided\n        \"\"\"\n\n        if not registration_id:\n            raise GCMMissingRegistrationException(\"Missing registration_id\")\n\n        payload = self.construct_payload(\n            registration_id, data, collapse_key,\n            delay_while_idle, time_to_live, False, dry_run\n        )\n\n        attempt = 0\n        backoff = self.BACKOFF_INITIAL_DELAY\n        for attempt in range(retries):\n            try:\n                response = self.make_request(payload, is_json=False)\n                return self.handle_plaintext_response(response)\n            except GCMUnavailableException:\n                sleep_time = backoff / 2 + random.randrange(backoff)\n                time.sleep(float(sleep_time) / 1000)\n                if 2 * backoff < self.MAX_BACKOFF_DELAY:\n                    backoff *= 2\n\n        raise IOError(\"Could not make request after %d attempts\" % attempt)", "response": "Makes a plaintext request to the GCM servers."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef json_request(self, registration_ids, data=None, collapse_key=None,\n                     delay_while_idle=False, time_to_live=None, retries=5, dry_run=False):\n        \"\"\"\n        Makes a JSON request to GCM servers\n\n        :param registration_ids: list of the registration ids\n        :param data: dict mapping of key-value pairs of messages\n        :return dict of response body from Google including multicast_id, success, failure, canonical_ids, etc\n        :raises GCMMissingRegistrationException: if the list of registration_ids is empty\n        :raises GCMTooManyRegIdsException: if the list of registration_ids exceeds 1000 items\n        \"\"\"\n\n        if not registration_ids:\n            raise GCMMissingRegistrationException(\"Missing registration_ids\")\n        if len(registration_ids) > 1000:\n            raise GCMTooManyRegIdsException(\n                \"Exceded number of registration_ids\")\n\n        backoff = self.BACKOFF_INITIAL_DELAY\n        for attempt in range(retries):\n            payload = self.construct_payload(\n                registration_ids, data, collapse_key,\n                delay_while_idle, time_to_live, True, dry_run\n            )\n            response = self.make_request(payload, is_json=True)\n            info = self.handle_json_response(response, registration_ids)\n\n            unsent_reg_ids = self.extract_unsent_reg_ids(info)\n            if unsent_reg_ids:\n                registration_ids = unsent_reg_ids\n                sleep_time = backoff / 2 + random.randrange(backoff)\n                time.sleep(float(sleep_time) / 1000)\n                if 2 * backoff < self.MAX_BACKOFF_DELAY:\n                    backoff *= 2\n            else:\n                break\n        return info", "response": "Makes a JSON request to GCM servers."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(**options):\n    log.msg(\"Hello!, I am a dummy, so I won't do a thing!\")\n    if len(options):\n        log.msg_debug(\"I have received a bunch of options, here they come ...\")\n        for o, v in options.items():\n            log.msg_debug(\"Option: name={name}, value={value}\"\n                          .format(name=o, value=v))", "response": "Load this driver s internal data structures."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms backup action :param file: Name of the file to be used by the driver :param host: Corresponding host name associated with file", "response": "def backup_file(*, file, host):\n    \"\"\"\n    Perform backup action\n\n    :param file: Name of the file to be used by the driver\n    :param host: Corresponding host name associated with file\n    \"\"\"\n    log.msg(\"[{host}] Backing up file '{file}'\".format(host=host, file=file))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef search(self, base_dn, search_filter, attributes=()):\n        results = []\n        page = 0\n        while page == 0 or self.sprc.cookie:\n            page += 1\n            #pylint: disable=no-member\n            message_id = self.ldap.search_ext(base_dn, ldap.SCOPE_SUBTREE,\n                                              search_filter, attributes,\n                                              serverctrls=[self.sprc])\n            #pylint: enable=no-member\n            data, server_controls = self.ldap.result3(message_id)[1::2]\n            self.sprc.cookie = server_controls[0].cookie\n            logging.debug('%s - Page %s results: %s',  \\\n                          self.__class__.__name__, page, ', '.join(k[0] for k in data))\n            results += [u for u in data]\n\n        return results", "response": "Perform an AD search within a base DN and return a list of objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _open(self):\n        try:\n            self.ldap.start_tls_s()\n        #pylint: disable=no-member\n        except ldap.CONNECT_ERROR:\n        #pylint: enable=no-member\n            logging.error('Unable to establish a connection to the LDAP server, ' + \\\n                          'please check the connection string ' + \\\n                          'and ensure the remote certificate is signed by a trusted authority.')\n            raise\n\n        self.ldap.simple_bind_s(self.user, self.password)", "response": "Open the LDAP server and bind to it."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _cast(self, value, format=None, **opts):\n        if format is not None:\n            return datetime.strptime(value, format)\n        return dateutil.parser.parse(value)", "response": "Optionally apply a format string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef enqueue(trg_queue, item_f, *args, **kwargs):\n    '''Enqueue the contents of a file, or file-like object, file-descriptor or\n       the contents of a file at an address (e.g. '/my/file') queue with\n       arbitrary arguments, enqueue is to venqueue what printf is to vprintf\n    '''\n    return venqueue(trg_queue, item_f, args, **kwargs)", "response": "Enqueue the contents of a file or file - like object or file - descriptor to the queue"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrenders a Python sequence as a comma - separated list with an or for the final item.", "response": "def make_any_items_node(rawtext, app, prefixed_name, obj, parent, modname, options):\n    \"\"\"Render a Python sequence as a comma-separated list, with an \"or\" for the final item.\n\n    :param rawtext: Text being replaced with link node.\n    :param app: Sphinx application context\n    :param prefixed_name: The dotted Python name for obj.\n    :param obj: The Python object to be rendered to text.\n    :param parent: The parent Python object of obj.\n    :param module: The name of the module containing obj.\n    :param options: Options dictionary passed to role func.\n    \"\"\"\n    text = list_conjunction(obj, \"or\")\n    node = nodes.Text(text, rawsource=rawtext)\n    return node"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_images_filter():\n    KEYSTONE = os.environ.get('OS_KEYSTONE')\n    TENANT_ID = os.environ.get('OS_TENANT_ID')\n    USERNAME = os.environ.get('OS_USERNAME')\n    PASSWORD = os.environ.get('OS_PASSWORD')\n\n    token = get_token(KEYSTONE,\n                      TENANT_ID,\n                      USERNAME,\n                      PASSWORD)\n    endpoints = get_endpoints(KEYSTONE,\n                              TENANT_ID,\n                              USERNAME,\n                              PASSWORD)\n\n    products = get_product_with_image_filtered(endpoints['sdc']['Spain2'],\n                                               token, TENANT_ID)\n\n    for product in products:\n        image_list = product[1].split(' ')\n        image_ids = ''\n        for image in image_list:\n            try:\n                try:\n                    image_ids.index(image)\n                    continue\n                except:\n                    image_name = check_image_in_spain(\n                        endpoints['image']['Spain2'], image, token)\n                    if image_name is None:\n                        continue\n                    image_ids = image_ids + ' ' + image\n                    for endpoint_glace in endpoints['image']:\n                        print endpoint_glace\n\t\t        if endpoint_glace in EXCLUDED_REGIONS:\n                            continue\n                        image_id = get_image_id_another_region(\n                            endpoints['image'][endpoint_glace],\n                            image_name, token)\n                        if image_id is None:\n                            continue\n                        image_ids = image_ids + ' ' + image_id\n                    update_metadata_image (endpoints['sdc']['Spain2'],\n                       token, TENANT_ID, product[0], image_ids)\n            except Exception, e:\n                print 'Error with image ' + image + ' ' + e.message\n        print 'Product ' + product[0] + ' ' + image_ids", "response": "This function returns all the products with metatada image and obtain all the their metadata images in all regions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_glance_url(url_base, tenant_id, user, password, region):\n    get_url(url_base, tenant_id, user, password, 'image', region)", "response": "It get the glance url"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_url(url_base, tenant_id, user, password, type, region):\n    url = 'http://' + url_base + '/v2.0/tokens'\n    headers = {'Accept': 'application/json'}\n    payload = {'auth': {'tenantName': '' + tenant_id + '',\n                        'passwordCredentials':\n                        {'username': '' + user + '',\n                        'password': '' + password + ''}}}\n    try:\n        response = requests.post(url, headers=headers,\n                                 data=json.dumps(payload))\n        response_json = response.json()\n        services = response_json['access']['serviceCatalog']\n    except Exception as e:\n        raise Exception('Error to obtain a image ' + e.message)\n\n    for service in services:\n        if service['type'] == type and service['region'] == region:\n            for endpoint in service['endpoints']:\n                return endpoint['publicURL']", "response": "This function returns the url for a concrete service"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_image_in_spain(glance_url, id, token):\n    url = glance_url + '/images?property-sdc_aware=true'\n    headers = {'Accept': 'application/json', 'X-Auth-Token': token}\n\n    try:\n        response = requests.get(url, headers=headers)\n        response_json = response.json()\n        for image in response_json['images']:\n            if image['id'] == id:\n                return image['name']\n        return None\n    except Exception as e:\n        raise Exception('Error to obtain a image ' + e.message)", "response": "It obtain if the image is in Spain\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_image_id_another_region(glance_url, image_name, token):\n    url = glance_url + '/images?property-sdc_aware=true'\n    headers = {'Accept': 'application/json', 'X-Auth-Token': token}\n    try:\n        response = requests.get(url, headers=headers)\n        response_json = response.json()\n        for image_info in response_json['images']:\n            if image_info['name'] == image_name:\n                return image_info['id']\n        return None\n    except Exception as e:\n        return None", "response": "It obtains the image in another region"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the minimal rectangle that encloses the given set of points.", "response": "def enclose_points(points, clip_rect):\n        \"\"\"Return the minimal rectangle enclosing the given set of points\n\n        Args:\n            points (List[Point]): The set of points that the new Rect must enclose.\n            clip_rect (Rect): A clipping Rect.\n\n        Returns:\n            Rect: A new Rect enclosing the given points.\n        \"\"\"\n        point_array = ffi.new('SDL_Point[]', len(points))\n        for i, p in enumerate(points):\n            point_array[i] = p._ptr\n        enclosing_rect = Rect()\n        if lib.SDL_EnclosePoints(point_array, len(points), clip_rect._ptr, enclosing_rect._ptr):\n            return enclosing_rect\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_intersection(self, other):\n        return bool(lib.SDL_HasIntersection(self._ptr, other._ptr))", "response": "Returns True if this rectangle intersects with another rectangle."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate the intersection of this rectangle and the given other rectangle.", "response": "def intersect(self, other):\n        \"\"\"Calculate the intersection of this rectangle and another rectangle.\n\n        Args:\n            other (Rect): The other rectangle.\n\n        Returns:\n            Rect: The intersection of this rectangle and the given other rectangle, or None if there is no such\n                intersection.\n        \"\"\"\n        intersection = Rect()\n        if lib.SDL_IntersectRect(self._ptr, self._ptr, intersection._ptr):\n            return intersection\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef union(self, other):\n        union = Rect()\n        lib.SDL_UnionRect(self._ptr, other._ptr, union._ptr)\n        return union", "response": "Calculate the union of this rectangle and the given other rectangle."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sanitize_word(word):\n    # use an unicode string for `unidecode`\n    if type(word) == str:\n        try:\n            word = word.decode()\n        except AttributeError:\n            pass  # Python3\n\n    # remove trailing spaces\n    word = word.strip()\n\n    # remove stuff between parentheses\n    word = re.sub(r'\\([^)]*\\)', '', word)\n\n    # remove accents, hyphens & other special chars\n    word = re.sub(r'[ \"\\'-;.]+', '', unidecode(word))\n\n    # only lowercase\n    return word.lower()", "response": "sanitize a word by removing its accents special characters etc."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing the local dictionnaries cache in ~/.crosswords. dictionnaries.", "response": "def init_storage():\n    \"\"\"\n    Initialize the local dictionnaries cache in ~/.crosswords/dicts.\n    \"\"\"\n    # http://stackoverflow.com/a/600612/735926\n    try:\n        os.makedirs(DICTS_PATH)\n    except OSError as ex:\n        if ex.errno != errno.EEXIST or not os.path.isdir(DICTS_PATH):\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef local_list(timestamps=True):\n    init_storage()\n    lst = []\n    for d in glob(os.path.join(DICTS_PATH, '*.txt')):\n        name = d.split('/')[-1].replace('.txt', '')\n        lst.append((name, os.path.getmtime(d)) if timestamps else name)\n\n    return lst", "response": "Return a list of the locally available dictionnaries."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_remote_file(url):\n    try:\n        return requests.get(url)\n    except requests.exceptions.ConnectionError as e:\n        print(\"Connection error!\")\n        print(e.message.reason)\n        exit(1)", "response": "Wrapper around requests. get which nicely handles connection errors\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remote_list(timestamps=True):\n    r = get_remote_file(DICTS_URL)\n    lst = []\n    for f in r.text.split('\\n'):\n        if not f:\n            continue\n        name, date = f.split(':')\n        name = name.replace('.txt', '')\n        lst.append((name, int(date)) if timestamps else name)\n\n    return lst", "response": "Return a list of the remotely available dictionnaries."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(verbose=False):\n    local = local_list()\n    remote = dict(remote_list())\n\n    updated = False\n\n    for name, date in local:\n        if name in remote and remote[name] > date:\n            updated = True\n            if verbose:\n                print(\"Updating '%s'...\" % name)\n            download(name)\n\n    if not updated and verbose:\n        print(\"Nothing to update.\")", "response": "Update local dictionnaries by downloading the latest version from the available remote dictionnaries if there s one."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndownload a dictionnary from the remote server into the local cache. Return - 1 on error.", "response": "def download(name, verbose=False):\n    \"\"\"\n    Download a dictionnary from the remote server into the local cache. Return\n    the number of new words or -1 on error.\n    \"\"\"\n    init_storage()\n\n    if verbose:\n        print(\"Downloading '%s'...\" % name)\n    r = get_remote_file('%s/%s.txt' % (DICTS_URL, name))\n\n    if r.status_code != 200:\n        return -1\n\n    wcount = 0\n\n    with open(os.path.join(DICTS_PATH, '%s.txt' % name), 'w') as f:\n        for word in r.iter_lines():\n            wcount += 1\n            f.write('%s\\n' % sanitize_word(word))\n\n    if verbose:\n        print(\"%d words added.\" % wcount)\n    return wcount"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove(self):\n        num, sp, newfile = 0, \"\", []\n        if os.path.isfile(self.filename):\n            with open(self.filename, \"r\") as r:\n                oldfile = r.read().splitlines()\n                for line in oldfile:\n                    if self.number:\n                        num += 1\n                        sp = \": \"\n                    if self.case_ins:\n                        line = line.lower()\n                    if self.ignore_blank and not line:\n                        newfile.append(line)\n                    elif line not in newfile:\n                        newfile.append(line)\n                    else:\n                        if (self.args[0] in self.options[4:5] or\n                                self.args[0] in self.options[6:7]):\n                            if num == 0:\n                                num = str()\n                            print(\"{0}{1}{2}\".format(num, sp, line))\n            if self.args[0] not in self.options[6:7]:\n                with open(self.filename, \"w\") as w:\n                    for line in newfile:\n                        w.write(line + \"\\n\")\n        else:\n            self.not_access()", "response": "Remove duplicate lines from text files"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncontrols the arguments for the command line interface", "response": "def arguments(self, args):\n        \"\"\"Control arguments\"\"\"\n        self.args = args\n        self.manage_flags()\n        self.filename = self.args[0]\n        if len(self.args) == 1 and self.args[0] in self.options[:2]:\n            print(self.help.__doc__)\n        elif len(self.args) == 1 and self.args[0] in self.options[2:4]:\n            self.version()\n        elif len(self.args) == 2 and self.args[0] in self.options[4:5]:\n            self.filename = self.args[1]\n            self.remove()\n        elif len(self.args) == 2 and self.args[0] in self.options[6:7]:\n            self.filename = self.args[1]\n            self.remove()\n        elif len(self.args) == 1:\n            if os.path.isfile(self.args[0]):\n                self.remove()\n            else:\n                self.not_access()\n        else:\n            self.usage()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_all_files(filename, data, wref_data=None, params=None):\n\n    # we assume that the data has one spectral dimension, any others must be\n    # spatial\n    if len(data.shape) == 1:\n        shape = (1, 1, 1)\n    elif len(data.shape) == 2:\n        shape = (data.shape[0], 1, 1)\n    elif len(data.shape) == 3:\n        shape = (data.shape[0], data.shape[1], 1)\n    elif len(data.shape) == 4:\n        shape = data.shape[0:3]\n    elif len(data.shape) > 4:\n        raise ValueError(\"LCModel cannot handle data with more than 4 dimensions\")\n\n    # We need to save a bunch of files for LCModel to process: a raw file for\n    # the data, possibly a raw file for the wref and a control file for each\n    # slice. In addition, in the absence of information in the params file\n    # about where to save the output (.ps, .csv, .table etc.) that should also\n    # be saved in the same folder as the input data for LCModel.\n    folder, file_root = os.path.split(filename)\n\n    # make sure that the folder exists before trying to save things to it\n    if not os.path.isdir(folder):\n        os.makedirs(folder)\n\n    file_root, ext = os.path.splitext(file_root)\n\n    base_params = {\n        \"FILBAS\": \"/home/spectre/.lcmodel/basis-sets/provencher/press_te30_3t_gsh_v3.basis\",\n        \"ICOLST\": 1,\n        \"ICOLEN\": shape[0],\n        \"NDCOLS\": shape[0],\n        \"IROWST\": 1,\n        \"IROWEN\": shape[1],\n        \"NDROWS\": shape[1],\n        \"NDSLIC\": shape[2],\n        \"DOWS\": \"T\" if wref_data is not None else \"F\",\n        \"DOECC\": \"T\" if wref_data is not None else \"F\",\n        \"FILRAW\": os.path.join(folder, file_root + \".RAW\"),\n        \"FILPS\": os.path.join(folder, file_root + \".PS\")\n    }\n    if wref_data is not None:\n        base_params[\"FILH2O\"] = os.path.join(folder, file_root + \".H2O\")\n\n    # add the user supplied parameters to the list\n    if params is not None:\n        base_params.update(params)\n\n    # make a few modifications based on user edits\n    if \"FILTAB\" in base_params:\n        base_params[\"LTABLE\"] = 7\n        base_params[\"FILTAB\"] = \"'{}'\".format(base_params[\"FILTAB\"])\n    elif \"LTABLE\" in base_params:\n        base_params[\"LTABLE\"] = 7\n        base_params[\"FILTAB\"] = \"'{}'\".format(os.path.join(folder, file_root + \".TABLE\"))\n    if \"FILCSV\" in base_params:\n        base_params[\"LCSV\"] = 11\n        base_params[\"FILCSV\"] = \"'{}'\".format(base_params[\"FILCSV\"])\n    elif \"LCSV\" in base_params:\n        base_params[\"LCSV\"] = 11\n        base_params[\"FILCSV\"] = \"'{}'\".format(os.path.join(folder, file_root + \".CSV\"))\n    if \"FILCOO\" in base_params:\n        base_params[\"LCOORD\"] = 9\n        base_params[\"FILCOO\"] = \"'{}'\".format(base_params[\"FILCOO\"])\n    elif \"LCOORD\" in base_params:\n        base_params[\"LCOORD\"] = 9\n        base_params[\"FILCOO\"] = \"'{}'\".format(os.path.join(folder, file_root + \".COORD\"))\n    if \"FILCOR\" in base_params:\n        base_params[\"LCORAW\"] = 10\n        base_params[\"FILCOR\"] = \"'{}'\".format(base_params[\"FILCOR\"])\n    elif \"LCORAW\" in base_params:\n        base_params[\"LCORAW\"] = 10\n        base_params[\"FILCOR\"] = \"'{}'\".format(os.path.join(folder, file_root + \".CORAW\"))\n\n    save_raw(base_params[\"FILRAW\"], data)\n    if wref_data is not None:\n        save_raw(base_params[\"FILH2O\"], wref_data)\n    # have to add single quotes to the various paths\n    base_params[\"FILRAW\"] = \"'{}'\".format(base_params[\"FILRAW\"])\n    base_params[\"FILBAS\"] = \"'{}'\".format(base_params[\"FILBAS\"])\n    base_params[\"FILPS\"] = \"'{}'\".format(base_params[\"FILPS\"])\n    if wref_data is not None:\n        base_params[\"FILH2O\"] = \"'{}'\".format(base_params[\"FILH2O\"])\n\n    for slice_index in range(shape[2]):\n        control_filename = \"{0}_sl{1}.CONTROL\".format(file_root, slice_index)\n        control_filepath = os.path.join(folder, control_filename)\n        with open(control_filepath, 'wt') as fout:\n            fout.write(\" $LCMODL\\n\")\n            fout.write(\" OWNER = ''\\n\")\n            fout.write(\" KEY = 123456789\\n\")\n            fout.write(\" DELTAT = {}\\n\".format(data.dt))\n            fout.write(\" HZPPPM = {}\\n\".format(data.f0))\n            fout.write(\" NUNFIL = {}\\n\".format(data.np))\n            for key, value in base_params.items():\n                fout.write(\" {0} = {1}\\n\".format(key, value))\n            fout.write(\" $END\\n\")", "response": "Writes a set of files for LCModel to a file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef call(func, max_attempts=None, exceptions=Exception, wait=0.0,\n         cleanup_hook=None, pre_retry_hook=None):\n    \"\"\" :param func (callable):\n            The function to retry. No arguments are passed to this function.\n            If your function requires arguments, consider defining a separate\n            function or use functools.partial / a lambda function.\n\n        :param max_attempts:\n            Any integer number to limit the maximum number of attempts.\n            Set to None for unlimited retries.\n\n        :param exceptions:\n            A tuple of exceptions that should result in a retry. Catches\n            everything derived from 'Exception' by default.\n\n        :param wait:\n            This can be an integer / float to specify the waittime in seconds\n            before the next attempt. You can also pass a function which accepts\n            a single argument 'attempt'.\n\n        :param cleanup_hook:\n            Can be set to a callable and will be called after an exception is\n            raised from calling `func`.\n            No arguments are passed to this function.\n            If your function requires arguments, consider defining a separate\n            function or use functools.partial / a lambda function.\n\n        :param pre_retry_hook:\n            Can be set to any callable that will be called before `function`\n            is called.\n            No arguments are passed to this function.\n            If your function requires arguments, consider defining a separate\n            function or use functools.partial / a lambda function.\n            If `wait` is set, `pre_retry_hook` will be called before the\n            waittime.\n            Exceptions that are raised when calling this hook are not caught.\n\n        :returns:\n            The result of calling the given `func`.\n\n        :raises:\n            Any exception which is\n             - not in the given `exceptions`\n             - raised in `pre_retry_hook` or in `cleanup_hook`\n             - raised in the last attempt at calling `func`\n    \"\"\"\n    # we check the callables in advance to prevent raising exceptions\n    # after making the first attempt\n    _assert_callable(func, allow_none=False)\n    _assert_callable(cleanup_hook, allow_none=True)\n    _assert_callable(pre_retry_hook, allow_none=True)\n    if not (max_attempts is None or max_attempts >= 1):\n        raise ValueError('max_attempts must be None or an integer >= 1')\n\n    # if the user sets the waittime to a fixed value (int or float) we create\n    # a function which always returns this fixed value. This way we avoid\n    # having to make this decision in the retry loop.\n    wait_func = wait if type(wait) not in [int, float] else lambda _: wait\n    _assert_callable(wait_func, allow_none=False)\n\n    def log_failed_attempt(attempt, error):\n        if max_attempts is None:\n            nr_display = '{0}'.format(attempt)\n        else:\n            nr_display = '{0} / {1}'.format(attempt, max_attempts)\n        logger.debug('Attempt {nr} at calling {func} failed ({msg})'\n                     .format(nr=nr_display, func=func, msg=error))\n\n    for attempt, f in enumerate(_repeat(func, max_attempts), start=1):\n        try:\n            return f()\n        except exceptions as e:\n            log_failed_attempt(attempt=attempt, error=e)\n            if cleanup_hook is not None:\n                cleanup_hook()\n            if attempt == max_attempts:\n                raise\n            if wait:\n                waittime = wait_func(attempt)\n                time.sleep(waittime)\n            if pre_retry_hook is not None:\n                pre_retry_hook()", "response": "Calls a function on the base language of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef restore_geometry_on_layout_change(self, value):\n\n        if value is not None:\n            assert type(value) is bool, \"'{0}' attribute: '{1}' type is not 'bool'!\".format(\n                \"restore_geometry_on_layout_change\", value)\n        self.__restore_geometry_on_layout_change = value", "response": "Setter for **self. __restore_geometry_on_layout_change ** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns given layout value.", "response": "def get(self, layout, default=None):\n        \"\"\"\n        Returns given layout value.\n\n        :param layout: Layout name.\n        :type layout: unicode\n        :param default: Default value if layout is not found.\n        :type default: object\n        :return: Action.\n        :rtype: QAction\n        \"\"\"\n\n        try:\n            return self.__getitem__(layout)\n        except KeyError as error:\n            return default"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters given layout. :param name: Layout name. :type name: unicode :param layout: Layout object. :type layout: Layout :return: Method success. :rtype: bool", "response": "def register_layout(self, name, layout):\n        \"\"\"\n        Registers given layout.\n\n        :param name: Layout name.\n        :type name: unicode\n        :param layout: Layout object.\n        :type layout: Layout\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if name in self:\n            raise umbra.exceptions.LayoutRegistrationError(\"{0} | '{1}' layout is already registered!\".format(\n                self.__class__.__name__, name))\n\n        self.__layouts[name] = layout\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unregister_layout(self, name):\n\n        if not name in self:\n            raise umbra.exceptions.LayoutRegistrationError(\"{0} | '{1}' layout is not registered!\".format(\n                self.__class__.__name__, name))\n\n        del (self.__layouts[name])\n        return True", "response": "Unregisters given layout.\n\n        :param name: Layout name.\n        :type name: unicode\n        :param layout: Layout object.\n        :type layout: Layout\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef restore_layout(self, name, *args):\n\n        layout = self.__layouts.get(name)\n        if not layout:\n            raise umbra.exceptions.LayoutExistError(\"{0} | '{1}' layout isn't registered!\".format(\n                self.__class__.__name__, name))\n\n        LOGGER.debug(\"> Restoring layout '{0}'.\".format(name))\n\n        for component, profile in self.__container.components_manager:\n            if profile.category == \"QWidget\" and component not in self.__container.visible_components:\n                interface = self.__container.components_manager.get_interface(component)\n                interface and interface.hide()\n\n        self.__current_layout = name\n        self.__container.centralWidget().setVisible(\n            self.__settings.get_key(\"Layouts\", \"{0}_central_widget\".format(name)).toBool())\n        self.__container.restoreState(\n            self.__settings.get_key(\"Layouts\", \"{0}_window_state\".format(name)).toByteArray())\n        self.__restore_geometry_on_layout_change and \\\n        self.__container.restoreGeometry(\n            self.__settings.get_key(\"Layouts\", \"{0}_geometry\".format(name)).toByteArray())\n        self.layout_restored.emit(self.__current_layout)\n        return True", "response": "Restores given layout.\n\n        :param name: Layout name.\n        :type name: unicode\n        :param \\*args: Arguments.\n        :type \\*args: \\*\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef store_layout(self, name, *args):\n\n        layout = self.__layouts.get(name)\n        if not layout:\n            raise umbra.exceptions.LayoutExistError(\"{0} | '{1}' layout isn't registered!\".format(\n                self.__class__.__name__, name))\n\n        LOGGER.debug(\"> Storing layout '{0}'.\".format(name))\n\n        self.__current_layout = name\n        self.__settings.set_key(\"Layouts\", \"{0}_geometry\".format(name), self.__container.saveGeometry())\n        self.__settings.set_key(\"Layouts\", \"{0}_window_state\".format(name), self.__container.saveState())\n        self.__settings.set_key(\"Layouts\", \"{0}_central_widget\".format(\n            name), self.__container.centralWidget().isVisible())\n        self.layout_stored.emit(self.__current_layout)\n        return True", "response": "Stores given layout.\n\n        :param name: Layout name.\n        :type name: unicode\n        :param \\*args: Arguments.\n        :type \\*args: \\*\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrestores the startup layout.", "response": "def restore_startup_layout(self):\n        \"\"\"\n        Restores the startup layout.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        LOGGER.debug(\"> Restoring startup layout.\")\n\n        if self.restore_layout(UiConstants.startup_layout):\n            not self.__restore_geometry_on_layout_change and self.__container.restoreGeometry(\n                self.__settings.get_key(\"Layouts\", \"{0}_geometry\".format(UiConstants.startup_layout)).toByteArray())\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new scope in the current frame.", "response": "def append_scope(self):\n        \"\"\"Create a new scope in the current frame.\"\"\"\n        self.stack.current.append(Scope(self.stack.current.current))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes the current scope in the current scope.", "response": "def pop_scope(self):\n        \"\"\"Delete the current scope in the current scope.\"\"\"\n        child_scope = self.stack.current.current.copy()\n        self.stack.current.pop()\n        parent_scope = self.stack.current.current.copy()\n        self.stack.current.current = {\n            key: child_scope[key] for key in child_scope if key in parent_scope\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrename a file based on the name generated using metadata.", "response": "def execute(filename, formatted_name):\n    \"\"\"Renames a file based on the name generated using metadata.\n\n    :param str filename: absolute path and filename of original file\n    :param str formatted_name: absolute path and new filename\n    \"\"\"\n\n    if os.path.isfile(formatted_name):\n        # If the destination exists, skip rename unless overwrite enabled\n        if not cfg.CONF.overwrite_file_enabled:\n            LOG.info('File %s already exists not forcefully moving %s',\n                     formatted_name, filename)\n            return\n\n    LOG.info('renaming [%s] to [%s]', filename, formatted_name)\n    if not cfg.CONF.dryrun:\n        shutil.move(filename, formatted_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getDistance2D(self, x1, y1, x2, y2, isGeo=False, isDriving=False):\n        posType = tc.POSITION_2D\n        if isGeo:\n            posType = tc.POSITION_LON_LAT\n        distType = tc.REQUEST_AIRDIST\n        if isDriving:\n            distType = tc.REQUEST_DRIVINGDIST\n        self._connection._beginMessage(\n            tc.CMD_GET_SIM_VARIABLE, tc.DISTANCE_REQUEST, \"\", 1 + 4 + 1 + 8 + 8 + 1 + 8 + 8 + 1)\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 3)\n        self._connection._string += struct.pack(\"!Bdd\", posType, x1, y1)\n        self._connection._string += struct.pack(\n            \"!BddB\", posType, x2, y2, distType)\n        return self._connection._checkResult(tc.CMD_GET_SIM_VARIABLE, tc.DISTANCE_REQUEST, \"\").readDouble()", "response": "This function returns the distance between two coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getDistanceRoad(self, edgeID1, pos1, edgeID2, pos2, isDriving=False):\n        distType = tc.REQUEST_AIRDIST\n        if isDriving:\n            distType = tc.REQUEST_DRIVINGDIST\n        self._connection._beginMessage(tc.CMD_GET_SIM_VARIABLE, tc.DISTANCE_REQUEST, \"\",\n                                       1 + 4 + 1 + 4 + len(edgeID1) + 8 + 1 + 1 + 4 + len(edgeID2) + 8 + 1 + 1)\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 3)\n        self._connection._packString(edgeID1, tc.POSITION_ROADMAP)\n        self._connection._string += struct.pack(\"!dB\", pos1, 0)\n        self._connection._packString(edgeID2, tc.POSITION_ROADMAP)\n        self._connection._string += struct.pack(\"!dBB\", pos2, 0, distType)\n        return self._connection._checkResult(tc.CMD_GET_SIM_VARIABLE, tc.DISTANCE_REQUEST, \"\").readDouble()", "response": "Reads two positions on the road network and returns the distance between them."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsubscribe to one or more simulation values for the given interval.", "response": "def subscribe(self, varIDs=(tc.VAR_DEPARTED_VEHICLES_IDS,), begin=0, end=2**31 - 1):\n        \"\"\"subscribe(list(integer), double, double) -> None\n\n        Subscribe to one or more simulation values for the given interval.\n        \"\"\"\n        Domain.subscribe(self, \"\", varIDs, begin, end)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef deactivate(self, asset_manager_id):\n        self.logger.info('Deactivate Asset Manager: %s', asset_manager_id)\n        url = '%s/asset-managers/%s' % (self.endpoint, asset_manager_id)\n        response = self.session.delete(url)\n        if response.ok:\n            self.logger.info('Successfully deactivated Asset Manager: %s', asset_manager_id)\n            return json_to_asset_manager(response.json())\n        else:\n            self.logger.error(response.text)\n            response.raise_for_status()", "response": "Deactivates an asset manager."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwaiting until a URL is available.", "response": "def waitForURL(url, max_seconds=None):\n    \"\"\"\n    Give it a URL.  Keep trying to get a HEAD request from it until it works.\n    If it doesn't work, wait a while and try again\n    \"\"\"\n\n    startTime = datetime.now()\n    while True:\n        response = None\n        try:\n            response = urllib2.urlopen(HEADREQUEST(url))\n        except urllib2.URLError:\n            pass\n        if response is not None and isinstance(response, urllib2.addinfourl):\n            if response.getcode() == 200:\n                # We're done, yay!\n                return\n        timeNow = datetime.now()\n        timePassed = timeNow - startTime\n        if max_seconds and max_seconds < timePassed.seconds:\n            return\n        print(\"Waiting on URL %s for %s so far\" % (url, timePassed))\n        time.sleep(30)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef doWaitWebRequest(url, method=\"GET\", data=None, headers={}):\n\n    completed = False\n    while not completed:\n        completed = True\n        try:\n            response, content = doWebRequest(url, method, data, headers)\n        except urllib2.URLError:\n            completed = False\n            waitForURL(url)\n    return response, content", "response": "A wrapper for doWebRequest that waits for a URL to be completed and returns the response and content."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef doWebRequest(url, method=\"GET\", data=None, headers={}):\n\n    # Initialize variables\n    response = None\n    content = None\n    # Find condition that matches request\n    if method == \"HEAD\":\n        request = HEADREQUEST(url, data=data, headers=headers)\n    elif method == \"PUT\":\n        request = PUTREQUEST(url, data=data, headers=headers)\n    elif method == \"DELETE\":\n        request = DELETEREQUEST(url, headers=headers)\n    elif method == \"GET\":\n        request = urllib2.Request(url, headers=headers)\n    # POST?\n    else:\n        request = urllib2.Request(url, data=data, headers=headers)\n    response = urllib2.urlopen(request)\n    if response:\n        content = response.read()\n    return response, content", "response": "A wrapper to mimic the functionality of http2lib but with timeout support"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sendPREMISEvent(webRoot, eventType, agentIdentifier, eventDetail,\n                    eventOutcome, eventOutcomeDetail=None, linkObjectList=[],\n                    eventDate=None, debug=False, eventIdentifier=None):\n    \"\"\"\n    A function to format an event to be uploaded and send it to a particular CODA server\n    in order to register it\n    \"\"\"\n\n    atomID = uuid.uuid1().hex\n    eventXML = createPREMISEventXML(\n        eventType=eventType,\n        agentIdentifier=agentIdentifier,\n        eventDetail=eventDetail,\n        eventOutcome=eventOutcome,\n        outcomeDetail=eventOutcomeDetail,\n        eventIdentifier=eventIdentifier,\n        eventDate=eventDate,\n        linkObjectList=linkObjectList\n    )\n    atomXML = bagatom.wrapAtom(eventXML, id=atomID, title=atomID)\n    atomXMLText = '<?xml version=\"1.0\"?>\\n%s' % etree.tostring(\n        atomXML, pretty_print=True\n    )\n    if debug:\n        print \"Uploading XML to %s\\n---\\n%s\\n---\\n\" % (webRoot, atomXMLText)\n    response = None\n    try:\n        response, content = doWebRequest(webRoot, \"POST\", data=atomXMLText)\n    except urllib2.URLError:\n        pass\n    if not response:\n        waitForURL(webRoot, 60)\n        response, content = doWebRequest(webRoot, \"POST\", data=atomXMLText)\n    if response.code != 201:\n        if debug:\n            tempdir = tempfile.gettempdir()\n            tfPath = os.path.join(\n                tempdir, \"premis_upload_%s.html\" % uuid.uuid1().hex\n            )\n            tf = open(tfPath, \"w\")\n            tf.write(content)\n            tf.close()\n            sys.stderr.write(\n                \"Output from webserver available at %s. Response code %s\" % (\n                    tf.name, response.code\n                )\n            )\n        raise Exception(\n            \"Error uploading PREMIS Event to %s. Response code is %s\" % (\n                webRoot, response.code\n            )\n        )\n    return (response, content)", "response": "This function formats an event to be uploaded and sends it to a particular CODA server and returns a list of the new event objects."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a PREMIS Event XML.", "response": "def createPREMISEventXML(eventType, agentIdentifier, eventDetail, eventOutcome,\n                         outcomeDetail=None, eventIdentifier=None,\n                         linkObjectList=[], eventDate=None):\n    \"\"\"\n    Actually create our PREMIS Event XML\n    \"\"\"\n\n    eventXML = etree.Element(PREMIS + \"event\", nsmap=PREMIS_NSMAP)\n    eventIDXML = etree.SubElement(eventXML, PREMIS + \"eventIdentifier\")\n    eventTypeXML = etree.SubElement(eventXML, PREMIS + \"eventType\")\n    eventTypeXML.text = eventType\n    eventIDTypeXML = etree.SubElement(\n        eventIDXML, PREMIS + \"eventIdentifierType\"\n    )\n    eventIDTypeXML.text = \\\n        \"http://purl.org/net/untl/vocabularies/identifier-qualifiers/#UUID\"\n    eventIDValueXML = etree.SubElement(\n        eventIDXML, PREMIS + \"eventIdentifierValue\"\n    )\n    if eventIdentifier:\n        eventIDValueXML.text = eventIdentifier\n    else:\n        eventIDValueXML.text = uuid.uuid4().hex\n    eventDateTimeXML = etree.SubElement(eventXML, PREMIS + \"eventDateTime\")\n    if eventDate is None:\n        eventDateTimeXML.text = xsDateTime_format(datetime.utcnow())\n    else:\n        eventDateTimeXML.text = xsDateTime_format(eventDate)\n    eventDetailXML = etree.SubElement(eventXML, PREMIS + \"eventDetail\")\n    eventDetailXML.text = eventDetail\n    eventOutcomeInfoXML = etree.SubElement(\n        eventXML, PREMIS + \"eventOutcomeInformation\"\n    )\n    eventOutcomeXML = etree.SubElement(\n        eventOutcomeInfoXML, PREMIS + \"eventOutcome\"\n    )\n    eventOutcomeXML.text = eventOutcome\n    if outcomeDetail:\n        eventOutcomeDetailXML = etree.SubElement(\n            eventOutcomeInfoXML, PREMIS + \"eventOutcomeDetail\"\n        )\n        eventOutcomeDetailNoteXML = etree.SubElement(\n            eventOutcomeDetailXML, PREMIS + \"eventOutcomeDetailNote\"\n        )\n        eventOutcomeDetailNoteXML.text = outcomeDetail\n        # Assuming it's a list of 3-item tuples here [ ( identifier, type, role) ]\n    linkAgentIDXML = etree.SubElement(\n        eventXML, PREMIS + \"linkingAgentIdentifier\")\n    linkAgentIDTypeXML = etree.SubElement(\n        linkAgentIDXML, PREMIS + \"linkingAgentIdentifierType\"\n    )\n    linkAgentIDTypeXML.text = \\\n        \"http://purl.org/net/untl/vocabularies/identifier-qualifiers/#URL\"\n    linkAgentIDValueXML = etree.SubElement(\n        linkAgentIDXML, PREMIS + \"linkingAgentIdentifierValue\"\n    )\n    linkAgentIDValueXML.text = agentIdentifier\n    linkAgentIDRoleXML = etree.SubElement(\n        linkAgentIDXML, PREMIS + \"linkingAgentRole\"\n    )\n    linkAgentIDRoleXML.text = \\\n        \"http://purl.org/net/untl/vocabularies/linkingAgentRoles/#executingProgram\"\n    for linkObject in linkObjectList:\n        linkObjectIDXML = etree.SubElement(\n            eventXML, PREMIS + \"linkingObjectIdentifier\"\n        )\n        linkObjectIDTypeXML = etree.SubElement(\n            linkObjectIDXML, PREMIS + \"linkingObjectIdentifierType\"\n        )\n        linkObjectIDTypeXML.text = linkObject[1]\n        linkObjectIDValueXML = etree.SubElement(\n            linkObjectIDXML, PREMIS + \"linkingObjectIdentifierValue\"\n        )\n        linkObjectIDValueXML.text = linkObject[0]\n        if linkObject[2]:\n            linkObjectRoleXML = etree.SubElement(\n                linkObjectIDXML, PREMIS + \"linkingObjectRole\"\n            )\n            linkObjectRoleXML.text = linkObject[2]\n    return eventXML"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef deleteQueue(destinationRoot, queueArk, debug=False):\n\n    url = urlparse.urljoin(destinationRoot, \"APP/queue/\" + queueArk + \"/\")\n    response, content = doWaitWebRequest(url, \"DELETE\")\n    if response.getcode() != 200:\n        raise Exception(\n            \"Error updating queue %s to url %s.  Response code is %s\\n%s\" %\n            (queueArk, url, response.getcode(), content)\n        )", "response": "Delete an entry from the queue"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef updateQueue(destinationRoot, queueDict, debug=False):\n\n    attrDict = bagatom.AttrDict(queueDict)\n    url = urlparse.urljoin(destinationRoot, \"APP/queue/\" + attrDict.ark + \"/\")\n    queueXML = bagatom.queueEntryToXML(attrDict)\n    urlID = os.path.join(destinationRoot, attrDict.ark)\n    uploadXML = bagatom.wrapAtom(queueXML, id=urlID, title=attrDict.ark)\n    uploadXMLText = '<?xml version=\"1.0\"?>\\n' + etree.tostring(\n        uploadXML, pretty_print=True\n    )\n    if debug:\n        print \"Sending XML to %s\" % url\n        print uploadXMLText\n    try:\n        response, content = doWebRequest(url, \"PUT\", data=uploadXMLText)\n    except:\n        # Sleep a few minutes then give it a second shot before dying\n        time.sleep(300)\n        response, content = doWebRequest(url, \"PUT\", data=uploadXMLText)\n    if response.getcode() != 200:\n        raise Exception(\n            \"Error updating queue %s to url %s.  Response code is %s\\n%s\" %\n            (attrDict.ark, url, response.getcode(), content)\n        )", "response": "Update the queue entry with the values of the queueDict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef table(rows, columns=None, output=None, data_args={}, **kwargs):\n    import pandas\n\n    # Number of columns.\n    num_columns = len(rows[0])\n\n    # Check that each row is the same length.\n    for i,row in enumerate(rows[1:]):\n        if len(row) != num_columns:\n            raise Error(\"Number of columns in row {i_row} ({c_row}) \"\n                        \"does not match number of columns in row 0 ({z_row})\"\n                        .format(i_row=i, c_row=len(row), z_row=num_columns))\n\n    if columns is None:\n        # Default parameters.\n        if \"header\" not in kwargs:\n            kwargs[\"header\"] = False\n    elif len(columns) != num_columns:\n        # Check that number of columns matches number of columns in\n        # rows.\n        raise Error(\"Number of columns in header ({c_header}) does not \"\n                    \"match the number of columns in the data ({c_rows})\"\n                    .format(c_header=len(columns), c_rows=num_columns))\n\n    # Default arguments.\n    if \"index\" not in kwargs:\n        kwargs[\"index\"] = False\n\n    data_args[\"columns\"] = columns\n\n    string = pandas.DataFrame(list(rows), **data_args).to_string(**kwargs)\n    if output is None:\n        return string\n    else:\n        print(string, file=open(output, \"w\"))\n        io.info(\"Wrote\", output)", "response": "Return a formatted string of list of list table data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef templategetter(tmpl):\n    tmpl = tmpl.replace('{', '%(')\n    tmpl = tmpl.replace('}', ')s')\n    return lambda data: tmpl % data", "response": "Returns a function that can be used to get a single - brace template string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a function that sorts the elements of a sequence by the given expression.", "response": "def sorter(expr):\n    \"\"\"\n    This is a sorting function generator that takes an expression optionally\n    prefixed with a \"+\" (ascending, the default) or \"-\" (descending) character.\n\n    >>> sorted([{'a': 12}, {'a': 1}, {'a': 4}], sorter(\"+a\"))\n    [{'a': 1}, {'a': 4}, {'a': 12}]\n    >>> sorted([{'a': 24}, {'a': 16}, {'a': 32}], sorter(\"-a\"))\n    [{'a': 32}, {'a': 24}, {'a': 16}]\n    \"\"\"\n    order = ascending\n    if not callable(expr):\n        if ',' in expr:\n            sorts = map(sorter, expr.split(','))\n            return multisorter(*sorts)\n        if expr[0] == '-':\n            order = descending\n            expr = expr[1:]\n        elif expr[0] == '+':\n            expr = expr[1:]\n        expr = expression(expr)\n    def _sort(a, b):\n        return order(expr(a), expr(b))\n    return _sort"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\niterate over a collection and group its values by a key.", "response": "def organize(data, key):\n    \"\"\"\n    Iterate over a collection and group its values by the provided key\n    function. If the key is not callable (a function), then we wrap it in\n    templategetter(), so that you can simply do:\n\n    >>> organize([{'foo': 1}, {'foo': 2}, {'foo': 1}], \"{foo}\")\n    {'1': [{'foo': 1}, {'foo': 1}], '2': [{'foo': 2}]}\n    \"\"\"\n    groups = {}\n    if not callable(key):\n        key = templategetter(key)\n    for row in data:\n        k = key(row)\n        if groups.has_key(k):\n            groups[k].append(row)\n        else:\n            groups[k] = [row]\n    return groups"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a function that treats the keys of a dictionary as locals and returns the expression", "response": "def expression(expr):\n    \"\"\"\n    Returns a function that treats the keys of a dictionary as locals, and\n    returns the expression, e.g.:\n\n    >>> expression(\"foo\")({'foo': 'bar'})\n    'bar'\n    >>> expression(\"bar + 1\")({'bar': 2})\n    3\n    >>> expression(\"get('foo bar') == 'baz'\")({'foo bar': 'baz'})\n    True\n    \"\"\"\n    if callable(expr):\n        return expr\n\n    if len(expr) == 0:\n        return lambda d: None\n\n    def _expr(data, **kwargs):\n        context = locals()\n        if type(data) is dict:\n            context[\"get\"] = data.get\n        else:\n            context[\"get\"] = lambda attr: getattr(data, attr)\n        context.update(data)\n        context.update(kwargs)\n        return eval(expr, globals(), context)\n    _expr.__doc__ = expr\n    return _expr"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef map_expression(expr):\n    if callable(expr):\n        return expr\n\n    # first, split the string on commas to get key/value bits\n    # XXX: should we allow people to escape commas here?\n    # XXX: what's a good test case for commas in an expression?\n    bits = expr.split(',')\n    # then, split each bit on '=' to get the key and expression strings\n    exprs = [\n        (bit[0].strip(), len(bit) > 1 and bit[1].strip() or '')\n        for bit in [bit.split('=') for bit in bits]\n    ]\n    # then, convert those into a dict where each key indicates an expression()\n    keys = [\n        (k[0], k[1] and expression(k[1]) or None)\n        for k in exprs\n    ]\n    key_dict = dict(keys)\n    def _expr(data, **kwargs):\n        vals = {}\n        for key, expr in key_dict.items():\n            # the SQL * selects all keys\n            if key == '*':\n                vals.update(data)\n                continue\n            # and if there's no expression, just grab the named key\n            elif not expr:\n                vals[key] = data.get(key)\n                continue\n            # otherwise, execute the expression\n            # XXX: this will throw an exception if the named key doesn't exist\n            # in the data dict!\n            else:\n                vals[key] = expr(data, **kwargs)\n        return vals\n    _expr.__doc__ = expr\n    _expr.keys = map(lambda k: k[0], keys)\n    return _expr", "response": "Returns a function that maps a dict to a new dict with unique keys and unique values."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nediting given paths into Umbra.", "response": "def u_edit(*args):\n    \"\"\"\n    Edits given paths into Umbra.\n\n    :param \\*args: Arguments.\n    :type \\*args: \\*\n    :return: Definition success.\n    :rtype: bool\n    \"\"\"\n\n    paths = []\n    for path in args:\n        if not os.path.exists(path):\n            continue\n\n        paths.append(os.path.abspath(path))\n\n    if not paths:\n        return\n\n    connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    connection.connect((socket.gethostbyname(socket.gethostname()), 16384))\n    connection.send(\"{0}<!RE>\".format(\"\\n\".join(COMMAND_TEMPLATE).format(paths)))\n    connection.close()\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _process_exception(e, body, tb):\n    # get informations about message\n    msg = e.message if hasattr(e, \"message\") else str(e)\n    exception_type = str(e.__class__)\n    exception_name = str(e.__class__.__name__)\n\n    properties = pika.BasicProperties(\n        content_type=\"application/text\",\n        delivery_mode=2,\n        headers={\n            \"exception\": msg,\n            \"exception_type\": exception_type,\n            \"exception_name\": exception_name,\n            \"traceback\": tb,\n            \"UUID\": str(uuid.uuid4())\n        }\n    )\n\n    send_message(\"harvester\", body, properties=properties)", "response": "Process informations about exception and send them thru AMQP."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remote(fn, name=None, types=None):\n    if not name:\n        name = fn.__name__\n\n    fn.remote = {\"name\": name, \"types\": types}\n    return fn", "response": "Decorator that adds a remote attribute to a function"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef call(self, function, args=(), kwargs={}):\n        return self.functions[function](*args, **kwargs)", "response": "Call a method given some args and kwargs."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a function to the dispatcher s functions list", "response": "def add(self, fn, name=None):\n        \"\"\"Add a function that the dispatcher will know about.\n\n        fn -- a callable object\n        name -- optional alias for the function\n\n        \"\"\"\n        if not name:\n            name = fn.__name__\n        self.functions[name] = fn"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef exit(status=0):\n    if status == 0:\n        lab.io.printf(lab.io.Colours.GREEN, \"Done.\")\n    else:\n        lab.io.printf(lab.io.Colours.RED, \"Error {0}\".format(status))\n    sys.exit(status)", "response": "Terminate the program with the given status code."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstarting the socket server.", "response": "def start(self):\n        \"\"\"Start the socket server.\n       \n        The socket server will begin accepting incoming connections.\n        \n        \"\"\"\n        if self._shutdown:\n            raise ShutdownError()\n\n        self.read_watcher.start()\n        logger.info(\"server started listening on {}\".format(self.address))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _readable(self, watcher, events):\n        protocol = self.factory.build(self.loop)\n        try:\n            sock, address = self.sock.accept()\n            connection = Connection(self.loop, sock, address, protocol, self)\n            self.connections.add(connection)\n            connection.make_connection()\n            logger.debug(\"added connection\")\n        except IOError as e:\n            self.shutdown(e)", "response": "Called by the pyev watcher when the socket is readable."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling by the connections themselves when they have been closed.", "response": "def remove_connection(self, connection):\n        \"\"\"Called by the connections themselves when they have been closed.\"\"\"\n        if not self._closing:\n            self.connections.remove(connection)\n            logger.debug(\"removed connection\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __initialize_tree(self, theme):\n\n        for item in sorted(theme):\n            current_node = self.__root_node\n            for format in item.split(\".\"):\n                nodes = [node for node in current_node.children if node.name == format]\n                format_node = foundations.common.get_first_item(nodes)\n                if not format_node:\n                    format_node = FormatNode(format, format=theme[item])\n                    current_node.add_child(format_node)\n                current_node = format_node", "response": "Initializes the object formats tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_formats(self, node, path=(), formats=None):\n\n        if formats == None:\n            formats = []\n\n        for child in node.children:\n            self.list_formats(child, path + (child.name,), formats)\n        path and formats.append(\".\".join(path))\n        return sorted(formats)", "response": "Lists the object formats in sorted order."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_format(self, name):\n\n        formats = [format for format in self.list_formats(self.__root_node) if format in name]\n        if not formats:\n            return QTextCharFormat()\n\n        name = max(formats)\n\n        format = None\n        current_node = self.__root_node\n        for selector in name.split(\".\"):\n            nodes = [node for node in current_node.children if node.name == selector]\n            format_node = nodes and nodes[0] or None\n            if not format_node:\n                break\n\n            current_node = format_node\n\n            if not format_node.format:\n                continue\n\n            format = format_node.format\n        return format", "response": "Returns the closest format or closest parent format associated to given name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the value of the formats attribute.", "response": "def formats(self, value):\n        \"\"\"\n        Setter for **self.__formats** attribute.\n\n        :param value: Attribute value.\n        :type value: FormatsTree\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is FormatsTree, \"'{0}' attribute: '{1}' type is not 'FormatsTree'!\".format(\n                \"formats\", value)\n        self.__formats = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rules(self, value):\n\n        if value is not None:\n            assert type(value) in (tuple, list), \"'{0}' attribute: '{1}' type is not 'tuple' or 'list'!\".format(\n                \"rules\", value)\n        self.__rules = value", "response": "Setter for **self. __rules** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef highlight_text(self, text, start, end):\n\n        for rule in self.__rules:\n            index = rule.pattern.indexIn(text, start)\n            while index >= start and index < end:\n                length = rule.pattern.matchedLength()\n                format = self.formats.get_format(rule.name) or self.formats.get_format(\"default\")\n                self.setFormat(index, min(length, end - index), format)\n                index = rule.pattern.indexIn(text, index + length)\n        return True", "response": "Highlights given text.\n\n        :param text: Text.\n        :type text: QString\n        :param start: Text start index.\n        :type start: int\n        :param end: Text end index.\n        :type end: int\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the theme of the object.", "response": "def theme(self, value):\n        \"\"\"\n        Setter for **self.__theme** attribute.\n\n        :param value: Attribute value.\n        :type value: dict\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is dict, \"'{0}' attribute: '{1}' type is not 'dict'!\".format(\"theme\", value)\n        self.__theme = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhighlighting the given block.", "response": "def highlightBlock(self, block):\n        \"\"\"\n        Reimplements the :meth:`AbstractHighlighter.highlightBlock` method.\n\n        :param block: Text block.\n        :type block: QString\n        \"\"\"\n\n        self.highlight_text(block, 0, len(block))\n        self.setCurrentBlockState(0)\n\n        state = 1\n        for rule in self.rules:\n            if re.match(\"comment\\.block\\.[\\w\\.]*start\", rule.name):\n                format = self.formats.get_format(rule.name) or self.formats.get_format(\"default\")\n                if self.highlight_multiline_block(block, rule.pattern,\n                                                  foundations.common.get_first_item([item for item in self.rules\n                                                                                     if item.name == rule.name.replace(\n                                                              \"start\", \"end\")]).pattern, state, format):\n                    break\n                state += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef highlight_multiline_block(self, block, start_pattern, end_pattern, state, format):\n\n        if self.previousBlockState() == state:\n            start = 0\n            extend = 0\n        else:\n            start = start_pattern.indexIn(block)\n            extend = start_pattern.matchedLength()\n\n        while start >= 0:\n            end = end_pattern.indexIn(block, start + extend)\n            if end >= extend:\n                length = end - start + extend + end_pattern.matchedLength()\n                self.setCurrentBlockState(0)\n            else:\n                self.setCurrentBlockState(state)\n                length = block.length() - start + extend\n            self.setFormat(start, length, format)\n            start = start_pattern.indexIn(block, start + length)\n\n        if self.currentBlockState() == state:\n            return True\n        else:\n            return False", "response": "Highlights given multiline text block."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrender the field as a select element.", "response": "def as_select(self, _items=None, **kwargs):\n        \"\"\"Render the field as a `<select>` element.\n\n        :param **kwargs:\n            Named paremeters used to generate the HTML attributes of each item.\n            It follows the same rules as `get_html_attrs`\n\n        \"\"\"\n        attrs = self.extra.copy()\n        attrs.update(kwargs)\n        attrs['name'] = self.name\n        if not self.optional:\n            attrs['required'] = True\n        html = [u'<select %s>' % get_html_attrs(attrs)]\n        values = [self.to_string(**attrs)] or []\n        items = _items or self.items\n\n        for item in items:\n            if isinstance(item, list):\n                html.extend(self._render_optgroup(item, values))\n            else:\n                html.append(self._render_option(item, values))\n        html.append(u'</select>')\n\n        return Markup('\\n'.join(html))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef as_checks(self, tmpl=TMPL, _items=None, **kwargs):\n        attrs = self.extra.copy()\n        attrs.update(kwargs)\n        attrs['type'] = 'checkbox'\n        attrs['name'] = self.name\n        html = []\n        tmpl = to_unicode(tmpl)\n        values = self.to_string(**attrs) or []\n        items = _items or self.items\n\n        for item in items:\n            if isinstance(item, list):\n                html.extend(self._render_fieldset(item, attrs, values, tmpl))\n            else:\n                html.append(self._render_item(item, attrs, values, tmpl))\n        return Markup('\\n'.join(html))", "response": "Render the field as a series of checkboxes using the tmpl parameter as the template for each item."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a function that generates hashed paths for file uploads.", "response": "def make_upload_to(base_path, by_fk_field=None):\n    \"\"\"\n    Creates ``upload_to`` function that generates hashed paths\n    for file uploads.\n\n    Filename hash is created from instance.pk and current time.\n    \n    Generated paths consist of:\n\n    {base_path}/{optional related field id/value hash}/{hashed filename}.{ext}\n\n    :param base_path: Base path for upload\n    :type base_path: str or unicode\n    :type by_fk_field: str or unicode\n    :param by_fk_field: Optional field name of related (parent) object.\n                            Its pk hash will be part of a generated path.\n    \"\"\"\n\n    if not base_path.endswith(\"/\"):\n        base_path += \"/\"\n\n    def get_field_value(field):\n        if isinstance(field, six.string_types + (int,)):\n            return field\n        elif isinstance(field, models.Model):\n            value = field.pk\n            assert value\n            return value\n\n    def upload_to(instance, filename):\n        \"\"\"\n        Returns upload path for FileField\n\n        :type instance: :class:`django.db.models.Model`\n        :param str filename:\n        :rtype: str\n        \"\"\"\n        extension = os.path.splitext(filename)[-1].lower()\n        salt, hash_instance = generate_hash(instance.pk)\n        salt, hash_time = generate_hash(tznow().isoformat())\n\n        fk_subdir = \"\"\n        if by_fk_field:\n            fk_field = getattr(instance, by_fk_field)\n            fk_value = get_field_value(fk_field)\n            salt, hash_fk = generate_hash(force_str(fk_value), salt=\"\")\n            fk_subdir = \"{hash}/\".format(hash=hash_fk[:6])\n\n        return \"{path}{fk_subdir}{hash}{extension}\".format(\n            path=base_path,\n            fk_subdir=fk_subdir,\n            hash=hash_instance[:10] + hash_time[:6],\n            extension=extension\n        )\n    return upload_to"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __parse_direct_mention(self, message_text):\n        matches = re.search(MENTION_REGEX, message_text)\n        # the first group contains the username, the second group contains the remaining message\n        return (matches.group(1), listify(matches.group(2).strip())) if matches else (None, None)", "response": "Parses the direct mention from the message text."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds files recursively in the root path using provided extensions.", "response": "def _find_files(self):\n        \"\"\"Find files recursively in the root path\n        using provided extensions.\n\n        :return: list of absolute file paths\n        \"\"\"\n        files = []\n        for ext in self.extensions:\n            ext_files = util.find_files(self.root, \"*\" + ext)\n            log.debug(\"found {} '*{}' files in '{}'\".format(\n                len(ext_files), ext, self.root)\n            )\n            files.extend(ext_files)\n        return files"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _clean_file(self, filename):\n        if not os.path.exists(filename):\n            return\n        self.announce(\"removing '{}'\".format(filename))\n        if not self.dry_run:\n            os.remove(filename)", "response": "Clean a file if exists and not in dry run"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncleans a directory if exists and not in dry run", "response": "def _clean_directory(self, name):\n        \"\"\"Clean a directory if exists and not in dry run\"\"\"\n        if not os.path.exists(name):\n            return\n        self.announce(\n            \"removing directory '{}' and all its contents\".format(name)\n        )\n        if not self.dry_run:\n            rmtree(name, True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_compiled_files(self):\n        files = self._find_files()\n        self.announce(\n            \"found '{}' compiled python files in '{}'\".format(\n                len(files), self.root\n            )\n        )\n        return files", "response": "Find compiled Python files recursively in the root path\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding compiled class files recursively in the root path", "response": "def find_class_files(self):\n        \"\"\"Find compiled class files recursively in the root path\n\n        :return: list of absolute file paths\n        \"\"\"\n        files = self._find_files()\n        self.announce(\n            \"found '{}' compiled class files in '{}'\".format(\n                len(files), self.root\n            )\n        )\n        return files"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclean extra files and directories specified by get_extra_paths", "response": "def clean_extra(self):\n        \"\"\"Clean extra files/directories specified by get_extra_paths()\"\"\"\n        extra_paths = self.get_extra_paths()\n        for path in extra_paths:\n            if not os.path.exists(path):\n                continue\n            if os.path.isdir(path):\n                self._clean_directory(path)\n            else:\n                self._clean_file(path)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting header for this node.", "response": "def set_header(self, name, format, *args):\n        \"\"\"\n        Set node header; these are provided to other nodes during discovery\nand come in each ENTER message.\n        \"\"\"\n        return lib.zyre_set_header(self._as_parameter_, name, format, *args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_endpoint(self, format, *args):\n        return lib.zyre_set_endpoint(self._as_parameter_, format, *args)", "response": "Set the local node s local node s local node s local node s local node s local node s local node s local node s ephemeral TCP port and broadcasts the local node s local node s local node s ephemeral TCP port and broadcasts the local node s local node s local node s ephemeral TCP port."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gossip_bind(self, format, *args):\n        return lib.zyre_gossip_bind(self._as_parameter_, format, *args)", "response": "Bind gossip to other nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconnects to other nodes.", "response": "def gossip_connect(self, format, *args):\n        \"\"\"\n        Set-up gossip discovery of other nodes. A node may connect to multiple\nother nodes, for redundancy paths. For details of the gossip network\ndesign, see the CZMQ zgossip class.\n        \"\"\"\n        return lib.zyre_gossip_connect(self._as_parameter_, format, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconnect to a gossip curve", "response": "def gossip_connect_curve(self, public_key, format, *args):\n        \"\"\"\n        Set-up gossip discovery with CURVE enabled.\n        \"\"\"\n        return lib.zyre_gossip_connect_curve(self._as_parameter_, public_key, format, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef whisper(self, peer, msg_p):\n        return lib.zyre_whisper(self._as_parameter_, peer, byref(czmq.zmsg_p.from_param(msg_p)))", "response": "Send a message to a single peer"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef shout(self, group, msg_p):\n        return lib.zyre_shout(self._as_parameter_, group, byref(czmq.zmsg_p.from_param(msg_p)))", "response": "Send a message to a named group"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend formatted string to a single peer specified as UUID string", "response": "def whispers(self, peer, format, *args):\n        \"\"\"\n        Send formatted string to a single peer specified as UUID string\n        \"\"\"\n        return lib.zyre_whispers(self._as_parameter_, peer, format, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef shouts(self, group, format, *args):\n        return lib.zyre_shouts(self._as_parameter_, group, format, *args)", "response": "Send formatted string to a named group"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a zlist of peers of a group.", "response": "def peers_by_group(self, name):\n        \"\"\"\n        Return zlist of current peers of this group.\n        \"\"\"\n        return czmq.Zlist(lib.zyre_peers_by_group(self._as_parameter_, name), True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef peer_header_value(self, peer, name):\n        return return_fresh_string(lib.zyre_peer_header_value(self._as_parameter_, peer, name))", "response": "Get the value of a header of a conected peer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrequiring a peer to be connected to a specific endpoint", "response": "def require_peer(self, uuid, endpoint, public_key):\n        \"\"\"\n        Explicitly connect to a peer\n        \"\"\"\n        return lib.zyre_require_peer(self._as_parameter_, uuid, endpoint, public_key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sign(self, msg):\n        '''\n        msg-->str or bytes\n        Returns-->bytes\n        '''\n        if self.__signingkey is None:\n            raise KeyTypeError('Wrong key type for operation')\n        sig = ffi.new(C_SIGNATURE)\n        lib.ed25519_SignMessage(\n            sig, self.__signingkey, ffi.NULL, msg, len(msg))\n        return ffi.get_bytes(sig)", "response": "Signs a message with the key associated with this instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef verify(self, sig, msg):\n        '''\n        sig-->bytes\n        msg-->str or bytes\n        Returns-->boolean\n        '''\n        return lib.ed25519_VerifySignature(\n            sig, self.__verifyingkey, msg, len(msg)) == 1", "response": "sig-->bytes\n        msg-->str or bytes\n        Returns-->boolean"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_ecdh_key(self, other):\n        '''\n        other-->Key25519 instance\n        '''\n        if self.__secretkey is None:\n            raise KeyTypeError('Wrong key type for operation')\n        # Copy because curve25519_dh_CreateSharedKey changes secretkey\n        tmp_secretkey = ffi.new(C_SECRETKEY, self.secretkey)\n        ecdh_key = ffi.new(C_SHAREDKEY)\n        lib.curve25519_dh_CreateSharedKey(\n            ecdh_key, other.pubkey, tmp_secretkey)\n        del tmp_secretkey\n        return ffi.get_bytes(ecdh_key)", "response": "Get the ECDH key for this key and another key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget information for a specific domain by either domain_id or domain.", "response": "def info(self, domain_id=None, domain=None):\n        '''Get information for a specific domain\n\n        Specify a domain by either ``domain_id`` or ``domain``, if both are\n        specified, then ``domain_id`` is used.\n        \n        :param str domain_id: Domain ID\n        :param str domain: Domain\n        :return: Domain object\n        '''\n        if domain_id != None:\n            r = self._api.do_post('Domain.Info', domain_id=domain_id)\n        elif domain != None:\n            r = self._api.do_post('Domain.Info', domain=domain)\n        else:\n            raise DNSPodError('Both domain_id and domain are not specificed')\n        return Domain(r['domain'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvisits the right method of the child class according to the node.", "response": "def visit(self, node):\n        \"\"\"Visit the right method of the child class according to the node.\"\"\"\n        method = 'visit_' + type(node).__name__\n        return getattr(self, method, self.fallback)(node)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main(args, stop=False):\n    daemon = AMQPDaemon(\n        con_param=getConParams(\n            settings.RABBITMQ_CALIBRE_VIRTUALHOST\n        ),\n        queue=settings.RABBITMQ_CALIBRE_INPUT_QUEUE,\n        out_exch=settings.RABBITMQ_CALIBRE_EXCHANGE,\n        out_key=settings.RABBITMQ_CALIBRE_OUTPUT_KEY,\n        react_fn=reactToAMQPMessage,\n        glob=globals()                # used in deserializer\n    )\n\n    if not stop and args.foreground:  # run at foreground\n        daemon.run()\n    else:\n        daemon.run_daemon()", "response": "Main function for the main function of the daemon."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef postprocess_periodical(marc_xml, mods, uuid, counter, url):\n    dom = double_linked_dom(mods)\n\n    # TODO: Add more postprocessing\n\n    add_missing_xml_attributes(dom, counter)\n\n    if uuid:\n        add_uuid(dom, uuid)\n\n    return dom.prettify()", "response": "This function is used to postprocess the periodical publications in the Aleph record."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the language of the object.", "response": "def language(self, value):\n        \"\"\"\n        Setter for **self.__language** attribute.\n\n        :param value: Attribute value.\n        :type value: unicode\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is unicode, \"'{0}' attribute: '{1}' type is not 'unicode'!\".format(\n                \"language\", value)\n        self.__language = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the tokens cache.", "response": "def __set_cache(self, tokens):\n        \"\"\"\n        Sets the tokens cache.\n\n        :param tokens: Completer tokens list.\n        :type tokens: tuple or list\n        \"\"\"\n\n        if DefaultCompleter._DefaultCompleter__tokens.get(self.__language):\n            return\n\n        DefaultCompleter._DefaultCompleter__tokens[self.__language] = tokens"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_model(self, words):\n\n        extended_words = DefaultCompleter._DefaultCompleter__tokens[self.__language][:]\n        extended_words.extend((word for word in set(words)\n                               if word not in DefaultCompleter._DefaultCompleter__tokens[self.__language]))\n        self.setModel(QStringListModel(extended_words))\n        return True", "response": "Updates the completer model with the given words."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getEdges(self, personID, nextStageIndex=0):\n        self._connection._beginMessage(\n            tc.CMD_GET_PERSON_VARIABLE, tc.VAR_EDGES, personID, 1 + 4)\n        self._connection._string += struct.pack(\"!Bi\",\n                                                tc.TYPE_INTEGER, nextStageIndex)\n        return self._connection._checkResult(tc.CMD_GET_PERSON_VARIABLE,\n                                             tc.VAR_EDGES, personID).readStringList()", "response": "Returns a list of all edges in the nth next stage."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the type of the next stage that the person is in.", "response": "def getStage(self, personID, nextStageIndex=0):\n        \"\"\"getStage(string, int) -> int\n        Returns the type of the nth next stage\n          0 for not-yet-departed\n          1 for waiting\n          2 for walking\n          3 for driving\n        nextStageIndex 0 retrieves value for the current stage.\n        nextStageIndex must be lower then value of getRemainingStages(personID)\n        \"\"\"\n        self._connection._beginMessage(\n            tc.CMD_GET_PERSON_VARIABLE, tc.VAR_STAGE, personID, 1 + 4)\n        self._connection._string += struct.pack(\"!Bi\",\n                                                tc.TYPE_INTEGER, nextStageIndex)\n        return self._connection._checkResult(tc.CMD_GET_PERSON_VARIABLE,\n                                             tc.VAR_STAGE, personID).readInt()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef removeStages(self, personID):\n        # remove all stages after the current and then abort the current stage\n        while self.getRemainingStages(personID) > 1:\n            self.removeStage(personID, 1)\n        self.removeStage(personID, 0)", "response": "remove all stages of the person"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add(self, personID, edgeID, pos, depart=DEPART_NOW, typeID=\"DEFAULT_PEDTYPE\"):\n        if depart > 0:\n            depart *= 1000\n        self._connection._beginMessage(tc.CMD_SET_PERSON_VARIABLE, tc.ADD, personID,\n                                       1 + 4 + 1 + 4 + len(typeID) + 1 + 4 + len(edgeID) + 1 + 4 + 1 + 8)\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 4)\n        self._connection._packString(typeID)\n        self._connection._packString(edgeID)\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_INTEGER, depart)\n        self._connection._string += struct.pack(\"!Bd\", tc.TYPE_DOUBLE, pos)\n        self._connection._sendExact()", "response": "This function inserts a new person into the simulation at the given edge and position."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef appendWaitingStage(self, personID, duration, description=\"waiting\", stopID=\"\"):\n        duration *= 1000\n        self._connection._beginMessage(tc.CMD_SET_PERSON_VARIABLE, tc.APPEND_STAGE, personID,\n                                       1 + 4 +  # compound\n                                       1 + 4 +  # stage type\n                                       1 + 4 +  # duration\n                                       1 + 4 + len(description) +\n                                       1 + 4 + len(stopID))\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 4)\n        self._connection._string += struct.pack(\n            \"!Bi\", tc.TYPE_INTEGER, tc.STAGE_WAITING)\n        self._connection._string += struct.pack(\"!Bi\",\n                                                tc.TYPE_INTEGER, duration)\n        self._connection._packString(description)\n        self._connection._packString(stopID)\n        self._connection._sendExact()", "response": "Appends a waiting stage to the plan of the given personID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef appendWalkingStage(self, personID, edges, arrivalPos, duration=-1, speed=-1, stopID=\"\"):\n        if duration is not None:\n            duration *= 1000\n\n        if isinstance(edges, str):\n            edges = [edgeList]\n        self._connection._beginMessage(tc.CMD_SET_PERSON_VARIABLE, tc.APPEND_STAGE, personID,\n                                       1 + 4 +  # compound\n                                       1 + 4 +  # stageType\n                                       1 + 4 + \\\n                                       sum(map(len, edges)) + 4 * len(edges) +\n                                       1 + 8 +  # arrivalPos\n                                       1 + 4 +  # duration\n                                       1 + 8 +  # speed\n                                       1 + 4 + len(stopID)\n                                       )\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 6)\n        self._connection._string += struct.pack(\n            \"!Bi\", tc.TYPE_INTEGER, tc.STAGE_WALKING)\n        self._connection._packStringList(edges)\n        self._connection._string += struct.pack(\"!Bd\",\n                                                tc.TYPE_DOUBLE, arrivalPos)\n        self._connection._string += struct.pack(\"!Bi\",\n                                                tc.TYPE_INTEGER, duration)\n        self._connection._string += struct.pack(\"!Bd\", tc.TYPE_DOUBLE, speed)\n        self._connection._packString(stopID)\n        self._connection._sendExact()", "response": "This method appends a walking stage to the plan of the person. The walking stage is a simple sequence of strings. The walking speed is taken from the duration parameter. The stopID parameter can be specified to specify the stop ID of the walking stage."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef appendDrivingStage(self, personID, toEdge, lines, stopID=\"\"):\n        self._connection._beginMessage(tc.CMD_SET_PERSON_VARIABLE, tc.APPEND_STAGE, personID,\n                                       1 + 4 +  # compound\n                                       1 + 4 +  # stage type\n                                       1 + 4 + len(toEdge) +\n                                       1 + 4 + len(lines) +\n                                       1 + 4 + len(stopID))\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 4)\n        self._connection._string += struct.pack(\n            \"!Bi\", tc.TYPE_INTEGER, tc.STAGE_DRIVING)\n        self._connection._packString(toEdge)\n        self._connection._packString(lines)\n        self._connection._packString(stopID)\n        self._connection._sendExact()", "response": "This method appends a driving stage to the plan of the given personID. The toEdge parameter should be a space - separated list of line ids that are used to identify the driving stage. The stopID parameter should be a space - separated list of line ids that are used to identify the driving stage."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove the nth next stage from the current stage.", "response": "def removeStage(self, personID, nextStageIndex):\n        \"\"\"removeStage(string, int)\n        Removes the nth next stage\n        nextStageIndex must be lower then value of getRemainingStages(personID)\n        nextStageIndex 0 immediately aborts the current stage and proceeds to the next stage\n        \"\"\"\n        self._connection._beginMessage(\n            tc.CMD_SET_PERSON_VARIABLE, tc.REMOVE_STAGE, personID, 1 + 4)\n        self._connection._string += struct.pack(\"!Bi\",\n                                                tc.TYPE_INTEGER, nextStageIndex)\n        self._connection._sendExact()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rerouteTraveltime(self, personID):\n        self._connection._beginMessage(\n            tc.CMD_SET_PERSON_VARIABLE, tc.CMD_REROUTE_TRAVELTIME, personID, 1 + 4)\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 0)\n        self._connection._sendExact()", "response": "rerouteTraveltime(string) -> None Reroutes a pedestrian (walking person)."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the maximum speed in m/s for the named person.", "response": "def setSpeed(self, personID, speed):\n        \"\"\"setSpeed(string, double) -> None\n\n        Sets the maximum speed in m/s for the named person for subsequent step.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_PERSON_VARIABLE, tc.VAR_SPEED, personID, speed)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setType(self, personID, typeID):\n        self._connection._sendStringCmd(\n            tc.CMD_SET_PERSON_VARIABLE, tc.VAR_TYPE, personID, typeID)", "response": "Sets the id of the type of the person."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the width of the person.", "response": "def setWidth(self, personID, width):\n        \"\"\"setWidth(string, double) -> None\n\n        Sets the width in m for this person.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_PERSON_VARIABLE, tc.VAR_WIDTH, personID, width)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the height of the person in m for this person.", "response": "def setHeight(self, personID, height):\n        \"\"\"setHeight(string, double) -> None\n\n        Sets the height in m for this person.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_PERSON_VARIABLE, tc.VAR_HEIGHT, personID, height)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setLength(self, personID, length):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_PERSON_VARIABLE, tc.VAR_LENGTH, personID, length)", "response": "Sets the length in m for the given person."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the minimum gap for a person.", "response": "def setMinGap(self, personID, minGap):\n        \"\"\"setMinGap(string, double) -> None\n\n        Sets the offset (gap to front person if halting) for this vehicle.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_PERSON_VARIABLE, tc.VAR_MINGAP, personID, minGap)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setColor(self, personID, color):\n        self._connection._beginMessage(\n            tc.CMD_SET_PERSON_VARIABLE, tc.VAR_COLOR, personID, 1 + 1 + 1 + 1 + 1)\n        self._connection._string += struct.pack(\"!BBBBB\", tc.TYPE_COLOR, int(\n            color[0]), int(color[1]), int(color[2]), int(color[3]))\n        self._connection._sendExact()", "response": "sets the color for the given person ID."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef quote_datetime(self, value):\n        if value:\n            if isinstance(value, type_check):\n                self._quote_datetime = parse(value)\n            elif isinstance(value, datetime.datetime):\n                self._quote_datetime = value", "response": "Set the quote_datetime attribute of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls after successfully signed on to the server.", "response": "def signedOn(self):\n        \"\"\"Called after successfully signing on to the server.\"\"\"\n        log.info(\"Signed on as %s.\", self.nickname)\n        if not self.password:\n            # We aren't wating for auth, join all the channels\n            self.joinChannels()\n        else:\n            self.msg(\"NickServ\", \"IDENTIFY %s\" % self.password)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef process_action(self, raw_user, channel, raw_message):\n        log.info(\"%s %s %s\", channel, raw_user, raw_message)\n\n        if not raw_user:\n            # ignore server messages\n            return\n\n        # This monster of a regex extracts msg and target from a message, where\n        # the target may not be there, and the target is a valid irc name.\n        # Valid ways to target someone are \"<nick>: ...\" and \"<nick>, ...\"\n        target, message = re.match(\n            r'^(?:([a-z_\\-\\[\\]\\\\^{}|`]'  # First letter can't be a number\n            '[a-z0-9_\\-\\[\\]\\\\^{}|`]*)'   # The rest can be many things\n            '[:,] )? *(.*)$',            # The actual message\n            raw_message, re.I).groups()\n\n        pm = channel == self.nickname\n        if pm:\n            directed = True\n        if target:\n            if target.lower() == self.nickname.lower():\n                directed = True\n            else:\n                directed = False\n                message = '{0}: {1}'.format(target, message)\n        else:\n            directed = False\n        if message.startswith('!'):\n            message = message[1:]\n            directed = True\n\n        if directed:\n            message = message.rstrip()\n\n        try:\n            user, mask = raw_user.split('!', 1)\n        except ValueError:\n            user = raw_user\n            mask = ''\n\n        comm = {\n            'raw_message': raw_message,\n            'message': message,\n            'raw_user': raw_user,\n            'user': user,\n            'mask': mask,\n            'target': target,\n            'channel': channel,\n            'directed': directed,\n            'pm': pm,\n        }\n\n        self.dispatch('chat', 'message', comm)\n\n        self.factory.history.setdefault(\n            channel, deque(maxlen=100)).append(comm)", "response": "Called when a message is received from a channel or user."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connectionLost(self, reason):\n        self.factory.loader.db.session.commit()\n        if reactor.running:\n            reactor.stop()", "response": "Called when the connection is lost to the server."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling when I see another user get kicked.", "response": "def userKicked(self, kickee, channel, kicker, message):\n        \"\"\"Called when I see another user get kicked.\"\"\"\n        self.dispatch('population', 'userKicked', kickee, channel, kicker,\n                      message)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndispatching an event to all listening plugins.", "response": "def dispatch(self, category, func, *args):\n        \"\"\"Dispatch an event to all listening plugins.\"\"\"\n        self.factory.loader.runPlugins(category, func, self, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks whether a plugin s dependencies are satisfied.", "response": "def dependencies_satisfied(self, plugin):\n        \"\"\"\n        Checks whether a plugin's dependencies are satisfied.\n\n        Logs an error if there is an unsatisfied dependencies\n        Returns: Bool\n        \"\"\"\n        for depends in plugin.dependencies:\n            if depends not in self.config['plugins']:\n                log.error(\"{0} depends on {1}, but {1} wasn't in the \"\n                          \"config file. To use {0}, install {1} and add \"\n                          \"it to the config.\".format(plugin.name, depends))\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns the specified set of plugins against a given protocol.", "response": "def runPlugins(self, category, func, protocol, *args):\n        \"\"\"\n        Run the specified set of plugins against a given protocol.\n        \"\"\"\n        # Plugins are already sorted by priority\n        for plugin in self.plugins:\n            # If a plugin throws an exception, we should catch it gracefully.\n            try:\n                event_listener = getattr(plugin, func)\n            except AttributeError:\n                # If the plugin doesn't implement the event, do nothing\n                pass\n            else:\n                try:\n                    stop = event_listener(protocol, *args)\n                    if stop:\n                        break\n                except Exception:\n                    # A plugin should not be able to crash the bot.\n                    # Catch and log all errors.\n                    traceback.print_exc()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef initialize_ui(self):\n\n        LOGGER.debug(\"> Initializing '{0}' Component ui.\".format(self.__class__.__name__))\n\n        umbra.ui.common.set_toolBox_height(self.Preferences_Manager_toolBox)\n\n        self.__Logging_Formatters_comboBox_set_ui()\n        self.__Verbose_Level_comboBox_set_ui()\n        self.__Restore_Geometry_On_Layout_Change_checkBox_set_ui()\n\n        # Signals / Slots.\n        self.__engine.verbosity_level_changed.connect(self.__engine__verbosity_level_changed)\n        self.Logging_Formatters_comboBox.activated.connect(self.__Logging_Formatters_comboBox__activated)\n        self.Verbose_Level_comboBox.activated.connect(self.__Verbose_Level_comboBox__activated)\n        self.Restore_Geometry_On_Layout_Change_checkBox.stateChanged.connect(\n            self.__Restore_Geometry_On_Layout_Change_checkBox__stateChanged)\n\n        self.initialized_ui = True\n        return True", "response": "Initializes the Component ui."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef uninitialize_ui(self):\n\n        raise foundations.exceptions.ProgrammingError(\n            \"{0} | '{1}' Component ui cannot be uninitialized!\".format(self.__class__.__name__, self.name))", "response": "Uninitializes the Component ui."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_widget(self):\n\n        LOGGER.debug(\"> Adding '{0}' Component Widget.\".format(self.__class__.__name__))\n\n        self.__engine.addDockWidget(Qt.DockWidgetArea(self.__dock_area), self)\n\n        return True", "response": "Adds the Component Widget to the engine."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets ui to available verbose levels.", "response": "def __Verbose_Level_comboBox_set_ui(self):\n        \"\"\"\n        Fills **Verbose_Level_ComboBox** Widget.\n        \"\"\"\n\n        self.Verbose_Level_comboBox.clear()\n        LOGGER.debug(\"> Available verbose levels: '{0}'.\".format(Constants.verbosity_labels))\n        self.Verbose_Level_comboBox.insertItems(0, QStringList(Constants.verbosity_labels))\n        self.__engine.verbosity_level = foundations.common.get_first_item(\n            self.__settings.get_key(\"Settings\", \"verbosity_level\").toInt())\n        self.Verbose_Level_comboBox.setCurrentIndex(self.__engine.verbosity_level)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the Restore_Geometry_On_Layout_Change_checkBox Widget.", "response": "def __Restore_Geometry_On_Layout_Change_checkBox_set_ui(self):\n        \"\"\"\n        Sets the **Restore_Geometry_On_Layout_Change_checkBox** Widget.\n        \"\"\"\n\n        # Adding settings key if it doesn't exists.\n        self.__settings.get_key(\"Settings\", \"restore_geometry_on_layout_change\").isNull() and \\\n        self.__settings.set_key(\"Settings\", \"restore_geometry_on_layout_change\", Qt.Unchecked)\n\n        restore_geometry_on_layout_change = foundations.common.get_first_item(\n            self.__settings.get_key(\"Settings\", \"restore_geometry_on_layout_change\").toInt())\n        LOGGER.debug(\"> Setting '{0}' with value '{1}'.\".format(\"Restore_Geometry_On_Layout_Change_checkBox\",\n                                                                restore_geometry_on_layout_change))\n        self.Restore_Geometry_On_Layout_Change_checkBox.setCheckState(restore_geometry_on_layout_change)\n        self.__engine.layouts_manager.restore_geometry_on_layout_change = True if restore_geometry_on_layout_change else False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the logging formatter.", "response": "def set_logging_formatter(self):\n        \"\"\"\n        Sets the logging formatter.\n        \"\"\"\n\n        for handler in (RuntimeGlobals.logging_console_handler,\n                        RuntimeGlobals.logging_file_handler,\n                        RuntimeGlobals.logging_session_handler):\n            handler and handler.setFormatter(\n                RuntimeGlobals.logging_formatters[RuntimeGlobals.logging_active_formatter])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an envvar profile instance with the specified root and profile properties.", "response": "def envvar_profile(\n    profile_root: str,\n    profile_properties: typing.Dict[str, typing.Optional[str]] = None,\n    **profile_properties_as_kwargs,\n) -> EnvvarProfile:\n    \"\"\"\n    Creates an EnvvarProfile instance without the need for an explicit declaration of the envvar profile class.\n    \"\"\"\n    if profile_properties:\n        profile_properties_as_kwargs.update(profile_properties)\n    return type(f\"{profile_root}Profile\", (EnvvarProfile,), {\n        \"profile_root\": profile_root.lower(),\n        \"profile_properties\": list(profile_properties_as_kwargs.keys()),\n        **{\n            k: EnvvarProfileProperty(name=k, default=v, type_=str)\n            for k, v in profile_properties_as_kwargs.items()\n        },\n    })()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload an environment variable profile from a frozen set of values.", "response": "def load(\n        cls, name=None, parent_name=None, profile_is_live=False, values=None, defaults=None\n    ) -> \"EnvvarProfile\":\n        \"\"\"\n        Get a loaded frozen instance of a specific profile.\n        \"\"\"\n        instance = cls(\n            name=name,\n            parent_name=parent_name,\n            profile_is_live=profile_is_live,\n            values=values,\n            defaults=defaults,\n        )\n        instance._do_load()\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_prop_value(self, prop: typing.Union[str, EnvvarProfileProperty]) -> bool:\n        return self._loader.has_prop_value(self, prop)", "response": "Returns True if the property has a concrete value set or via environment\n        variables."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexports properties to a dictionary with environment variable names as keys.", "response": "def to_envvars(self):\n        \"\"\"\n        Export property values to a dictionary with environment variable names as keys.\n        \"\"\"\n        export = {}\n        for prop_name in self.profile_properties:\n            prop = self._get_prop(prop_name)\n            value = self[prop_name]\n            if value is not None:\n                export[prop.get_envvar(self)] = prop.to_str(self, value)\n        if self._profile_parent_name:\n            export[\n                f\"{self._envvar_prefix}PARENT_PROFILE\".upper()\n            ] = self._profile_parent_name\n        return export"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nactivating the current profile.", "response": "def activate(self, profile_name=NotSet):\n        \"\"\"\n        Sets <PROFILE_ROOT>_PROFILE environment variable to the name of the current profile.\n        \"\"\"\n        if profile_name is NotSet:\n            profile_name = self.profile_name\n        self._active_profile_name = profile_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_env(self, include_activation=True, **props) -> \"Environment\":\n        self: EnvvarProfile\n        props = dict(props)\n        env = Environment()\n\n        if include_activation:\n            env[self._active_profile_name_envvar] = self.profile_name\n\n        for k in self.profile_properties:\n            p = self._get_prop(k)\n            if k in props:\n                v = props.pop(k)\n                env[p.get_envvar(self)] = p.to_str(self, v)\n            else:\n                env[p.get_envvar(self)] = self._get_prop_value(p)\n\n        if props:\n            raise ValueError(f\"Unexpected property names: {', '.join(str(k) for k in props.keys())}\")\n\n        return env", "response": "Create a custom dictionary of environment variables representing a specific environment variable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef applied(\n        self,\n        context: typing.Any = None,\n        setenv: typing.Callable = operator.setitem,\n        delenv: typing.Callable = None,\n        getenv: typing.Callable = operator.getitem,\n    ):\n        \"\"\"\n        Apply this environment to the context.\n\n        If no context is supplied, os.environ is used.\n\n        If you pass setenv= and delenv=, those will be used to apply the environment.\n        delenv must not fail for non-existent environment variables.\n\n        If context has a 'setenv' attribute, then we believe it's pytest's MonkeyPatch\n        and use it accordingly.\n        \"\"\"\n        if context is None:\n            context = os.environ\n        if hasattr(context, \"setenv\"):\n            # context is probably pytest's MonkeyPatch\n            setenv = context.setenv\n            delenv = functools.partial(context.delenv, raising=False)\n            getenv = functools.partial(operator.getitem, os.environ)\n        elif delenv is None:\n            setenv = functools.partial(operator.setitem, context)\n            delenv = functools.partial(Environment._del_item, context)\n\n        # Retain previous values so we can reset the changes we did\n        previous_values = {}\n\n        # Apply the values\n        for k, v in self.items():\n            try:\n                previous_values[k] = getenv(k)\n            except KeyError:\n                previous_values[k] = None\n            if v is None:\n                delenv(k)\n            else:\n                setenv(k, v)\n\n        try:\n            yield self\n\n        finally:\n            # Set back the previous values\n            for k, v in previous_values.items():\n                if v is None:\n                    delenv(k)\n                else:\n                    setenv(k, v)", "response": "A context manager that applies the environment variables to the current context and returns a new context manager that can be used to update the environment variables."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming Gower normalizion on covariance matrix K.", "response": "def gower_normalization(K, out=None):\n    \"\"\"Perform Gower normalizion on covariance matrix K.\n\n    The rescaled covariance matrix has sample variance of 1.\n    \"\"\"\n    c = (K.shape[0] - 1) / (K.trace() - K.mean(0).sum())\n    if out is None:\n        return c * K\n\n    copyto(out, K)\n    out *= c"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pattern(self, value):\n\n        if value is not None:\n            assert type(value) in (unicode, QString), \\\n                \"'{0}' attribute: '{1}' type is not 'unicode' or 'QString'!\".format(\"pattern\", value)\n        self.__pattern = value", "response": "Sets the pattern of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the location of the resource.", "response": "def location(self, value):\n        \"\"\"\n        Setter for **self.__location** attribute.\n\n        :param value: Attribute value.\n        :type value: Location\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is umbra.ui.common.Location, \\\n                \"'{0}' attribute: '{1}' type is not 'umbra.ui.common.Location'!\".format(\"location\", value)\n        self.__location = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef settings(self, value):\n\n        if value is not None:\n            assert type(value) is dict, \"'{0}' attribute: '{1}' type is not 'dict'!\".format(\"settings\", value)\n        self.__settings = foundations.data_structures.Structure(**{\"case_sensitive\": False,\n                                                                   \"whole_word\": False,\n                                                                   \"regular_expressions\": False})\n        self.__settings.update(value)", "response": "Updates the locations related settings."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __search(self):\n\n        self.__search_results = []\n\n        editorsFiles = self.__container.default_target in self.__location.targets and \\\n                       [editor.file for editor in self.__container.script_editor.list_editors()] or []\n        self.__search_editors_files(editorsFiles)\n\n        self.__search_files(self.__location.files)\n\n        for directory in self.__location.directories:\n            if self.__interrupt:\n                return\n\n            files_walker = foundations.walkers.files_walker(directory,\n                                                            self.__location.filters_in,\n                                                            list(itertools.chain(self.__location.filters_out,\n                                                                                 self.__location.files,\n                                                                                 editorsFiles)))\n            self.__search_files(files_walker)\n\n        not self.__interrupt and self.searchFinished.emit(self.__search_results)", "response": "Searches for the files in the current location."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __search_editors_files(self, files):\n\n        for file in files:\n            if self.__interrupt:\n                return\n\n            if foundations.io.is_readable(file):\n                if foundations.io.is_binary_file(file):\n                    continue\n\n            LOGGER.info(\"{0} | Searching '{1}' file!\".format(self.__class__.__name__, file))\n            editor = self.__container.script_editor.get_editor(file)\n            if not editor:\n                continue\n\n            self.__lock.lock()\n            occurrences = self.__search_document(editor.document(), self.__pattern, self.__settings)\n            self.__lock.unlock()\n            occurrences and self.__search_results.append(SearchResult(file=file,\n                                                                      pattern=self.__pattern,\n                                                                      settings=self.__settings,\n                                                                      occurrences=occurrences))", "response": "Searches for given files."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __search_files(self, files):\n\n        for file in files:\n            if self.__interrupt:\n                return\n\n            if not foundations.common.path_exists(file):\n                continue\n\n            if foundations.io.is_readable(file):\n                if foundations.io.is_binary_file(file):\n                    continue\n\n            LOGGER.info(\"{0} | Searching '{1}' file!\".format(self.__class__.__name__, file))\n            cache_data = self.__container.files_cache.get_content(file)\n            if not cache_data:\n                reader = foundations.io.File(file)\n                content = reader.read()\n                if content is None:\n                    LOGGER.warning(\"!> Error occured while reading '{0}' file proceeding to next one!\".format(file))\n                    continue\n                self.__container.files_cache.add_content(**{file: CacheData(content=content, document=None)})\n            else:\n                content = cache_data.content\n            occurrences = self.__search_document(QTextDocument(QString(content)), self.__pattern, self.__settings)\n            occurrences and self.__search_results.append(SearchResult(file=file,\n                                                                      pattern=self.__pattern,\n                                                                      settings=self.__settings,\n                                                                      occurrences=occurrences))", "response": "Searches given files for occurrences."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsearch given pattern occurrences in given document.", "response": "def __search_document(self, document, pattern, settings):\n        \"\"\"\n        Searches for given pattern occurrences in given document using given settings.\n\n        :param document: Document.\n        :type document: QTextDocument\n        :param pattern: Pattern.\n        :type pattern: unicode\n        :param settings: Search settings.\n        :type settings: Structure\n        :return: Matched occurrences.\n        :rtype: list\n        \"\"\"\n\n        pattern = settings.regular_expressions and QRegExp(pattern) or pattern\n\n        flags = QTextDocument.FindFlags()\n        if settings.case_sensitive:\n            flags = flags | QTextDocument.FindCaseSensitively\n        if settings.whole_word:\n            flags = flags | QTextDocument.FindWholeWords\n\n        occurrences = []\n        block = document.findBlock(0)\n        cursor = document.find(pattern, block.position(), flags)\n        while block.isValid() and cursor.position() != -1:\n            if self.__interrupt:\n                return\n\n            block_cursor = QTextCursor(cursor)\n            block_cursor.movePosition(QTextCursor.StartOfLine, QTextCursor.MoveAnchor)\n            block_cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)\n            length = cursor.selectionEnd() - cursor.selectionStart()\n            occurrences.append(Occurence(line=cursor.blockNumber(),\n                                         column=cursor.columnNumber() - length,\n                                         length=length,\n                                         position=cursor.position() - length,\n                                         text=block_cursor.selectedText()))\n            cursor = document.find(pattern, cursor.position(), flags)\n            block = block.next()\n        return occurrences"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun a command with optional timeout and retries.", "response": "def run(command, num_retries=1, timeout=-1, **kwargs):\n    \"\"\"\n    Run a command with optional timeout and retries.\n\n    Provides a convenience method for executing a subprocess with\n    additional error handling.\n\n    Arguments:\n        command (list of str): The command to execute.\n        num_retries (int, optional): If the subprocess fails, the number of\n          attempts to execute it before failing.\n        timeout (float, optional): If positive, the number of seconds to wait\n          for subprocess completion before failing.\n        **kwargs: Additional args to pass to Subprocess.__init__()\n\n    Returns:\n        Tuple of (int, str, str): Where the variables represent\n        (exit status, stdout, stderr).\n\n    Raises:\n        SubprocessError: If the command fails after the given number of\n          retries.\n    \"\"\"\n    last_error = None\n    for _ in range(num_retries):\n        try:\n            process = Subprocess(command, **kwargs)\n            return process.run(timeout)\n        except Exception as err:\n            last_error = err\n\n    raise last_error"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform sed text substitution.", "response": "def sed(match, replacement, path, modifiers=\"\"):\n    \"\"\"\n    Perform sed text substitution.\n    \"\"\"\n    cmd = \"sed -r -i 's/%s/%s/%s' %s\" % (match, replacement, modifiers, path)\n\n    process = Subprocess(cmd, shell=True)\n    ret, out, err = process.run(timeout=60)\n    if ret:\n        raise SubprocessError(\"Sed command failed!\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting a message to a file.", "response": "def echo(*args, **kwargs):\n    \"\"\"\n    Write a message to a file.\n\n    Arguments:\n        args A list of arguments which make up the message. The last argument\n            is the path to the file to write to.\n    \"\"\"\n    msg = args[:-1]\n    path = fs.path(args[-1])\n    append = kwargs.pop(\"append\", False)\n\n    if append:\n        with open(path, \"a\") as file:\n            print(*msg, file=file, **kwargs)\n    else:\n        with open(fs.path(path), \"w\") as file:\n            print(*msg, file=file, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the full path to the named command in the system.", "response": "def which(program, path=None):\n    \"\"\"\n    Returns the full path of shell commands.\n\n    Replicates the functionality of system which (1) command. Looks\n    for the named program in the directories indicated in the $PATH\n    environment variable, and returns the full path if found.\n\n    Examples:\n\n        >>> system.which(\"ls\")\n        \"/bin/ls\"\n\n        >>> system.which(\"/bin/ls\")\n        \"/bin/ls\"\n\n        >>> system.which(\"not-a-real-command\")\n        None\n\n        >>> system.which(\"ls\", path=(\"/usr/bin\", \"/bin\"))\n        \"/bin/ls\"\n\n    Arguments:\n\n        program (str): The name of the program to look for. Can\n          be an absolute path.\n        path (sequence of str, optional): A list of directories to\n          look for the pgoram in. Default value is system $PATH.\n\n    Returns:\n\n       str: Full path to program if found, else None.\n    \"\"\"\n    # If path is not given, read the $PATH environment variable.\n    path = path or os.environ[\"PATH\"].split(os.pathsep)\n    abspath = True if os.path.split(program)[0] else False\n    if abspath:\n        if fs.isexe(program):\n            return program\n    else:\n        for directory in path:\n            # De-quote directories.\n            directory = directory.strip('\"')\n            exe_file = os.path.join(directory, program)\n            if fs.isexe(exe_file):\n                return exe_file\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scp(host, src, dst, user=None, path=None):\n    # Create the first argument.\n    if user is None:\n        arg = \"{host}:{path}\".format(host=host, path=src)\n    else:\n        arg = \"{user}@{host}:{path}\".format(user=user, host=host, path=src)\n\n    # Get path to scp binary.\n    scp_bin = which(\"scp\", path=(path,))\n    if scp_bin is None:\n        raise CommandNotFoundError(\"Could not find scp in '{0}'\".format(path))\n\n    # Run system \"scp\" command.\n    ret,out,err = run([scp_bin,\n                       \"-o\", \"StrictHostKeyChecking=no\",\n                       \"-o\", \"UserKnownHostsFile=/dev/null\",\n                       arg, dst])\n\n    # Check return code for error.\n    if ret:\n        raise ScpError(out, err)", "response": "Copy a file or directory from a remote location."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking that a process is running.", "response": "def isprocess(pid, error=False):\n    \"\"\"\n    Check that a process is running.\n\n    Arguments:\n\n        pid (int): Process ID to check.\n\n    Returns:\n\n        True if the process is running, else false.\n    \"\"\"\n    try:\n        # Don't worry folks, no processes are harmed in the making of\n        # this system call:\n        os.kill(pid, 0)\n        return True\n    except OSError:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self, timeout=-1):\n        def target():\n            self.process = subprocess.Popen(self.cmd,\n                                            stdout=self.stdout_dest,\n                                            stderr=self.stderr_dest,\n                                            shell=self.shell)\n            stdout, stderr = self.process.communicate()\n\n            # Decode output if the user wants, and if there is any.\n            if self.decode_out:\n                if stdout:\n                    self.stdout = stdout.decode(\"utf-8\")\n                if stderr:\n                    self.stderr = stderr.decode(\"utf-8\")\n\n        thread = threading.Thread(target=target)\n        thread.start()\n\n        if timeout > 0:\n            thread.join(timeout)\n            if thread.is_alive():\n                self.process.terminate()\n                thread.join()\n                raise SubprocessError((\"Reached timeout after {t} seconds\"\n                                       .format(t=timeout)))\n        else:\n            thread.join()\n\n        return self.process.returncode, self.stdout, self.stderr", "response": "Run the subprocess.\n\n        Arguments:\n            timeout (optional) If a positive real value, then timout after\n                the given number of seconds.\n\n        Raises:\n            SubprocessError If subprocess has not completed after \"timeout\"\n                seconds."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef todjango(table, model, update=True, create=True, use_bulk_create=True, *args, **kwargs):\r\n    '''\r\n    Given a table with appropriate headings create Django models.\r\n    '''\r\n    assert issubclass(model, Model), 'Must be supplied a valid Django model class'\r\n    table_iterator = iter(table)\r\n    table_headers = table_iterator.next()\r\n\r\n    model_pk_field_name = model._meta.pk.name\r\n    model_field_names = _get_model_field_names(model)\r\n    model_name = model.__name__\r\n\r\n    existing_models = _get_django_objects(model)\r\n    existing_model_map = dict([(m.pk, m) for m in existing_models])\r\n\r\n    if update:\r\n        # if we are going to update existing models we need to have a table field that\r\n        # corresponds to the model 'pk' field.\r\n        assert model_pk_field_name in set(model_field_names), 'To be able to update existing models the data must have a field corresponding to the Django Primary Key field {}'.format(model_pk_field_name)\r\n        # existing_model_pks = model.objects.all().values_list('pk', flat=True) # TODO: this could be a performance bottleneck if lots of models are being updated\r\n\r\n    updated_model_count = 0\r\n    unsaved_models = []\r\n\r\n    for row in table_iterator:\r\n        value_map = dict(zip(table_headers, row))\r\n        pk = value_map.get(model_pk_field_name, None)\r\n\r\n        try:\r\n            django_object = existing_model_map[pk]\r\n            if _will_model_change(value_map, django_object):\r\n                _apply_value_map(value_map, django_object)\r\n                try:\r\n                    django_object.save()\r\n                except Exception as e:\r\n                    # Add the data that cause the exception to the exception as reraise\r\n                    e.petl_data = value_map\r\n                    raise e\r\n                updated_model_count += 1\r\n        except KeyError:\r\n            django_object = model(**value_map)\r\n            if use_bulk_create:\r\n                unsaved_models.append(django_object)\r\n            else:\r\n                try:\r\n                    django_object.save()\r\n                except Exception as e:\r\n                    e.petl_data = value_map\r\n                    raise e\r\n    logger.debug('Bulk creating unsaved {}'.format(model_name))\r\n    if use_bulk_create:\r\n        _chunked_bulk_create(model, unsaved_models)\r\n\r\n    msg = 'Updated {} existing {}'.format(updated_model_count, model_name)\r\n    logger.info(msg)\r\n\r\n    msg = 'Created {} new {}'.format(len(unsaved_models), model_name)\r\n    logger.info(msg)", "response": "Given a table with appropriate headings create Django models."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_django_objects(model):\r\n    '''\r\n    Given a Django model class get all of the current records that match.\r\n    This is better than django's bulk methods and has no upper limit.\r\n    '''\r\n    model_name = model.__class__.__name__\r\n    model_objects = [i for i in model.objects.all()]\r\n    logger.debug('Found {} {} objects in DB'.format(len(model_objects), model_name))\r\n    return model_objects", "response": "Given a Django model class get all of the current records that match."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _chunked_bulk_create(django_model_object, unsaved_models, chunk_size=None):\r\n    '''Create new models using bulk_create in batches of `chunk_size`.\r\n    This is designed to overcome a query size limitation in some databases'''\r\n    if chunk_size is None:\r\n        chunk_size = getattr(settings, 'BULK_CREATE_CHUNK_SIZE', 50)\r\n    for i in range(0, len(unsaved_models), chunk_size):\r\n        try:\r\n            django_model_object.objects.bulk_create(unsaved_models[i:i + chunk_size])\r\n        except Exception as e:\r\n            chunk_data = unsaved_models[i:i + chunk_size]\r\n            e.petl_chunk_data = chunk_data\r\n            raise e", "response": "Create new models using bulk_create in batches of chunk_size."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvisiting the entry in the log.", "response": "def visit(self, t1, t2, value, data):\n        '''\n        Return nothing\n        '''\n        if self.is_visited(t1, t2):\n            return\n\n        k1 = str(t1)\n        k2 = str(t2)\n        if k1 not in self._history:\n            self._history[k1] = {}\n        self._history[k1][k2] = True\n\n        if value < self._min_value:\n            self._min_value = value\n            self._min_value_t1 = t1\n            self._min_value_t2 = t2\n            self._min_value_data = data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the minimum value of the resource entry.", "response": "def get_minimum(self):\n        '''\n        Return\n            (t1, t2, value) triple where the value is the minimal one.\n        '''\n        return (self._min_value_t1, self._min_value_t2,\n                self._min_value,    self._min_value_data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_primers(self, primers=None, mismatches=0, revcompl=False):\n    # Default primers #\n    if primers is None: primers = self.primers\n    # Case straight #\n    if not revcompl:\n        fwd_regex = regex.compile(\"(%s){s<=%i}\" % (primers.fwd_pattern, mismatches))\n        rev_regex = regex.compile(\"(%s){s<=%i}\" % (primers.rev_pattern, mismatches))\n        generator = (ReadWithPrimers(r, fwd_regex, rev_regex) for r in self.parse())\n    # Case revcompl #\n    if revcompl:\n        fwd_regex = regex.compile(\"(%s){s<=%i}\" % (primers.fwd_pattern,          mismatches))\n        rev_regex = regex.compile(\"(%s){s<=%i}\" % (primers.rev_pattern_revcompl, mismatches))\n        generator = (ReadWithPrimersRevCompl(r, fwd_regex, rev_regex) for r in self.parse())\n    # Return #\n    return GenWithLength(generator, len(self))", "response": "This function starts with self because it s \n    meant as an extension to the FASTA class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getEffort(self, vehID, time, edgeID):\n        self._connection._beginMessage(tc.CMD_GET_VEHICLE_VARIABLE,\n                                       tc.VAR_EDGE_EFFORT, vehID, 1 + 4 + 1 + 4 + 1 + 4 + len(edgeID))\n        self._connection._string += struct.pack(\n            \"!BiBi\", tc.TYPE_COMPOUND, 2, tc.TYPE_INTEGER, time)\n        self._connection._packString(edgeID)\n        return self._connection._checkResult(tc.CMD_GET_VEHICLE_VARIABLE, tc.VAR_EDGE_EFFORT, vehID).readDouble()", "response": "This method returns the effective time of the vehicite."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getLeader(self, vehID, dist=0.):\n        self._connection._beginMessage(\n            tc.CMD_GET_VEHICLE_VARIABLE, tc.VAR_LEADER, vehID, 1 + 8)\n        self._connection._string += struct.pack(\"!Bd\", tc.TYPE_DOUBLE, dist)\n        return _readLeader(self._connection._checkResult(tc.CMD_GET_VEHICLE_VARIABLE, tc.VAR_LEADER, vehID))", "response": "Returns the leading vehicle id together with the distance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsubscribing for the leading vehicle id together with the distance.", "response": "def subscribeLeader(self, vehID, dist=0., begin=0, end=2**31 - 1):\n        \"\"\"subscribeLeader(string, double) -> None\n\n        Subscribe for the leading vehicle id together with the distance.\n        The dist parameter defines the maximum lookahead, 0 calculates a lookahead from the brake gap.\n        \"\"\"\n        self._connection._subscribe(tc.CMD_SUBSCRIBE_VEHICLE_VARIABLE, begin, end, vehID,\n                                    (tc.VAR_LEADER,), {tc.VAR_LEADER: struct.pack(\"!Bd\", tc.TYPE_DOUBLE, dist)})"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getDrivingDistance2D(self, vehID, x, y):\n        self._connection._beginMessage(\n            tc.CMD_GET_VEHICLE_VARIABLE, tc.DISTANCE_REQUEST, vehID, 1 + 4 + 1 + 8 + 8 + 1)\n        self._connection._string += struct.pack(\"!BiBddB\", tc.TYPE_COMPOUND, 2,\n                                                tc.POSITION_2D, x, y, tc.REQUEST_DRIVINGDIST)\n        return self._connection._checkResult(tc.CMD_GET_VEHICLE_VARIABLE, tc.DISTANCE_REQUEST, vehID).readDouble()", "response": "This method returns the distance to the given network position along the vehicles route."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the current lane change state for the vehicle.", "response": "def getLaneChangeState(self, vehID, direction):\n        \"\"\"getLaneChangeState(string, int) -> (int, int)\n        Return the lane change state for the vehicle\n        \"\"\"\n        self._connection._beginMessage(\n            tc.CMD_GET_VEHICLE_VARIABLE, tc.CMD_CHANGELANE, vehID, 1 + 4)\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_INTEGER, direction)\n        result = self._connection._checkResult(tc.CMD_GET_VEHICLE_VARIABLE, tc.CMD_CHANGELANE, vehID)\n        return result.read(\"!iBiBi\")[2::2]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef couldChangeLane(self, vehID, direction):\n        state = self.getLaneChangeState(vehID, direction)[0]\n        return state != tc.LCA_UNKNOWN and (state & tc.LCA_BLOCKED == 0)", "response": "Returns whether the vehicle could change lanes in the specified direction"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn whether the vehicle wants to and could change lanes in the specified direction", "response": "def wantsAndCouldChangeLane(self, vehID, direction):\n        \"\"\"wantsAndCouldChangeLane(string, int) -> bool\n        Return whether the vehicle wants to and could change lanes in the specified direction\n        \"\"\"\n        state = self.getLaneChangeState(vehID, direction)[0]\n        if state & tc.LCA_BLOCKED == 0:\n            if direction == -1:\n                return state & tc.LCA_RIGHT != 0\n            if direction == 1:\n                return state & tc.LCA_LEFT != 0\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the maximum speed in m/s for the vehicle.", "response": "def setMaxSpeed(self, vehID, speed):\n        \"\"\"setMaxSpeed(string, double) -> None\n\n        Sets the maximum speed in m/s for this vehicle.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_MAXSPEED, vehID, speed)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setMaxSpeedLat(self, vehID, speed):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_MAXSPEED_LAT, vehID, speed)", "response": "Sets the maximum lateral speed in m / s for this vehicle."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setStop(self, vehID, edgeID, pos=1., laneIndex=0, duration=2**31 - 1,\n                flags=tc.STOP_DEFAULT, startPos=tc.INVALID_DOUBLE_VALUE, until=-1):\n        \"\"\"setStop(string, string, double, integer, integer, integer, double, integer) -> None\n\n        Adds or modifies a stop with the given parameters. The duration and the until attribute are\n        in milliseconds.\n        \"\"\"\n        self._connection._beginMessage(tc.CMD_SET_VEHICLE_VARIABLE, tc.CMD_STOP,\n                                       vehID, 1 + 4 + 1 + 4 + len(edgeID) + 1 + 8 + 1 + 1 + 1 + 4 + 1 + 1 + 1 + 8 + 1 + 4)\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 7)\n        self._connection._packString(edgeID)\n        self._connection._string += struct.pack(\"!BdBBBiBB\", tc.TYPE_DOUBLE, pos,\n                                                tc.TYPE_BYTE, laneIndex, tc.TYPE_INTEGER, duration, tc.TYPE_BYTE, flags)\n        self._connection._string += struct.pack(\"!BdBi\",\n                                                tc.TYPE_DOUBLE, startPos, tc.TYPE_INTEGER, until)\n        self._connection._sendExact()", "response": "This method sets the stop parameter of the current active resource."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setBusStop(self, vehID, stopID, duration=2**31 - 1, until=-1, flags=tc.STOP_DEFAULT):\n        self.setStop(vehID, stopID, duration=duration,\n                     until=until, flags=flags | tc.STOP_BUS_STOP)", "response": "Adds or modifies a bus stop for the given vehicle ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding or modifies a container stop with the given parameters.", "response": "def setContainerStop(self, vehID, stopID, duration=2**31 - 1, until=-1, flags=tc.STOP_DEFAULT):\n        \"\"\"setContainerStop(string, string, integer, integer, integer) -> None\n\n        Adds or modifies a container stop with the given parameters. The duration and the until attribute are\n        in milliseconds.\n        \"\"\"\n        self.setStop(vehID, stopID, duration=duration, until=until,\n                     flags=flags | tc.STOP_CONTAINER_STOP)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setChargingStationStop(self, vehID, stopID, duration=2**31 - 1, until=-1, flags=tc.STOP_DEFAULT):\n        self.setStop(vehID, stopID, duration=duration, until=until,\n                     flags=flags | tc.STOP_CHARGING_STATION)", "response": "Sets the stop ID for a given chargingStation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setParkingAreaStop(self, vehID, stopID, duration=2**31 - 1, until=-1, flags=tc.STOP_PARKING):\n        self.setStop(vehID, stopID, duration=duration, until=until,\n                     flags=flags | tc.STOP_PARKING_AREA)", "response": "Sets a stop at a parking area."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resume(self, vehID):\n        self._connection._beginMessage(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.CMD_RESUME, vehID, 1 + 4)\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 0)\n        self._connection._sendExact()", "response": "Resumes the vehicle from the current stop."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nforcing a change to the lane with the given index.", "response": "def changeLane(self, vehID, laneIndex, duration):\n        \"\"\"changeLane(string, int, int) -> None\n\n        Forces a lane change to the lane with the given index; if successful,\n        the lane will be chosen for the given amount of time (in ms).\n        \"\"\"\n        self._connection._beginMessage(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.CMD_CHANGELANE, vehID, 1 + 4 + 1 + 1 + 1 + 4)\n        self._connection._string += struct.pack(\n            \"!BiBBBi\", tc.TYPE_COMPOUND, 2, tc.TYPE_BYTE, laneIndex, tc.TYPE_INTEGER, duration)\n        self._connection._sendExact()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef changeSublane(self, vehID, latDist):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.CMD_CHANGESUBLANE, vehID, latDist)", "response": "Changes the lane of the specified location."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef changeTarget(self, vehID, edgeID):\n        self._connection._sendStringCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.CMD_CHANGETARGET, vehID, edgeID)", "response": "Changes the destination of the vehicle to the given edge id."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setType(self, vehID, typeID):\n        self._connection._sendStringCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_TYPE, vehID, typeID)", "response": "Sets the type of the vehicle."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the route ID of the vehicles that have the given id.", "response": "def setRouteID(self, vehID, routeID):\n        \"\"\"setRouteID(string, string) -> None\n\n        Changes the vehicles route to the route with the given id.\n        \"\"\"\n        self._connection._sendStringCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_ROUTE_ID, vehID, routeID)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setAdaptedTraveltime(self, vehID, edgeID, time=None, begTime=None, endTime=None):\n        if type(edgeID) != str and type(begTime) == str: \n            # legacy handling\n            warnings.warn(\"Parameter order has changed for setAdaptedTraveltime(). Attempting legacy ordering. Please update your code.\", stacklevel=2)\n            return self.setAdaptedTraveltime(vehID, begTime, endTime, edgeID, time)\n        if time is None:\n            # reset\n            self._connection._beginMessage(tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_EDGE_TRAVELTIME,\n                                           vehID, 1 + 4 + 1 + 4 + len(edgeID))\n            self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 1)\n            self._connection._packString(edgeID)\n            self._connection._sendExact()\n        elif begTime is None:\n            # set value for the whole simulation\n            self._connection._beginMessage(tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_EDGE_TRAVELTIME,\n                                           vehID, 1 + 4 + 1 + 4 + len(edgeID) + 1 + 8)\n            self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 2)\n            self._connection._packString(edgeID)\n            self._connection._string += struct.pack(\"!Bd\", tc.TYPE_DOUBLE, time)\n            self._connection._sendExact()\n        else:\n            self._connection._beginMessage(tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_EDGE_TRAVELTIME,\n                                           vehID, 1 + 4 + 1 + 4 + 1 + 4 + 1 + 4 + len(edgeID) + 1 + 8)\n            self._connection._string += struct.pack(\"!BiBiBi\", tc.TYPE_COMPOUND, 4, tc.TYPE_INTEGER, begTime,\n                                                    tc.TYPE_INTEGER, endTime)\n            self._connection._packString(edgeID)\n            self._connection._string += struct.pack(\"!Bd\", tc.TYPE_DOUBLE, time)\n            self._connection._sendExact()", "response": "Sets the time of the vehicle s internal edge travel time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the effort of the edgeID in the vehicle s internal edge weights.", "response": "def setEffort(self, vehID, edgeID, effort=None, begTime=None, endTime=None):\n        \"\"\"setEffort(string, string, double, int, int) -> None\n        Inserts the information about the effort of edge \"edgeID\" valid from\n        begin time to end time into the vehicle's internal edge weights\n        container.\n        If the time is not specified, any previously set values for that edge\n        are removed.\n        If begTime or endTime are not specified the value is set for the whole\n        simulation duration.\n        \"\"\"\n        if type(edgeID) != str and type(begTime) == str: \n            # legacy handling\n            warnings.warn(\"Parameter order has changed for setEffort(). Attempting legacy ordering. Please update your code.\", stacklevel=2)\n            return self.setEffort(vehID, begTime, endTime, edgeID, effort)\n        if effort is None:\n            # reset\n            self._connection._beginMessage(tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_EDGE_EFFORT,\n                                           vehID, 1 + 4 + 1 + 4 + len(edgeID))\n            self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 1)\n            self._connection._packString(edgeID)\n            self._connection._sendExact()\n        elif begTime is None:\n            # set value for the whole simulation\n            self._connection._beginMessage(tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_EDGE_EFFORT,\n                                           vehID, 1 + 4 + 1 + 4 + len(edgeID) + 1 + 8)\n            self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 2)\n            self._connection._packString(edgeID)\n            self._connection._string += struct.pack(\"!Bd\", tc.TYPE_DOUBLE, effort)\n            self._connection._sendExact()\n        else:\n            self._connection._beginMessage(tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_EDGE_EFFORT,\n                                           vehID, 1 + 4 + 1 + 4 + 1 + 4 + 1 + 4 + len(edgeID) + 1 + 8)\n            self._connection._string += struct.pack(\"!BiBiBi\", tc.TYPE_COMPOUND, 4, tc.TYPE_INTEGER, begTime,\n                                                    tc.TYPE_INTEGER, endTime)\n            self._connection._packString(edgeID)\n            self._connection._string += struct.pack(\"!Bd\", tc.TYPE_DOUBLE, effort)\n            self._connection._sendExact()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setSignals(self, vehID, signals):\n        self._connection._sendIntCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_SIGNALS, vehID, signals)", "response": "Sets the state of the signals of the vehicle."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the speed in m/s for the named vehicle.", "response": "def setSpeed(self, vehID, speed):\n        \"\"\"setSpeed(string, double) -> None\n\n        Sets the speed in m/s for the named vehicle within the last step.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_SPEED, vehID, speed)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the color for the vehicle with the given ID", "response": "def setColor(self, vehID, color):\n        \"\"\"setColor(string, (integer, integer, integer, integer))\n        sets color for vehicle with the given ID.\n        i.e. (255,0,0,0) for the color red.\n        The fourth integer (alpha) is only used when drawing vehicles with raster images\n        \"\"\"\n        self._connection._beginMessage(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_COLOR, vehID, 1 + 1 + 1 + 1 + 1)\n        self._connection._string += struct.pack(\"!BBBBB\", tc.TYPE_COLOR, int(\n            color[0]), int(color[1]), int(color[2]), int(color[3]))\n        self._connection._sendExact()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the length in m for the given vehicle.", "response": "def setLength(self, vehID, length):\n        \"\"\"setLength(string, double) -> None\n\n        Sets the length in m for the given vehicle.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_LENGTH, vehID, length)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setVehicleClass(self, vehID, clazz):\n        self._connection._sendStringCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_VEHICLECLASS, vehID, clazz)", "response": "Sets the class of the vehicle."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the current speed factor for the specified vehicle.", "response": "def setSpeedFactor(self, vehID, factor):\n        \"\"\"setSpeedFactor(string, double) -> None\n\n        .\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_SPEED_FACTOR, vehID, factor)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setEmissionClass(self, vehID, clazz):\n        self._connection._sendStringCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_EMISSIONCLASS, vehID, clazz)", "response": "Sets the emission class for this vehicle."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the width in m for this vehicle.", "response": "def setWidth(self, vehID, width):\n        \"\"\"setWidth(string, double) -> None\n\n        Sets the width in m for this vehicle.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_WIDTH, vehID, width)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the height of the vehicle.", "response": "def setHeight(self, vehID, height):\n        \"\"\"setHeight(string, double) -> None\n\n        Sets the height in m for this vehicle.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_HEIGHT, vehID, height)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the line information for the vehicle.", "response": "def setLine(self, vehID, line):\n        \"\"\"setHeight(string, string) -> None\n\n        Sets the line information for this vehicle.\n        \"\"\"\n        self._connection._sendStringCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_LINE, vehID, line)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setVia(self, vehID, edgeList):\n        if isinstance(edgeList, str):\n            edgeList = [edgeList]\n        self._connection._beginMessage(tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_VIA, vehID,\n                                       1 + 4 + sum(map(len, edgeList)) + 4 * len(edgeList))\n        self._connection._packStringList(edgeList)\n        self._connection._sendExact()", "response": "Sets the via edges of the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setMinGap(self, vehID, minGap):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_MINGAP, vehID, minGap)", "response": "Sets the minimum gap for this vehicle."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the minimum lateral gap of the vehicle at 50km / h in m .", "response": "def setMinGapLat(self, vehID, minGapLat):\n        \"\"\"setMinGapLat(string, double) -> None\n\n        Sets the minimum lateral gap of the vehicle at 50km/h in m\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_MINGAP_LAT, vehID, minGapLat)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the preferred lateral alignment for this vehicle.", "response": "def setLateralAlignment(self, vehID, align):\n        \"\"\"setLateralAlignment(string, string) -> None\n\n        Sets the preferred lateral alignment for this vehicle.\n        \"\"\"\n        self._connection._sendStringCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_LATALIGNMENT, vehID, align)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setShapeClass(self, vehID, clazz):\n        self._connection._sendStringCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_SHAPECLASS, vehID, clazz)", "response": "Sets the shape class for this vehicle."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the maximum acceleration in m/s^2 for this vehicle.", "response": "def setAccel(self, vehID, accel):\n        \"\"\"setAccel(string, double) -> None\n\n        Sets the maximum acceleration in m/s^2 for this vehicle.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_ACCEL, vehID, accel)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the preferred maximal deceleration in m/s^2 for this vehicle.", "response": "def setDecel(self, vehID, decel):\n        \"\"\"setDecel(string, double) -> None\n\n        Sets the preferred maximal deceleration in m/s^2 for this vehicle.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_DECEL, vehID, decel)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the maximum physically possible deceleration in m/s^2 for this vehicle.", "response": "def setEmergencyDecel(self, vehID, decel):\n        \"\"\"setEmergencyDecel(string, double) -> None\n\n        Sets the maximal physically possible deceleration in m/s^2 for this vehicle.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_EMERGENCY_DECEL, vehID, decel)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the apparent deceleration in m/s^2 for this vehicle.", "response": "def setApparentDecel(self, vehID, decel):\n        \"\"\"setApparentDecel(string, double) -> None\n\n        Sets the apparent deceleration in m/s^2 for this vehicle.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_APPARENT_DECEL, vehID, decel)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the action step length for this vehicle.", "response": "def setActionStepLength(self, vehID, actionStepLength, resetActionOffset = True):\n        \"\"\"setActionStepLength(string, double, bool) -> None\n\n        Sets the action step length for this vehicle. If resetActionOffset == True (default), the \n        next action point is scheduled immediately. if If resetActionOffset == False, the interval \n        between the last and the next action point is updated to match the given value, or if the latter\n        is smaller than the time since the last action point, the next action follows immediately.\n        \"\"\"\n        if actionStepLength < 0:\n            raise exceptions.TraCIException(\"Invalid value for actionStepLength. Given value must be non-negative.\")\n        # Use negative value to indicate resetActionOffset == False\n        if not resetActionOffset:\n            actionStepLength*=-1\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_ACTIONSTEPLENGTH, vehID, actionStepLength)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setImperfection(self, vehID, imperfection):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_IMPERFECTION, vehID, imperfection)", "response": "Sets the driver imperfection sigma."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the driver s tau - parameter for the vehicle.", "response": "def setTau(self, vehID, tau):\n        \"\"\"setTau(string, double) -> None\n\n        Sets the driver's tau-parameter (reaction time or anticipation time depending on the car-following model) in s for this vehicle.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_TAU, vehID, tau)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the lane change mode for the vehicle.", "response": "def setLaneChangeMode(self, vehID, lcm):\n        \"\"\"setLaneChangeMode(string, integer) -> None\n\n        Sets the vehicle's lane change mode as a bitset.\n        \"\"\"\n        self._connection._sendIntCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_LANECHANGE_MODE, vehID, lcm)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the speed mode of the vehicle.", "response": "def setSpeedMode(self, vehID, sm):\n        \"\"\"setSpeedMode(string, integer) -> None\n\n        Sets the vehicle's speed mode as a bitset.\n        \"\"\"\n        self._connection._sendIntCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.VAR_SPEEDSETMODE, vehID, sm)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add(self, vehID, routeID, depart=tc.DEPARTFLAG_NOW, pos=0, speed=0,\n            lane=tc.DEPARTFLAG_LANE_FIRST_ALLOWED, typeID=\"DEFAULT_VEHTYPE\"):\n        \"\"\"\n        Add a new vehicle (old style)\n        \"\"\"\n        self._connection._beginMessage(tc.CMD_SET_VEHICLE_VARIABLE, tc.ADD, vehID,\n                                       1 + 4 + 1 + 4 + len(typeID) + 1 + 4 + len(routeID) + 1 + 4 + 1 + 8 + 1 + 8 + 1 + 1)\n        if depart > 0:\n            depart *= 1000\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 6)\n        self._connection._packString(typeID)\n        self._connection._packString(routeID)\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_INTEGER, depart)\n        self._connection._string += struct.pack(\"!BdBd\",\n                                                tc.TYPE_DOUBLE, pos, tc.TYPE_DOUBLE, speed)\n        self._connection._string += struct.pack(\"!Bb\", tc.TYPE_BYTE, lane)\n        self._connection._sendExact()", "response": "This method adds a new vehicle to the cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a new vehicle (new style with all possible parameters)", "response": "def addFull(self, vehID, routeID, typeID=\"DEFAULT_VEHTYPE\", depart=None,\n                departLane=\"first\", departPos=\"base\", departSpeed=\"0\",\n                arrivalLane=\"current\", arrivalPos=\"max\", arrivalSpeed=\"current\",\n                fromTaz=\"\", toTaz=\"\", line=\"\", personCapacity=0, personNumber=0):\n        \"\"\"\n        Add a new vehicle (new style with all possible parameters)\n        \"\"\"\n        messageString = struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 14)\n        if depart is None:\n            depart = str(self._connection.simulation.getCurrentTime() / 1000.)\n        for val in (routeID, typeID, depart, departLane, departPos, departSpeed,\n                    arrivalLane, arrivalPos, arrivalSpeed, fromTaz, toTaz, line):\n            messageString += struct.pack(\"!Bi\",\n                                         tc.TYPE_STRING, len(val)) + str(val).encode(\"latin1\")\n        messageString += struct.pack(\"!Bi\", tc.TYPE_INTEGER, personCapacity)\n        messageString += struct.pack(\"!Bi\", tc.TYPE_INTEGER, personNumber)\n\n        self._connection._beginMessage(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.ADD_FULL, vehID, len(messageString))\n        self._connection._string += messageString\n        self._connection._sendExact()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove(self, vehID, reason=tc.REMOVE_VAPORIZED):\n        '''Remove vehicle with the given ID for the give reason.\n           Reasons are defined in module constants and start with REMOVE_'''\n        self._connection._sendByteCmd(\n            tc.CMD_SET_VEHICLE_VARIABLE, tc.REMOVE, vehID, reason)", "response": "Removes a vehicle with the given ID for the given reason."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmoves the vehicle to the given x y coordinates and force it s angle to the given value.", "response": "def moveToXY(self, vehID, edgeID, lane, x, y, angle=tc.INVALID_DOUBLE_VALUE, keepRoute=1):\n        '''Place vehicle at the given x,y coordinates and force it's angle to\n        the given value (for drawing).\n        If the angle is set to INVALID_DOUBLE_VALUE, the vehicle assumes the\n        natural angle of the edge on which it is driving.\n        If keepRoute is set to 1, the closest position\n        within the existing route is taken. If keepRoute is set to 0, the vehicle may move to\n        any edge in the network but it's route then only consists of that edge.\n        If keepRoute is set to 2 the vehicle has all the freedom of keepRoute=0\n        but in addition to that may even move outside the road network.\n        edgeID and lane are optional placement hints to resovle ambiguities'''\n        self._connection._beginMessage(tc.CMD_SET_VEHICLE_VARIABLE, tc.MOVE_TO_XY,\n                                       vehID, 1 + 4 + 1 + 4 + len(edgeID) + 1 + 4 + 1 + 8 + 1 + 8 + 1 + 8 + 1 + 1)\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 6)\n        self._connection._packString(edgeID)\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_INTEGER, lane)\n        self._connection._string += struct.pack(\"!Bd\", tc.TYPE_DOUBLE, x)\n        self._connection._string += struct.pack(\"!Bd\", tc.TYPE_DOUBLE, y)\n        self._connection._string += struct.pack(\"!Bd\", tc.TYPE_DOUBLE, angle)\n        self._connection._string += struct.pack(\"!BB\", tc.TYPE_BYTE, keepRoute)\n        self._connection._sendExact()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsubscribe to one or more object values for the given interval.", "response": "def subscribe(self, objectID, varIDs=(tc.VAR_ROAD_ID, tc.VAR_LANEPOSITION), begin=0, end=2**31 - 1):\n        \"\"\"subscribe(string, list(integer), int, int) -> None\n\n        Subscribe to one or more object values for the given interval.\n        \"\"\"\n        Domain.subscribe(self, objectID, varIDs, begin, end)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsubscribe to one or more object values of the given domain around the given objectID in a given radius.", "response": "def subscribeContext(self, objectID, domain, dist, varIDs=(\n            tc.VAR_ROAD_ID, tc.VAR_LANEPOSITION), begin=0, end=2**31 - 1):\n        \"\"\"subscribe(string, int, double, list(integer), int, int) -> None\n\n        Subscribe to one or more object values of the given domain around the\n        given objectID in a given radius\n        \"\"\"\n        Domain.subscribeContext(\n            self, objectID, domain, dist, varIDs, begin, end)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the manifest document in the given datamodel.", "response": "def initialize(self, version, force=False):\n        \"\"\"\n        Initialize the manifest document in the given datamodel\n\n        :param version: Actual version of the datamodel\n        :param force: Replace manifest if it already exists\n        \"\"\"\n        _check_version_format(version)\n        if not force and self.collection.find_one({'_id': 'manifest'}):\n            raise DatamodelManifestError(\"Datamodel has already a manifest\")\n        manifest = self.collection.update({'_id': 'manifest'}, {\n            '_id': 'manifest', 'version': version, 'history': [\n                {'timestamp': datetime.utcnow(), 'version': version,\n                 'reason': 'Initialize version'}\n            ]}, upsert=True)\n        return manifest"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, version, reason=None):\n        _check_version_format(version)\n        return self.collection.update({'_id': 'manifest'}, {\n            '$set': {'version': version},\n            '$push': {'history': {\n                'timestamp': datetime.utcnow(), 'version': version,\n                'reason': reason}}\n        })", "response": "Modify the datamodel s manifest with new version"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef discover_and_apply(self, directory=None, dry_run=False):\n        directory = directory or self.patches_dir\n        patches_dict = {p.base_version: p for p in self.discover(directory)}\n        current_version = self.manifest.version\n        if not patches_dict.get(current_version):\n            print('No patch to apply')\n            return\n        if dry_run:\n            msg = 'Datamodel should be in version %s !'\n        else:\n            msg = 'Datamodel in now in version %s !'\n        pss = []\n        while True:\n            patch = patches_dict.get(current_version)\n            if not patch:\n                print(msg % current_version)\n                if pss:\n                    print()\n                    print(yellow('\\n'.join(pss)))\n                return\n            print('Applying patch %s => %s' % (patch.base_version,\n                                               patch.target_version))\n            patch_pss = [patch.ps] if patch.ps else []\n            if not dry_run:\n                patch_pss += self.apply_patch(patch)\n            if patch_pss:\n                pss.append(\"Patch %s:\\n%s\" % (patch.target_version,\n                                              tabulate('\\n'.join(patch_pss))))\n            self.manifest.reload()\n            current_version = patch.target_version", "response": "Retrieve the patches and apply them against the datamodel."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking that the current datamodel s manifest has the correct version to run the patch", "response": "def can_be_applied(self, manifest, db):\n        \"\"\"\n        Check the current datamodel state fulfill the requirements\n        to run this patch\n        \"\"\"\n        if manifest.version != self.base_version:\n            raise DatamodelManifestError(\n                \"Datamodel's manifest shows incompatible version to \"\n                \"apply the patch (required: %s, available: %s)\" %\n                (self.base_version, manifest.version))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun the given patch to update the datamodel", "response": "def apply(self, manifest, db, force=False):\n        \"\"\"\n        Run the given patch to update the datamodel\n\n        :return: the list of post-scriptum returned by the fixes\n        \"\"\"\n        fixes_pss = []\n        if not force:\n            self.can_be_applied(manifest, db)\n        for fix in self.fixes:\n            print('\\t%s...' % fix.__name__, flush=True, end='')\n            ps = fix(db)\n            if ps:\n                fixes_pss.append(\"%s: %s\" % (fix.__name__, ps))\n            print(' Done !')\n        manifest.update(self.target_version,\n                        reason='Upgrade from %s' % self.base_version)\n        return fixes_pss"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __parseResponseServer(self):\n        \n        self.__logger.debug(Sitools2Abstract.getBaseUrl(self) + SITools2Instance.PROJECTS_URI)        \n        result = Util.retrieveJsonResponseFromServer(Sitools2Abstract.getBaseUrl(self) + SITools2Instance.PROJECTS_URI)\n        isSuccess = result['success']\n        if isSuccess:            \n            data = result['data']\n            self.__logger.debug(data)\n            for i, dataItem in enumerate(data):\n                project = Project(Sitools2Abstract.getBaseUrl(self), dataItem)\n                self.__projects.append(project)\n        else:\n            raise Sitools2Exception(\"Error when loading the server response\")", "response": "Parses the response from the server and adds the projects to the list of projects that are available."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __parseResponseServer(self, uri):\n        \n        self.__logger.debug(\"URL to parse: %s\"%(Sitools2Abstract.getBaseUrl(self) + uri))\n        result = Util.retrieveJsonResponseFromServer(Sitools2Abstract.getBaseUrl(self) + uri)            \n        isSuccess = result['success']\n        if isSuccess:\n            data = result['project']            \n            return data\n        else:\n            raise Sitools2Exception(\"Error when loading the server response\")", "response": "Parses the server response and returns the data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __parseDatasets(self):\n        datasets = []\n        if self.__dataItem.has_key('dataSets'):\n            for dataset in self.__dataItem['dataSets']:\n                datasets.append(DataSet(Sitools2Abstract.getBaseUrl(self), dataset))\n        return datasets", "response": "Returns the list of Dataset related to the project."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the project image when available.", "response": "def getImage(self):\n        \"\"\"Returns the project image when available.\"\"\"\n        value = self.__getNone(self.__dataItem['image']['url'])\n        if value == None:\n            return None\n        else:\n            return Sitools2Abstract.getBaseUrl(self) + self.__dataItem['image']['url']"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a Dataset Object by its name.", "response": "def getDatasetByName(self, name):\n        \"\"\"Returns a Dataset Object by its name.\n        Input\n        -----\n        name : dataset name to search\n        \n        Return\n        ------\n        A Dataset Object or None when the dataset is not found\n        \"\"\"\n        \n        result = None\n        for dataset in self.__datasets:\n            datasetName = dataset.getName()\n            if datasetName == name:\n                result = dataset\n                break\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __parseColumns(self):\n        columns = []\n        if self.__dataItem.has_key('columnModel'):\n            for column in self.__dataItem['columnModel']:\n                columns.append(Column(column))\n        return columns", "response": "Returns the list of columns related to the dataset."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a column object from its name.", "response": "def getColumnByColumnAlias(self, name):\n        \"\"\"Returns a column from its name.\n        Input\n        -----\n        name : columnAlias of the column to retrieve\n        \n        Return\n        ------\n        A Column object or None when the name cannot be found.        \n        \"\"\"\n        result = None\n        for column in self.__columns:\n            columnAlias = column.getColumnAlias()\n            if columnAlias == name:\n                result = column\n                break\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the search capability.", "response": "def getSearch(self):\n        \"\"\"Returns the search capability.\"\"\"\n        return Search(self.getColumns(), Sitools2Abstract.getBaseUrl(self) + self.getUri())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform lookup for series by name", "response": "def get_series_by_name(self, series_name):\n        \"\"\"Perform lookup for series\n\n        :param str series_name: series name found within filename\n        :returns: instance of series\n        :rtype: object\n        \"\"\"\n        series = trakt.Trakt['search'].query(series_name, 'show')\n        if not series:\n            return None, 'Not Found'\n        return series[0], None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nperforming lookup for a series by id", "response": "def get_series_by_id(self, series_id):\n        \"\"\"Perform lookup for series\n\n        :param int series_id: series id of series\n        :returns: instance of series\n        :rtype: object\n        \"\"\"\n        series = trakt.Trakt['search'].lookup(series_id, 'trakt-show')\n        if not series:\n            return None, 'Not Found'\n        return series, None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_episode_name(self, series, episode_numbers, season_number):\n        ids = series.to_identifier()\n        series_id = ids['ids']['trakt']\n\n        epnames = []\n        for epno in episode_numbers:\n            try:\n                episode = trakt.Trakt['shows'].episode(\n                    series_id, season_number, epno, exceptions=True)\n            except exceptions.RequestError as err:\n                LOG.exception('fetch episode %s S%sE%s failed',\n                              series_id, season_number, epno)\n                return None, str(err)\n\n            epnames.append(episode.title)\n\n        return epnames, None", "response": "Perform lookup for name of episode numbers for a given series."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mapTrace(trace, net, delta, verbose=False):\n    result = []\n    paths = {}\n    if verbose:\n        print(\"mapping trace with %s points\" % len(trace))\n    for pos in trace:\n        newPaths = {}\n        candidates = net.getNeighboringEdges(pos[0], pos[1], delta)\n        if len(candidates) == 0 and verbose:\n            print(\"Found no candidate edges for %s,%s\" % pos)\n        for edge, d in candidates:\n            if paths:\n                minDist = 1e400\n                minPath = None\n                for path, dist in paths.iteritems():\n                    if dist < minDist:\n                        if edge == path[-1]:\n                            minPath = path\n                            minDist = dist\n                        elif edge in path[-1].getOutgoing():\n                            minPath = path + (edge,)\n                            minDist = dist\n                        else:\n                            minPath = path + (edge,)\n                            minDist = dist + euclidean(\n                                path[-1].getToNode().getCoord(),\n                                edge.getFromNode().getCoord())\n                if minPath:\n                    newPaths[minPath] = minDist + d * d\n            else:\n                newPaths[(edge,)] = d * d\n        if not newPaths:\n            if paths:\n                result += [e.getID() for e in _getMinPath(paths)]\n        paths = newPaths\n    if paths:\n        return result + [e.getID() for e in _getMinPath(paths)]\n    return result", "response": "Map a list of 2D positions to consecutive edges in a network."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a file path.", "response": "def path(*components):\n    \"\"\"\n    Get a file path.\n\n    Concatenate all components into a path.\n    \"\"\"\n    _path = os.path.join(*components)\n    _path = os.path.expanduser(_path)\n\n    return _path"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef must_exist(*components):\n    _path = path(*components)\n    if not exists(_path):\n        raise File404(_path)\n    return _path", "response": "Ensure path exists.\n\n    Arguments:\n        *components (str[]): Path components.\n\n    Returns:\n        str: File path.\n\n    Raises:\n        File404: If path does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndetermining if child is a subdirectory of parent.", "response": "def is_subdir(child, parent):\n    \"\"\"\n    Determine if \"child\" is a subdirectory of \"parent\".\n\n    If child == parent, returns True.\n    \"\"\"\n    child_path = os.path.realpath(child)\n    parent_path = os.path.realpath(parent)\n\n    if len(child_path) < len(parent_path):\n        return False\n\n    for i in range(len(parent_path)):\n        if parent_path[i] != child_path[i]:\n            return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nchange working directory. Returns absolute path to new working directory.", "response": "def cd(path):\n    \"\"\"\n    Change working directory.\n\n    Returns absolute path to new working directory.\n    \"\"\"\n    _cdhist.append(pwd())  # Push to history.\n    path = abspath(path)\n    os.chdir(path)\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the last directory in the current working directory.", "response": "def cdpop():\n    \"\"\"\n    Return the last directory.\n\n    Returns absolute path to new working directory.\n    \"\"\"\n    if len(_cdhist) >= 1:\n        old = _cdhist.pop()  # Pop from history.\n        os.chdir(old)\n        return old\n    else:\n        return pwd()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef isexe(*components):\n    _path = path(*components)\n    return isfile(_path) and os.access(_path, os.X_OK)", "response": "Check if a path is an executable file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of files in a directory.", "response": "def ls(root=\".\", abspaths=False, recursive=False):\n    \"\"\"\n    Return a list of files in directory.\n\n    Directory listings are sorted alphabetically. If the named\n    directory is a file, return it's path.\n\n    Examples:\n\n        >>> fs.ls(\"foo\")\n        [\"a\", \"b\", \"c\"]\n\n        >>> fs.ls(\"foo/a\")\n        [\"foo/a\"]\n\n        >>> fs.ls(\"foo\", abspaths=True)\n        [\"/home/test/foo/a\", \"/home/test/foo/b\", \"/home/test/foo/c\"]\n\n        >>> fs.ls(\"foo\", recursive=True)\n        [\"a\", \"b\", \"b/d\", \"b/d/e\", \"c\"]\n\n    Arguments:\n\n        root (str): Path to directory. Can be relative or absolute.\n        abspaths (bool, optional): Return absolute paths if true.\n        recursive (bool, optional): Recursively list subdirectories if\n          true.\n\n    Returns:\n\n        list of str: A list of paths.\n\n    Raises:\n\n        OSError: If root directory does not exist.\n    \"\"\"\n    def _expand_subdirs(file):\n        if isdir(path(root, file)):\n            return [file] + [path(file, x) for x in\n                             ls(path(root, file), recursive=True)]\n        else:\n            return [file]\n\n    if isfile(root):\n        # If argument is a file, return path.\n        return [abspath(root)] if abspaths else [basename(root)]\n    elif abspaths:\n        # Get relative names.\n        relpaths = ls(root, recursive=recursive, abspaths=False)\n        # Prepend the absolute path to each relative name.\n        base = abspath(root)\n        return [path(base, relpath) for relpath in relpaths]\n    elif recursive:\n        # Recursively expand subdirectories.\n        paths = ls(root, abspaths=abspaths, recursive=False)\n        return labtypes.flatten([_expand_subdirs(file) for file in paths])\n    else:\n        # List directory contents.\n        return list(sorted(os.listdir(root)))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn only subdirectories from a directory listing.", "response": "def lsdirs(root=\".\", **kwargs):\n    \"\"\"\n    Return only subdirectories from a directory listing.\n\n    Arguments:\n\n        root (str): Path to directory. Can be relative or absolute.\n        **kwargs: Any additional arguments to be passed to ls().\n\n    Returns:\n\n        list of str: A list of directory paths.\n\n    Raises:\n\n        OSError: If root directory does not exist.\n    \"\"\"\n    paths = ls(root=root, **kwargs)\n    if isfile(root):\n        return []\n    return [_path for _path in paths if isdir(path(root, _path))]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns only files from a directory listing.", "response": "def lsfiles(root=\".\", **kwargs):\n    \"\"\"\n    Return only files from a directory listing.\n\n    Arguments:\n\n        root (str): Path to directory. Can be relative or absolute.\n        **kwargs: Any additional arguments to be passed to ls().\n\n    Returns:\n\n        list of str: A list of file paths.\n\n    Raises:\n\n        OSError: If root directory does not exist.\n    \"\"\"\n    paths = ls(root=root, **kwargs)\n    if isfile(root):\n        return paths\n    return [_path for _path in paths if isfile(path(root, _path))]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rm(*components, **kwargs):\n    _path = path(*components)\n    glob = kwargs.get(\"glob\", True)\n    paths = iglob(_path) if glob else [_path]\n\n    for file in paths:\n        if isfile(file):\n            os.remove(file)\n        elif exists(file):\n            shutil.rmtree(file, ignore_errors=False)", "response": "Removes a file or directory or directory recursively."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cp(src, dst):\n    if isdir(src):\n        # Overwrite an existing directory.\n        if isdir(dst):\n            rm(dst)\n        shutil.copytree(src, dst)\n    elif isfile(src):\n        shutil.copy(src, dst)\n    else:\n        raise IOError(\"Source '{0}' not found\".format(src))", "response": "Copy a file or directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmoving a file or directory.", "response": "def mv(src, dst):\n    \"\"\"\n    Move a file or directory.\n\n    If the destination already exists, this will attempt to overwrite\n    it.\n\n    Arguments:\n\n        src (string): path to the source file or directory.\n        dst (string): path to the destination file or directory.\n\n    Raises:\n\n        File404: if source does not exist.\n        IOError: in case of error.\n    \"\"\"\n    if not exists(src):\n        raise File404(src)\n\n    try:\n        shutil.move(src, dst)\n    except Exception as e:\n        raise IOError(str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mkdir(*components, **kwargs):\n    _path = path(*components)\n    if not isdir(_path):\n        os.makedirs(_path, **kwargs)\n    return _path", "response": "Make directory path including any required parents."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread a single or multiple components from a file and returns a list of lines.", "response": "def read(*components, **kwargs):\n    \"\"\"\n    Read file and return a list of lines. If comment_char is set, ignore the\n    contents of lines following the comment_char.\n\n    Raises:\n\n        IOError: if reading path fails\n    \"\"\"\n    rstrip = kwargs.get(\"rstrip\", True)\n    comment_char = kwargs.get(\"comment_char\", None)\n\n    ignore_comments = comment_char is not None\n\n    file = open(path(*components))\n    lines = file.readlines()\n    file.close()\n\n    # Multiple definitions to handle all cases.\n    if ignore_comments:\n        comment_line_re = re.compile(\"^\\s*{char}\".format(char=comment_char))\n        not_comment_re = re.compile(\"[^{char}]+\".format(char=comment_char))\n\n        if rstrip:\n            # Ignore comments, and right strip results.\n            return [re.match(not_comment_re, line).group(0).rstrip()\n                    for line in lines\n                    if not re.match(comment_line_re, line)]\n        else:\n            # Ignore comments, and don't strip results.\n            return [re.match(not_comment_re, line).group(0)\n                    for line in lines\n                    if not re.match(comment_line_re, line)]\n    elif rstrip:\n        # No comments, and right strip results.\n        return [line.rstrip() for line in lines]\n    else:\n        # Just a good old-fashioned read!\n        return lines"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the size of a file in bytes or as a human - readable string.", "response": "def du(*components, **kwargs):\n    \"\"\"\n    Get the size of a file in bytes or as a human-readable string.\n\n    Arguments:\n\n        *components (str[]): Path to file.\n        **kwargs: If \"human_readable\" is True, return a formatted string,\n          e.g. \"976.6 KiB\" (default True)\n\n    Returns:\n        int or str: If \"human_readble\" kwarg is True, return str, else int.\n    \"\"\"\n    human_readable = kwargs.get(\"human_readable\", True)\n\n    _path = path(*components)\n    if not exists(_path):\n        raise Error(\"file '{}' not found\".format(_path))\n    size = os.stat(_path).st_size\n    if human_readable:\n        return naturalsize(size)\n    else:\n        return size"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_file(path):\n    with open(must_exist(path)) as infile:\n        r = infile.read()\n    return r", "response": "Reads a file into a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of all file paths from a list of files or directories.", "response": "def files_from_list(*paths):\n    \"\"\"\n    Return a list of all file paths from a list of files or directories.\n\n    For each path in the input: if it is a file, return it; if it is a\n    directory, return a list of files in the directory.\n\n    Arguments:\n        paths (list of str): List of file and directory paths.\n\n    Returns:\n        list of str: Absolute file paths.\n\n    Raises:\n        File404: If any of the paths do not exist.\n    \"\"\"\n    ret = []\n    for path in paths:\n        if isfile(path):\n            ret.append(abspath(path))\n        elif isdir(path):\n            ret += [f for f in ls(path, abspaths=True, recursive=True)\n                    if isfile(f)]\n        else:\n            raise File404(path)\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pdf(options):\n    rc = run_sphinx(options, 'pdf')\n    if rc:\n        print('skipping the rest of the build, sphinx returned', rc)\n        return rc\n    options.order('pdf')\n    pdflatex = options.get('pdflatex', 'pdflatex')\n    paths = _get_paths(options)\n    outdir = options.get('outdir', paths.builddir / options.builder)\n    sh('cd %s; PDFLATEX=\"%s\" make -e' % (outdir, pdflatex))\n    return", "response": "Generate a PDF file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run_sphinx(options, *option_sets):\n    if 'sphinx' not in option_sets:\n        option_sets += ('sphinx',)\n    kwds = dict(add_rest=False)\n\n    # Set the search order of the options\n    options.order(*option_sets, **kwds)\n\n    paths = _get_and_create_paths(options)\n    template_args = [\n        '-A%s=%s' % (name, value)\n        for (name, value) in getattr(options, 'template_args', {}).items()\n    ]\n    config_args = [\n        '-D%s=%s' % (name, value)\n        for (name, value) in getattr(options, 'config_args', {}).items()\n    ]\n    sphinxopts = []\n    sphinxopts.extend([\n        '-b', options.get('builder', 'html'),\n        '-d', paths.doctrees,\n        '-c', paths.confdir,\n    ])\n\n    if options.get('force_all', False):\n        sphinxopts.append('-a')\n    if options.get('freshenv', False):\n        sphinxopts.append('-E')\n    if options.get('warnerror', False):\n        sphinxopts.append('-W')\n    if options.get('quiet', False):\n        sphinxopts.append('-Q')\n\n    sphinxopts.extend(template_args)\n    sphinxopts.extend(config_args)\n    sphinxopts.extend([paths.srcdir, paths.outdir])\n    rc = sh(\"sphinx-build {}\".format(\" \".join(sphinxopts)))\n\n    options.order()\n    return rc", "response": "This function is used to run sphinx with common options."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_and_create_paths(options):\n    paths = _get_paths(options)\n    paths.builddir.mkdir_p()\n    paths.outdir.mkdir_p()\n    paths.doctrees.mkdir_p()\n    return paths", "response": "Retrieves and creates the required paths needed to run sphinx."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_paths(options):\n    opts = options\n\n    docroot = path(opts.get('docroot', 'docs'))\n    if not docroot.exists():\n        raise BuildFailure(\"Sphinx documentation root (%s) does not exist.\"\n                           % docroot)\n\n    builddir = docroot / opts.get(\"builddir\", \".build\")\n\n    srcdir = docroot / opts.get(\"sourcedir\", \"\")\n    if not srcdir.exists():\n        raise BuildFailure(\"Sphinx source file dir (%s) does not exist\"\n                           % srcdir)\n\n    # Where is the sphinx conf.py file?\n    confdir = path(opts.get('confdir', srcdir))\n\n    # Where should output files be generated?\n    outdir = opts.get('outdir', '')\n    if outdir:\n        outdir = path(outdir)\n    else:\n        outdir = builddir / opts.get('builder', 'html')\n\n    # Where are doctrees cached?\n    doctrees = opts.get('doctrees', '')\n    if not doctrees:\n        doctrees = builddir / \"doctrees\"\n    else:\n        doctrees = path(doctrees)\n\n    return Bunch(locals())", "response": "Retrieves paths needed to run sphinx."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_script(input_file, script_name,\n               interpreter='python',\n               include_prefix=True,\n               ignore_error=False,\n               trailing_newlines=True,\n               break_lines_at=0,\n               line_break_mode='break',\n               adjust_python_for_version=True,\n               line_cleanups=[],\n               ):\n    \"\"\"Run a script in the context of the input_file's directory,\n    return the text output formatted to be included as an rst\n    literal text block.\n\n    Arguments:\n\n     input_file\n      The name of the file being processed by cog.  Usually passed as\n      cog.inFile.\n\n     script_name\n       The name of the Python script living in the same directory as\n       input_file to be run.  If not using an interpreter, this can be\n       a complete command line.  If using an alternate interpreter, it\n       can be some other type of file. If the command line is very\n       long, this can be a list of parts. They will be displayed\n       with backslashes indicating the continuation from line to line,\n       but will be joined with a space character into a single string\n       to be executed.\n\n     include_prefix=True\n       Boolean controlling whether the :: prefix is included.\n\n     ignore_error=False\n       Boolean controlling whether errors are ignored.  If not\n       ignored, the error is printed to stdout and then the command is\n       run *again* with errors ignored so that the output ends up in\n       the cogged file.\n\n     trailing_newlines=True\n       Boolean controlling whether the trailing newlines are added to\n       the output.  If False, the output is passed to rstrip() then\n       one newline is added.  If True, newlines are added to the\n       output until it ends in 2.\n\n     break_lines_at=0\n       Integer indicating the length where lines should be broken and\n       continued on the next line.  Defaults to 0, meaning no special\n       handling should be done.\n\n     line_break_mode='break'\n       Name of mode to break lines.\n\n         break\n           Insert a hard break\n         continue\n           Insert a hard break with a backslash\n         wrap\n           Use textwrap.fill() to wrap\n         wrap-no-breaks\n           Use textwrap.fill() without breaking on hyphens\n           or long words\n         fill\n           Use textwrap.fill(), maintaining whitespace prefix\n           on subsequent lines\n         continue\n           Insert a hard break and backslash at the end of\n           long lines, continuing on the next\n         truncate\n           Chop the line at the required width and discard the\n           remainder\n\n    adjust_python_for_version=True\n      Boolean controlling whether the default `python`\n      interpreter setting is changed to `python3` when\n      running under python 3.\n\n    line_cleanups=[]\n      Process each output line through the cleanups and replace the\n      input line with the output values. Each cleanup should be a\n      callable that accepts the name of the original input file and\n      the line of output produced and returns a replacement string, or\n      the original input string if no changes are to be made.\n\n    \"\"\"\n    rundir = path(input_file).dirname()\n    if (adjust_python_for_version\n            and interpreter == 'python'\n            and sys.version_info[0] == 3):\n        # Automatically switch to python3 if we're running under\n        # python3 ourselves.\n        interpreter = 'python3'\n    cmd_list = script_name\n    if isinstance(script_name, list):\n        # We've been given a list, convert it to a string.\n        script_name = ' '.join(cmd_list)\n    if interpreter:\n        cmd = '%(interpreter)s %(script_name)s' % {\n            'interpreter': interpreter,\n            'script_name': script_name,\n        }\n    else:\n        cmd = script_name\n    real_cmd = 'cd %(rundir)s; %(cmd)s 2>&1' % {\n        'rundir': rundir,\n        'cmd': cmd,\n    }\n    try:\n        print()\n        output_text = sh(real_cmd, capture=True, ignore_error=ignore_error)\n        print(output_text)\n    except Exception as err:\n        print('*' * 50)\n        print('ERROR run_script(%s) => %s' % (real_cmd, err))\n        print('*' * 50)\n        output_text = sh(real_cmd, capture=True, ignore_error=True)\n        print(output_text)\n        print('*' * 50)\n        if not ignore_error:\n            raise\n    if include_prefix:\n        response = '\\n.. code-block:: none\\n\\n'\n    else:\n        response = ''\n\n    # Start building our result list.\n    lines = []\n\n    # Add the command we ran to the result.\n    if isinstance(cmd_list, list):\n        # We were originally given a list, so interpret the\n        # parts as already split up. Add the continuation\n        # markers to the end.\n        if interpreter:\n            lines.append('\\t$ {} {}'.format(interpreter, cmd_list[0] + ' \\\\'))\n        else:\n            lines.append('\\t$ {}'.format(cmd_list[0] + ' \\\\'))\n        lines.extend(\n            l + ' \\\\'\n            for l in cmd_list[1:-1]\n        )\n        lines.append(cmd_list[-1])\n    else:\n        raw_command_line = '\\t$ %s' % cmd\n        for cleanup in line_cleanups:\n            raw_command_line = cleanup(input_file, raw_command_line)\n        command_line = adjust_line_widths(\n            [raw_command_line],\n            break_lines_at - 1 if break_lines_at else 64,\n            'continue',\n        )\n        lines.extend(command_line)\n\n    lines.append('')  # a blank line\n    lines.extend(output_text.splitlines())  # the output\n\n    # Clean up the raw output lines.\n    clean_lines = []\n    for line in lines:\n        for cleanup in line_cleanups:\n            line = cleanup(input_file, line)\n        clean_lines.append(line)\n    lines = clean_lines\n\n    # Deal with lines that might be too long\n    if break_lines_at:\n        lines = adjust_line_widths(lines, break_lines_at, line_break_mode)\n\n    response += '\\n\\t'.join(lines)\n    if trailing_newlines:\n        while not response.endswith('\\n\\n'):\n            response += '\\n'\n    else:\n        response = response.rstrip()\n        response += '\\n'\n    return response", "response": "This function runs a Python script in the context of the input_file s directory and returns the output formatted to be included as an rst tree literal text block."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _runcog(options, files, uncog=False):\n    options.order('cog', 'sphinx', add_rest=True)\n    c = Cog()\n    if uncog:\n        c.options.bNoGenerate = True\n    c.options.bReplace = True\n    c.options.bDeleteCode = options.get(\"delete_code\", False)\n    includedir = options.get('includedir', None)\n    if includedir:\n        include = Includer(includedir, cog=c,\n                           include_markers=options.get(\"include_markers\"))\n        # load cog's namespace with our convenience functions.\n        c.options.defines['include'] = include\n        c.options.defines['sh'] = _cogsh(c)\n\n    c.options.sBeginSpec = options.get('beginspec', '[[[cog')\n    c.options.sEndSpec = options.get('endspec', ']]]')\n    c.options.sEndOutput = options.get('endoutput', '[[[end]]]')\n\n    basedir = options.get('basedir', None)\n    if basedir is None:\n        basedir = (path(options.get('docroot', \"docs\"))\n                   / options.get('sourcedir', \"\"))\n    basedir = path(basedir)\n\n    if not files:\n        pattern = options.get(\"pattern\", \"*.rst\")\n        if pattern:\n            files = basedir.walkfiles(pattern)\n        else:\n            files = basedir.walkfiles()\n    for f in sorted(files):\n        dry(\"cog %s\" % f, c.processOneFile, f)", "response": "Common function for the cog and runcog tasks."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun cog against all or a subset of the input source files.", "response": "def cog(options):\n    \"\"\"Run cog against all or a subset of the input source files.\n\n    Examples::\n\n      $ paver cog PyMOTW/atexit\n      $ paver cog PyMOTW/atexit/index.rst\n      $ paver cog\n\n    See help on paver.doctools.cog for details on the standard\n    options.\n    \"\"\"\n    options.order('cog', 'sphinx', add_rest=True)\n    # Figure out if we were given a filename or\n    # directory, and scan the directory for files\n    # if we need to.\n    files_to_cog = getattr(options, 'args', [])\n    if files_to_cog and os.path.isdir(files_to_cog[0]):\n        dir_to_scan = path(files_to_cog[0])\n        files_to_cog = list(dir_to_scan.walkfiles(\n            options.get(\"pattern\", \"*.rst\")\n        ))\n    try:\n        _runcog(options, files_to_cog)\n    except Exception as err:\n        print('ERROR: %s' % err)\n        raise\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the user has called the task with a server name. Fabric tasks decorated with this decorator must be called like so:: fab <server name> <task name> If no server name is given, the task will not be executed.", "response": "def require_server(fn):\n    \"\"\"\n    Checks if the user has called the task with a server name.\n\n    Fabric tasks decorated with this decorator must be called like so::\n\n        fab <server name> <task name>\n\n    If no server name is given, the task will not be executed.\n\n    \"\"\"\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        if env.machine is None:\n            abort(red('ERROR: You must provide a server name to call this'\n                      ' task!'))\n        return fn(*args, **kwargs)\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the mongopatcher for the application.", "response": "def init_patcher(app, db):\n    \"\"\"\n    Init mongopatcher for the application\n\n    :param app: :class:`flask.Flask` app to initialize\n    :param db: :class:`pymongo.MongoClient` to work on\n\n    .. note: This function must be called before using ``patcher_manager``\n    \"\"\"\n    app.config.setdefault('MONGOPATCHER_PATCHES_DIR', 'patches')\n    app.config.setdefault('MONGOPATCHER_COLLECTION', 'mongopatcher')\n    if not hasattr(app, 'extensions'):\n        app.extensions = {}\n    if 'mongopatcher' not in app.extensions:\n        mp = MongoPatcher(db=db,\n                          patches_dir=app.config['MONGOPATCHER_PATCHES_DIR'],\n                          collection=app.config['MONGOPATCHER_COLLECTION'])\n        app.extensions['mongopatcher'] = mp\n    else:\n        # Raise an exception if extension already initialized as\n        # potentially new configuration would not be loaded.\n        raise Exception('Extension already initialized')\n    if 'MONGOPATCHER_DATAMODEL_VERSION' not in app.config:\n        # Find last version from patches\n        patches = mp.discover(app.config['MONGOPATCHER_PATCHES_DIR'])\n        last_version = patches[-1].target_version if patches else '1.0.0'\n        app.config.setdefault('MONGOPATCHER_DATAMODEL_VERSION', last_version)\n    mp.__class__.need_upgrade = need_upgrade\n    mp.app_datamodel_version = app.config['MONGOPATCHER_DATAMODEL_VERSION']\n    return mp"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupgrade the datamodel by applying recusively the patches available", "response": "def upgrade(yes, dry_run, patches):\n    \"\"\"\n    Upgrade the datamodel by applying recusively the patches available\n    \"\"\"\n    patcher = _get_mongopatcher()\n    if dry_run:\n        patcher.discover_and_apply(directory=patches, dry_run=dry_run)\n    else:\n        if (yes or prompt_bool(\"Are you sure you want to alter %s\" %\n                               green(patcher.db))):\n            patcher.discover_and_apply(patches)\n        else:\n            raise SystemExit('You changed your mind, exiting...')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef discover(patches, verbose, name):\n    patches = _get_mongopatcher().discover(directory=patches)\n    if name:\n        import re\n        patches = [p for p in patches if re.match(name, p.target_version)]\n    if not patches:\n        print('No patches found')\n    else:\n        print('Patches available:')\n        for patch in patches:\n            if verbose:\n                print()\n                print(patch.target_version)\n                print(\"~\" * len(patch.target_version))\n                print(tabulate(patch.patchnote))\n            else:\n                print(' - %s' % patch.target_version)", "response": "List the patches available in the given patches directory"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing mongopatcher on the database by setting it manifest", "response": "def init(version, force):\n    \"\"\"Initialize mongopatcher on the database by setting it manifest\"\"\"\n    version = version or current_app.config['MONGOPATCHER_DATAMODEL_VERSION']\n    _get_mongopatcher().manifest.initialize(version, force)\n    print('Datamodel initialized to version %s' % version)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nshow version of the datamodel", "response": "def info(verbose):\n    \"\"\"Show version of the datamodel\"\"\"\n    if _get_mongopatcher().manifest.is_initialized():\n        print('Datamodel version: %s' % _get_mongopatcher().manifest.version)\n        if verbose:\n            print('\\nUpdate history:')\n            for update in reversed(_get_mongopatcher().manifest.history):\n                reason = update.get('reason')\n                reason = '(%s)' % reason if reason else ''\n                print(' - %s: %s %s' % (update['timestamp'], update['version'],\n                                        reason))\n    else:\n        print('Datamodel is not initialized')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_average(self, default=None):\n        try:\n            first_row = self.get_first()\n            if first_row:\n                count0 = first_row[0]['Count']\n            else:\n                count0 = 0\n            average = (self.count - count0) / (self.get_number_of_rows() - 1)\n        except Exception as e:\n            logging.error(e)\n            return default\n        else:\n            return average", "response": "Returns the average count value of the statistic s table rows."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef statsd_middleware_factory(app, handler):\n    @coroutine\n    def middleware(request):\n        \"\"\"Send stats to statsd.\"\"\"\n        timer = Timer()\n        timer.start()\n\n        statsd = yield from app.ps.metrics.client()\n        pipe = statsd.pipe()\n        pipe.incr('request.method.%s' % request.method)\n\n        try:\n            response = yield from handler(request)\n            pipe.incr('response.status.%s' % response.status)\n            return response\n\n        except HTTPException as exc:\n            pipe.incr('response.status.%s' % exc.status_code)\n            raise\n\n        except Exception:\n            pipe.incr('response.exception')\n            raise\n\n        finally:\n            timer.stop()\n            pipe.timing('response.time', timer.ms)\n            pipe.disconnect()\n\n    return middleware", "response": "Create a middleware that sends stats to statsd."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setup(self, app):\n        super().setup(app)\n\n        self.enabled = len(self.cfg.backends)\n\n        self.default = self.cfg.default\n        if not self.default and self.enabled:\n            self.default = self.cfg.backends[0][0]\n\n        self.backends_hash = {name: parse.urlparse(loc) for (name, loc) in self.cfg.backends}\n        if self.default and self.default not in self.backends_hash:\n            raise PluginException('Backend not found: %s' % self.default)", "response": "Parse and prepare the plugin s configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes a backend s client with given name or default.", "response": "def client(self, name=None):\n        \"\"\"Initialize a backend's client with given name or default.\"\"\"\n        name = name or self.default\n        if not name:\n            return NullClient(self, None, None)\n        params = self.backends_hash[name]\n        ccls = self.backends_schemas.get(params.scheme, TCPClient)\n        return (yield from ccls(self, params.hostname, params.port).connect())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend stat to backend.", "response": "def send(self, stat, value, backend=None):\n        \"\"\"Send stat to backend.\"\"\"\n        client = yield from self.client(backend)\n        if not client:\n            return False\n        client.send(stat, value)\n        client.disconnect()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisconnect from the socket.", "response": "def disconnect(self):\n        \"\"\"Disconnect from the socket.\"\"\"\n        if self.pipeline:\n            self._send(*self.pipeline)\n        self.transport.close()\n        self.transport = self.pipeline = None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_message(self, stat, value):\n        return ' '.join((self.prefix + str(stat), str(value), str(round(time()))))", "response": "Build a metric in Graphite format."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend a message to the backend.", "response": "def send(self, stat, value, rate=1):\n        \"\"\"Send message to backend.\"\"\"\n        if rate < 1 and random() > rate:\n            return\n\n        message = self.build_message(stat, value)\n        if not message:\n            return\n\n        if self.pipeline is None:\n            return self._send(message)\n\n        self.pipeline.append(message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a message to the remote peer.", "response": "def _send(self, *messages):\n        \"\"\"Send message.\"\"\"\n        if not self.transport:\n            return False\n\n        messages = [message.encode('ascii') for message in messages]\n        data = b''\n        while messages:\n            message = messages.pop(0)\n            if len(data + message) + 1 > self.parent.cfg.maxudpsize:\n                self.transport.sendto(data)\n                data = b''\n\n            data += message + b'\\n'\n\n        if data:\n            self.transport.sendto(data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconnect to the socket.", "response": "def connect(self):\n        \"\"\"Connect to socket.\"\"\"\n        try:\n            _, self.transport = yield from open_connection(\n                self.hostname, self.port, loop=self.parent.app.loop)\n        except OSError:\n            if self.parent.cfg.fail_silently:\n                return False\n            raise\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a message to the remote server.", "response": "def _send(self, *messages):\n        \"\"\"Send messages.\"\"\"\n        if not self.transport:\n            return False\n\n        message = '\\n'.join(messages) + '\\n'\n        self.transport.write(message.encode('ascii'))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef incr(self, stat, count=1, rate=1):\n        return self.send(stat, \"%s|c\" % count, rate)", "response": "Increment a stat by count."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends new timing information. delta is in milliseconds. rate is in milliseconds.", "response": "def timing(self, stat, delta, rate=1):\n        \"\"\"Send new timing information. `delta` is in milliseconds.\"\"\"\n        return self.send(stat, \"%d|ms\" % delta, rate)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send(self, stat, value, rate=1):\n        if rate < 1:\n            value = \"%s|@%s\" % (value, rate)\n        return super().send(stat, value, rate)", "response": "Send a message to the backend."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndisconnects from the socket.", "response": "def disconnect(self):\n        \"\"\"Disconnect from the socket.\"\"\"\n        if self.pipeline:\n            self._send(*self.pipeline)\n        self.pipeline = None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_options(settings):\n    '''Parse command line options'''\n    optlist, args = getopt(sys.argv, 'x', [])\n    settings['configfile'] = args[1]\n    return settings", "response": "Parse command line options and return settings dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_config(settings):\n    '''Load settings from configfile'''\n    config = ConfigParser()\n    section = 'pgdocgen'\n    try:\n        config.read(settings['configfile'])\n    except Exception as e:\n        sys.stderr.write('Failed to read config: ' + str(e))\n        sys.exit(1)\n    for option in config.options(section):\n        settings[option] = config.get(section, option)\n    return settings", "response": "Load settings from configfile"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the logger with the given settings.", "response": "def init_logging(settings):\n    '''Set up logger'''\n    lg_format = '%(asctime)s : - %(message)s'\n    lg_dateformat = '%Y.%m.%d %H:%M:%S'\n    logging.basicConfig(format=lg_format, datefmt=lg_dateformat)\n\n    log = get_logger()\n\n    handler = logging.handlers.WatchedFileHandler(\n                            filename=settings['log_file'] \\\n                            if 'log_file' in settings.keys() else None,\n                            encoding='utf-8')\n    formatter = logging.Formatter(fmt=lg_format, datefmt=lg_dateformat)\n    handler.setFormatter(formatter)\n    log.addHandler(handler)\n    return log"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef server_main(loop, path):\n    loop.fork()\n    logger.debug('forked function')\n    sigintwatcher = pyev.Signal(signal.SIGINT, loop, lambda watcher, events: logger.info('interrupt ignored'))\n    sigintwatcher.start()\n    sigtermwatcher = pyev.Signal(signal.SIGTERM, loop, server_stop)\n    sigtermwatcher.start()\n    adder = AdderService()\n    dispatcher = ObjectDispatch(adder)\n    pickle_factory = PickleProtocolFactory(dispatcher)\n    pickle_server = UnixServer(loop, pickle_factory, path)\n    pickle_server.start()\n    msgpack_factory = MsgPackProtocolFactory(dispatcher)\n    msgpack_server = UnixServer(loop, msgpack_factory, path + '_mp')\n    msgpack_server.start()\n\n    logger.debug('running server loop')\n\n    import cProfile\n    cProfile.runctx('loop.loop()', None, {'loop':loop}, 'server_profile')\n\n    logger.debug('server unlooped')", "response": "Run in the client after the fork."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the Application package directory in the path.", "response": "def _set_package_directory():\n    \"\"\"\n    Sets the Application package directory in the path.\n    \"\"\"\n\n    package_directory = os.path.normpath(os.path.join(os.path.dirname(__file__), \"../\"))\n    package_directory not in sys.path and sys.path.append(package_directory)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstarting the Application. :return: Definition success. :rtype: bool", "response": "def main():\n    \"\"\"\n    Starts the Application.\n\n    :return: Definition success.\n    :rtype: bool\n    \"\"\"\n\n    components_paths = []\n    for path in (os.path.join(umbra.__path__[0], Constants.factory_components_directory),\n                 os.path.join(umbra.__path__[0], Constants.factory_addons_components_directory)):\n        os.path.exists(path) and components_paths.append(path)\n    return umbra.engine.run(umbra.engine.Umbra,\n                            umbra.engine.get_command_line_parameters_parser().parse_args(\n                                [unicode(argument, Constants.default_codec, Constants.codec_error) for argument in\n                                 sys.argv]),\n                            components_paths,\n                            (\"factory.script_editor\", \"factory.preferences_manager\", \"factory.components_manager_ui\"))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef define_options(default_conf):\n    default = {}\n    with open(default_conf, 'rb') as f:\n        exec_in(native_str(f.read()), {}, default)\n\n    for name, value in default.iteritems():\n        # if the option is already defined by tornado\n        # override the value\n        # a list of options set by tornado:\n        # log_file_num_backups, logging, help,\n        # log_to_stderr, log_file_max_size, log_file_prefix\n        if name in options:\n            setattr(options, name, value)\n        # otherwise define the option\n        else:\n            define(name, value)", "response": "Define the options from default. conf dynamically"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs the config used to start the application", "response": "def log_config():\n    \"\"\"Logs the config used to start the application\"\"\"\n    conf = '\\n'.join(\n            ['{}=\"{}\"'.format(k, v) for k, v\n             in sorted(options.as_dict().iteritems())])\n    logging.info('Service started with the following settings:\\n' + conf)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef log_formatter(request=None):\n\n    if request:\n        format_str = ('%(asctime)s {ip} {name}:  ENV={env} '\n                      'REMOTE_IP=%(remote_ip)s REQUEST_ID=%(request_id)s '\n                      '%(message)s')\n    else:\n        format_str = '%(asctime)s {ip} {name}:  ENV={env} %(message)s'\n\n    try:\n        hostname = socket.gethostname()\n    except socket.gaierror:\n        hostname = 'localhost'\n\n    try:\n        ip = socket.gethostbyname(hostname)\n    except socket.gaierror:\n        ip = '127.0.0.1'\n\n    formatter = logging.Formatter(\n            format_str.format(ip=ip, name=options.name, env=options.env),\n            datefmt='%Y-%m-%dT%H:%M:%S')\n    logging.Formatter.converter = time.gmtime\n\n    return formatter", "response": "Returns a logging. Formatter that can be used in our syslog log file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef configure_syslog(request=None, logger=None, exceptions=False):\n    syslog_host = getattr(options, 'syslog_host', None)\n    if not syslog_host:\n        return\n\n    sys.modules[\"logging\"].raiseExceptions = exceptions\n    handler = SysLogHandler(address=(syslog_host, options.syslog_port))\n    formatter = log_formatter(request)\n    handler.setFormatter(formatter)\n\n    if request:\n        handler.addFilter(RequestFilter(request))\n\n    if logger:\n        logger.addHandler(handler)\n    else:\n        logging.getLogger().addHandler(handler)", "response": "Configure syslog logging channel.\n    It is turned on by setting `syslog_host` in the config file.\n    The port default to 514 can be overridden by setting `syslog_port`.\n\n    :param request: tornado.httputil.HTTPServerRequest instance\n    :param exceptions: boolean - This indicates if we should raise\n        exceptions encountered in the logging system."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a tornado. web. Application instance from the given version and app_name and app_urls.", "response": "def make_application(version, app_name, app_urls, kwargs=None):\n    \"\"\"\n    Loads the routes and starts the server\n\n    :param version: the application version\n    :param app_name: the application name\n    :param app_urls: a list of application endpoints\n    :param kwargs: dictionary of options\n    :returns: tornado.web.Application instance\n    \"\"\"\n    if kwargs is None:\n        kwargs = {}\n\n    urls = make_endpoints(version, app_name, app_urls, kwargs)\n    application = tornado.web.Application(\n            urls,\n            default_handler_class=kwargs.get('default_handler_class', ErrorHandler))\n\n    return application"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a tornado server instance for the application.", "response": "def make_server(application, conf_dir=None):\n    \"\"\"\n    Configure the server return the server instance\n    \"\"\"\n    if conf_dir:\n        load_config(conf_dir)\n    configure_syslog()\n    log_config()\n    if options.use_ssl:\n        ssl_options = ssl_server_options()\n        server = tornado.httpserver.HTTPServer(\n                application, ssl_options=ssl_options)\n        general_logger.info(\n                'start tornado https server at https://%s:%s'\n                ' with ssl_options: %s', options.ip, options.port, ssl_options)\n    else:\n\n        server = tornado.httpserver.HTTPServer(application)\n        general_logger.info('start tornado http server at http://{0}:{1}'.format(\n                options.ip, options.port))\n\n    server.bind(options.port, options.ip)\n    return server"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef highlight_current_line(editor):\n\n    format = editor.language.theme.get(\"accelerator.line\")\n    if not format:\n        return False\n\n    extra_selections = editor.extraSelections() or []\n    if not editor.isReadOnly():\n        selection = QTextEdit.ExtraSelection()\n        selection.format.setBackground(format.background())\n        selection.format.setProperty(QTextFormat.FullWidthSelection, True)\n        selection.cursor = editor.textCursor()\n        selection.cursor.clearSelection()\n        extra_selections.append(selection)\n    editor.setExtraSelections(extra_selections)\n    return True", "response": "Highlights given editor current line."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhighlights given editor current line.", "response": "def highlight_occurences(editor):\n    \"\"\"\n    Highlights given editor current line.\n\n    :param editor: Document editor.\n    :type editor: QWidget\n    :return: Method success.\n    :rtype: bool\n    \"\"\"\n\n    format = editor.language.theme.get(\"accelerator.occurence\")\n    if not format:\n        return False\n\n    extra_selections = editor.extraSelections() or []\n    if not editor.isReadOnly():\n        word = editor.get_word_under_cursor()\n        if not word:\n            return False\n\n        block = editor.document().findBlock(0)\n        cursor = editor.document().find(word,\n                                        block.position(),\n                                        QTextDocument.FindCaseSensitively | QTextDocument.FindWholeWords)\n        while block.isValid() and cursor.position() != -1:\n            selection = QTextEdit.ExtraSelection()\n            selection.format.setBackground(format.background())\n            selection.cursor = cursor\n            extra_selections.append(selection)\n            cursor = editor.document().find(word,\n                                            cursor.position(),\n                                            QTextDocument.FindCaseSensitively | QTextDocument.FindWholeWords)\n            block = block.next()\n    editor.setExtraSelections(extra_selections)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef highlight_matching_symbols_pairs(editor):\n\n    format = editor.language.theme.get(\"accelerator.pair\")\n    if not format:\n        return False\n\n    extra_selections = editor.extraSelections() or []\n    if not editor.isReadOnly():\n        start_selection = QTextEdit.ExtraSelection()\n        start_selection.format.setBackground(format.background())\n        end_selection = QTextEdit.ExtraSelection()\n        end_selection.format.setBackground(format.background())\n\n        cursor = editor.textCursor()\n        if cursor.hasSelection():\n            text = foundations.strings.to_string(cursor.selectedText())\n        else:\n            cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.KeepAnchor)\n            text = foundations.strings.to_string(cursor.selectedText())\n\n        start_selection.cursor = cursor\n\n        if text in editor.language.symbols_pairs.keys():\n            extra_selections.append(start_selection)\n            end_selection.cursor = editor.get_matching_symbols_pairs(cursor,\n                                                                     text,\n                                                                     editor.language.symbols_pairs[text])\n        elif text in editor.language.symbols_pairs.values():\n            extra_selections.append(start_selection)\n            end_selection.cursor = editor.get_matching_symbols_pairs(cursor,\n                                                                     text,\n                                                                     editor.language.symbols_pairs.get_first_key_from_value(\n                                                                         text),\n                                                                     True)\n        else:\n            return False\n\n        extra_selections.append(end_selection)\n    editor.setExtraSelections(extra_selections)\n    return True", "response": "Highlights given editor matching pairs."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _absolute_template_path(fn):\n    return os.path.join(os.path.dirname(__file__), \"xslt\", fn)", "response": "Return absolute path for filename from local XSLT directory."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply func to all <mods : mods > tags from xml. Insert UUID.", "response": "def _apply_postprocessing(marc_xml, xml, func, uuid, url):\n    \"\"\"\n    Apply `func` to all ``<mods:mods>`` tags from `xml`. Insert UUID.\n\n    Args:\n        marc_xml (str): Original Aleph record.\n        xml (str): XML which will be postprocessed.\n        func (fn): Function, which will be used for postprocessing.\n        uuid (str): UUID, which will be inserted to `xml`.\n        url (str): URL of the publication (public or not).\n\n    Returns:\n        list: List of string with postprocessed XML.\n    \"\"\"\n    dom = dhtmlparser.parseString(xml)\n\n    return [\n        func(marc_xml, mods_tag, uuid, cnt, url)\n        for cnt, mods_tag in enumerate(dom.find(\"mods:mods\"))\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transform_to_mods_mono(marc_xml, uuid, url):\n    marc_xml = _read_content_or_path(marc_xml)\n\n    transformed = xslt_transformation(\n        marc_xml,\n        _absolute_template_path(\"MARC21slim2MODS3-4-NDK.xsl\")\n    )\n\n    return _apply_postprocessing(\n        marc_xml=marc_xml,\n        xml=transformed,\n        func=mods_postprocessor.postprocess_monograph,\n        uuid=uuid,\n        url=url,\n    )", "response": "Convert MARC XML to MODS data format."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert MARC XML to multimonograph MODS data format.", "response": "def transform_to_mods_multimono(marc_xml, uuid, url):\n    \"\"\"\n    Convert `marc_xml` to multimonograph MODS data format.\n\n    Args:\n        marc_xml (str): Filename or XML string. Don't use ``\\\\n`` in case of\n                        filename.\n        uuid (str): UUID string giving the package ID.\n        url (str): URL of the publication (public or not).\n\n    Returns:\n        list: Collection of transformed xml strings.\n    \"\"\"\n    marc_xml = _read_content_or_path(marc_xml)\n\n    transformed = xslt_transformation(\n        marc_xml,\n        _absolute_template_path(\"MARC21toMultiMonographTitle.xsl\")\n    )\n\n    return _apply_postprocessing(\n        marc_xml=marc_xml,\n        xml=transformed,\n        func=mods_postprocessor.postprocess_multi_mono,\n        uuid=uuid,\n        url=url,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transform_to_mods_periodical(marc_xml, uuid, url):\n    marc_xml = _read_content_or_path(marc_xml)\n\n    transformed = xslt_transformation(\n        marc_xml,\n        _absolute_template_path(\"MARC21toPeriodicalTitle.xsl\")\n    )\n\n    return _apply_postprocessing(\n        marc_xml=marc_xml,\n        xml=transformed,\n        func=mods_postprocessor.postprocess_periodical,\n        uuid=uuid,\n        url=url,\n    )", "response": "Convert MARC XML to periodical MODS data format."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef type_decisioner(marc_xml, mono_callback, multimono_callback,\n                    periodical_callback):\n    \"\"\"\n    Detect type of the `marc_xml`. Call proper callback.\n\n    Args:\n        marc_xml (str): Filename or XML string. Don't use ``\\\\n`` in case of\n                        filename.\n        mono_callback (fn reference): Callback in case of monographic\n                      publications.\n        multimono_callback (fn reference): Callback used in case of\n                           multi-monographic publications.\n        periodical_callback (fn reference): Callback used in case of periodical\n                            publications.\n\n    Returns:\n        obj: Content returned by the callback.\n\n    Raises:\n        ValueError: In case that type couldn't be detected.\n    \"\"\"\n    marc_xml = _read_content_or_path(marc_xml)\n    record = MARCXMLRecord(marc_xml)\n\n    if record.is_monographic or record.is_single_unit:\n        return mono_callback()\n    elif record.is_multi_mono:\n        return multimono_callback()\n    elif record.is_continuing:\n        return periodical_callback()\n\n    raise ValueError(\"Can't identify type of the `marc_xml`!\")", "response": "Detect type of the MARC XML file. Call proper callback."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef marcxml2mods(marc_xml, uuid, url):\n    marc_xml = _read_content_or_path(marc_xml)\n\n    return type_decisioner(\n        marc_xml,\n        lambda: transform_to_mods_mono(marc_xml, uuid, url),\n        lambda: transform_to_mods_multimono(marc_xml, uuid, url),\n        lambda: transform_to_mods_periodical(marc_xml, uuid, url),\n    )", "response": "Convert MARC XML to MODS."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a float in Vax format to IEEE format.", "response": "def _vax_to_ieee_single_float(data):\n    \"\"\"Converts a float in Vax format to IEEE format.\n\n    data should be a single string of chars that have been read in from\n    a binary file. These will be processed 4 at a time into float values.\n    Thus the total number of byte/chars in the string should be divisible\n    by 4.\n\n    Based on VAX data organization in a byte file, we need to do a bunch of\n    bitwise operations to separate out the numbers that correspond to the\n    sign, the exponent and the fraction portions of this floating point\n    number\n\n    role :      S        EEEEEEEE      FFFFFFF      FFFFFFFF      FFFFFFFF\n    bits :      1        2      9      10                               32\n    bytes :     byte2           byte1               byte4         byte3\n\n    \"\"\"\n    f = []\n    nfloat = int(len(data) / 4)\n    for i in range(nfloat):\n\n        byte2 = data[0 + i*4]\n        byte1 = data[1 + i*4]\n        byte4 = data[2 + i*4]\n        byte3 = data[3 + i*4]\n\n        # hex 0x80 = binary mask 10000000\n        # hex 0x7f = binary mask 01111111\n\n        sign = (byte1 & 0x80) >> 7\n        expon = ((byte1 & 0x7f) << 1) + ((byte2 & 0x80) >> 7)\n        fract = ((byte2 & 0x7f) << 16) + (byte3 << 8) + byte4\n\n        if sign == 0:\n            sign_mult = 1.0\n        else:\n            sign_mult = -1.0\n\n        if 0 < expon:\n            # note 16777216.0 == 2^24\n            val = sign_mult * (0.5 + (fract/16777216.0)) * pow(2.0, expon - 128.0)\n            f.append(val)\n        elif expon == 0 and sign == 0:\n            f.append(0)\n        else:\n            f.append(0)\n            # may want to raise an exception here ...\n\n    return f"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_contents(self):\n        '''Read all schemas in database'''\n        cur = self.conn.cursor()\n        cur.execute('''select nspname,\n                              description\n                        from pg_catalog.pg_namespace s\n                        left join pg_catalog.pg_description d\n                            on (d.objoid = s.oid)\n                        where s.nspname not like 'pg\\_%' and\n                        s.nspname <> 'information_schema'\n                        order by s.nspname''')\n        schemas = cur.fetchall()\n        cur.close()\n        from pgdocgen.ddlobject.schema import Schema\n        for (schema, comment) in [(x[0], x[1]) for x in schemas]:\n            schema_obj = Schema(schema, comment, self.conn)\n            self.contents.append(copy.deepcopy(schema_obj))\n        self.conn.close()", "response": "Read all schemas in database and add them to the list of contents"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nverify and clean data. Raise error if input fails.", "response": "def scrub(data):\n    \"\"\"Verify and clean data. Raise error if input fails.\"\"\"\n    # blanks, Nones, and empty strings can stay as is\n    if not data:\n        return data\n    if isinstance(data, (int, float)):\n        return data\n    if isinstance(data, list):\n        return [scrub(entry) for entry in data]\n    if isinstance(data, dict):\n        return {scrub(key): scrub(value) for key, value in data.items()}\n    try:\n        return json.encoder.encode_basestring(data)[1:-1]\n    except TypeError as exc:\n        raise ValidationError(\"Input '%s' is not a permitted type: %s\" % (data,\n                                                                          exc))\n    except Exception as exc:\n        raise ValidationError(\"Input '%s' not permitted: %s\" % (data, exc))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds a mongodb query that performs text search for strings.", "response": "def build_text_search(strings, name_field='name'):\n    \"\"\"Build mongodb query that performs text search for string(s).\n\n    This is the backend implementation of the front-end search box on a list.\n    It performs text search on a text index and a regex search on a `name`\n    field. The value(s) for this are parsed by `rest.process_params` from the\n    `q` query param.\n\n    :param list strings: strings to search on.\n    :keyword str name: field to search on in addition to search index.\n\n    For example, searching the following collection for 'john':\n\n    #  Name    Description (in text index)\n    -  ------  ---------------------------\n    1  John    Big boss\n    2  Johnny  Boss' son\n    3  Thomas  John's first employee\n    4  Henry   He quit\n\n    Search returns all records except the last one:\n    #1 - match on name\n    #2 - partial match on name\n    #3 - text index match on description\n\n    >>> import pprint\n    >>> pprint.pprint(build_text_search(['john']))\n    {'$or': [{'$text': {'$search': 'john'}},\n             {'name': {'$options': 'i', '$regex': 'john'}}]}\n\n    >>> import pprint\n    >>> pprint.pprint(build_text_search(['john', 'tom'], name_field='objName'))\n    {'$or': [{'$text': {'$search': 'john tom'}},\n             {'$or': [{'objName': {'$options': 'i', '$regex': 'john'}},\n                      {'objName': {'$options': 'i', '$regex': 'tom'}}]}]}\n    \"\"\"\n    assert isinstance(strings, list)\n\n    text_search = {'$text': {'$search': ' '.join(strings)}}\n\n    searches = [{name_field: {'$regex': s, '$options': 'i'}} for s in strings]\n    if len(searches) == 1:\n        name_search = searches[0]\n    else:\n        name_search = {'$or': searches}\n\n    return {'$or': [text_search, name_search]}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef database(connection_string, db_class=SimplDB):\n    if not hasattr(database, \"singletons\"):\n        database.singletons = {}\n    if connection_string not in database.singletons:\n        instance = db_class(connection_string)\n        database.singletons[connection_string] = instance\n    return database.singletons[connection_string]", "response": "Return the same database instance for the same connection_string"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert HTTP query params into mongodb query syntax.", "response": "def params_to_mongo(query_params):\n    \"\"\"Convert HTTP query params to mongodb query syntax.\n\n    Converts the parse query params into a mongodb spec.\n\n    :param dict query_params: return of func:`rest.process_params`\n    \"\"\"\n    if not query_params:\n        return {}\n    for key, value in query_params.items():\n        if isinstance(value, list):\n            query_params[key] = {'$in': value}\n    return query_params"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset client property if not set.", "response": "def _set_client(self):\n        \"\"\"Set client property if not set.\"\"\"\n        if self._client is None:\n            if mongo_proxy:\n                self._client = mongo_proxy.MongoProxy(\n                    pymongo.MongoClient(self.connection_string),\n                    logger=LOG)\n            else:\n                LOG.warning(\"MongoDBProxy not imported. AutoReconnect \"\n                            \"is not enabled.\")\n                self._client = mongo_proxy.MongoProxy(\n                    pymongo.MongoClient(self.connection_string),\n                    logger=LOG)\n            LOG.debug(\"Created new connection to MongoDB: %s\",\n                      self.safe_connection_string)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef client(self):\n        if eventlet:\n            with self.client_lock:\n                self._set_client()\n        else:\n            self._set_client()\n        return self._client", "response": "Return a lazy - instantiated pymongo client."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connection(self):\n        if self._connection is None:\n\n            self._connection = self.client[self.database_name]\n\n            if self.disable_id_injector:\n                incoming = self._connection._Database__incoming_manipulators\n                for manipulator in incoming:\n                    if isinstance(manipulator,\n                                  pymongo.son_manipulator.ObjectIdInjector):\n                        incoming.remove(manipulator)\n                        LOG.debug(\"Disabling %s on mongodb connection to \"\n                                  \"'%s'.\",\n                                  manipulator.__class__.__name__,\n                                  self.database_name)\n                        break\n\n            for manipulator in self.manipulators:\n                self._connection.add_son_manipulator(manipulator)\n            LOG.info(\"Connected to mongodb on %s (database=%s)\",\n                     self.safe_connection_string, self.database_name)\n\n        return self._connection", "response": "Connect to and return mongodb database object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_index(self, collection, index_name, **kwargs):\n        try:\n            self.connection[collection].create_index(index_name, **kwargs)\n        except Exception as exc:\n            LOG.warn(\"Error tuning mongodb database: %s\", exc)", "response": "Safely attempt to create index."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, key, data):\n        if key:\n            spec = {'_id': key}\n\n        write = data.copy()\n\n        response = self._collection.update(\n            spec, {'$set': write}, multi=False, upsert=False, manipulate=True)\n\n        if response.get('ok') != 1:\n            raise SimplMongoError(\"Error updating document '%s': %s\" %\n                                  (spec.get('_id'), response.errmsg))\n        LOG.debug(\"DB UPDATE: %s.%s\", self.collection_name, response)\n        return response.get('n')", "response": "Update the document with _id = key with partial data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list(self, offset=0, limit=0, fields=None, sort=None, **kwargs):\n        try:\n            cursor = self._cursor(offset=offset, limit=limit, fields=fields,\n                                  sort=sort, **kwargs)\n            return list(cursor), cursor.count()\n        except pymongo.errors.OperationFailure as exc:\n            # This is workaround for mongodb v2.4 and 'q' filter params\n            try:\n                kwargs['$or'][0]['$text']['$search']\n            except (KeyError, IndexError):\n                raise exc\n            LOG.warn(\"Falling back to hard-coded mongo v2.4 search behavior\")\n            kwargs = self.search_alternative(limit, **kwargs)\n            LOG.debug(\"Modified kwargs: %s\", kwargs)\n            cursor = self._cursor(offset=offset, limit=limit, fields=fields,\n                                  sort=sort, **kwargs)\n            return list(cursor), cursor.count()", "response": "Return filtered list of documents in a collection."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search_alternative(self, limit, **kwargs):\n        search_term = kwargs['$or'][0]['$text']['$search']\n        response = self._collection.database.command(\n            'text', self._collection.name,\n            search=search_term,\n            project={'_id': 1},\n            limit=limit\n        )\n        id_list = [e['obj']['_id'] for e in response['results']]\n        kwargs['$or'][0] = {'_id': {'$in': id_list}}\n        return kwargs", "response": "Search for alternative entries in the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a cursor on a filtered list of documents in a collection.", "response": "def _cursor(self, offset=0, limit=0, fields=None, sort=None, **kwargs):\n        \"\"\"Return a cursor on a filtered list of documents in a collection.\n\n        :param offset: for pagination, which record to start attribute\n        :param limit: for pagination, how many records to return\n        :param fields: list of field names to return (otherwise returns all)\n        :param sort: list of fields to sort by (prefix with '-' for descending)\n        :param kwargs: key/values to find (only supports equality for now)\n\n        :returns: a tuple of a cursor on documents and the total count\n\n        Note: close the cursor after using it if you don't exhaust it\n        \"\"\"\n        projection = {'_id': False}\n        if fields:\n            projection.update({field: True for field in fields})\n        results = self._collection.find(kwargs, projection)\n        if sort:\n            sort_pairs = sort[:]\n            for index, field in enumerate(sort):\n                if field[0] == \"-\":\n                    sort_pairs[index] = (field[1:], pymongo.DESCENDING)\n                else:\n                    sort_pairs[index] = (field, pymongo.ASCENDING)\n            results.sort(sort_pairs)\n        results.skip(offset or 0).limit(limit or 0)\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete a document by id.", "response": "def delete(self, key):\n        \"\"\"Delete a document by id.\"\"\"\n        assert key, \"A key must be supplied for delete operations\"\n        self._collection.remove(spec_or_id={'_id': key})\n        LOG.debug(\"DB REMOVE: %s.%s\", self.collection_name, key)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a document by id.", "response": "def get(self, key):\n        \"\"\"Get a document by id.\"\"\"\n        doc = self._collection.find_one({'_id': key})\n        if doc:\n            doc.pop('_id')\n            return doc"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _transform_incoming(self, son, collection, skip=0):\n        skip = 0 if skip < 0 else skip\n        if isinstance(son, dict):\n            for (key, value) in son.items():\n                if key.startswith('$'):\n                    if isinstance(value, dict):\n                        skip = 2\n                    else:\n                        pass  # allow mongo to complain\n                if self.replace in key:\n                    k = key if skip else self.transform_key(key)\n                    son[k] = self._transform_incoming(\n                        son.pop(key), collection, skip=skip - 1)\n                elif isinstance(value, dict):  # recurse into sub-docs\n                    son[key] = self._transform_incoming(value, collection,\n                                                        skip=skip - 1)\n                elif isinstance(value, list):\n                    son[key] = [\n                        self._transform_incoming(k, collection, skip=skip - 1)\n                        for k in value\n                    ]\n            return son\n        elif isinstance(son, list):\n            return [self._transform_incoming(item, collection, skip=skip - 1)\n                    for item in son]\n        else:\n            return son", "response": "Recursively replace all keys that need transforming."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef transform_outgoing(self, son, collection):\n        if isinstance(son, dict):\n            for (key, value) in son.items():\n                if self.replacement in key:\n                    k = self.revert_key(key)\n                    son[k] = self.transform_outgoing(son.pop(key), collection)\n                elif isinstance(value, dict):  # recurse into sub-docs\n                    son[key] = self.transform_outgoing(value, collection)\n                elif isinstance(value, list):\n                    son[key] = [self.transform_outgoing(item, collection)\n                                for item in value]\n            return son\n        elif isinstance(son, list):\n            return [self.transform_outgoing(item, collection)\n                    for item in son]\n        else:\n            return son", "response": "Recursively restore all transformed keys."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a setup. py file for the name.", "response": "def parse_application_name(setup_filename):\n        \"\"\"Parse a setup.py file for the name.\n\n        Returns:\n            name, or None\n        \"\"\"\n        with open(setup_filename, 'rt') as setup_file:\n            fst = RedBaron(setup_file.read())\n            for node in fst:\n                if (\n                    node.type == 'atomtrailers' and\n                    str(node.name) == 'setup'\n                ):\n                    for call in node.call:\n                        if str(call.name) == 'name':\n                            value = call.value\n                            if hasattr(value, 'to_python'):\n                                value = value.to_python()\n                            name = str(value)\n                            break\n                    if name:\n                        break\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild the app in the environment.", "response": "def build(self):\n        \"\"\"Builds the app in the app's environment.\n\n        Only builds if the build is out-of-date and is non-empty.\n        Builds in 3 stages: requirements, dev requirements, and app.\n        pip is used to install requirements, and setup.py is used to\n        install the app itself.\n\n        Raises:\n            ValidationError if the app fails to build.\n        \"\"\"\n\n        if self.exists:\n            self._build(\n                'requirements',\n                self.requirements_last_modified,\n                'pip install -U -r %s' % self.requirements_file\n            )\n            try:\n                self._build(\n                    'requirements (dev)',\n                    self.dev_requirements_last_modified,\n                    'pip install -U -r %s' % self.dev_requirements_file\n                )\n            except Exception as e:\n                if 'No such file' not in str(e):\n                    raise e\n                self.stdout.write(\n                    style.yellow('Could not find dev requirements')\n                )\n            try:\n                self._build(\n                    'requirements (local)',\n                    self.local_requirements_last_modified,\n                    'pip install -U -r %s' % self.local_requirements_file\n                )\n            except Exception as e:\n                if 'No such file' not in str(e):\n                    raise e\n                self.stdout.write(\n                    style.yellow('Could not find local requirements')\n                )\n            self._build(\n                'application',\n                self.setup_last_modified,\n                'python %s develop' % self.setup_file\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a blueprint within this application.", "response": "def generate(self, blueprint, context, interactive=True):\n        \"\"\"Generate a blueprint within this application.\"\"\"\n        if not isinstance(blueprint, Blueprint):\n            bp = self.blueprints.get(blueprint)\n            if not bp:\n                raise ValueError('%s is not a valid blueprint' % blueprint)\n            blueprint = bp\n\n        self.stdout.write(\n            style.format_command(\n                'Generating',\n                blueprint.full_name\n            )\n        )\n        generator = Generator(\n            self,\n            blueprint,\n            context,\n            interactive=interactive\n        )\n        result = generator.generate()\n        if blueprint.name == 'init':\n            # try re-setting the name\n            self.refresh()\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a new dependency and install it.", "response": "def add(self, addon, dev=False, interactive=True):\n        \"\"\"Add a new dependency and install it.\"\"\"\n        dependencies = self.get_dependency_manager(dev=dev)\n        other_dependencies = self.get_dependency_manager(dev=not dev)\n        existing = dependencies.get(addon)\n        self.stdout.write(style.format_command('Adding', addon))\n        dependencies.add(addon)\n        try:\n            # try running the build\n            self.build()\n            self.refresh()\n\n            # remove version of this in other requirements file\n            other_dependencies.remove(addon, warn=False)\n\n            # run new addon constructor\n            constructor_name = '%s.init' % Dependency(addon).module_name\n            constructor = self.blueprints.get(constructor_name)\n\n            if constructor:\n                context = constructor.load_context().main(\n                    [], standalone_mode=False\n                )\n                self.generate(constructor, context, interactive=interactive)\n        except Exception as e:\n            # restore original settings\n            self.stdout.write(style.red(str(e)))\n            self.stdout.write(\n                style.yellow('Could not find %s' % addon)\n            )\n            dependencies.remove(addon)\n            if existing:\n                dependencies.add(existing)\n            return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove a dependency and uninstall it.", "response": "def remove(self, addon, dev=False):\n        \"\"\"Remove a dependency and uninstall it.\"\"\"\n        dependencies = self.get_dependency_manager(dev=dev)\n        other_dependencies = self.get_dependency_manager(dev=not dev)\n        self.stdout.write(style.format_command('Removing', addon))\n        removed = dependencies.remove(addon, warn=False)\n        if not removed:\n            removed = other_dependencies.remove(addon, warn=False)\n\n        if removed:\n            self.build()\n        else:\n            exception = '%s is not installed.' % Dependency(addon).to_stdout()\n            self.stdout.write(style.red(exception))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make(target=\"all\", dir=\".\", **kwargs):\n    if not fs.isfile(fs.path(dir, \"Makefile\")):\n        raise NoMakefileError(\"No makefile in '{}'\".format(fs.abspath(dir)))\n\n    fs.cd(dir)\n\n    # Default parameters to system.run()\n    if \"timeout\" not in kwargs: kwargs[\"timeout\"] = 300\n\n    ret, out, err = system.run([\"make\", target], **kwargs)\n    fs.cdpop()\n\n    if ret > 0:\n        if re.search(_BAD_TARGET_RE, err):\n            raise NoTargetError(\"No rule for target '{}'\"\n                                .format(target))\n        else:\n            raise MakeError(\"Target '{}' failed\".format(target))\n\n        raise MakeError(\"Failed\")\n\n    return ret, out, err", "response": "Run the Makefile and return the output of the system. run."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_msg(self, address, args=[]):\n        if not address.startswith('/'):\n            address = '/{}'.format(address)\n    \n        msg = osc_message_builder.OscMessageBuilder(address=address)\n    \n        for arg in args:\n            msg.add_arg(arg)\n        self.conn.send(msg.build())\n        return", "response": "Send multiple args into a single message to a given address."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun lint checks using flake8.", "response": "def lint(args):\n    \"\"\"Run lint checks using flake8.\"\"\"\n    application = get_current_application()\n    if not args:\n        args = [application.name, 'tests']\n    args = ['flake8'] + list(args)\n    run.main(args, standalone_mode=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads a module from anywhere in the system.", "response": "def load_module(filename):\n    \"\"\"Loads a module from anywhere in the system.\n\n    Does not depend on or modify sys.path.\n    \"\"\"\n    path, name = os.path.split(filename)\n    name, ext = os.path.splitext(name)\n    (file, filename, desc) = imp.find_module(name, [path])\n\n    try:\n        return imp.load_module(name, file, filename, desc)\n    finally:\n        if file:\n            file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _start_new_worker_process(self, server_socket):\n        from multiprocessing import Process\n        p = Process(target=forked_child, args=self._get_child_args(server_socket))\n        p.start()\n        return p", "response": "Start a new child worker process which will listen on the given\n        socket and return a reference to the new process."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads and returns a template for the given name.", "response": "def get_template(template_name, using=None):\n    \"\"\"\n    Loads and returns a template for the given name.\n    Raises TemplateDoesNotExist if no such template exists.\n    \"\"\"\n    engines = _engine_list(using)\n    for engine in engines:\n        try:\n            return engine.get_template(template_name)\n        except TemplateDoesNotExist as e:\n            pass\n\n    raise TemplateDoesNotExist(template_name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef select_template(template_name_list, using=None):\n    if isinstance(template_name_list, six.string_types):\n        raise TypeError(\n            'select_template() takes an iterable of template names but got a '\n            'string: %r. Use get_template() if you want to load a single '\n            'template by name.' % template_name_list\n        )\n\n    engines = _engine_list(using)\n    for template_name in template_name_list:\n        for engine in engines:\n            try:\n                return engine.get_template(template_name)\n            except TemplateDoesNotExist as e:\n                pass\n\n    if template_name_list:\n        raise TemplateDoesNotExist(', '.join(template_name_list))\n    else:\n        raise TemplateDoesNotExist(\"No template names provided\")", "response": "Loads and returns a template for one of the given names."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_to_string(template_name, context=None, request=None, using=None):\n    if isinstance(template_name, (list, tuple)):\n        template = select_template(template_name, using=using)\n    else:\n        template = get_template(template_name, using=using)\n    return template.render(context, request)", "response": "Loads a template and renders it with a context. Returns a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef spectral_registration(data, target, initial_guess=(0.0, 0.0), frequency_range=None):\n\n    # make sure that there are no extra dimensions in the data\n    data = data.squeeze()\n    target = target.squeeze()\n\n    # the supplied frequency range can be none, in which case we use the whole\n    # spectrum, or it can be a tuple defining two frequencies in Hz, in which\n    # case we use the spectral points between those two frequencies, or it can\n    # be a numpy.array of the same size as the data in which case we simply use\n    # that array as the weightings for the comparison\n    if type(frequency_range) is tuple:\n        spectral_weights = frequency_range[0] < data.frequency_axis() & data.frequency_axis() < frequency_range[1]\n    else:\n        spectral_weights = frequency_range\n\n    # define a residual function for the optimizer to use\n    def residual(input_vector):\n        transformed_data = transform_fid(data, input_vector[0], input_vector[1])\n        residual_data = transformed_data - target\n        if frequency_range is not None:\n            spectrum = residual_data.spectrum()\n            weighted_spectrum = residual_data * spectral_weights\n            # remove zero-elements\n            weighted_spectrum = weighted_spectrum[weighted_spectrum != 0]\n            residual_data = numpy.fft.ifft(numpy.fft.ifftshift(weighted_spectrum))\n        return_vector = numpy.zeros(len(residual_data) * 2)\n        return_vector[:len(residual_data)] = residual_data.real\n        return_vector[len(residual_data):] = residual_data.imag\n        return return_vector\n\n    out = scipy.optimize.leastsq(residual, initial_guess)\n    return -out[0][0], -out[0][1]", "response": "This method is used to calculate the frequency and phase shifts between the input data and the reference spectrum target."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the adapter path that would be used to adapt obj to to_cls.", "response": "def get_adapter_path(obj, to_cls):\n    \"\"\"\n    Returns the adapter path that would be used to adapt `obj` to `to_cls`.\n    \"\"\"\n    from_cls = type(obj)\n    key = (from_cls, to_cls)\n    if key not in __mro__:\n        __mro__[key] = list(itertools.product(inspect.getmro(from_cls), inspect.getmro(to_cls)))\n\n    return __mro__[key]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef adapt(obj, to_cls):\n    if obj is None:\n        return obj\n    elif isinstance(obj, to_cls):\n        return obj\n\n    errors = []\n\n    if hasattr(obj, '__adapt__') and obj.__adapt__:\n        try:\n            return obj.__adapt__(to_cls)\n        except (AdaptError, TypeError) as e:\n            ex_type, ex, tb = sys.exc_info()\n            errors.append((obj.__adapt__, ex_type, ex, tb))\n\n    if hasattr(to_cls, '__adapt__') and to_cls.__adapt__:\n        try:\n            return to_cls.__adapt__(obj)\n        except (AdaptError, TypeError) as e:\n            ex_type, ex, tb = sys.exc_info()\n            errors.append((to_cls.__adapt__, ex_type, ex, tb))\n\n    for k in get_adapter_path(obj, to_cls):\n        if k in __adapters__:\n            try:\n                return __adapters__[k](obj, to_cls)\n            except (AdaptError, TypeError) as e:\n                ex_type, ex, tb = sys.exc_info()\n                errors.append((__adapters__[k], ex_type, ex, tb))\n                break\n\n    raise AdaptErrors('Could not adapt %r to %r' % (obj, to_cls), errors=errors)", "response": "Adapt obj to an instance of to_cls."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nregister a function that can handle adapting from from_classes to to_classes.", "response": "def register_adapter(from_classes, to_classes, func):\n    \"\"\"\n    Register a function that can handle adapting from `from_classes` to `to_classes`.\n    \"\"\"\n    assert from_classes, 'Must supply classes to adapt from'\n    assert to_classes, 'Must supply classes to adapt to'\n    assert func, 'Must supply adapter function'\n\n    if not isinstance(from_classes, (tuple, list)):\n        from_classes = [from_classes]\n    if not isinstance(to_classes, (tuple, list)):\n        to_classes = [to_classes]\n\n    for key in itertools.product(from_classes, to_classes):\n        if key in __adapters__:\n            raise AdapterExists('%r to %r already exists.' % key)\n        __adapters__[key] = func"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef errors_string(self):\n        output = []\n        for e in self.errors:\n            output.append('%s: %s in %s:' % (e[1], e[2], e[0]))\n            output.append(''.join(traceback.format_tb(e[3])))\n        return '\\n'.join(output)", "response": "Returns all errors as a string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef activate(self, engine):\n\n        LOGGER.debug(\"> Activating '{0}' Component.\".format(self.__class__.__name__))\n\n        self.__engine = engine\n        self.__settings = self.__engine.settings\n        self.__settings_section = self.name\n\n        self.__default_script_editor_directory = os.path.join(self.__engine.user_application_data_directory,\n                                                              Constants.io_directory,\n                                                              self.__default_script_editor_directory)\n        not foundations.common.path_exists(self.__default_script_editor_directory) and \\\n        os.makedirs(self.__default_script_editor_directory)\n        self.__default_session_directory = os.path.join(\n            self.__default_script_editor_directory, self.__default_session_directory)\n        not foundations.common.path_exists(self.__default_session_directory) and os.makedirs(\n            self.__default_session_directory)\n        self.__default_script_editor_file = os.path.join(self.__default_script_editor_directory,\n                                                         self.__default_script_editor_file)\n\n        self.__console = code.InteractiveConsole(self.__engine.locals)\n\n        self.activated = True\n        return True", "response": "Activates the Component.\n\n        :param engine: Container to attach the Component to.\n        :type engine: QObject\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the Component ui.", "response": "def initialize_ui(self):\n        \"\"\"\n        Initializes the Component ui.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        LOGGER.debug(\"> Initializing '{0}' Component ui.\".format(self.__class__.__name__))\n\n        self.__model = ProjectsModel(self, default_project=self.__default_project)\n\n        self.Script_Editor_tabWidget = ScriptEditor_QTabWidget(self.__engine)\n        self.Script_Editor_tabWidget_frame_gridLayout.addWidget(self.Script_Editor_tabWidget, 0, 0)\n        self.__Script_Editor_tabWidget_set_ui()\n\n        self.__recent_files_actions = []\n        for i in range(self.__maximum_recent_files):\n            self.__recent_files_actions.append(QAction(self.__menu_bar,\n                                                       visible=False,\n                                                       triggered=self.__load_recent_file__triggered))\n\n        self.__menu_bar = QMenuBar()\n        self.__menu_bar.setNativeMenuBar(False)\n        self.Menu_Bar_frame_gridLayout.addWidget(self.__menu_bar)\n        # Qt 4.8.4: Needs to show the menu_bar, otherwise it doesn't appear.\n        self.__menu_bar.show()\n        self.__initialize_menu_bar()\n\n        self.Script_Editor_Output_plainTextEdit.setParent(None)\n        self.Script_Editor_Output_plainTextEdit = Basic_QPlainTextEdit(self)\n        self.Script_Editor_Output_plainTextEdit_frame_gridLayout.addWidget(\n            self.Script_Editor_Output_plainTextEdit, 0, 0)\n        self.Script_Editor_Output_plainTextEdit.setObjectName(\"Script_Editor_Output_plainTextEdit\")\n        self.__Script_Editor_Output_plainTextEdit_set_ui()\n\n        self.__search_and_replace = SearchAndReplace(self, Qt.Window)\n        self.__search_in_files = SearchInFiles(self, Qt.Window)\n\n        self.__initialize_languages_model()\n\n        self.Editor_Status_editorStatus = EditorStatus(self)\n        self.__engine.statusBar.insertPermanentWidget(0, self.Editor_Status_editorStatus)\n\n        Editor.get_untitled_file_name = self.__get_untitled_file_name\n\n        # Signals / Slots.\n        self.__engine.timer.timeout.connect(self.__Script_Editor_Output_plainTextEdit_refresh_ui)\n        self.__engine.content_dropped.connect(self.__engine__content_dropped)\n        self.__engine.layouts_manager.layout_restored.connect(self.__engine_layouts_manager__layout_restored)\n        self.__engine.file_system_events_manager.file_changed.connect(\n            self.__engine_file_system_events_manager__file_changed)\n        self.__engine.file_system_events_manager.file_invalidated.connect(\n            self.__engine_file_system_events_manager__file_invalidated)\n        self.__engine.file_system_events_manager.directory_changed.connect(\n            self.__engine_file_system_events_manager__directory_changed)\n        self.__engine.file_system_events_manager.directory_invalidated.connect(\n            self.__engine_file_system_events_manager__directory_invalidated)\n        self.Script_Editor_tabWidget.tabCloseRequested.connect(self.__Script_Editor_tabWidget__tabCloseRequested)\n        self.Script_Editor_tabWidget.currentChanged.connect(self.__Script_Editor_tabWidget__currentChanged)\n        self.Script_Editor_tabWidget.content_dropped.connect(self.__Script_Editor_tabWidget__content_dropped)\n        self.Script_Editor_tabWidget.tabBar().tabMoved.connect(self.__Script_Editor_tabWidget_tabBar__tabMoved)\n        self.visibilityChanged.connect(self.__script_editor__visibilityChanged)\n        self.ui_refresh.connect(self.__Script_Editor_Output_plainTextEdit_refresh_ui)\n        self.recent_files_changed.connect(self.__set_recent_files_actions)\n        self.__model.file_registered.connect(self.__model__file_registered)\n        self.__model.file_unregistered.connect(self.__model__file_unregistered)\n        self.__model.directory_registered.connect(self.__model__directory_registered)\n        self.__model.directory_unregistered.connect(self.__model__directory_unregistered)\n        self.__model.project_registered.connect(self.__model__project_registered)\n        self.__model.project_unregistered.connect(self.__model__project_unregistered)\n        self.__model.editor_registered.connect(self.__model__editor_registered)\n        self.__model.editor_unregistered.connect(self.__model__editor_unregistered)\n\n        self.initialized_ui = True\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_widget(self):\n\n        LOGGER.debug(\"> Removing '{0}' Component Widget.\".format(self.__class__.__name__))\n\n        self.__engine.removeDockWidget(self)\n        self.setParent(None)\n\n        return True", "response": "Removes the Component Widget from the engine."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_startup(self):\n\n        LOGGER.debug(\"> Calling '{0}' Component Framework 'on_startup' method.\".format(self.__class__.__name__))\n\n        factory_default_script_editor_file = umbra.ui.common.get_resource_path(\n            self.__factory_default_script_editor_file)\n        if foundations.common.path_exists(factory_default_script_editor_file) and \\\n                not foundations.common.path_exists(self.__default_script_editor_file):\n            shutil.copyfile(factory_default_script_editor_file, self.__default_script_editor_file)\n\n        if foundations.common.path_exists(self.__default_script_editor_file):\n            self.load_file(self.__default_script_editor_file)\n        else:\n            self.new_file()\n\n        startup_script = self.__engine.parameters.startup_script\n        if foundations.common.path_exists(startup_script):\n            self.load_file(startup_script) and self.evaluate_script()\n\n        self.restore_session()\n\n        for argument in self.__engine.arguments[1:]:\n            file = os.path.abspath(argument)\n            if foundations.common.path_exists(file):\n                os.path.isfile(file) and self.load_file(file)\n\n        return True", "response": "Determines if this Component is starting up."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls by the framework when the application closes the session.", "response": "def on_close(self):\n        \"\"\"\n        Defines the slot triggered on Framework close.\n        \"\"\"\n\n        LOGGER.debug(\"> Calling '{0}' Component Framework 'on_close' method.\".format(self.__class__.__name__))\n\n        map(self.unregister_file, self.list_files())\n\n        if self.store_session() and self.close_all_files(leave_first_editor=False):\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __initialize_menu_bar(self):\n\n        self.__file_menu = QMenu(\"&File\", parent=self.__menu_bar)\n        self.__file_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&File|&New\",\n            shortcut=QKeySequence.New,\n            slot=self.__new_file_action__triggered))\n        self.__file_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&File|&Load ...\",\n            shortcut=QKeySequence.Open,\n            slot=self.__load_file_action__triggered))\n        self.__file_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&File|Source ...\",\n            slot=self.__source_file_action__triggered))\n        self.__file_menu.addSeparator()\n        self.__file_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&File|Add Project ...\",\n            slot=self.__add_project_action__triggered))\n        self.__file_menu.addSeparator()\n        self.__file_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&File|&Save\",\n            shortcut=QKeySequence.Save,\n            slot=self.__save_file_action__triggered))\n        self.__file_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&File|Save As ...\",\n            shortcut=QKeySequence.SaveAs,\n            slot=self.__save_file_as_action__triggered))\n        self.__file_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&File|Save All\",\n            slot=self.__save_all_files_action__triggered))\n        self.__file_menu.addSeparator()\n        self.__file_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&File|Revert\",\n            slot=self.__revert_file_action__triggered))\n        self.__file_menu.addSeparator()\n        self.__file_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&File|Close ...\",\n            shortcut=QKeySequence.Close,\n            slot=self.__close_file_action__triggered))\n        self.__file_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&File|Close All ...\",\n            shortcut=Qt.SHIFT + Qt.ControlModifier + Qt.Key_W,\n            slot=self.__close_all_files_action__triggered))\n        self.__file_menu.addSeparator()\n        for action in self.__recent_files_actions:\n            self.__file_menu.addAction(action)\n        self.__set_recent_files_actions()\n        self.__menu_bar.addMenu(self.__file_menu)\n\n        self.__edit_menu = QMenu(\"&Edit\", parent=self.__menu_bar)\n        self.__edit_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Edit|&Undo\",\n            shortcut=QKeySequence.Undo,\n            slot=self.__undo_action__triggered))\n        self.__edit_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Edit|&Redo\",\n            shortcut=QKeySequence.Redo,\n            slot=self.__redo_action__triggered))\n        self.__edit_menu.addSeparator()\n        self.__edit_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Edit|Cu&t\",\n            shortcut=QKeySequence.Cut,\n            slot=self.__cut_action__triggered))\n        self.__edit_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Edit|&Copy\",\n            shortcut=QKeySequence.Copy,\n            slot=self.__copy_action__triggered))\n        self.__edit_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Edit|&Paste\",\n            shortcut=QKeySequence.Paste,\n            slot=self.__paste_action__triggered))\n        self.__edit_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Edit|Delete\",\n            slot=self.__delete_action__triggered))\n        self.__edit_menu.addSeparator()\n        self.__edit_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Edit|Select All\",\n            shortcut=QKeySequence.SelectAll,\n            slot=self.__select_all_action__triggered))\n        self.__menu_bar.addMenu(self.__edit_menu)\n\n        self.__source_menu = QMenu(\"&Source\", parent=self.__menu_bar)\n        self.__source_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Source|Delete Line(s)\",\n            shortcut=Qt.ControlModifier + Qt.Key_D,\n            slot=self.__delete_lines_action__triggered))\n        self.__source_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Source|Duplicate Line(s)\",\n            shortcut=Qt.SHIFT + Qt.ControlModifier + Qt.Key_D,\n            slot=self.__duplicate_lines_action__triggered))\n        self.__source_menu.addSeparator()\n        self.__source_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Source|Move Up\",\n            shortcut=Qt.SHIFT + Qt.ControlModifier + Qt.ALT + Qt.Key_Up,\n            slot=self.__move_up_action__triggered))\n        self.__source_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Source|Move Down\",\n            shortcut=Qt.SHIFT + Qt.ControlModifier + Qt.ALT + Qt.Key_Down,\n            slot=self.__move_down_action__triggered))\n        self.__source_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Source|Indent Selection\",\n            shortcut=Qt.Key_Tab,\n            slot=self.__indent_selection_action__triggered))\n        self.__source_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Source|Unindent Selection\",\n            shortcut=Qt.Key_Backtab,\n            slot=self.__unindent_selection_action__triggered))\n        self.__source_menu.addSeparator()\n        self.__source_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Source|Convert Indentation To Tabs\",\n            slot=self.__convert_indentation_to_tabs_action__triggered))\n        self.__source_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Source|Convert Indentation To Spaces\",\n            slot=self.__convert_indentation_to_spaces_action__triggered))\n        self.__source_menu.addSeparator()\n        self.__source_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Source|Remove Trailing WhiteSpaces\",\n            slot=self.__remove_trailing_white_spaces_action__triggered))\n        self.__source_menu.addSeparator()\n        self.__source_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Source|Toggle Comments\",\n            shortcut=Qt.ControlModifier + Qt.Key_Slash,\n            slot=self.__toggle_comments_action__triggered))\n        self.__menu_bar.addMenu(self.__source_menu)\n\n        self.__navigate_menu = QMenu(\"&Navigate\", parent=self.__menu_bar)\n        self.__navigate_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Navigate|Goto Line ...\",\n            shortcut=Qt.ControlModifier + Qt.Key_L,\n            slot=self.__go_to_line_action__triggered))\n        self.__navigate_menu.addSeparator()\n        self.__menu_bar.addMenu(self.__navigate_menu)\n\n        self.__search_menu = QMenu(\"&Search\", parent=self.__menu_bar)\n        self.__search_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Search|Search And Replace ...\",\n            shortcut=Qt.ControlModifier + Qt.Key_F,\n            slot=self.__search_and_replace_action__triggered))\n        self.__search_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Search|Search In Files ...\",\n            shortcut=Qt.ALT + Qt.ControlModifier + Qt.Key_F,\n            slot=self.__search_in_files_action__triggered))\n        self.__search_menu.addSeparator()\n        self.__search_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Search|Search Next\",\n            shortcut=Qt.ControlModifier + Qt.Key_K,\n            slot=self.__search_next_action__triggered))\n        self.__search_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Search|Search Previous\",\n            shortcut=Qt.SHIFT + Qt.ControlModifier + Qt.Key_K,\n            slot=self.__search_previous_action__triggered))\n        self.__menu_bar.addMenu(self.__search_menu)\n\n        self.__command_menu = QMenu(\"&Command\", parent=self.__menu_bar)\n        self.__command_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Command|&Evaluate Selection\",\n            shortcut=Qt.ControlModifier + Qt.Key_Return,\n            slot=self.__evaluate_selection_action__triggered))\n        self.__command_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&Command|Evaluate &Script\",\n            shortcut=Qt.SHIFT + Qt.CTRL + Qt.Key_Return,\n            slot=self.__evaluate_script_action__triggered))\n        self.__menu_bar.addMenu(self.__command_menu)\n\n        self.__view_menu = QMenu(\"&View\", parent=self.__menu_bar)\n        self.__view_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&View|Increase Font Size\",\n            shortcut=Qt.ControlModifier + Qt.Key_Plus,\n            slot=self.__increase_font_size_action__triggered))\n        self.__view_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&View|Decrease Font Size\",\n            shortcut=Qt.ControlModifier + Qt.Key_Minus,\n            slot=self.__decrease_font_size_action__triggered))\n        self.__view_menu.addSeparator()\n        self.__view_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&View|Toggle Word Wrap\",\n            slot=self.__toggle_word_wrap_action__triggered))\n        self.__view_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&View|Toggle White Spaces\",\n            slot=self.__toggle_white_spaces_action__triggered))\n        self.__view_menu.addSeparator()\n        self.__view_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&View|Loop Through Editors\",\n            shortcut=Qt.AltModifier + Qt.SHIFT + Qt.Key_Tab,\n            slot=self.__loop_through_editors_action__triggered))\n        self.__menu_bar.addMenu(self.__view_menu)", "response": "Initializes the Component menu_bar."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __Script_Editor_Output_plainTextEdit_set_ui(self):\n\n        self.Script_Editor_Output_plainTextEdit.setReadOnly(True)\n        self.Script_Editor_Output_plainTextEdit.highlighter = umbra.ui.highlighters.DefaultHighlighter(\n            self.Script_Editor_Output_plainTextEdit.document(),\n            LOGGING_LANGUAGE.rules,\n            LOGGING_LANGUAGE.theme)\n\n        self.Script_Editor_Output_plainTextEdit.setTabStopWidth(self.__indent_width)\n        self.Script_Editor_Output_plainTextEdit.setWordWrapMode(QTextOption.NoWrap)\n        if platform.system() == \"Windows\" or platform.system() == \"Microsoft\":\n            fontFamily, fontSize = self.__default_fonts_settings[\"Windows\"]\n        elif platform.system() == \"Darwin\":\n            fontFamily, fontSize = self.__default_fonts_settings[\"Darwin\"]\n        elif platform.system() == \"Linux\":\n            fontFamily, fontSize = self.__default_fonts_settings[\"Linux\"]\n        font = QFont(fontFamily)\n        font.setPointSize(fontSize)\n        self.Script_Editor_Output_plainTextEdit.setFont(font)\n        self.Script_Editor_Output_plainTextEdit.contextMenuEvent = \\\n            self.__Script_Editor_Output_plainTextEdit_contextMenuEvent\n        self.__Script_Editor_Output_plainTextEdit_set_default_view_state()", "response": "Sets the **Script_Editor_Output_plainTextEdit** Widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __Script_Editor_Output_plainTextEdit_set_default_view_state(self):\n\n        self.Script_Editor_Output_plainTextEdit.moveCursor(QTextCursor.End)\n        self.Script_Editor_Output_plainTextEdit.ensureCursorVisible()", "response": "Sets the **Script_Editor_Output_plainTextEdit** Widget default View state."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the **Script_Editor_Output_plainTextEdit** Widget.", "response": "def __Script_Editor_Output_plainTextEdit_refresh_ui(self):\n        \"\"\"\n        Updates the **Script_Editor_Output_plainTextEdit** Widget.\n        \"\"\"\n\n        memory_handler_stack_depth = len(self.__engine.logging_session_handler_stream.stream)\n        if memory_handler_stack_depth != self.__memory_handler_stack_depth:\n            for line in self.__engine.logging_session_handler_stream.stream[\n                        self.__memory_handler_stack_depth:memory_handler_stack_depth]:\n                self.Script_Editor_Output_plainTextEdit.moveCursor(QTextCursor.End)\n                self.Script_Editor_Output_plainTextEdit.insertPlainText(line)\n            self.__Script_Editor_Output_plainTextEdit_set_default_view_state()\n            self.__memory_handler_stack_depth = memory_handler_stack_depth"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __Script_Editor_Output_plainTextEdit_contextMenuEvent(self, event):\n\n        menu = self.Script_Editor_Output_plainTextEdit.createStandardContextMenu()\n        menu.addSeparator()\n        menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|Edit Selected Path\",\n            slot=self.__edit_selected_path_action__triggered))\n        menu.exec_(event.globalPos())", "response": "Reimplementes the QPlainTextEdit. contextMenuEvent method."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the **Script_Editor_tabWidget** Widget.", "response": "def __Script_Editor_tabWidget_set_ui(self):\n        \"\"\"\n        Sets the **Script_Editor_tabWidget** Widget.\n        \"\"\"\n\n        self.Script_Editor_tabWidget.setTabsClosable(True)\n        self.Script_Editor_tabWidget.setMovable(True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __initialize_languages_model(self):\n\n        languages = [PYTHON_LANGUAGE, LOGGING_LANGUAGE, TEXT_LANGUAGE]\n        existingGrammarFiles = [os.path.normpath(language.file) for language in languages]\n\n        for directory in RuntimeGlobals.resources_directories:\n            for file in foundations.walkers.files_walker(directory, (\"\\.{0}$\".format(self.__extension),), (\"\\._\",)):\n                if os.path.normpath(file) in existingGrammarFiles:\n                    continue\n\n                languageDescription = get_language_description(file)\n                if not languageDescription:\n                    continue\n\n                LOGGER.debug(\"> Adding '{0}' language to model.\".format(languageDescription))\n                languages.append(languageDescription)\n\n        self.__languages_model = LanguagesModel(self, sorted(languages, key=lambda x: (x.name)))\n        self.__get_supported_file_types_string()", "response": "Initializes the languages Model."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __handle_dropped_content(self, event):\n\n        if not event.mimeData().hasUrls():\n            return\n\n        urls = event.mimeData().urls()\n\n        self.__engine.start_processing(\"Loading Files ...\", len(urls))\n        for url in event.mimeData().urls():\n            path = foundations.strings.to_string(url.path())\n            LOGGER.debug(\"> Handling dropped '{0}' file.\".format(path))\n            path = (platform.system() == \"Windows\" or platform.system() == \"Microsoft\") and \\\n                   re.search(r\"^\\/[A-Z]:\", path) and path[1:] or path\n            self.load_path(path) and self.restore_development_layout()\n            self.__engine.step_processing()\n        self.__engine.stop_processing()", "response": "Handles the dropped content event."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __get_supported_file_types_string(self):\n\n        languages = [\"All Files (*)\"]\n        for language in self.__languages_model.languages:\n            languages.append(\"{0} Files ({1})\".format(language.name,\n                                                      \" \".join(language.extensions.split(\"|\")).replace(\"\\\\\", \"*\")))\n        return \";;\".join(languages)", "response": "Returns the string that contains the supported file types dialog string."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the recent files actions.", "response": "def __set_recent_files_actions(self):\n        \"\"\"\n        Sets the recent files actions.\n        \"\"\"\n\n        recentFiles = [foundations.strings.to_string(file)\n                       for file in self.__settings.get_key(self.__settings_section, \"recentFiles\").toStringList()\n                       if foundations.common.path_exists(file)]\n        if not recentFiles:\n            return\n\n        numberRecentFiles = min(len(recentFiles), self.__maximum_recent_files)\n\n        for i in range(self.__maximum_recent_files):\n            if i >= numberRecentFiles:\n                self.__recent_files_actions[i].setVisible(False)\n                continue\n\n            LOGGER.debug(\"> Adding '{0}' file to recent files actions.\".format(recentFiles[i]))\n\n            self.__recent_files_actions[i].setText(\"{0} {1}\".format(i + 1, os.path.basename(\n                foundations.strings.to_string(recentFiles[i]))))\n            self.__recent_files_actions[i].data = foundations.strings.to_string(recentFiles[i])\n            self.__recent_files_actions[i].setVisible(True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstores given recent file into the settings.", "response": "def __store_recent_file(self, file):\n        \"\"\"\n        Stores given recent file into the settings.\n\n        :param file: File to store.\n        :type file: unicode\n        \"\"\"\n\n        LOGGER.debug(\"> Storing '{0}' file in recent files.\".format(file))\n\n        recentFiles = [foundations.strings.to_string(recentFile)\n                       for recentFile in self.__settings.get_key(self.__settings_section, \"recentFiles\").toStringList()\n                       if foundations.common.path_exists(recentFile)]\n        if not recentFiles:\n            recentFiles = []\n\n        if file in recentFiles:\n            recentFiles.pop(recentFiles.index(file))\n        recentFiles.insert(0, file)\n        del recentFiles[self.__maximum_recent_files:]\n        recentFiles = self.__settings.set_key(self.__settings_section, \"recentFiles\", recentFiles)\n        self.recent_files_changed.emit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the Component window title.", "response": "def __set_window_title(self):\n        \"\"\"\n        Sets the Component window title.\n        \"\"\"\n\n        if self.has_editor_tab():\n            windowTitle = \"{0} - {1}\".format(self.__default_window_title, self.get_current_editor().file)\n        else:\n            windowTitle = \"{0}\".format(self.__default_window_title)\n\n        LOGGER.debug(\"> Setting 'Script Editor' window title to '{0}'.\".format(windowTitle))\n        self.setWindowTitle(windowTitle)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __set_tab_title(self, index):\n\n        editor = self.get_widget(index)\n        if not editor:\n            return\n\n        title, tool_tip = foundations.strings.to_string(editor.title), foundations.strings.to_string(editor.file)\n        LOGGER.debug(\n            \"> Setting '{0}' window title and '{1}' toolTip to tab with '{2}' index.\".format(title, tool_tip, index))\n        # TODO: https://bugreports.qt-project.org/browse/QTBUG-27084\n        color = QColor(224, 224, 224) if editor.is_modified() else QColor(160, 160, 160)\n        self.Script_Editor_tabWidget.tabBar().setTabTextColor(index, color)\n        tabText = self.Script_Editor_tabWidget.tabText(index)\n        tabText != title and self.Script_Editor_tabWidget.setTabText(index, title)\n        self.Script_Editor_tabWidget.setTabToolTip(index, tool_tip)", "response": "Sets the name and toolTip of the Script_Editor_tabWidget Widget tab with given index."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an untitled file name.", "response": "def __get_untitled_file_name(self):\n        \"\"\"\n        Returns an untitled file name.\n\n        :return: Untitled file name.\n        :rtype: unicode\n        \"\"\"\n\n        untitledNameId = Editor._Editor__untitled_name_id\n        for file in self.list_files():\n            if not os.path.dirname(file) == self.__default_session_directory:\n                continue\n\n            search = re.search(r\"\\d+\", os.path.basename(file))\n            if not search:\n                continue\n\n            untitledNameId = max(int(search.group(0)), untitledNameId) + 1\n\n        name = \"{0} {1}.{2}\".format(self.__default_file_name, untitledNameId, self.__default_file_extension)\n        Editor._Editor__untitled_name_id += 1\n        LOGGER.debug(\"> Next untitled file name: '{0}'.\".format(name))\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering given file in the file_system_events_manager.", "response": "def register_file(self, file):\n        \"\"\"\n        Registers given file in the **file_system_events_manager**.\n\n        :param file: File.\n        :type file: unicode\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        not self.__engine.file_system_events_manager.is_path_registered(file) and \\\n        self.__engine.file_system_events_manager.register_path(file)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register_node_path(self, node):\n\n        path = node.file if hasattr(node, \"file\") else node.path\n        path = foundations.strings.to_string(path)\n        if not foundations.common.path_exists(path):\n            return False\n\n        return self.register_file(path)", "response": "Registers given Node path in the file system events manager."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_file_ui(self):\n\n        editor = self.get_current_editor()\n        file = editor and editor.file or None\n\n        browsedPath = os.path.dirname(file) if foundations.common.path_exists(\n            file) else RuntimeGlobals.last_browsed_path\n        files = umbra.ui.common.store_last_browsed_path(QFileDialog.getOpenFileNames(self,\n                                                                                     \"Load File(s):\",\n                                                                                     browsedPath,\n                                                                                     self.__get_supported_file_types_string()))\n        if not files:\n            return False\n\n        success = True\n        for file in files:\n            success *= self.load_file(file)\n        return success", "response": "Loads user chosen file into Script_Editor_tabWidget Widget Model editor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding user chosen project to the editor tab Model.", "response": "def add_project_ui(self):\n        \"\"\"\n        Adds user chosen project **Script_Editor_tabWidget** Widget tab Model.\n\n        :return: Method success.\n        :rtype: bool\n\n        :note: May require user interaction.\n        \"\"\"\n\n        directory = umbra.ui.common.store_last_browsed_path(QFileDialog.getExistingDirectory(self,\n                                                                                             \"Add Project:\",\n                                                                                             RuntimeGlobals.last_browsed_path))\n        if not directory:\n            return False\n\n        return self.add_project(directory)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_focus_widget(self):\n\n        current_widget = QApplication.focusWidget()\n        if current_widget is None:\n            return False\n\n        if current_widget.objectName() == \"Script_Editor_Output_plainTextEdit\" or \\\n                isinstance(current_widget, Editor):\n            return current_widget", "response": "Returns the Widget with focus."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_editorTab(self, editor):\n\n        for i in range(self.Script_Editor_tabWidget.count()):\n            if not self.get_widget(i) == editor:\n                continue\n\n            LOGGER.debug(\"> Editor '{0}': Tab index '{1}'.\".format(editor, i))\n            return i", "response": "Returns the **Script_Editor_tabWidget** Widget tab associated with the given editor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_editor_tab(self, editor):\n\n        index = self.Script_Editor_tabWidget.addTab(editor, editor.get_file_short_name())\n        LOGGER.debug(\"> Assigning '{0}' editor to '{1}' tab index.\".format(editor, index))\n        self.Script_Editor_tabWidget.setCurrentIndex(index)\n        self.__set_tab_title(index)\n\n        # Signals / Slots.\n        editor.patterns_replaced.connect(self.__editor__patterns_replaced)\n        editor.title_changed.connect(self.__editor__title_changed)\n        editor.file_loaded.connect(self.__editor__file_loaded)\n        editor.file_saved.connect(self.__editor__file_saved)\n        editor.language_changed.connect(self.__editor__language_changed)\n        editor.modification_changed.connect(self.__editor__modification_changed)\n        editor.cursorPositionChanged.connect(\n            self.Editor_Status_editorStatus._EditorStatus__editor__cursorPositionChanged)\n        return index", "response": "Adds a new tab to the Script_Editor_tabWidget and sets the given editor as child widget."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_editor_tab(self, editor):\n\n        LOGGER.debug(\"> Removing tab with Editor '{0}'.\".format(editor))\n        self.Script_Editor_tabWidget.removeTab(self.get_editorTab(editor))\n        return True", "response": "Removes the **Script_Editor_tabWidget** Widget tab with given editor."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_editor_tab(self, file):\n\n        for i in range(self.Script_Editor_tabWidget.count()):\n            if not self.get_widget(i).file == file:\n                continue\n\n            LOGGER.debug(\"> File '{0}': Tab index '{1}'.\".format(file, i))\n            return i", "response": "Finds the Editor_Editor_tabWidget associated to the given file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_current_editor(self, file):\n\n        index = self.find_editor_tab(file)\n        if index is not None:\n            self.Script_Editor_tabWidget.setCurrentIndex(index)\n            return True", "response": "Focus the **Script_Editor_tabWidget** Widget tab Model editor with given file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_path(self, path):\n\n        if not foundations.common.path_exists(path):\n            return False\n\n        if os.path.isfile(path):\n            if path in self.list_files():\n                self.set_current_editor(path)\n            else:\n                self.load_file(path)\n        else:\n            if not path in self.list_projects():\n                self.add_project(path)\n        return True", "response": "Loads given path.\n\n        :param path: Path to load.\n        :type path: unicode\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload given document into a new Script_Editor_tabWidget editor.", "response": "def load_document(self, document, file):\n        \"\"\"\n        Loads given document into a new **Script_Editor_tabWidget** Widget tab Model editor.\n\n        :param document: Document to load.\n        :type document: QTextDocument\n        :param file: Document file.\n        :type file: unicode\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if not foundations.common.path_exists(file):\n            raise foundations.exceptions.FileExistsError(\"{0} | '{1}' file doesn't exists!\".format(\n                self.__class__.__name__, file))\n\n        if self.get_editor(file):\n            LOGGER.info(\"{0} | '{1}' is already loaded!\".format(self.__class__.__name__, file))\n            return True\n\n        self.close_first_file()\n        language = self.__languages_model.get_language(self.__default_language)\n        editor = Editor(parent=self, language=language)\n        if not editor.new_file():\n            return False\n\n        LOGGER.info(\"{0} | Loading '{1}' file document!\".format(self.__class__.__name__, file))\n        language = self.__languages_model.get_file_language(\n            file) or self.__languages_model.get_language(self.__default_language)\n        if not editor.load_document(document, file, language):\n            return False\n\n        if self.__model.set_authoring_nodes(editor):\n            self.__store_recent_file(file)\n            self.file_loaded.emit(file)\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_project(self, path):\n\n        if not foundations.common.path_exists(path):\n            return False\n\n        path = os.path.normpath(path)\n        if self.__model.get_project_nodes(path):\n            self.__engine.notifications_manager.warnify(\n                \"{0} | '{1}' project is already opened!\".format(self.__class__.__name__, path))\n            return False\n\n        LOGGER.info(\"{0} | Adding '{1}' project!\".format(self.__class__.__name__, path))\n        project_node = self.__model.register_project(path)\n        if not project_node:\n            return False\n\n        self.__model.set_project_nodes(project_node)\n        return True", "response": "Adds a project to the database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_project(self, path):\n\n        project_node = foundations.common.get_first_item(self.__model.get_project_nodes(path))\n        if not project_node:\n            self.__engine.notifications_manager.warnify(\n                \"{0} | '{1}' project is not opened!\".format(self.__class__.__name__, path))\n            return False\n\n        LOGGER.info(\"{0} | Removing '{1}' project!\".format(self.__class__.__name__, path))\n        self.__model.delete_project_nodes(project_node)\n        return True", "response": "Removes a project.\n\n        :param path: Project path.\n        :type path: unicode\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new file into a new Script_Editor_tabWidget.", "response": "def new_file(self):\n        \"\"\"\n        Creates a new file into a new **Script_Editor_tabWidget** Widget tab.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        language = self.__languages_model.get_language(self.__default_script_language)\n        editor = Editor(parent=self, language=language)\n\n        file = editor.new_file()\n        if not file:\n            return False\n\n        LOGGER.info(\"{0} | Creating '{1}' file!\".format(self.__class__.__name__, file))\n\n        if self.__model.set_authoring_nodes(editor):\n            self.__store_recent_file(file)\n            self.file_loaded.emit(file)\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreloading given file **Script_Editor_tabWidget** Widget Model editor content.", "response": "def reload_file(self, file, is_modified=True):\n        \"\"\"\n        Reloads given file **Script_Editor_tabWidget** Widget tab Model editor content.\n\n        :param file: File to reload.\n        :type file: unicode\n        :param is_modified: File modified state.\n        :type is_modified: bool\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if not foundations.common.path_exists(file):\n            raise foundations.exceptions.FileExistsError(\"{0} | '{1}' file doesn't exists!\".format(\n                self.__class__.__name__, file))\n\n        editor = self.get_editor(file)\n        if not editor:\n            return False\n\n        if self.__has_editor_lock(editor):\n            self.__unlock_editor(editor)\n            return True\n\n        LOGGER.info(\"{0} | Reloading '{1}' file!\".format(self.__class__.__name__, file))\n        return editor.reload_file(is_modified)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_file(self, file=None):\n\n        editor = file and self.get_editor(file) or self.get_current_editor()\n        if not editor:\n            return False\n\n        LOGGER.info(\"{0} | Saving '{1}' file!\".format(self.__class__.__name__, editor.file))\n        self.__lock_editor(editor)\n        if not editor.is_untitled and foundations.common.path_exists(editor.file):\n            return editor.save_file()\n        else:\n            return self.save_fileAs()", "response": "Saves either given file or current Script_Editor_tabWidget. tabModel editor file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_fileAs(self):\n\n        editor = self.get_current_editor()\n        if not editor:\n            return False\n\n        file = umbra.ui.common.store_last_browsed_path(QFileDialog.getSaveFileName(self, \"Save As:\", editor.file))\n        if not file:\n            return False\n\n        candidate_editor = self.get_editor(file)\n        if candidate_editor:\n            if not candidate_editor is editor:\n                raise foundations.exceptions.UserError(\"{0} | '{1}' file is already opened!\".format(\n                    self.__class__.__name__, file))\n            else:\n                return self.save_file(file)\n\n        LOGGER.info(\"{0} | Saving '{1}' file!\".format(self.__class__.__name__, file))\n        self.__lock_editor(editor)\n        self.unregister_node_path(editor)\n        if editor.save_fileAs(file):\n            self.__model.update_authoring_nodes(editor)\n            language = self.__languages_model.get_file_language(\n                file) or self.__languages_model.get_language(self.__default_language)\n            if editor.language.name != language.name:\n                self.set_language(editor, language)\n            return True", "response": "Saves current script editor file as user chosen file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_all_files(self):\n\n        self.__engine.start_processing(\"Saving All Files ...\", len(self.list_editors()))\n        success = True\n        for file in self.list_files():\n            success *= self.save_file(file)\n            self.__engine.step_processing()\n        self.__engine.stop_processing()\n        return success", "response": "Saves all files in the current tab Model editor."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef revert_file(self, file=None):\n\n        editor = file and self.get_editor(file) or self.get_current_editor()\n        if not editor:\n            return False\n\n        file = editor.file\n        LOGGER.info(\"{0} | Reverting '{1}' file!\".format(self.__class__.__name__, file))\n        if self.reload_file(file, is_modified=False):\n            return True", "response": "Reverts either given file or current editor file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclosing either given file or current editor file.", "response": "def close_file(self, file=None, leave_first_editor=True):\n        \"\"\"\n        Closes either given file or current **Script_Editor_tabWidget** Widget tab Model editor file.\n\n        :param file: File to save.\n        :type file: unicode\n        :param leave_first_editor: Leave first editor.\n        :type leave_first_editor: bool\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        editor = file and self.get_editor(file) or self.get_current_editor()\n        if not editor:\n            return False\n\n        file = editor.file\n        LOGGER.info(\"{0} | Closing '{1}' file!\".format(self.__class__.__name__, file))\n        if not editor.close_file():\n            return False\n\n        if self.__model.delete_authoring_nodes(editor):\n            if not self.has_editor_tab() and leave_first_editor:\n                self.new_file()\n            self.file_closed.emit(file)\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclose all opened files and removes their associated Script_Editor_tabWidget Widgets.", "response": "def close_all_files(self, leave_first_editor=True):\n        \"\"\"\n        Closes every opened files and removes their associated **Script_Editor_tabWidget** Widget tabs.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        # self.__engine.start_processing(\"Closing All Files ...\", len(self.list_editors()))\n        success = True\n        for file in self.list_files():\n            success *= True if self.close_file(file, leave_first_editor) else False\n            if not success:\n                break\n\n                # self.__engine.step_processing()\n        # self.__engine.stop_processing()\n        return success"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef close_first_file(self):\n\n        editor = self.get_current_editor()\n        if len(self.__model.list_editors()) == 1 and editor.is_untitled and not editor.is_modified():\n            self.close_file(leave_first_editor=False)\n            return True", "response": "Closes the first file in the current tab Model editor."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the Model editor associated with given file.", "response": "def get_editor(self, file):\n        \"\"\"\n        Returns the Model editor associated with given file.\n\n        :param file: File to search editors for.\n        :type file: unicode\n        :return: Editor.\n        :rtype: Editor\n        \"\"\"\n\n        for editor in self.__model.list_editors():\n            if editor.file == file:\n                return editor"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_language(self, editor, language):\n\n        LOGGER.debug(\"> Setting '{0}' language to '{1}' editor.\".format(language.name, editor))\n\n        return editor.set_language(language)", "response": "Sets given language to given Model editor."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmoves current tab widget editor cursor to user defined line.", "response": "def go_to_line(self):\n        \"\"\"\n        Moves current **Script_Editor_tabWidget** Widget tab Model editor cursor to user defined line.\n\n        :return: Method success.\n        :rtype: bool\n\n        :note: May require user interaction.\n        \"\"\"\n\n        editor = self.get_current_editor()\n        if not editor:\n            return False\n\n        line, state = QInputDialog.getInt(self, \"Goto Line Number\", \"Line number:\", min=1)\n        if not state:\n            return False\n\n        LOGGER.debug(\"> Chosen line number: '{0}'.\".format(line))\n        return editor.go_to_line(line)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nevaluate current script editor s selected content in the interactive console.", "response": "def evaluate_selection(self):\n        \"\"\"\n        Evaluates current **Script_Editor_tabWidget** Widget tab Model editor\n        selected content in the interactive console.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        editor = self.get_current_editor()\n        if not editor:\n            return False\n\n        LOGGER.debug(\"> Evaluating 'Script Editor' selected content.\")\n        if self.evaluate_code(\n                foundations.strings.to_string(editor.get_selected_text().replace(QChar(QChar.ParagraphSeparator),\n                                                                                 QString(\"\\n\")))):\n            self.ui_refresh.emit()\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nevaluating current Script Editor content into the interactive console.", "response": "def evaluate_script(self):\n        \"\"\"\n        Evaluates current **Script_Editor_tabWidget** Widget tab Model editor content\n        into the interactive console.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        editor = self.get_current_editor()\n        if not editor:\n            return False\n\n        LOGGER.debug(\"> Evaluating 'Script Editor' content.\")\n        if self.evaluate_code(foundations.strings.to_string(editor.toPlainText().toUtf8())):\n            self.ui_refresh.emit()\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nevaluates given code into the interactive console.", "response": "def evaluate_code(self, code):\n        \"\"\"\n        Evaluates given code into the interactive console.\n\n        :param code: Code to evaluate.\n        :type code: unicode\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if not code:\n            return False\n\n        LOGGER.debug(\"> Evaluating given code.\")\n\n        code = code.endswith(\"\\n\") and code or \"{0}\\n\".format(code)\n\n        code = code.split(\"\\n\", 3)\n        for i, line in enumerate(code[:-2]):\n            if \"coding\" in line:\n                code[i] = line.replace(\"=\", \"\\=\").replace(\":\", \"\\:\")\n                break\n        code = \"\\n\".join(code)\n\n        sys.stdout.write(code)\n        self.__console.runcode(code)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef store_session(self):\n\n        session = []\n        for editor in self.list_editors():\n            file = editor.file\n            ignore_file = True\n            if editor.is_untitled and not editor.is_empty():\n                file = os.path.join(self.__default_session_directory, file)\n                editor.write_file(file)\n            elif os.path.dirname(file) == self.__default_session_directory:\n                editor.save_file()\n            session.append(file)\n\n        for directory in self.list_projects():\n            if not os.path.exists(directory):\n                continue\n\n            session.append(directory)\n\n        LOGGER.debug(\"> Storing session :'{0}'.\".format(session))\n        self.__settings.set_key(self.__settings_section, \"session\", session)\n        return True", "response": "Stores the current session."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrestoring the stored session.", "response": "def restore_session(self):\n        \"\"\"\n        Restores the stored session.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        session = [foundations.strings.to_string(path)\n                   for path in self.__settings.get_key(self.__settings_section, \"session\").toStringList()\n                   if foundations.common.path_exists(path)]\n\n        LOGGER.debug(\"> Restoring session :'{0}'.\".format(session))\n        success = True\n        for path in session:\n            if os.path.isfile(path):\n                success *= self.load_file(path)\n            else:\n                success *= self.add_project(path)\n        return success"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef loop_through_editors(self, backward=False):\n\n        step = not backward and 1 or -1\n        idx = self.Script_Editor_tabWidget.currentIndex() + step\n        if idx < 0:\n            idx = self.Script_Editor_tabWidget.count() - 1\n        elif idx > self.Script_Editor_tabWidget.count() - 1:\n            idx = 0\n        self.Script_Editor_tabWidget.setCurrentIndex(idx)\n        return True", "response": "Loop through the editor tabs."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrestores the development layout.", "response": "def restore_development_layout(self):\n        \"\"\"\n        Restores the development layout.\n\n        :return: Definition success.\n        :rtype: bool\n        \"\"\"\n\n        if self.__engine.layouts_manager.current_layout != self.__development_layout and not self.isVisible():\n            self.__engine.layouts_manager.restore_layout(self.__development_layout)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_args():\n    parser = argparse.ArgumentParser(description=\"Converts, and downloads a vm by name from vCenter to OVF in specified\"\n                                                 \" directory, then uploads the image as an AMI. AMI will be uploaded \"\n                                                 \"using specified AWS profile, to specified regions. \")\n    parser.add_argument('-i', '--vcenter_host', type=str, required=True, help='Hostname or Ip of vCenter API of VM')\n    parser.add_argument('-u', '--vcenter_user', type=str, required=True, help='Username for vCenter authentication')\n    parser.add_argument('-p', '--vcenter_pass', type=str, required=True, help='Password for authentication to vCenter API')\n    parser.add_argument('-n', '--vm_name', type=str, required=True, help='Name of the VM in vCenter')\n    parser.add_argument('-d', '--directory', type=str, default=tempfile.mkdtemp(),\n                        help='Directory to save the vmdk temp file (defaults to temp location')\n    parser.add_argument('-w', '--vcenter_port', type=str, default='443',\n                        help='Port to use for communication to vcenter api. Default is 443')\n    args = parser.parse_args()\n    validate_args(args)\n    return args", "response": "Parse command line arguments and validate them"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate_args(args):\n    if not os.path.isdir(args.directory):\n        print \"Directory {} does not exist\".format(args.directory)\n        sys.exit(5)\n    return args", "response": "Call all required validation functions\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a vCenter to OVF.", "response": "def convert(args):\n    \"\"\"\n    Download VM disks, and OVF from vCenter\n    :param args:\n    :return: created vmdk\n    \"\"\"\n    exporter = OvfExporter(user=args.vcenter_user,password=args.vcenter_pass, host=args.vcenter_host, port=args.vcenter_port,\n                           vm_name=args.vm_name, dir=args.directory)\n    return exporter.export_ovf()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef estimate(phenotype, G=None, K=None, covariates=None, overdispersion=True):\n    logger = logging.getLogger(__name__)\n    logger.info('Heritability estimation has started.')\n\n    G, K = _background_standardize(G, K)\n\n    if G is None and K is None:\n        raise Exception('G and K cannot be all None.')\n\n    Q0, Q1, S0 = _background_decomposition(G, K)\n\n    if covariates is None:\n        logger.debug('Inserting offset covariate.')\n        covariates = ones((phenotype.sample_size, 1))\n\n    logger.debug('Constructing EP.')\n    from limix_inference.glmm import ExpFamEP\n    ep = ExpFamEP(phenotype.to_likelihood(), covariates, Q0, Q1, S0,\n                  overdispersion)\n\n    logger.debug('EP optimization.')\n    ep.learn()\n\n    h2 = ep.heritability\n    logger.info('Found heritability before correction: %.5f.', h2)\n\n    return h2", "response": "Estimate the narrow - sense heritability."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef retrieve_mtm_results(self, book_id, asset_manager_id, paramaters):\n        self.logger.info('Retrieving mtm Positions - Asset Manager: %s', asset_manager_id)\n        url = '%s/mtm/%s' % (self.endpoint, asset_manager_id)\n        paramaters.update({'book_id': book_id})\n        response = self.session.get(url, params = paramaters)\n        if response.ok:\n            mtm_results = [json_to_mtm_result(json_mtm_result) for json_mtm_result in response.json()]\n            self.logger.info('Returned %s mtm results.', len(mtm_results))\n            return mtm_results\n        else:\n            self.logger.error(response.text)\n            response.raise_for_status()", "response": "Retrieves all the mtm results for a given asset manager and book."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pnl_search(self, asset_manager_id, pnl_type, business_date,\n                   **kwargs):\n        \"\"\"\n        Search pnl records.\n\n        Args:\n            asset_manager_id (int): id of asset manager owning the pnl records\n            pnl_type (str): either \"Position\" or \"Transaction\n            business_date (date): date of the pnl records to return\n            book_ids (list): book id filter on pnl records\n            asset_ids (list): asset id filter on pnl records\n            transaction_ids (list): transactino id filter on pnl records\n            next_hash_key (str): continuation hash key for paging the results\n            next_range_key (str): continuation range key for paging the results\n            page_size (int): the number of results to return\n        \"\"\"\n        self.logger.info('Retrieving Pnls - Asset Manager: %s - Business Date: %s' % \\\n                        (asset_manager_id, business_date))\n        url = '%s/pnls/%s' % (self.endpoint, asset_manager_id)\n        search_params = {'pnl_type': pnl_type,\n                         'business_date': business_date.isoformat()}\n\n        for param_key, param_val in kwargs.items():\n            if not param_val:\n                continue\n            search_params[param_key] = ','.join(param_val) if isinstance(param_val, list) else param_val\n\n        response = self.session.get(url, params=search_params)\n        if response.ok:\n            json_body = response.json()\n            results = json_body.get('items')\n            next_hash_key = json_body.get('next_hash_key')\n            next_range_key = json_body.get('next_range_key')\n            pnls = [json_to_pnl(pnl_json) for pnl_json in results]\n            self.logger.info('Retrieved %s Pnl records.', len(pnls))\n            return next_hash_key, next_range_key, pnls\n        else:\n            self.logger.error(response.text)\n            response.raise_for_status()", "response": "Search the Pnls for the given asset manager and return the results."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pnl_upsert(self, asset_manager_id, pnls):\n        self.logger.info('Upsert PnL for - Asset Manager: %s', asset_manager_id)\n        pnls = [pnls] if not isinstance(pnls, list) else pnls\n\n        json_pnls = [pnl.to_interface() for pnl in pnls]\n        url = '%s/pnls/%s' % (self.endpoint, asset_manager_id)\n        response = self.session.put(url, json=json_pnls)\n        if response.ok:\n            results = []\n            for pnl_result in response.json():\n                results.append(json_to_pnl(pnl_result))\n            self.logger.info('Upserted %s PnL records', len(results))\n            return results\n        else:\n            self.logger.error(response.text)\n            response.raise_for_status()", "response": "Upserts a list of pnls for an asset manager."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncancel the PNL records matching the request.", "response": "def pnl_cancel(self, asset_manager_id, pnl_type,\n                   business_date, book_id,\n                   next_hash_key=None, next_range_key=None,\n                   page_size=None):\n        \"\"\"\n        Cancel the PNL records matching the request\n\n        Args:\n            asset_manager_id (int): id of asset manager owning the pnl records\n            pnl_type (str): either \"Position\" or \"Transaction\n            business_date (date): date of the pnl records to return\n            book_id (str): book id filter on pnl records\n            next_hash_key (str): continuation hash key for paging the results\n            next_range_key (str): continuation range key for paging the results\n            page_size (int): the number of results to return\n        \"\"\"\n        self.logger.info('Cancelling %s Pnls - Asset Manager: %s - Business Date: %s - Book: %s' % \\\n                        (pnl_type, asset_manager_id, business_date, book_id))\n        url = '%s/pnls/%s' % (self.endpoint, asset_manager_id)\n        params = {'pnl_type': pnl_type,\n                  'business_date': business_date.isoformat(),\n                  'book_id': book_id}\n\n        if next_hash_key:\n            params['next_hash_key'] = next_hash_key\n        if next_range_key:\n            params['next_range_key'] = next_range_key\n        if page_size:\n            params['page_size'] = page_size\n\n        response = self.session.delete(url, params=params)\n        if response.ok:\n            json_body = response.json()\n            next_hash_key = json_body.get('next_hash_key')\n            next_range_key = json_body.get('next_range_key')\n            count = json_body.get('count')\n            self.logger.info('Cancelled %s Pnl records.', count)\n            return next_hash_key, next_range_key, count\n        else:\n            self.logger.error(response.text)\n            response.raise_for_status()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve the netting set for a single transaction.", "response": "def retrieve_netting_set(self, asset_manager_id, transaction_id):\n        \"\"\"\n        Returns all the transaction_ids associated with a single netting set.  Pass in the ID for any transaction in\n        the set.\n        :param asset_manager_id:  The asset_manager_id for the netting set owner.\n        :param transaction_id: A transaction_id of an entry within the netting set.\n        :return:\n        \"\"\"\n        self.logger.info('Retrieve Netting Set - Asset Manager: %s - Transaction ID: %s', asset_manager_id,\n                         transaction_id)\n        url = '%s/netting/%s/%s' % (self.endpoint, asset_manager_id, transaction_id)\n        response = self.session.get(url)\n        if response.ok:\n            net_transaction_id, netting_set_json = next(iter(response.json().items()))\n            netting_set = [json_to_transaction(net_transaction) for net_transaction in netting_set_json]\n            self.logger.info('Returned %s Transactions in Netting Set.', len(netting_set))\n            return net_transaction_id, netting_set\n        else:\n            self.logger.error(response.text)\n            response.raise_for_status()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbooking an asset between two books.", "response": "def book_transfer(self, asset_manager_id, asset_id, source_book_id, target_book_id, wash_book_id, quantity, price,\n                      currency):\n        \"\"\"\n        A method for moving between books.  The convention is always *from* the source, *to* the target.\n\n        Two transactions are booked -  one against each\n\n        :param asset_manager_id: The owning asset manager id.\n        :param asset_id: The asset being transferred.\n        :param source_book_id: The book id of the source.\n        :param target_book_id:  The book id of the target.\n        :param wash_book_id:  The book id of the wash book which will be the counterparty for the two sides.\n        :param quantity: The quantity to transfer.\n        :param price:  The price at which to make the transfer.  Typically T-1 EOD price or current market price.\n        :param currency: The currency for the transfer price.\n        :return:\n        \"\"\"\n        url = '%s/book_transfer/%s' % (self.endpoint, asset_manager_id)\n        body = {'asset_id': asset_id, 'source_book_id': source_book_id, 'target_book_id': target_book_id,\n                'wash_book_id': wash_book_id, 'quantity': quantity, 'price': price, 'currency': currency}\n        response = self.session.post(url, data=json.dumps(body, default=json_handler), headers=self.json_header)\n        if response.ok:\n            deliver_json, receive_json = response.json()\n            return json_to_transaction(deliver_json), json_to_transaction(receive_json),\n        else:\n            self.logger.error(response.text)\n            response.raise_for_status()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd dic pairs to self. data", "response": "def join(self, dic):\n        \"\"\" Add dic pairs to self.data \"\"\"\n        for k,v in dic.iteritems():\n            if k in self.data:\n                self[k] += dic[k]\n            else:\n                self[k] = deepcopy(v)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef map(self, callable):\n        for k,v in self.iteritems():\n            self[k] = callable(v)", "response": "Apply callable function over all values in the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fromrepetitions(cls, iterable):\n        d = cls()\n        for key in iterable:\n            d[key] = d[key] + 1 if key in d else 1\n        return d", "response": "Create a dict whose keys are the members of the iterable and values are the number of times the key appears in the iterable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef relookup(self, pattern):\n        key = re.compile(pattern)\n        return filter(lambda x : key.match(x[0]), self.data.items())", "response": "Dictionary lookup with a regular expression. Return pairs whose key \n        matches pattern."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_corenlp_version():\n    \"Return the corenlp version pointed at by CORENLP_HOME, or None\"\n    corenlp_home = os.environ.get(\"CORENLP_HOME\")\n    if corenlp_home:\n        for fn in os.listdir(corenlp_home):\n            m = re.match(\"stanford-corenlp-([\\d.]+)-models.jar\", fn)\n            if m:\n                return m.group(1)", "response": "Return the corenlp version pointed at by CORENLP_HOME or None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the system ( shell ) call to run corenlp", "response": "def get_command(annotators=None, memory=None):\n    \"Return the system (shell) call to run corenlp\"\n    corenlp_home = os.environ.get(\"CORENLP_HOME\")\n    if not corenlp_home:\n        raise Exception(\"CORENLP_HOME not set\")\n    cmd = 'java'\n    if memory:\n        cmd += ' -Xmx{memory}'.format(**locals())\n    cmd += ' -cp \"{}\"'.format(os.path.join(corenlp_home, \"*\"))\n    cmd += \" edu.stanford.nlp.pipeline.StanfordCoreNLP -outputFormat xml\"\n    if annotators:\n        cmd += ' -annotators {}'.format(\",\".join(annotators))\n    return cmd"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef corenlp2naf(xml_bytes, annotators):\n    naf = KafNafParser(type=\"NAF\")\n\n    try:\n        doc = Document(xml_bytes)\n    except:\n        log.exception(\"Error on parsing xml\")\n        raise\n\n    terms = {} # (xml_sentid, xml_tokenid) : term\n    for sent in doc.sentences:\n        for t in sent.tokens:\n            wf = naf.create_wf(t.word, sent.id, t.character_offset_begin)\n            term = naf.create_term(t.lemma, POSMAP[t.pos], t.pos, [wf])\n            terms[sent.id, t.id] = term\n            if t.ner not in (None, 'O'):\n                naf.create_entity(t.ner, [term.get_id()])\n        if sent.collapsed_ccprocessed_dependencies:\n            dependencies = True\n            for dep in sent.collapsed_ccprocessed_dependencies.links:\n                if dep.type != 'root':\n                    child = terms[sent.id, dep.dependent.idx]\n                    parent = terms[sent.id, dep.governor.idx]\n                    comment = \"{t}({o}, {s})\".format(s=child.get_lemma(), t=dep.type, o=parent.get_lemma())\n                    naf.create_dependency(child.get_id(), parent.get_id(), dep.type, comment=comment)\n\n    if doc.coreferences:\n        for coref in doc.coreferences:\n            cterms = set()\n            for m in coref.mentions:\n                cterms |= {terms[m.sentence.id, t.id].get_id() for t in m.tokens}\n            naf.create_coreference(\"term\", cterms)\n        \n    for annotator in annotators:\n        if annotator in LAYERMAP:\n            naf.create_linguistic_processor(LAYERMAP[annotator], \"CoreNLP {annotator}\".format(**locals()),\n                                            get_corenlp_version())\n    s = BytesIO()\n    naf.dump(s)\n    return s.getvalue()", "response": "Return a Naf object from a corenlp text."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget or create a corenlp parser with the given annotator and options.", "response": "def get_singleton(cls, annotators=None, **options):\n        \"\"\"\n        Get or create a corenlp parser with the given annotator and options\n        Note: multiple parsers with the same annotator and different options\n              are not supported.\n        \"\"\"\n        if annotators is not None:\n            annotators = tuple(annotators)\n        if annotators not in cls._singletons:\n            cls._singletons[annotators] = cls(annotators, **options)\n        return cls._singletons[annotators]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nintending to be run as background thread to collect parser output", "response": "def read_output_lines(self):\n        \"intended to be run as background thread to collect parser output\"\n        while True:\n            chars = self.corenlp_process.stdout.readline()\n            if chars == '':  # EOF\n                break\n            self.out.write(chars)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse(self, text):\n        if isinstance(text, bytes):\n            text = text.decode(\"ascii\")\n        text = re.sub(\"\\s+\", \" \", unidecode(text))\n        return self.communicate(text + \"\\n\")", "response": "Call the server and return the raw results."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses a message and update the database if necessary.", "response": "def message(self, bot, comm):\n        \"\"\"\n        Check for strings ending with 2 or more '-' or '+'\n        \"\"\"\n        super(KarmaAdv, self).message(bot, comm)\n\n        # No directed karma giving or taking\n        if not comm['directed'] and not comm['pm']:\n            msg = comm['message'].strip().lower()\n            # use the magic above\n            words = self.regstr.findall(msg)\n            # Do things to people\n            karmas = self.modify_karma(words)\n            # Notify the users they can't modify their own karma\n            if comm['user'] in karmas.keys():\n                if karmas[comm['user']] <= 0:\n                    bot.reply(comm, \"Don't be so hard on yourself.\")\n                else:\n                    bot.reply(comm, \"Tisk, tisk, no up'ing your own karma.\")\n            # Commit karma changes to the db\n            self.update_db(comm[\"user\"], karmas)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef modify_karma(self, words):\n\n        # 'user': karma\n        k = defaultdict(int)\n\n        if words:\n            # For loop through all of the group members\n            for word_tuple in words:\n                word = word_tuple[0]\n                ending = word[-1]\n                # This will either end with a - or +, if it's a - subract 1\n                # kara, if it ends with a +, add 1 karma\n                change = -1 if ending == '-' else 1\n                # Now strip the ++ or -- from the end\n                if '-' in ending:\n                    word = word.rstrip('-')\n                elif '+' in ending:\n                    word = word.rstrip('+')\n                # Check if surrounded by parens, if so, remove them\n                if word.startswith('(') and word.endswith(')'):\n                    word = word[1:-1]\n                # Finally strip whitespace\n                word = word.strip()\n                # Add the user to the dict\n                if word:\n                    k[word] += change\n        return k", "response": "Given a regex object look through the groups and modify karma\n            as necessary and return a dictionary of the keys that are the user s words."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_db(self, giver, receiverkarma):\n\n        for receiver in receiverkarma:\n            if receiver != giver:\n                urow = KarmaStatsTable(\n                    ude(giver), ude(receiver), receiverkarma[receiver])\n                self.db.session.add(urow)\n        self.db.session.commit()", "response": "Update the database with the giver and receiver karma stats."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef info():\n    application = get_current_application()\n    info = application.info()\n    stdout.write(info)\n    return info", "response": "Display app info.\n\n    Examples:\n\n    $ dj info\n    No application, try running dj init.\n\n    $ dj info\n    Application:\n      foo @ 2.7.9\n    Requirements:\n      Django == 1.10"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef miscellaneous_menu(self, value):\n\n        if value is not None:\n            assert type(value) is QMenu, \"'{0}' attribute: '{1}' type is not 'QMenu'!\".format(\n                \"miscellaneous_menu\", value)\n        self.__miscellaneous_menu = value", "response": "Set the miscellaneous_menu attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the application toolbar.", "response": "def __initialize_ui(self):\n        \"\"\"\n        Initializes the Widget ui.\n        \"\"\"\n\n        LOGGER.debug(\"> Initializing Application toolBar!\")\n\n        self.setIconSize(QSize(UiConstants.default_toolbar_icon_size, UiConstants.default_toolbar_icon_size))\n        self.setAllowedAreas(Qt.TopToolBarArea)\n        self.setFloatable(False)\n        self.setMovable(False)\n        self.set_layout_default_geometry()\n\n        self.setObjectName(\"toolBar\")\n        self.setWindowTitle(\"{0} - toolBar\".format(Constants.application_name))\n\n        self.set_toolbar_children_widgets()\n\n        # Signals / Slots.\n        self.__container.layouts_manager.layout_stored.connect(self.__layouts_manager__layout_stored)\n        self.__container.layouts_manager.layout_restored.connect(self.__layouts_manager__layout_restored)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_toolbar_children_widgets(self):\n\n        LOGGER.debug(\"> Adding 'Application_Logo_label' widget!\")\n        self.addWidget(self.get_application_logo_label())\n\n        LOGGER.debug(\"> Adding 'Spacer_label' widget!\")\n        self.addWidget(self.get_spacer_label())\n\n        LOGGER.debug(\"> Adding 'Development_active_label', 'Preferences_active_label' widgets!\")\n        for layout_active_label in self.get_layouts_active_labels():\n            self.addWidget(layout_active_label)\n\n        LOGGER.debug(\"> Adding 'Custom_Layouts_active_label' widget!\")\n        self.addWidget(self.get_custom_layouts_active_label())\n\n        LOGGER.debug(\"> Adding 'Miscellaneous_active_label' widget!\")\n        self.addWidget(self.get_miscellaneous_active_label())\n\n        LOGGER.debug(\"> Adding 'Closure_Spacer_label' widget!\")\n        self.addWidget(self.get_closure_spacer_label())\n\n        return True", "response": "Sets the toolBar children widgets."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprovides the default application logo label.", "response": "def get_application_logo_label(self):\n        \"\"\"\n        Provides the default **Application_Logo_label** widget.\n\n        :return: Application logo label.\n        :rtype: QLabel\n        \"\"\"\n\n        logo_label = QLabel()\n        logo_label.setObjectName(\"Application_Logo_label\")\n        logo_label.setPixmap(QPixmap(umbra.ui.common.get_resource_path(UiConstants.logo_image)))\n        return logo_label"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a layout Active_QLabel widget.", "response": "def get_layout_active_label(self, resources, name, title, identity, shortcut):\n        \"\"\"\n        Returns a layout **Active_QLabel** widget.\n\n        :param resources: Icons resources ( Default / Hover / Active ).\n        :type resources: tuple\n        :param name: Ui object name.\n        :type name: unicode\n        :param title: Layout registration title.\n        :type title: unicode\n        :param identity: Layout code name.\n        :type identity: unicode\n        :param shortcut: Layout associated shortcut. ( QtCore.Key )\n        :return: Layout active label.\n        :rtype: Active_QLabel\n        \"\"\"\n\n        default_icon, hover_icon, active_icon = resources\n        layout_active_label = Active_QLabel(self,\n                                            QPixmap(umbra.ui.common.get_resource_path(default_icon)),\n                                            QPixmap(umbra.ui.common.get_resource_path(hover_icon)),\n                                            QPixmap(umbra.ui.common.get_resource_path(active_icon)),\n                                            True)\n        self.__container.layouts_manager.register_layout(identity, umbra.managers.layouts_manager.Layout(name=title,\n                                                                                                         identity=identity,\n                                                                                                         shortcut=shortcut))\n        self.__container.addAction(\n            self.__container.actions_manager.register_action(\n                \"Actions|Umbra|ToolBar|Layouts|Restore layout {0}\".format(title),\n                shortcut=shortcut,\n                shortcut_context=Qt.ApplicationShortcut,\n                slot=functools.partial(\n                    self.__container.layouts_manager.restore_layout, identity)))\n\n        layout_active_label.setObjectName(name)\n\n        # Signals / Slots.\n        layout_active_label.clicked.connect(functools.partial(self.__layout_active_label__clicked, identity))\n\n        return layout_active_label"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_layouts_active_labels(self):\n\n        self.__layouts_active_labels_collection = Active_QLabelsCollection(self)\n\n        self.__layouts_active_labels_collection.add_active_label(\n            self.get_layout_active_label((UiConstants.development_icon,\n                                          UiConstants.development_hover_icon,\n                                          UiConstants.development_active_icon),\n                                         \"Development_active_label\",\n                                         \"Development\",\n                                         \"development_centric\",\n                                         Qt.Key_9))\n\n        self.__layouts_active_labels_collection.add_active_label(\n            self.get_layout_active_label((UiConstants.preferences_icon,\n                                          UiConstants.preferences_hover_icon,\n                                          UiConstants.preferences_active_icon),\n                                         \"Preferences_active_label\",\n                                         \"Preferences\",\n                                         \"preferences_centric\",\n                                         Qt.Key_0))\n        return self.__layouts_active_labels_collection.active_labels", "response": "Returns the layouts Active_QLabels widgets."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_custom_layouts_active_label(self):\n\n        layout_active_label = Active_QLabel(self,\n                                            QPixmap(umbra.ui.common.get_resource_path(UiConstants.custom_layouts_icon)),\n                                            QPixmap(\n                                                umbra.ui.common.get_resource_path(\n                                                    UiConstants.custom_layouts_hover_icon)),\n                                            QPixmap(umbra.ui.common.get_resource_path(\n                                                UiConstants.custom_layouts_active_icon)))\n        layout_active_label.setObjectName(\"Custom_Layouts_active_label\")\n\n        self.__custom_layouts_menu = QMenu(\"Layouts\", layout_active_label)\n\n        for layout in self.__user_layouts:\n            self.__container.layouts_manager.register_layout(layout.identity, layout)\n            self.__custom_layouts_menu.addAction(self.__container.actions_manager.register_action(\n                \"Actions|Umbra|ToolBar|Layouts|Restore layout {0}\".format(layout.name),\n                shortcut=layout.shortcut,\n                slot=functools.partial(self.__container.layouts_manager.restore_layout, layout.identity)))\n\n        self.__custom_layouts_menu.addSeparator()\n\n        for layout in self.__user_layouts:\n            self.__custom_layouts_menu.addAction(self.__container.actions_manager.register_action(\n                \"Actions|Umbra|ToolBar|Layouts|Store layout {0}\".format(layout.name),\n                shortcut=Qt.CTRL + layout.shortcut,\n                slot=functools.partial(self.__container.layouts_manager.store_layout, layout.identity)))\n\n        self.__custom_layouts_menu.addSeparator()\n\n        self.__custom_layouts_menu.addAction(self.__container.actions_manager.register_action(\n            \"Actions|Umbra|ToolBar|Layouts|Toggle FullScreen\",\n            shortcut=Qt.ControlModifier + Qt.SHIFT + Qt.Key_F,\n            slot=self.__container.toggle_full_screen))\n\n        layout_active_label.set_menu(self.__custom_layouts_menu)\n        return layout_active_label", "response": "Provides the default **Custom_Layouts_active_label** widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprovides the default Miscellaneous active label.", "response": "def get_miscellaneous_active_label(self):\n        \"\"\"\n        Provides the default **Miscellaneous_active_label** widget.\n\n        :return: Miscellaneous active label.\n        :rtype: Active_QLabel\n        \"\"\"\n\n        miscellaneous_active_label = Active_QLabel(self,\n                                                   QPixmap(\n                                                       umbra.ui.common.get_resource_path(\n                                                           UiConstants.miscellaneous_icon)),\n                                                   QPixmap(\n                                                       umbra.ui.common.get_resource_path(\n                                                           UiConstants.miscellaneous_hover_icon)),\n                                                   QPixmap(umbra.ui.common.get_resource_path(\n                                                       UiConstants.miscellaneous_active_icon)))\n        miscellaneous_active_label.setObjectName(\"Miscellaneous_active_label\")\n\n        self.__miscellaneous_menu = QMenu(\"Miscellaneous\", miscellaneous_active_label)\n\n        self.__miscellaneous_menu.addAction(self.__container.actions_manager.register_action(\n            \"Actions|Umbra|ToolBar|Miscellaneous|Help content ...\",\n            shortcut=\"F1\",\n            slot=self.__help_display_misc_action__triggered))\n        self.__miscellaneous_menu.addAction(self.__container.actions_manager.register_action(\n            \"Actions|Umbra|ToolBar|Miscellaneous|Api content ...\",\n            slot=self.__api_display_misc_action__triggered))\n        self.__miscellaneous_menu.addSeparator()\n\n        miscellaneous_active_label.set_menu(self.__miscellaneous_menu)\n        return miscellaneous_active_label"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nproviding the default Spacer_label widget.", "response": "def get_spacer_label(self):\n        \"\"\"\n        Provides the default **Spacer_label** widget.\n\n        :return: Logo spacer label.\n        :rtype: QLabel\n        \"\"\"\n\n        spacer = QLabel()\n        spacer.setObjectName(\"Spacer_label\")\n        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        return spacer"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_closure_spacer_label(self):\n\n        spacer = QLabel()\n        spacer.setObjectName(\"Closure_Spacer_label\")\n        spacer.setSizePolicy(QSizePolicy.Maximum, QSizePolicy.Expanding)\n        return spacer", "response": "Provides the default Closure spacer label."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the _date_of_birth attribute of the individual.", "response": "def date_of_birth(self, value):\n        \"\"\"\n        The date of birth of the individual.\n        :param value:\n        :return:\n        \"\"\"\n        if value:\n            self._date_of_birth = parse(value).date() if isinstance(value, type_check) else value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the least layout compatible with layout1 and layout2", "response": "def sup_of_layouts(layout1, layout2):\n        \"\"\" Return the least layout compatible with layout1 and layout2 \"\"\"\n        if len(layout1) > len(layout2):\n                layout1, layout2 = layout2, layout1\n        if len(layout1) < len(layout2):\n                layout1 += [0] * (len(layout2) - len(layout1))\n        return [max(layout1[i], layout2[i]) for i in xrange(len(layout1))]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the widths of the columns to set the table", "response": "def layout(self):\n                \"\"\" Calculate the widths of the columns to set the table \"\"\"\n                ret = []\n                for row in self.rows:\n                        if len(row) > len(ret):\n                                ret += [0] * (len(row) - len(ret))\n                        for n, field in enumerate(row):\n                                if field is self.empty_value:\n                                        field = ''\n                                ret[n] = max(ret[n], len(field))\n                return ret"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef plotLattice(beamlinepatchlist,\n                fignum=1, fig_size=20, fig_ratio=0.5,\n                xranges=(-10, 10), yranges=(-10, 10),\n                zoomfac=1.5):\n    \"\"\"\n    function plot beamline defined by ``beamlinepatchlist``, which is a set of patches for all elements\n\n    :param beamlinepatchlist: generated by function ``makeBeamline()``\n    :param fignum: figure number, 1 by default\n    :param fig_size: figure size, 20 inch by default\n    :param fig_ratio: figure ratio, 0.5 by default\n    :param xranges: axes x-ranges, ``(-10, 10)`` by default\n    :param yranges: axes y-ranges, ``(-10, 10)`` by default\n    :param zoomfac: zoom in factor, 1.5 by default\n    \"\"\"\n    fig = plt.figure(fignum, figsize=(fig_size, fig_size * fig_ratio))\n    ax = fig.add_subplot(111)\n    for ins in beamlinepatchlist:\n        [ax.add_patch(inspatch) for inspatch in ins.patch]\n    x1, x2 = xranges\n    y1, y2 = yranges\n    minx = 0.5 * (x2 + x1) - 0.5 * zoomfac * (x2 - x1)\n    maxx = 0.5 * (x2 + x1) + 0.5 * zoomfac * (x2 - x1)\n    miny = 0.5 * (y2 + y1) - 0.5 * zoomfac * (y2 - y1)\n    maxy = 0.5 * (y2 + y1) + 0.5 * zoomfac * (y2 - y1)\n    ax.set_xlim([minx, maxx])\n    ax.set_ylim([miny, maxy])\n    plt.show()", "response": "function plot the beamline defined by beamlinepatchlist"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef makeBeamline(beamlinelist, startpoint=(0, 0)):\n    latticelist = []\n    anglenow = 0.0\n    maxx, maxy = startpoint\n    minx, miny = startpoint\n\n    for i in range(len(beamlinelist)):\n        element = beamlinelist[i]\n        elementtype = element[\"type\"][0:4].lower()\n        if elementtype == \"rben\":\n            newelement = elements.Rbend(width=float(element[\"l\"]), height=1.5 * float(element[\"l\"]),\n                                        angle=float(element[\"angle\"]),\n                                        link_node=startpoint, )\n            anglenow += newelement.angle\n            minx = min(minx, newelement.minx)\n            miny = min(miny, newelement.miny)\n            maxx = max(maxx, newelement.maxx)\n            maxy = max(maxy, newelement.maxy)\n\n        elif elementtype == \"drif\":\n            newelement = elements.Drift(length=float(element[\"l\"]), angle=anglenow,\n                                        link_node=startpoint, )\n            minx = min(minx, newelement.minx)\n            miny = min(miny, newelement.miny)\n            maxx = max(maxx, newelement.maxx)\n            maxy = max(maxy, newelement.maxy)\n\n        elif elementtype == \"quad\":\n            xory = \"x\"\n            if float(element[\"k1\"]) < 0:\n                xory = \"y\"\n            newelement = elements.Quadrupole(width=float(element[\"l\"]),\n                                             angle=float(element[\"angle\"]),\n                                             xysign=xory,\n                                             link_node=startpoint, )\n            minx = min(minx, newelement.minx)\n            miny = min(miny, newelement.miny)\n            maxx = max(maxx, newelement.maxx)\n            maxy = max(maxy, newelement.maxy)\n\n        elif elementtype == \"undu\":\n            newelement = elements.Undulator(period_length=float(element[\"xlamd\"]),\n                                            period_number=int(element[\"nwig\"]),\n                                            link_node=startpoint, )\n            minx = min(minx, newelement.minx)\n            miny = min(miny, newelement.miny)\n            maxx = max(maxx, newelement.maxx)\n            maxy = max(maxy, newelement.maxy)\n\n        else:\n            print(\"unknown element\\n\")\n\n        startpoint = newelement.link_node\n        latticelist.append(newelement)\n\n    return latticelist, np.array([minx, maxx]), np.array([miny, maxy])", "response": "function to construct beamline patches for plotLattice from different elements like rben or quadrupole."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the close time in utc.", "response": "def utc_book_close_time(self):\n        \"\"\"\n        The book close time in utc.\n        \"\"\"\n        tz = pytz.timezone(self.timezone)\n        close_time = datetime.datetime.strptime(self.close_time, '%H:%M:%S').time()\n        close_time = tz.localize(datetime.datetime.combine(datetime.datetime.now(tz), close_time))\n        return close_time.astimezone(pytz.utc).time()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef uibei(order, energy_lo, temp, chem_potential):\n    if energy_lo < 0:\n        raise ValueError(\"energy_lo < 0\")\n    elif temp < 0:\n        raise ValueError(\"temp < 0\")\n    elif chem_potential < 0:\n        raise ValueError(\"chem_potential < 0\")\n\n    energy_lo = units.Quantity(energy_lo, \"eV\")\n    temp = units.Quantity(temp, \"K\")\n    chem_potential = units.Quantity(chem_potential, \"eV\")\n\n    kT = temp * constants.k_B\n\n    reduced_energy_lo = energy_lo / kT\n    reduced_chem_potential = chem_potential / kT\n\n    prefactor = (2 * np.pi * np.math.factorial(order) * kT**(order + 1)) / \\\n        (constants.h**3 * constants.c**2)\n\n    expt = (reduced_chem_potential - reduced_energy_lo).decompose()\n    real_arg = np.exp(expt.value)\n\n    if reduced_chem_potential == 0 and reduced_energy_lo == 0:\n        # Specify this condition just to skip the next condition.\n        term = float(polylog(order + 1, real_arg))\n        return term * prefactor\n    elif reduced_chem_potential >= reduced_energy_lo:\n        return 0 * prefactor\n\n    summand = 0\n    for indx in range(1, order + 2):\n        index = order - indx + 1\n\n        term = reduced_energy_lo**index * float(polylog(indx, real_arg)) / np.math.factorial(index)\n\n        summand += term\n\n    return prefactor * summand", "response": "Return a new univariate Bose - Einstein integral."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main(argv=None):\n    #\n    # `simpl server`\n    #\n    logging.basicConfig(level=logging.INFO)\n    server_func = functools.partial(server.main, argv=argv)\n    server_parser = server.attach_parser(default_subparser())\n    server_parser.set_defaults(_func=server_func)\n\n    # the following code shouldn't need to change when\n    # we add a new subcommand.\n    args = default_parser().parse_args(argv)\n    args._func()", "response": "Entry point for the simplify command."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getQRArray(text, errorCorrection):\n\t# White is True (1)\n\t# Black is False (0)\n\t# ECC: L7, M15, Q25, H30\n\n\t# Create the object\n\tqr = pyqrcode.create(text, error=errorCorrection)\n\n\t# Get the terminal representation and split by lines (get rid of top and bottom white spaces)\n\tplainOut = qr.terminal().split(\"\\n\")[5:-5]\n\n\t# Initialize the output 2D list\n\tout = []\n\n\tfor line in plainOut:\n\t\tthisOut = []\n\t\tfor char in line:\n\t\t\tif char == u'7':\n\t\t\t\t# This is white\n\t\t\t\tthisOut.append(1)\n\t\t\telif char == u'4':\n\t\t\t\t# This is black, it's part of the u'49'\n\t\t\t\tthisOut.append(0)\n\t\t# Finally add everything to the output, stipping whitespaces at start and end\n\t\tout.append(thisOut[4:-4])\n\n\t# Everything is done, return the qr code list\n\treturn out", "response": "Takes in text and errorCorrection ( letter returns 2D array of the QR code"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_args(args, cfg):\n    prog = pathlib.Path(sys.argv[0]).parts[-1].replace('.py', '')\n    prog_version = \"%%(prog)s %s\" % versionner.__version__\n\n    # pylint: disable=invalid-name\n    p = argparse.ArgumentParser(prog=prog, description='Helps manipulating version of the project')\n    p.add_argument('--file', '-f', dest='version_file', type=str,\n        default=cfg.version_file,\n        help=\"path to file where version is saved\")\n    p.add_argument('--version', '-v', action=\"version\", version=prog_version)\n    p.add_argument('--date-format', type=str,\n        default=cfg.date_format,\n        help=\"Date format used in project files\")\n    p.add_argument('--verbose', action=\"store_true\",\n        help=\"Be more verbose if it's possible\")\n\n    sub = p.add_subparsers(dest='command')\n\n    p_init = sub.add_parser('init', aliases=commands.get_aliases_for('init'),\n        help=\"Create new version file\")\n    p_init.add_argument('value', nargs='?', type=str,\n        default=cfg.default_init_version,\n        help=\"Initial version\")\n    p_init.add_argument('--vcs-engine', type=str,\n        default=cfg.vcs_engine,\n        help=\"Select VCS engine (only git is supported currently)\", )\n    p_init.add_argument('--vcs-commit-message', '-m', type=str,\n        default=cfg.vcs_commit_message,\n        help=\"Commit message used when committing changes\")\n    p_init.add_argument('--commit', '-c', action='store_true',\n        help=\"Commit changes done by `up` command (only if there is no changes in repo before)\")\n\n    p_up = sub.add_parser('up', aliases=commands.get_aliases_for('up'),\n        help=\"Increase version\")\n    p_up.add_argument('--vcs-engine', type=str,\n        default=cfg.vcs_engine,\n        help=\"Select VCS engine (only git is supported currently)\", )\n    p_up.add_argument('--vcs-commit-message', '-m', type=str,\n        default=cfg.vcs_commit_message,\n        help=\"Commit message used when committing changes\")\n    p_up.add_argument('--commit', '-c', action='store_true',\n        help=\"Commit changes done by `up` command (only if there is no changes in repo before)\")\n    p_up.add_argument('value', nargs='?', type=int,\n        default=cfg.default_increase_value,\n        help=\"Increase version by this value (default: %d)\" % cfg.default_increase_value)\n\n    p_up_gr = p_up.add_mutually_exclusive_group()\n    p_up_gr.add_argument('--major', '-j', action=\"store_true\",\n        help=\"increase major part of version\" + (\" (project default)\" if cfg.up_part == 'major' else \"\"))\n    p_up_gr.add_argument('--minor', '-n', action=\"store_true\",\n        help=\"increase minor part of version\" + (\" (project default)\" if cfg.up_part == 'minor' else \"\"))\n    p_up_gr.add_argument('--patch', '-p', action=\"store_true\",\n        help=\"increase patch part of version\" + (\" (project default)\" if cfg.up_part == 'patch' else \"\"))\n\n    p_set = sub.add_parser('set', aliases=commands.get_aliases_for('set'),\n        help=\"Set version to specified one\")\n    p_set.add_argument('--major', '-j', type=int,\n        help=\"set major part of version to MAJOR\")\n    p_set.add_argument('--minor', '-n', type=int,\n        help=\"set minor part of version to MINOR\")\n    p_set.add_argument('--patch', '-p', type=int,\n        help=\"set patch part of version to PATCH\")\n    p_set.add_argument('--prerelease', '-r', type=str,\n        help=\"set prerelease part of version to PRERELEASE\")\n    p_set.add_argument('--build', '-b', type=str,\n        help=\"set build part of version to BUILD\")\n    p_set.add_argument('--vcs-engine', type=str,\n        default=cfg.vcs_engine,\n        help=\"Select VCS engine (only git is supported currently)\", )\n    p_set.add_argument('--vcs-commit-message', '-m', type=str,\n        default=cfg.vcs_commit_message,\n        help=\"Commit message used when committing changes\")\n    p_set.add_argument('--commit', '-c', action='store_true',\n        help=\"Commit changes done by `set` command (only if there is no changes in repo before)\")\n    p_set.add_argument('value', nargs='?', type=str,\n        help=\"set version to this value\")\n\n    p_tag = sub.add_parser('tag', aliases=commands.get_aliases_for('tag'),\n        help=\"Create VCS tag with current version\")\n    p_tag.add_argument('--vcs-tag-param', dest='vcs_tag_params', type=str, action=\"append\",\n        help=\"Additional params for VCS for \\\"tag\\\" command\")\n\n    sub.add_parser('read', aliases=commands.get_aliases_for('read'),\n        help=\"Read current version\")\n\n    args = p.parse_args(args)\n\n    cfg.command = args.command\n    cfg.version_file = pathlib.Path(args.version_file).absolute()\n    cfg.date_format = args.date_format\n    cfg.verbose = args.verbose\n\n    version_file_requirement = 'doesn\\'t matter'\n    if cfg.command == 'init':\n        version_file_requirement = 'none'\n\n        cfg.commit = args.commit\n        cfg.vcs_engine = args.vcs_engine\n        cfg.vcs_commit_message = args.vcs_commit_message\n        cfg.value = args.value\n\n    elif cfg.command == 'up':\n        version_file_requirement = 'required'\n\n        cfg.commit = args.commit\n        cfg.vcs_engine = args.vcs_engine\n        cfg.vcs_commit_message = args.vcs_commit_message\n        cfg.value = args.value\n        if args.major:\n            cfg.up_part = 'major'\n        elif args.minor:\n            cfg.up_part = 'minor'\n        elif args.patch:\n            cfg.up_part = 'patch'\n\n    elif cfg.command == 'set':\n        version_file_requirement = 'required'\n\n        cfg.commit = args.commit\n        cfg.vcs_engine = args.vcs_engine\n        cfg.vcs_commit_message = args.vcs_commit_message\n\n        if args.value:\n            cfg.value = args.value\n        else:\n            cfg.value = (\n                args.major, args.minor, args.patch,\n                args.prerelease, args.build\n            )\n\n            if all(value is None for value in cfg.value):\n                p.error(\"Version is not specified\")\n\n    elif cfg.command == 'tag':\n        version_file_requirement = 'required'\n\n        cfg.vcs_tag_params = args.vcs_tag_params or []\n\n    elif cfg.command is None:\n        cfg.command = 'read'\n        version_file_requirement = 'required'\n\n    if version_file_requirement == 'required':\n        if not cfg.version_file.exists():\n            p.error(\"Version file \\\"%s\\\" doesn't exists\" % cfg.version_file)\n    elif version_file_requirement == 'none':\n        if cfg.version_file.exists():\n            p.error(\"Version file \\\"%s\\\" already exists\" % cfg.version_file)", "response": "Parse command line arguments of script."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds path to project - wide config file.", "response": "def _find_project_config_file(user_config_file):\n    \"\"\"Find path to project-wide config file\n    Search from current working directory, and traverse path up to\n    directory with .versionner.rc file or root directory\n\n    :param user_config_file: instance with user-wide config path\n    :type: pathlib.Path\n    :rtype: pathlib.Path\n    \"\"\"\n    proj_cfg_dir = pathlib.Path('.').absolute()\n    proj_cfg_file = None\n    root = pathlib.Path('/')\n    while proj_cfg_dir != root:\n        proj_cfg_file = proj_cfg_dir / defaults.RC_FILENAME\n        if proj_cfg_file.exists():\n            break\n\n        proj_cfg_file = None\n        # pylint: disable=redefined-variable-type\n        proj_cfg_dir = proj_cfg_dir.parent\n\n    if proj_cfg_file and proj_cfg_file != user_config_file:\n        return proj_cfg_file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexecute whole program :param prog: program name :param argv: list: script arguments :return:", "response": "def execute(prog, argv):\n    \"\"\"Execute whole program\n\n    :param prog: program name\n    :param argv: list: script arguments\n    :return:\n    \"\"\"\n    if pathlib.Path(prog).parts[-1] in ('versionner', 'versionner.py'):\n        print(\"versionner name is deprecated, use \\\"ver\\\" now!\", file=sys.stderr)\n\n    cfg_files = [\n        pathlib.Path(os.path.expanduser('~')) / defaults.RC_FILENAME,\n    ]\n    proj_cfg_file = _find_project_config_file(cfg_files[0])\n    if proj_cfg_file:\n        cfg_files.append(proj_cfg_file)\n\n    cfg = config.Config(cfg_files)\n    parse_args(argv, cfg)\n\n    cmd = commands.get(cfg.command, cfg)\n\n    try:\n        result = cmd.execute()\n    except VersionnerError as exc:\n        print('%s: %s' % (exc.__class__.__name__, exc), file=sys.stderr)\n        return exc.ret_code\n\n    print(\"Current version: %s\" % (result.current_version, ))\n\n    if result.modified_files:\n        print('Changed' + (' and committed' if cfg.commit else '') + ' %(files)s files (%(changes)s changes)' % {\n            'files': result.modified_files,\n            'changes': result.modifications,\n        })\n\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_deploy_website(restart_apache=False, restart_uwsgi=False,\n                       restart_nginx=False):\n    \"\"\"\n    Executes all tasks necessary to deploy the website on the given server.\n\n    Usage::\n\n        fab <server> run_deploy_website\n\n    \"\"\"\n    run_git_pull()\n    run_pip_install()\n    run_rsync_project()\n    run_syncdb()\n    run_collectstatic()\n    if getattr(settings, 'MAKEMESSAGES_ON_DEPLOYMENT', False):\n        run_makemessages()\n    if getattr(settings, 'COMPILEMESSAGES_ON_DEPLOYMENT', False):\n        run_compilemessages()\n    if restart_apache:\n        run_restart_apache()\n    if restart_uwsgi:\n        run_restart_uwsgi()\n    if restart_nginx:\n        run_restart_nginx()\n    else:\n        run_touch_wsgi()", "response": "This function executes all the tasks necessary to deploy the website on the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_download_media(filename=None):\n    if not filename:\n        filename = settings.MEDIA_DUMP_FILENAME\n    if env.key_filename:\n        ssh = settings.PROJECT_NAME\n    else:\n        ssh = '{0}@{1}'.format(env.user, env.host_string)\n    local('scp {0}:{1}{2} .'.format(\n        ssh, settings.FAB_SETTING('SERVER_MEDIA_BACKUP_DIR'), filename))", "response": "Downloads the media dump from the server into your local machine."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexport the database on the server.", "response": "def run_export_db(filename=None):\n    \"\"\"\n    Exports the database on the server.\n\n    Usage::\n\n        fab prod run_export_db\n        fab prod run_export_db:filename=foobar.dump\n\n    \"\"\"\n    if not filename:\n        filename = settings.DB_DUMP_FILENAME\n    with cd(settings.FAB_SETTING('SERVER_PROJECT_ROOT')):\n        run_workon('fab export_db:remote=True,filename={}'.format(filename))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexports the media folder on the server.", "response": "def run_export_media(filename=None):\n    \"\"\"\n    Exports the media folder on the server.\n\n    Usage::\n\n        fab prod run_export_media\n        fab prod run_export_media:filename=foobar.tar.gz\n\n    \"\"\"\n    if not filename:\n        filename = settings.MEDIA_DUMP_FILENAME\n\n    with cd(settings.FAB_SETTING('SERVER_MEDIA_ROOT')):\n        run('rm -rf {0}'.format(filename))\n        run('tar -czf {0} *'.format(filename))\n        run('mv {0} {1}'.format(\n            filename, settings.FAB_SETTING('SERVER_MEDIA_BACKUP_DIR')))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns pip install on the given server.", "response": "def run_pip_install(upgrade=0):\n    \"\"\"\n    Installs the requirement.txt file on the given server.\n\n    Usage::\n\n        fab <server> run_pip_install\n        fab <server> run_pip_install:upgrade=1\n\n    :param upgrade: If set to 1, the command will be executed with the\n      ``--upgrade`` flag.\n\n    \"\"\"\n    command = 'pip install -r {0}'.format(\n        settings.FAB_SETTING('SERVER_REQUIREMENTS_PATH'))\n    if upgrade:\n        command += ' --upgrade'\n    run_workon(command)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns rsync on the project", "response": "def run_rsync_project():\n    \"\"\"\n    Copies the project from the git repository to it's destination folder.\n\n    This has the nice side effect of rsync deleting all ``.pyc`` files and\n    removing other files that might have been left behind by sys admins messing\n    around on the server.\n\n    Usage::\n\n        fab <server> run_rsync_project\n\n    \"\"\"\n    excludes = ''\n    for exclude in settings.RSYNC_EXCLUDES:\n        excludes += \" --exclude '{0}'\".format(exclude)\n    command = \"rsync -avz --stats --delete {0} {1} {2}\".format(\n        excludes, settings.FAB_SETTING('SERVER_REPO_PROJECT_ROOT'),\n        settings.FAB_SETTING('SERVER_APP_ROOT'))\n    run(command)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_syncdb():\n    with cd(settings.FAB_SETTING('SERVER_PROJECT_ROOT')):\n        if StrictVersion(django.get_version()) < StrictVersion('1.7'):\n            run_workon('python{} manage.py syncdb --migrate --noinput'.format(\n                PYTHON_VERSION))\n        else:\n            run_workon('python{} manage.py migrate'.format(PYTHON_VERSION))", "response": "Runs the syncdb command on the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_upload_db(filename=None):\n    if not filename:\n        filename = settings.DB_DUMP_FILENAME\n    if env.key_filename:\n        ssh = settings.PROJECT_NAME\n    else:\n        ssh = '{0}@{1}'.format(env.user, env.host_string)\n    local('scp {0} {1}:{3}'.format(\n        filename, ssh, settings.FAB_SETTING('SERVER_DB_BACKUP_DIR')))", "response": "Uploads your local database to the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nderiving a PEP386 - compliant version number from VERSION.", "response": "def get_version(version=None):\n    \"\"\"Derives a PEP386-compliant version number from VERSION.\"\"\"\n    if version is None:\n        version = VERSION\n    assert len(version) == 5\n    assert version[3] in ('alpha', 'beta', 'rc', 'final')\n\n    # Now build the two parts of the version number:\n    # main = X.Y[.Z]\n    # sub = .devN - for pre-alpha releases\n    #     | {a|b|c}N - for alpha, beta and rc releases\n\n    parts = 2 if version[2] == 0 else 3\n    main = '.'.join(str(x) for x in version[:parts])\n\n    sub = ''\n    if version[3] == 'alpha' and version[4] == 0:\n        # At the toplevel, this would cause an import loop.\n        from django.utils.version import get_svn_revision\n        svn_revision = get_svn_revision()[4:]\n        if svn_revision != 'unknown':\n            sub = '.dev%s' % svn_revision\n\n    elif version[3] != 'final':\n        mapping = {'alpha': 'a', 'beta': 'b', 'rc': 'c'}\n        sub = mapping[version[3]] + str(version[4])\n\n    return main + sub"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setRedYellowGreenState(self, tlsID, state):\n        self._connection._sendStringCmd(\n            tc.CMD_SET_TL_VARIABLE, tc.TL_RED_YELLOW_GREEN_STATE, tlsID, state)", "response": "Sets the red yellow green state of the named tl."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setLinkState(self, tlsID, tlsLinkIndex, state):\n        fullState = list(self.getRedYellowGreenState(tlsID))\n        if tlsLinkIndex >= len(fullState):\n            raise TraCIException(None, None, \"Invalid tlsLinkIndex %s for tls '%s' with maximum index %s.\" % (\n                tlsLinkIndex, tlsID, len(fullState) - 1))\n        else:\n            fullState[tlsLinkIndex] = state\n            self.setRedYellowGreenState(tlsID, ''.join(fullState))", "response": "Sets the state of the given junctino and link index."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the index of the current phase of the given TlsID.", "response": "def setPhase(self, tlsID, index):\n        \"\"\"setPhase(string, integer) -> None\n\n        .\n        \"\"\"\n        self._connection._sendIntCmd(\n            tc.CMD_SET_TL_VARIABLE, tc.TL_PHASE_INDEX, tlsID, index)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the id of the current program.", "response": "def setProgram(self, tlsID, programID):\n        \"\"\"setProgram(string, string) -> None\n\n        Sets the id of the current program.\n        \"\"\"\n        self._connection._sendStringCmd(\n            tc.CMD_SET_TL_VARIABLE, tc.TL_PROGRAM, tlsID, programID)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the phase duration of the current phase in seconds.", "response": "def setPhaseDuration(self, tlsID, phaseDuration):\n        \"\"\"setPhaseDuration(string, integer or float) -> None\n\n        Set the phase duration of the current phase in seconds.\n        \"\"\"\n        self._connection._sendIntCmd(\n            tc.CMD_SET_TL_VARIABLE, tc.TL_PHASE_DURATION, tlsID, int(1000 * phaseDuration))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setCompleteRedYellowGreenDefinition(self, tlsID, tls):\n        length = 1 + 4 + 1 + 4 + \\\n            len(tls._subID) + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 4  # tls parameter\n        itemNo = 1 + 1 + 1 + 1 + 1\n        for p in tls._phases:\n            length += 1 + 4 + 1 + 4 + 1 + 4 + 1 + 4 + len(p._phaseDef)\n            itemNo += 4\n        self._connection._beginMessage(\n            tc.CMD_SET_TL_VARIABLE, tc.TL_COMPLETE_PROGRAM_RYG, tlsID, length)\n        self._connection._string += struct.pack(\"!Bi\",\n                                                tc.TYPE_COMPOUND, itemNo)\n        # programID\n        self._connection._packString(tls._subID)\n        # type\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_INTEGER, 0)\n        # subitems\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 0)\n        # index\n        self._connection._string += struct.pack(\"!Bi\",\n                                                tc.TYPE_INTEGER, tls._currentPhaseIndex)\n        # phaseNo\n        self._connection._string += struct.pack(\"!Bi\",\n                                                tc.TYPE_INTEGER, len(tls._phases))\n        for p in tls._phases:\n            self._connection._string += struct.pack(\"!BiBiBi\", tc.TYPE_INTEGER,\n                                                    p._duration, tc.TYPE_INTEGER, p._duration1, tc.TYPE_INTEGER, p._duration2)\n            self._connection._packString(p._phaseDef)\n        self._connection._sendExact()", "response": "This method sets the complete red yellow green definition for the specified time series."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register_service(email, password, organisation_id, name=None,\n                     service_type=None, accounts_url=None,\n                     location=None, config=None):\n    \"\"\"Register a service with the accounts service\n\n    \\b\n    EMAIL: a user's email\n    PASSWORD: a user's password\n    ORGANISATION_ID: ID of the service's parent organisation\n    \"\"\"\n    accounts_url = accounts_url or getattr(options, 'url_accounts', None)\n    name = name or getattr(options, 'name', None)\n    service_type = service_type or getattr(options, 'service_type', None)\n    location = location or ('https://localhost:' + str(getattr(options, 'port')))\n    config = config or 'config'\n\n    if not accounts_url:\n        raise click.ClickException(click.style('accounts_url not defined',\n                                               fg='red'))\n\n    if not name:\n        raise click.ClickException(click.style('service name not defined',\n                                               fg='red'))\n\n    if not service_type:\n        raise click.ClickException(click.style('service type not defined',\n                                               fg='red'))\n\n    try:\n        client = _get_accounts_client(accounts_url, email, password)\n        service_id = _create_service(client, organisation_id, name, location, service_type)\n        client_secret = _get_client_secret(client, service_id)\n        _update_local_conf(config, service_id, client_secret)\n    except httpclient.HTTPError as exc:\n        try:\n            msg = exc.response.body\n        except AttributeError:\n            msg = exc.message\n        raise click.ClickException(click.style(msg, fg='red'))\n    except socket.error as exc:\n        raise click.ClickException(click.style(exc.strerror, fg='red'))\n\n    click.echo(click.style('\\n{} service registered\\n'.format(name),\n                           fg='green'))", "response": "Register a new service with the accounts service"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_accounts_client(accounts_url, email, password):\n    client = API(accounts_url, async=False, validate_cert=False)\n    try:\n        response = client.accounts.login.post(email=email, password=password)\n        client.default_headers['Authorization'] = response['data']['token']\n        return client\n    except httpclient.HTTPError:\n        msg = ('There was a problem logging into the accounts service.'\n               ' Please check your email and password.')\n        raise click.ClickException(click.style(msg, fg='red'))", "response": "Create an Accounts Service API client and log in using provided email and password."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_service(client, organisation_id, name, location, service_type):\n    try:\n        response = client.accounts.organisations[organisation_id].services.post(\n            name=name, location=location, service_type=service_type)\n        service_id = response['data']['id']\n    except httpclient.HTTPError as exc:\n        if exc.code == 404:\n            # If error is a 404 then this means the organisation_id is not recognised. Raise this error immediately\n            msg = ('Organisation {} cannot be found. '\n                   'Please check organisation_id.'.format(organisation_id))\n            raise click.ClickException(click.style(msg, fg='red'))\n        else:\n            service_id = _get_service(client, organisation_id, name)\n            # If cannot find existing service, raise original error\n            if not service_id:\n                raise exc\n\n    return service_id", "response": "Create a new service with given details."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_service(client, organisation_id, name):\n    try:\n        response = client.accounts.services.get(organisation_id=organisation_id)\n    except httpclient.HTTPError as exc:\n        if exc.code == 404:\n            # If error is a 404 then this means the organisation_id is not recognised. Raise this error immediately\n            msg = ('Organisation {} cannot be found. '\n                   'Please check organisation_id.'.format(organisation_id))\n            raise click.ClickException(click.style(msg, fg='red'))\n        else:\n            raise exc\n\n    services = [s for s in response['data'] if s['name'] == name]\n\n    if services:\n        return services[0]['id']\n    return None", "response": "Get a service from the given organisation_id and name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting client secret for a service.", "response": "def _get_client_secret(client, service_id):\n    \"\"\"\n    Get client secret for service\n    :param client: Accounts Service API Client\n    :param service_id: Service ID\n    :return: Client secret (if available)\n    \"\"\"\n    try:\n        response = client.accounts.services[service_id].secrets.get()\n    except httpclient.HTTPError as exc:\n        if exc.code == 404:\n            # If error is a 404 then this means the service_id is not recognised. Raise this error immediately\n            msg = ('Service {} cannot be found.'.format(service_id))\n            raise click.ClickException(click.style(msg, fg='red'))\n        else:\n            raise exc\n\n    client_secrets = response['data']\n    if client_secrets:\n        return client_secrets[0]\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _update_local_conf(config, service_id, client_secret):\n    lines = _get_existing_conf(config)\n    lines.append('\\nservice_id = \"{}\"\\n'.format(service_id))\n    if client_secret:\n        lines.append('client_secret = \"{}\"\\n'.format(client_secret))\n\n    with open(os.path.join(config, 'local.conf'), 'w') as f:\n        f.writelines(lines)", "response": "Update local. conf with service id and client secret"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread existing local. conf and strip out service id and client secret", "response": "def _get_existing_conf(config):\n    \"\"\"\n    Read existing local.conf and strip out service id and client secret\n    :param config: Location of config files\n    :param lines of existing config (excluding service id and client secret)\n    \"\"\"\n    try:\n        with open(os.path.join(config, 'local.conf'), 'r') as f:\n            lines = [line for line in f.readlines()\n                     if not (line.startswith('service_id') or line.startswith('client_secret'))]\n    except IOError:\n        lines = []\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _options():\n    opts = sys.argv[1:]\n    return [click.Option((v.split('=')[0],)) for v in opts\n            if v[0] == '-' and v != '--help']", "response": "Collect all command line options"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(func):\n\n    @defaults.command(help='Run the service')\n    @click.pass_context\n    def runserver(ctx, *args, **kwargs):\n        if (ctx.parent.invoked_subcommand and\n                ctx.command.name != ctx.parent.invoked_subcommand):\n            return\n\n        # work around the fact that tornado's parse_command_line can't\n        # cope with having subcommands / positional arguments.\n        sys.argv = [sys.argv[0]] + [a for a in sys.argv if a[0] == '-']\n\n        sys.exit(func())\n\n    return runserver", "response": "Execute the provided function if there are no subcommands"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cli(main, conf_dir=None, commands_dir=None):\n    return Command(main, conf_dir=conf_dir, commands_dir=commands_dir)()", "response": "Convenience function for initialising a Command object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_commands(self, ctx):\n        rv = defaults.list_commands(ctx)\n        if self._commands_dir:\n            for filename in os.listdir(self._commands_dir):\n                if _is_command_file(filename) and filename[:-3] not in rv:\n                    rv.append(filename[:-3])\n            rv.sort()\n        return rv", "response": "List commands from the commands dir and default group"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_command(self, ctx, name):\n        if not self._commands_dir:\n            return defaults.get_command(ctx, name)\n\n        ns = {}\n        fn = os.path.join(self._commands_dir, name + '.py')\n\n        try:\n            with open(fn) as f:\n                code = compile(f.read(), fn, 'exec')\n        except IOError:\n            return defaults.get_command(ctx, name)\n\n        eval(code, ns, ns)\n\n        CLI = 'cli'\n\n        try:\n            return ns[CLI]\n        except KeyError:\n            ctx.fail('`{}` not defined in \"{}\"'.format(CLI, name))", "response": "Get the command from either the commands dir or the default group"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if there is a dict in a dict and if so update the dict with the response", "response": "def _check_for_inception(self, root_dict):\n        '''\n        Used to check if there is a dict in a dict\n        '''\n\n        for key, value in root_dict.items():\n            if isinstance(value, dict):\n                root_dict[key] = Response(value)\n\n        return root_dict"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef main(args, stop=False):\n    if not stop and not os.path.exists(args.filename):\n        sys.stderr.write(\"'%s' doesn't exists!\\n\" % args.filename)\n        sys.exit(1)\n\n    daemon = FTPMonitorDaemon(\n        con_param=getConParams(\n            settings.RABBITMQ_FTP_VIRTUALHOST\n        ),\n        queue=settings.RABBITMQ_FTP_INPUT_QUEUE,\n        out_exch=settings.RABBITMQ_FTP_EXCHANGE,\n        out_key=settings.RABBITMQ_FTP_OUTPUT_KEY,\n        react_fn=None,\n        glob=globals(),               # used in deserializer\n        fn=args.filename if not stop else \"\"\n    )\n\n    if not stop and args.foreground:  # run at foreground\n        daemon.run()\n    else:\n        daemon.run_daemon()", "response": "Main function for FTPMonitorDaemon."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef body(self):\n        self.connection = pika.BlockingConnection(self.connection_param)\n        self.channel = self.connection.channel()\n\n        print \"Monitoring file '%s'.\" % self.ftp_extended_log\n\n        file_iter = process_log(\n            sh.tail(\"-f\", self.ftp_extended_log, _iter=True)\n        )\n        for import_request in file_iter:\n            self.sendMessage(\n                exchange=self.output_exchange,\n                routing_key=self.output_key,\n                message=serializers.serialize(import_request),\n                UUID=str(uuid.uuid1())\n            )", "response": "This method handles the connection details and reacts to FTP events by sending messages to output queue."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef default_roles(*role_list):\n    def selectively_attach(func):\n        \"\"\"Only decorate if nothing specified on command line\"\"\"\n        # pylint: disable=W0142\n        if not env.roles and not env.hosts:\n            return roles(*role_list)(func)\n        else:\n            if env.hosts:\n                func = hosts(*env.hosts)(func)\n            if env.roles:\n                func = roles(*env.roles)(func)\n            return func\n    return selectively_attach", "response": "Decorate task with these roles by default but override with - R - H"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef chput(local_path=None, remote_path=None, user=None, group=None,\n          mode=None, use_sudo=True, mirror_local_mode=False, check=True):\n    \"\"\"Put file and set user and group ownership.  Default to use sudo.\"\"\"\n    # pylint: disable=R0913\n    result = None\n    if env.get('full') or not check or diff(local_path, remote_path):\n        result = put(local_path, remote_path, use_sudo,\n                     mirror_local_mode, mode)\n    with hide('commands'):\n        chown(remote_path, user, group)\n    return result", "response": "Put file and set user and group ownership. Default to use sudo."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cron(name, timespec, user, command, environ=None, disable=False):\n    path = '/etc/cron.d/{}'.format(name)\n    if disable:\n        sudo('rm ' + path)\n        return\n    entry = '{}\\t{}\\t{}\\n'.format(timespec, user, command)\n    if environ:\n        envstr = '\\n'.join('{}={}'.format(k, v)\n                           for k, v in environ.iteritems())\n        entry = '{}\\n{}'.format(envstr, entry)\n    chput(StringIO(entry), path, use_sudo=True,\n          mode=0o644, user='root', group='root')", "response": "Create a new entry in the cron. d directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef diff(local_path, remote_path):\n    with hide('commands'):\n        if isinstance(local_path, basestring):\n            with open(local_path) as stream:\n                local_content = stream.read()\n        else:\n            pos = local_path.tell()\n            local_content = local_path.read()\n            local_path.seek(pos)\n        remote_content = StringIO()\n        with settings(hide('warnings'), warn_only=True):\n            if get(remote_path, remote_content).failed:\n                return True\n        return local_content.strip() != remote_content.getvalue().strip()", "response": "Return true if local and remote paths differ in contents"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef md5sum(filename, use_sudo=False):\n    runner = sudo if use_sudo else run\n    with hide('commands'):\n        return runner(\"md5sum '{}'\".format(filename)).split()[0]", "response": "Return md5sum of remote file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a directory with sudo and octal mode then set ownership.", "response": "def mkdir(dirs, user=None, group=None, mode=None, use_sudo=True):\n    \"\"\"Create directory with sudo and octal mode, then set ownership.\"\"\"\n    if isinstance(dirs, basestring):\n        dirs = [dirs]\n    runner = sudo if use_sudo else run\n    if dirs:\n        modearg = '-m {:o}'.format(mode) if mode else ''\n        cmd = 'mkdir -v -p {} {}'.format(modearg, ' '.join(dirs))\n        result = runner(cmd)\n        with hide('commands'):\n            chown(dirs, user, group)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rsync(local_path, remote_path, exclude=None, extra_opts=None):\n    if not local_path.endswith('/'):\n        local_path += '/'\n    exclude = exclude or []\n    exclude.extend(['*.egg-info', '*.pyc', '.git', '.gitignore',\n                    '.gitmodules', '/build/', '/dist/'])\n    with hide('running'):\n        run(\"mkdir -p '{}'\".format(remote_path))\n        return rsync_project(\n            remote_path, local_path, delete=True,\n            extra_opts='-i --omit-dir-times -FF ' +\n                       (extra_opts if extra_opts else ''),\n            ssh_opts='-o StrictHostKeyChecking=no',\n            exclude=exclude)", "response": "rsync a local file to remote_path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nputting a file to remote and remove it afterwards", "response": "def tempput(local_path=None, remote_path=None, use_sudo=False,\n            mirror_local_mode=False, mode=None):\n    \"\"\"Put a file to remote and remove it afterwards\"\"\"\n    import warnings\n    warnings.simplefilter('ignore', RuntimeWarning)\n    if remote_path is None:\n        remote_path = os.tempnam()\n    put(local_path, remote_path, use_sudo, mirror_local_mode, mode)\n    yield remote_path\n    run(\"rm '{}'\".format(remote_path))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef watch(filenames, callback, use_sudo=False):\n    filenames = [filenames] if isinstance(filenames, basestring) else filenames\n    old_md5 = {fn: md5sum(fn, use_sudo) for fn in filenames}\n    yield\n    for filename in filenames:\n        if md5sum(filename, use_sudo) != old_md5[filename]:\n            callback()\n            return", "response": "Yields a generator that yields when any of the filenames change during the context."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving package and map config set selections", "response": "def debconf_set_selections(package, selections):\n    \"\"\"Given package and map config:(type,value), set selections\"\"\"\n    text = '\\n'.join(' '.join([package, k, t, v]) for\n                     k, (t, v) in selections.iteritems())\n    sudo('debconf-set-selections <<-HEREDOC\\n{}\\nHEREDOC'.format(text))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninstalls package from custom deb hosted on S3. Returns True if package was installed by this invocation.", "response": "def install_deb(pkgname, url):\n    \"\"\"Install package from custom deb hosted on S3.\n    Return true if package was installed by this invocation.\"\"\"\n    status = run(\"dpkg-query -W -f='${{Status}}' {p}; true\".format(p=pkgname))\n    if ('installed' not in status) or ('not-installed' in status):\n        deb = url.rpartition('/')[2]\n        debtmp = '/tmp/{}'.format(deb)\n        run(\"wget --no-check-certificate -qc -O '{}' '{}'\".format(debtmp, url))\n        sudo(\"dpkg -i '{0}' && rm -f '{0}'\".format(debtmp))\n        return True\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef package_ensure_apt(*packages):\n    package = \" \".join(packages)\n    status = run(\"dpkg-query -W -f='${{Status}} ' {p}; true\".format(p=package))\n    status = status.lower()\n    if 'no packages found' in status or 'not-installed' in status:\n        sudo(\"apt-get --yes install \" + package)\n        return False\n    else:\n        return True", "response": "Ensure apt packages are installed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_apt(days=3, upgrade=False):\n    # Check the apt-get update timestamp (works on Ubuntu only)\n    with settings(warn_only=True):\n        last_update = run(\n            \"stat -c %Y /var/lib/apt/periodic/update-success-stamp\")\n    if ('cannot stat' in last_update\n            or (time.time() - float(last_update)) > days * 86400):\n        sudo(\"apt-get --yes update\")\n        if upgrade:\n            sudo(\"apt-get --yes upgrade\")", "response": "Update apt index if not update in last N days"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild git version string for current directory", "response": "def make_version(ref=None):\n    \"\"\"Build git version string for current directory\"\"\"\n    cmd = 'git describe --tags --abbrev=6 {}'.format(ref or '')\n    with hide('commands'):\n        version = local(cmd, capture=True).strip()\n    if re.match('^v[0-9]', version):\n        version = version[1:]\n    # replacements to match semver.org build numbers\n    if '-' in version:\n        head, _, tail = version.partition('-')\n        count, _, sha = tail.partition('-g')\n        version = head + '+' + count + '-' + sha\n    return version"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tagversion(repo, level='patch', special=''):\n    prepend = 'v'\n    with lcd(repo):\n        oldversion = local(\n            'git describe --abbrev=0 --tags', capture=True).strip()\n        if oldversion.startswith('v'):\n            oldversion = oldversion[1:]\n        else:\n            prepend = ''\n    major, minor, patch = [int(x) for x in re.split('\\D', oldversion, 3)[:3]]\n    if special:\n        if not re.match('^[a-z]', special):\n            raise ValueError('Special must start with a-z')\n        if not re.match('[_a-zA-Z0-9]+', special):\n            raise ValueError('Must contain start with lowercase letter')\n    if level == 'major':\n        major, minor, patch = major + 1, 0, 0\n    elif level == 'minor':\n        major, minor, patch = major, minor + 1, 0\n    elif level == 'patch':\n        major, minor, patch = major, minor, patch + 1\n    version_string = '{}.{}.{}'.format(major, minor, patch) + special\n    with lcd(repo):\n        local('git tag -s --force {}{}'.format(prepend, version_string))\n    return version_string", "response": "Increment and return tagged version in git."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates version file using git desribe", "response": "def write_version(path, ref=None):\n    \"\"\"Update version file using git desribe\"\"\"\n    with lcd(dirname(path)):\n        version = make_version(ref)\n    if (env.get('full') or not os.path.exists(path)\n            or version != open(path).read().strip()):\n        with open(path, 'w') as out:\n            out.write(version + '\\n')\n    return version"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef splunk(cmd, user='admin', passwd='changeme'):\n    return sudo('/opt/splunkforwarder/bin/splunk {c} -auth {u}:{p}'\n                .format(c=cmd, u=user, p=passwd))", "response": "Authenticated call to splunk"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef splunk_monitor(monitors):\n    if not exists('/opt/splunkforwarder'):\n        return\n    if not env.get('splunk_monitors'):\n        with hide('commands'):\n            env['splunk_monitors'] = str(splunk('list monitor'))\n    for path, sourcetype in monitors:\n        if path not in env['splunk_monitors']:\n            with hide('everything'):\n                run(\"touch '{path}'; true\".format(path=path))\n            splunk(\"add monitor '{path}' -sourcetype {st}\".format(\n                path=path, st=sourcetype))\n            env['splunk_monitors'] += '\\n' + path", "response": "Monitor a list of path pairs in splunk"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bilinear_interpolation(x, y, points):\r\n    '''Interpolate (x,y) from values associated with four points.\r\n\r\n    The four points are a list of four triplets:  (x, y, value).\r\n    The four points can be in any order.  They should form a rectangle.\r\n\r\n        >>> bilinear_interpolation(12, 5.5,\r\n        ...                        [(10, 4, 100),\r\n        ...                         (20, 4, 200),\r\n        ...                         (10, 6, 150),\r\n        ...                         (20, 6, 300)])\r\n        165.0\r\n        \r\n        @note : source -> http://stackoverflow.com/questions/8661537/how-to-perform-bilinear-interpolation-in-python\r\n    '''\r\n    # See formula at:  http://en.wikipedia.org/wiki/Bilinear_interpolation\r\n\r\n    points = sorted(points)               # order points by x, then by y\r\n    (x1, y1, q11), (_x1, y2, q12), (x2, _y1, q21), (_x2, _y2, q22) = points\r\n\r\n#    if x1 != _x1 or x2 != _x2 or y1 != _y1 or y2 != _y2:\r\n#        raise ValueError('points do not form a rectangle')\r\n#    if not x1 <= x <= x2 or not y1 <= y <= y2:\r\n#        raise ValueError('(x, y) not within the rectangle')\r\n\r\n    try :\r\n        if x1 != _x1 or x2 != _x2 or y1 != _y1 or y2 != _y2:\r\n            raise ValueError('points do not form a rectangle')\r\n        if not x1 <= x <= x2 or not y1 <= y <= y2:\r\n            raise ValueError('(x, y) not within the rectangle')\r\n        return (q11 * (x2 - x) * (y2 - y) +\r\n            q21 * (x - x1) * (y2 - y) +\r\n            q12 * (x2 - x) * (y - y1) +\r\n            q22 * (x - x1) * (y - y1)\r\n           ) / ((x2 - x1) * (y2 - y1) + 0.0)\r\n    except ValueError : return np.nan", "response": "Interpolate x y from values associated with four points."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extrap1d(Z,mask):\r\n    Zout=Z.copy()\r\n    N=len(Zout)\r\n    ind=np.arange(N)\r\n    xout=ind[mask]\r\n    hist=(~mask).astype(int)\r\n    dhist=hist[1:]-hist[:-1]\r\n    st=ind[dhist==1]+1\r\n    if len(st) > 0 :\r\n        st=st[0]\r\n        Zout[:st]=Z[st] - (np.roll(Z,-st-1)[:st][::-1] - Z[st])\r\n    en=ind[dhist==-1]\r\n    if len(en) > 0 :\r\n        en=en[-1]\r\n        Zout[en+1:]=Z[en] - (np.roll(Z,-en)[::-1][:N-en-1] - Z[en])\r\n    return Zout", "response": "Extrapolate values from a 1D vector at its beginning and end using reversal of this array"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninterpolate values from a 1D vector at given positions.", "response": "def interp1d(x,Z,xout,spline=False,kind='linear',fill_value=np.NaN,**kwargs):\r\n    \"\"\"    \r\n    INTERP1D : Interpolate values from a 1D vector at given positions\r\n    \r\n    @param x: 1st dimension vector of size NX\r\n    \r\n    @author: Renaud DUSSURGET, LER/PAC, Ifremer La Seyne\r\n    \"\"\"\r\n\r\n    linear = not spline\r\n    \r\n    \r\n    nx=len(x)\r\n    \r\n    if linear :\r\n        \r\n        try :\r\n            f = scipy.interpolate.interp1d(x, Z, kind=kind,bounds_error=False,fill_value=fill_value,**kwargs)\r\n            Zout = f(xout)\r\n        except RuntimeError : Zout = np.repeat(np.NaN,nx)\r\n\r\n    else :\r\n        tck = scipy.interpolate.splrep(x,Z,s=0)\r\n        try : Zout = scipy.interpolate.splev(xout,tck,der=0,**kwargs)\r\n        except RuntimeError : Zout = np.repeat(np.NaN,nx)\r\n\r\n    return Zout"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef interp2d1d(x,y,Z,xout,yout,**kwargs):\r\n\r\n    gx = np.reshape(np.repeat(x,y.size),(x.size,y.size)).transpose((1,0))\r\n    gy = np.reshape(np.repeat(y,x.size),(y.size,x.size))\r\n\r\n    gxout = xout\r\n    gyout = yout\r\n    gz = Z.flatten()\r\n    \r\n    Zout=np.empty(Z.shape,dtype=Z.dtype)\r\n    \r\n#    if isinstance(Z,np.ma.masked_array):\r\n#        mask=Z.mask\r\n#        Zout=np.ma.array(Zout,mask=True)\r\n#    else : mask=np.ones(gz.shape,dtype=bool)\r\n     \r\n#    points_masked = zip(*(gx[mask].flatten(),gy[mask].flatten()))\r\n    points = zip(*(gx.flatten(),gy.flatten()))\r\n#    gz=gz[mask.flatten()]\r\n    xi = zip(*(gxout,gyout))\r\n    \r\n    try : Zout = scipy.interpolate.griddata(points, gz, xi, **kwargs)\r\n    except RuntimeError : Zout = np.NaN\r\n#    Zout = sc.interpolate.griddata(points, gz, xi, **kwargs)\r\n    return Zout", "response": "Interpolate values from a 2D matrix along a 1D trajectory and return the interpolated array."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef interp2d2d(x,y,Z,xout,yout,split_factor=1,**kwargs):\r\n    \r\n    #Queued thread\r\n    ##############\r\n    class ThreadClass(threading.Thread):\r\n        \r\n        #We override the __init__ method\r\n        def __init__(self, input_q,indices_q,result_q):\r\n            threading.Thread.__init__(self)\r\n            self.input = input_q\r\n            self.indices = indices_q\r\n            self.result = result_q\r\n        \r\n        def task(self,NaN=True):\r\n            \r\n            #grabs host from queue\r\n            inargs = self.input.get()\r\n            ind = inargs[0] #thread index\r\n            x = inargs[1]\r\n            y = inargs[2]\r\n            Z = inargs[3]\r\n            xout = inargs[4]\r\n            yout = inargs[5]\r\n            \r\n            Zout=_interp2d2d(x,y,Z,xout,yout,**kwargs)\r\n            \r\n        #    Zout = sc.interpolate.griddata(points, gz, xi, **kwargs)\r\n            \r\n            self.indices.put(ind)\r\n            self.result.put(Zout)\r\n    \r\n            del Zout\r\n            \r\n#            if verbose > 0 : print \"%s ended at time: %s\" % (self.getName(), datetime.datetime.now())\r\n        \r\n        def run(self):\r\n            \r\n                #Starts the queue\r\n                self.task()\r\n                #signals to queue job is done\r\n                self.input.task_done()\r\n       \r\n\r\n    #Setup input and output queues\r\n    input_q = Queue.Queue()\r\n    indices_q = Queue.Queue()\r\n    result_q = Queue.Queue()\r\n    \r\n    #Map the data along X axis\r\n    N_threads=split_factor**2\r\n#    over=np.ceil(cut/dx) #Overlay between each time series processed in parallel\r\n    \r\n    #Get dimensions to split matrix\r\n    nxin=x.size\r\n    nyin=y.size\r\n    nxout=xout.size\r\n    nyout=yout.size\r\n    \r\n    gx = np.reshape(np.repeat(x,nyin),(nxin,nyin))\r\n    gy = np.reshape(np.repeat(y,nxin),(nyin,nxin)).transpose((1,0))\r\n\r\n    gxout = np.reshape(np.repeat(xout,nyout),(nxout,nyout))\r\n    gyout = np.reshape(np.repeat(yout,nxout),(nyout,nxout)).transpose((1,0))\r\n    \r\n    #Map output coordinates\r\n    ind=[]\r\n    \r\n    #Map output coordinates\r\n    xsplit=[]\r\n    ysplit=[]\r\n    for i in np.arange(split_factor) : \r\n        for j in np.arange(split_factor) :\r\n            xsplit.append(i*(nxout/float(split_factor)))\r\n            xsplit.append((i+1)*(nxout/float(split_factor))-1)\r\n            ysplit.append(j*(nyout/float(split_factor)))\r\n            ysplit.append((j+1)*(nyout/float(split_factor))-1)\r\n    \r\n    #Round\r\n    xsplit=np.round(xsplit).astype(int)\r\n    ysplit=np.round(ysplit).astype(int)\r\n    \r\n    N_threads = len(xsplit)/2\r\n    \r\n    \r\n    \r\n#    th_xout=gxout[0:nxout/split_factor,0:2]\r\n#    th_yout=\r\n\r\n#    gz = Z.flatten()\r\n     \r\n#    points = zip(*(gx.flatten(),gy.flatten())) \r\n    \r\n    #spawn a pool of threads, and pass them queue instance \r\n    for i in np.arange(N_threads):\r\n        t = ThreadClass(input_q,indices_q,result_q)\r\n        t.setDaemon(True)\r\n        t.start()\r\n    \r\n    #Feed threads with data\r\n    for i in range(N_threads):\r\n        xoind=xsplit[[i*2,(i*2)+1]]\r\n        yoind=ysplit[[i*2,(i*2)+1]]\r\n        xiind=x[xout[xoind].astype(int)].astype(int)\r\n        yiind=y[yout[yoind].astype(int)].astype(int)\r\n        th_x=x[xiind[0]:xiind[1]+1]\r\n        th_y=y[yiind[0]:yiind[1]+1]\r\n        th_xo=xout[xoind[0]:xoind[1]+1]\r\n        th_yo=yout[yoind[0]:yoind[1]+1]\r\n        th_z=Z[xiind[0]:xiind[1]+1,yiind[0]:yiind[1]+1]\r\n#        input_q.put((i,np.copy(points),gz.copy(),xout[iind[i]].copy(),yout[iind[i]].copy()))\r\n        input_q.put((i,th_x,th_y,th_z,th_xo,th_yo))\r\n\r\n   \r\n#    outvar=Z.copy()\r\n#    outvar.data[:]=outvar.fill_value\r\n    \r\n#    for i in range(N_threads):\r\n#        print \"%s launched time: %s\" % (i, datetime.datetime.now())\r\n#        input_q.put((i,np.copy(points),gz.copy(),xout[iind[i]].copy(),yout[iind[i]].copy()))\r\n\r\n    \r\n\r\n    #wait on the queue until everything has been processed     \r\n    input_q.join()\r\n    \r\n    #Sort threads\r\n    tnb=[]\r\n    for i in range(N_threads) : tnb.append(indices_q.get(i))\r\n    tsort=np.argsort(tnb)\r\n    \r\n    #Get back the results for each thread in a list of results\r\n    for i in np.arange(N_threads) :\r\n        r=result_q.get(i)\r\n        if i == 0 : dum = [r]\r\n        else : dum.append(r)\r\n\r\n    #Reorder data from each thread into output matrix\r\n    for i in tsort :\r\n        if i == tsort[0] : outmat = dum[i]\r\n        else : outmat=np.ma.concatenate((outmat,dum[i]),0) if isinstance(outmat,np.ma.masked_array) else np.concatenate((outmat,dum[i]),0)\r\n    \r\n    if len(outmat) != len(outmat) :\r\n        raise '[ERROR]Output array is not coherent with input array - check array reconstruction'\r\n    return(outmat)", "response": "Interpolate a 2D matrix into another 2D matrix."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninterpolating values from a 3D matrix along a 1D trajectory and return the interpolated values.", "response": "def interp3d_core(x,y,t,Z,xout,yout,tout,**kwargs):\r\n    \"\"\"    \r\n    INTERP3D : Interpolate values from a 3D matrix along a 1D trajectory\r\n    \r\n    @param x: 1st dimension vector of size NX\r\n    @param y: 2nd dimension vector of size NY\r\n    @param t: 3rd dimension vector of size NT\r\n    \r\n    @author: Renaud DUSSURGET, LER/PAC, Ifremer La Seyne\r\n    \"\"\"\r\n    \r\n    #this below can take a very LOOOOOONG time\r\n    gx = np.reshape(np.repeat(x,y.size*t.size),(x.size,y.size,t.size))\r\n    gy = np.reshape(np.repeat(y,x.size*t.size),(y.size,x.size,t.size)).transpose((1,0,2))\r\n    gt = np.reshape(np.repeat(t,x.size*y.size),(t.size,x.size,y.size)).transpose((1,2,0))\r\n\r\n    gz = Z.flatten()\r\n     \r\n    points = zip(*(gx.flatten(),gy.flatten(),gt.flatten())) \r\n    xi = zip(*(xout,yout,tout))\r\n    \r\n    Zout = scipy.interpolate.griddata(points, gz, xi, **kwargs)\r\n    return Zout"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _process_attachments(self, email):\n        for a in email.attachments:\n            if isinstance(a, MIMEBase):\n                if not a.is_multipart():\n                    obj = {\n                        'filename': a.get_filename(),\n                        'content_type': a.get_content_type(),\n                    }\n                    if a.get('content-transfer-encoding') == 'base64':\n                        obj['content'] = a.get_payload()\n                        obj['encoded'] = True\n                    else:\n                        obj['content'] = a.get_payload(decode=True)\n                    yield obj\n            else:\n                yield {\n                    'filename': a[0],\n                    'content_type': a[2],\n                    'content': a[1],\n                }", "response": "Yields the attachments in the email. attachments list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend the specified emails.", "response": "def send_messages(self, emails):\n        \"\"\"\n        Attempt to send the specified emails.\n        \"\"\"\n        num_sent = 0\n        for e in emails:\n            html = None\n            if isinstance(e, EmailMultiAlternatives):\n                for a in e.alternatives:\n                    if a[1] == 'text/html':\n                        html = a[0]\n            r = self._connection.send(\n                from_=e.from_email,\n                to=e.to,\n                subject=e.subject,\n                text=e.body,\n                html=html,\n                cc=e.cc,\n                bcc=e.bcc,\n                attachments=list(self._process_attachments(e)),\n            )\n            if 'error' not in r:\n                num_sent += 1\n        return num_sent"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef advance(self):\n        self.cursor += 1\n        if self.cursor >= len(self.raw):\n            self.char = None\n        else:\n            self.char = self.raw[self.cursor]", "response": "Increments the cursor position."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the next character without moving the cursor.", "response": "def peek(self):\n        \"\"\"Get the next character without moving the cursor.\"\"\"\n        peek_cursor = self.cursor + 1\n        if peek_cursor >= len(self.raw):\n            return None\n        else:\n            return self.raw[peek_cursor]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef number(self):\n        number = ''\n        while self.char is not None and self.char.isdigit():\n            number += self.char\n            self.advance()\n\n        if self.char == '.':\n            number += self.char\n            self.advance()\n\n            while self.char is not None and self.char.isdigit():\n                number += self.char\n                self.advance()\n\n            token = Token(Nature.FLOAT_NUMBER, number)\n\n        else:\n            token = Token(Nature.INT_NUMBER, number)\n\n        return token", "response": "Return a multidigit int or float number."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles identifiers and reserverd keywords.", "response": "def _id(self):\n        \"\"\"Handle identifiers and reserverd keywords.\"\"\"\n        result = ''\n        while self.char is not None and (self.char.isalnum() or self.char == '_'):\n            result += self.char\n            self.advance()\n\n        token = RESERVED_KEYWORDS.get(result, Token(Nature.ID, result))\n        return token"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef next_token(self):\n        while self.char is not None:\n\n            if self.char.isspace():\n                # The current character is a whitespace\n                self.whitespace()\n                continue\n\n            elif self.char == '#':\n                # The current character is `#`\n                self.advance()\n                self.comment()\n                continue\n\n            elif self.char.isalpha() or self.char == '_':\n                # The current character is a letter or `_`\n                return self._id()\n\n            elif self.char == ';':\n                # The current character is `;`\n                self.advance()\n                return Token(Nature.SEMI, ';')\n\n            elif self.char == ',':\n                # The current character is `,`\n                self.advance()\n                return Token(Nature.COMMA, ';')\n\n            elif self.char.isdigit():\n                # The current character is a number\n                return self.number()\n\n            elif self.char == '=' and self.peek() == '=':\n                # The current character is `==`\n                self.advance()\n                self.advance()\n                return Token(Nature.EQ, '==')\n\n            elif self.char == '!' and self.peek() == '=':\n                # The current character is `!=`\n                self.advance()\n                self.advance()\n                return Token(Nature.NE, '!=')\n\n            elif self.char == '<' and self.peek() == '=':\n                # The current character is `<=`\n                self.advance()\n                self.advance()\n                return Token(Nature.LE, '<=')\n\n            elif self.char == '>' and self.peek() == '=':\n                # The current character is `>=`\n                self.advance()\n                self.advance()\n                return Token(Nature.GE, '>=')\n\n            elif self.char == '<':\n                # The current character is `<`\n                self.advance()\n                return Token(Nature.LT, '<')\n\n            elif self.char == '>':\n                # The current character is `>`\n                self.advance()\n                return Token(Nature.GT, '>')\n\n            elif self.char == '=':\n                # The current character is `=`\n                self.advance()\n                return Token(Nature.ASSIGN, '=')\n\n            elif self.char == '+':\n                # The current character is `+`\n                self.advance()\n                return Token(Nature.PLUS, '+')\n\n            elif self.char == '-':\n                # The current character is `-`\n                self.advance()\n                return Token(Nature.MINUS, '-')\n\n            elif self.char == '*':\n                # The current character is `*`\n                self.advance()\n                return Token(Nature.MUL, '*')\n\n            elif self.char == '/' and self.peek() == '/':\n                # The current character is `//`\n                self.advance()\n                self.advance()\n                return Token(Nature.INT_DIV, '//')\n\n            elif self.char == '/':\n                # The current character is `/`\n                self.advance()\n                return Token(Nature.DIV, '/')\n\n            elif self.char == '(':\n                # The current character is `(`\n                self.advance()\n                return Token(Nature.LPAREN, '(')\n\n            elif self.char == ')':\n                # The current character is `)`\n                self.advance()\n                return Token(Nature.RPAREN, ')')\n\n            elif self.char == '{':\n                # The current character is `{`\n                self.advance()\n                return Token(Nature.LBRACKET, '{')\n\n            elif self.char == '}':\n                # The current character is `}`\n                self.advance()\n                return Token(Nature.RBRACKET, '}')\n\n            else:\n                # The current character is unknown\n                raise LexicalError(f\"Invalid character `{self.char}`.\")\n\n        # End of raw input\n        return Token(Nature.EOF, None)", "response": "Lexical analyser of the raw input."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef checksum_file(scheme, path):\n    h = getattr(hashlib, scheme)()\n\n    with open(path, 'rb') as f:\n        chunk = f.read(65535)\n        while chunk:\n            h.update(chunk)\n            chunk = f.read(65535)\n    return h.hexdigest()", "response": "Return the checksum of a file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate(self):\n        if not self.file.exists():\n            raise ValueError(\"File \\\"%s\\\" doesn't exists\")\n\n        if not self.search:\n            raise ValueError(\"Search cannot be empty\")\n\n        if not self.replace:\n            raise ValueError(\"Replace cannot be empty\")\n\n        if self.match not in ('file', 'line'):\n            raise ValueError(\"Match must be one of: file, line\")\n\n        try:\n            codecs.lookup(self.encoding)\n        except LookupError:\n            raise ValueError(\"Unknown encoding: \\\"%s\\\"\" % self.encoding)", "response": "Validate current file configuration."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses config file and set properties", "response": "def _parse_config_file(self, cfg_files):\n        \"\"\"Parse config file (ini) and set properties\n\n        :return:\n        \"\"\"\n        cfg_handler = configparser.ConfigParser(interpolation=None)\n\n        if not cfg_handler.read(map(str, cfg_files)):\n            return\n\n        self._parse_global_section(cfg_handler)\n        self._parse_vcs_section(cfg_handler)\n        self._parse_file_section(cfg_handler)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_global_section(self, cfg_handler):\n        # global configuration\n        if 'versionner' in cfg_handler:\n            cfg = cfg_handler['versionner']\n            if 'file' in cfg:\n                self.version_file = cfg['file']\n            if 'date_format' in cfg:\n                self.date_format = cfg['date_format']\n            if 'up_part' in cfg:\n                self.up_part = cfg['up_part']\n            if 'default_init_version' in cfg:\n                self.default_init_version = cfg['default_init_version']\n            if 'default_increase_value' in cfg:\n                self.default_increase_value = cfg.getint('default_increase_value')", "response": "Parse the global section of the xml file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing [ vcs ] section", "response": "def _parse_vcs_section(self, cfg_handler):\n        \"\"\"Parse [vcs] section\n\n        :param cfg_handler:\n        :return:\n        \"\"\"\n        if 'vcs' in cfg_handler:\n            cfg = cfg_handler['vcs']\n            if 'engine' in cfg:\n                self.vcs_engine = cfg['engine']\n            if 'tag_params' in cfg:\n                self.vcs_tag_params = list(filter(None, cfg['tag_params'].split(\"\\n\")))\n            if 'commit_message' in cfg:\n                self.vcs_commit_message = cfg['commit_message']"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses file sections and add them to self. files", "response": "def _parse_file_section(self, cfg_handler):\n        \"\"\"Parse [file:*] sections\n\n        :param cfg_handler:\n        :return:\n        \"\"\"\n\n        _number_rxp = re.compile(r'^\\d+:(.)')\n        # project files configuration\n        for section in cfg_handler.sections():\n            if section.startswith('file:'):\n                path = section[5:]\n                path = _number_rxp.sub(r'\\1', path)\n\n                project_file = FileConfig(path, cfg_handler[section])\n\n                if not project_file.date_format:\n                    project_file.date_format = self.date_format\n\n                if project_file.enabled:\n                    try:\n                        project_file.validate()\n                    except ValueError as exc:\n                        print(\"Incorrect configuration for file \\\"%s\\\": %s\" % (project_file.filename, exc.args[0]), file=sys.stderr)\n                    else:\n                        self.files.append(project_file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_json_feed_content(url, offset=0, limit=None):\n\n    end = limit + offset if limit is not None else None\n\n    response = _get(url)\n\n    try:\n        content = json.loads(response.text)\n    except Exception as parse_error:\n        logger.warning(\n            'Failed to parse feed from {}: {}'.format(url, str(parse_error))\n        )\n        return False\n\n    return content[offset:end]", "response": "Get the entries in a JSON feed"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_rss_feed_content(url, offset=0, limit=None, exclude_items_in=None):\n\n    end = limit + offset if limit is not None else None\n\n    response = _get(url)\n\n    try:\n        feed_data = feedparser.parse(response.text)\n        if not feed_data.feed:\n            logger.warning('No valid feed data found at {}'.format(url))\n            return False\n        content = feed_data.entries\n    except Exception as parse_error:\n        logger.warning(\n            'Failed to parse feed from {}: {}'.format(url, str(parse_error))\n        )\n        return False\n\n    if exclude_items_in:\n        exclude_ids = [item['guid'] for item in exclude_items_in]\n        content = [item for item in content if item['guid'] not in exclude_ids]\n\n    content = content[offset:end]\n\n    for item in content:\n        updated_time = time.mktime(item['updated_parsed'])\n        item['updated_datetime'] = datetime.fromtimestamp(updated_time)\n\n    return content", "response": "Get the entries from an RSS feed and return them as a list of dictionaries."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap a call to the pystmark Simple API adding the pystmark_config settings as well as the pystmark_config_vars as the kwargs passed to the method.", "response": "def _pystmark_call(self, method, *args, **kwargs):\n        ''' Wraps a call to the pystmark Simple API, adding configured\n        settings\n        '''\n        kwargs = self._apply_config(**kwargs)\n        return method(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding the current_app s pystmark configuration to a dict.", "response": "def _apply_config(**kwargs):\n        '''Adds the current_app's pystmark configuration to a dict. If a\n        configuration value has been specified in \\*\\*kwargs, it will not\n        be overriden by the app's configuration.\n\n        :param kwargs: Keyword arguments to be passed to the pystmark Simple\n            API\n        '''\n        kwargs = dict(**kwargs)\n        kwargs.setdefault('api_key', current_app.config['PYSTMARK_API_KEY'])\n        kwargs.setdefault('secure', current_app.config.get('PYSTMARK_HTTPS',\n                                                           True))\n        kwargs.setdefault('test', current_app.config.get('PYSTMARK_TEST_API',\n                                                         False))\n        return kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef body(self):\n        self.connection = pika.BlockingConnection(self.connection_param)\n        self.channel = self.connection.channel()\n\n        # receive messages and put them to .onMessageReceived() callback\n        for method_frame, properties, body in self.channel.consume(self.queue):\n            if self.onMessageReceived(method_frame, properties, body):\n                self.ack(method_frame.delivery_tag)", "response": "This method handles AMQP connection details and receive loop."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef onMessageReceived(self, method_frame, properties, body):\n        print \"method_frame:\", method_frame\n        print \"properties:\", properties\n        print \"body:\", body\n\n        print \"---\"\n        print", "response": "Callback which is called every time when a message is received."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sendResponse(self, message, UUID, routing_key):\n        self.sendMessage(\n            exchange=self.output_exchange,\n            routing_key=routing_key,\n            message=message,\n            UUID=UUID\n        )", "response": "Send a response to the output exchange with the routing key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef onExit(self):\n        def try_call(fn):\n            try:\n                fn()\n            except (pika.exceptions.ChannelClosed, AttributeError,\n                    pika.exceptions.ConnectionClosed):\n                return\n\n        if hasattr(self, \"channel\"):\n            try_call(self.channel.cancel)\n            try_call(self.channel.close)\n            try_call(self.connection.close)", "response": "Called when daemon is stopped."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, file_lines, index):\n        line = file_lines[index]\n        start_index = line.find('# ') + 2   # Start index for header text\n        start_tag = line.rfind(self._open)  # Start index of AnchorHub tag\n        end_tag = line.rfind(self._close)   # End index of AnchorHub tag\n\n        # The magic '+1' below knocks out the hash '#' character from extraction\n        tag = line[start_tag + len(self._open) + 1:end_tag]\n        string = line[start_index:start_tag]\n        return [tag, string]", "response": "Extract the specified AnchorHub tag and portion of the current line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the database with the user s karma amount.", "response": "def update_db(self, userkarma, username):\n        \"\"\"\n        Change the users karma by the karma amount (either 1 or -1)\n        \"\"\"\n\n        kt = self.db.session.query(KarmaTable)\n        for user in userkarma:\n            if user != username:\n                # Modify the db accourdingly\n                urow = kt.filter(KarmaTable.user == ude(user)).first()\n                # If the user doesn't exist, create it\n                if not urow:\n                    urow = KarmaTable(ude(user))\n                urow.kcount += userkarma[user]\n                self.db.session.add(urow)\n        self.db.session.commit()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the travel time value used for re - routing on the given edge.", "response": "def getAdaptedTraveltime(self, edgeID, time):\n        \"\"\"getAdaptedTraveltime(string, double) -> double\n\n        Returns the travel time value (in s) used for (re-)routing\n        which is valid on the edge at the given time.\n        \"\"\"\n        self._connection._beginMessage(tc.CMD_GET_EDGE_VARIABLE, tc.VAR_EDGE_TRAVELTIME,\n                                       edgeID, 1 + 4)\n        self._connection._string += struct.pack(\n            \"!Bi\", tc.TYPE_INTEGER, time)\n        return self._connection._checkResult(tc.CMD_GET_EDGE_VARIABLE,\n                                             tc.VAR_EDGE_TRAVELTIME, edgeID).readDouble()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the effort value used for re - routing on the given edge.", "response": "def getEffort(self, edgeID, time):\n        \"\"\"getEffort(string, double) -> double\n\n        Returns the effort value used for (re-)routing\n        which is valid on the edge at the given time.\n        \"\"\"\n        self._connection._beginMessage(tc.CMD_GET_EDGE_VARIABLE, tc.VAR_EDGE_EFFORT,\n                                       edgeID, 1 + 4)\n        self._connection._string += struct.pack(\n            \"!Bi\", tc.TYPE_INTEGER, time)\n        return self._connection._checkResult(tc.CMD_GET_EDGE_VARIABLE,\n                                             tc.VAR_EDGE_EFFORT, edgeID).readDouble()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadapt the travel time value for the given edge.", "response": "def adaptTraveltime(self, edgeID, time, begin=None, end=None):\n        \"\"\"adaptTraveltime(string, double, int, int) -> None\n\n        Adapt the travel time value (in s) used for (re-)routing for the given edge.\n\n        When setting begin time and end time (in seconds), the changes only\n        apply to that time range. Otherwise they apply all the time\n        \"\"\"\n        if begin is None and end is None:\n            self._connection._beginMessage(\n                tc.CMD_SET_EDGE_VARIABLE, tc.VAR_EDGE_TRAVELTIME, edgeID, 1 + 4 + 1 + 8)\n            self._connection._string += struct.pack(\"!BiBd\",\n                                                    tc.TYPE_COMPOUND, 1, tc.TYPE_DOUBLE, time)\n            self._connection._sendExact()\n        elif begin is not None and end is not None:\n            self._connection._beginMessage(\n                tc.CMD_SET_EDGE_VARIABLE, tc.VAR_EDGE_TRAVELTIME, edgeID, 1 + 4 + 1 + 4 + 1 + 4 + 1 + 8)\n            self._connection._string += struct.pack(\"!BiBiBiBd\",\n                                                    tc.TYPE_COMPOUND, 3,\n                                                    tc.TYPE_INTEGER, begin,\n                                                    tc.TYPE_INTEGER, end,\n                                                    tc.TYPE_DOUBLE, time)\n            self._connection._sendExact()\n        else:\n            raise TraCIException(\n                \"Both, begin time and end time must be specified\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setEffort(self, edgeID, effort, begin=None, end=None):\n        if begin is None and end is None:\n            self._connection._beginMessage(\n                tc.CMD_SET_EDGE_VARIABLE, tc.VAR_EDGE_EFFORT, edgeID, 1 + 4 + 1 + 8)\n            self._connection._string += struct.pack(\"!BiBd\",\n                                                    tc.TYPE_COMPOUND, 1, tc.TYPE_DOUBLE, effort)\n            self._connection._sendExact()\n        elif begin is not None and end is not None:\n            self._connection._beginMessage(\n                tc.CMD_SET_EDGE_VARIABLE, tc.VAR_EDGE_EFFORT, edgeID, 1 + 4 + 1 + 4 + 1 + 4 + 1 + 8)\n            self._connection._string += struct.pack(\"!BiBiBiBd\",\n                                                    tc.TYPE_COMPOUND, 3,\n                                                    tc.TYPE_INTEGER, begin,\n                                                    tc.TYPE_INTEGER, end,\n                                                    tc.TYPE_DOUBLE, effort)\n            self._connection._sendExact()\n        else:\n            raise TraCIException(\n                \"Both, begin time and end time must be specified\")", "response": "This method is used to set the effort value for a given edge."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the maximum speed of the edge.", "response": "def setMaxSpeed(self, edgeID, speed):\n        \"\"\"setMaxSpeed(string, double) -> None\n\n        Set a new maximum speed (in m/s) for all lanes of the edge.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_EDGE_VARIABLE, tc.VAR_MAXSPEED, edgeID, speed)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef eventFilter(self, object, event):\n\n        if event.type() == QEvent.MouseButtonDblClick:\n            view = object.parent()\n            if view.read_only:\n                self.__raise_user_error(view)\n                return True\n        return False", "response": "Reimplement the QObject. eventFilter method."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nraises an error if the given View has been set read only and the user attempted to edit its content.", "response": "def __raise_user_error(self, view):\n        \"\"\"\n        Raises an error if the given View has been set read only and the user attempted to edit its content.\n\n        :param view: View.\n        :type view: QWidget\n        \"\"\"\n\n        raise foundations.exceptions.UserError(\"{0} | Cannot perform action, '{1}' View has been set read only!\".format(\n            self.__class__.__name__, view.objectName() or view))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resizeEvent(self, event):\n\n        super(type(self), self).resizeEvent(event)\n\n        self.__notifier.refresh_position()", "response": "Reimplement the. resizeEvent method."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef paintEvent(self, event):\n\n        super(type(self), self).paintEvent(event)\n\n        show_message = True\n        model = self.model()\n        if issubclass(type(model), GraphModel):\n            if model.has_nodes():\n                show_message = False\n        elif issubclass(type(model), QAbstractItemModel) or \\\n                issubclass(type(model), QAbstractListModel) or \\\n                issubclass(type(model), QAbstractTableModel):\n            if model.rowCount():\n                show_message = False\n\n        if show_message:\n            self.__notifier.show_message(self.__message, 0)\n        else:\n            self.__notifier.hide_message()", "response": "Reimplement the. paintEvent method."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_only(self, value):\n\n        if value is not None:\n            assert type(value) is bool, \"'{0}' attribute: '{1}' type is not 'bool'!\".format(\"read_only\", value)\n        self.__read_only = value", "response": "Sets the read_only flag."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __initialize_ui(self):\n\n        self.viewport().installEventFilter(ReadOnlyFilter(self))\n\n        if issubclass(type(self), QListView):\n            super(type(self), self).setUniformItemSizes(True)\n        elif issubclass(type(self), QTreeView):\n            super(type(self), self).setUniformRowHeights(True)", "response": "Initializes the View ui."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the View nodes.", "response": "def get_nodes(self):\n        \"\"\"\n        Returns the View nodes.\n\n        :return: View nodes.\n        :rtype: list\n        \"\"\"\n\n        return [node for node in foundations.walkers.nodes_walker(self.model().root_node)]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter_nodes(self, pattern, attribute, flags=re.IGNORECASE):\n\n        return [node for node in self.get_nodes() if re.search(pattern, getattr(node, attribute), flags)]", "response": "Filters the View Nodes on given attribute using given pattern."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_view_nodes_from_indexes(self, *indexes):\n\n        nodes = {}\n        model = self.model()\n        if not model:\n            return nodes\n\n        if not hasattr(model, \"get_node\"):\n            raise NotImplementedError(\n                \"{0} | '{1}' Model doesn't implement a 'get_node' method!\".format(__name__, model))\n\n        if not hasattr(model, \"get_attribute\"):\n            raise NotImplementedError(\n                \"{0} | '{1}' Model doesn't implement a 'get_attribute' method!\".format(__name__, model))\n\n        for index in indexes:\n            node = model.get_node(index)\n            if not node in nodes:\n                nodes[node] = []\n            attribute = model.get_attribute(node, index.column())\n            attribute and nodes[node].append(attribute)\n        return nodes", "response": "Returns the View Nodes from given indexes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef select_view_indexes(self, indexes, flags=QItemSelectionModel.Select | QItemSelectionModel.Rows):\n\n        if self.selectionModel():\n            selection = QItemSelection()\n            for index in indexes:\n                selection.merge(QItemSelection(index, index), flags)\n            self.selectionModel().select(selection, flags)\n        return True", "response": "Selects the view given indexes."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef select_indexes(self, indexes, flags=QItemSelectionModel.Select | QItemSelectionModel.Rows):\n\n        return self.select_view_indexes(indexes, flags)", "response": "Selects given indexes.\n\n        :param indexes: Indexes to select.\n        :type indexes: list\n        :param flags: Selection flags. ( QItemSelectionModel.SelectionFlags )\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lint(fmt='colorized'):\n    if fmt == 'html':\n        outfile = 'pylint_report.html'\n        local('pylint -f %s davies > %s || true' % (fmt, outfile))\n        local('open %s' % outfile)\n    else:\n        local('pylint -f %s davies || true' % fmt)", "response": "Run verbose PyLint on source. Optionally specify fmt = html for HTML output. Optionally specify fmt = colorized for colorized output."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef azm(self):\n        azm1 = self.get('BEARING', None)\n        azm2 = self.get('AZM2', None)\n        if azm1 is None and azm2 is None:\n            return None\n        if azm2 is None:\n            return azm1 + self.declination\n        if azm1 is None:\n            return (azm2 + 180) % 360 + self.declination\n        return (azm1 + (azm2 + 180) % 360) / 2.0 + self.declination", "response": "Corrected azimuth taking into account backsight declination and compass corrections."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncorrecting inclination taking into account backsight and clino corrections.", "response": "def inc(self):\n        \"\"\"Corrected inclination, taking into account backsight and clino corrections.\"\"\"\n        inc1 = self.get('INC', None)\n        inc2 = self.get('INC2', None)\n        if inc1 is None and inc2 is None:\n            return None\n        if inc2 is None:\n            return inc1\n        if inc1 is None:\n            return -1 * inc2\n        return (inc1 - inc2) / 2.0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a shot dictionary to this survey s shots list applying this survey s magnetic declination", "response": "def add_shot(self, shot):\n        \"\"\"Add a shot dictionary to :attr:`shots`, applying this survey's magnetic declination\"\"\"\n        shot.declination = self.declination\n        self.shots.append(shot)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the total length of included shots in the site.", "response": "def included_length(self):\n        \"\"\"Surveyed length, not including \"excluded\" shots\"\"\"\n        return sum([shot.length for shot in self.shots if shot.is_included])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the total length of the excluded shot items", "response": "def excluded_length(self):\n        \"\"\"Surveyed length which does not count toward the included total\"\"\"\n        return sum([shot.length for shot in self.shots if Exclude.LENGTH in shot.flags or Exclude.TOTAL in shot.flags])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting or overwrite a Survey to the specified. DAT file", "response": "def write(self, outfname=None):\n        \"\"\"Write or overwrite a `Survey` to the specified .DAT file\"\"\"\n        outfname = outfname or self.filename\n        with codecs.open(outfname, 'wb', 'windows-1252') as outf:\n            for survey in self.surveys:\n                outf.write('\\r\\n'.join(survey._serialize()))\n                outf.write('\\r\\n'+'\\f'+'\\r\\n')  # ASCII \"form feed\" ^L\n            outf.write('\\x1A')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_base_location(self, location):\n        self.base_location = location\n        self._utm_zone = location.zone\n        self._utm_datum = location.datum\n        self._utm_convergence = location.convergence", "response": "Configure the project s base location"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a linked station to the current state.", "response": "def add_linked_station(self, datfile, station, location=None):\n        \"\"\"Add a linked or fixed station\"\"\"\n        if datfile not in self.fixed_stations:\n            self.fixed_stations[datfile] = {station: location}\n        else:\n            self.fixed_stations[datfile][station] = location\n\n        if location and not self.base_location:\n            self._utm_zone = location.zone\n            self._utm_datum = location.datum\n            self._utm_convergence = location.convergence"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write(self, outfilename=None):\n        outfilename = outfilename or self.filename\n        if not outfilename:\n            raise ValueError('Unable to write MAK file without a filename')\n        with codecs.open(outfilename, 'wb', 'windows-1252') as outf:\n            outf.write('\\r\\n'.join(self._serialize()))", "response": "Write or overwrite this. MAK file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(self):\n        if not self.survey_str:\n            return None\n        lines = self.survey_str.splitlines()\n        if len(lines) < 10:\n            raise ParseException(\"Expected at least 10 lines in a Compass Survey, only found %d!\\nlines=%s\" % (len(lines), lines))\n\n        # undelimited Cave Name may be empty string and \"skipped\"\n        first_line = lines.pop(0).strip()\n        if first_line.startswith('SURVEY NAME:'):\n            cave_name = ''\n            name = first_line.strip('SURVEY NAME:').strip()\n        else:\n            cave_name = first_line\n            name = lines.pop(0).split('SURVEY NAME:', 1)[1].strip()\n\n        # Date and Comment on one line, Comment may be missing\n        date_comment_toks = lines.pop(0).split('SURVEY DATE:', 1)[1].split('COMMENT:')\n        date = CompassSurveyParser._parse_date(date_comment_toks[0])\n        comment = date_comment_toks[1].strip() if len(date_comment_toks) > 1 else ''\n\n        lines.pop(0)  # SURVEY TEAM:\\n (actual team members are on the next line)\n        team = [member.strip() for member in lines.pop(0).split(',')]  # We're already decoding from windows-1252 codec so we have unicode for names like 'Tanya Pietra\\xdf'\n\n        # TODO: implement format (units!), instrument correction(s)\n        dec_fmt_corr = lines.pop(0)\n        declination, fmt, corrections, corrections2 = CompassSurveyParser._parse_declination_line(dec_fmt_corr)\n\n        lines.pop(0)\n        shot_header = lines.pop(0).split()\n        val_count = len(shot_header) - 2 if 'FLAGS' in shot_header else len(shot_header)  # 1998 vintage data has no FLAGS, COMMENTS at end\n        lines.pop(0)\n\n        survey = Survey(name=name, date=date, comment=comment, team=team, cave_name=cave_name,\n                        shot_header=shot_header, declination=declination,\n                        file_format=fmt, corrections=corrections, corrections2=corrections2)\n\n        shots = []\n        shot_lines = lines\n        for shot_line in shot_lines:\n            shot_vals = shot_line.split(None, val_count)\n\n            if len(shot_vals) > val_count:  # last two spare columns are FLAGS and COMMENTS, either value may be missing\n                flags_comment = shot_vals.pop()\n                if not flags_comment.startswith('#|'):\n                    flags, comment = '', flags_comment\n                else:\n                    try:\n                        flags, comment = flags_comment.split('#|', 1)[1].split('#', 1)\n                    except ValueError:\n                        raise ParseException('Invalid flags in %s survey: %s' % (name, flags_comment))  # A 2013 bug in Compass inserted corrupt binary garbage into FLAGS column, causes parse to barf\n                shot_vals += [flags, comment.strip()]\n\n            shot_vals = [(header, self._coerce(header, val)) for (header, val) in zip(shot_header, shot_vals)]\n            shot = Shot(shot_vals)\n            survey.add_shot(shot)\n\n        #log.debug(\"Survey: name=%s shots=%d length=%0.1f date=%s team=%s\\n%s\", name, len(shots), survey.length, date, team, '\\n'.join([str(shot) for shot in survey.shots]))\n\n        return survey", "response": "Parse the string and return a Survey object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses our data file and return a DatFile or raise a ParseException.", "response": "def parse(self):\n        \"\"\"Parse our data file and return a :class:`DatFile` or raise :exc:`ParseException`.\"\"\"\n        log.debug(\"Parsing Compass .DAT file %s ...\", self.datfilename)\n        datobj = DatFile(name_from_filename(self.datfilename), filename=self.datfilename)\n\n        with codecs.open(self.datfilename, 'rb', 'windows-1252') as datfile:\n            full_contents = datfile.read()\n            survey_strs = [survey_str.strip() for survey_str in full_contents.split('\\x0C')]\n\n            if survey_strs[-1] == '\\x1A':\n                survey_strs.pop()  # Compass may place a \"soft EOF\" with ASCII SUB char\n\n            log.debug(\"Parsed %d raw surveys from Compass .DAT file %s.\", len(survey_strs), self.datfilename)\n            for survey_str in survey_strs:\n                if not survey_str:\n                    continue\n                survey = CompassSurveyParser(survey_str).parse()\n                datobj.add_survey(survey)\n\n        return datobj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse our Compass. MAK file and return a Project object or raise a ParseException.", "response": "def parse(self):\n        \"\"\"Parse our project file and return :class:`Project` object or raise :exc:`ParseException`.\"\"\"\n        log.debug(\"Parsing Compass .MAK file %s ...\", self.makfilename)\n\n        base_location = None\n        linked_files = []\n        file_params = set()\n\n        def parse_linked_file(value):\n            log.debug(\"Parsing linked file:  %s\", value)\n            value = value.rstrip(';')\n            toks = value.split(',', 1)\n            if len(toks) == 1:\n                return toks[0]\n            else:\n                return toks[0]  # TODO: implement link stations and fixed stations\n\n        with codecs.open(self.makfilename, 'rb', 'windows-1252') as makfile:\n            prev = None\n\n            for line in makfile:\n                line = line.strip()\n\n                if not line:\n                    continue\n\n                header, value = line[0], line[1:]\n\n                if prev:\n                    if line.endswith(';'):\n                        linked_file = parse_linked_file(prev + line.rstrip(';'))\n                        linked_files.append(linked_file)\n                        prev = None\n                    else:\n                        prev += value\n                    continue\n\n                if header == '/':\n                    pass  # comment\n\n                elif header == '@':\n                    value = value.rstrip(';')\n                    base_location = UTMLocation(*(float(v) for v in value.split(',')))\n\n                elif header == '&':\n                    value = value.rstrip(';')\n                    base_location.datum = value\n\n                elif header == '%':\n                    value = value.rstrip(';')\n                    base_location.convergence = float(value)\n\n                elif header == '!':\n                    value = value.rstrip(';')\n                    #file_params = set(value)  # TODO\n\n                elif header == '#':\n                    if value.endswith(';'):\n                        linked_files.append(parse_linked_file(value))\n                        prev = None\n                    else:\n                        prev = value\n\n            log.debug(\"Project:  base_loc=%s  linked_files=%s\", base_location, linked_files)\n\n            project = Project(name_from_filename(self.makfilename), filename=self.makfilename)\n            project.set_base_location(base_location)\n\n            for linked_file in linked_files:\n                # TODO: we need to support case-insensitive path resolution on case-sensitive filesystems\n                linked_file_path = os.path.join(os.path.dirname(self.makfilename), os.path.normpath(linked_file.replace('\\\\', '/')))\n                datfile = CompassDatParser(linked_file_path).parse()\n                project.add_linked_file(datfile)\n\n            return project"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads version from version file", "response": "def read(self):\n        \"\"\"Read version from version file\n\n        :rtype : Version\n        :return:\n        \"\"\"\n        with self._path.open(mode='r') as fh:\n            version = fh.read().strip()\n        return Version(version)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves new version into self. _path in safe way.", "response": "def write(self, version):\n        \"\"\"Save new version into self._path in safe way (using temporary file)\n\n        :param version:Version\n        \"\"\"\n        with tempfile.NamedTemporaryFile(mode='w', delete=False) as fh:\n            fh.write(str(version))\n\n        if self._path.exists():\n            shutil.copystat(str(self._path), fh.name)\n\n        try:\n            pathlib.Path(fh.name).rename(self._path)\n        except OSError as exc:\n            # handling situation with tmp file on another device\n            if exc.errno == 18 and 'Invalid cross-device link' in exc.strerror:\n                with self._path.open(mode='w') as fh:\n                    fh.write(str(version))\n            else:\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef compile_pattern(word):\n    return re.compile(r'^%s$' % re.sub(r'\\?', '[a-z]',\n                                       dicts.sanitize_word(word)))", "response": "take a word pattern and return a Python regexp."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of all matching words in a language.", "response": "def get_matches(pattern, language, max_count=8):\n    \"\"\"\n    take a word pattern or a Python regexp and a language name, and return a\n    list of all matching words.\n    \"\"\"\n    if str(pattern) == pattern:\n        pattern = compile_pattern(pattern)\n\n    results = []\n\n    if not dicts.exists(language):\n        print(\"The language '%s' is not available locally.\" % language)\n        return []\n\n    with open(dicts.filepath(language), 'r') as f:\n        for word in f:\n            if max_count <= 0:\n                break\n            w = word.strip()\n            if pattern.match(w) and w not in results:\n                results.append(w)\n                max_count -= 1\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nactivating the Component. :param engine: Engine to attach the Component to. :type engine: QObject :return: Method success. :rtype: bool", "response": "def activate(self, engine):\n        \"\"\"\n        Activates the Component.\n\n        :param engine: Engine to attach the Component to.\n        :type engine: QObject\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        LOGGER.debug(\"> Activating '{0}' Component.\".format(self.__class__.__name__))\n\n        self.__engine = engine\n        self.__settings = self.__engine.settings\n        self.__settings_section = self.name\n\n        self.activated = True\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef initialize_ui(self):\n\n        LOGGER.debug(\"> Initializing '{0}' Component ui.\".format(self.__class__.__name__))\n\n        self.Trace_Modules_Filter_lineEdit = Search_QLineEdit(self)\n        self.Trace_Modules_Filter_lineEdit.search_active_label.hide()\n        self.Trace_Modules_Filter_lineEdit.setPlaceholderText(\"Objects Trace Filter ...\")\n        self.Trace_Modules_Filter_horizontalLayout.addWidget(self.Trace_Modules_Filter_lineEdit)\n\n        self.__model = ModulesModel(self, horizontal_headers=self.__headers)\n\n        self.Modules_treeView.setParent(None)\n        self.Modules_treeView = Modules_QTreeView(self, self.__model)\n        self.Modules_treeView.setObjectName(\"Modules_treeView\")\n        self.Modules_treeView.setContextMenuPolicy(Qt.ActionsContextMenu)\n        self.Trace_Ui_dockWidgetContents_gridLayout.addWidget(self.Modules_treeView, 0, 0)\n        self.__view = self.Modules_treeView\n        self.__view_add_actions()\n\n        self.set_modules()\n\n        # Signals / Slots.\n        self.refresh_nodes.connect(self.__model__refresh_nodes)\n\n        self.initialized_ui = True\n        return True", "response": "Initializes the Component ui."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the View actions.", "response": "def __view_add_actions(self):\n        \"\"\"\n        Sets the View actions.\n        \"\"\"\n\n        self.__view.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|addons.trace_ui|Trace Module(s)\",\n            slot=self.__view_trace_modules_action__triggered))\n        self.__view.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|addons.trace_ui|Untrace Module(s)\",\n            slot=self.__view_untrace_modules_action__triggered))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves the View actions.", "response": "def __view_remove_actions(self):\n        \"\"\"\n        Removes the View actions.\n        \"\"\"\n\n        trace_modules_action = \"Actions|Umbra|Components|addons.trace_ui|Trace Module(s)\"\n        untrace_modules_action = \"Actions|Umbra|Components|addons.trace_ui|Untrace Module(s)\"\n\n        for action in (trace_modules_action, untrace_modules_action):\n            self.__view.removeAction(self.__engine.actions_manager.get_action(action))\n            self.__engine.actions_manager.unregister_action(action)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntracing given modules using given filter pattern.", "response": "def trace_modules(self, modules, pattern=r\".*\", flags=re.IGNORECASE):\n        \"\"\"\n        Traces given modules using given filter pattern.\n\n        :param modules: Modules to trace.\n        :type modules: list\n        :param pattern: Matching pattern.\n        :type pattern: unicode\n        :param flags: Matching regex flags.\n        :type flags: int\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        try:\n            pattern = re.compile(pattern, flags)\n        except Exception:\n            raise foundations.exceptions.UserError(\n                \"{0} | Invalid objects trace filter pattern: Regex compilation failed!\".format(self.__class__.__name__))\n\n        for module in modules:\n            foundations.trace.trace_module(module, foundations.verbose.tracer, pattern)\n        self.__model__refresh_attributes()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the modules Model nodes.", "response": "def set_modules(self, modules=None):\n        \"\"\"\n        Sets the modules Model nodes.\n\n        :param modules: Modules to set.\n        :type modules: list\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        node_flags = int(Qt.ItemIsSelectable | Qt.ItemIsEnabled)\n        modules = modules or self.get_modules()\n        root_node = umbra.ui.nodes.DefaultNode(name=\"InvisibleRootNode\")\n        for module in modules:\n            module_node = ModuleNode(module=module,\n                                     name=foundations.strings.to_string(module.__name__),\n                                     parent=root_node,\n                                     node_flags=node_flags,\n                                     attributes_flags=int(Qt.ItemIsSelectable | Qt.ItemIsEnabled))\n\n        root_node.sort_children()\n\n        self.__model.initialize_model(root_node)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef auth_required(validator):\n    def _auth_required_decorator(handler):\n        if inspect.isclass(handler):\n            return _wrap_class(handler, validator)\n        return _auth_required(handler, validator)\n\n    return _auth_required_decorator", "response": "Decorator to make sure a request is authenticated\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef auth_optional(validator):\n    def _auth_optional_decorator(handler):\n        if inspect.isclass(handler):\n            return _wrap_class(handler, validator)\n        return _auth_optional(handler, validator)\n\n    return _auth_optional_decorator", "response": "Decorator to accept optional authentication token"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _wrap_class(request_handler, validator):\n    METHODS = ['get', 'post', 'put', 'head', 'options', 'delete', 'patch']\n    for name in METHODS:\n        method = getattr(request_handler, name)\n        setattr(request_handler, name, _auth_required(method, validator))\n\n    return request_handler", "response": "Decorate each HTTP verb method to check if the request is authenticated."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_token(request):\n    token = request.headers.get('Authorization')\n    if not token:\n        message = 'Token not in Authorization header'\n        logging.warning(message)\n        raise HTTPError(401, message)\n    return token", "response": "Gets authentication token from request header"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _auth_required(method, validator):\n    @gen.coroutine\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        token = _get_token(self.request)\n        valid_token = yield validator(token)\n        if not valid_token:\n            message = 'Invalid token: {}'.format(token)\n            logging.warning(message)\n            raise HTTPError(401, message)\n        result = method(self, *args, **kwargs)\n\n        if isinstance(result, Future):\n            result = yield result\n\n        raise gen.Return(result)\n\n    return wrapper", "response": "Decorator that checks if the request is authenticated and returns the result."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndecorating a RequestHandler or method to require that a request is authorized If decorating a coroutine make sure coroutine decorator is first. eg.:: class Handler(tornado.web.RequestHandler): @authorized(validator) @coroutine def get(self): pass :param validator: a coroutine that will authorize the user associated with the token and return True/False", "response": "def authorized(validator):\n    \"\"\"Decorate a RequestHandler or method to require that a request is authorized\n\n    If decorating a coroutine make sure coroutine decorator is first.\n    eg.::\n\n        class Handler(tornado.web.RequestHandler):\n\n            @authorized(validator)\n            @coroutine\n            def get(self):\n                pass\n\n    :param validator: a coroutine that will authorize the user associated with the token and return True/False\n    \"\"\"\n    def _authorized_decorator(method):\n        @gen.coroutine\n        def wrapper(self, *args, **kwargs):\n            token = _get_token(self.request)\n            authorized = yield validator(token, **kwargs)\n            if not authorized:\n                message = 'Token is not authorised for this action: {}'.format(token)\n                logging.warning(message)\n                raise HTTPError(403, message)\n\n            result = method(self, *args, **kwargs)\n\n            if isinstance(result, Future):\n                result = yield result\n\n            raise gen.Return(result)\n\n        return wrapper\n    return _authorized_decorator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the power density of the current sunlight entry.", "response": "def calc_power_density(self):\n        \"\"\"\n        Solar cell power density\n\n        The output power density is calculated according to DeVos's :cite:`9780198513926` Eq. 6.4. Note that this expression assumes fully concentrated sunlight and is therefore not completely general.\n\n        This method returns values of type :class:`astropy.units.Quantity` with units of [W m^-2].\n        \"\"\"\n        electron_energy = constants.e.si * self.voltage\n\n        if self.bandgap == 0:\n            solar_flux = units.Quantity(0., \"1/(m2*s)\")\n            solar_cell_flux = units.Quantity(0., \"1/(m2*s)\")\n        else:\n            solar_flux = uibei(2, self.bandgap, self.temp_sun, 0)\n            solar_cell_flux = uibei(2, self.bandgap, self.temp_planet, electron_energy)\n        power_density = electron_energy * (solar_flux - solar_cell_flux)\n\n        return power_density.to(\"W/m^2\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef print_input_output(opts):\n    if opts.is_dir:\n        print(\"Root input directory:\\t\" + opts.input)\n        print(\"Outputting to:\\t\\t\" + opts.output + \"\\n\")\n    else:\n        print(\"Input file:\\t\\t\" + opts.input)\n        print(\"Outputting to:\\t\\t\" + opts.output + opts.input + \"\\n\")", "response": "Prints the input and output directories to the console."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef print_files(opts, file_paths):\n    print(\"Parsing the following files:\")\n    for file_path in file_paths:\n        print(\"  \" + strip_prefix(file_path, opts.abs_input))\n    print(\"--------------------\")\n    print(str(len(file_paths)) + \" total\\n\")", "response": "Prints the file paths that will be parsed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef print_no_files_found(opts):\n    msg =  \"No files found with [\" +', '.join(opts.extensions) + \"] \"\n    msg += \"extension\" +(\"s \" if len(opts.extensions) > 1 else \" \")\n    msg += \"in \" + opts.input\n    # if recursive\n    msg += \" or any of its subdirectories\"\n    print(msg)", "response": "Prints message that no files were found in the input directory with the given list of extensions."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_duplicate_anchor_information(duplicate_tags):\n    print(\"Duplicate anchors specified within file(s)\")\n    print(\"Please modify your code to remove duplicates.\\r\\n\")\n    for file_path in duplicate_tags:\n        print(\"File: \" + file_path)\n        for line_info in duplicate_tags[file_path]:\n            print(\"\\tLine \" + str(line_info[1]) +     # Line number\n                  \"\\t#\" + line_info[0] +            # Repeated AnchorHub tag\n                  \" :\\t\" + line_info[2])", "response": "Prints information about duplicate AnchorHub tags found during collection."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef print_modified_files(opts, anchors):\n    print(\"Files with modifications:\")\n    for file_path in anchors:\n        print(\"  \" + strip_prefix(file_path, opts.abs_input))\n    print(\"--------------------\")\n    print(str(len(anchors)) + \" total\\n\")", "response": "Prints out which files were modified amongst those looked at by the user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprinting summary statistics about which WriterStrategies were used and how much they were used.", "response": "def print_summary_stats(counter):\n    \"\"\"\n    Prints summary statistics about which writer strategies were used,\n    and how much they were used.\n\n    :param counter: A list of lists. The first entry on the inner list is a\n        number count of how many times a WriterStrategy was used, and the\n        second entry is a string label describing the WriterStrategy\n    \"\"\"\n    sum = 0     # Sum of labeled WriterStrategy modifications\n    u_sum = 0   # Sum of unlabeled WriterStrategy modifications\n    for c in counter:\n        if c[1] is not None and c[0] > 0:\n            print(\"Total \" + c[1] + \" modified:\\t\" + str(c[0]))\n            sum += c[0]\n        else:\n            u_sum += c[0]\n    if u_sum > 0:\n        print(\"Unlabeled modifications: \\t\" + str(u_sum))\n    print(\"Total modifications: \\t\\t\" + str(sum + u_sum))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfunction to focus a quad in X in Y", "response": "def funTransQuadF(k, s):\n    \"\"\" Focusing quad in X, defocusing in Y\n\n    :param k: k1, in [T/m]\n    :param s: width, in [m]\n    :return: 2x2 numpy array\n    \"\"\"\n    sqrtk = np.sqrt(complex(k))\n    a = np.cos(sqrtk * s)\n    b = np.sin(sqrtk * s) / sqrtk\n    c = -sqrtk * np.sin(sqrtk * s)\n    d = np.cos(sqrtk * s)\n    return np.matrix([[a.real, b.real], [c.real, d.real]], dtype=np.double)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef funTransQuadD(k, s):\n    sqrtk = np.sqrt(complex(k))\n    a = np.cosh(sqrtk * s)\n    b = np.sinh(sqrtk * s) / sqrtk\n    c = sqrtk * np.sinh(sqrtk * s)\n    d = np.cosh(sqrtk * s)\n    return np.matrix([[a.real, b.real], [c.real, d.real]], dtype=np.double)", "response": "Defocusing quad in X focusing in Y"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfringing matrix in X", "response": "def funTransEdgeX(theta, rho):\n    \"\"\" Fringe matrix in X\n\n    :param theta: fringe angle, in [rad]\n    :param rho: bend radius, in [m]\n    :return: 2x2 numpy array\n    \"\"\"\n    return np.matrix([[1, 0], [np.tan(theta) / rho, 1]], dtype=np.double)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions that computes the fringe matrix in Y in the Y plane", "response": "def funTransEdgeY(theta, rho):\n    \"\"\" Fringe matrix in Y\n\n    :param theta: fringe angle, in [rad]\n    :param rho: bend radius, in [m]\n    :return: 2x2 numpy array\n    \"\"\"\n    return np.matrix([[1, 0], [-np.tan(theta) / rho, 1]], dtype=np.double)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef funTransSectX(theta, rho):\n    return np.matrix([[np.cos(theta), rho * np.sin(theta)], [-np.sin(theta) / rho, np.cos(theta)]], dtype=np.double)", "response": "Sector matrix in X"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef funTransSectY(theta, rho):\n    return np.matrix([[1, rho * theta], [0, 1]], dtype=np.double)", "response": "This function transforms the Y plane in the Y series to the Y plane."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the Chicane matrix of the given imagl and idril.", "response": "def funTransChica(imagl, idril, ibfield, gamma0, xoy='x'):\n    \"\"\" Chicane matrix, composed of four rbends, seperated by drifts\n\n    :param imagl: rbend width, in [m]\n    :param idril: drift length between two adjacent rbends, in [m]\n    :param ibfield: rbend magnetic strength, in [T]\n    :param gamma0: electron energy, gamma\n    :param xoy: ``'x'`` or ``'y'``, matrix in X or Y direction, ``'x'`` by default\n    :return: 2x2 numpy array\n    \"\"\"\n    m0 = 9.10938215e-31\n    e0 = 1.602176487e-19\n    c0 = 299792458\n    rho = np.sqrt(gamma0 ** 2 - 1) * m0 * c0 / ibfield / e0\n    theta = np.arcsin(imagl / rho)\n    ld = idril\n    mx = reduce(np.dot, [funTransDrift(idril),\n                         funTransSectX(theta, rho), funTransEdgeX(theta, rho),\n                         funTransDrift(ld),\n                         funTransEdgeX(-theta, -rho), funTransSectX(-theta, -rho),\n                         funTransDrift(ld),\n                         funTransSectX(-theta, -rho), funTransEdgeX(-theta, -rho),\n                         funTransDrift(ld),\n                         funTransEdgeX(theta, rho), funTransSectX(theta, rho),\n                         funTransDrift(idril)])\n    my = reduce(np.dot, [funTransDrift(idril),\n                         funTransSectY(theta, rho), funTransEdgeY(theta, rho),\n                         funTransDrift(ld),\n                         funTransEdgeY(-theta, -rho), funTransSectY(-theta, -rho),\n                         funTransDrift(ld),\n                         funTransSectY(-theta, -rho), funTransEdgeY(-theta, -rho),\n                         funTransDrift(ld),\n                         funTransEdgeY(theta, rho), funTransSectY(theta, rho),\n                         funTransDrift(idril)])\n    if xoy == 'x':\n        m = mx\n    else:\n        m = my\n\n    return m"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the matrix of drift in the order of length and gamma.", "response": "def transDrift(length=0.0, gamma=None):\n    \"\"\" Transport matrix of drift\n\n    :param length: drift length in [m]\n    :param gamma: electron energy, gamma value\n    :return: 6x6 numpy array\n    \"\"\"\n    m = np.eye(6, 6, dtype=np.float64)\n    if length == 0.0:\n        print(\"warning: 'length' should be a positive float number.\")\n    elif gamma is not None and gamma != 0.0:\n        m[0, 1] = m[2, 3] = length\n        m[4, 5] = float(length) / gamma / gamma\n    else:\n        print(\"warning: 'gamma' should be a positive float number.\")\n    return m"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transQuad(length=0.0, k1=0.0, gamma=None):\n    m = np.eye(6, 6, dtype=np.float64)\n    if length == 0.0:\n        print(\"warning: 'length' should be a positive float number.\")\n    elif gamma is not None and gamma != 0.0:\n        if k1 == 0:\n            print(\"warning: 'k1' should be a positive float number.\")\n            m[0, 1] = m[2, 3] = 1.0\n            m[4, 5] = float(length) / gamma / gamma\n        else:\n            sqrtk = np.sqrt(complex(k1))\n            sqrtkl = sqrtk * length\n            m[0, 0] = m[1, 1] = (np.cos(sqrtkl)).real\n            m[0, 1] = (np.sin(sqrtkl) / sqrtk).real\n            m[1, 0] = (-np.sin(sqrtkl) * sqrtk).real\n            m[2, 2] = m[3, 3] = (np.cosh(sqrtkl)).real\n            m[2, 3] = (np.sinh(sqrtkl) / sqrtk).real\n            m[3, 2] = (-np.sinh(sqrtkl) * sqrtk).real\n            m[4, 5] = float(length) / gamma / gamma\n    else:\n        print(\"warning: 'gamma' should be a positive float number.\")\n    return m", "response": "This function returns the transport matrix of quadrupole in the form of a 6x6 numpy array."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntransports matrix of sector dipole", "response": "def transSect(theta=None, rho=None, gamma=None):\n    \"\"\" Transport matrix of sector dipole\n\n    :param theta: bending angle in [RAD]\n    :param rho: bending radius in [m]\n    :param gamma: electron energy, gamma value\n    :return: 6x6 numpy array\n    \"\"\"\n    m = np.eye(6, 6, dtype=np.float64)\n    if None in (theta, rho, gamma):\n        print(\"warning: 'theta', 'rho', 'gamma' should be positive float numbers.\")\n        return m\n    else:\n        rc = rho * np.cos(theta)\n        rs = rho * np.sin(theta)\n        m[0, 0] = m[1, 1] = rc / rho\n        m[0, 1] = rs\n        m[0, 5] = rho - rc\n        m[1, 0] = -np.sin(theta) / rho\n        m[1, 5] = rs / rho\n        m[2, 3] = rho * np.sin(theta)\n        m[4, 0] = m[1, 5]\n        m[4, 1] = m[0, 5]\n        m[4, 5] = rho * np.sin(theta) / gamma / gamma - rho * theta + rs\n        return m"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntransporting matrix of rectangle dipole :param theta: bending angle in [RAD] :param incsym: incident symmetry, -1 by default, available options: * -1: left half symmetry, * 0: full symmetry, * 1: right half symmetry :param rho: bending radius in [m] :param gamma: electron energy, gamma value :return: 6x6 numpy array", "response": "def transRbend(theta=None, rho=None, gamma=None, incsym=-1):\n    \"\"\" Transport matrix of rectangle dipole\n\n    :param theta: bending angle in [RAD]\n    :param incsym: incident symmetry, -1 by default,\n        available options:\n            * -1: left half symmetry,\n            * 0: full symmetry,\n            * 1: right half symmetry\n    :param rho: bending radius in [m]\n    :param gamma: electron energy, gamma value\n    :return: 6x6 numpy array\n    \"\"\"\n    if None in (theta, rho, gamma):\n        print(\"warning: 'theta', 'rho', 'gamma' should be positive float numbers.\")\n        m = np.eye(6, 6, dtype=np.float64)\n        return m\n    else:\n        beta12d = {'-1': (0, theta), '0': (theta * 0.5, theta * 0.5), '1': (theta, 0)}\n        (beta1, beta2) = beta12d[str(incsym)]\n        mf1 = transFringe(beta=beta1, rho=rho)\n        mf2 = transFringe(beta=beta2, rho=rho)\n        ms = transSect(theta=theta, rho=rho, gamma=gamma)\n        m = reduce(np.dot, [mf1, ms, mf2])\n        return m"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the matrix of fringe field.", "response": "def transFringe(beta=None, rho=None):\n    \"\"\" Transport matrix of fringe field\n\n    :param beta: angle of rotation of pole-face in [RAD]\n    :param rho: bending radius in [m]\n    :return: 6x6 numpy array\n    \"\"\"\n    m = np.eye(6, 6, dtype=np.float64)\n    if None in (beta, rho):\n        print(\"warning: 'theta', 'rho' should be positive float numbers.\")\n        return m\n    else:\n        m[1, 0] = np.tan(beta) / rho\n        m[3, 2] = -np.tan(beta) / rho\n        return m"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef transChicane(bend_length=None, bend_field=None, drift_length=None, gamma=None):\n    if None in (bend_length, bend_field, drift_length, gamma):\n        print(\"warning: 'bend_length', 'bend_field', 'drift_length', 'gamma' should be positive float numbers.\")\n        m = np.eye(6, 6, dtype=np.float64)\n        return m\n    else:\n        if isinstance(drift_length, tuple) or isinstance(drift_length, list):\n            if len(drift_length) == 1:\n                dflist = drift_length * 3\n            elif len(drift_length) == 2:\n                dflist = []\n                dflist.extend(drift_length)\n                dflist.append(drift_length[0])\n            elif len(drift_length) >= 3:\n                dflist = drift_length[0:3]\n                if dflist[0] != dflist[-1]:\n                    print(\"warning: chicane is not symmetric.\")\n            else:\n                print(\"drift_length is not a valid list or tuple.\")\n        else:\n            dflist = []\n            dflist.extend([drift_length, drift_length, drift_length])\n\n        m0 = 9.10938215e-31\n        e0 = 1.602176487e-19\n        c0 = 299792458.0\n        rho = np.sqrt(gamma ** 2 - 1) * m0 * c0 / bend_field / e0\n        theta = np.arcsin(bend_length / rho)\n\n        m_rb_1 = transRbend(theta, rho, gamma, -1)\n        m_rb_2 = transRbend(-theta, -rho, gamma, 1)\n        m_rb_3 = transRbend(-theta, -rho, gamma, -1)\n        m_rb_4 = transRbend(theta, rho, gamma, 1)\n        m_df_12 = transDrift(dflist[0], gamma)\n        m_df_23 = transDrift(dflist[1], gamma)\n        m_df_34 = transDrift(dflist[2], gamma)\n\n        m = reduce(np.dot, [m_rb_1, m_df_12, m_rb_2, m_df_23, m_rb_3, m_df_34, m_rb_4])\n        return m", "response": "This function returns the transport matrix of chicane in the system."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset chicane parameters :param bend_length: bend length, [m] :param bend_field: bend field, [T] :param drift_length: drift length, [m], list :param gamma: electron energy, gamma :return: None", "response": "def setParams(self, bend_length, bend_field, drift_length, gamma):\n        \"\"\" set chicane parameters\n\n        :param bend_length: bend length, [m]\n        :param bend_field: bend field, [T]\n        :param drift_length: drift length, [m], list\n        :param gamma: electron energy, gamma\n        :return: None\n        \"\"\"\n        if None in (bend_length, bend_field, drift_length, gamma):\n            print(\"warning: 'bend_length', 'bend_field', 'drift_length', 'gamma' should be positive float numbers.\")\n            self.mflag = False\n        else:\n            self._setDriftList(drift_length)\n            self.gamma = gamma\n            self.bend_length = bend_length\n            self.bend_field = bend_field"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _setDriftList(self, drift_length):\n        if isinstance(drift_length, tuple) or isinstance(drift_length, list):\n            if len(drift_length) == 1:\n                self.dflist = drift_length * 3\n            elif len(drift_length) == 2:\n                self.dflist = []\n                self.dflist.extend(drift_length)\n                self.dflist.append(drift_length[0])\n            elif len(drift_length) >= 3:\n                self.dflist = drift_length[0:3]\n                if self.dflist[0] != self.dflist[-1]:\n                    print(\"warning: chicane is not symmetric.\")\n            else:\n                print(\"drift_length is not a valid list or tuple.\")\n                self.mflag = False\n        else:\n            self.dflist = []\n            self.dflist.extend([drift_length, drift_length, drift_length])", "response": "set the drift length list of three elements in the system"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getMatrix(self):\n        if self.mflag:\n            m0 = 9.10938215e-31\n            e0 = 1.602176487e-19\n            c0 = 299792458.0\n            rho = np.sqrt(self.gamma ** 2 - 1) * m0 * c0 / self.bend_field / e0\n            theta = np.arcsin(self.bend_length / rho)\n            self.bangle = theta\n\n            m_rb_1 = transRbend(theta, rho, self.gamma, -1)\n            m_rb_2 = transRbend(-theta, -rho, self.gamma, 1)\n            m_rb_3 = transRbend(-theta, -rho, self.gamma, -1)\n            m_rb_4 = transRbend(theta, rho, self.gamma, 1)\n            m_df_12 = transDrift(self.dflist[0], self.gamma)\n            m_df_23 = transDrift(self.dflist[1], self.gamma)\n            m_df_34 = transDrift(self.dflist[2], self.gamma)\n\n            self.transM = reduce(np.dot, [m_rb_1, m_df_12, m_rb_2, m_df_23, m_rb_3, m_df_34, m_rb_4])\n\n            return self.transM", "response": "get transport matrix with mflag flag"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn bend angle in degree or rad", "response": "def getAngle(self, mode='deg'):\n        \"\"\" return bend angle\n\n        :param mode: 'deg' or 'rad'\n        :return: deflecting angle in RAD\n        \"\"\"\n        if self.refresh is True:\n            self.getMatrix()\n\n        try:\n            if self.mflag:\n                if mode == 'deg':\n                    return self.bangle / np.pi * 180\n                else:  # rad\n                    return self.bangle\n            else:\n                return 0\n        except AttributeError:\n            print(\"Please execute getMatrix() first.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getR(self, i=5, j=6):\n        if self.refresh is True:\n            self.getMatrix()\n        return self.transM[i - 1, j - 1]", "response": "return transport matrix element, indexed by i, j,\n        be default, return dispersion value, i.e. getR(5,6) in [m]\n\n        :param i: row index, with initial index of 1\n        :param j: col indx, with initial index of 1\n        :return: transport matrix element"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setBendLength(self, x):\n        if x != self.bend_length:\n            self.bend_length = x\n            self.refresh = True", "response": "set bend length\n\n        :param x: new bend length to be assigned, [m]\n        :return: None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets bend magnetic field", "response": "def setBendField(self, x):\n        \"\"\" set bend magnetic field\n\n        :param x: new bend field to be assigned, [T]\n        :return: None\n        \"\"\"\n        if x != self.bend_field:\n            self.bend_field = x\n            self.refresh = True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting lengths for drift sections", "response": "def setDriftLength(self, x):\n        \"\"\" set lengths for drift sections\n\n        :param x: single double or list\n        :return: None\n\n        :Example:\n\n        >>> import beamline\n        >>> chi = beamline.mathutils.Chicane(bend_length=1,bend_field=0.5,drift_length=1,gamma=1000)\n        >>> chi.getMatrix()\n        >>> r56 = chi.getR(5,6)  # r56 = -0.432\n        >>> chi.setDriftLength([2,4,2])\n        >>> # same effect (to R56) as ``chi.setDriftLength([2,4])`` or ``chi.setDriftLength([2])``\n        >>> # or ``chi.setDriftLength(2)``\n        >>> r56 = chi.getR(5,6)  # r56 = -0.620\n        \"\"\"\n        if x != self.getDriftLength():\n            self._setDriftList(x)\n            self.refresh = True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setGamma(self, x):\n        if x != self.gamma:\n            self.gamma = x\n            self.refresh = True", "response": "set electron energy gamma value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _is_valid_extension(extension):\n    if not cfg.CONF.valid_extensions:\n        return True\n\n    valid = False\n    for cext in cfg.CONF.valid_extensions:\n        if not cext.startswith('.'):\n            cext = '.%s' % cext\n        if extension == cext:\n            valid = True\n            break\n\n    return valid", "response": "Checks if the file extension is blacklisted in the list of valid_extensions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the filename matches filename_blacklist", "response": "def _is_blacklisted_filename(filepath):\n    \"\"\"Checks if the filename matches filename_blacklist\n\n    blacklist is a list of filenames(str) and/or file patterns(dict)\n\n    string, specifying an exact filename to ignore\n    [\".DS_Store\", \"Thumbs.db\"]\n\n    mapping(dict), where each dict contains:\n        'match' - (if the filename matches the pattern, the filename\n        is blacklisted)\n\n        'is_regex' - if True, the pattern is treated as a\n        regex. If False, simple substring check is used (if\n        'match' in filename). Default is False\n\n        'full_path' - if True, full path is checked. If False, only\n        filename is checked. Default is False.\n\n        'exclude_extension' - if True, the extension is removed\n        from the file before checking. Default is False.\n\n    :param str filepath: an absolute path and filename to check against\n                         the blacklist\n    :returns: flag indicating if the file was matched in the blacklist\n    :rtype: bool\n    \"\"\"\n\n    if not cfg.CONF.filename_blacklist:\n        return False\n\n    filename = os.path.basename(filepath)\n    fname = os.path.splitext(filename)[0]\n\n    blacklisted = False\n    for fblacklist in cfg.CONF.filename_blacklist:\n\n        if isinstance(fblacklist, dict):\n            to_check = filename\n            if fblacklist.get('exclude_extension', False):\n                to_check = fname\n            if fblacklist.get('full_path', False):\n                to_check = filepath\n\n            if fblacklist.get('is_regex', False):\n                blacklisted = re.match(fblacklist['match'],\n                                       to_check) is not None\n            else:\n                blacklisted = (fblacklist['match'] in to_check)\n        else:\n            blacklisted = (filename == fblacklist)\n\n        if blacklisted:\n            break\n\n    return blacklisted"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef retrieve_files():\n\n    all_files = []\n    for location in cfg.CONF.locations or []:\n        # if local path then make sure it is absolute\n        if not location.startswith('\\\\'):\n            location = os.path.abspath(os.path.expanduser(location))\n\n        LOG.debug('searching [%s]', location)\n        for root, _, files in os.walk(location):\n            LOG.debug('found file(s) %s', files)\n            for name in files:\n                filepath = os.path.join(root, name)\n                if (os.access(filepath, os.R_OK) and\n                        not _is_blacklisted_filename(filepath) and\n                        _is_valid_extension(os.path.splitext(name)[1])):\n                    all_files.append(filepath)\n\n    return all_files", "response": "Retrieve the list of files found in the provided locations."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an embed field value based on the parameters.", "response": "def process_embed(embed_items=None,\n                  embed_tracks=None,\n                  embed_metadata=None,\n                  embed_insights=None):\n    \"\"\"Returns an embed field value based on the parameters.\"\"\"\n\n    result = None\n\n    embed = ''\n    if embed_items:\n        embed = 'items'\n    if embed_tracks:\n        if embed != '':\n            embed += ','\n        embed += 'tracks'\n    if embed_metadata:\n        if embed != '':\n            embed += ','\n        embed += 'metadata'\n    if embed_insights:\n        if embed != '':\n            embed += ','\n        embed += 'insights'\n\n    if embed != '':\n        result = embed\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_embed_override(href_embed=None,\n                           embed_items=None,\n                           embed_tracks=None,\n                           embed_metadata=None,\n                           embed_insights=None):\n    \"\"\"Returns an embed field value based on the parameters.\"\"\"\n    # Our defaults are None, which are the API defaults.\n    final_items = None\n    final_tracks = None\n    final_metadata = None\n    final_insights = None\n\n    # First, figure out what was embedded in the original href.\n    # If any of the embeds are there, flip the final to True\n    if href_embed:\n        if 'items' in href_embed:\n            final_items = True\n        if 'tracks' in href_embed:\n            final_tracks = True\n        if 'metadata' in href_embed:\n            final_metadata = True\n        if 'insights' in href_embed:\n            final_insights = True\n\n    # Second, override the what we have.\n    # None >> Do nothing\n    # True >> Set to True\n    # False >> Set to None\n    if embed_items is not None:\n        if embed_items is True:\n            final_items = True\n        else:\n            final_items = None\n    if embed_tracks is not None:\n        if embed_tracks is True:\n            final_tracks = True\n        else:\n            final_tracks = None\n    if embed_metadata is not None:\n        if embed_metadata is True:\n            final_metadata = True\n        else:\n            final_metadata = None\n    if embed_insights is not None:\n        if embed_insights is True:\n            final_insights = True\n        else:\n            final_insights = None\n\n    return process_embed(embed_items=final_items,\n                         embed_tracks=final_tracks,\n                         embed_metadata=final_metadata,\n                         embed_insights=final_insights)", "response": "Returns an embed field value based on the parameters."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving a result_collection returns a list of embedded items with each item in the returned list as a result object.", "response": "def get_embedded_items(result_collection):\n    \"\"\"\n    Given a result_collection (returned by a previous API call that\n    returns a collection, like get_bundle_list() or search()), return a\n    list of embedded items with each item in the returned list\n    considered a result object.\n\n    'result_collection' a JSON object returned by a previous API\n    call. The parameter 'embed_items' must have been True when the\n    result_collection was originally requested.May not be None.\n\n    Returns a list, which may be empty if no embedded items were found.\n    \"\"\"\n\n    # Argument error checking.\n    assert result_collection is not None\n\n    result = []\n\n    embedded_objects = result_collection.get('_embedded')\n    if embedded_objects is not None:\n        # Handle being passed a non-collection gracefully.\n        result = embedded_objects.get('items', result)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_item_hrefs(result_collection):\n\n    # Argument error checking.\n    assert result_collection is not None\n\n    result = []\n\n    links = result_collection.get('_links')\n    if links is not None:\n        items = links.get('items')\n        if items is not None:\n            for item in items:\n                result.append(item.get('href'))\n\n    return result", "response": "Given a result_collection returns a list of item hrefs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_link_href(result_object, link_relation):\n\n    # Argument error checking.\n    assert result_object is not None\n\n    result = None\n\n    link = result_object['_links'].get(link_relation)\n    if link:\n        result = link.get('href')\n\n    return result", "response": "Given a result_object returns the link href for a link relation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_embedded(result_object, link_relation):\n\n    # Argument error checking.\n    assert result_object is not None\n    assert link_relation is not None\n\n    result = None\n\n    embedded_object = result_object['_embedded']\n    if embedded_object:\n        result = embedded_object.get(link_relation)\n\n    return result", "response": "Given a result_object returns the embedded object for link_relation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef notifiers_stack_padding(self, value):\n\n        if value is not None:\n            assert type(value) is int, \"'{0}' attribute: '{1}' type is not 'int'!\".format(\"notifiers_stack_padding\",\n                                                                                          value)\n            assert value >= 0, \"'{0}' attribute: '{1}' need to be positive!\".format(\"notifiers_stack_padding\", value)\n        self.__notifiers_stack_padding = value", "response": "Setter for **self. notifiers_stack_padding** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncorrespond to IDD Field maximum_notifiers", "response": "def maximum_notifiers(self, value):\n        \"\"\"\n        Setter for **self.__maximum_notifiers** attribute.\n\n        :param value: Attribute value.\n        :type value: int\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is int, \"'{0}' attribute: '{1}' type is not 'int'!\".format(\"maximum_notifiers\",\n                                                                                          value)\n            assert value > 0, \"'{0}' attribute: '{1}' need to be exactly positive!\".format(\"maximum_notifiers\", value)\n        self.__maximum_notifiers = value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\noffsetting existing notifiers. :param offset: Offset. :type offset: int", "response": "def __offset_notifiers(self, offset):\n        \"\"\"\n        Offsets existing notifiers.\n\n        :param offset: Offset.\n        :type offset: int\n        \"\"\"\n\n        overall_offset = offset\n        for notifier in self.__notifiers:\n            notifier.vertical_offset = overall_offset\n            notifier.refresh_position()\n            overall_offset += offset"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_notification(self, notification):\n\n        LOGGER.debug(\"> Registering notification: '{0}'.\".format(notification))\n\n        self.__notifications.append(notification)\n        self.notification_registered.emit(notification)\n        return True", "response": "Registers given notification.\n\n        :param notification: Notification to register.\n        :type notification: Notification\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat given notification. :param notification: Notification to format. :type notification: Notification :return: Method success. :rtype: bool", "response": "def format_notification(self, notification):\n        \"\"\"\n        Formats given notification.\n\n        :param notification: Notification to format.\n        :type notification: Notification\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        return \"{0} | '{1}'\".format(time.ctime(notification.time), notification.message)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndisplay an Application notification.", "response": "def notify(self, message, duration=3000, notification_clicked_slot=None, message_level=\"Information\", **kwargs):\n        \"\"\"\n        Displays an Application notification.\n\n        :param message: Notification message.\n        :type message: unicode\n        :param duration: Notification display duration.\n        :type duration: int\n        :param notification_clicked_slot: Notification clicked slot.\n        :type notification_clicked_slot: object\n        :param message_level: Message level ( \"Information\", \"Warning\", \"Exception\" ).\n        :type message_level: unicode\n        :param \\*\\*kwargs: Keywords arguments.\n        :type \\*\\*kwargs: \\*\\*\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        for notifier in self.__notifiers[self.__maximum_notifiers - 1:]:\n            notifier.duration = 150\n            notifier.hide_message()\n\n        notification = Notification(message=message, time=time.time())\n\n        self.register_notification(notification)\n\n        notifier = Notification_QLabel(self.__container, **kwargs)\n\n        # Signals / Slots.\n        notifier.faded_out.connect(self.__notifier__faded_out)\n        self.__container.size_changed.connect(notifier.resizeEvent)\n        if notification_clicked_slot:\n            notifier.notification_clicked.connect(notification_clicked_slot)\n        else:\n            notifier.setAttribute(Qt.WA_TransparentForMouseEvents)\n\n        notifier.show_message(message, duration)\n\n        self.__offset_notifiers(-notifier.height() - self.__notifiers_stack_padding)\n        self.__notifiers.insert(0, notifier)\n\n        if message_level == \"Information\":\n            LOGGER.info(\"{0} | '{1}'.\".format(self.__class__.__name__, self.format_notification(notification)))\n        elif message_level == \"Warning\":\n            LOGGER.warning(\"!> {0} | '{1}'.\".format(self.__class__.__name__, self.format_notification(notification)))\n        elif message_level == \"Exception\":\n            LOGGER.error(\"!> {0} | '{1}'.\".format(self.__class__.__name__, self.format_notification(notification)))\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisplay an Application notification warning.", "response": "def warnify(self, message, duration=3000, notification_clicked_slot=None, **kwargs):\n        \"\"\"\n        Displays an Application notification warning.\n\n        :param message: Notification message.\n        :type message: unicode\n        :param duration: Notification display duration.\n        :type duration: int\n        :param notification_clicked_slot: Notification clicked slot.\n        :type notification_clicked_slot: object\n        :param \\*\\*kwargs: Keywords arguments.\n        :type \\*\\*kwargs: \\*\\*\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        return self.notify(message,\n                           duration,\n                           notification_clicked_slot,\n                           message_level=\"Warning\",\n                           color=QColor(220, 128, 64),\n                           background_color=QColor(32, 32, 32),\n                           border_color=QColor(220, 128, 64),\n                           **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef has_data(d, fullname):\n    fullname = r'%s-' % (fullname, )\n    for k in d:\n        if not k.startswith(fullname):\n            continue\n        return True\n    return False", "response": "Test if any of the keys of d starts with fullname."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the n - index form where index is 1 - based.", "response": "def get_form(self, index):\n        \"\"\"Returns the n-index form, where index is 1-based.\n        the form'll be filled with data if it exists or empty if not\n        \"\"\"\n        index = max(1, index)\n        if len(self._forms) >= index:\n            return self._forms[index - 1]\n        return self.get_empty_form(index)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _find_new_forms(self, forms, num, data, files, locale, tz):\n        fullname = self._get_fullname(num)\n        while has_data(data, fullname) or has_data(files, fullname):\n            f = self._form_class(\n                data, files=files, locale=locale, tz=tz,\n                prefix=fullname, backref=self._backref\n            )\n            forms.append(f)\n            num += 1\n            fullname = self._get_fullname(num)\n        return forms", "response": "Find new forms in the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting ownership of the user.", "response": "def ownership(self, ownership):\n        \"\"\"\n        A list of dictionaries in format {'party_id': 'XYZ', 'split': Decimal('0.5')}\n        :param ownership:\n        :return:\n        \"\"\"\n        error_msg = 'ownership must be a list of dictionaries'\n        if ownership:\n            if not isinstance(ownership, list):\n                raise TypeError(error_msg)\n            if not all([isinstance(item, dict) for item in ownership]):\n                raise TypeError(error_msg)\n            if not all([item.get('party_id') for item in ownership]):\n                raise ValueError('Ownership missing one or more party_ids')\n            if not all([item.get('split') for item in ownership]):\n                raise ValueError('Ownership missing one or more splits')\n            if sum([item.get('split') for item in ownership]) != Decimal('1'):\n                raise ValueError('Ownership must sum up to 100%')\n        self._ownership = ownership"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates given **Active_QLabel| Widget siblings states.", "response": "def __update_siblings_active_labels_states(self, active_label):\n        \"\"\"\n        Updates given **Active_QLabel** Widget siblings states.\n\n        :param active_label: Active label.\n        :type active_label: Active_QLabel\n        \"\"\"\n\n        LOGGER.debug(\"> Clicked 'Active_QLabel': '{0}'.\".format(active_label))\n\n        for item in self.__active_labels:\n            if item is active_label:\n                continue\n\n            umbra.ui.common.signals_blocker(item, item.set_checked, False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_active_label(self, active_label):\n\n        if not issubclass(active_label.__class__, Active_QLabel):\n            raise foundations.exceptions.ProgrammingError(\"{0} | '{1}' must be a '{2}' subclass!\".format(\n                self.__class__.__name__, active_label, Active_QLabel.__name__))\n\n        if active_label in self.__active_labels:\n            raise foundations.exceptions.ProgrammingError(\"{0} | '{1}' is already in the collection!\".format(\n                self.__class__.__name__, active_label))\n\n        active_label.checkable = True\n        not self.__active_labels and active_label.set_checked(True) or active_label.set_checked(False)\n        self.__active_labels.append(active_label)\n\n        # Signals / Slots.\n        active_label.toggled.connect(functools.partial(self.__active_label__toggled, active_label))\n\n        active_label.clicked.connect(functools.partial(self.active_label_clicked.emit, active_label))\n        active_label.pressed.connect(functools.partial(self.active_label_pressed.emit, active_label))\n        active_label.released.connect(functools.partial(self.active_label_released.emit, active_label))\n        active_label.toggled.connect(functools.partial(self.active_label_toggled.emit, active_label))\n\n        return True", "response": "Adds given Active_QLabel to the collection."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves given Active_QLabel from the collection.", "response": "def remove_active_label(self, active_label):\n        \"\"\"\n        Removes given **Active_QLabel** Widget.\n\n        :param active_label: Active label to remove.\n        :type active_label: Active_QLabel\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if not active_label in self.__active_labels:\n            raise foundations.exceptions.ProgrammingError(\"{0} | '{1}' is not in the collection!\".format(\n                self.__class__.__name__, active_label))\n\n        self.__active_labels.remove(active_label)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_idxs(exprs):\n    idxs = set()\n    for expr in (exprs):\n        for i in expr.find(sympy.Idx):\n            idxs.add(i)\n    return sorted(idxs, key=str)", "response": "Finds sympy. tensor. indexed. Index instances and returns them."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef model1(inps, lims, logger=None):\n    a_arr, c_ = inps\n    ilim, jlim = lims\n\n    i_bs = sympy.symbols('i_lb i_ub', integer=True)\n    i = sympy.Idx('i', i_bs)\n\n    j_bs = sympy.symbols('j_lb j_ub', integer=True)\n    j = sympy.Idx('j', j_bs)\n\n    a = sympy.IndexedBase('a')\n\n    c = sympy.Symbol('c', real=True)\n\n    x = sympy.IndexedBase('x')\n    y = sympy.IndexedBase('y')\n\n    eqs = [\n        sympy.Eq(x[i], (a[i]/3-1)**i+c),\n        sympy.Eq(y[j], a[j]-j),\n    ]\n\n    ex_code = ExampleCode(eqs, (a[i], c), (i, j),\n                          logger=logger, save_temp=True)\n    x_, y_ = ex_code(inps, bounds=(ilim, jlim))\n    x_ref = (a_arr/3-1)**np.arange(ilim[0], ilim[1]) + c_\n    y_ref = a_arr[jlim[0]:jlim[1]] - np.arange(jlim[0], jlim[1])\n    assert np.allclose(x_, x_ref)\n    assert np.allclose(y_, y_ref)", "response": "A model of the first 3 - dimensional linear system."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild and md5sum from a file in chunks.", "response": "def _md5sum(file_path):\n    \"\"\" Helper function that builds and md5sum from a file in chunks.\n\n    Args:\n        file_path: The path to the file you want an md5sum for.\n\n    Returns:\n        A string containing an md5sum.\n\n    \"\"\"\n    md5 = hashlib.md5()\n\n    with open(file_path, \"rb\") as md5_file:\n        while True:\n            data = md5_file.read(1024 * 1024 * 4)\n            if not data:\n                break\n            md5.update(data)\n\n    return md5.digest()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreloading the modules from the current plugin_dirs attribute.", "response": "def reload(self):\n        \"\"\" Reloads modules from the current plugin_dirs.\n\n        This method will search the plugin_dirs attribute finding new plugin modules,\n        updating plugin modules that have changed, and unloading plugin modules that\n        no longer exist.\n\n        \"\"\"\n        logger.debug(\"Reloading Plugins...\")\n\n        deleted_modules = set(self.loaded_modules.keys())\n\n        for plugin_file in self._get_plugin_files(self.plugin_dirs):\n            if plugin_file not in self.loaded_modules:\n                logger.debug(\"New Plugin Module found. Loading: %s\", plugin_file)\n                self._load_plugin(plugin_file)\n            elif _md5sum(plugin_file) != self.loaded_modules[plugin_file].md5:\n                deleted_modules.remove(plugin_file)\n                logger.debug(\"Plugin Module changed. Reloading: %s\", plugin_file)\n                self._load_plugin(plugin_file)\n            else:\n                deleted_modules.remove(plugin_file)\n\n        for plugin_file in deleted_modules:\n            logger.debug(\"Plugin Module deleted. Removing: %s\", plugin_file)\n            del self.loaded_modules[plugin_file]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bind_type(python_value):\n    binding_table = {'bool': Bool, 'int': Int, 'float': Float}\n\n    if python_value is None:\n        return NoneType()\n\n    python_type = type(python_value)\n\n    gibica_type = binding_table.get(python_type.__name__)\n\n    if gibica_type is None:\n        raise TypeError('Impossible to recognize underlying type.')\n    return gibica_type(python_value)", "response": "Return a Gibica type derived from a Python type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _handle_type(self, other):\n        if isinstance(other, Int):\n            return Int\n        elif isinstance(other, Float):\n            return Float\n        else:\n            raise TypeError(\n                f\"Unsuported operation between `{type(self)}` and `{type(other)}`.\"\n            )", "response": "Helper to handle the return type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve an instance of the configured database API.", "response": "def dbapi(conf=cfg.CONF):\n    \"\"\"Retrieves an instance of the configured database API.\n\n    :param oslo_config.cfg.ConfigOpts conf: an instance of the configuration\n                                            file\n    :return: database API instance\n    :rtype: :class:`~tvrenamer.cache.api.DatabaseAPI`\n    \"\"\"\n    global _DBAPI\n\n    if _DBAPI is None:\n        _DBAPI = api.DatabaseAPI(conf)\n    return _DBAPI"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write(self):\n        io.debug(\"Storing cache '{0}'\".format(self.path))\n        with open(self.path, \"w\") as file:\n            json.dump(self._data, file, sort_keys=True, indent=2,\n                      separators=(',', ': '))", "response": "Write contents of the cache to disk."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the filesystem path for a key.", "response": "def keypath(self, key):\n        \"\"\"\n        Get the filesystem path for a key.\n\n        Arguments:\n            key: Key.\n\n        Returns:\n            str: Absolute path.\n        \"\"\"\n        return fs.path(self.path, self.escape_key(key))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates that overwrite and input and output directories are the same.", "response": "def validate_overwrite_different_input_output(opts):\n    \"\"\"\n    Make sure that if overwrite is set to False, the input and output folders\n    are not set to the same location.\n\n    :param opts: a namespace containing the attributes 'overwrite', 'input',\n        and 'output'\n    :raises ValidationException: if 'input' and 'output' point to the same\n        directory and 'overwrite' is set to False\n    :return: True if 'overwrite' is set to True, or 'input'/'output' are\n        separate directories\n    \"\"\"\n    if opts.overwrite or path.abspath(opts.input) != path.abspath(opts.output):\n        return True\n    else:\n        raise ValidationException(\"Input and output directories are the same, \"\n                                  \"but --overwrite / -X flag is not provided.\\n\"\n                                  \"Do you want to overwrite your input files? \"\n                                  \"If so, use the following command:\\n\"\n                                  \"\\tanchorhub -X \" + opts.input)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_app(app_id, app_name, source_id, region, app_data):\n    try:\n        create_at = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        conn = get_conn()\n        c = conn.cursor()\n\n        #check old app\n        c.execute(\"SELECT count(*) FROM app WHERE name='{0}' \".format(app_name))\n        old_app = c.fetchone()\n        if old_app[0] > 0:\n            print 'app name (%s) already existed, clear old app and container info ...' % app_name\n            c.execute(\"DELETE FROM container WHERE app_id='{0}'\".format(app_id))\n            c.execute(\"DELETE FROM app WHERE name='{0}'\".format(app_name))\n            conn.commit()\n\n        #insert new app\n        c.execute(\"INSERT INTO app (id,name,source_id,region,state,create_at,change_at,app_data) VALUES ('{0}','{1}','{2}','{3}','{4}','{5}','{6}','{7}')\"\n            .format(app_id, app_name, source_id, region, constant.STATE_APP_RUNNING, create_at, create_at, app_data))\n        conn.commit()\n        conn.close()\n        print 'create app %s succeed!' % app_id\n    except Exception, e:\n        raise RuntimeError('create app %s failed! %s' % (app_id,e))", "response": "create app record when stack run as a app"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting app info from local db", "response": "def delete_app_info(app_id):\n    \"\"\"\n    delete app info from local db\n    \"\"\"\n    try:\n        conn = get_conn()\n        c = conn.cursor()\n        c.execute(\"DELETE FROM container WHERE app_id='{0}'\".format(app_id))\n        c.execute(\"DELETE FROM app WHERE id='{0}'\".format(app_id))\n        conn.commit()\n        #print 'clear old app %s in db succeed!' % app_id\n    except Exception, e:\n        raise RuntimeError('clear old app %s in db failed! %s' % (app_id,e))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stop_app(app_id, is_finished=False):\n    state = constant.STATE_APP_STOPPED if is_finished else constant.STATE_APP_STOPPING\n    app_update_state(app_id, state)", "response": "update app state to 'Stopped'"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates app state to 'Running'", "response": "def start_app(app_id, is_finished=False):\n    \"\"\"\n    update app state to 'Running'\n    \"\"\"\n    state = constant.STATE_APP_RUNNING if is_finished else constant.STATE_APP_STARTING\n    app_update_state(app_id, state)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrestarting the app with the given id", "response": "def restart_app(app_id, is_finished=False):\n    \"\"\"\n    update app state to 'Running'\n    \"\"\"\n    state = constant.STATE_APP_RUNNING if is_finished else constant.STATE_APP_RESTARTING\n    app_update_state(app_id, state)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating app state to 'Terminated'", "response": "def terminate_app(app_id, is_finished=False):\n    \"\"\"\n    update app state to 'Terminated'\n    \"\"\"\n    state = constant.STATE_APP_TERMINATED if is_finished else constant.STATE_APP_TERMINATING\n    app_update_state(app_id, state)\n    if is_finished:\n        delete_app_info(app_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget local app list", "response": "def get_app_list(region_name=None,filter_name=None):\n    \"\"\"\n    get local app list\n    \"\"\"\n    try:\n        conn = get_conn()\n        c = conn.cursor()\n\n        cond = []\n        where_clause = \"\"\n        if region_name:\n            cond.append( \"region='{0}' \".format(region_name) )\n        if filter_name:\n            cond.append( \"lower(name) like '%{0}%' \".format(filter_name.lower()) )\n        if len(cond) > 0:\n            where_clause = 'and ' + 'and '.join( cond )\n\n        sqlcmd = \"SELECT name,source_id,region,state,create_at,change_at FROM app where state<>'Terminated' %s \" % where_clause\n        log = logging.getLogger(__name__)\n        log.debug('> sql : %s' % sqlcmd)\n\n        c.execute(sqlcmd)\n        rlt = c.fetchall()\n        conn.commit()\n        conn.close()\n\n        return rlt\n    except Exception,e:\n        raise RuntimeError('list app failed! %s ' % e)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate container record when create container", "response": "def create_container(app_id,container_id,container_name):\n    \"\"\"\n    insert container record when create container\n    \"\"\"\n    try:\n        conn = get_conn()\n        c = conn.cursor()\n        c.execute(\"INSERT INTO container (id,name,app_id) VALUES ('{0}','{1}','{2}')\"\n            .format(container_id,container_name,app_id))\n        conn.commit()\n        conn.close()\n        print 'create container %s succeed!' % app_id\n    except Exception,e :\n        raise RuntimeError('create container %s failed! %s' % (app_id,e))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget app info( exclude app_data )", "response": "def get_app_info(app_id):\n    \"\"\"\n    get app info( exclude app_data )\n    \"\"\"\n    try:\n        conn = get_conn()\n        c = conn.cursor()\n        c.execute(\"SELECT name,source_id,region,state,create_at,change_at FROM app WHERE id='{0}' \".format(app_id))\n        app_info = c.fetchone()\n        c.execute(\"SELECT app_data FROM app WHERE id='{0}' \".format(app_id))\n        app_data = c.fetchone()\n        c.execute(\"SELECT id,name,app_id FROM container WHERE app_id='{0}' \".format(app_id))\n        container_rlt = c.fetchall()\n        conn.close()\n        return (app_info, app_data, container_rlt)\n    except Exception,e:\n        raise RuntimeError('get app info failed! %s' % e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_app_data(app_id):\n    try:\n        conn = get_conn()\n        c = conn.cursor()\n        c.execute(\"SELECT id,name,app_data FROM app WHERE id='{0}' \".format(app_id))\n        result = c.fetchone()\n        conn.close()\n\n        if result:\n            appname = result[1]\n            app_data = utils.str2dict( base64.b64decode(result[2]) )\n\n            return (appname,app_data)\n        else:\n            return (None,None)\n\n    except Exception,e:\n        raise RuntimeError('get app data failed! %s' % e)", "response": "get app data ( include name and app_data )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprovide a copy of this player s attributes as a dictionary", "response": "def attrs(self):\n        \"\"\"provide a copy of this player's attributes as a dictionary\"\"\"\n        ret = dict(self.__dict__) # obtain copy of internal __dict__\n        del ret[\"_matches\"] # match history is specifically distinguished from player information (and stored separately)\n        if self.type != c.COMPUTER: # difficulty only matters for computer playres\n            del ret[\"difficulty\"]\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef simpleAttrs(self):\n        simpleAttrs = {}\n        for k,v in iteritems(self.attrs):\n            if k in [\"_matches\"]: continue # attributes to specifically ignore\n            try:    simpleAttrs[k] = v.type\n            except: simpleAttrs[k] = v\n        return simpleAttrs", "response": "provide a copy of this player s attributes as a dictionary but with objects flattened into a string representation of the object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprove that all attributes are defined appropriately", "response": "def _validateAttrs(self, keys):\n        \"\"\"prove that all attributes are defined appropriately\"\"\"\n        badAttrs = []\n        for k in keys:\n            if k not in self.__dict__:\n                badAttrs.append(\"Attribute key '%s' is not a valid attribute\"%(k))\n        badAttrsMsg = os.linesep.join(badAttrs)\n        if not keys: return # is iterable, but didn't contain any keys\n        if badAttrsMsg:\n            raise ValueError(\"Encountered invalid attributes.  ALLOWED: %s%s%s\"\\\n                %(list(self.__dict__), os.linesep, badAttrsMsg))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load(self, playerName=None):\n        if playerName: # switch the PlayerRecord this object describes\n            self.name = playerName # preset value to load self.filename\n        try:\n            with open(self.filename, \"rb\") as f:\n                data = f.read()\n        except Exception:\n            raise ValueError(\"invalid profile, '%s'. file does not exist: %s\"%(self.name, self.filename))\n        self.update(json.loads(data))\n        self._matches = [] # mandate match history be recalculated for this newly loaded player", "response": "retrieve the PlayerRecord settings from saved disk file"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save(self):\n        data = str.encode( json.dumps(self.simpleAttrs, indent=4, sort_keys=True) )\n        with open(self.filename, \"wb\") as f:\n            f.write(data)", "response": "save PlayerRecord settings to disk"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate attributes initialized with the proper type", "response": "def update(self, attrs):\n        \"\"\"update attributes initialized with the proper type\"\"\"\n        ########################################################################\n        def convertStrToDict(strVal):\n            if isinstance(strVal, dict): return strVal\n            strVal = re.sub(\"[\\{\\}]+\", \"\", str(strVal))\n            regexCol = re.compile(\":\")\n            terms = re.split(\"[,\\s]+\", strVal)\n            keyvals = [re.split(regexCol, t) for t in terms]\n            x = re.compile(\"['\\\"]\")\n            ret = {}\n            boolTrue  = re.compile(\"true\" , flags=re.IGNORECASE)\n            boolFalse = re.compile(\"false\", flags=re.IGNORECASE)\n            for k, v in keyvals:\n                k = re.sub(x, \"\", k)\n                v = re.sub(x, \"\", v)\n                if   re.search(boolTrue, v):    v = True\n                elif re.search(boolFalse, v):   v = False\n                else:\n                    if '.' in v:\n                        try:                    v = float(v)\n                        except:                 pass\n                    else:\n                        try:                    v = int(v)\n                        except:                 pass\n                ret[k] = v\n            return ret\n        ########################################################################\n        self._validateAttrs(attrs)\n        for k,v in iteritems(attrs):\n            typecast = type( getattr(self, k) )\n            if typecast==bool and v==\"False\":   newval = False # \"False\" evalued as boolean is True because its length > 0\n            elif issubclass(typecast, c.RestrictedType): # let the RestrictedType handle the type setting, value matching\n                                                newval = typecast(v)\n            elif \"<\" in str(v) or v==None:      newval = typecast(v)\n            elif k == \"initCmd\":                newval = str(v) # specifically don't mangle the command as specified\n            elif k == \"initOptions\":            newval = convertStrToDict(v)\n            else:                               newval = typecast(str(v).lower())\n            setattr(self, k, newval)\n        if self.isComputer: pass\n        elif \"difficulty\" in attrs and attrs[\"difficulty\"]!=None: # the final state of this PlayerRecord cannot be a non-computer and specify a difficulty\n            raise ValueError(\"%s type %s=%s does not have a difficulty\"%(\n                self.__class__.__name__, self.type.__class__.__name__, self.type.type))\n        else: self.difficulty = c.ComputerDifficulties(None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nextracts matches from player s entire match history given matching criteria kwargs", "response": "def matchSubset(**kwargs):\n        \"\"\"extract matches from player's entire match history given matching criteria kwargs\"\"\"\n        ret = []\n        for m in self.matches:\n            allMatched = True\n            for k,v in iteritems(kwargs):\n                mVal = getattr(m, k)\n                try:\n                    if v == mVal or v in mVal: continue # this check passed\n                except Exception: pass # if attempting to check __contains__ and exception is raised, it's assumed to be false\n                allMatched = False\n                break\n            if allMatched: ret.append(m)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef apmRecent(self, maxMatches=c.RECENT_MATCHES, **criteria):\n        if not self.matches: return 0 # no apm information without match history\n        #try:        maxMatches = criteria[\"maxMatches\"]\n        #except:     maxMatches = c.RECENT_MATCHES\n        apms = [m.apm(self) for m in self.recentMatches(maxMatches=maxMatches, **criteria)]\n        return sum(apms) / len(apms)", "response": "collect recent match history s apm data to report player s calculated MMR"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\naggregate all match history s apm data to report player s calculated MMR", "response": "def apmAggregate(self, **criteria):\n        \"\"\"collect all match history's apm data to report player's calculated MMR\"\"\"\n        apms = [m.apm(self) for m in self.matchSubset(**criteria)]\n        if not apms: return 0 # no apm information without match history\n        return sum(apms) / len(apms)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nidentifying all recent matches for player given optional additional criteria", "response": "def recentMatches(self, **criteria):\n        \"\"\"identify all recent matches for player given optional, additional criteria\"\"\"\n        if not self.matches: return [] # no match history\n        try: # maxMatches is a specially handled parameter (not true criteria)\n            maxMatches = criteria[\"maxMatches\"]\n            del criteria[\"maxMatches\"]\n        except AttributeError:\n            maxMatches = c.RECENT_MATCHES\n        alLMatches = self.matchSubset(**criteria)\n        matchTimes = [(m.endTime, m) for m in matches]\n        selMatches = sorted(matchTimes)[:maxMatches] # slice off X most recet matches\n        retMatches = [m for endTime,m in selMatches] # extract matches only\n        return retMatches"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreplaces a password part of a URL with *****.", "response": "def hide_url_password(url):\n    \"\"\"Replace a password part of a URL with *****.\n\n    This can be used to scrub URLs before logging them.\n    \"\"\"\n    try:\n        parsed = parse.urlsplit(url)\n        if parsed.password:\n            return url.replace(':%s@' % parsed.password, ':*****@')\n    except Exception:  # pylint: disable=W0703\n        pass\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a URL and return the html code and charset", "response": "def get_url(url):\n    \"\"\"\u83b7\u53d6url\u5730\u5740\u5e76\u6839\u636e\u7f51\u9875\u7f16\u7801\u683c\u5f0f\u81ea\u52a8\u89e3\u6790\n\n    Keyword arguments:\n    url                    -- \u7528\u6237\u4f20\u5165\u5730\u5740\uff0c\u5934\u90e8\u5fc5\u987b\u542b\u6709http\uff1a//\n    Return:\n        \u7f51\u9875\u6e90\u4ee3\u7801\uff08\u4e3a\u4e86\u4e0b\u4e00\u6b65\u9884\u5904\u7406\u65b9\u4fbf\uff0c\u6240\u6709\u82f1\u6587\u5b57\u6bcd\u8f6c\u6362\u4e3a\u5c0f\u5199\uff09\n        \u7f51\u9875\u7f16\u89e3\u7801\n    \"\"\"\n\n    r = requests.get(url)\n    charset = r.apparent_encoding\n    r.encoding = charset\n    html_code = r.text.lower()\n\n    log('debg', '\u83b7\u53d6\u3010{}\u3011\u6210\u529f\uff0c\u7f51\u9875\u7f16\u7801\u683c\u5f0f\u4e3a\uff1a\u3010{}\u3011'.format(url, charset))\n    return html_code, charset"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions to clean html_code", "response": "def html_clean(html_code):\n    \"\"\"\u83b7\u53d6\u7f51\u9875\u6e90\u4ee3\u7801\u5e76\u8fdb\u884c\u9884\u5904\u7406\n\n    Keyword arguments:\n    html_code           -- \u7f51\u9875\u6e90\u4ee3\u7801\uff0c\u5b57\u7b26\u4e32\u7c7b\u578b\n    Return:\n        \u6e05\u6d17\u540e\u7684\u7f51\u9875\u6e90\u4ee3\u7801\uff08\u53ea\u5305\u542b\u6587\u672c\u548c\u6362\u884c\u7b26\\n\uff09\n    \"\"\"\n    temp = re.sub('<script([\\s\\S]*?)</script>', '', html_code)\n    temp = re.sub('<style([\\s\\S]*?)</style>', '', temp)\n    html_cleaned = re.sub('(?is)<.*?>', '', temp)\n    for item in html_character:\n        html_cleaned = html_cleaned.replace(item, html_character[item])\n\n    log('debug', '\u7f51\u9875\u6e90\u4ee3\u7801\u9884\u5904\u7406\u5b8c\u6210\uff1a\\n\u3010{}\u3011'.format(html_cleaned))\n    return html_cleaned"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the intersection of fake_title and unit.", "response": "def intersection(fake_title, unit):\n    \"\"\"\u5bf9\u4e24\u4e2alist\u6c42\u4ea4\u96c6\uff0c\u5e76\u8fd4\u56de\u76f8\u540c\u5143\u7d20\u7684\u4e2a\u6570\n\n    Keyword arguments:\n    fake_title, unit            -- \u5217\u8868\u7c7b\u578b\n    Return:\n        \u76f8\u540c\u5143\u7d20\u7684\u4e2a\u6570\n    \"\"\"\n    same = 0\n    for i in fake_title:\n        if i in unit:\n            same += 1\n    return same"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndropping stopwords from list", "response": "def drop_stopwords(list):\n    \"\"\"\u53bb\u505c\u8bcd\n\n    Keyword arguments:\n    list            -- \u5217\u8868\u7c7b\u578b\n    Return:\n        \u4e0d\u542b\u505c\u8bcd\u7684list\n    \"\"\"\n    stopwords_list = []\n    with open(get_default_stop_words_file(), encoding='utf-8') as stopwords:\n        for line in stopwords:\n            stopwords_list.append(line.replace('\\n', ''))\n\n    list_clean = []\n    for i in list:\n        if i not in stopwords_list:\n            list_clean.append(i)\n    return list_clean"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_mapping(html_cleaned):\n    unit_raw = html_cleaned.split('\\n')\n    for i in unit_raw:\n        c = CDM(i)\n        if c.PTN is not 0:\n            fake_title = i\n            break\n\n    init_list = []\n    init_dict = {}\n    for i in unit_raw:\n        init_list.append(len(i))\n    for i in range(0, len(init_list)):\n        init_dict[i] = init_list[i]\n    init_dict = sorted(init_dict.items(), key=lambda item: item[1], reverse=True)\n    try:\n        log('debug', '\u6620\u5c04\u6210\u529f\uff0c\u63d0\u53d6\u7684\u865a\u5047\u6807\u9898\u4e3a\uff1a\u3010{}\u3011'.format(fake_title))\n    except UnboundLocalError:\n        fake_title = ''\n        log('err', '\u865a\u5047\u6807\u9898\u63d0\u53d6\u5931\u8d25')\n    return unit_raw, init_dict, fake_title", "response": "List the mapping from the HTML to the UK."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of all the units in the initial corpus.", "response": "def first_unit(unit_raw, init_dict, fake_title):\n    \"\"\"\u521d\u59cb\u5316\u8bed\u6599\u5e93\uff0c\u63d0\u53d6\u7684\u662f\u6587\u672c\u884c\u957f\u5ea6\u6700\u5927\u4e14\u4e0e\u865a\u5047\u6807\u9898\u76f8\u4f3c\u5ea6\u6700\u5927\u7684\u6587\u672c\u884c\n\n    Keyword arguments:\n    unit_raw                -- \u9884\u5904\u7406\u540e\u7684\u7f51\u9875\u6587\u672c\u884c\uff0c\u53ea\u6709\u6587\u672c\u884c\u548c\u7a7a\u884c\n    Return:\n        init_corpus               -- \u7b2c\u4e00\u4e2a\u52a0\u5165\u8bed\u6599\u5e93\u7684\u6587\u672c\u884c\n    \"\"\"\n    init_corpus = {}\n    for i in range(0, 3):\n        try:\n            c = CDM(unit_raw[init_dict[i][0]])\n            init_corpus[init_dict[i][0]] = c.get_alpha([i for i in cut_for_search(fake_title)]) + c.SN\n        except IndexError:\n            break\n    init_corpus = sorted(init_corpus.items(), key=lambda item: item[1], reverse=True)\n\n    log('debug', '\\n\u521d\u59cb\u5316\u8bed\u6599\u5e93\u5b8c\u6210\uff0c\u521d\u59cb\u8bed\u6599\u4e3a\uff1a\u3010{}\u3011\\n'.format(unit_raw[init_corpus[0][0]]))\n    return init_corpus"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_corpus(self):\n\n        # \u6b63\u5411\u5224\u5b9a\n        corpus = []\n        cd = 0\n        tag = None\n        for i in range(0, self.init_corpus[0][0]):\n            init_unit = self.unit_raw[self.init_corpus[0][0] - i]\n            cdm = CDM(init_unit)\n            alpha = cdm.get_alpha()\n\n            if cd <= self.cd_min and cdm.NC is not 0:\n                tag = True\n            if cd > self.cd_max or cdm.NC == 0:\n                tag = False\n            if cd in range(self.cd_min + 1, self.cd_max) and cdm.NC is not 0:\n                if alpha > 0:\n                    tag = True\n                else:\n                    tag = False\n\n            if cdm.NC == 0:\n                cd += 1\n            else:\n                cd = 0\n\n            if tag == True:\n                corpus.append(init_unit)\n            elif tag == False:\n                if alpha < 0 or cd > self.cd_max:\n                    break\n                else:\n                    continue\n        corpus = list(reversed(corpus))\n        try:\n            self.index = self.init_corpus[0][0] - i + 1\n        except UnboundLocalError:\n            log('err', '\u6b63\u5411\u5224\u5b9a\u5b8c\u6210\uff0c\u7d22\u5f15\u5b9a\u4f4d\u51fa\u9519')\n            self.index = self.init_corpus[0][0]\n\n        # \u53cd\u5411\u5224\u5b9a\n        cd = 0\n        tag = None\n        for i in range(1, len(self.unit_raw) - self.init_corpus[0][0]):\n            init_unit = self.unit_raw[self.init_corpus[0][0] + i]\n            cdm = CDM(init_unit)\n            alpha = cdm.get_alpha()\n\n            if cd <= self.cd_min and cdm.NC is not 0:\n                tag = True\n            if cd > self.cd_max or cdm.NC == 0:\n                tag = False\n            if cd in range(self.cd_min + 1, self.cd_max) and cdm.NC is not 0:\n                if alpha > 0:\n                    tag = True\n                else:\n                    tag = False\n\n            if cdm.NC == 0:\n                cd += 1\n            else:\n                cd = 0\n\n            if tag == True:\n                corpus.append(init_unit)\n            elif tag == False:\n                if alpha < 0 or cd > self.cd_max:\n                    break\n                else:\n                    continue\n        log('debug', '\\n\u83b7\u53d6\u8bed\u6599\u5e93\u6210\u529f:\u3010{}\u3011\\n'.format(corpus))\n        return ''.join(corpus)", "response": "Get the corpus from the init_corpus."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfilter out any files marked draft", "response": "def drafts(files, stack):\n    \"Filter out any files marked 'draft'\"\n    for path, post in list(files.items()):\n        if post.get('draft'):\n            del files[path]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unpack_archive(*components, **kwargs) -> str:\n    path = fs.abspath(*components)\n    compression = kwargs.get(\"compression\", \"bz2\")\n    dir = kwargs.get(\"dir\", fs.dirname(path))\n\n    fs.cd(dir)\n    tar = tarfile.open(path, \"r:\" + compression)\n    tar.extractall()\n    tar.close()\n    fs.cdpop()\n\n    return dir", "response": "Unpack a compressed archive."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef workbook_to_reader(xlwt_wb):\n    _xlrd_required()\n    fh = BytesIO()\n    xlwt_wb.save(fh)\n    # prep for reading\n    fh.seek(0)\n    return xlrd.open_workbook(file_contents=fh.read())", "response": "convert xlwt Workbook instance to xlrd instance for reading\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert xlwt Workbook instance to a BytesIO instance", "response": "def xlsx_to_strio(xlsx_wb):\n    \"\"\"\n        convert xlwt Workbook instance to a BytesIO instance\n    \"\"\"\n    _xlrd_required()\n    fh = BytesIO()\n    xlsx_wb.filename = fh\n    xlsx_wb.close()\n    # prep for reading\n    fh.seek(0)\n    return fh"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting xlwt Workbook instance to xlrd instance for reading", "response": "def xlsx_to_reader(xlsx_wb):\n    \"\"\"\n        convert xlwt Workbook instance to an xlrd instance for reading\n    \"\"\"\n    fh = xlsx_to_strio(xlsx_wb)\n    return xlrd.open_workbook(file_contents=fh.read())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite data to row col of worksheet.", "response": "def write(self, row, col, data, style=None):\n        \"\"\"\n        Write data to row, col of worksheet (ws) using the style\n        information.\n\n        Again, I'm wrapping this because you'll have to do it if you\n        create large amounts of formatted entries in your spreadsheet\n        (else Excel, but probably not OOo will crash).\n        \"\"\"\n        ws = self.ws\n        if not ws:\n            raise Exception('you must use set_sheet() before write()')\n\n        if style:\n            if isinstance(style, xlwt.Style.XFStyle):\n                s = style\n            else:\n                s = self.get_style(style)\n            ws.write(row, col, data, s)\n        else:\n            ws.write(row, col, data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites data to row col of worksheet r1 r2 c1 c2 using the style specified in style.", "response": "def write_merge(self, r1, r2, c1, c2, data, style=None):\n        \"\"\"\n        Write data to row, col of worksheet (ws) using the style\n        information.\n\n        Again, I'm wrapping this because you'll have to do it if you\n        create large amounts of formatted entries in your spreadsheet\n        (else Excel, but probably not OOo will crash).\n        \"\"\"\n        ws = self.ws\n        if not ws:\n            raise Exception('you must use set_sheet() before write()')\n\n        if style:\n            if isinstance(style, xlwt.Style.XFStyle):\n                s = style\n            else:\n                s = self.get_style(style)\n            ws.write_merge(r1, r2, c1, c2, data, s)\n        else:\n            ws.write_merge(r1, r2, c1, c2, data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an XFStyle instance for the given style.", "response": "def get_style(self, style):\n        \"\"\"\n        Style is a dict maping key to values.\n        Valid keys are: background, format, alignment, border\n\n        The values for keys are lists of tuples containing (attribute,\n        value) pairs to set on model instances...\n        \"\"\"\n        style_key = tuple(style.items())\n        s = self.STYLE_FACTORY.get(style_key, None)\n        if s is None:\n            s = xlwt.XFStyle()\n            for key, values in style.items():\n                if key == \"background\":\n                    p = xlwt.Pattern()\n                    for attr, value in values:\n                        p.__setattr__(attr, value)\n                    s.pattern = p\n                elif key == \"format\":\n                    s.num_format_str = values\n                elif key == \"alignment\":\n                    a = xlwt.Alignment()\n                    for attr, value in values:\n                        a.__setattr__(attr, value)\n                    s.alignment = a\n                elif key == \"border\":\n                    b = xlwt.Formatting.Borders()\n                    for attr, value in values:\n                        b.__setattr__(attr, value)\n                    s.borders = b\n                elif key == \"font\":\n                    f = self.get_font(values)\n                    s.font = f\n            self.STYLE_FACTORY[style_key] = s\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_font(self, values):\n        font_key = values\n        f = self.FONT_FACTORY.get(font_key, None)\n        if f is None:\n            f = xlwt.Font()\n            for attr, value in values:\n                f.__setattr__(attr, value)\n            self.FONT_FACTORY[font_key] = f\n        return f", "response": "Get a font from a list of values."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef switch_on(self, *args):\n        if self.on_check(*args):\n            return self._switch.switch(True)\n        else:\n            return False", "response": "Sets the state of the switch to True if on_check returns True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef switch_off(self, *args):\n        if self.off_check(*args):\n            return self._switch.switch(False)\n        else:\n            return False", "response": "Sets the state of the switch to False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_daemon(self):\n        try:\n            self.daemon_runner.do_action()\n        except daemon.runner.DaemonRunnerStopFailureError:\n            self.onStopFail()\n        except SystemExit:\n            self.onExit()", "response": "Used as daemon starter.\n\n        Warning:\n            DO NOT OVERRIDE THIS."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef wrapAtom(xml, id, title, author=None, updated=None, author_uri=None,\n             alt=None, alt_type=\"text/html\"):\n    \"\"\"\n    Create an Atom entry tag and embed the passed XML within it\n    \"\"\"\n\n    entryTag = etree.Element(ATOM + \"entry\", nsmap=ATOM_NSMAP)\n    titleTag = etree.SubElement(entryTag, ATOM + \"title\")\n    titleTag.text = title\n    idTag = etree.SubElement(entryTag, ATOM + \"id\")\n    idTag.text = id\n    updatedTag = etree.SubElement(entryTag, ATOM + \"updated\")\n\n    if alt:\n        etree.SubElement(\n            entryTag,\n            ATOM + \"link\",\n            rel='alternate',\n            href=alt,\n            type=alt_type)\n\n    if updated is not None:\n        # If updated is a naive datetime, set its timezone to the local one\n        # So the xs:datetime value will include an explicit offset\n        if updated.tzinfo is None:\n            updated = localize_datetime(updated)\n        updatedTag.text = xsDateTime_format(updated)\n    else:\n        updatedTag.text = xsDateTime_format(localize_datetime(datetime.now()))\n    if author or author_uri:\n        authorTag = etree.SubElement(entryTag, ATOM + \"author\")\n        if author:\n            nameTag = etree.SubElement(authorTag, ATOM + \"name\")\n            nameTag.text = author\n        if author_uri:\n            nameUriTag = etree.SubElement(authorTag, ATOM + \"uri\")\n            nameUriTag.text = author_uri\n    contentTag = etree.SubElement(entryTag, ATOM + \"content\")\n    contentTag.set(\"type\", \"application/xml\")\n    contentTag.append(xml)\n    return entryTag", "response": "Create an Atom entry tag and embed the passed XML within it"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate oxum for a given path", "response": "def getOxum(dataPath):\n    \"\"\"\n    Calculate the oxum for a given path\n    \"\"\"\n\n    fileCount = 0L\n    fileSizeTotal = 0L\n    for root, dirs, files in os.walk(dataPath):\n        for fileName in files:\n            fullName = os.path.join(root, fileName)\n            stats = os.stat(fullName)\n            fileSizeTotal += stats.st_size\n            fileCount += 1\n    return \"%s.%s\" % (fileSizeTotal, fileCount)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a path to a bag and a ark_naan return a new XML file containing the bag.", "response": "def bagToXML(bagPath, ark_naan=None):\n    \"\"\"\n    Given a path to a bag, read stuff about it and make an XML file\n    \"\"\"\n    # This is so .DEFAULT_ARK_NAAN can be modified\n    # at runtime.\n    if ark_naan is None:\n        ark_naan = DEFAULT_ARK_NAAN\n    bagInfoPath = os.path.join(bagPath, \"bag-info.txt\")\n    bagTags = getBagTags(bagInfoPath)\n    if 'Payload-Oxum' not in bagTags:\n        bagTags['Payload-Oxum'] = getOxum(os.path.join(bagPath, \"data\"))\n    oxumParts = bagTags['Payload-Oxum'].split(\".\", 1)\n    bagName = \"ark:/%d/%s\" % (ark_naan, os.path.split(bagPath)[1])\n    bagSize = oxumParts[0]\n    bagFileCount = oxumParts[1]\n    bagitString = open(os.path.join(bagPath, \"bagit.txt\"), \"r\").read()\n    bagitLines = bagitString.split(\"\\n\")\n    versionLine = bagitLines[0].strip()\n    bagVersion = versionLine.split(None, 1)[1]\n    bagXML = etree.Element(BAG + \"codaXML\", nsmap=BAG_NSMAP)\n    name = etree.SubElement(bagXML, BAG + \"name\")\n    name.text = bagName\n    fileCount = etree.SubElement(bagXML, BAG + \"fileCount\")\n    fileCount.text = bagFileCount\n    payLoadSize = etree.SubElement(bagXML, BAG + \"payloadSize\")\n    payLoadSize.text = bagSize\n    bagitVersion = etree.SubElement(bagXML, BAG + \"bagitVersion\")\n    bagitVersion.text = bagVersion\n    etree.SubElement(bagXML, BAG + \"lastStatus\")\n    etree.SubElement(bagXML, BAG + \"lastVerified\")\n    if 'Bagging-Date' in bagTags:\n        baggingDate = etree.SubElement(bagXML, BAG + \"baggingDate\")\n        baggingDate.text = bagTags['Bagging-Date']\n    bagInfo = etree.SubElement(bagXML, BAG + \"bagInfo\")\n    for tag, content in bagTags.items():\n        item = etree.SubElement(bagInfo, BAG + \"item\")\n        itemName = etree.SubElement(item, BAG + \"name\")\n        itemName.text = tag\n        itemBody = etree.SubElement(item, BAG + \"body\")\n        itemBody.text = content\n    return bagXML, bagName"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getValueByName(node, name):\n\n    try:\n        value = node.xpath(\"*[local-name() = '%s']\" % name)[0].text.strip()\n    except:\n        return None\n    return value", "response": "Returns the value of a node with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getNodeByName(node, name):\n\n    if node is None:\n        raise Exception(\n            \"Cannot search for a child '%s' in a None object\" % (name,)\n        )\n    if not name:\n        raise Exception(\"Unspecified name to find node for.\")\n    try:\n        childNode = node.xpath(\"*[local-name() = '%s']\" % name)[0]\n    except:\n        return None\n    return childNode", "response": "Get the first child node matching a given local name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwalk down a chain of node names and returns the first node that is a child of the node.", "response": "def getNodeByNameChain(node, chain_list):\n    \"\"\"\n    Walk down a chain of node names and get the nodes they represent\n    e.g. [ \"entry\", \"content\", \"bag\", \"fileCount\" ]\n    \"\"\"\n\n    working_list = chain_list[:]\n    working_list.reverse()\n    current_node = node\n    while len(working_list):\n        current_name = working_list.pop()\n        child_node = getNodeByName(current_node, current_name)\n        if child_node is None:\n            raise Exception(\"Unable to find child node %s\" % current_name)\n        current_node = child_node\n    return current_node"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef nodeToXML(nodeObject):\n\n    xmlRoot = etree.Element(NODE + \"node\", nsmap=NODE_NSMAP)\n    nameNode = etree.SubElement(xmlRoot, NODE + \"name\")\n    nameNode.text = nodeObject.node_name\n    urlNode = etree.SubElement(xmlRoot, NODE + \"url\")\n    urlNode.text = nodeObject.node_url\n    pathNode = etree.SubElement(xmlRoot, NODE + \"path\")\n    pathNode.text = nodeObject.node_path\n    capNode = etree.SubElement(xmlRoot, NODE + \"capacity\")\n    capNode.text = str(nodeObject.node_capacity)\n    sizeNode = etree.SubElement(xmlRoot, NODE + \"size\")\n    sizeNode.text = str(nodeObject.node_size)\n    if nodeObject.last_checked:\n        checkedNode = etree.SubElement(xmlRoot, NODE + \"lastChecked\")\n        checkedNode.text = nodeObject.last_checked.strftime(TIME_FORMAT_STRING)\n    return xmlRoot", "response": "Takes a Django node object from our CODA store and makes an XML\n    representation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef queueEntryToXML(queueEntry):\n\n    xmlRoot = etree.Element(QXML + \"queueEntry\", nsmap=QXML_NSMAP)\n    arkTag = etree.SubElement(xmlRoot, QXML + \"ark\")\n    arkTag.text = queueEntry.ark\n    oxumTag = etree.SubElement(xmlRoot, QXML + \"oxum\")\n    oxumTag.text = queueEntry.oxum\n    urlListLinkTag = etree.SubElement(xmlRoot, QXML + \"urlListLink\")\n    urlListLinkTag.text = queueEntry.url_list\n    statusTag = etree.SubElement(xmlRoot, QXML + \"status\")\n    statusTag.text = queueEntry.status\n    if hasattr(queueEntry, \"harvest_start\") and queueEntry.harvest_start:\n        startTag = etree.SubElement(xmlRoot, QXML + \"start\")\n        if isinstance(queueEntry.harvest_start, basestring):\n            startTag.text = queueEntry.harvest_start\n        else:\n            startTag.text = queueEntry.harvest_start.strftime(\n                TIME_FORMAT_STRING\n            )\n    if hasattr(queueEntry, \"harvest_end\") and queueEntry.harvest_end:\n        endTag = etree.SubElement(xmlRoot, QXML + \"end\")\n        if isinstance(queueEntry.harvest_end, basestring):\n            endTag.text = queueEntry.harvest_end\n        else:\n            endTag.text = queueEntry.harvest_end.strftime(TIME_FORMAT_STRING)\n    positionTag = etree.SubElement(xmlRoot, QXML + \"position\")\n    positionTag.text = str(queueEntry.queue_position)\n    return xmlRoot", "response": "Converts an instance of a QueueEntry model into an xml data format"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef makeObjectFeed(\n        paginator, objectToXMLFunction, feedId, title, webRoot,\n        idAttr=\"id\", nameAttr=\"name\", dateAttr=None, request=None, page=1,\n        count=20, author=APP_AUTHOR):\n    \"\"\"\n    Take a list of some kind of object, a conversion function, an id and a\n    title Return XML representing an ATOM feed\n    \"\"\"\n\n    listSize = paginator.count\n    if listSize:\n        object_list = paginator.page(page).object_list\n    else:\n        object_list = []\n    count = int(count)\n    originalId = feedId\n    idParts = feedId.split(\"?\", 1)\n    if len(idParts) == 2:\n        feedId = idParts[0]\n    if request:\n        GETStruct = request.GET\n    else:\n        GETStruct = False\n    feedTag = etree.Element(ATOM + \"feed\", nsmap=ATOM_NSMAP)\n    # The id tag is very similar to the 'self' link\n    idTag = etree.SubElement(feedTag, ATOM + \"id\")\n    idTag.text = \"%s/%s\" % (webRoot, feedId)\n    # The title is passed in from the calling function\n    titleTag = etree.SubElement(feedTag, ATOM + \"title\")\n    titleTag.text = title\n    # The author is passed in from the calling function and required to be valid ATOM\n    if author:\n        authorTag = etree.SubElement(feedTag, ATOM + \"author\")\n        nameTag = etree.SubElement(authorTag, ATOM + \"name\")\n        urlTag = etree.SubElement(authorTag, ATOM + \"uri\")\n        nameTag.text = author.get('name', 'UNT')\n        urlTag.text = author.get('uri', 'http://library.unt.edu/')\n    # The updated tag is a\n    updatedTag = etree.SubElement(feedTag, ATOM + \"updated\")\n    updatedTag.text = xsDateTime_format(localize_datetime(datetime.now()))\n    # We will always show the link to the current 'self' page\n    linkTag = etree.SubElement(feedTag, ATOM + \"link\")\n    linkTag.set(\"rel\", \"self\")\n    if not request or not request.META['QUERY_STRING']:\n        linkTag.set(\"href\", \"%s/%s\" % (webRoot, feedId))\n    else:\n        linkTag.set(\n            \"href\", \"%s/%s?%s\" % (\n                webRoot, feedId, urllib.urlencode(request.GET, doseq=True)\n            )\n        )\n    # We always have a last page\n    endLink = etree.SubElement(feedTag, ATOM + \"link\")\n    endLink.set(\"rel\", \"last\")\n    if GETStruct:\n        endLinkGS = GETStruct.copy()\n    else:\n        endLinkGS = {}\n    endLinkGS.update({\"page\": paginator.num_pages})\n    endLink.set(\n        \"href\", \"%s/%s?%s\" % (\n            webRoot, feedId, urllib.urlencode(endLinkGS, doseq=True)\n        )\n    )\n    # We always have a first page\n    startLink = etree.SubElement(feedTag, ATOM + \"link\")\n    startLink.set(\"rel\", \"first\")\n    if GETStruct:\n        startLinkGS = GETStruct.copy()\n    else:\n        startLinkGS = {}\n    startLinkGS.update({\"page\": paginator.page_range[0]})\n    startLink.set(\n        \"href\", \"%s/%s?%s\" % (\n            webRoot, feedId, urllib.urlencode(startLinkGS, doseq=True)\n        )\n    )\n    # Potentially there is a previous page, list it's details\n    if paginator.page(page).has_previous():\n        prevLink = etree.SubElement(feedTag, ATOM + \"link\")\n        prevLink.set(\"rel\", \"previous\")\n        if GETStruct:\n            prevLinkGS = GETStruct.copy()\n        else:\n            prevLinkGS = {}\n        prevLinkGS.update(\n            {\"page\": paginator.page(page).previous_page_number()}\n        )\n        prevLinkText = \"%s/%s?%s\" % (\n            webRoot, feedId, urllib.urlencode(prevLinkGS, doseq=True)\n        )\n        prevLink.set(\"href\", prevLinkText)\n    # Potentially there is a next page, fill in it's details\n    if paginator.page(page).has_next():\n        nextLink = etree.SubElement(feedTag, ATOM + \"link\")\n        nextLink.set(\"rel\", \"next\")\n        if GETStruct:\n            nextLinkGS = GETStruct.copy()\n        else:\n            nextLinkGS = {}\n        nextLinkGS.update({\"page\": paginator.page(page).next_page_number()})\n        nextLinkText = \"%s/%s?%s\" % (\n            webRoot, feedId, urllib.urlencode(nextLinkGS, doseq=True)\n        )\n        nextLink.set(\"href\", nextLinkText)\n    for o in object_list:\n        objectXML = objectToXMLFunction(o)\n        if dateAttr:\n            dateStamp = getattr(o, dateAttr)\n        else:\n            dateStamp = None\n        althref = feedId.strip('/').split('/')[-1]\n        althref = '%s/%s/%s/' % (\n            webRoot, althref, getattr(o, idAttr)\n        )\n        objectEntry = wrapAtom(\n            xml=objectXML,\n            id='%s/%s%s/' % (webRoot, originalId, getattr(o, idAttr)),\n            title=getattr(o, nameAttr),\n            updated=dateStamp,\n            alt=althref\n        )\n        feedTag.append(objectEntry)\n    return feedTag", "response": "Create an ATOM feed from an object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking an ATOM service doc here. The collections parameter is a list of dictionaries with the keys of title accept and categories being valid .", "response": "def makeServiceDocXML(title, collections):\n    \"\"\"\n    Make an ATOM service doc here. The 'collections' parameter is a list of\n    dictionaries, with the keys of 'title', 'accept' and 'categories'\n    being valid\n    \"\"\"\n\n    serviceTag = etree.Element(\"service\")\n    workspaceTag = etree.SubElement(serviceTag, \"workspace\")\n    titleTag = etree.SubElement(workspaceTag, ATOM + \"title\", nsmap=ATOM_NSMAP)\n    titleTag.text = title\n    for collection in collections:\n        collectionTag = etree.SubElement(workspaceTag, \"collection\")\n        if 'href' in collection:\n            collectionTag.set(\"href\", collection['href'])\n        if 'title' in collection:\n            colTitleTag = etree.SubElement(\n                collectionTag, ATOM + \"title\", nsmap=ATOM_NSMAP\n            )\n            colTitleTag.text = collection['title']\n        if 'accept' in collection:\n            acceptTag = etree.SubElement(collectionTag, \"accept\")\n            acceptTag.text = collection['accept']\n    return serviceTag"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addObjectFromXML(xmlObject, XMLToObjectFunc,\n                     topLevelName, idKey, updateList):\n    \"\"\"\n    Handle adding or updating the Queue.  Based on XML input.\n    \"\"\"\n\n    # Get the current object to update\n    contentElement = getNodeByName(xmlObject, \"content\")\n    objectNode = getNodeByName(contentElement, topLevelName)\n    dupObjects = None\n    newObject = XMLToObjectFunc(objectNode)\n    try:\n        kwargs = {idKey: getattr(newObject, idKey)}\n        dupObjects = type(newObject).objects.filter(**kwargs)\n    except type(newObject).DoesNotExist:\n        pass\n    if dupObjects and dupObjects.count() > 1:\n        raise Exception(\n            \"Duplicate object with identifier %s\" % getattr(newObject, idKey)\n        )\n    newObject.save()\n    return newObject", "response": "Handles adding or updating the Queue based on XML input."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate an object based on XML input.", "response": "def updateObjectFromXML(xml_doc, obj, mapping):\n    \"\"\"\n    Handle updating an object.  Based on XML input.\n    \"\"\"\n    nsmap = None\n    if isinstance(mapping, dict):\n        # The special key @namespaces is used to pass\n        # namespaces and prefix mappings for xpath selectors.\n        # e.g. {'x': 'http://example.com/namespace'}\n        if '@namespaces' in mapping:\n            nsmap = mapping['@namespaces']\n    else:\n        raise TypeError('Tag-to-property map must be a dict.')\n    # Iterate over the keys of the translation dictionary from event objects\n    # to xml objects, so we can update the fields with the new information\n    for k, v in mapping.items():\n        if k.startswith('@'):\n            continue\n        selected_text = None\n        if isinstance(v, basestring):\n            selector = v\n        elif isinstance(v, list):\n            selector = '/'.join(v)\n        else:\n            raise TypeError(\n                'Invalid tag-to-property mapping dict: '\n                'values must be strings or lists, not %s.' % (type(v),)\n            )\n        try:\n            selected_text = xml_doc.xpath(selector, namespaces=nsmap)\n            if isinstance(selected_text, list):\n                selected_text = selected_text[0]\n            selected_text = selected_text.text\n            setattr(obj, k, selected_text)\n        except IndexError:\n            # Assume the value is missing. It's also possible that the\n            # given selector is valid but wrong, but the more common\n            # case is that the element is missing. To be consistent with\n            # the prior implementation, empty resultsets just mean empty\n            # attributes.\n            continue\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a Compass plot file to XYZ pointcloud", "response": "def plt2xyz(fname):\n\t\"\"\"Convert a Compass plot file to XYZ pointcloud\"\"\"\n\tparser = CompassPltParser(fname)\n\tplt = parser.parse()\n\n\tfor segment in plt:\n\t\tfor command in segment:\n\t\t\tif command.cmd == 'd':\n\t\t\t\tif plt.utm_zone:\n\t\t\t\t\tx, y, z = command.x * FT_TO_M, command.y * FT_TO_M, command.z * FT_TO_M\n\t\t\t\telse:\n\t\t\t\t\tx, y, z = command.x, command.y, command.z\n\t\t\t\tprint('%.3f\\t%.3f\\t%.3f' % (x, y, z))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_routes(self):\n        for file_name in os.listdir(os.path.join(self._project_dir, 'controllers')):\n            # ignore disabled controllers\n            if not file_name.startswith('_'):\n                module_name = file_name.split('.', 1)[0]\n                module_path = \"controllers.{}\".format(module_name)\n                module = import_module(module_path)\n                controllers = [getattr(module, x) for x in dir(module) if x != 'Controller' and x.endswith('Controller')]\n                controller = controllers[0]\n                self._routes[module_name] = controller\n        return self._routes", "response": "Load all routes in project s folder controllers."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_controller(self, path):\n        path_info = path.lstrip('/').split('/', 2)\n        try:\n            return self._routes.get(path_info[0] + '/' + path_info[1])\n        except (IndexError, KeyError):\n            return self._routes.get(path_info[0] or 'index')", "response": "Returns the controller that handle given path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_key(self, key):\n        # Sanity check it's a valid key\n        if key not in KEYS:\n            return ['error', None]\n\n        url = 'http://%s/WAN/%s/%s_ctrl.cgi' % (self._host, 'dvdr', 'dvdr')\n        data = ('cCMD_RC_%s.x=100&cCMD_RC_%s.y=100' % (key, key)).encode()\n\n        return self.send_cmd(url, data)", "response": "Send a keypress to the device"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ui_clear_image(self, value):\n\n        if value is not None:\n            assert type(value) is unicode, \"'{0}' attribute: '{1}' type is not 'unicode'!\".format(\n                \"ui_clear_image\", value)\n            assert os.path.exists(value), \"'{0}' attribute: '{1}' file doesn't exists!\".format(\n                \"ui_clear_image\", value)\n        self.__ui_clear_image = value", "response": "Setter for **self. __ui_clear_image** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resizeEvent(self, event):\n\n        frame_width = self.style().pixelMetric(QStyle.PM_DefaultFrameWidth)\n        search_active_labelSize = self.__search_active_label.sizeHint()\n        self.__search_active_label.move(self.rect().left() + frame_width,\n                                        (self.rect().bottom() - search_active_labelSize.height()) / 2 + frame_width / 2)\n        clear_buttonSize = self.__clear_button.sizeHint()\n        self.__clear_button.move(self.rect().right() - frame_width - clear_buttonSize.width(),\n                                 (self.rect().bottom() - clear_buttonSize.height()) / 2 + frame_width / 2)", "response": "Reimplement the QLineEdit. QResizeEvent method."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes the Widget ui.", "response": "def __initialize_ui(self):\n        \"\"\"\n        Initializes the Widget ui.\n        \"\"\"\n\n        self.__clear_button.setCursor(Qt.ArrowCursor)\n        if self.__ui_clear_image and self.__ui_clear_clicked_image:\n            pixmap = QPixmap(self.__ui_clear_image)\n            clicked_pixmap = QPixmap(self.__ui_clear_clicked_image)\n            self.__clear_button.setIcon(QIcon(pixmap))\n            self.__clear_button.setMaximumSize(pixmap.size())\n\n            # Signals / Slots.\n            self.__clear_button.pressed.connect(functools.partial(self.__clear_button.setIcon, QIcon(clicked_pixmap)))\n            self.__clear_button.released.connect(functools.partial(self.__clear_button.setIcon, QIcon(pixmap)))\n        else:\n            self.__clear_button.setText(\"Clear\")\n\n        self.__set_style_sheet()\n\n        frame_width = self.style().pixelMetric(QStyle.PM_DefaultFrameWidth)\n        self.setMinimumSize(\n            max(self.minimumSizeHint().width(), self.__clear_button.sizeHint().height() + frame_width * 2),\n            max(self.minimumSizeHint().height(), self.__clear_button.sizeHint().height() + frame_width * 2))\n\n        self.__completer.setCaseSensitivity(Qt.CaseInsensitive)\n        self.__completer.setCompletionMode(QCompleter.UnfilteredPopupCompletion)\n        self.__completer.setMaxVisibleItems(self.__completer_visible_items_count)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the Widget stylesheet.", "response": "def __set_style_sheet(self):\n        \"\"\"\n        Sets the Widget stylesheet.\n        \"\"\"\n\n        frame_width = self.style().pixelMetric(QStyle.PM_DefaultFrameWidth)\n        self.setStyleSheet(QString(\"QLineEdit {{ padding-left: {0}px; padding-right: {1}px; }}\".format(\n            self.__search_active_label.sizeHint().width(\n            ) if self.__search_active_label.isVisible() else 0 + frame_width,\n            self.__clear_button.sizeHint().width() + frame_width)))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __set_clear_button_visibility(self, text):\n\n        if text:\n            self.__clear_button.show()\n        else:\n            self.__clear_button.hide()", "response": "Sets the clear button visibility."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading a JSON file and returns a list of dicts.", "response": "def read_file(*components, **kwargs):\n    \"\"\"\n    Load a JSON data blob.\n\n    Arguments:\n        path (str): Path to file.\n        must_exist (bool, otional): If False, return empty dict if file does\n            not exist.\n\n    Returns:\n        array or dict: JSON data.\n\n    Raises:\n        File404: If path does not exist, and must_exist is True.\n        InvalidFile: If JSON is malformed.\n    \"\"\"\n    must_exist = kwargs.get(\"must_exist\", True)\n\n    if must_exist:\n        path = fs.must_exist(*components)\n    else:\n        path = fs.path(*components)\n\n    try:\n        with open(path) as infile:\n            return loads(infile.read())\n    except ValueError as e:\n        raise ValueError(\n            \"malformed JSON file '{path}'. Message from parser: {err}\"\n            .format(path=fs.basename(path), err=str(e)))\n    except IOError as e:\n        if not must_exist:\n            return {}\n        else:\n            return e"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites JSON data to file.", "response": "def write_file(path, data, format=True):\n    \"\"\"\n    Write JSON data to file.\n\n    Arguments:\n        path (str): Destination.\n        data (dict or list): JSON serializable data.\n        format (bool, optional): Pretty-print JSON data.\n    \"\"\"\n    if format:\n        fs.write_file(path, format_json(data))\n    else:\n        fs.write_file(path, json.dumps(data))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new base with the specified field names and return the new base.", "response": "def create(self,*fields,**kw):\r\n        \"\"\"Create a new base with specified field names\r\n        A keyword argument mode can be specified ; it is used if a file\r\n        with the base name already exists\r\n        - if mode = 'open' : open the existing base, ignore the fields\r\n        - if mode = 'override' : erase the existing base and create a\r\n        new one with the specified fields\"\"\"\r\n        self.mode = mode = kw.get(\"mode\",None)\r\n        if os.path.exists(self.name):\r\n            if not os.path.isfile(self.name):\r\n                raise IOError,\"%s exists and is not a file\" %self.name\r\n            elif mode is None:\r\n                raise IOError,\"Base %s already exists\" %self.name\r\n            elif mode == \"open\":\r\n                return self.open()\r\n            elif mode == \"override\":\r\n                os.remove(self.name)\r\n        self.fields = list(fields)\r\n        self.records = {}\r\n        self.next_id = 0\r\n        self.indices = {}\r\n        self.commit()\r\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate an index on the specified fields and create an instance of the appropriate class.", "response": "def create_index(self,*fields):\r\n        \"\"\"Create an index on the specified field names\r\n        \r\n        An index on a field is a mapping between the values taken by the field\r\n        and the sorted list of the ids of the records whose field is equal to \r\n        this value\r\n        \r\n        For each indexed field, an attribute of self is created, an instance \r\n        of the class Index (see above). Its name it the field name, with the\r\n        prefix _ to avoid name conflicts\r\n        \"\"\"\r\n        reset = False\r\n        for f in fields:\r\n            if not f in self.fields:\r\n                raise NameError,\"%s is not a field name %s\" %(f,self.fields)\r\n            # initialize the indices\r\n            if self.mode == \"open\" and f in self.indices:\r\n                continue\r\n            reset = True\r\n            self.indices[f] = {}\r\n            for _id,record in self.records.iteritems():\r\n                # use bisect to quickly insert the id in the list\r\n                bisect.insort(self.indices[f].setdefault(record[f],[]),\r\n                    _id)\r\n            # create a new attribute of self, used to find the records\r\n            # by this index\r\n            setattr(self,'_'+f,Index(self,f))\r\n        if reset:\r\n            self.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting the index on the specified fields", "response": "def delete_index(self,*fields):\r\n        \"\"\"Delete the index on the specified fields\"\"\"\r\n        for f in fields:\r\n            if not f in self.indices:\r\n                raise ValueError,\"No index on field %s\" %f\r\n        for f in fields:\r\n            del self.indices[f]\r\n        self.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef open(self):\r\n        # guess protocol\r\n        if self.protocol==0:\r\n            _in = open(self.name) # don't specify binary mode !\r\n        else:\r\n            _in = open(self.name,'rb')\r\n        self.fields = cPickle.load(_in)\r\n        self.next_id = cPickle.load(_in)\r\n        self.records = cPickle.load(_in)\r\n        self.indices = cPickle.load(_in)\r\n        for f in self.indices.keys():\r\n            setattr(self,'_'+f,Index(self,f))\r\n        _in.close()\r\n        self.mode = \"open\"\r\n        return self", "response": "Open an existing database and load its content into memory."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites the database to a file", "response": "def commit(self):\r\n        \"\"\"Write the database to a file\"\"\"\r\n        out = open(self.name,'wb')\r\n        cPickle.dump(self.fields,out,self.protocol)\r\n        cPickle.dump(self.next_id,out,self.protocol)\r\n        cPickle.dump(self.records,out,self.protocol)\r\n        cPickle.dump(self.indices,out,self.protocol)\r\n        out.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef insert(self,*args,**kw):\r\n        if args:\r\n            kw = dict([(f,arg) for f,arg in zip(self.fields,args)])\r\n        # initialize all fields to None\r\n        record = dict([(f,None) for f in self.fields])\r\n        # raise exception if unknown field\r\n        for key in kw:\r\n            if not key in self.fields:\r\n                raise NameError,\"Invalid field name : %s\" %key\r\n        # set keys and values\r\n        for (k,v) in kw.iteritems():\r\n            record[k]=v\r\n        # add the key __id__ : record identifier\r\n        record['__id__'] = self.next_id\r\n        # add the key __version__ : version number\r\n        record['__version__'] = 0\r\n        # create an entry in the dictionary self.records, indexed by __id__\r\n        self.records[self.next_id] = record\r\n        # update index\r\n        for ix in self.indices.keys():\r\n            bisect.insort(self.indices[ix].setdefault(record[ix],[]),\r\n                self.next_id)\r\n        # increment the next __id__\r\n        self.next_id += 1\r\n        return record['__id__']", "response": "Insert a record in the database Returns the new record identifier"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self,removed):\r\n        if isinstance(removed,dict):\r\n            # remove a single record\r\n            removed = [removed]\r\n        else:\r\n            # convert iterable into a list (to be able to sort it)\r\n            removed = [ r for r in removed ]\r\n        if not removed:\r\n            return 0\r\n        _ids = [ r['__id__'] for r in removed ]\r\n        _ids.sort()\r\n        keys = set(self.records.keys())\r\n        # check if the records are in the base\r\n        if not set(_ids).issubset(keys):\r\n            missing = list(set(_ids).difference(keys))\r\n            raise IndexError,'Delete aborted. Records with these ids' \\\r\n                ' not found in the base : %s' %str(missing)\r\n        # raise exception if duplicate ids\r\n        for i in range(len(_ids)-1):\r\n            if _ids[i] == _ids[i+1]:\r\n                raise IndexError,\"Delete aborted. Duplicate id : %s\" %_ids[i]\r\n        deleted = len(removed)\r\n        while removed:\r\n            r = removed.pop()\r\n            _id = r['__id__']\r\n            # remove id from indices\r\n            for indx in self.indices.keys():\r\n                pos = bisect.bisect(self.indices[indx][r[indx]],_id)-1\r\n                del self.indices[indx][r[indx]][pos]\r\n                if not self.indices[indx][r[indx]]:\r\n                    del self.indices[indx][r[indx]]\r\n            # remove record from self.records\r\n            del self.records[_id]\r\n        return deleted", "response": "Remove a single record or the records in an iterable"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates one record of a list of records with new keys and values and update indices", "response": "def update(self,records,**kw):\r\n        \"\"\"Update one record of a list of records \r\n        with new keys and values and update indices\"\"\"\r\n        # ignore unknown fields\r\n        kw = dict([(k,v) for (k,v) in kw.iteritems() if k in self.fields])\r\n        if isinstance(records,dict):\r\n            records = [ records ]\r\n        # update indices\r\n        for indx in set(self.indices.keys()) & set (kw.keys()):\r\n            for record in records:\r\n                if record[indx] == kw[indx]:\r\n                    continue\r\n                _id = record[\"__id__\"]\r\n                # remove id for the old value\r\n                old_pos = bisect.bisect(self.indices[indx][record[indx]],_id)-1\r\n                del self.indices[indx][record[indx]][old_pos]\r\n                if not self.indices[indx][record[indx]]:\r\n                    del self.indices[indx][record[indx]]\r\n                # insert new value\r\n                bisect.insort(self.indices[indx].setdefault(kw[indx],[]),_id)\r\n        for record in records:\r\n            # update record values\r\n            record.update(kw)\r\n            # increment version number\r\n            record[\"__version__\"] += 1"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getShape(self, includeJunctions=False):\n        if self._shape is None:\n            self.rebuildShape()\n        if includeJunctions:\n            return self._shapeWithJunctions\n        return self._shape", "response": "Return the 2D shape that is the average of all lane shapes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntruing if this edge is fringe", "response": "def is_fringe(self, connections=None):\n        \"\"\"true if this edge has no incoming or no outgoing connections (except turnarounds)\n           If connections is given, only those connections are considered\"\"\"\n        if connections is None:\n            return self.is_fringe(self._incoming) or self.is_fringe(self._outgoing)\n        else:\n            cons = sum([c for c in connections.values()], [])\n            return len([c for c in cons if c._direction != Connection.LINKDIR_TURN]) == 0"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef allows(self, vClass):\n        for lane in self._lanes:\n            if vClass in lane._allowed:\n                return True\n        return False", "response": "true if this edge has a lane which allows the given vehicle class"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readANVLString(string):\n\n    ANVLDict = {}\n    ANVLLines = string.split(\"\\n\")\n    lineCount = len(ANVLLines)\n    index = 0\n    while index < lineCount:\n        line = ANVLLines[index]\n        if not len(line) or not len(line.strip()):\n            index = index + 1\n            continue\n        if \"#\" == line[0]:\n            index = index + 1\n            continue\n        if \":\" not in line:\n            raise InvalidANVLRecord(\n                \"Missing colon in line %d of ANVL record.\" % (index+1,)\n            )\n        parts = line.split(\":\", 1)\n        key = parts[0].strip()\n        contentBuffer = parts[1].lstrip()\n        nextIndex = index + 1\n        while nextIndex < lineCount:\n            nextLine = ANVLLines[nextIndex]\n            if len(nextLine) and \"#\" == nextLine[0]:\n                nextIndex = nextIndex + 1\n                continue\n            if nextLine == nextLine.lstrip():\n                break\n            if contentBuffer:\n                contentBuffer = contentBuffer + \" \" + nextLine.lstrip()\n            else:\n                contentBuffer = nextLine.lstrip()\n            nextIndex = nextIndex + 1\n        index = nextIndex\n        ANVLDict[key] = contentBuffer\n    return ANVLDict", "response": "Take a string in ANVL format and break it into a dictionary of key - value pairs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef writeANVLString(ANVLDict):\n    lines = []\n    keys = ANVLDict.keys()\n    keys.sort()\n    for key in keys:\n        value = ANVLDict[key]\n        offset = len(key) + 1\n        line = \"%s: %s\" % (key, breakString(value, 79, offset))\n        lines.append(line)\n    return \"\\n\".join(lines)", "response": "Takes a dictionary and writes out the keys and values in ANVL format and returns a string that contains the ANVL formatted version of the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate(opts):\n    if hasattr(opts, 'extensions'):\n        return _validate(opts.extensions)\n    elif isinstance(opts, list):\n        return _validate(opts)\n    else:\n        raise ValueError(\"Value passed into extension validation must either \"\n                         \"be a list of strings or a namespace with an \"\n                         \"attribute of 'extensions'\")", "response": "Client - facing validate method. Checks to see if the passed in opts contains the necessary extensions and runs validations on it accordingly."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_map(self,londel=1.,latdel=1.,*args,**kwargs):\r\n        \r\n        s = kwargs['s'] if kwargs.has_key('s') else 25\r\n        edgecolor = kwargs['edgecolor'] if kwargs.has_key('edgecolor') else 'none'\r\n        bathy = kwargs.get('bathy',not kwargs.get('nobathy',False))\r\n        \r\n        #Plot Sequence\r\n        ##############\r\n        self.drawcoastlines()\r\n        if bathy : cs=self.drawbathy(**kwargs)\r\n        \r\n        self.drawparallels(np.arange(np.floor(self.limit[0]), np.ceil(self.limit[2]), latdel), labels=[1, 0, 0, 0])\r\n        self.drawmeridians(np.arange(np.floor(self.limit[1]), np.ceil(self.limit[3]), londel), labels=[0, 0, 0, 1])\r\n                \r\n#        if len(args) == 3 :\r\n#            lon=args[0]\r\n#            lat=args[1]\r\n#            z=args[2]\r\n#            if np.size(z) > 1 : self.scatter(lon,lat,z,s=s,edgecolor=edgecolor)\r\n#            else : \r\n#                if type(z) != type(str()) : z = '.k'\r\n#                self.plot(lon,lat,z,ms=s)*\r\n#        if len(args) == 2 :\r\n#            lon=args[0]\r\n#            lat=args[1]\r\n#            if np.size(z) > 1 : self.plot(lon,lat,z,s=s,edgecolor=edgecolor)\r\n#            else : \r\n#                if type(z) != type(str()) : z = '.k'\r\n#                self.plot(lon,lat,z,ms=s)\r\n        return cs if bathy else None", "response": "Setup the map for the most recent in - sequence."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ensure_datetime(dobj, time_part=None):\n    if isinstance(dobj, dt.datetime):\n        return dobj\n    return dt.datetime.combine(dobj, time_part or dt.time())", "response": "Ensure dobj is a datetime object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the Widget ui.", "response": "def __initialize_ui(self):\n        \"\"\"\n        Initializes the Widget ui.\n        \"\"\"\n\n        self.Lines_Columns_label.setAlignment(Qt.AlignRight)\n        self.Lines_Columns_label.setText(self.__Lines_Columns_label_default_text.format(1, 1))\n\n        self.Languages_comboBox.setModel(self.__container.languages_model)\n\n        # Signals / Slots.\n        self.Languages_comboBox.currentIndexChanged.connect(self.__Languages_comboBox__currentIndexChanged)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the **Languages_comboBox** Widget default View state.", "response": "def __Languages_comboBox_set_default_view_state(self):\n        \"\"\"\n        Sets the **Languages_comboBox** Widget default View state.\n        \"\"\"\n\n        if not self.__container.has_editor_tab():\n            return\n\n        editor = self.__container.get_current_editor()\n        index = self.Languages_comboBox.findText(editor.language.name)\n\n        self.Languages_comboBox.setCurrentIndex(index)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nnormalize and expand a shorthand or relative path.", "response": "def normalized_path(value):\n    \"\"\"Normalize and expand a shorthand or relative path.\"\"\"\n    if not value:\n        return\n    norm = os.path.normpath(value)\n    norm = os.path.abspath(os.path.expanduser(norm))\n    return norm"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads file and return contents.", "response": "def read_from(value):\n    \"\"\"Read file and return contents.\"\"\"\n    path = normalized_path(value)\n    if not os.path.exists(path):\n        raise argparse.ArgumentTypeError(\"%s is not a valid path.\" % path)\n    LOG.debug(\"%s exists.\", path)\n    with open(path, 'r') as reader:\n        read = reader.read()\n    return read"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle comma - separated key = value pairs passed in command - line.", "response": "def comma_separated_pairs(value):\n    \"\"\"Handle comma-separated key/values passed in command-line.\"\"\"\n    pairs = value.split(\",\")\n    results = {}\n    for pair in pairs:\n        key, pair_value = pair.split('=')\n        results[key] = pair_value\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init(options=None, ini_paths=None, argv=None,\n         strict=False, **parser_kwargs):\n    \"\"\"Initialize singleton config and read/parse configuration.\n\n    :keyword bool strict: when true, will error out on invalid arguments\n        (default behavior is to ignore them)\n    :returns: the loaded configuration.\n    \"\"\"\n    global SINGLETON\n    SINGLETON = Config(\n        options=options,\n        ini_paths=ini_paths,\n        argv=argv,\n        **parser_kwargs)\n    SINGLETON.parse(argv, strict=strict)\n    return SINGLETON", "response": "Initialize singleton config and read or parse configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_argument(self, parser, permissive=False, **override_kwargs):\n        kwargs = {}\n        required = None\n        if self.kwargs:\n            kwargs = copy.copy(self.kwargs)\n            if 'env' in kwargs and 'help' in kwargs:\n                kwargs['help'] = \"%s (or set %s)\" % (kwargs['help'],\n                                                     kwargs['env'])\n            if permissive:\n                required = kwargs.pop('required', None)\n            try:\n                del kwargs['env']\n            except KeyError:\n                pass\n            try:\n                del kwargs['ini_section']\n            except KeyError:\n                pass\n\n            # allow custom and/or exclusive argument groups\n            if kwargs.get('group') or kwargs.get('mutually_exclusive'):\n                groupname = kwargs.pop('group', None) or kwargs.get('dest')\n                mutually_exclusive = kwargs.pop('mutually_exclusive', None)\n                if not groupname:\n                    raise NoGroupForOption(\n                        \"%s requires either 'group' or 'dest'.\" % self)\n                description = kwargs.pop('group_description', None)\n                exists = [grp for grp in parser._action_groups\n                          if grp.title == groupname]\n                if exists:\n                    group = exists[0]\n                    if description and not group.description:\n                        group.description = description\n                else:\n                    group = parser.add_argument_group(\n                        title=groupname, description=description)\n                if mutually_exclusive:\n                    if not required:\n                        required = kwargs.pop('required', None)\n                    mutexg_title = '%s mutually-exclusive-group' % groupname\n                    exists = [grp for grp in group._mutually_exclusive_groups\n                              if grp.title == mutexg_title]\n                    if exists:\n                        group = exists[0]\n                    else:\n                        # extend parent group\n                        group = group.add_mutually_exclusive_group(\n                            required=required)\n                        group.title = mutexg_title\n                    # if any in the same group are required, then the\n                    # mutually exclusive group should be set to required\n                    if required and not group.required:\n                        group.required = required\n                    self._mutexgroup = group\n                self._action = group.add_argument(*self.args, **kwargs)\n                return\n\n        kwargs.update(override_kwargs)\n        self._action = parser.add_argument(*self.args, **kwargs)", "response": "Add an option to an argparse parser."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize the config like as you would a regular dict.", "response": "def init(cls, *args, **kwargs):\n        \"\"\"Initialize the config like as you would a regular dict.\"\"\"\n        instance = cls()\n        instance._values.update(dict(*args, **kwargs))\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prog(self):\n        if not self._prog:\n            self._prog = self._parser.prog\n        return self._prog", "response": "Return the program name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize metaconfig for provisioning self.", "response": "def _metaconfigure(self, argv=None):\n        \"\"\"Initialize metaconfig for provisioning self.\"\"\"\n        metaconfig = self._get_metaconfig_class()\n        if not metaconfig:\n            return\n        if self.__class__ is metaconfig:\n            # don't get too meta\n            return\n        override = {\n            'conflict_handler': 'resolve',\n            'add_help': False,\n            'prog': self._parser_kwargs.get('prog'),\n        }\n        self._metaconf = metaconfig(**override)\n        metaparser = self._metaconf.build_parser(\n            options=self._metaconf._options, permissive=False, **override)\n        self._parser_kwargs.setdefault('parents', [])\n        self._parser_kwargs['parents'].append(metaparser)\n        self._metaconf._values = self._metaconf.load_options(\n            argv=argv)\n        self._metaconf.provision(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct an argparser from supplied options.", "response": "def build_parser(self, options=None, permissive=False, **override_kwargs):\n        \"\"\"Construct an argparser from supplied options.\n\n        :keyword override_kwargs: keyword arguments to override when calling\n            parser constructor.\n        :keyword permissive: when true, build a parser that does not validate\n            required arguments.\n        \"\"\"\n        kwargs = copy.copy(self._parser_kwargs)\n        kwargs.setdefault('formatter_class',\n                          argparse.ArgumentDefaultsHelpFormatter)\n        kwargs.update(override_kwargs)\n        if 'fromfile_prefix_chars' not in kwargs:\n            kwargs['fromfile_prefix_chars'] = '@'\n        parser = self._parser_class(**kwargs)\n        if options is None:\n            options = []\n            for _opt in self._options:\n                _kw = _opt.kwargs.copy()\n                if _kw.get('default') is None:\n                    _kw['default'] = argparse.SUPPRESS\n                options.append(Option(*_opt.args, **_kw))\n        for option in options:\n            option.add_argument(parser, permissive=permissive)\n        return parser"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cli_values(self, argv):\n        options = []\n        for option in self._options:\n            kwargs = option.kwargs.copy()\n            # Must explicitly set default to None or `store_true` and\n            # `store_false` actions will set the value to true or false,\n            # respectively.\n            kwargs['default'] = None\n            kwargs['required'] = False\n            options.append(Option(*option.args, **kwargs))\n        parser = self.build_parser(options, add_help=False)\n        parsed, extras = parser.parse_known_args(argv[1:] if argv else [])\n        if extras and argv:\n            valid, pass_thru = self.parse_passthru_args(argv[1:])\n            parsed, extras = parser.parse_known_args(valid)\n            self.pass_thru_args = pass_thru + extras\n        else:\n            # maybe reset pass_thru_args on subsequent calls\n            # parse() -> cli_values() is called post-plugin-init\n            self.pass_thru_args = []\n\n        return {k: v for k, v in vars(parsed).items() if v is not None}", "response": "Parse command - line arguments into values."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating all config values through the command - line parser.", "response": "def validate_config(self, values, argv=None, strict=False):\n        \"\"\"Validate all config values through the command-line parser.\n\n        This takes all supplied options (which could have been retrieved from a\n        number of sources (such as CLI, env vars, etc...) and then validates\n        them by running them through argparser (and raises SystemExit on\n        failure).\n\n        :returns dict: key/values for all config values (from all sources)\n        :raises: SystemExit\n        \"\"\"\n        options = []\n        for option in self._options:\n            kwargs = option.kwargs.copy()\n            if option.name in values:\n                if 'default' in kwargs:\n                    # Since we're overriding defaults, we need to\n                    # preserve the default value for the help text:\n                    help_text = kwargs.get('help')\n                    if help_text:\n                        if '(default: ' not in help_text:\n                            kwargs['help'] = '%s (default: %s)' % (\n                                help_text, kwargs['default']\n                            )\n                kwargs['default'] = values[option.name]\n                kwargs['required'] = False  # since we have a value\n            temp = Option(*option.args, **kwargs)\n            options.append(temp)\n        parser = self.build_parser(options,\n                                   formatter_class=argparse.HelpFormatter)\n        if argv:\n            parsed, extras = parser.parse_known_args(argv[1:])\n            if extras:\n                valid, _ = self.parse_passthru_args(argv[1:])\n                parsed, extras = parser.parse_known_args(valid)\n                if extras and strict:  # still\n                    self.build_parser(options)\n                    parser.parse_args(argv[1:])\n        else:\n            parsed = parser.parse_args([])\n\n        results = vars(parsed)\n        raise_for_group = {}\n        for option in self._options:\n            if option.kwargs.get('required'):\n                if option.dest not in results or results[option.dest] is None:\n                    if getattr(option, '_mutexgroup', None):\n                        raise_for_group.setdefault(option._mutexgroup, [])\n                        raise_for_group[option._mutexgroup].append(\n                            option._action)\n                    else:\n                        raise SystemExit(\"'%s' is required. See --help \"\n                                         \"for more info.\" % option.name)\n                else:\n                    if getattr(option, '_mutexgroup', None):\n                        raise_for_group.pop(option._mutexgroup, None)\n        if raise_for_group:\n            optstrings = [str(k.option_strings)\n                          for k in raise_for_group.values()[0]]\n            msg = \"One of %s required. \" % \" ,\".join(optstrings)\n            raise SystemExit(msg + \"See --help for more info.\")\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_defaults(self):\n        # dont need 'required' to determine the default\n        options = [copy.copy(opt) for opt in self._options]\n        for opt in options:\n            try:\n                del opt.kwargs['required']\n            except KeyError:\n                pass\n        parser = self.build_parser(options, permissive=True, add_help=False)\n        parsed, _ = parser.parse_known_args([])\n        return vars(parsed)", "response": "Use argparse to determine and return dict of defaults."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_ini(self, paths=None, namespace=None, permissive=False):\n        namespace = namespace or self.prog\n        results = {}\n        # DeprecationWarning: SafeConfigParser has been renamed to ConfigParser\n        # in Python 3.2. This alias will be removed in future versions. Use\n        # ConfigParser directly instead.\n        if sys.version_info < (3, 2):\n            self.ini_config = configparser.SafeConfigParser()\n        else:\n            self.ini_config = configparser.ConfigParser()\n\n        parser_errors = (configparser.NoOptionError,\n                         configparser.NoSectionError)\n\n        inipaths = list(paths or reversed(self._ini_paths))\n        # check that explicitly defined ini paths exist\n        for pth in inipaths:\n            if not os.path.isfile(pth):\n                raise OSError(errno.ENOENT, 'No such file or directory', pth)\n\n        read_ok = self.ini_config.read(inipaths)\n        assert read_ok == inipaths\n        dicts = (list(self.ini_config._sections.values()) +\n                 [self.ini_config.defaults()])\n        ini_options = {k for d in dicts for k in d.keys() if k != '__name__'}\n        if not ini_options:\n            return results\n\n        for option in self._options:\n            ini_section = option.kwargs.get('ini_section')\n            value = None\n            if ini_section:\n                try:\n                    value = self.ini_config.get(ini_section, option.name)\n                    results[option.dest] = option.type(value)\n                except parser_errors as err:\n                    # this is an ERROR and the next one is a DEBUG b/c\n                    # this code is executed only if the Option is defined\n                    # with the ini_section keyword argument\n                    LOG.error('Error parsing ini file: %r -- Continuing.',\n                              err)\n            if not value:\n                try:\n                    value = self.ini_config.get(namespace, option.name)\n                    results[option.dest] = option.type(value)\n                except parser_errors as err:\n                    LOG.debug('Error parsing ini file: %r -- Continuing.',\n                              err)\n            if option.dest in results:\n                ini_options.remove(option.dest)\n        if ini_options and not permissive:\n            raise simpl.exceptions.SimplConfigUnknownOption(\n                'No corresponding Option was found for the following '\n                'values in the ini file: %s'\n                % ', '.join([\"'%s'\" % o for o in ini_options]))\n        return results", "response": "Parse the ini file and return the configuration options."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds settings from keyring.", "response": "def parse_keyring(self, namespace=None):\n        \"\"\"Find settings from keyring.\"\"\"\n        results = {}\n        if not keyring:\n            return results\n        if not namespace:\n            namespace = self.prog\n        for option in self._options:\n            secret = keyring.get_password(namespace, option.name)\n            if secret:\n                results[option.dest] = option.type(secret)\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds settings from all sources.", "response": "def load_options(self, argv=None, keyring_namespace=None):\n        \"\"\"Find settings from all sources.\n\n        Only performs data type validation. Does not perform validation on\n        required, extra/unknown, or mutually exclusive options. To perform that\n        call `validate_config`.\n        \"\"\"\n        defaults = self.get_defaults()\n        args = self.cli_values(argv=argv)\n        env = self.parse_env()\n        secrets = self.parse_keyring(keyring_namespace)\n        ini = self.parse_ini()\n\n        results = defaults\n        results.update(ini)\n        results.update(secrets)\n        results.update(env)\n        results.update(args)\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse all options from all sources.", "response": "def parse(self, argv=None, keyring_namespace=None, strict=False):\n        \"\"\"Find settings from all sources.\n\n        :keyword strict: fail if unknown args are passed in.\n        :returns: dict of parsed option name and values\n        :raises: SystemExit if invalid arguments supplied along with stdout\n            message (same as argparser).\n        \"\"\"\n        if argv is None:\n            argv = self._argv or sys.argv\n        results = self.load_options(argv=argv,\n                                    keyring_namespace=keyring_namespace)\n        # Run validation\n        results = self.validate_config(results, argv=argv, strict=strict)\n        self._values = results\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling arguments to be passed thru a subprocess using '--'.", "response": "def parse_passthru_args(argv):\n        \"\"\"Handle arguments to be passed thru to a subprocess using '--'.\n\n        :returns: tuple of two lists; args and pass-thru-args\n        \"\"\"\n        if '--' in argv:\n            dashdash = argv.index(\"--\")\n            return argv[:dashdash], argv[dashdash + 1:]\n        return argv, []"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprovisioning this metaconfig s config with what we gathered.", "response": "def provision(self, conf):\n        \"\"\"Provision this metaconfig's config with what we gathered.\n\n        Since Config has native support for ini files, we just need to\n        let this metaconfig's config know about the ini file we found.\n\n        In future scenarios, this is where we would implement logic\n        specific to a metaconfig source if that source is not natively\n        supported by Config.\n        \"\"\"\n        if self.ini and self.ini not in conf._ini_paths:\n            conf._ini_paths.insert(0, self.ini)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef initialize_model(self, root_node):\n\n        LOGGER.debug(\"> Initializing model with '{0}' root node.\".format(root_node))\n\n        self.beginResetModel()\n        self.root_node = root_node\n        self.enable_model_triggers(True)\n        self.endResetModel()\n        return True", "response": "Initializes the model using given root node."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _send(self, email_message):\n        if not email_message.recipients():\n            return False\n\n        if set(email_message.recipients()).issubset(admin_emails()):\n            # Skip on admin notifications\n            return super(DevEmailBackend, self)._send(email_message)\n\n        from_email = sanitize_address(email_message.from_email, email_message.encoding)\n        try:\n            recipients = [sanitize_address(addr, email_message.encoding)\n                          for addr in settings.DEV_EMAIL_LIST]\n        except:\n            raise ImproperlyConfigured(\"You must set a DEV_EMAIL_LIST setting to use the Dev Email Backend.\")\n\n        message = email_message.message()\n        charset = message.get_charset().get_output_charset() if message.get_charset() else \"utf-8\"\n        try:\n            self.connection.sendmail(from_email, recipients,\n                                     force_bytes(message.as_string(), charset))\n        except:\n            if not self.fail_silently:\n                raise\n            return False\n        return True", "response": "A helper method that does the actual sending."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_version():\n    versions = {'netshow-core':\n                pkg_resources.require('netshow-core-lib')[0].version}\n\n    install_location = pkg_resources.require('netshow-core-lib')[0].location\n    _dir_entries = glob.glob(install_location +\n                             \"/../../../share/netshow-lib/providers/*\")\n    for _entry in _dir_entries:\n        provider_pkg = \"netshow-%s\" % (os.path.basename(_entry))\n        pkg_name = \"netshow-%s-lib\" % (os.path.basename(_entry))\n        versions[provider_pkg] = pkg_resources.require(pkg_name)[0].version\n\n    return versions", "response": "Returns a hash of versions of various netshow components."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef subscribe(self, objectID, varIDs=None, begin=0, end=2**31 - 1):\n        if varIDs is None:\n            if tc.LAST_STEP_VEHICLE_NUMBER in self._retValFunc:\n                varIDs = (tc.LAST_STEP_VEHICLE_NUMBER,)\n            else:\n                varIDs = (tc.ID_LIST,)\n        self._connection._subscribe(\n            self._subscribeID, begin, end, objectID, varIDs)", "response": "Subscribe to one or more object values for the given interval."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef subscribeContext(self, objectID, domain, dist, varIDs=None, begin=0, end=2**31 - 1):\n        if varIDs is None:\n            if tc.LAST_STEP_VEHICLE_NUMBER in self._retValFunc:\n                varIDs = (tc.LAST_STEP_VEHICLE_NUMBER,)\n            else:\n                varIDs = (tc.ID_LIST,)\n        self._connection._subscribeContext(\n            self._contextID, begin, end, objectID, domain, dist, varIDs)", "response": "Subscribe to objects of the given domain closer than dist to the object specified by objectID."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getParameter(self, objID, param):\n        self._connection._beginMessage(\n            self._cmdGetID, tc.VAR_PARAMETER, objID, 1 + 4 + len(param))\n        self._connection._packString(param)\n        result = self._connection._checkResult(\n            self._cmdGetID, tc.VAR_PARAMETER, objID)\n        return result.readString()", "response": "Returns the value of the given parameter for the given objID."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setParameter(self, objID, param, value):\n        self._connection._beginMessage(self._cmdSetID, tc.VAR_PARAMETER, objID,\n                                       1 + 4 + 1 + 4 + len(param) + 1 + 4 + len(value))\n        self._connection._string += struct.pack(\"!Bi\", tc.TYPE_COMPOUND, 2)\n        self._connection._packString(param)\n        self._connection._packString(value)\n        self._connection._sendExact()", "response": "Sets the value of the given parameter to value for the given objID."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _initialize_logging():\n\n    # Starting the console handler if a terminal is available.\n    if sys.stdout.isatty() or platform.system() in (\"Darwin\", \"Linux\"):\n        RuntimeGlobals.logging_console_handler = foundations.verbose.get_logging_console_handler()\n\n    # Defining logging formatters.\n    RuntimeGlobals.logging_formatters = {\"Default\": foundations.verbose.LOGGING_DEFAULT_FORMATTER,\n                                         \"Extended\": foundations.verbose.LOGGING_EXTENDED_FORMATTER,\n                                         \"Standard\": foundations.verbose.LOGGING_STANDARD_FORMATTER}", "response": "Initializes the Application logging."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the Application ui file.", "response": "def _initialize_applicationUiFile():\n    \"\"\"\n    Initializes the Application ui file.\n    \"\"\"\n\n    RuntimeGlobals.ui_file = umbra.ui.common.get_resource_path(UiConstants.ui_file)\n    if not foundations.common.path_exists(RuntimeGlobals.ui_file):\n        raise foundations.exceptions.FileExistsError(\"'{0}' ui file is not available, {1} will now close!\".format(\n            UiConstants.ui_file, Constants.application_name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nshows processing behavior. :param message: Operation description. :type message: unicode :return: Object. :rtype: object", "response": "def show_processing(message=\"\"):\n    \"\"\"\n    Shows processing behavior.\n\n    :param message: Operation description.\n    :type message: unicode\n    :return: Object.\n    :rtype: object\n    \"\"\"\n\n    def show_processingDecorator(object):\n        \"\"\"\n        Shows processing behavior.\n\n        :param object: Object to decorate.\n        :type object: object\n        :return: Object.\n        :rtype: object\n        \"\"\"\n\n        @functools.wraps(object)\n        def show_processingWrapper(*args, **kwargs):\n            \"\"\"\n            Shows processing behavior.\n\n            :param \\*args: Arguments.\n            :type \\*args: \\*\n            :param \\*\\*kwargs: Keywords arguments.\n            :type \\*\\*kwargs: \\*\\*\n            \"\"\"\n\n            RuntimeGlobals.engine.start_processing(message, warning=False)\n            try:\n                return object(*args, **kwargs)\n            finally:\n                RuntimeGlobals.engine.stop_processing(warning=False)\n\n        return show_processingWrapper\n\n    return show_processingDecorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndecorates a processing operation.", "response": "def encapsulate_processing(object):\n    \"\"\"\n    Encapsulates a processing operation.\n\n    :param object: Object to decorate.\n    :type object: object\n    :return: Object.\n    :rtype: object\n    \"\"\"\n\n    @functools.wraps(object)\n    def encapsulate_processing_wrapper(*args, **kwargs):\n        \"\"\"\n        Encapsulates a processing operation.\n\n        :param \\*args: Arguments.\n        :type \\*args: \\*\n        :param \\*\\*kwargs: Keywords arguments.\n        :type \\*\\*kwargs: \\*\\*\n        \"\"\"\n\n        RuntimeGlobals.engine._Umbra__store_processing_state()\n        RuntimeGlobals.engine.stop_processing(warning=False)\n        try:\n            return object(*args, **kwargs)\n        finally:\n            RuntimeGlobals.engine.stop_processing(warning=False)\n            RuntimeGlobals.engine._Umbra__restore_processing_state()\n\n    return encapsulate_processing_wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the user Application data directory.", "response": "def set_user_application_data_directory(directory):\n    \"\"\"\n    Sets the user Application data directory.\n\n    :param directory: Starting point for the directories tree creation.\n    :type directory: unicode\n    :return: Definition success.\n    :rtype: bool\n    \"\"\"\n\n    LOGGER.debug(\"> Current Application data directory '{0}'.\".format(directory))\n    if foundations.io.set_directory(directory):\n        for sub_directory in Constants.preferences_directories:\n            if not foundations.io.set_directory(os.path.join(directory, sub_directory)):\n                raise OSError(\"{0} | '{1}' directory creation failed , '{2}' will now close!\".format(\n                    __name__, os.path.join(directory, sub_directory), Constants.application_name))\n        return True\n    else:\n        raise OSError(\"{0} | '{1}' directory creation failed , '{2}' will now close!\".format(__name__,\n                                                                                             directory,\n                                                                                             Constants.application_name))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_command_line_parameters_parser():\n\n    parser = optparse.OptionParser(formatter=optparse.IndentedHelpFormatter(indent_increment=2,\n                                                                            max_help_position=8,\n                                                                            width=128,\n                                                                            short_first=1),\n                                   add_help_option=None)\n\n    parser.add_option(\"-h\",\n                      \"--help\",\n                      action=\"help\",\n                      help=\"'Display this help message and exit.'\")\n    parser.add_option(\"-a\",\n                      \"--about\",\n                      action=\"store_true\",\n                      default=False,\n                      dest=\"about\",\n                      help=\"'Display Application about message.'\")\n    parser.add_option(\"-v\",\n                      \"--verbose\",\n                      action=\"store\",\n                      type=\"int\",\n                      dest=\"verbosity_level\",\n                      help=\"'Application verbosity levels: 0 = Critical | 1 = Error | 2 = Warning | 3 = Info | 4 = Debug.'\")\n    parser.add_option(\"-f\",\n                      \"--logging_formatter\",\n                      action=\"store\",\n                      type=\"string\",\n                      dest=\"logging_formatter\",\n                      help=\"'Application logging formatter: '{0}'.'\".format(\n                          \", \".join(sorted(RuntimeGlobals.logging_formatters))))\n    parser.add_option(\"-u\",\n                      \"--user_application_data_directory\",\n                      action=\"store\",\n                      type=\"string\",\n                      dest=\"user_application_data_directory\",\n                      help=\"'User Application data directory'.\")\n    parser.add_option(\"-s\",\n                      \"--hide_splash_screen\",\n                      action=\"store_true\",\n                      default=False,\n                      dest=\"hide_splash_screen\",\n                      help=\"'Hide splashscreen'.\")\n    parser.add_option(\"-w\",\n                      \"--deactivate_worker_threads\",\n                      action=\"store_true\",\n                      default=False,\n                      dest=\"deactivate_worker_threads\",\n                      help=\"'Deactivate worker threads'.\")\n    parser.add_option(\"-x\",\n                      \"--startup_script\",\n                      action=\"store\",\n                      type=\"string\",\n                      dest=\"startup_script\",\n                      help=\"'Execute given startup script'.\")\n    parser.add_option(\"-t\",\n                      \"--trace_modules\",\n                      action=\"store\",\n                      default=\"{}\",\n                      type=\"string\",\n                      dest=\"trace_modules\",\n                      help=\"'Trace given modules'.\")\n    return parser", "response": "Returns the command line parameters parser."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the logging file path.", "response": "def get_logging_file(maximum_logging_files=10, retries=2 ^ 16):\n    \"\"\"\n    Returns the logging file path.\n\n    :param maximum_logging_files: Maximum allowed logging files in the logging directory.\n    :type maximum_logging_files: int\n    :param retries: Number of retries to generate a unique logging file name.\n    :type retries: int\n    :return: Logging file path.\n    :rtype: unicode\n    \"\"\"\n\n    logging_directory = os.path.join(RuntimeGlobals.user_application_data_directory, Constants.logging_directory)\n    for file in sorted(foundations.walkers.files_walker(logging_directory),\n                       key=lambda y: os.path.getmtime(os.path.abspath(y)), reverse=True)[maximum_logging_files:]:\n        try:\n            os.remove(file)\n        except OSError:\n            LOGGER.warning(\n                \"!> {0} | Cannot remove '{1}' file!\".format(__name__, file, Constants.application_name))\n\n    path = None\n    for i in range(retries):\n        path = os.path.join(RuntimeGlobals.user_application_data_directory,\n                            Constants.logging_directory,\n                            Constants.logging_file.format(foundations.strings.get_random_sequence()))\n        if not os.path.exists(path):\n            break\n\n    if path is None:\n        raise umbra.exceptions.EngineConfigurationError(\n            \"{0} | Logging file is not available, '{1}' will now close!\".format(__name__, Constants.application_name))\n\n    LOGGER.debug(\"> Current Logging file: '{0}'\".format(path))\n\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart the Application. :param engine: Engine. :type engine: QObject :param parameters: Command line parameters. :type parameters: tuple :param components_paths: Components components_paths. :type components_paths: tuple or list :param requisite_components: Requisite components names. :type requisite_components: tuple or list :param visible_components: Visible components names. :type visible_components: tuple or list :return: Definition success. :rtype: bool", "response": "def run(engine, parameters, components_paths=None, requisite_components=None, visible_components=None):\n    \"\"\"\n    Starts the Application.\n\n    :param engine: Engine.\n    :type engine: QObject\n    :param parameters: Command line parameters.\n    :type parameters: tuple\n    :param components_paths: Components components_paths.\n    :type components_paths: tuple or list\n    :param requisite_components: Requisite components names.\n    :type requisite_components: tuple or list\n    :param visible_components: Visible components names.\n    :type visible_components: tuple or list\n    :return: Definition success.\n    :rtype: bool\n    \"\"\"\n\n    # Command line parameters handling.\n    RuntimeGlobals.parameters, RuntimeGlobals.arguments = parameters\n\n    foundations.trace.evaluate_trace_request(RuntimeGlobals.parameters.trace_modules, foundations.verbose.tracer)\n\n    if RuntimeGlobals.parameters.about:\n        for line in SESSION_HEADER_TEXT:\n            sys.stdout.write(\"{0}\\n\".format(line))\n        foundations.core.exit(1)\n\n    # Redirecting standard output and error messages.\n    sys.stdout = foundations.verbose.StandardOutputStreamer(LOGGER)\n    sys.stderr = foundations.verbose.StandardOutputStreamer(LOGGER)\n\n    # Setting application verbose level.\n    foundations.verbose.set_verbosity_level(4)\n\n    # Setting user application data directory.\n    if RuntimeGlobals.parameters.user_application_data_directory:\n        user_application_data_directory = RuntimeGlobals.user_application_data_directory = \\\n            RuntimeGlobals.parameters.user_application_data_directory\n    else:\n        user_application_data_directory = RuntimeGlobals.user_application_data_directory = \\\n            foundations.environment.get_user_application_data_directory()\n\n    if not set_user_application_data_directory(user_application_data_directory):\n        raise umbra.exceptions.EngineConfigurationError(\n            \"{0} | '{1}' user Application data directory is not available, '{2}' will now close!\".format(\n                __name__, RuntimeGlobals.user_application_data_directory, Constants.application_name))\n\n    if foundations.environment.get_temporary_directory() in user_application_data_directory:\n        umbra.ui.widgets.message_box.message_box(\"Error\",\n                                                 \"Error\",\n                                                 \"{0} failed to use the default user Application data directory to store its preferences \\\nand has defaulted to the following directory:\\n\\n\\t'{1}'.\\n\\nReasons for this are various:\\n\\\n\\t- Undefined 'APPDATA' ( Windows ) or 'HOME' ( Mac Os X, Linux ) environment variables.\\n\\\n\\t- User name with non 'UTF-8' encoding compliant characters.\\n\\\n\\t- Non 'UTF-8' encoding compliant characters in the preferences directory path.\\n\\n\\\nYou will have to define your own preferences directory by launching {0} with the \\\n'-u \\\"path\\\\to\\\\the\\\\custom\\\\preferences\\\\directory\\\"' command line parameter.\".format(\n                                                     Constants.application_name,\n                                                     user_application_data_directory))\n\n    LOGGER.debug(\"> Application Python interpreter: '{0}'\".format(sys.executable))\n    LOGGER.debug(\"> Application PyQt version: '{0}'\".format(PYQT_VERSION_STR))\n    LOGGER.debug(\"> Application startup location: '{0}'\".format(os.getcwd()))\n    LOGGER.debug(\"> Session user Application data directory: '{0}'\".format(\n        RuntimeGlobals.user_application_data_directory))\n\n    LOGGER.debug(\"> Initializing '{0}'!\".format(Constants.application_name))\n\n    # Getting the logging file path.\n    RuntimeGlobals.logging_file = get_logging_file()\n    RuntimeGlobals.logging_file_handler = foundations.verbose.get_logging_file_handler(\n        file=RuntimeGlobals.logging_file)\n\n    # Getting the patches file path.\n    RuntimeGlobals.patches_file = os.path.join(RuntimeGlobals.user_application_data_directory,\n                                               Constants.patches_directory,\n                                               Constants.patches_file)\n    # Initializing the patches manager.\n    RuntimeGlobals.patches_manager = umbra.managers.patches_manager.PatchesManager(RuntimeGlobals.patches_file,\n                                                                                   [os.path.join(path,\n                                                                                                 Constants.patches_directory)\n                                                                                    for path in\n                                                                                    RuntimeGlobals.resources_directories])\n    RuntimeGlobals.patches_manager.register_patches() and RuntimeGlobals.patches_manager.apply_patches()\n\n    # Retrieving settings file.\n    RuntimeGlobals.settings_file = os.path.join(RuntimeGlobals.user_application_data_directory,\n                                                Constants.settings_directory,\n                                                Constants.settings_file)\n\n    RuntimeGlobals.settings = Preferences(RuntimeGlobals.settings_file)\n\n    LOGGER.debug(\"> Retrieving default layouts.\")\n    RuntimeGlobals.settings.set_default_layouts((\"startup_centric\",))\n\n    foundations.common.path_exists(RuntimeGlobals.settings_file) or RuntimeGlobals.settings.set_default_preferences()\n\n    LOGGER.debug(\"> Retrieving stored verbose level.\")\n    RuntimeGlobals.verbosity_level = RuntimeGlobals.parameters.verbosity_level \\\n        if RuntimeGlobals.parameters.verbosity_level is not None else \\\n        foundations.common.get_first_item(RuntimeGlobals.settings.get_key(\"Settings\", \"verbosity_level\").toInt())\n    LOGGER.debug(\"> Setting logger verbosity level to: '{0}'.\".format(RuntimeGlobals.verbosity_level))\n    foundations.verbose.set_verbosity_level(RuntimeGlobals.verbosity_level)\n    RuntimeGlobals.settings.set_key(\"Settings\", \"verbosity_level\", RuntimeGlobals.verbosity_level)\n\n    LOGGER.debug(\"> Retrieving stored logging formatter.\")\n    logging_formatter = RuntimeGlobals.parameters.logging_formatter if RuntimeGlobals.parameters.logging_formatter is not None else \\\n        foundations.strings.to_string(RuntimeGlobals.settings.get_key(\"Settings\", \"logging_formatter\").toString())\n    logging_formatter = logging_formatter if logging_formatter in RuntimeGlobals.logging_formatters else None\n    RuntimeGlobals.logging_active_formatter = logging_formatter if logging_formatter is not None else Constants.logging_default_formatter\n    LOGGER.debug(\"> Setting logging formatter: '{0}'.\".format(RuntimeGlobals.logging_active_formatter))\n    for handler in (RuntimeGlobals.logging_console_handler, RuntimeGlobals.logging_file_handler):\n        handler and handler.setFormatter(RuntimeGlobals.logging_formatters[RuntimeGlobals.logging_active_formatter])\n\n    # Starting the session handler.\n    RuntimeGlobals.logging_session_handler = foundations.verbose.get_logging_stream_handler()\n    RuntimeGlobals.logging_session_handler_stream = RuntimeGlobals.logging_session_handler.stream\n\n    LOGGER.info(Constants.logging_separators)\n    for line in SESSION_HEADER_TEXT:\n        LOGGER.info(line)\n    LOGGER.info(\"{0} | Session started at: {1}\".format(Constants.application_name, time.strftime('%X - %x')))\n    LOGGER.info(Constants.logging_separators)\n    LOGGER.info(\"{0} | Starting Interface!\".format(Constants.application_name))\n\n    # Initializing splashscreen.\n    if RuntimeGlobals.parameters.hide_splash_screen:\n        LOGGER.debug(\"> SplashScreen skipped by 'hide_splash_screen' command line parameter.\")\n    else:\n        LOGGER.debug(\"> Initializing splashscreen.\")\n\n        RuntimeGlobals.splashscreen_image = QPixmap(umbra.ui.common.get_resource_path(UiConstants.splash_screen_image))\n        RuntimeGlobals.splashscreen = Delayed_QSplashScreen(RuntimeGlobals.splashscreen_image, text_color=Qt.white)\n        RuntimeGlobals.splashscreen.show_message(\n            \"{0} - {1} | Initializing {0}.\".format(Constants.application_name, Constants.version))\n        RuntimeGlobals.splashscreen.show()\n\n    # Initializing requests stack.\n    RuntimeGlobals.requests_stack = collections.deque()\n\n    # Initializing engine.\n    RuntimeGlobals.engine = engine(parent=None,\n                                   components_paths=components_paths,\n                                   requisite_components=requisite_components,\n                                   visible_components=visible_components,\n                                   splashscreen=RuntimeGlobals.splashscreen,\n                                   requests_stack=RuntimeGlobals.requests_stack,\n                                   patches_manager=RuntimeGlobals.patches_manager,\n                                   user_application_data_directory=RuntimeGlobals.user_application_data_directory,\n                                   logging_session_handler=RuntimeGlobals.logging_session_handler,\n                                   logging_file_handler=RuntimeGlobals.logging_file_handler,\n                                   logging_console_handler=RuntimeGlobals.logging_console_handler,\n                                   logging_session_handler_stream=RuntimeGlobals.logging_session_handler_stream,\n                                   logging_active_formatter=RuntimeGlobals.logging_active_formatter,\n                                   settings=RuntimeGlobals.settings,\n                                   verbosity_level=RuntimeGlobals.verbosity_level,\n                                   parameters=RuntimeGlobals.parameters,\n                                   arguments=RuntimeGlobals.arguments)\n    RuntimeGlobals.engine.show()\n    RuntimeGlobals.engine.raise_()\n\n    return sys.exit(RuntimeGlobals.application.exec_())"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexits the Application. :param exit_code: Exit code. :type exit_code: int", "response": "def exit(exit_code=0):\n    \"\"\"\n    Exits the Application.\n\n    :param exit_code: Exit code.\n    :type exit_code: int\n    \"\"\"\n\n    for line in SESSION_FOOTER_TEXT:\n        LOGGER.info(line)\n\n    foundations.verbose.remove_logging_handler(RuntimeGlobals.logging_console_handler)\n\n    RuntimeGlobals.application.exit(exit_code)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef visible_components(self, value):\n\n        if value is not None:\n            assert type(value) in (tuple, list), \"'{0}' attribute: '{1}' type is not 'tuple' or 'list'!\".format(\n                \"visible_components\", value)\n            for element in value:\n                assert type(element) is unicode, \"'{0}' attribute: '{1}' type is not 'unicode'!\".format(\n                    \"visible_components\", element)\n        self.__visible_components = value", "response": "Setter for self. __visible_components"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef logging_active_formatter(self, value):\n\n        if value is not None:\n            assert type(value) in (\n                unicode, QString), \"'{0}' attribute: '{1}' type is not 'unicode' or 'QString'!\".format(\n                \"logging_active_formatter\", value)\n        self.__logging_active_formatter = value", "response": "Setter for **self. logging_active_formatter** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef verbosity_level(self, value):\n\n        if value is not None:\n            assert type(value) is int, \"'{0}' attribute: '{1}' type is not 'int'!\".format(\"verbosity_level\", value)\n            assert value >= 0 and value <= 4, \"'{0}' attribute: Value need to be exactly beetween 0 and 4!\".format(\n                \"verbosity_level\")\n        self.__verbosity_level = value", "response": "Sets the verbosity level of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resizeEvent(self, event):\n\n        LOGGER.debug(\"> Application resize event accepted!\")\n        self.size_changed.emit(event)\n        event.accept()", "response": "Reimplement the QWidget. resizeEvent method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the Components. :param requisite: Set only requisite Components. :type requisite: bool", "response": "def __set_components(self, requisite=True):\n        \"\"\"\n        Sets the Components.\n\n        :param requisite: Set only requisite Components.\n        :type requisite: bool\n        \"\"\"\n\n        components = self.__components_manager.list_components()\n        candidate_components = \\\n            getattr(set(components), \"intersection\" if requisite else \"difference\")(self.__requisite_components)\n        deactivated_components = self.__settings.get_key(\"Settings\", \"deactivated_components\").toString().split(\",\")\n        candidate_components = \\\n            sorted(filter(lambda x: x not in deactivated_components, candidate_components), key=(components).index)\n\n        for component in candidate_components:\n            try:\n                profile = self.__components_manager.components[component]\n                interface = self.__components_manager.get_interface(component)\n\n                setattr(self,\n                        \"_{0}__{1}\".format(self.__class__.__name__, foundations.namespace.get_leaf(component, \".\")),\n                        interface)\n\n                self.__splashscreen and self.__splashscreen.show_message(\n                    \"{0} - {1} | Activating {2}.\".format(self.__class__.__name__, Constants.version, component))\n                interface.activate(self)\n                if profile.category in (\"Default\", \"QObject\"):\n                    interface.initialize()\n                elif profile.category == \"QWidget\":\n                    interface.add_widget()\n                    interface.initialize_ui()\n            except Exception as error:\n                if requisite:\n                    message = \"'{0}' Component failed to activate!\\nException raised: {1}\"\n                    handler = umbra.reporter.system_exit_exception_handler\n                else:\n                    message = \"'{0}' Component failed to activate, unexpected behavior may occur!\\nException raised: {1}\"\n                    handler = umbra.reporter.base_exception_handler\n\n                exception = manager.exceptions.ComponentActivationError(message.format(component, error))\n                handler(exception)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __set_locals(self):\n\n        for globals in (Constants, RuntimeGlobals, UiConstants):\n            self.__locals[globals.__name__] = globals\n\n        self.__locals[Constants.application_name] = self\n        self.__locals[\"application\"] = self\n        self.__locals[\"patches_manager\"] = self.__patches_manager\n        self.__locals[\"components_manager\"] = self.__components_manager\n        self.__locals[\"actions_manager\"] = self.__actions_manager\n        self.__locals[\"file_system_events_manager\"] = self.__file_system_events_manager\n        self.__locals[\"notifications_manager\"] = self.__notifications_manager\n        self.__locals[\"layouts_manager\"] = self.__layouts_manager\n        self.__locals[\"LOGGER\"] = LOGGER\n\n        LOGGER.debug(\"> Defined locals: '{0}'.\".format(self.__locals))", "response": "Sets the locals for the requests_stack."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprocess the requests stack.", "response": "def __process_requests_stack(self):\n        \"\"\"\n        Process the requests stack.\n        \"\"\"\n\n        while self.__requests_stack:\n            try:\n                exec self.__requests_stack.popleft() in self.__locals\n            except Exception as error:\n                umbra.exceptions.notify_exception_handler(error)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __components_instantiation_callback(self, profile):\n\n        self.__splashscreen and self.__splashscreen.show_message(\n            \"{0} - {1} | Instantiating {2} Component.\".format(self.__class__.__name__, Constants.version,\n                                                              profile.name))", "response": "Defines a callback for Components instantiation."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __store_processing_state(self):\n\n        steps = self.Application_Progress_Status_processing.Processing_progressBar.maximum()\n        value = self.Application_Progress_Status_processing.Processing_progressBar.value()\n        message = self.Application_Progress_Status_processing.Processing_label.text()\n        state = self.__is_processing\n\n        self.__processing_state = steps, value, message, state", "response": "Stores the processing state."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrestores the processing state.", "response": "def __restore_processing_state(self):\n        \"\"\"\n        Restores the processing state.\n        \"\"\"\n\n        steps, value, message, state = self.__processing_state\n\n        self.Application_Progress_Status_processing.Processing_progressBar.setRange(0, steps)\n        self.Application_Progress_Status_processing.Processing_progressBar.setValue(value)\n        self.set_processing_message(message, warning=False)\n        self.__is_processing = state\n        state and self.Application_Progress_Status_processing.show()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_verbosity_level(self, verbosity_level):\n\n        self.__verbosity_level = verbosity_level\n        foundations.verbose.set_verbosity_level(verbosity_level)\n        self.__settings.set_key(\"Settings\", \"verbosity_level\", verbosity_level)\n        self.verbosity_level_changed.emit(verbosity_level)\n        return True", "response": "Sets the Application verbosity level."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the Application visual style.", "response": "def set_visual_style(self, full_screen_style=False):\n        \"\"\"\n        Sets the Application visual style.\n\n        :param full_screen_style: Use fullscreen stylesheet file.\n        :type full_screen_style: bool\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        LOGGER.debug(\"> Setting Application visual style.\")\n        platform_styles = {\"Windows\": ((\"Windows\", \"Microsoft\"),\n                                       UiConstants.windows_style,\n                                       UiConstants.windows_stylesheet_file,\n                                       UiConstants.windows_full_screen_stylesheet_file),\n                           \"Darwin\": ((\"Darwin\",),\n                                      UiConstants.darwin_style,\n                                      UiConstants.darwin_stylesheet_file,\n                                      UiConstants.darwin_full_screen_stylesheet_file),\n                           \"Linux\": ((\"Linux\",),\n                                     UiConstants.linux_style,\n                                     UiConstants.linux_stylesheet_file,\n                                     UiConstants.linux_full_screen_stylesheet_file)}\n\n        style_sheet_file = None\n        for platform_style, settings in platform_styles.iteritems():\n            LOGGER.debug(\"> Setting '{0}' visual style.\".format(platform_style))\n            platform_systems, style, styleSheeFile, full_screen_style_sheet_file = settings\n            if platform.system() in platform_systems:\n                RuntimeGlobals.application.setStyle(style)\n                style_sheet_path = umbra.ui.common.get_resource_path(styleSheeFile)\n                if full_screen_style:\n                    full_screen_style_sheet_path = umbra.ui.common.get_resource_path(full_screen_style_sheet_file,\n                                                                                     raise_exception=False)\n                    style_sheet_path = full_screen_style_sheet_path or style_sheet_path\n                style_sheet_file = foundations.io.File(style_sheet_path)\n                break\n\n        if not style_sheet_file:\n            raise foundations.exceptions.FileExistsError(\n                \"{0} | No stylesheet file found, visual style will not be applied!\".format(self.__class__.__name__))\n\n        if foundations.common.path_exists(style_sheet_file.path):\n            LOGGER.debug(\"> Reading style sheet file: '{0}'.\".format(style_sheet_file.path))\n            style_sheet_file.cache()\n            for i, line in enumerate(style_sheet_file.content):\n                search = re.search(r\"url\\((?P<url>.*)\\)\", line)\n                if not search:\n                    continue\n\n                style_sheet_file.content[i] = line.replace(search.group(\"url\"),\n                                                           foundations.strings.to_forward_slashes(\n                                                               umbra.ui.common.get_resource_path(search.group(\"url\"))))\n            RuntimeGlobals.application.setStyleSheet(QString(\"\".join(style_sheet_file.content)))\n            return True\n        else:\n            raise foundations.exceptions.FileExistsError(\n                \"{0} | '{1}' stylesheet file is not available, visual style will not be applied!\".format(\n                    self.__class__.__name__, style_sheet_file.path))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntoggles Application fullscreen state.", "response": "def toggle_full_screen(self, *args):\n        \"\"\"\n        Toggles Application fullscreen state.\n\n        :param \\*args: Arguments.\n        :type \\*args: \\*\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        LOGGER.debug(\"> Toggling FullScreen state.\")\n\n        if self.is_full_screen():\n            self.setUnifiedTitleAndToolBarOnMac(True)\n            self.set_visual_style(full_screen_style=False)\n            self.showNormal()\n            # TODO: Remove hack that ensure toolBar is repainted.\n            platform.system() == \"Darwin\" and self.resize(self.size().width() + 1, self.size().height() + 1)\n        else:\n            self.setUnifiedTitleAndToolBarOnMac(False)\n            self.set_visual_style(full_screen_style=True)\n            self.showFullScreen()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the processing message.", "response": "def set_processing_message(self, message, warning=True):\n        \"\"\"\n        Sets the processing operation message.\n\n        :param message: Operation description.\n        :type message: unicode\n        :param warning: Emit warning message.\n        :type warning: int\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if not self.__is_processing:\n            warning and LOGGER.warning(\n                \"!> {0} | Engine not processing, 'set_processing_message' request has been ignored!\".format(\n                    self.__class__.__name__))\n            return False\n\n        LOGGER.debug(\"> Setting processing message!\")\n\n        self.Application_Progress_Status_processing.Processing_label.setText(message)\n        self.process_events()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstep the processing operation.", "response": "def step_processing(self, warning=True):\n        \"\"\"\n        Steps the processing operation progress indicator.\n\n        :param warning: Emit warning message.\n        :type warning: int\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if not self.__is_processing:\n            warning and LOGGER.warning(\n                \"!> {0} | Engine is not processing, 'step_processing' request has been ignored!\".format(\n                    self.__class__.__name__))\n            return False\n\n        LOGGER.debug(\"> Stepping processing operation!\")\n\n        self.Application_Progress_Status_processing.Processing_progressBar.setValue(\n            self.Application_Progress_Status_processing.Processing_progressBar.value() + 1)\n        self.process_events()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stop_processing(self, warning=True):\n\n        if not self.__is_processing:\n            warning and LOGGER.warning(\n                \"!> {0} | Engine is not processing, 'stop_processing' request has been ignored!\".format(\n                    self.__class__.__name__))\n            return False\n\n        LOGGER.debug(\"> Stopping processing operation!\")\n\n        self.__is_processing = False\n        self.Application_Progress_Status_processing.Processing_label.setText(QString())\n        self.Application_Progress_Status_processing.Processing_progressBar.setRange(0, 100)\n        self.Application_Progress_Status_processing.Processing_progressBar.setValue(0)\n        self.Application_Progress_Status_processing.hide()\n        return True", "response": "Registers the end of a processing operation.\n\n        :param warning: Emit warning message.\n        :type warning: int\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef quit(self, exit_code=0, event=None):\n\n        # --- Running on_close components methods. ---\n        for component in reversed(self.__components_manager.list_components()):\n            interface = self.__components_manager.get_interface(component)\n            if not interface:\n                continue\n\n            if not interface.activated:\n                continue\n\n            if not hasattr(interface, \"on_close\"):\n                continue\n\n            if not interface.on_close():\n                event and event.ignore()\n                return\n\n        # Storing current layout.\n        self.__layouts_manager.store_startup_layout()\n        self.__settings.settings.sync()\n\n        # Stopping worker threads.\n        for worker_thread in self.__worker_threads:\n            LOGGER.debug(\"> Stopping worker thread: '{0}'.\".format(worker_thread))\n            if not worker_thread.isFinished():\n                worker_thread.quit()\n            worker_thread.wait()\n\n        foundations.verbose.remove_logging_handler(self.__logging_file_handler)\n        foundations.verbose.remove_logging_handler(self.__logging_session_handler)\n        # foundations.verbose.remove_logging_handler(self.__logging_console_handler)\n\n        # Stopping the Application timer.\n        self.__timer.stop()\n        self.__timer = None\n\n        self.deleteLater()\n        event and event.accept()\n\n        exit(exit_code)", "response": "Quits the Application.\n\n        :param exit_code: Exit code.\n        :type exit_code: int\n        :param event: QEvent.\n        :type event: QEvent"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef horizontal_headers(self, value):\n\n        if value is not None:\n            assert type(value) is OrderedDict, \"'{0}' attribute: '{1}' type is not 'OrderedDict'!\".format(\n                \"horizontal_headers\", value)\n        self.__horizontal_headers = value", "response": "Set the value of the internal _horizontal_headers attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef default_node(self, value):\n\n        if value is not None:\n            assert issubclass(value, AbstractCompositeNode), \\\n                \"'{0}' attribute: '{1}' is not a '{2}' subclass!\".format(\n                    \"default_node\", value, AbstractCompositeNode.__name__)\n        self.__default_node = value", "response": "Set the default node for this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setData(self, index, value, role=Qt.EditRole):\n\n        if not index.isValid():\n            return False\n\n        node = self.get_node(index)\n        if role == Qt.DisplayRole or role == Qt.EditRole:\n            value = foundations.strings.to_string(value.toString())\n            roles = {Qt.DisplayRole: value, Qt.EditRole: value}\n        else:\n            roles = {role: value}\n\n        if index.column() == 0:\n            if (node and hasattr(node, \"roles\")):\n                node.roles.update(roles)\n                node.name = value\n        else:\n            attribute = self.get_attribute(node, index.column())\n            if (attribute and hasattr(attribute, \"roles\")):\n                attribute.roles.update(roles)\n                attribute.value = value\n\n        self.dataChanged.emit(index, index)\n        return True", "response": "Updates the data of the item with the given index to the given value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef headerData(self, section, orientation, role=Qt.DisplayRole):\n\n        if role == Qt.DisplayRole:\n            if orientation == Qt.Horizontal:\n                if section < len(self.__horizontal_headers):\n                    return self.__horizontal_headers.keys()[section]\n            elif orientation == Qt.Vertical:\n                if section < len(self.__vertical_headers):\n                    return self.__vertical_headers.keys()[section]\n        return QVariant()", "response": "Reimplement the QAbstractItemModel. headerData method."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef removeRows(self, row, count, parent=QModelIndex()):\n\n        parent_node = self.get_node(parent)\n        self.beginRemoveRows(parent, row, row + count - 1)\n        success = True\n        for i in range(count):\n            success *= True if parent_node.remove_child(row) else False\n        self.endRemoveRows()\n        return success", "response": "Reimplement the QAbstractItemModel. removeRows method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the Node at given index.", "response": "def get_node(self, index):\n        \"\"\"\n        Returns the Node at given index.\n\n        :param index: Index.\n        :type index: QModelIndex\n        :return: Node.\n        :rtype: AbstractCompositeNode or GraphModelNode\n        \"\"\"\n\n        if not index.isValid():\n            return self.__root_node\n        return index.internalPointer() or self.__root_node"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the given Node attribute associated to the given column.", "response": "def get_attribute(self, node, column):\n        \"\"\"\n        Returns the given Node attribute associated to the given column.\n\n        :param node: Node.\n        :type node: AbstractCompositeNode or GraphModelNode\n        :param column: Column.\n        :type column: int\n        :return: Attribute.\n        :rtype: Attribute\n        \"\"\"\n\n        if column > 0 and column < len(self.__horizontal_headers):\n            return node.get(self.__horizontal_headers[self.__horizontal_headers.keys()[column]], None)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn given Node index.", "response": "def get_node_index(self, node):\n        \"\"\"\n        Returns given Node index.\n\n        :param node: Node.\n        :type node: AbstractCompositeNode or GraphModelNode\n        :return: Index.\n        :rtype: QModelIndex\n        \"\"\"\n\n        if node == self.__root_node:\n            return QModelIndex()\n        else:\n            row = node.row()\n            return self.createIndex(row, 0, node) if row is not None else QModelIndex()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns given Node attribute index at given column.", "response": "def get_attribute_index(self, node, column):\n        \"\"\"\n        Returns given Node attribute index at given column.\n\n        :param node: Node.\n        :type node: AbstractCompositeNode or GraphModelNode\n        :param column: Attribute column.\n        :type column: int\n        :return: Index.\n        :rtype: QModelIndex\n        \"\"\"\n\n        if column > 0 and column < len(self.__horizontal_headers):\n            row = node.row()\n            return self.createIndex(row, column, node) if row is not None else QModelIndex()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_family(self, pattern=r\".*\", flags=0, node=None):\n\n        return self.__root_node.find_family(pattern, flags, node or self.__root_node)", "response": "Returns the Nodes from given family."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_node(self, attribute):\n\n        for model in GraphModel._GraphModel__models_instances.itervalues():\n            for node in foundations.walkers.nodes_walker(model.root_node):\n                if attribute in node.get_attributes():\n                    return node", "response": "Finds the Node with given attribute."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind the model associated with given object.", "response": "def find_model(object):\n        \"\"\"\n        Returns the model(s) associated with given object.\n\n        :param object: Node / Attribute.\n        :type object: GraphModelNode or GraphModelAttribute\n        :return: Model(s).\n        :rtype: list\n        \"\"\"\n\n        models = []\n        for model in GraphModel._GraphModel__models_instances.itervalues():\n            for node in foundations.walkers.nodes_walker(model.root_node):\n                if node is object:\n                    models.append(model)\n\n                for attribute in node.get_attributes():\n                    if attribute is object:\n                        models.append(model)\n        return models"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nenable Model Nodes and attributes triggers.", "response": "def enable_model_triggers(self, state):\n        \"\"\"\n        Enables Model Nodes and attributes triggers.\n\n        :param state: Inform model state.\n        :type state: bool\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        for node in foundations.walkers.nodes_walker(self.root_node):\n            node.trigger_model = state\n\n            for attribute in node.get_attributes():\n                attribute.trigger_model = state"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall self. dataChanged with given Node index.", "response": "def node_changed(self, node):\n        \"\"\"\n        Calls :meth:`QAbstractItemModel.dataChanged` with given Node index.\n\n        :param node: Node.\n        :type node: AbstractCompositeNode or GraphModelNode\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        index = self.get_node_index(node)\n        if index is not None:\n            self.dataChanged.emit(index, index)\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall self. dataChanged with given Node attribute index.", "response": "def attribute_changed(self, node, column):\n        \"\"\"\n        Calls :meth:`QAbstractItemModel.dataChanged` with given Node attribute index.\n\n        :param node: Node.\n        :type node: AbstractCompositeNode or GraphModelNode\n        :param column: Attribute column.\n        :type column: int\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        index = self.get_attribute_index(node, column)\n        if index is not None:\n            self.dataChanged.emit(index, index)\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef activate(self, engine):\n\n        LOGGER.debug(\"> Activating '{0}' Component.\".format(self.__class__.__name__))\n\n        self.__ui_resources_directory = os.path.join(os.path.dirname(__file__), self.__ui_resources_directory)\n        self.__engine = engine\n\n        self.__settings = self.__engine.settings\n\n        self.activated = True\n        return True", "response": "Activates the Component.\n\n        :param engine: Engine to attach the Component to.\n        :type engine: QObject\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the Component ui.", "response": "def initialize_ui(self):\n        \"\"\"\n        Initializes the Component ui.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        LOGGER.debug(\"> Initializing '{0}' Component ui.\".format(self.__class__.__name__))\n\n        self.__model = ComponentsModel(self, horizontal_headers=self.__headers)\n        self.set_components()\n\n        self.Components_Manager_Ui_treeView.setParent(None)\n        self.Components_Manager_Ui_treeView = Components_QTreeView(self, self.__model)\n        self.Components_Manager_Ui_treeView.setObjectName(\"Components_Manager_Ui_treeView\")\n        self.Components_Manager_Ui_gridLayout.setContentsMargins(self.__tree_view_inner_margins)\n        self.Components_Manager_Ui_gridLayout.addWidget(self.Components_Manager_Ui_treeView, 0, 0)\n        self.__view = self.Components_Manager_Ui_treeView\n        self.__view.setContextMenuPolicy(Qt.ActionsContextMenu)\n        self.__view_add_actions()\n\n        self.Components_Informations_textBrowser.setText(self.__components_informations_default_text)\n\n        self.Components_Manager_Ui_splitter.setSizes([16777215, 1])\n\n        # Signals / Slots.\n        self.__view.selectionModel().selectionChanged.connect(self.__view_selectionModel__selectionChanged)\n        self.refresh_nodes.connect(self.__model__refresh_nodes)\n\n        self.initialized_ui = True\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_startup(self):\n\n        LOGGER.debug(\"> Calling '{0}' Component Framework 'on_startup' method.\".format(self.__class__.__name__))\n\n        self.refresh_nodes.emit()\n        return True", "response": "Defines the slot triggered by Framework startup."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd the **Components_Manager_Ui_treeView** actions.", "response": "def __view_add_actions(self):\n        \"\"\"\n        Sets the **Components_Manager_Ui_treeView** actions.\n        \"\"\"\n\n        self.Components_Manager_Ui_treeView.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.ComponentsManagerUi|Activate Component(s)\",\n            slot=self.__view_activate_components_action__triggered))\n        self.Components_Manager_Ui_treeView.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.ComponentsManagerUi|Deactivate Component(s)\",\n            slot=self.__view_deactivate_components_action__triggered))\n\n        separator_action = QAction(self.Components_Manager_Ui_treeView)\n        separator_action.setSeparator(True)\n        self.Components_Manager_Ui_treeView.addAction(separator_action)\n\n        self.Components_Manager_Ui_treeView.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.ComponentsManagerUi|Reload Component(s)\",\n            slot=self.__view_reload_components_action__triggered))\n\n        separator_action = QAction(self.Components_Manager_Ui_treeView)\n        separator_action.setSeparator(True)\n        self.Components_Manager_Ui_treeView.addAction(separator_action)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __store_deactivated_components(self):\n\n        deactivated_components = []\n        for node in foundations.walkers.nodes_walker(self.__model.root_node):\n            if node.family == \"Component\":\n                node.component.interface.activated or deactivated_components.append(node.component.name)\n\n        LOGGER.debug(\"> Storing '{0}' deactivated Components.\".format(\", \".join(deactivated_components)))\n        self.__settings.set_key(\"Settings\", \"deactivated_components\", \",\".join(deactivated_components))", "response": "Stores deactivated Components in settings file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef activate_components_ui(self):\n\n        selected_components = self.get_selected_components()\n\n        self.__engine.start_processing(\"Activating Components ...\", len(selected_components))\n        activation_failed_components = []\n        for component in selected_components:\n            if not component.interface.activated:\n                success = self.activate_component(component.name) or False\n                if not success:\n                    activation_failed_components.append(component)\n            else:\n                self.__engine.notifications_manager.warnify(\"{0} | '{1}' Component is already activated!\".format(\n                    self.__class__.__name__, component.name))\n            self.__engine.step_processing()\n        self.__engine.stop_processing()\n\n        self.__store_deactivated_components()\n\n        if not activation_failed_components:\n            return True\n        else:\n            raise manager.exceptions.ComponentActivationError(\n                \"{0} | Exception(s) raised while activating '{1}' Component(s)!\".format(self.__class__.__name__,\n                                                                                        \", \".join((\n                                                                                        activation_failed_component.name\n                                                                                        for activation_failed_component\n                                                                                        in\n                                                                                        activation_failed_components))))", "response": "Activates user selected Components."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef deactivate_components_ui(self):\n\n        selected_components = self.get_selected_components()\n\n        self.__engine.start_processing(\"Deactivating Components ...\", len(selected_components))\n        deactivation_failed_components = []\n        for component in selected_components:\n            if component.interface.activated:\n                if component.interface.deactivatable:\n                    success = self.deactivate_component(component.name) or False\n                    if not success:\n                        deactivation_failed_components.append(component)\n                else:\n                    self.__engine.notifications_manager.warnify(\n                        \"{0} | '{1}' Component cannot be deactivated!\".format(self.__class__.__name__, component.name))\n            else:\n                self.__engine.notifications_manager.warnify(\n                    \"{0} | '{1}' Component is already deactivated!\".format(self.__class__.__name__, component.name))\n            self.__engine.step_processing()\n        self.__engine.stop_processing()\n\n        self.__store_deactivated_components()\n\n        if not deactivation_failed_components:\n            return True\n        else:\n            raise manager.exceptions.ComponentDeactivationError(\n                \"{0} | Exception(s) raised while deactivating '{1}' Component(s)!\".format(self.__class__.__name__,\n                                                                                          \", \".join((\n                                                                                          deactivation_failed_component.name\n                                                                                          for\n                                                                                          deactivation_failed_component\n                                                                                          in\n                                                                                          deactivation_failed_components))))", "response": "Deactivates user selected Components."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reload_components_ui(self):\n\n        selected_components = self.get_selected_components()\n\n        self.__engine.start_processing(\"Reloading Components ...\", len(selected_components))\n        reload_failed_components = []\n        for component in selected_components:\n            if component.interface.deactivatable:\n                success = self.reload_component(component.name) or False\n                if not success:\n                    reload_failed_components.append(component)\n            else:\n                self.__engine.notifications_manager.warnify(\n                    \"{0} | '{1}' Component cannot be deactivated and won't be reloaded!\".format(self.__class__.__name__,\n                                                                                                component.name))\n            self.__engine.step_processing()\n        self.__engine.stop_processing()\n\n        if not reload_failed_components:\n            return True\n        else:\n            raise manager.exceptions.ComponentReloadError(\n                \"{0} | Exception(s) raised while reloading '{1}' Component(s)!\".format(self.__class__.__name__,\n                                                                                       \", \".join(\n                                                                                           (reload_failed_component.name\n                                                                                            for reload_failed_component\n                                                                                            in\n                                                                                            reload_failed_components))))", "response": "Reloads user selected Components."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nactivating given Component. :param name: Component name. :type name: unicode :return: Method success. :rtype: bool", "response": "def activate_component(self, name):\n        \"\"\"\n        Activates given Component.\n\n        :param name: Component name.\n        :type name: unicode\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if not name in self.__engine.components_manager.components:\n            raise manager.exceptions.ComponentExistsError(\n                \"{0} | '{1}' Component isn't registered in the Components Manager!\".format(self.__class__.__name__,\n                                                                                           name))\n\n        component = self.__engine.components_manager.components[name]\n        if component.interface.activated:\n            LOGGER.warning(\"!> {0} | '{1}' Component is already activated!\".format(self.__class__.__name__, name))\n            return False\n\n        LOGGER.debug(\"> Attempting '{0}' Component activation.\".format(component.name))\n        component.interface.activate(self.__engine)\n        if component.category in (\"Default\", \"QObject\"):\n            component.interface.initialize()\n        elif component.category == \"QWidget\":\n            component.interface.initialize_ui()\n            component.interface.add_widget()\n        LOGGER.info(\"{0} | '{1}' Component has been activated!\".format(self.__class__.__name__, component.name))\n        self.activated_component.emit(name)\n        self.refresh_nodes.emit()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef deactivate_component(self, name):\n\n        if not name in self.__engine.components_manager.components:\n            raise manager.exceptions.ComponentExistsError(\n                \"{0} | '{0}' Component isn't registered in the Components Manager!\".format(self.__class__.__name__,\n                                                                                           name))\n\n        component = self.__engine.components_manager.components[name]\n        if not component.interface.activated:\n            LOGGER.warning(\"!> {0} | '{1}' Component is already deactivated!\".format(self.__class__.__name__, name))\n            return False\n\n        LOGGER.debug(\"> Attempting '{0}' Component deactivation.\".format(component.name))\n        if component.interface.deactivatable:\n            if component.category in (\"Default\", \"QObject\"):\n                component.interface.uninitialize()\n            elif component.category == \"QWidget\":\n                component.interface.uninitialize_ui()\n                component.interface.remove_widget()\n            component.interface.deactivate()\n            LOGGER.info(\"{0} | '{1}' Component has been deactivated!\".format(self.__class__.__name__, component.name))\n            self.deactivated_component.emit(name)\n            self.refresh_nodes.emit()\n            return True\n        else:\n            raise manager.exceptions.ComponentDeactivationError(\n                \"{0} | '{1}' Component cannot be deactivated!\".format(self.__class__.__name__, component.name))", "response": "Deactivates given Component.\n\n        :param name: Component name.\n        :type name: unicode\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reload_component(self, name):\n\n        if not name in self.__engine.components_manager.components:\n            raise manager.exceptions.ComponentExistsError(\n                \"{0} | '{1}' Component isn't registered in the Components Manager!\".format(self.__class__.__name__,\n                                                                                           name))\n\n        component = self.__engine.components_manager.components[name]\n        LOGGER.debug(\"> Attempting '{0}' Component reload.\".format(component.name))\n        if component.interface.deactivatable:\n            dependents = list(reversed(self.__engine.components_manager.list_dependents(component.name)))\n\n            if filter(lambda x: not self.__engine.components_manager[x].deactivatable, dependents):\n                LOGGER.warning(\n                    \"!> {0} | '{1}' Component has non reloadable dependencies and won't be reloaded!\".format(\n                        self.__class__.__name__, component.name))\n                return False\n\n            LOGGER.info(\"{0} | '{1}' Component dependents: '{2}'.\".format(self.__class__.__name__,\n                                                                          component.name,\n                                                                          \", \".join(dependents)))\n\n            LOGGER.debug(\"> Deactivating '{0}' Component dependents.\".format(component.name))\n            dependents.append(component.name)\n            for dependent in dependents:\n                if self.__engine.components_manager[dependent].activated:\n                    self.deactivate_component(dependent)\n                self.__engine.process_events()\n\n            LOGGER.debug(\"> Reloading '{0}' Component dependents.\".format(component.name))\n            self.__engine.components_manager.reload_component(component.name)\n\n            LOGGER.debug(\"> Activating '{0}' Component dependents.\".format(component.name))\n            for dependent in reversed(dependents):\n                if not self.__engine.components_manager[dependent].activated:\n                    self.activate_component(dependent)\n                self.__engine.process_events()\n\n            LOGGER.info(\"{0} | '{1}' Component has been reloaded!\".format(self.__class__.__name__, component.name))\n            self.reloaded_component.emit(component.name)\n            return True\n        else:\n            raise manager.exceptions.ComponentReloadError(\n                \"{0} | '{1}' Component cannot be deactivated and won't be reloaded!\".format(self.__class__.__name__,\n                                                                                            component.name))", "response": "Reloads given Component.\n\n        :param name: Component name.\n        :type name: unicode\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the Components Model nodes.", "response": "def set_components(self):\n        \"\"\"\n        Sets the Components Model nodes.\n        \"\"\"\n\n        node_flags = attributes_flags = int(Qt.ItemIsSelectable | Qt.ItemIsEnabled)\n\n        root_node = umbra.ui.nodes.DefaultNode(name=\"InvisibleRootNode\")\n\n        paths = {}\n        for path in self.__engine.components_manager.paths:\n            basename = os.path.basename(path)\n            if not paths.get(basename):\n                paths[basename] = {}\n\n            paths[basename].update(dict((name, component)\n                                        for (name, component) in self.__engine.components_manager\n                                        if basename == os.path.basename(os.path.dirname(component.directory))))\n\n        for path, components in paths.iteritems():\n            path_node = PathNode(name=path.title(),\n                                 parent=root_node,\n                                 node_flags=node_flags,\n                                 attributes_flags=attributes_flags)\n\n            for component in components.itervalues():\n                if not component.interface:\n                    continue\n\n                component_node = ComponentNode(component,\n                                               name=component.title,\n                                               parent=path_node,\n                                               node_flags=node_flags,\n                                               attributes_flags=attributes_flags,\n                                               activated=umbra.ui.nodes.GraphModelAttribute(name=\"activated\",\n                                                                                            flags=attributes_flags,\n                                                                                            roles={\n                                                                                            Qt.DisplayRole: foundations.strings.to_string(\n                                                                                                component.interface.activated),\n                                                                                            Qt.DecorationRole: os.path.join(\n                                                                                                self.__ui_resources_directory,\n                                                                                                component.interface.activated and\n                                                                                                self.__ui_activated_image or self.__ui_deactivated_image)}))\n                component_node.roles[Qt.DecorationRole] = os.path.join(self.__ui_resources_directory,\n                                                                       \"{0}{1}\".format(component.category,\n                                                                                       self.__ui_category_affixe))\n\n        root_node.sort_children()\n\n        self.__model.initialize_model(root_node)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of absolute string file paths of requested files", "response": "def get_file_list(opts):\n    \"\"\"\n    Returns a list containing file paths of requested files to be parsed\n    using AnchorHub options.\n\n    :param opts: Namespace containing AnchorHub options, usually created from\n        command line arguments\n    :return: a list of absolute string file paths of files that should be\n        parsed\n    \"\"\"\n    if opts.is_dir:\n        # Input is a directory, get a list of files\n        return get_files(opts.abs_input, opts.extensions, exclude=[\n            opts.abs_output], recursive=opts.recursive)\n    elif os.path.isfile(opts.input):\n        # Input is a file, should only parse that one file\n        return [opts.abs_input]\n    else:\n        # Input is non-existent\n        return []"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __initialize_node(self, attributes_flags=int(Qt.ItemIsSelectable | Qt.ItemIsEnabled)):\n\n        self[\"activated\"] = umbra.ui.nodes.GraphModelAttribute(name=\"activated\",\n                                                               flags=attributes_flags)\n        self[\"category\"] = umbra.ui.nodes.GraphModelAttribute(name=\"category\",\n                                                              flags=attributes_flags)\n        self[\"require\"] = umbra.ui.nodes.GraphModelAttribute(name=\"require\",\n                                                             flags=attributes_flags)\n        self[\"version\"] = umbra.ui.nodes.GraphModelAttribute(name=\"version\",\n                                                             flags=attributes_flags)", "response": "Initializes the node.\n\n        :param attributes_flags: Attributes flags.\n        :type attributes_flags: int"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the node. :param attributes_flags: Attributes flags. :type attributes_flags: int", "response": "def __initialize_node(self, attributes_flags=int(Qt.ItemIsSelectable | Qt.ItemIsEnabled)):\n        \"\"\"\n        Initializes the node.\n\n        :param attributes_flags: Attributes flags.\n        :type attributes_flags: int\n        \"\"\"\n\n        attributes = dir(self.__component)\n        for attribute in attributes:\n            if attribute == \"name\":\n                continue\n\n            if not \"_Profile__{0}\".format(attribute) in attributes:\n                continue\n\n            value = getattr(self.__component, attribute)\n            value = \", \".join(value) if type(value) in (tuple, list) else value\n            roles = {Qt.DisplayRole: value,\n                     Qt.EditRole: value}\n            self[attribute] = umbra.ui.nodes.GraphModelAttribute(attribute, value, roles, attributes_flags)\n\n        self.update_tool_tip()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_tool_tip(self):\n\n        self.roles[Qt.ToolTipRole] = self.__tool_tip_text.format(self.component.name,\n                                                                 self.component.author,\n                                                                 self.component.category,\n                                                                 \", \".join(self.component.require),\n                                                                 self.component.version,\n                                                                 self.component.description)\n        return True", "response": "Updates the node tooltip."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef query(self, *args, **kwargs):\n        qitem = th.merge_dicts(*args)\n        # If there a 'price' type, check to see if there's a 'period' as well. \n        # This determines which kind of data we need to get.\n        query_type = qitem.get('type')\n        _query_type = kwargs.get(\"_type\")\n        if query_type is None and _query_type is None:\n            raise AttributeError(\"Must specify a type. It is a selector to help the user sort through data. Can use either kwargs or dict\")\n\n        if query_type is None:\n            # This means _query_type is specified instead\n            query_type = _query_type\n\n        if query_type == \"price\":\n            try:\n                th.price_query_filter(qitem)\n            except KeyError:\n                raise AttributeError(\"When querying price information, couldn't find the required variables. Must have: exchange (to select what exchange the data is coming from) and period (to select the time period of the data)\")\n        \n        pagination = kwargs.get(\"pagination\", False)\n        page_size = kwargs.get(\"page_size\", 1)\n        page_num = kwargs.get(\"page_num\", 10)\n        # Gets the page if pagination == true\n        if pagination:\n            # Re return something else here\n            skips = page_size * (page_num - 1)\n            cursor = self._collection.find(qitem).skip(skips).limit(page_size)\n            for x in cursor:\n                del x[\"_id\"]\n                yield x\n        \n        # Break the function here\n        else:\n            # Get absolute latest\n            for x in self._collection.find(qitem):\n                del x['_id'] # Remove default unique '_id' field from doc\n                # TODO: Create generic cast\n                yield x", "response": "Generic query method.\n        In reality, your storage class would have its own query methods,\n        Performs a Mongo find on the Marketdata index metadata collection.\n        See:\n        http://api.mongodb.org/python/current/api/pymongo/collection.html"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef query_closest(self, query_item):\n\n        if not isinstance(query_item, dict):\n            raise TypeError(\"The query query_item isn't a dictionary\")\n        \n        _type = query_item.get(\"type\")\n        _timestamp = query_item.get(\"timestamp\")\n\n        if _type is None:\n            raise AttributeError(\"Please make sure to add a type to the query_item dict\")\n\n        if _timestamp is None:\n            raise AttributeError(\"Timestamp doesn't exist. It's necessary to provide closest query\")\n        \n        query_less = deepcopy(query_item)\n        query_more = deepcopy(query_item)\n        \n        query_less[\"timestamp\"] = {\"$lte\": _timestamp}\n        query_more[\"timestamp\"] = {\"$gt\": _timestamp}\n        closestBelow = self._collection.find(query_less).sort(\n            \"timestamp\", pymongo.DESCENDING).limit(1)\n        closestAbove = self._collection.find(query_more).sort(\"timestamp\", pymongo.ASCENDING).limit(1)\n        \n        combined = list(closestAbove) + list(closestBelow)\n        for x in combined:\n            del x['_id']\n        \n        # abs()\n        if len(combined) >= 2: \n            if abs(combined[0][\"timestamp\"] - _timestamp) > abs(combined[1][\"timestamp\"] - _timestamp):\n                return combined[1]\n            else:\n                return combined[0]\n        elif combined == 1:\n            return combined[0]\n        else:\n            return None", "response": "returns a list of the closest items to a given thing"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef store(self, store_item):\n        required_keys = {\"type\": str, \"timestamp\": float}\n        \n        if not isinstance(store_item, dict):\n            raise TypeError(\"The stored item should be a dict\")\n           \n        for k, v in required_keys.items(): \n            if k not in store_item:\n                raise AttributeError(\"{} is not available. Please add it.\".format(k))\n            \n            if not isinstance(store_item[k], v):\n                raise TypeError(\"{} is not a {}. Please change it. \".format(k, v))\n                #       \n#         # TODO: CREATE FILTER FOR PERSISTENCE METHOD. Make sure it has the necessary data\n#         to_store = {'field1': thing.field1,\n#                     'date_field': thing.date_field,\n#                     }\n#         to_store['stuff'] = Binary(cPickle.dumps(thing.stuff))\n        # Respect any soft-quota on write - raises if stats().totals.size > quota \n        self._arctic_lib.check_quota()\n        self._collection.update(store_item, store_item, upsert=True)", "response": "Stores the given item in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new table with the specified fields.", "response": "def create(self,*fields,**kw):\r\n        \"\"\"Create a new table\r\n        For each field, a 2-element tuple is provided :\r\n        - the field name\r\n        - a string with additional information : field type +\r\n          other information using the MySQL syntax\r\n          eg : ('name','TEXT NOT NULL')\r\n               ('date','TIMESTAMP DEFAULT CURRENT_TIMESTAMP')\r\n        A keyword argument mode can be specified ; it is used if a file\r\n        with the base name already exists\r\n        - if mode = 'open' : open the existing base, ignore the fields\r\n        - if mode = 'override' : erase the existing base and create a\r\n        new one with the specified fields\"\"\"\r\n        self.mode = mode = kw.get(\"mode\",None)\r\n        if self._table_exists():\r\n            if mode == \"override\":\r\n                self.cursor.execute(\"DROP TABLE %s\" %self.name)\r\n            elif mode == \"open\":\r\n                return self.open()\r\n            else:\r\n                raise IOError,\"Base %s already exists\" %self.name\r\n        self.fields = []\r\n        self.field_info = {}\r\n        sql = \"CREATE TABLE %s (\" %self.name\r\n        for field in fields:\r\n            sql += self._validate_field(field)\r\n            sql += ','\r\n        sql = sql[:-1]+')'\r\n        self.cursor.execute(sql)\r\n        self._get_table_info()\r\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _table_exists(self):\r\n        self.cursor.execute(\"SHOW TABLES\")\r\n        for table in self.cursor.fetchall():\r\n            if table[0].lower() == self.name.lower():\r\n                return True\r\n        return False", "response": "Return True if the table exists False otherwise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the table info.", "response": "def _get_table_info(self):\r\n        \"\"\"Database-specific method to get field names\"\"\"\r\n        self.rowid = None\r\n        self.fields = []\r\n        self.field_info = {}\r\n        self.cursor.execute('DESCRIBE %s' %self.name)\r\n        for row in self.cursor.fetchall():\r\n            field,typ,null,key,default,extra = row\r\n            self.fields.append(field)\r\n            self.field_info[field] = {'type':typ,'NOT NULL':null,'key':key,\r\n                'DEFAULT':default,'extra':extra}\r\n            if extra == 'auto_increment':\r\n                self.rowid = field"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninserting a record in the database Returns the record identifier", "response": "def insert(self,*args,**kw):\r\n        \"\"\"Insert a record in the database\r\n        Parameters can be positional or keyword arguments. If positional\r\n        they must be in the same order as in the create() method\r\n        If some of the fields are missing the value is set to None\r\n        Returns the record identifier\r\n        \"\"\"\r\n        fields = [ f for f in self.fields\r\n            if not self.field_info[f]['extra']==\"auto_increment\"]\r\n        if args:\r\n            kw = dict([(f,arg) for f,arg in zip(fields,args)])\r\n\r\n        vals = self._make_sql_params(kw)\r\n        sql = \"INSERT INTO %s SET %s\" %(self.name,\",\".join(vals))\r\n        res = self.cursor.execute(sql,kw.values())\r\n        self.cursor.execute(\"SELECT LAST_INSERT_ID()\")\r\n        __id__ = self.cursor.fetchone()[0]\r\n        return __id__"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_blocking_connection(host):\n    return pika.BlockingConnection(\n        amqpdaemon.getConParams(\n            settings.get_amqp_settings()[host.lower()][\"vhost\"]\n        )\n    )", "response": "Create a new connection to the given host."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates the schema of the given host.", "response": "def create_schema(host):\n    \"\"\"\n    Create exchanges, queues and route them.\n\n    Args:\n        host (str): One of the possible hosts.\n    \"\"\"\n    connection = create_blocking_connection(host)\n    channel = connection.channel()\n\n    exchange = settings.get_amqp_settings()[host][\"exchange\"]\n    channel.exchange_declare(\n        exchange=exchange,\n        exchange_type=\"topic\",\n        durable=True\n    )\n    print \"Created exchange '%s'.\" % exchange\n    print \"Creating queues:\"\n\n    queues = settings.get_amqp_settings()[host][\"queues\"]\n    for queue in queues.keys():\n        channel.queue_declare(\n            queue=queue,\n            durable=True,\n            # arguments={'x-message-ttl': int(1000 * 60 * 60 * 24)} # :S\n        )\n        print \"\\tCreated durable queue '%s'.\" % queue\n\n    print\n    print \"Routing exchanges using routing key to queues:\"\n\n    for queue in queues.keys():\n        channel.queue_bind(\n            queue=queue,\n            exchange=exchange,\n            routing_key=queues[queue]\n        )\n\n        print \"\\tRouting exchange %s['%s'] -> '%s'.\" % (\n            exchange,\n            queues[queue],\n            queue\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a Pika channel for given host.", "response": "def _get_channel(host, timeout):\n    \"\"\"\n    Create communication channel for given `host`.\n\n    Args:\n        host (str): Specified --host.\n        timeout (int): Set `timeout` for returned `channel`.\n\n    Returns:\n        Object: Pika channel object.\n    \"\"\"\n    connection = create_blocking_connection(host)\n\n    # register timeout\n    if timeout >= 0:\n        connection.add_timeout(\n            timeout,\n            lambda: sys.stderr.write(\"Timeouted!\\n\") or sys.exit(1)\n        )\n\n    return connection.channel()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef receive(host, timeout):\n    parameters = settings.get_amqp_settings()[host]\n\n    queues = parameters[\"queues\"]\n    queues = dict(map(lambda (x, y): (y, x), queues.items()))  # reverse items\n    queue = queues[parameters[\"out_key\"]]\n\n    channel = _get_channel(host, timeout)\n    for method_frame, properties, body in channel.consume(queue):\n        print json.dumps({\n            \"method_frame\": str(method_frame),\n            \"properties\": str(properties),\n            \"body\": body\n        })\n        print \"-\" * 79\n        print\n\n        channel.basic_ack(method_frame.delivery_tag)", "response": "Print all messages in queue."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_message(host, data, timeout=None, properties=None):\n    channel = _get_channel(host, timeout)\n\n    if not properties:\n        properties = pika.BasicProperties(\n            content_type=\"application/json\",\n            delivery_mode=2,\n            headers={\"UUID\": str(uuid.uuid4())}\n        )\n\n    parameters = settings.get_amqp_settings()[host]\n\n    channel.basic_publish(\n        exchange=parameters[\"exchange\"],\n        routing_key=parameters[\"in_key\"],\n        properties=properties,\n        body=data\n    )", "response": "Send a message to given host."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking that user specified a host parameter.", "response": "def _require_host_parameter(args, to):\n    \"\"\"\n    Make sure, that user specified --host argument.\n    \"\"\"\n    if not args.host:\n        sys.stderr.write(\"--host is required parameter to --%s\\n\" % to)\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking a dictionary of provider state and returns a new ProviderState object.", "response": "def _pluck_provider_state(raw_provider_state: Dict) -> ProviderState:\n    \"\"\"\n    >>> _pluck_provider_state({'name': 'there is an egg'})\n    ProviderState(descriptor='there is an egg', params=None)\n\n    >>> _pluck_provider_state({'name': 'there is an egg called', 'params': {'name': 'humpty'}})\n    ProviderState(descriptor='there is an egg called', params={'name': 'humpty'})\n    \"\"\"\n    return ProviderState(\n        descriptor=raw_provider_state['name'],\n        params=raw_provider_state.get('params')\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fit(pointlist):\n    '''\n    Parameter\n      pointlist\n        [[x0,y0], [x1,y1], ...]\n    '''\n\n    gapless_pointlist = gaze_repair(pointlist)\n    src, sacc, tgt, mle = saccade_model_em(gapless_pointlist)\n\n    return {\n        'source_points': src,\n        'saccade_points': sacc,\n        'target_points': tgt,\n        'mean_squared_error': mle\n    }", "response": "Fit a set of points to a set of points."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _visible_in_diff(merge_result, context_lines=3):\n    i = old_line = new_line = 0\n    while i < len(merge_result):\n        line_or_conflict = merge_result[i]\n        if isinstance(line_or_conflict, tuple):\n            yield old_line, new_line, line_or_conflict\n            old_line += len(line_or_conflict[0])\n            new_line += len(line_or_conflict[1])\n        else:\n            for j in (list(range(max(0, i-context_lines), i                                        )) +  # look behind for nearby conflicts\n                      list(range(i+1                    , min(len(merge_result), i+1+context_lines)))):  # look ahead for nearby conflicts\n                if isinstance(merge_result[j], tuple):\n                    yield old_line, new_line, line_or_conflict\n                    break\n            else:\n                yield None  # sentinel to mark boundaries between diff section groups\n            old_line += 1\n            new_line += 1\n        i += 1\n    yield None", "response": "Yields the set of lines that should be visible in a diff with a certain number of context lines"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _split_diff(merge_result, context_lines=3):\n    collect = []\n    for item in _visible_in_diff(merge_result, context_lines=context_lines):\n        if item is None:\n            if collect:\n                yield collect\n            collect = []\n        else:\n            collect.append(item)", "response": "Split diffs and context lines into groups based on None sentinel"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _diff_group_position(group):\n    old_start = group[0][0]\n    new_start = group[0][1]\n    old_length = new_length = 0\n    for old_line, new_line, line_or_conflict in group:\n        if isinstance(line_or_conflict, tuple):\n            old, new = line_or_conflict\n            old_length += len(old)\n            new_length += len(new)\n        else:\n            old_length += 1\n            new_length += 1\n    if old_length:\n        old_start += 1\n    if new_length:\n        new_start += 1\n\n    return color.LineNumber('@@ -%s,%s +%s,%s @@' % (old_start, old_length, new_start, new_length))", "response": "Generate a unified diff position line for a diff group"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a diff section for a diff group", "response": "def _diff_group(group):\n    \"\"\"Generate a diff section for diff group\"\"\"\n    yield _diff_group_position(group)\n\n    for old_line, new_line, line_or_conflict in group:\n        if isinstance(line_or_conflict, tuple):\n            old, new = line_or_conflict\n            for o in old:\n                yield color.Deleted('-' + o.strip('\\n'))\n\n            if new and old and new[-1].endswith('\\n') and not old[-1].endswith('\\n'):  # new last line has a newline but old last line doesn't\n                yield \"\\ No newline at end of file\"\n\n            for n in new:\n                yield color.Added('+' + n.strip('\\n'))\n\n            if old and new and old[-1].endswith('\\n') and not new[-1].endswith('\\n'):  # old last line has a newline but new last line doesn't\n                yield \"\\ No newline at end of file\"\n\n        else:\n            yield ' ' + line_or_conflict.strip('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _full_diff(merge_result, key, context_lines=3):\n    header_printed = False\n    for group in _split_diff(merge_result, context_lines=context_lines):\n        if not header_printed:\n            header_printed = True\n            yield color.Header('diff a/%s b/%s' % (key, key))\n            yield color.DeletedHeader('--- %s' % key)\n            yield color.AddedHeader('+++ %s' % key)\n\n        for l in _diff_group(group):\n            yield l", "response": "Generate a full diff based on a Weave merge result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resolvePrefix(self):\n        tmpstrlist = []\n        tmpstodict = {}\n        for line in self.file_lines:\n            if line.startswith('%'):\n                stolist = line.replace('%', '').split('sto')\n                rpnexp = stolist[0].strip()  # rpn expression\n                rpnvar = stolist[1].strip()  # rpn variable\n                tmpstodict[rpnvar] = rpnexp\n                # bug: rpnval in rpnexp\n                # raises error when converting string convert to float\n                # Found: 2016-06-08 22:29:25 PM CST\n                # Fixed: 2016-06-12 11:51:01 AM CST\n                # e.g.\n                # a sto 0.1\n                # a sto b\n                # then b should be 0.1,\n                # i.e. b -> a -> 0.1\n                # solve the 'sto chain' assignment issue.\n\n        self.stodict = self.resolve_rpn(tmpstodict)\n        for k, v in self.stodict.items():\n            stostr = '% {val} sto {var}'.format(val=v, var=k)\n            tmpstrlist.append(stostr)\n        self.prestrdict['_prefixstr'] = tmpstrlist", "response": "extract prefix information into dict with the key _prefixstr"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_rpndict_flag(self, rpndict):\n        flag_set = set([rpn.Rpn.solve_rpn(str(v)) is not None for v in rpndict.values()])\n        if len(flag_set) == 1 and flag_set.pop():\n            return True\n        else:\n            return False", "response": "calculate flag set based on rpndict value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rinse_rpnexp(self, rpnexp, rpndict):\n        for wd in rpnexp.split():\n            if wd in rpndict:\n                try:\n                    val = float(rpndict[wd])\n                    rpnexp = rpnexp.replace(wd, str(val))\n                except:\n                    pass\n        return rpnexp", "response": "rinse_rpnexp is a function that takes a string rpnexp and returns the rpnexp that is used to rinse the rpndict."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsolves dict of rpn expressions to pure var to val dict", "response": "def resolve_rpn(self, rpndict):\n        \"\"\" solve dict of rpn expressions to pure var to val dict\n        :param rpndict: dict of rpn expressions\n        return pure var to val dict\n        \"\"\"\n        if rpndict == {}:\n            return {}\n\n        retflag = self.get_rpndict_flag(rpndict)\n        cnt = 0\n        tmpdict = {k: v for k, v in rpndict.items()}\n        while not retflag:\n            # update rpndict\n            cnt += 1\n            tmpdict = self.update_rpndict(tmpdict)\n            # and flag\n            retflag = self.get_rpndict_flag(tmpdict)\n        return tmpdict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_rpndict(self, rpndict):\n        tmpdict = {k: v for k, v in rpndict.items()}\n        for k, v in rpndict.items():\n            v_str = str(v)\n            if rpn.Rpn.solve_rpn(v_str) is None:\n                tmpdict[k] = self.rinse_rpnexp(v_str, tmpdict)\n            else:\n                tmpdict[k] = rpn.Rpn.solve_rpn(v_str)\n        return tmpdict", "response": "update rpndict try to solve rpn expressions as many as possible"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract epics control configs into self. ctrlconf_dict", "response": "def resolveEPICS(self):\n        \"\"\" extract epics control configs into\n        \"\"\"\n        kw_name_list = []\n        kw_ctrlconf_list = []\n        for line in self.file_lines:\n            if line.startswith('!!epics'):\n                el = line.replace('!!epics', '').replace(':', ';;', 1).split(';;')\n                kw_name_list.append(el[0].strip())\n                kw_ctrlconf_list.append(json.loads(el[1].strip()))\n        self.ctrlconf_dict = dict(zip(kw_name_list, kw_ctrlconf_list))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getKw(self, kw):\n        ikw = kw.lower()\n        line_continue_flag = ''\n        appendflag = False\n        try:\n            for line in self.file_lines:\n                if line.strip() == '':\n                    continue\n                line = ' '.join(line.strip().split()).strip('\\n; ')\n                if line.startswith('!'):\n                    continue\n                if line.lower().startswith(ikw + ' :') or line.lower().startswith(ikw + ':'):\n                    conflist = []  # list to put into element configuration\n                    conflist.append(line)\n                    appendflag = True\n                elif appendflag and line_continue_flag == '&':\n                    conflist.append(line)\n                line_continue_flag = line[-1]\n                if line_continue_flag != '&':\n                    appendflag = False\n            conf_str = ''.join(conflist).replace('&', ',')\n            if 'line' in conf_str.lower().split('=')[0]:  # if bl defines lattice\n                conf_str = conf_str.lower().replace(',', ' ')[::-1].replace('enil', 'beamline,lattice'[::-1], 1)[\n                           ::-1]  # avoid the case with bl keyword has 'line'\n        except:\n            conf_str = ''\n\n        # print conf_str\n\n        # split('!epics'): second part is epics control conf\n        splitedparts = conf_str.split('!epics')\n        self.confstr = splitedparts[0]\n        try:\n            self.confstr_epics = splitedparts[1].strip()\n        except IndexError:\n            self.confstr_epics = ''\n\n        return self", "response": "Extract doc snippet for element configuration and return instance itself"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a string to a dictionary", "response": "def str2dict(self, rawstr):\n        \"\"\" convert str to dict format\n\n        USAGE: rdict = str2dict(rawstr)\n        :param rawstr: raw configuration string of element\n        \"\"\"\n        kw_list = []\n        sp1 = rawstr.split(':')\n        kw_name = sp1[0].strip().upper()\n        kw_desc = sp1[1:]\n        sp2 = kw_desc[0].replace(',', ';;', 1).split(';;')\n        kw_type = sp2[0].strip()\n        try:\n            kw_vals = sp2[1].replace(\",\", '=').split('=')\n            [(not (i.isspace() or i == '')) and kw_list.append(i) for i in kw_vals]\n            ks = [k.strip() for k in kw_list[0::2]]\n            vs = [v.strip().replace('\"', '').replace(\"'\", '') for v in kw_list[1::2]]\n            kw_vals_dict = dict(zip(ks, vs))\n            rdict = {kw_name: {kw_type: kw_vals_dict}}\n        except:\n            rdict = {kw_name: kw_type}\n        return rdict"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns keyword configuration as a dict", "response": "def getKwAsDict(self, kw):\n        \"\"\" return keyword configuration as a dict\n\n        Usage: rdict = getKwAsDict(kw)\n        \"\"\"\n        self.getKw(kw)\n        return self.str2dict(self.confstr)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn keyword s control configuration followed after!epics notation", "response": "def getKwCtrlConf(self, kw, fmt='dict'):\n        \"\"\" return keyword's control configuration, followed after '!epics' notation\n        :param kw: keyword name\n        :param fmt: return format, 'raw', 'dict', 'json', default is 'dict'\n        \"\"\"\n        try:\n            confd = self.ctrlconf_dict[kw]\n            if fmt == 'dict':\n                retval = confd\n            else:  # 'json' string for other options\n                retval = json.dumps(confd)\n        except KeyError:\n            # try to get from raw line string\n            self.getKw(kw)\n            if self.confstr_epics != '':\n                if fmt == 'dict':\n                    retval = ast.literal_eval(self.confstr_epics)\n                elif fmt == 'json':\n                    retval = json.dumps(ast.literal_eval(self.confstr_epics))\n                else:  # raw string\n                    retval = self.confstr_epics\n            else:\n                retval = None\n\n        return retval"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetecting all keyword from infile return as a list USAGE", "response": "def detectAllKws(self):\n        \"\"\" Detect all keyword from infile, return as a list\n\n        USAGE: kwslist = detectAllKws()\n        \"\"\"\n        kwslist = []\n        for line in self.file_lines:\n            # if line.strip() == '': continue\n            line = ''.join(line.strip().split())\n            if line.startswith(\"!\"):\n                continue\n            # if ':' in line and not \"line\" in line:\n            if ':' in line:\n                kw_name = line.split(':')[0]\n                if set(kw_name).difference({'=', '-', '*', '/', '+'}) == set(kw_name):\n                    kwslist.append(kw_name)\n        return kwslist"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert all keywords in the lte file into json like format", "response": "def file2json(self, jsonfile=None):\n        \"\"\" Convert entire lte file into json like format\n\n        USAGE: 1: kwsdictstr = file2json()\n               2: kwsdictstr = file2json(jsonfile = 'somefile')\n\n        show pretty format with pipeline: | jshon, or | pjson\n        if jsonfile is defined, dump to defined file before returning json string\n        :param jsonfile: filename to dump json strings\n        \"\"\"\n        kwslist = self.detectAllKws()\n        kwsdict = {}\n        idx = 0\n        for kw in sorted(kwslist, key=str.lower):\n            # print kw\n            idx += 1\n            tdict = self.getKwAsDict(kw)\n            self.rpn2val(tdict)\n            kwsdict.update(tdict)\n            if kw not in self.ctrlconf_dict:\n                ctrlconf = self.getKwCtrlConf(kw, fmt='dict')\n                if ctrlconf is not None:\n                    self.ctrlconf_dict.update({kw: ctrlconf})\n        kwsdict.update(self.prestrdict)\n        ctrlconfdict = {'_epics': self.ctrlconf_dict}  # all epics contrl config in self.ctrlconfdict\n        kwsdict.update(ctrlconfdict)\n        try:\n            with open(os.path.expanduser(jsonfile), 'w') as outfile:\n                json.dump(kwsdict, outfile)\n        except:\n            pass\n        return json.dumps(kwsdict)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getKwConfig(self, kw):\n        confd = self.getKwAsDict(kw).values()[0].values()[0]\n        return {k.lower(): v for k, v in confd.items()}", "response": "return the configuration of kw"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef makeElement(self, kw):\n        kw_name = kw\n        kw_type = self.getKwType(kw_name)\n        kw_config = {k.lower(): v for k, v in self.getKwConfig(kw_name).items()}\n        objtype = 'Element' + kw_type.capitalize()\n        retobj = getattr(element, objtype)(name=kw_name, config=kw_config)\n        # set up EPICS control configs\n        ctrlconf = self.getKwCtrlConf(kw_name)\n        if ctrlconf != {}:\n            retobj.setConf(ctrlconf, type='ctrl')\n\n        return retobj", "response": "return an element object regarding the keyword configuration\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nscan input string line replace sto parameters with calculated results.", "response": "def scanStoVars(self, strline):\n        \"\"\" scan input string line, replace sto parameters with calculated results.\n        \"\"\"\n        for wd in strline.split():\n            if wd in self.stodict:\n                strline = strline.replace(wd, str(self.stodict[wd]))\n        return strline"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nresolve the rpn string into calulated float number", "response": "def rpn2val(self, rdict):\n        \"\"\" Resolve the rpn string into calulated float number\n\n        USAGE: rpn2val(rdict)\n            :param rdict: json like dict\n        \"\"\"\n\n        kw_name = list(rdict.keys())[0]  # b11\n        kw_val = rdict[kw_name]\n        try:\n            kw_type = list(kw_val.keys())[0]  # csrcsben\n            kw_param = list(kw_val.values())[0]\n            if kw_type != 'beamline':\n                for k, v in kw_param.items():\n                    v = self.scanStoVars(v)\n                    rpnval = rpn.Rpn.solve_rpn(v)\n                    if rpnval is not None:\n                        kw_param[k] = rpnval  # update rpn string to float if not None\n        except:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getBeamline(self, beamlineKw):\n        lattice_string = list(self.all_elements.get(beamlineKw.upper()).values())[0].get('lattice')\n        return lattice_string[1:-1].split()", "response": "get beamline definition from all_elements return as a list"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets beamline definition from all_elements, expand iteratively with the elements from all_elements e.g. element 'doub1' in chi : line=(DBLL2 , doub1 , DP4FH , DP4SH , DBLL5 , DBD , B11 , DB11 , B12 , DB12 , PF2 , DB13 , B13 , DB14 , B14 , DBD , DBLL5 , doub2 , DP5FH , DP5SH , DBLL2 , PSTN1) should be expaned with 'doub1' configuration: doub1 : line=(DQD3, Q05, DQD2, Q06, DQD3) since: getBeamline('doub1') = [u'dqd3', u'q05', u'dqd2', u'q06', u'dqd3'] = A getBeamline('doub2') = [u'dqd3', u'q05', u'dqd2', u'q06', u'dqd3'] = B getBeamline('chi') = [u'dbll2', u'doub1', u'dp4fh', u'dp4sh', u'dbll5', u'dbd', u'b11', u'db11', u'b12', u'db12', u'pf2', u'db13', u'b13', u'db14', u'b14', u'dbd', u'dbll5', u'doub2', u'dp5fh', u'dp5sh', u'dbll2', u'pstn1'] thus: getFullBeamline('chi') should return: [u'dbll2', A, u'dp4fh', u'dp4sh', u'dbll5', u'dbd', u'b11', u'db11', u'b12', u'db12', u'pf2', u'db13', u'b13', u'db14', u'b14', u'dbd', u'dbll5', B, u'dp5fh', u'dp5sh', u'dbll2', u'pstn1'] :param extend: if extend mode should be envoked, by default False if extend = True, element like '2*D01' would be expended to be D01, D01", "response": "def getFullBeamline(self, beamlineKw, extend=False):\n        \"\"\" get beamline definition from all_elements,\n            expand iteratively with the elements from all_elements\n            e.g.\n            element 'doub1' in\n            chi   : line=(DBLL2 , doub1 , DP4FH , DP4SH , DBLL5 , DBD   ,\n                          B11   , DB11  , B12   , DB12  , PF2   , DB13  ,\n                          B13   , DB14  , B14   , DBD   , DBLL5 , doub2 ,\n                          DP5FH , DP5SH , DBLL2 , PSTN1)\n            should be expaned with 'doub1' configuration:\n            doub1 : line=(DQD3, Q05, DQD2, Q06, DQD3)\n\n            since:\n            getBeamline('doub1') = [u'dqd3', u'q05', u'dqd2', u'q06', u'dqd3'] = A\n            getBeamline('doub2') = [u'dqd3', u'q05', u'dqd2', u'q06', u'dqd3'] = B\n            getBeamline('chi') = [u'dbll2', u'doub1', u'dp4fh', u'dp4sh', u'dbll5', u'dbd', u'b11', u'db11', u'b12',\n                                  u'db12', u'pf2', u'db13', u'b13', u'db14', u'b14', u'dbd', u'dbll5', u'doub2',\n                                  u'dp5fh', u'dp5sh', u'dbll2', u'pstn1']\n\n            thus: getFullBeamline('chi') should return:\n            [u'dbll2', A, u'dp4fh', u'dp4sh', u'dbll5', u'dbd', u'b11', u'db11', u'b12', u'db12', u'pf2', u'db13',\n             u'b13', u'db14', u'b14', u'dbd', u'dbll5', B, u'dp5fh', u'dp5sh', u'dbll2', u'pstn1']\n\n            :param extend: if extend mode should be envoked, by default False\n            if extend = True, element like '2*D01' would be expended to be D01, D01\n        \"\"\"\n        try:\n            assert beamlineKw.upper() in self.kws_bl\n            rawbl = self.getBeamline(beamlineKw)\n            fullbl = []\n            if not extend:\n                for ele in rawbl:\n                    if self.isBeamline(ele):\n                        fullbl.extend(self.getFullBeamline(ele))\n                    else:  # if not beamline, do not expand\n                        fullbl.append(ele)\n            else:  # extend\n                for ele in rawbl:\n                    ele_num_name_dict = self.rinseElement(ele)\n                    elename = ele_num_name_dict['name']\n                    elenum = ele_num_name_dict['num']\n                    if self.isBeamline(elename):\n                        fullbl.extend(self.getFullBeamline(elename, extend=True) * elenum)\n                    else:\n                        fullbl.extend([elename] * elenum)\n            return fullbl\n        except AssertionError:\n            print('ERROR: %s is not a right defined beamline.' % beamlineKw)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract all keywords into two categories", "response": "def getAllKws(self):\n        \"\"\" extract all keywords into two categories\n\n            kws_ele: magnetic elements\n            kws_bl: beamline elements\n\n            return (kws_ele, kws_bl)\n        \"\"\"\n        kws_ele = []\n        kws_bl = []\n        for ele in self.all_elements:\n            if ele == '_prefixstr' or ele == '_epics':\n                continue\n            elif self.getElementType(ele).lower() == u'beamline':\n                kws_bl.append(ele)\n            else:\n                kws_ele.append(ele)\n\n        return tuple((kws_ele, kws_bl))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nshow all defined beamlines", "response": "def showBeamlines(self):\n        \"\"\" show all defined beamlines\n        \"\"\"\n        cnt = 0\n        blidlist = []\n        for k in self.all_elements:\n            try:\n                if 'beamline' in self.all_elements.get(k):\n                    cnt += 1\n                    blidlist.append(k)\n            except:\n                pass\n        retstr = '{total:<3d}beamlines: {allbl}'.format(total=cnt,\n                                                        allbl=';'.join(blidlist))\n        return retstr"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn type name for given element keyword", "response": "def getElementType(self, elementKw):\n        \"\"\" return type name for given element keyword,\n            e.g. getElementType('Q01') should return string: 'QUAD'\n        \"\"\"\n        try:\n            etype = list(self.all_elements.get(elementKw.upper()).keys())[0]\n        except:\n            etype = self.all_elements.get(elementKw.upper())\n        return etype.upper()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getElementConf(self, elementKw, raw=False):\n        if raw is True:\n            try:\n                econf = self.all_elements.get(elementKw.upper())\n            except:\n                return {}\n        else:\n            try:\n                econf = list(self.all_elements.get(elementKw.upper()).values())[0]\n            except:\n                return {}\n        return econf", "response": "get element configuration for given element keyword"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the element s EPICS control configs", "response": "def getElementCtrlConf(self, elementKw):\n        \"\"\" return keyword's EPICS control configs,\n            if not setup, return {}\n        \"\"\"\n        try:\n            retval = self.all_elements['_epics'][elementKw.upper()]\n        except KeyError:\n            retval = {}\n\n        return retval"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef formatElement(self, kw, format='elegant'):\n        etype = self.getElementType(kw)\n        econf_dict = self.getElementConf(kw)\n        econf_str = ''\n        for k, v in econf_dict.items():\n            econf_str += (k + ' = ' + '\"' + str(v) + '\"' + ', ')\n\n        if format == 'elegant':\n            fmtstring = '{eid:<10s}:{etype:>10s}, {econf}'.format(eid=kw.upper(),\n                                                                  etype=etype.upper(),\n                                                                  econf=econf_str[\n                                                                        :-2])\n            # [:-2] slicing to remove trailing space and ','\n        elif format == 'mad':\n            raise NotImplementedError(\"Not implemented, yet\")\n\n        return fmtstring", "response": "convert json dict of element configuration into elegant or mad format"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generateLatticeLine(self, latname='newline', line=None):\n        latticeline = []\n        for e in line:\n            if isinstance(e, list):\n                latticeline.extend(e)\n            else:\n                latticeline.append(e)\n\n        newblele = {latname.upper(): {'beamline': {'lattice': '(' + ' '.join(latticeline) + ')'}}}\n        self.all_elements.update(newblele)\n        self.kws_bl.append(latname.upper())\n        return newblele", "response": "construct a new lattice line"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate simulation files for the current beamline", "response": "def generateLatticeFile(self, beamline, filename=None, format='elegant'):\n        \"\"\" generate simulation files for lattice analysis,\n            e.g. \".lte\" for elegant, \".madx\" for madx\n\n            input parameters:\n            :param beamline: keyword for beamline\n            :param filename: name of lte/mad file,\n                if None, output to stdout;\n                if 'sio', output to a string as return value;\n                other cases, output to filename;\n            :param format: madx, elegant,\n                'elegant' by default, generated lattice is for elegant tracking\n        \"\"\"\n\n        \"\"\"\n        if not self.isBeamline(beamline):\n            print(\"%s is a valid defined beamline, do not process.\" % (beamline))\n            return False\n        \"\"\"\n\n        if filename is None:\n            f = sys.stdout\n        elif filename == 'sio':\n            f = StringIO()\n        else:\n            f = open(os.path.expanduser(filename), 'w')\n\n        # write filehead, mainly resolving prefix string lines\n        cl1 = \"This file is automatically generated by 'generateLatticeFile()' method,\"\n        cl2 = 'could be used as ' + format + ' lattice file.'\n        cl3 = 'Author: Tong Zhang (zhangtong@sinap.ac.cn)'\n        cl4 = 'Generated Date: ' + time.strftime('%Y-%m-%d %H:%M:%S %Z', time.localtime())\n\n        f.write('!{str1:<73s}!\\n'.format(str1='-' * 73))\n        f.write('!{str1:^73s}!\\n'.format(str1=cl1))\n        f.write('!{str1:^73s}!\\n'.format(str1=cl2))\n        f.write('!{str1:^73s}!\\n'.format(str1='-' * 24))\n        f.write('!{str1:^73s}!\\n'.format(str1=cl3))\n        f.write('!{str1:^73s}!\\n'.format(str1=cl4))\n        f.write('!{str1:<73s}!\\n'.format(str1='-' * 73))\n        f.write('\\n')\n\n        \"\"\" do not need to dump stoed variables now, 2016-03-21\n        # write global variables\n        f.write('! {str1:<73s}\\n'.format(str1= 'Global variable definitions:'))\n        f.write('\\n'.join(self.all_elements['_prefixstr']))\n        f.write('\\n')\n        f.write('\\n')\n        \"\"\"\n\n        # write EPICS control configuration part if contains '_epics' key\n        if '_epics' in self.all_elements:\n            f.write('! {str1:<73s}\\n'.format(str1='EPICS control definitions:'))\n            for k, v in self.all_elements['_epics'].items():\n                f.write('!!epics {k:<10s}:{v:>50s}\\n'.format(k=k, v=json.dumps(v)))\n            f.write('\\n')\n\n        # write element definitions and lattice\n        f.write('! {str1:<72s}\\n'.format(str1='Element definitions:'))\n        elelist = self.getFullBeamline(beamline, extend=True)\n        if self.getElementType(elelist[0]) != 'CHARGE':\n            elelist.insert(0, self.getChargeElement())\n        for ele in sorted(set(elelist)):\n            elestring = self.rinseElement(ele)['name']\n            f.write(self.formatElement(elestring, format='elegant') + '\\n')\n\n        # write beamline lattice definition\n        f.write('\\n')\n        f.write('! {str1:<72s}\\n'.format(str1='Beamline definitions:'))\n        f.write('{bl:<10s}: line = ({lattice})'.format(bl=beamline.upper(),\n                                                       lattice=', '.join(elelist)))\n        if filename == 'sio':\n            retval = f.getvalue()\n        else:\n            retval = True\n        f.close()\n\n        # if everything's OK, return True or string ('sio') mode\n        return retval"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresolving element case with multiply format", "response": "def rinseElement(self, ele):\n        \"\"\" resolve element case with multiply format,\n            e.g. rinseElement('10*D01') should return dict {'num': 10; 'name' = 'D01'}\n            :param ele: element string\n        \"\"\"\n        if '*' in ele:\n            tmplist = ''.join(ele.split()).split('*')\n            tmplist_num = tmplist[[x.isdigit() for x in tmplist].index(True)]\n            tmplist_ele = tmplist[[x.isdigit() for x in tmplist].index(False)]\n            return dict(zip(('num', 'name'), (int(tmplist_num), tmplist_ele)))\n        else:\n            return dict(zip(('num', 'name'), (1, ele)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\norder the element type appearance sequence for each element of beamline", "response": "def orderLattice(self, beamline):\n        \"\"\" ordering element type appearance sequence for each element of beamline\n            e.g. after getFullBeamline,\n            lattice list ['q','Q01', 'B11', 'Q02', 'B22'] will return:\n            [(u'q',   u'CHARGE',   1),\n             (u'q01', u'QUAD',     1),\n             (u'b11', u'CSRCSBEN', 1),\n             (u'q02', u'QUAD',     2),\n             (u'b12', u'CSRCSBEN', 2)]\n\n        \"\"\"\n        ele_name_list = self.getFullBeamline(beamline, extend=True)\n        ele_type_list = [self.getElementType(ele) for ele in ele_name_list]\n        order_list = [0] * len(ele_name_list)\n        ele_type_dict_uniq = dict(zip(ele_type_list, order_list))\n        for idx in xrange(len(ele_name_list)):\n            etype = ele_type_list[idx]\n            ele_type_dict_uniq[etype] += 1\n            order_list[idx] = ele_type_dict_uniq[etype]\n\n        return zip(ele_name_list, ele_type_list, order_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets element list by appearance order in beamline", "response": "def getElementByOrder(self, beamline, type, irange):\n        \"\"\" return element list by appearance order in beamline,\n            which could be returned by orderLattice(beamline)\n\n            :param beamline: beamline name\n            :param type: element type name\n            :param irange: selected element range\n\n        possible irange definitions:\n            irange = 0,      first one 'type' element;\n            irange = -1,     last one\n            irange = 0,2,3,  the first, third and fourth 'type' element\n            irange = 2:10:1, start:end:setp range\n            irange = 'all',    all\n        \"\"\"\n        try:\n            assert beamline.upper() in self.kws_bl\n        except AssertionError:\n            print('%s is not a defined beamline.' % beamline)\n            return ''\n\n        try:\n            orderedLattice_list = self.orderLattice(beamline)\n            allmatchedlist = [val for idx, val in enumerate(orderedLattice_list) if val[1] == type.upper()]\n            if ',' in str(irange):\n                retlist = [allmatchedlist[int(num)] for num in str(irange).split(',')]\n            elif ':' in str(irange):\n                idxlist = map(int, irange.split(':'))\n                if len(idxlist) == 2:\n                    idxlist.append(1)\n                idx_start, idx_stop, idx_step = idxlist[0], idxlist[1], idxlist[2]\n                retlist = allmatchedlist[slice(idx_start, idx_stop, idx_step)]\n            elif str(irange) == 'all':\n                retlist = allmatchedlist[:]\n            else:\n                retlist = [allmatchedlist[int(irange)]]\n            return retlist\n        except:\n            # print('Can not find %s in %s.' % (type, beamline))\n            return ''"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getElementByName(self, beamline, name):\n        try:\n            assert beamline.upper() in self.kws_bl\n        except AssertionError:\n            print('%s is not a defined beamline.' % beamline)\n            return ''\n\n        try:\n            assert name.lower() in self.getFullBeamline(beamline, extend=True)\n            orderedLattice_list = self.orderLattice(beamline)\n            retlist = [val for idx, val in enumerate(orderedLattice_list) if val[0] == name.lower()]\n            return retlist\n\n        except AssertionError:\n            print('%s is not in %s.' % (name, beamline))\n            return ''", "response": "return element list by literal name in beamline\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmanipulate the beamline with type and operation", "response": "def manipulateLattice(self, beamline, type='quad',\n                          irange='all', property='k1',\n                          opstr='+0%'):\n        \"\"\" manipulate element with type, e.g. quad\n\n            input parameters:\n            :param beamline: beamline definition keyword\n            :param type: element type, case insensitive\n            :param irange: slice index, see getElementByOrder()\n            :param property: element property, e.g. 'k1' for 'quad' strength\n            :param opstr: operation, '+[-]n%' or '+[-*/]n'\n        \"\"\"\n        # lattice_list = self.getFullBeamline(beamline, extend = True)\n        # orderedLattice_list = self.orderLattice(beamline)\n        opele_list = self.getElementByOrder(beamline, type, irange)\n\n        opr = opstr[0]\n        opn = float(opstr[1:].strip('%'))\n\n        if opstr[-1] == '%':\n            opn /= 100.0\n            opsdict = {'+': lambda a, p: a * (1 + p),\n                       '-': lambda a, p: a * (1 - p)}\n        else:\n            opsdict = {'+': lambda a, p: a + p,\n                       '-': lambda a, p: a - p,\n                       '*': lambda a, p: a * p,\n                       '/': lambda a, p: a / float(p)}\n\n        for ename, etype, eid in opele_list:\n            val0_old = self.all_elements[ename.upper()].values()[0].get(property.lower())\n            val0_new = opsdict[opr](val0_old, opn)\n            self.all_elements[ename.upper()].values()[0][property.lower()] = val0_new\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn element properties :param name: element name", "response": "def getElementProperties(self, name):\n        \"\"\" return element properties\n        :param name: element name\n        \"\"\"\n        try:\n            allp = self.all_elements[name.upper()]\n            if isinstance(allp, dict):\n                type = allp.keys()[0]\n                properties = allp.values()[0]\n                return {'type': type, 'properties': properties}\n            else:\n                type = allp\n                return {'type': type, 'properties': None}\n        except:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an element object regarding the keyword configuration", "response": "def makeElement(self, kw):\n        \"\"\" return element object regarding the keyword configuration\n        \"\"\"\n        kw_name = kw\n        kw_type = self.getElementType(kw_name)\n        kw_config = {k.lower(): v for k, v in self.getElementConf(kw_name).items()}\n        objtype = 'Element' + kw_type.capitalize()\n        retobj = getattr(element, objtype)(name=kw_name, config=kw_config)\n        # set up EPICS control configs\n        ctrlconf = self.getElementCtrlConf(kw)\n        if ctrlconf != {}:\n            retobj.setConf(ctrlconf, type='ctrl')\n\n        return retobj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting a list to display it.", "response": "def format(name, dataItem, eltsToParse=None):\n        \"\"\"Formats a list to display it.                \n        Input Parameters\n        ----------------\n        name : name of the object that contains a list of afftributes\n        dataItem : list of attributes\n        eltsToParse : elts to display\n        \n        Return\n        ------\n        Returns a string to display\n        \n        Note : When eltsToParse is no defined then all the list is displayed.\"\"\"\n        display = []\n        if eltsToParse == None:\n            display = dataItem\n        else:\n            display = eltsToParse\n        \n        str = \"%s object display:\\n\"%(name)       \n        for key, value in enumerate(display):\n            str += \"\\t%s : %s = %s\\n\"%(key, value, dataItem[value])\n        return str"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves a JSON response from the server.", "response": "def retrieveJsonResponseFromServer(url):\n        \"\"\"Retrieves a JSON response from the server.\n        Input parameters\n        ----------------\n        url : url to call for retrieving the JSON response\n        \n        Return\n        ------\n        A dictionary\n        \n        Exception\n        ---------\n        SITools2Exception when a problem during the download or parsing happens\"\"\"\n        jsonData = None\n        try:\n            data = urllib.urlopen(url)\n            jsonData = simplejson.load(data)\n        except Exception as ex:\n            raise Sitools2Exception(ex)\n        return jsonData"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getLogger(name, level = logging.INFO):\n        # create logger\n        logger = logging.getLogger(name) \n        logger.setLevel(level)\n        # create console handler and set level to debug\n        ch = logging.StreamHandler()\n        ch.setLevel(level)\n        # create formatter\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        # add formatter to ch\n        ch.setFormatter(formatter)\n        # add ch to logger\n        logger.addHandler(ch)\n        return logger", "response": "Returns the logger with the given name and level."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef render_from_path(path, context=None, globals=None):\n    abs_source = os.path.abspath(os.path.expanduser(path))\n    yaml_resolver = resolver.TYamlResolver.new_from_path(abs_source)\n\n    return yaml_resolver.resolve(Context(context), globals)._data", "response": "Renders a templated yaml document from a file path."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrenders a templated yaml document from a string.", "response": "def render_from_string(content, context=None, globals=None):\n    \"\"\"\n    Renders a templated yaml document from a string.\n\n    :param content: The yaml string to evaluate.\n    :param context: A context to overlay on the yaml file.  This will override any yaml values.\n    :param globals: A dictionary of globally-accessible objects within the rendered template.\n    :return: A dict with the final overlayed configuration.\n    \"\"\"\n    yaml_resolver = resolver.TYamlResolver.new_from_string(content)\n\n    return yaml_resolver.resolve(Context(context), globals)._data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns interface URL endpoint.", "response": "def get_endpoint(self, endpoint=None):\n        \"\"\"Return interface URL endpoint.\"\"\"\n        base_url = self.api_config.api_url\n        if not endpoint:\n            if 'localhost' in base_url:\n                endpoint = ''\n            else:\n                endpoint = ENDPOINTS[self.endpoint_type]\n\n        endpoint = '/'.join([p.strip('/') for p in (base_url, endpoint)]).strip('/')\n        self.logger.info(\"Using Endpoint: %s\", endpoint)\n        return endpoint"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the _expiry_date attribute of the object.", "response": "def expiry_date(self, value):\n        \"\"\"\n        The date on which the Futures contract expires\n        :param expiry_date:\n        :return:\n        \"\"\"\n        if value:\n            self._expiry_date = parse(value).date() if isinstance(value, type_check) else value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main(args, stop=False):\n    daemon = AMQPDaemon(\n        con_param=getConParams(\n            settings.RABBITMQ_FTP_VIRTUALHOST\n        ),\n        queue=settings.RABBITMQ_FTP_INPUT_QUEUE,\n        out_exch=settings.RABBITMQ_FTP_EXCHANGE,\n        out_key=settings.RABBITMQ_FTP_OUTPUT_KEY,\n        react_fn=reactToAMQPMessage,\n        glob=globals()                # used in deserializer\n    )\n\n    if not stop and args.foreground:  # run at foreground\n        daemon.run()\n    else:\n        daemon.run_daemon()", "response": "Main function for the daemon."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __validInputs(self):\n        #if not isinstance(self.__column, Column):\n        #    raise Sitools2Exception(\"column must be an instance of Column\")\n        try:\n            float(self.__minVal)\n        except ValueError as ex:\n            raise Sitools2Exception(ex)\n        try:\n            float(self.__maxVal)\n        except ValueError as ex:\n            raise Sitools2Exception(ex)\n        \n        if float(self.__minVal) >= float(self.__maxVal):\n            raise Sitools2Exception(\"maxVal must be superior to minVal\")", "response": "Validates the inputs of the constructor."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _getParameters(self):\n        param = self.query._getParameters()\n        key = self.__PATTERN_KEY % (str(self._getIndex()))\n        val = self.__PATTERN_VALUE % (self.__column, self.__value)\n        #self.__column.getColumnAlias()\n        param.update({key:val})\n        return param", "response": "Returns the result of this decorator."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates the inputs of the constructor.", "response": "def __validInputs(self):\n        \"\"\"Validates the inputs of the constructor.\"\"\"\n        #if not isinstance(self.__column, Column):\n        #    raise Sitools2Exception(\"column must be an instance of Column\") \n        if self.__type not in self.__TYPE:\n            raise Sitools2Exception(\"Type must be one of these values : numeric, string, boolean\")\n        if self.__comparison not in self.__COMPARISON:\n            raise Sitools2Exception(\"Comparison must be one of these values : LT, GT, EQ, LIKE, IN, NOTIN\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _getParameters(self):\n        param = self.query._getParameters() \n        index = self._getFilterIndex()\n        param.update({\n        'filter['+str(index)+'][columnAlias]' : self.__column,\n        'filter['+str(index)+'][data][type]' : self.__type,\n        'filter['+str(index)+'][data][value]' : self.__value,\n        'filter['+str(index)+'][data][comparison]' : self.__comparison})        \n        #self.__column.getColumnAlias()\n        return param", "response": "Returns the result of this decorator."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _getParameters(self):\n        param = self.query._getParameters() \n        outputNames = []\n        for outputCol in self.__columns:\n            outputNames.append(outputCol)            \n        param.update({'colModel' : '\"'+', '.join(outputNames)+'\"'})        \n        return param", "response": "Returns the result of this decorator."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _getParameters(self):\n        param = self.query._getParameters()        \n        sortingNames = []\n        for outputCol in self.__columns:\n            sort_dictionary={\"field\" : outputCol, \"direction\" : \"ASC\"}\n            sortingNames.append(sort_dictionary)            \n        param.update({'sort' : {\"ordersList\" : sortingNames}})\n        return param", "response": "Returns the result of this decorator."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the result of this decorator.", "response": "def _getParameters(self):\n        \"\"\"Returns the result of this decorator.\"\"\"\n        param = self.query._getParameters()                   \n        param[self.__key] =  self.__value\n        return param"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the server response.", "response": "def __parseResponse(self, result):\n        \"\"\"Parses the server response.\"\"\"\n        response = []\n        for data in result['data'] :\n            result_dict={}\n            for k,v in data.items() :\n                column = self.getOutputColumn(k)\n                if column != None:\n                    type = column.getSqlColumnType()\n                    if type != None and type.startswith('int'): \n                        result_dict.update({\n                                k : int(v)\n                        })\n                    elif type != None and type.startswith('float'):\n                        result_dict.update({\n                                k : float(v)\n                        })\n                    elif type != None  and type.startswith('timestamp'):\n                        (dt, mSecs)= v.split(\".\")\n                        dt = datetime.strptime(dt,\"%Y-%m-%dT%H:%M:%S\")\n                        mSeconds = timedelta(microseconds = int(mSecs))\n                        result_dict.update({\n                                k : dt+mSeconds\n                        })\n                    else :\n                        result_dict.update({\n                                k : v\n                        })                    \n            response.append(result_dict)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading the files related to the query.", "response": "def download(self, FILENAME=None):\n        \"\"\"Downloads the files related to the query.\"\"\"\n        resultFilename = None\n        url = self.__url+'/services'                \n        result = Util.retrieveJsonResponseFromServer(url)\n        dataItems = result['data']\n        for item in dataItems:\n            plugin = Plugin(item)        \n            result = plugin.getParameterByValue(\"fr.cnes.sitools.resources.order.DirectOrderResource\")            \n            if result == None:\n                continue\n            else:\n                urlParameter = plugin.getParameterByType('PARAMETER_ATTACHMENT')\n                urlPlugin = urlParameter.getValue()\n                encodingParameter = plugin.getParameterByName('archiveType')\n                encodingPlugin = encodingParameter.getValue()\n                query = self.getQueries()\n                query.setBaseUrl(self.__url + urlPlugin)\n                url = query.getUrl()                \n                (filename, header) = Util.urlretrieve('%s' % url, FILENAME)\n                if FILENAME == None:\n                    os.rename(filename, filename + \".\" + encodingPlugin)\n                    resultFilename = filename + \".\" + encodingPlugin\n                else:\n                    os.rename(FILENAME, FILENAME + \".\" + encodingPlugin)\n                    resultFilename = FILENAME + \".\" + encodingPlugin\n                break\n        return resultFilename"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the parameters of the data.", "response": "def __parseParameters(self):\n        \"\"\"Parses the parameters of data.\"\"\"\n        self.__parameters = []\n        for parameter in self.__data['parameters']:\n            self.__parameters.append(Parameter(parameter))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches a parameter by value and returns it.", "response": "def getParameterByValue(self, value):\n        \"\"\"Searchs a parameter by value and returns it.\"\"\"\n        result = None\n        for parameter in self.getParameters():\n            valueParam = parameter.getValue()\n            if valueParam == value:\n                result = parameter\n                break\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getParameterByType(self, type):\n        result = None\n        for parameter in self.getParameters():\n            typeParam = parameter.getType()\n            if typeParam == type:\n                result = parameter\n                break\n        return result", "response": "Searches a parameter by type and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getParameterByName(self, name):\n        result = None\n        for parameter in self.getParameters():\n            nameParam = parameter.getName()\n            if nameParam == name:\n                result = parameter\n                break\n        return result", "response": "Searches a parameter by name and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_dataset(self,dataStr,flatten=False):\r\n        '''\r\n        update class with a data structure.\r\n        \r\n        :keyword flatten: use this to automatically flatten variables (squeeze dimensions)\r\n        '''\r\n\r\n        #Load keys and dimensions\r\n        #########################\r\n        dataDim = dataStr.pop('_dimensions',{})\r\n        attrStr = dataStr.pop('_attributes',{})\r\n        ndims = dataDim.pop('_ndims',0)\r\n        dimensions = [dataDim.keys(),dataDim.values()]\r\n        \r\n        keys = dataStr.keys()\r\n        if len(keys) == 0:\r\n            self.warning(2, 'No data loaded')\r\n            return\r\n        self.message(2, 'Loaded variables : '+str(keys))\r\n        \r\n        #Check what is the current variable type\r\n        isStructure = True if isinstance(dataStr[keys[0]],dict) else False\r\n        \r\n#        datalen = [np.size(dataStr[key]) for key in keys]\r\n        datalen = [list(np.shape(dataStr[key]['data'])[::-1]) for key in keys] if isStructure else [list(np.shape(dataStr[key])[::-1]) for key in keys] #Shape is inverted wrt to order of dimensions to be consistent with check_variable\r\n        if isStructure :\r\n            varDim = [list(dataStr[key]['_dimensions'])[1:] for key in keys]\r\n            ind = [where_list(vDim,dimensions[0]) for vDim in varDim] #Dimensions indices from actual variables' dimensions\r\n            \r\n            #Check dimension lengths\r\n#             dimOk = np.array([enum[1][0] == dimensions[1][ind[enum[0]][0]] for enum in enumerate(datalen)])\r\n            dimOk = [any([enum[1][ii] == dimensions[1][jj] for ii,jj in enumerate(ind[enum[0]])]) for enum in enumerate(datalen)]\r\n            \r\n\r\n            if any([not d for d in dimOk]) : \r\n                notOk = np.where(~np.array(dimOk))[0]\r\n                print datalen\r\n                \r\n                self.Error('Problem with {0} variables : {1}'.format(len(notOk),','.join(np.array(dataStr.keys())[notOk])))\r\n        else :\r\n            ind = [where_list(dlen,dimensions[1]) for dlen in datalen] #Dimensions indices from variable length\r\n            if (np.array(ind).sum() == -1)!= 0 : self.Error('At least one variable have not been properly defined')\r\n            \r\n        dimname = [np.array(dimensions[0])[i].tolist() for i in ind]  #Get correspondance between data structure dimensions and variables\r\n                \r\n        curDim, nself=self.get_currentDim()\r\n        createDim=np.array([np.array([w == -1 for w in where_list(j, curDim[0])]) for i,j in enumerate(dimname) ])\r\n        createDim=np.squeeze(createDim)\r\n#        curInd = atools.where_list(dimname_reduced,curDim[0]) #Get correspondance between data structure dimensions and object dimensions\r\n        \r\n#        createDim = (np.array(curInd) == -1) #Get dimensions to be created   \r\n        toCreate = np.array([not self.__dict__.has_key(key) for key in keys])\r\n        \r\n        updateDim=[]  \r\n        \r\n        self.message(2, 'Updating object with '+str(['{0}({1}:{2})'.format(i[0],i[1],i[2]) for i in zip(*(keys,dimname,datalen))]))\r\n        \r\n        #Update variables available in files\r\n        for enum in enumerate(keys) :\r\n            \r\n            ind=enum[0]\r\n            key=enum[1]\r\n            \r\n            #Load variable\r\n            ##############\r\n#            var=dataStr.get(key)\r\n            dum=dataStr.get(key).pop('data') if isStructure else copy.deepcopy(dataStr.get(key)) \r\n            if flatten :\r\n                if isinstance(dum,dict) :dum['data']=dum['data'].flatten()\r\n                else : dum=dum.flatten()\r\n            \r\n            if not isStructure :\r\n                dum={'_dimensions':dum._dimensions if hasattr(dum,'_dimensions') else {},\r\n                      '_attributes':dum._attributes if hasattr(dum,'_attributes') else {},\r\n                      'data':dum}\r\n            else :\r\n                dumStr=dataStr.get(key)\r\n                dumStr.update({'data':dum})\r\n                dum=dumStr\r\n\r\n            dumDim=dimStr(dimname[ind],datalen[ind])\r\n\r\n#             if dataStr[key].has_key('_attributes'):\r\n#                 dum.update(dataStr[key]['_attributes'])\r\n#            if isinstance(dum,np.ma.masked_array) : \r\n            \r\n#            #Get associated dimensions\r\n#            ##################################\r\n#            datalen = datalen[ind]#[len(dataStr[key]) for key in keys]\r\n#            ind = atools.where_list([datalen],dimensions[1])[0]\r\n#            if (ind == -1) : self.Error('Dimensions of current variable ('+key+') have not been properly defined')\r\n#            dimname = dimensions[\r\n            \r\n            #Initialize variable if required\r\n#            if toCreate :\r\n#            updateDim.append(self.create_Variable(key, dum, dimensions={dimname[ind]:datalen[ind]},toCreate=toCreate[ind],createDim=createDim[ind]))\r\n            updateDim.append(self.create_Variable(key, dum, dimensions=dumDim,toCreate=toCreate[ind],createDim=createDim[ind]))\r\n\r\n        \r\n        #Extend missing variables\r\n#         missing__keys = list(set(self.par_list).difference(keys))\r\n#         for enum in enumerate(missing__keys) :\r\n#             ind=enum[0]\r\n#             key=enum[1]\r\n#             updateDim.append(self.create_Variable(key, np.ma.repeat(self.dist_to_coast_leuliette.fill_value), dimensions=dumDim,toCreate=False,createDim=False))\r\n        \r\n        \r\n        #Final sequence\r\n        \r\n        zipped_upd=zip(*(np.hstack(dimname)[~np.hstack(createDim)],np.hstack(datalen)[~np.hstack(createDim)]))\r\n        updateDim_List = np.array(list(set(tuple(i) for i in np.array(zipped_upd,dtype='|S16').tolist()))) #2D unique\r\n#        updateDim_List = np.unique(np.array(zipped_upd,dtype='|S16')) #[str(i) for i in datalen]\r\n#        if updateDim_List.size > 0 : updateDim_List.resize((2,updateDim_List.size/2))\r\n#        updateDim_List = np.unique(zip(*(np.array(dimname)[~createDim],np.array(datalen)[~createDim]))) #[str(i) for i in datalen]\r\n\r\n        zipped_dims=zip(*(np.hstack(dimname)[np.hstack(createDim)],np.hstack(datalen)[np.hstack(createDim)]))\r\n        createDim_list = np.array(list(set(tuple(i) for i in np.array(zipped_dims,dtype='|S16').tolist()))) #2D unique\r\n#        clist, inv = np.unique(np.array(zipped_dims,dtype='|S16'),return_inverse=True) #RQ : THIS WILL FAIL IF NUMBERS HAVE MORE THAN 16 DIGITS #[str(i) for i in datalen]\r\n#        if createDim_list.size > 0 : createDim_list.resize((2,createDim_list.size/2))\r\n        \r\n#        createDim_list = np.unique(zip(*(np.array(dimname)[createDim],np.array(datalen)[createDim]))) #[str(i) for i in datalen]\r\n        \r\n        for dname,dim in createDim_list :\r\n            self.create_Dim(dname, np.int(dim))\r\n        \r\n        for dname,dim in updateDim_List:\r\n            self.update_Dim(dname, np.int(dim))", "response": "update the variable table with a new data structure."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if all variables are consistent with the current object.", "response": "def check_variables(self):\r\n        \"\"\"\r\n        Forces variables to respect dimensions\r\n        \"\"\"\r\n        \r\n        self.count = len(self.fileid)\r\n        self.size = np.size([np.size(self.__dict__.get(par)) for par in self.par_list])\r\n        \r\n        infos = zip(*(self.par_list.tolist(),self.dim_list.tolist()))\r\n#        curDim, nself = self.get_currentDim()\r\n        \r\n        for enum in enumerate(infos):\r\n            varSize = np.size(self.__dict__.get(enum[1][0]))\r\n            varShape = np.shape(self.__dict__.get(enum[1][0]))[::-1] #Data and Netcdf dimensions are inverted (not allways?)\r\n            \r\n            dimSize = None\r\n            if hasattr(self.__dict__.get(enum[1][0]),'_dimensions') :\r\n                dumDim = self.__dict__.get(enum[1][0])._dimensions\r\n                dumDim.pop('_ndims')\r\n                dimSize = tuple(dumDim.values())\r\n            elif isinstance(self.__dict__.get(enum[1][0]),dict):\r\n                if self.__dict__.get(enum[1][0]).has_key('_dimensions'):\r\n                    dumDim = self.__dict__.get(enum[1][0])['_dimensions']\r\n                    dumDim.pop('_ndims')\r\n                    dimSize = tuple(dumDim.values())\r\n            \r\n            if dimSize is None :\r\n                if isinstance(self._dimensions,dimStr) :\r\n                    dimSize = (self._dimensions).get(enum[1][1])\r\n                else :\r\n                    dimSize = tuple([(self._dimensions).get([d]) for d in enum[1][1]])\r\n                \r\n            masked = isinstance(self.__dict__.get(enum[1][0]), np.ma.masked_array)\r\n            \r\n            #Check mask consistency (mask length should be the same as data)\r\n            if masked :\r\n                if (self.__dict__.get(enum[1][0]).mask.size != self.__dict__.get(enum[1][0]).data.size): raise np.ma.core.MaskError(\"Mask length is not consistent with data\")\r\n            \r\n            #Check dimensions\r\n            self.message(4, 'checking variables -> {0}(N={1}) - {2}:{3}'.format(enum[1][0],varSize,enum[1][1],dimSize))\r\n            for n,sh in enumerate(varShape) :\r\n                if (sh > dimSize[n]) :\r\n                    self.Error('Object variable {0} greater than corresponding dimension ({1})'.format(enum[1][0],enum[1][1]))\r\n                elif (sh < dimSize[n]):\r\n                    self.message(3, 'Variable {0}(N={1}) being extended to match dimension {2}:{3}'.format(enum[1][0],varSize,enum[1][1],dimSize))  \r\n    #                self.__dict__[enum[1][0]] = np.ma.concatenate((self.__dict__[enum[1][0]], np.ma.masked_array(np.repeat(np.nan,dimSize - varSize),mask=np.zeros(dimSize - varSize,dtype='bool'))))\r\n    \r\n                    #Save additonnal attributes\r\n                    attrStr={}\r\n                    for a in set(self.__dict__[enum[1][0]].__dict__.keys()).difference(np.ma.empty(0,dtype=bool).__dict__.keys()):\r\n                        attrStr.update({a:self.__dict__[enum[1][0]].__dict__[a]})\r\n                    self.__dict__[enum[1][0]] = np.ma.masked_array( np.append(self.__dict__[enum[1][0]].data,np.repeat(self.__dict__[enum[1][0]].fill_value if hasattr(self.__dict__[enum[1][0]],'fill_value') else np.NaN,dimSize[n] - varSize)),\r\n                                                                    mask=np.append(self.__dict__[enum[1][0]].mask,np.ones(dimSize[n] - varSize,dtype='bool')) )\r\n                    self.__dict__[enum[1][0]].__dict__.update(attrStr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a dimension to class.", "response": "def create_Dim(self, name,value):\r\n        '''\r\n        Adds a dimension to class.\r\n        \r\n        :parameter name: dimension name\r\n        :parameter value: dimension value\r\n        '''\r\n        if not self._dimensions.has_key(name) :\r\n            self.message(3, 'Create dimension {0}:{1}'.format(name,value))\r\n            self._dimensions[name]=value\r\n            self._dimensions['_ndims']=len(self._dimensions) - 1\r\n        else :\r\n            self.message(3, 'Dimension {0} already exists'.format(name))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_Dim(self,name,value):\r\n        '''\r\n        update a dimension by appending the number of added elements to the dimensions ::\r\n        \r\n          <upddated dimension> = <old dimension> + <number of added elements along this dimension>\r\n           \r\n        '''\r\n        oldVal=self._dimensions[name]\r\n        self._dimensions[name] += value\r\n        self.message(2, 'Updating dimension {0} (from {1} to {2})'.format(name,oldVal,self._dimensions[name]))\r\n        \r\n        #Update dimensions within all variables\r\n        for p in self.par_list:\r\n            if self.__dict__[p].__dict__.has_key('_dimensions'):\r\n                for d in self.__dict__[p]._dimensions.keys():\r\n                    self.__dict__[p]._dimensions.update({d:self._dimensions[d]})", "response": "update a dimension by appending the number of added elements along this dimension"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating file indices attribute altimetry. data. hydro_data. fileid", "response": "def update_fid_list(self,filename,N):\r\n        '''\r\n        update file indices attribute `altimetry.data.hydro_data.fileid`\r\n        '''\r\n        self.filelist_count[self.filelist.index(filename)] = N\r\n        fid=self.fid_list.compress([enum[1][0] == os.path.basename(filename) for enum in enumerate(zip(*(self.filelist,self.fid_list)))])\r\n        self.__dict__.update({'fileid' :np.append(self.fileid,np.repeat(fid,N))})"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_Variable(self,name):\r\n        '''\r\n        pops a variable from class and delete it from parameter list\r\n        \r\n        :parameter name: name of the parameter to delete\r\n        '''\r\n        self.message(1,'Deleting variable {0}'.format(name))\r\n        self.par_list=self.par_list[self.par_list != name]\r\n        return self.__dict__.pop(name)", "response": "delete a variable from the class and remove it from the parameter list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_Variable(self,name,value,dimensions,toCreate=None,createDim=None,extend=True):\r\n        \r\n        #Check variable name\r\n        ####################\r\n        #This allows to remove impossible variable names\r\n        #!!!! This is not a good solution\r\n        name=name.replace('.','_')\r\n        \r\n        #Check if data is structured or not\r\n        isStructure = True if isinstance(value,dict) else False\r\n        \r\n        #Get dimensions\r\n        dimName = np.array(dimensions.keys())\r\n        dimVal = np.array(dimensions.values())\r\n        keys=np.array(self._dimensions.keys())\r\n        \r\n#        if createDim is None : createDim = self._dimensions.has_key(dimName[0])\r\n        createDim = np.array([not self._dimensions.has_key(dim) for dim in dimName]) if createDim is None else np.array(createDim)\r\n        if toCreate is None : toCreate = np.sum(self.par_list == name) == 0\r\n        \r\n        self.message(3,'Loading {0} ({1}:{2}) from {3}'.format(name,dimName,dimVal,os.path.basename(self._filename)))\r\n\r\n        #Cast variable into masked array first\r\n        ######################################\r\n        if (not isinstance(value['data'],np.ma.core.MaskedArray) if isStructure else not isinstance(value,np.ma.core.MaskedArray)) :\r\n            value['data'] = np.ma.masked_array(value['data'],mask=np.zeros(tuple(dimVal),dtype='bool')) if isStructure else np.ma.masked_array(value,mask=np.zeros(tuple(dimVal),dtype='bool'))\r\n            self.message(4,'Casting variable to np.ma.MaskedArray')\r\n        \r\n        #Restructure dataset if structure\r\n        if isStructure :\r\n            dumvalue=value.pop('data')\r\n            if value.has_key('_attributes'):\r\n                for a in value['_attributes'].keys():\r\n                    self.message(4, \"copying attribute %s\" % a)\r\n                    dumvalue.__setattr__(a,value['_attributes'][a])\r\n            value=copy.deepcopy(dumvalue)\r\n        \r\n        \r\n        curDim, nself=self.get_currentDim()\r\n        \r\n        curInd=np.array(where_list(dimName,curDim[0]))\r\n        curDimVal=np.array(where_list(dimVal,curDim[1]))\r\n        \r\n        existDims= (curInd != -1)\r\n        createDim = (curInd == -1)\r\n        createInd = np.where(createDim)[0]\r\n        \r\n        appendDim=existDims & (curDimVal == -1)\r\n        appendInd=curInd[appendDim]\r\n        \r\n        \r\n#        curInd = set(atools.where_list(dimVal,curDim[1])).intersection(set(atools.where_list(dimName,curDim[0]))) \r\n\r\n        #Get dims to be created\r\n        #######################\r\n        \r\n        \r\n\r\n        #Choose case between all different solutions :\r\n        ##############################################\r\n        # 1: create a new variable with at least 1 new dimension\r\n        # 2: extend -> create a new variable using existing dimensions\r\n        # 3: append exisiting variable with data\r\n        # 4: impossible case ?\r\n        \r\n        #1) Create variable\r\n        if createDim.any() & toCreate :           \r\n            #Create Variable\r\n            self.message(4,'Create variable %s '+name)\r\n#            self.__setattr__(name,value)\r\n#            cmd='self.'+name+'=value'\r\n\r\n            #Append variable infos to object\r\n            self.par_list=np.append(self.par_list,name)\r\n            dimlist_cp=self.dim_list.tolist()\r\n            dimlist_cp.append(dimName.tolist())\r\n            self.dim_list=np.array(dimlist_cp) #np.append(self.dim_list,dimName.tolist())\r\n        \r\n            updateDim=False\r\n        \r\n        #2) Extend\r\n        elif (not createDim.any()) & toCreate :\r\n            \r\n            #extend variable\r\n            if extend :\r\n                dumvalue = np.ma.masked_array(np.append(np.zeros(curDim[1][curInd]),value.data),mask=np.append(np.ones(curDim[1][curInd],dtype='bool'),value.mask))\r\n                for a in set(value.__dict__.keys()).difference(dumvalue.__dict__.keys()) :\r\n                    dumvalue.__setattr__(a,value.__dict__[a] if hasattr(value, a) else self.__getattribute__(name).__getattribute__(a))\r\n                value=copy.deepcopy(dumvalue)\r\n            \r\n            self.message(4,'Extend variable '+name)\r\n#            self.__setattr__(name,value)\r\n#            cmd='self.'+name+'=value'\r\n#            self.message(4,'exec : '+cmd)\r\n\r\n            #Append variable infos to object\r\n            self.par_list=np.append(self.par_list,name)\r\n            dimlist_cp=self.dim_list.tolist()\r\n            dimlist_cp.append(dimName.tolist())\r\n            self.dim_list=np.array(dimlist_cp)\r\n#            self.dim_list=np.append(self.dim_list,dimName)\r\n            \r\n            updateDim=True\r\n        \r\n        #3) Append\r\n        elif (not createDim.any()) & (not toCreate) :\r\n            #append variable\r\n            self.message(4,'Append data to variable '+name)\r\n            \r\n            dumvalue = np.ma.masked_array(np.append(self.__getattribute__(name).data,value.data),mask=np.append(self.__getattribute__(name).mask,value.mask))\r\n            \r\n            #We gather a list of attributes :\r\n            # - already in data structure,\r\n            # - in current data file\r\n            # - and not in output structure\r\n            attributes=set(self.__getattribute__(name).__dict__.keys())\r\n            attributes=attributes.union(value.__dict__.keys())\r\n#             attributes=attributes.difference(self.__getattribute__(name).__dict__.keys())\r\n            attributes=attributes.difference(dumvalue.__dict__.keys())\r\n            \r\n            #Then :\r\n            # - we add attributes of current file not in data structure\r\n            # - we keep attributes of current data structure if they exist \r\n            for a in attributes :\r\n                dumvalue.__setattr__(a,value.__dict__[a] if hasattr(value, a) else self.__getattribute__(name).__getattribute__(a))\r\n            value=copy.deepcopy(dumvalue)\r\n                    \r\n            updateDim=True\r\n        \r\n        elif createDim.any() & (not toCreate) :\r\n            #Impossible case ?\r\n            self.Error('Impossible case : create dimensions and variable {0} already existing'.format(name))\r\n        \r\n        \r\n        #Append dimensions to variable\r\n        if not dimensions.has_key('_ndims') :\r\n            dumDim=dimStr(dimensions)\r\n            dimensions=dumDim.copy()\r\n        \r\n        #Update variable dimensions\r\n        if updateDim :\r\n            for k in dimensions.keys(): dimensions.update({k:self._dimensions[k]})\r\n        \r\n        value.__setattr__('_dimensions',dimensions)\r\n        \r\n        try : self.__setattr__(name,value)\r\n        except np.ma.core.MaskError : raise 'mask error' \r\n#           \r\n#        try : exec(cmd)\r\n#        except np.ma.core.MaskError :\r\n#            raise 'mask error' \r\n#        exec(cmd)\r\n         \r\n        return updateDim", "response": "This function creates a new variable in the given NetCDF file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting a message depending on the verbose level", "response": "def message(self,MSG_LEVEL,str):\r\n        \"\"\"\r\n        print function wrapper. Print a message depending on the verbose level\r\n         \r\n        :parameter {in}{required}{type=int} MSG_LEVEL: level of the message to be compared with self.verbose\r\n        \r\n        :example: To write a message \r\n           \r\n           .. code-block:: python\r\n           \r\n              self.message(0,'This message will be shown for any verbose level')\r\n        \r\n        \r\n        \"\"\"\r\n        \r\n        caller=get_caller()\r\n        if MSG_LEVEL <= self.verbose :  print('[{0}.{1}()] {2}'.format(__name__,caller.co_name,str))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef updated_copy(self,flag,deep=True):\r\n        '''\r\n        Returns a sliced (updated) copy of current data object\r\n        \r\n        :summary: This has the same effect as `obj.copy();obj.update(flag)` but is much less memory consumming.\r\n        \r\n        .. note:: TypeError could arise if some object attributes are setted outside the :func:`__init__` function (eg. for data objects derived from :class:`hydro_data`). If this is the case, initialise these attributes within their respective :func:`__init__`.\r\n        \r\n        '''\r\n        \r\n        \r\n        emptyObj=self.__class__([])\r\n        \r\n        if deep : func_copy = copy.deepcopy\r\n        else : func_copy = copy.copy\r\n        \r\n        #Get object attributes from self\r\n        for a in set(self.__dict__.keys()).intersection(emptyObj.__dict__.keys()):\r\n            self.message(4, 'updating attribute %s to returned object' % a)\r\n            emptyObj.__dict__[a] = func_copy(self.__dict__[a])\r\n        \r\n        #Get slices\r\n        for p in set(self.__dict__.keys()).difference(emptyObj.__dict__.keys()):\r\n            self.message(4, 'updating parameter %s to returned object' % p)\r\n            try :\r\n                #Save additionnal attributes\r\n                attrlist=list(set(dir(self.__dict__[p])).difference(dir(np.ma.array(0))))\r\n                attrvalues=[self.__dict__[p].__dict__[l] for l in attrlist]\r\n                attr=attrStr(attrlist,attrvalues)\r\n                emptyObj.__dict__[p] = func_copy(self.__dict__[p][flag])\r\n                for a in attr.keys(): setattr(emptyObj.__dict__[p], a, attr[a])\r\n            except TypeError:\r\n                self.warning(1,'Could not slice %s - check if this attribute is in self.__init__')\r\n            \r\n        #update dimensions\r\n        N=flag.sum()\r\n        emptyObj._dimensions['time']=N\r\n        emptyObj.count=N\r\n        \r\n#         self.message(4, \"Checking variables consistency\")\r\n#         emptyObj.check_variables()\r\n        \r\n        return emptyObj", "response": "Returns a new object with the same attributes and dimensions as the current object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef copy(self,*args,**kwargs):\r\n        '''\r\n        Returns a copy of the current data object\r\n        \r\n        :param flag: if an argument is provided, this returns an updated copy of current object (ie. equivalent to obj.copy();obj.update(flag)), optimising the memory (\r\n        :keyword True deep: deep copies the object (object data will be copied as well).\r\n        '''\r\n        deep=kwargs.get('deep',True)\r\n        \r\n        if len(args) > 0:\r\n            return self.updated_copy(*args)\r\n        else :\r\n            return copy.deepcopy(self) if deep else copy.copy(self)", "response": "Returns a copy of the current data object\r\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a flag for indexing based on values ( range of fixed values.", "response": "def slice(self,param,range,surf=False):\r\n        '''\r\n        get a flag for indexing based on values (ange of fixed values).\r\n        \r\n        :parameter param: variable name\r\n        :parameter range: numpy array defining the range of the values. If size(range) == 2 :\r\n        \r\n           * flag is computed between min and max values of range\r\n           * flag is computed based on equality to range value.\r\n              \r\n        '''\r\n        if np.size(range) == 2 :\r\n            if not surf : fg = (self.__dict__[param] >= np.min(range)) & (self.__dict__[param] < np.max(range))\r\n            else : fg = (self.__dict__[param+'_surf'] >= np.min(range)) & (self.__dict__[param+'_surf'] < np.max(range))\r\n        elif np.size(range) == 1 :\r\n            if not surf : fg = (self.__dict__[param] == range)\r\n            else : fg = (self.__dict__[param+'_surf'] == range)\r\n        else : self.Error('Range array must have 1 or 2 elements max')\r\n        return fg"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef time_slice(self,timerange,surf=False):\r\n        '''\r\n        slice object given a time range\r\n        \r\n        :parameter timerange: rime range to be used.\r\n        '''\r\n        if isinstance(timerange[0],str): trange = cnes_convert(timerange)[0]\r\n        else: trange=timerange\r\n        return self.slice('date',trange,surf=surf)", "response": "returns a slice object given a time range"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_with_slice(self,flag):\r\n        '''\r\n        update object with a given time slice flag\r\n        \r\n        :parameter (boolean array) flag: a flag for indexing data along the ''time'' dimension \r\n        '''\r\n        \r\n        N=flag.sum()\r\n        \r\n        #Get object attributes to update\r\n        varSize = np.array([np.size(self.__dict__[k]) for k in self.__dict__.keys()])\r\n        par_list=np.array(self.__dict__.keys())[varSize == self._dimensions['time']].tolist()\r\n        \r\n        self._dimensions['time']=N\r\n        self.count=N\r\n        \r\n        for par in par_list :\r\n#             self.__setattr__(par,self.__dict__[par][flag])\r\n#             inVar=copy.deepcopy(self.__dict__[par])\r\n            if isinstance(self.__dict__[par],np.ma.masked_array) :\r\n                tmpVar=self.__dict__.pop(par)\r\n                dumVar=copy.deepcopy(tmpVar)\r\n                tmpVar=tmpVar.compress(flag)\r\n                for a in set(dumVar.__dict__.keys()).difference(tmpVar.__dict__.keys()) :\r\n                    tmpVar.__dict__[a]=dumVar.__dict__[a]\r\n                self.__dict__[par] =  tmpVar\r\n            elif isinstance(self.__dict__[par],np.ndarray):\r\n                self.__dict__[par] = self.__dict__[par].compress(flag)\r\n            elif isinstance(self.__dict__[par],list):\r\n                self.__dict__[par] = (np.array(self.__dict__[par])[flag]).tolist()\r\n            if (hasattr(self.__dict__[par], '_dimensions')) : self.__dict__[par]._dimensions['time']=self._dimensions['time']", "response": "update object with a given time slice"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_file(self,pattern):\r\n        '''\r\n        returns a flag array of the data loaded from a given file pattern\r\n        \r\n        :parameter pattern: pattern to match in the file list. \r\n        '''\r\n        flag=[fnmatch.fnmatch(l,pattern) for l in self.filelist]\r\n        id=self.fid_list.compress(flag)\r\n        flag = self.fileid == id\r\n        return flag", "response": "returns a flag array of the data loaded from a given file pattern"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef time_range(self,flag=None):\r\n        '''\r\n        time range of the current dataset\r\n        \r\n        :keyword flag: use a flag array to know the time range of an indexed slice of the object\r\n        '''\r\n        if self.count==0: return [[None,None],[None,None]]\r\n        \r\n        if flag is None : return cnes_convert([self.date.min(),self.date.max()])\r\n        else : return cnes_convert([self.date.compress(flag).min(),self.date.compress(flag).max()])", "response": "returns a list of time range of the current dataset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_github_markdown_collector(opts):\n    assert hasattr(opts, 'wrapper_regex')\n    atx = MarkdownATXCollectorStrategy(opts)\n    setext = MarkdownSetextCollectorStrategy(opts)\n    code_block_switch = ghswitches.code_block_switch\n\n    strategies = [atx, setext]\n    switches = [code_block_switch]\n\n    return Collector(converter.create_anchor_from_header, strategies,\n                     switches=switches)", "response": "Creates a Collector object used for parsing Markdown files using GitHub style anchor transformation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _setElegant(self, **infiles):\n        ltefile, elefile = infiles['ltefile'], infiles['elefile']\n        self.lattice_file = ltefile\n        self.elegant_file = elefile", "response": "set the elegant tracking parameters for this object"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets elegant output according to the given keywords", "response": "def _getOutputElegant(self, **kws):\n        \"\"\" get results from elegant output according to the given keywords,\n            input parameter format: key = sdds field name tuple, e.g.:\n            available keywords are:\n             - 'file': sdds fielname, file = test.sig\n             - 'data': data array,    data = ('s','Sx')\n             - 'dump': h5file name, if defined, dump data to hdf5 format\n        \"\"\"\n        datascript = \"sddsprintdata.sh\"\n        datapath = self.sim_path\n        trajparam_list = kws['data']\n        sddsfile = os.path.expanduser(os.path.join(self.sim_path, kws['file']))\n        dh = datautils.DataExtracter(sddsfile, *trajparam_list)\n        dh.setDataScript(datascript)\n        dh.setDataPath(datapath)\n        if 'dump' in kws:\n            dh.setH5file(kws['dump'])\n            dh.extractData().dump()\n        data = dh.extractData().getH5Data()\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a zmsg message to the actor.", "response": "def send(self, msg_p):\n        \"\"\"\n        Send a zmsg message to the actor, take ownership of the message\nand destroy when it has been sent.\n        \"\"\"\n        return lib.zactor_send(self._as_parameter_, byref(zmsg_p.from_param(msg_p)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a value from the set of parameters. Returns NULL if the name is not specified.", "response": "def getx(self, name, *args):\n        \"\"\"\n        Return value of one of parameter(s) or NULL is it has no value (or was not specified)\n        \"\"\"\n        return lib.zargs_getx(self._as_parameter_, name, *args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if named parameter is specified on command line.", "response": "def hasx(self, name, *args):\n        \"\"\"\n        Returns true if named parameter(s) was specified on command line\n        \"\"\"\n        return lib.zargs_hasx(self._as_parameter_, name, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode(self, data, size):\n        return return_fresh_string(lib.zarmour_encode(self._as_parameter_, data, size))", "response": "Encode a stream of bytes into an armoured string. Returns the armoured string or NULL if there is insufficient memory available to allocate a new string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decode(self, data):\n        return Zchunk(lib.zarmour_decode(self._as_parameter_, data), True)", "response": "Decode an armoured string into a chunk."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets certificate metadata from formatted string.", "response": "def set_meta(self, name, format, *args):\n        \"\"\"\n        Set certificate metadata from formatted string.\n        \"\"\"\n        return lib.zcert_set_meta(self._as_parameter_, name, format, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\noverriding the default disk loader with a custom disk loader fn.", "response": "def set_loader(self, loader, destructor, state):\n        \"\"\"\n        Override the default disk loader with a custom loader fn.\n        \"\"\"\n        return lib.zcertstore_set_loader(self._as_parameter_, loader, destructor, state)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lookup(self, public_key):\n        return Zcert(lib.zcertstore_lookup(self._as_parameter_, public_key), False)", "response": "Look up certificate by public key returns zcert_t object if found returns NULL otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninserting a certificate into the certificate store.", "response": "def insert(self, cert_p):\n        \"\"\"\n        Insert certificate into certificate store in memory. Note that this\ndoes not save the certificate to disk. To do that, use zcert_save()\ndirectly on the certificate. Takes ownership of zcert_t object.\n        \"\"\"\n        return lib.zcertstore_insert(self._as_parameter_, byref(zcert_p.from_param(cert_p)))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset chunk data from user - supplied data ; truncate if too large. Returns actual size of data.", "response": "def set(self, data, size):\n        \"\"\"\n        Set chunk data from user-supplied data; truncate if too large. Data may\nbe null. Returns actual size of chunk\n        \"\"\"\n        return lib.zchunk_set(self._as_parameter_, data, size)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfilling the chunk with the specified data.", "response": "def fill(self, filler, size):\n        \"\"\"\n        Fill chunk data from user-supplied octet\n        \"\"\"\n        return lib.zchunk_fill(self._as_parameter_, filler, size)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nappend user - supplied data to the end of the chunk. Returns the size of the new chunk.", "response": "def append(self, data, size):\n        \"\"\"\n        Append user-supplied data to chunk, return resulting chunk size. If the\ndata would exceeded the available space, it is truncated. If you want to\ngrow the chunk to accommodate new data, use the zchunk_extend method.\n        \"\"\"\n        return lib.zchunk_append(self._as_parameter_, data, size)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nappend user - supplied data to the chunk and return the resulting size.", "response": "def extend(self, data, size):\n        \"\"\"\n        Append user-supplied data to chunk, return resulting chunk size. If the\ndata would exceeded the available space, the chunk grows in size.\n        \"\"\"\n        return lib.zchunk_extend(self._as_parameter_, data, size)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read(handle, bytes):\n        return Zchunk(lib.zchunk_read(coerce_py_file(handle), bytes), True)", "response": "Read a chunk from an open file descriptor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef put(self, path, value):\n        return lib.zconfig_put(self._as_parameter_, path, value)", "response": "Update the value of a key in the configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites a string to a file in the config file at the specified path.", "response": "def putf(self, path, format, *args):\n        \"\"\"\n        Equivalent to zconfig_put, accepting a format specifier and variable\nargument list, instead of a single string value.\n        \"\"\"\n        return lib.zconfig_putf(self._as_parameter_, path, format, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets value for a config item into a string value.", "response": "def get(self, path, default_value):\n        \"\"\"\n        Get value for config item into a string value; leading slash is optional\nand ignored.\n        \"\"\"\n        return lib.zconfig_get(self._as_parameter_, path, default_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets new value for the current config item.", "response": "def set_value(self, format, *args):\n        \"\"\"\n        Set new value for config item. The new value may be a string, a printf\nformat, or NULL. Note that if string may possibly contain '%', or if it\ncomes from an insecure source, you must use '%s' as the format, followed\nby the string.\n        \"\"\"\n        return lib.zconfig_set_value(self._as_parameter_, format, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind a config item along a path.", "response": "def locate(self, path):\n        \"\"\"\n        Find a config item along a path; leading slash is optional and ignored.\n        \"\"\"\n        return Zconfig(lib.zconfig_locate(self._as_parameter_, path), False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef at_depth(self, level):\n        return Zconfig(lib.zconfig_at_depth(self._as_parameter_, level), False)", "response": "Locate the last config item at a specified depth."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexecute a callback for each config item in the tree ; returns zero if the callback was successful otherwise - 1.", "response": "def execute(self, handler, arg):\n        \"\"\"\n        Execute a callback for each config item in the tree; returns zero if\nsuccessful, else -1.\n        \"\"\"\n        return lib.zconfig_execute(self._as_parameter_, handler, arg)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding comment to config item before saving to disk.", "response": "def set_comment(self, format, *args):\n        \"\"\"\n        Add comment to config item before saving to disk. You can add as many\ncomment lines as you like. If you use a null format, all comments are\ndeleted.\n        \"\"\"\n        return lib.zconfig_set_comment(self._as_parameter_, format, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving the current configuration to a file.", "response": "def savef(self, format, *args):\n        \"\"\"\n        Equivalent to zconfig_save, taking a format string instead of a fixed\nfilename.\n        \"\"\"\n        return lib.zconfig_savef(self._as_parameter_, format, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, buffer, length):\n        return lib.zdigest_update(self._as_parameter_, buffer, length)", "response": "Update the digest of the specified buffer into the specified length."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates differences between two versions of a directory tree.", "response": "def diff(older, newer, alias):\n        \"\"\"\n        Calculate differences between two versions of a directory tree.\nReturns a list of zdir_patch_t patches. Either older or newer may\nbe null, indicating the directory is empty/absent. If alias is set,\ngenerates virtual filename (minus path, plus alias).\n        \"\"\"\n        return Zlist(lib.zdir_diff(older, newer, alias), True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resync(self, alias):\n        return Zlist(lib.zdir_resync(self._as_parameter_, alias), True)", "response": "Return full contents of directory as a zdir_patch list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fprint(self, file, indent):\n        return lib.zdir_fprint(self._as_parameter_, coerce_py_file(file), indent)", "response": "Print contents of directory to open stream"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads a chunk from the file at the specified offset. Returns a Zchunk object if successful.", "response": "def read(self, bytes, offset):\n        \"\"\"\n        Read chunk from file at specified position. If this was the last chunk,\nsets the eof property. Returns a null chunk in case of error.\n        \"\"\"\n        return Zchunk(lib.zfile_read(self._as_parameter_, bytes, offset), True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites a chunk to the file at the specified offset. Returns 0 if OK - 1 if not OK.", "response": "def write(self, chunk, offset):\n        \"\"\"\n        Write chunk to file at specified position\nReturn 0 if OK, else -1\n        \"\"\"\n        return lib.zfile_write(self._as_parameter_, chunk, offset)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a frame to a socket.", "response": "def send(self_p, dest, flags):\n        \"\"\"\n        Send a frame to a socket, destroy frame after sending.\nReturn -1 on error, 0 on success.\n        \"\"\"\n        return lib.zframe_send(byref(zframe_p.from_param(self_p)), dest, flags)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreset the contents of the frame to the specified data.", "response": "def reset(self, data, size):\n        \"\"\"\n        Set new contents for frame\n        \"\"\"\n        return lib.zframe_reset(self._as_parameter_, data, size)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef insert(self, key, item):\n        return lib.zhash_insert(self._as_parameter_, key, item)", "response": "Insert item into hash table with specified key. Returns 0 on success."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rename(self, old_key, new_key):\n        return lib.zhash_rename(self._as_parameter_, old_key, new_key)", "response": "Rename an item from an old key to a new key. Returns 0 if successful otherwise - 1."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets free_fn to be called on the specified item. Returns the item or NULL if there is no such item.", "response": "def freefn(self, key, free_fn):\n        \"\"\"\n        Set a free function for the specified hash table item. When the item is\ndestroyed, the free function, if any, is called on that item.\nUse this when hash items are dynamically allocated, to ensure that\nyou don't have memory leaks. You can pass 'free' or NULL as a free_fn.\nReturns the item, or NULL if there is no such item.\n        \"\"\"\n        return c_void_p(lib.zhash_freefn(self._as_parameter_, key, free_fn))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef comment(self, format, *args):\n        return lib.zhash_comment(self._as_parameter_, format, *args)", "response": "Add a comment to the hash table."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insert(self, key, item):\n        return lib.zhashx_insert(self._as_parameter_, key, item)", "response": "Insert an item into the hash table with specified key. Returns 0 on success."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, key, item):\n        return lib.zhashx_update(self._as_parameter_, key, item)", "response": "Update or insert a container item in hash table with specified key and item. Returns 0 if success - 1 if the key is not present."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrenames an item from an old key to a new key. Returns 0 if successful otherwise - 1.", "response": "def rename(self, old_key, new_key):\n        \"\"\"\n        Reindexes an item from an old key to a new key. If there was no such\nitem, does nothing. Returns 0 if successful, else -1.\n        \"\"\"\n        return lib.zhashx_rename(self._as_parameter_, old_key, new_key)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset free_fn to be called on the specified item. Returns the item or NULL if there is no such item.", "response": "def freefn(self, key, free_fn):\n        \"\"\"\n        Set a free function for the specified hash table item. When the item is\ndestroyed, the free function, if any, is called on that item.\nUse this when hash items are dynamically allocated, to ensure that\nyou don't have memory leaks. You can pass 'free' or NULL as a free_fn.\nReturns the item, or NULL if there is no such item.\n        \"\"\"\n        return c_void_p(lib.zhashx_freefn(self._as_parameter_, key, free_fn))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef comment(self, format, *args):\n        return lib.zhashx_comment(self._as_parameter_, format, *args)", "response": "Add a comment to the current hash table."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npacks the items into longstr.", "response": "def pack_own(self, serializer):\n        \"\"\"\n        Same as pack but uses a user-defined serializer function to convert items\ninto longstr.\n        \"\"\"\n        return Zframe(lib.zhashx_pack_own(self._as_parameter_, serializer), True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef freefn(self, item, fn, at_tail):\n        return c_void_p(lib.zlist_freefn(self._as_parameter_, item, fn, at_tail))", "response": "Set a free function for the specified list item."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninserts an item into the sorted list. Returns a handle to the newly created node.", "response": "def insert(self, item, low_value):\n        \"\"\"\n        Create a new node and insert it into a sorted list. Calls the item\nduplicator, if any, on the item. If low_value is true, starts searching\nfrom the start of the list, otherwise searches from the end. Use the item\ncomparator, if any, to find where to place the new node. Returns a handle\nto the new node, or NULL if memory was exhausted. Resets the cursor to the\nlist head.\n        \"\"\"\n        return c_void_p(lib.zlistx_insert(self._as_parameter_, item, low_value))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reorder(self, handle, low_value):\n        return lib.zlistx_reorder(self._as_parameter_, handle, low_value)", "response": "Move an item specified by handle into position in a sorted list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering a socket reader with the reactor.", "response": "def reader(self, sock, handler, arg):\n        \"\"\"\n        Register socket reader with the reactor. When the reader has messages,\nthe reactor will call the handler, passing the arg. Returns 0 if OK, -1\nif there was an error. If you register the same socket more than once,\neach instance will invoke its corresponding handler.\n        \"\"\"\n        return lib.zloop_reader(self._as_parameter_, sock, handler, arg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nregister low - level libzmq pollitem with the reactor.", "response": "def poller(self, item, handler, arg):\n        \"\"\"\n        Register low-level libzmq pollitem with the reactor. When the pollitem\nis ready, will call the handler, passing the arg. Returns 0 if OK, -1\nif there was an error. If you register the pollitem more than once, each\ninstance will invoke its corresponding handler. A pollitem with\nsocket=NULL and fd=0 means 'poll on FD zero'.\n        \"\"\"\n        return lib.zloop_poller(self._as_parameter_, item, handler, arg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef timer(self, delay, times, handler, arg):\n        return lib.zloop_timer(self._as_parameter_, delay, times, handler, arg)", "response": "Register a timer that expires after some delay and repeats some number of naccesstimes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ticket(self, handler, arg):\n        return c_void_p(lib.zloop_ticket(self._as_parameter_, handler, arg))", "response": "Register a ticket timer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send(self_p, dest):\n        return lib.zmsg_send(byref(zmsg_p.from_param(self_p)), dest)", "response": "Send a message to destination socket and destroy the message after sending\nit successfully."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sendm(self_p, dest):\n        return lib.zmsg_sendm(byref(zmsg_p.from_param(self_p)), dest)", "response": "Send a message to destination socket."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npush a new frame to the front of the message.", "response": "def prepend(self, frame_p):\n        \"\"\"\n        Push frame to the front of the message, i.e. before all other frames.\nMessage takes ownership of frame, will destroy it when message is sent.\nReturns 0 on success, -1 on error. Deprecates zmsg_push, which did not\nnullify the caller's frame reference.\n        \"\"\"\n        return lib.zmsg_prepend(self._as_parameter_, byref(zframe_p.from_param(frame_p)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append(self, frame_p):\n        return lib.zmsg_append(self._as_parameter_, byref(zframe_p.from_param(frame_p)))", "response": "Append a new frame to the end of the message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pushmem(self, data, size):\n        return lib.zmsg_pushmem(self._as_parameter_, data, size)", "response": "Push block of memory to front of message. Returns 0 on success - 1 on error."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addmem(self, data, size):\n        return lib.zmsg_addmem(self._as_parameter_, data, size)", "response": "Add block of memory to the end of the message. Returns 0 on success - 1 on error."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pushstrf(self, format, *args):\n        return lib.zmsg_pushstrf(self._as_parameter_, format, *args)", "response": "Push formatted string as new frame to front of message. Returns 0 on success - 1 on error."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addstrf(self, format, *args):\n        return lib.zmsg_addstrf(self._as_parameter_, format, *args)", "response": "Push formatted string as new frame to end of message. Returns 0 on success - 1 on error."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addmsg(self, msg_p):\n        return lib.zmsg_addmsg(self._as_parameter_, byref(zmsg_p.from_param(msg_p)))", "response": "Push encoded message as a new frame."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_args(self, arguments):\n        return lib.zproc_set_args(self._as_parameter_, byref(zlist_p.from_param(arguments)))", "response": "Setup the command line arguments"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_env(self, arguments):\n        return lib.zproc_set_env(self._as_parameter_, byref(zhash_p.from_param(arguments)))", "response": "Setup the environment variables for the process."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bind(self, format, *args):\n        return lib.zsock_bind(self._as_parameter_, format, *args)", "response": "Bind a socket to a formatted endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nunbinding a socket from a formatted endpoint. Returns 0 if OK - 1 if the endpoint was invalid.", "response": "def unbind(self, format, *args):\n        \"\"\"\n        Unbind a socket from a formatted endpoint.\nReturns 0 if OK, -1 if the endpoint was invalid or the function\nisn't supported.\n        \"\"\"\n        return lib.zsock_unbind(self._as_parameter_, format, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connect(self, format, *args):\n        return lib.zsock_connect(self._as_parameter_, format, *args)", "response": "Connect a socket to a formatted endpoint. Returns 0 if OK - 1 if the endpoint was invalid."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef disconnect(self, format, *args):\n        return lib.zsock_disconnect(self._as_parameter_, format, *args)", "response": "Disconnect a socket from a formatted endpoint. Returns 0 if OK - 1 if the endpoint was invalid."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nattaches a socket to zero or more ZeroMQ endpoints.", "response": "def attach(self, endpoints, serverish):\n        \"\"\"\n        Attach a socket to zero or more endpoints. If endpoints is not null,\nparses as list of ZeroMQ endpoints, separated by commas, and prefixed by\n'@' (to bind the socket) or '>' (to connect the socket). Returns 0 if all\nendpoints were valid, or -1 if there was a syntax error. If the endpoint\ndoes not start with '@' or '>', the serverish argument defines whether\nit is used to bind (serverish = true) or connect (serverish = false).\n        \"\"\"\n        return lib.zsock_attach(self._as_parameter_, endpoints, serverish)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend a message to the socket or actor.", "response": "def send(self, picture, *args):\n        \"\"\"\n        Send a 'picture' message to the socket (or actor). The picture is a\nstring that defines the type of each frame. This makes it easy to send\na complex multiframe message in one call. The picture can contain any\nof these characters, each corresponding to one or two arguments:\n\n    i = int (signed)\n    1 = uint8_t\n    2 = uint16_t\n    4 = uint32_t\n    8 = uint64_t\n    s = char *\n    b = byte *, size_t (2 arguments)\n    c = zchunk_t *\n    f = zframe_t *\n    h = zhashx_t *\n    U = zuuid_t *\n    p = void * (sends the pointer value, only meaningful over inproc)\n    m = zmsg_t * (sends all frames in the zmsg)\n    z = sends zero-sized frame (0 arguments)\n    u = uint (deprecated)\n\nNote that s, b, c, and f are encoded the same way and the choice is\noffered as a convenience to the sender, which may or may not already\nhave data in a zchunk or zframe. Does not change or take ownership of\nany arguments. Returns 0 if successful, -1 if sending failed for any\nreason.\n        \"\"\"\n        return lib.zsock_send(self._as_parameter_, picture, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a picture message to the socket or actor.", "response": "def vsend(self, picture, argptr):\n        \"\"\"\n        Send a 'picture' message to the socket (or actor). This is a va_list\nversion of zsock_send (), so please consult its documentation for the\ndetails.\n        \"\"\"\n        return lib.zsock_vsend(self._as_parameter_, picture, argptr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef recv(self, picture, *args):\n        return lib.zsock_recv(self._as_parameter_, picture, *args)", "response": "Receive a picture message to the socket or actor. Returns 0 if successful - 1 if unsuccessful."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef vrecv(self, picture, argptr):\n        return lib.zsock_vrecv(self._as_parameter_, picture, argptr)", "response": "Receive a message from the socket or actor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend a binary encoded picture message to the socket or actor.", "response": "def bsend(self, picture, *args):\n        \"\"\"\n        Send a binary encoded 'picture' message to the socket (or actor). This\nmethod is similar to zsock_send, except the arguments are encoded in a\nbinary format that is compatible with zproto, and is designed to reduce\nmemory allocations. The pattern argument is a string that defines the\ntype of each argument. Supports these argument types:\n\n pattern    C type                  zproto type:\n    1       uint8_t                 type = \"number\" size = \"1\"\n    2       uint16_t                type = \"number\" size = \"2\"\n    4       uint32_t                type = \"number\" size = \"3\"\n    8       uint64_t                type = \"number\" size = \"4\"\n    s       char *, 0-255 chars     type = \"string\"\n    S       char *, 0-2^32-1 chars  type = \"longstr\"\n    c       zchunk_t *              type = \"chunk\"\n    f       zframe_t *              type = \"frame\"\n    u       zuuid_t *               type = \"uuid\"\n    m       zmsg_t *                type = \"msg\"\n    p       void *, sends pointer value, only over inproc\n\nDoes not change or take ownership of any arguments. Returns 0 if\nsuccessful, -1 if sending failed for any reason.\n        \"\"\"\n        return lib.zsock_bsend(self._as_parameter_, picture, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef brecv(self, picture, *args):\n        return lib.zsock_brecv(self._as_parameter_, picture, *args)", "response": "Receive a binary encoded picture message from the socket or actor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreceiving a series of strings from a multipart data stream.", "response": "def recvx(source, string_p, *args):\n        \"\"\"\n        Receive a series of strings (until NULL) from multipart data.\nEach string is allocated and filled with string data; if there\nare not enough frames, unallocated strings are set to NULL.\nReturns -1 if the message could not be read, else returns the\nnumber of strings filled, zero or more. Free each returned string\nusing zstr_free(). If not enough strings are provided, remaining\nmultipart frames in the message are dropped.\n        \"\"\"\n        return lib.zstr_recvx(source, byref(c_char_p.from_param(string_p)), *args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a new ZMQ socket.", "response": "def socket(type, filename, line_nbr):\n        \"\"\"\n        Get a new ZMQ socket, automagically creating a ZMQ context if this is\nthe first time. Caller is responsible for destroying the ZMQ socket\nbefore process exits, to avoid a ZMQ deadlock. Note: you should not use\nthis method in CZMQ apps, use zsock_new() instead.\n*** This is for CZMQ internal use only and may change arbitrarily ***\n        \"\"\"\n        return c_void_p(lib.zsys_socket(type, filename, line_nbr))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_pipe(backend_p):\n        return Zsock(lib.zsys_create_pipe(byref(zsock_p.from_param(backend_p))), False)", "response": "Create a pipe that connects to the backend socket."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef version(major, minor, patch):\n        return lib.zsys_version(byref(c_int.from_param(major)), byref(c_int.from_param(minor)), byref(c_int.from_param(patch)))", "response": "Returns the CZMQ version for run - time API detection ; returns version\nnumber into provided fields providing reference isn t null in each case."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef udp_send(udpsock, frame, address, addrlen):\n        return lib.zsys_udp_send(udpsock, frame, address, addrlen)", "response": "Send a frame to UDP socket."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef udp_recv(udpsock, peername, peerlen):\n        return Zframe(lib.zsys_udp_recv(udpsock, peername, peerlen), False)", "response": "Receive zframe from UDP socket and set address of peer that sent it\n"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a timer to the set. Returns 0 if OK - 1 if failure.", "response": "def add(self, interval, handler, arg):\n        \"\"\"\n        Add a timer to the set. Returns timer id if OK, -1 on failure.\n        \"\"\"\n        return lib.ztimerset_add(self._as_parameter_, interval, handler, arg)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_interval(self, timer_id, interval):\n        return lib.ztimerset_set_interval(self._as_parameter_, timer_id, interval)", "response": "Set timer interval. Returns 0 if OK - 1 on failure."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef insert_route(self, path, data, destroy_data_fn):\n        return lib.ztrie_insert_route(self._as_parameter_, path, data, destroy_data_fn)", "response": "Inserts a new route into the tree and attaches the data. Returns 0 if the route already exists."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ae(actual, predicted):\n    return np.abs(np.array(actual)-np.array(predicted))", "response": "Computes the absolute error between two numbers and a predicted value."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the classification error between two lists of true classes and predicted classes.", "response": "def ce(actual, predicted):\n    \"\"\"\n    Computes the classification error.\n\n    This function computes the classification error between two lists\n\n    Parameters\n    ----------\n    actual : list\n             A list of the true classes\n    predicted : list\n                A list of the predicted classes\n\n    Returns\n    -------\n    score : double\n            The classification error between actual and predicted\n\n    \"\"\"\n    return (sum([1.0 for x,y in zip(actual,predicted) if x != y]) /\n            len(actual))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute the squared error between two numbers and a single list of doubles.", "response": "def se(actual, predicted):\n    \"\"\"\n    Computes the squared error.\n\n    This function computes the squared error between two numbers,\n    or for element between a pair of lists or numpy arrays.\n\n    Parameters\n    ----------\n    actual : int, float, list of numbers, numpy array\n             The ground truth value\n    predicted : same type as actual\n                The predicted value\n\n    Returns\n    -------\n    score : double or list of doubles\n            The squared error between actual and predicted\n\n    \"\"\"\n    return np.power(np.array(actual)-np.array(predicted), 2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sle(actual, predicted):\n    return (np.power(np.log(np.array(actual)+1) - \n            np.log(np.array(predicted)+1), 2))", "response": "Computes the squared log error between two numbers and predicted."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ll(actual, predicted):\n    actual = np.array(actual)\n    predicted = np.array(predicted)\n    err = np.seterr(all='ignore')\n    score = -(actual*np.log(predicted)+(1-actual)*np.log(1-predicted))\n    np.seterr(divide=err['divide'], over=err['over'],\n              under=err['under'], invalid=err['invalid'])\n    if type(score)==np.ndarray:\n        score[np.isnan(score)] = 0\n    else:\n        if np.isnan(score):\n            score = 0\n    return score", "response": "Computes the log likelihood between two numbers or numpy arrays."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rmspe(actual, predicted):\n    \n    actual = np.array(actual)\n    predicted = np.array(predicted)\n    zeros = actual == 0\n    actual = actual[~zeros]\n    predicted = predicted[~zeros]\n    return np.sqrt(np.sum(np.power((actual - predicted) / actual, 2)) / len(actual))", "response": "Computes the root mean square percentage error between two lists\n    actual and predicted."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats the mean score + - std error for params", "response": "def display_scores(params, scores, append_star=False):\n    \"\"\"Format the mean score +/- std error for params\"\"\"\n    params = \", \".join(\"{0}={1}\".format(k, v)\n                      for k, v in params.items())\n    line = \"{0}:\\t\\t{1:.3f} (+/-{2:.3f})\".format(\n        params, np.mean(scores), sem(scores))\n    if append_star:\n        line += \" *\"\n    return line"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef display_grid_scores(grid_scores, top=None):\n    grid_scores = sorted(grid_scores, key=lambda x: x[1], reverse=True)\n    if top is not None:\n        grid_scores = grid_scores[:top]\n        \n    # Compute a threshold for staring models with overlapping stderr:\n    _, best_mean, best_scores = grid_scores[0]\n    threshold = best_mean - 2 * sem(best_scores)\n    \n    for params, mean_score, scores in grid_scores:\n        append_star = mean_score + 2 * sem(scores) > threshold\n        print(display_scores(params, scores, append_star=append_star))", "response": "Helper function to format a report on a grid of scores"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nguess the PHRED score format from the gold standard.", "response": "def guess_phred_format(self):\n        \"\"\"Guess the PHRED score format. The gold standard is the first one, aka\n        the one called \"Sanger\". Sanger encoding is exactly equivalent to\n        Illumina-1.8 encoding. In other words, they finally gave up with their bullshit.\"\"\"\n        # Possibilities #\n        self.intervals = {\n            'Sanger':       (33,  74),         # <- This one is the gold standard\n            'Solexa':       (59, 105),\n            'Illumina-1.3': (64, 105),         # <- These were abandoned after they wised up.\n            'Illumina-1.5': (67, 105),         # <- These were abandoned after they wised up.\n        }\n        # Initialize variables #\n        glob_min  = 9999\n        glob_max  = 0\n        take_next = False\n        # Stop after #\n        max_sequences_to_consider = 2000000\n        # Error message #\n        message = \"Multiple PHRED encodings possible for '%s'.\\n\"\n        # Loop #\n        self.open()\n        for i, line in enumerate(self.handle):\n            # Are we on the PHRED line? #\n            if not take_next:\n                take_next = line.startswith('+')\n                continue\n            # Now we are on the PHRED line! #\n            take_next = False\n            current_min, current_max = self.get_qual_range(line.rstrip('\\n'))\n            if current_min < glob_min or current_max > glob_max:\n                glob_min = min(current_min, glob_min)\n                glob_max = max(current_max, glob_max)\n                valid_encodings = [e for e, r in self.intervals.items() if glob_min >= r[0] and glob_max <= r[1]]\n                if len(valid_encodings) == 0:\n                    message = \"Illegal PHRED encoding for '%s'.\\n\"\n                    break\n                if len(valid_encodings) == 1:\n                    return valid_encodings[0]\n            # Stop condition #\n            if i >= max_sequences_to_consider: break\n        # It didn't work #\n        message += \"Maximum detected value is: %s.\\n\"\n        message += \"Minimum detected value is: %s.\\n\"\n        message += \"Possibilities are: %s.\"\n        message  = message % (self, glob_max, glob_min, ' or '.join(valid_encodings))\n        raise Exception(message)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the qual range of the string.", "response": "def get_qual_range(self, phred_string):\n        \"\"\"\n        >>> self.get_qual_range(\"DLXYXXRXWYYTPMLUUQWTXTRSXSWMDMTRNDNSMJFJFFRMV\")\n        (68, 89)\n        \"\"\"\n        values = [ord(char) for char in phred_string]\n        return min(values), max(values)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef phred_13_to_18_sed(self, new_path=None, in_place=True):\n        # String #\n        sed_command = r\"\"\"4~4y/@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghi/!\"#$%&'\\''()*+,-.\\/0123456789:;<=>?@ABCDEFGHIJ/\"\"\"\n        # Faster with bash utilities #\n        if in_place is True:\n            sh.sed('-i', sed_command, self.path)\n            return self\n        # New file #\n        if new_path is None: new_fastq = self.__class__(new_temp_path())\n        else:                new_fastq = self.__class__(new_path)\n        sh.sed(sed_command + \" \" + new_fastq, self.path)\n        return new_fastq", "response": "Convert from Phred - 13 format to Illumina - 1. 8 format via sed."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave given key into settings file.", "response": "def set_key(self, section, key, value):\n        \"\"\"\n        Stores given key in settings file.\n\n        :param section: Current section to save the key into.\n        :type section: unicode\n        :param key: Current key to save.\n        :type key: unicode\n        :param value: Current key value to save.\n        :type value: object\n        \"\"\"\n\n        LOGGER.debug(\"> Saving '{0}' in '{1}' section with value: '{2}' in settings file.\".format(\n            key, section, foundations.strings.to_string(value)))\n\n        self.__settings.beginGroup(section)\n        self.__settings.setValue(key, QVariant(value))\n        self.__settings.endGroup()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_key(self, section, key):\n\n        LOGGER.debug(\"> Retrieving '{0}' in '{1}' section.\".format(key, section))\n\n        self.__settings.beginGroup(section)\n        value = self.__settings.value(key)\n        LOGGER.debug(\"> Key value: '{0}'.\".format(value))\n        self.__settings.endGroup()\n\n        return value", "response": "Retrieves the value of a key from settings file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef key_exists(self, section, key):\n\n        LOGGER.debug(\"> Checking '{0}' key existence in '{1}' section.\".format(key, section))\n\n        self.__settings.beginGroup(section)\n        exists = self.__settings.contains(key)\n        self.__settings.endGroup()\n        return exists", "response": "Checks if given key exists in given section."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the default settings.", "response": "def __get_default_settings(self):\n        \"\"\"\n        Gets the default settings.\n        \"\"\"\n\n        LOGGER.debug(\"> Accessing '{0}' default settings file!\".format(UiConstants.settings_file))\n        self.__default_settings = QSettings(\n            umbra.ui.common.get_resource_path(UiConstants.settings_file), QSettings.IniFormat)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __get_default_layouts_settings(self):\n\n        LOGGER.debug(\"> Accessing '{0}' default layouts settings file!\".format(UiConstants.layouts_file))\n        self.__default_layouts_settings = QSettings(umbra.ui.common.get_resource_path(UiConstants.layouts_file),\n                                                    QSettings.IniFormat)", "response": "Gets the default layouts settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_default_preferences(self):\n\n        LOGGER.debug(\"> Initializing default settings!\")\n\n        for key in self.__default_settings.allKeys():\n            self.__settings.setValue(key, self.__default_settings.value(key))\n\n        self.set_default_layouts()\n        return True", "response": "Sets the default preferences for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the default layouts in preferences file.", "response": "def set_default_layouts(self, ignored_layouts=None):\n        \"\"\"\n        Sets the default layouts in the preferences file.\n\n        :param ignored_layouts: Ignored layouts.\n        :type ignored_layouts: tuple or list\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        for key in self.__default_layouts_settings.allKeys():\n            if ignored_layouts:\n                if tuple((layout for layout in ignored_layouts if layout in key)):\n                    continue\n            self.__settings.setValue(key, self.__default_layouts_settings.value(key))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nblock method that runs the server.", "response": "def run(self):\n        \"\"\"\n        Blocking method that run the server.\n        \"\"\"\n        if self.tasks:\n            logger.info('Registered tasks: %s' % ', '.join(self.tasks))\n        else:\n            logger.info('No tasks registered')\n        logger.info('Listening on %s ...' % self.bind)\n        self.socket.bind(self.bind)\n\n        self.running = True\n        self.pre_run()\n\n        while self.running:\n            msg = self.socket.recv_pyobj()\n\n            action = msg.get('action')\n            if action == 'run_task':\n                if msg.get('name') not in self.tasks:\n                    print(msg.get('name'))\n                    print(self.tasks)\n                    response = {\n                        'success': False, 'exception': TaskNotFound(msg.get('name'))}\n                    self.socket.send_pyobj(response)\n                else:\n                    task = Task(str(uuid.uuid4()), msg.get('name'), [], {})\n\n                    if msg.get('args'):\n                        task.args = msg.get('args', [])\n                    if msg.get('kwargs'):\n                        task.kwargs = msg.get('kwargs', {})\n\n                    self.task_result_backend.add_task(task)\n\n                    self.queue.put(task.id)\n                    self.socket.send_pyobj({'success': True, 'task': task})\n            elif action == 'get_result':\n                task_id = msg.get('id')\n                task = self.task_result_backend.get_task(task_id)\n                if task:\n                    response = {'success': True, 'task': task}\n                else:\n                    response = {\n                        'success': False,\n                        'id': task_id,\n                        'exception': TaskNotFound(task_id)}\n                self.socket.send_pyobj(response)\n            elif action == 'wait':\n                task_id = msg.get('id')\n                task = self.task_result_backend.get_task(task_id)\n                if task:\n                    while not task.terminated:\n                        task = self.task_result_backend.get_task(task_id)\n                        time.sleep(1)\n                    response = {'success': True, 'task': task}\n                else:\n                    response = {\n                        'success': False,\n                        'id': task_id,\n                        'exception': TaskNotFound(task_id)}\n                self.socket.send_pyobj(response)\n            else:\n                response = {'success': False, 'exception': MessageMalformed()}\n                self.socket.send_pyobj(response)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stop(self):\n        try:\n            self.running = False\n            logger.info('Waiting tasks to finish...')\n            self.queue.join()\n            self.socket.close()\n            logger.info('Exiting (C-Ctrl again to force it)...')\n        except KeyboardInterrupt:\n            logger.info('Forced.')\n            sys.exit(1)", "response": "Stop server and all its threads."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmounts an EBS volume", "response": "def mount_volume(volume, device='/dev/xvdf', mountpoint='/mnt/data', fstype='ext4'):\n    '''\n    Mount an EBS volume\n\n    Args:\n        volume (str): EBS volume ID\n        device (str): default /dev/xvdf\n        mountpoint (str): default /mnt/data\n        fstype (str): default ext4\n    '''\n    _ec2().attach_volume(volume, _host_node()['id'], device)\n    time.sleep(1)\n    sudo('mkdir -p \"%s\"' % mountpoint)\n    sudo('mount -t \"%s\" \"%s\" \"%s\"' % (fstype, device, mountpoint))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the ids of existing input documents that match a query", "response": "def get_input_ids(query, limit=None):\n    \"\"\"Get the ids of existing input documents that match a query\"\"\"\n    docs = scan(_es, index=esconfig.ES_INPUT_INDEX,\n                doc_type=esconfig.ES_INPUT_DOCTYPE,\n                query=query, size=(limit or 1000), fields=\"\")\n    for i, a in enumerate(docs):\n        if limit and i >= limit:\n            return\n        yield a['_id']"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the ids of documents that have been parsed with this doc_type.", "response": "def get_cached_document_ids(ids, doc_type):\n    \"\"\"Get the ids of documents that have been parsed with this doc_type\"\"\"\n    for batch in _split_list(ids):\n        for id in _get_cached_document_ids(batch, doc_type):\n            yield id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _replace_series_name(seriesname, replacements):\n    for pat, replacement in six.iteritems(replacements):\n        if re.match(pat, seriesname, re.IGNORECASE | re.UNICODE):\n            return replacement\n    return seriesname", "response": "Performs replacement of series name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncleans up series name.", "response": "def clean_series_name(seriesname):\n    \"\"\"Cleans up series name.\n\n    By removing any . and _ characters, along with any trailing hyphens.\n\n    Is basically equivalent to replacing all _ and . with a\n    space, but handles decimal numbers in string, for example:\n\n    >>> _clean_series_name(\"an.example.1.0.test\")\n    'an example 1.0 test'\n    >>> _clean_series_name(\"an_example_1.0_test\")\n    'an example 1.0 test'\n    \"\"\"\n    if not seriesname:\n        return seriesname\n    # TODO(xxxx): Could this be made to clean \"Hawaii.Five-0.2010\" into\n    # \"Hawaii Five-0 2010\"?\n    seriesname = re.sub(r'(\\D)[.](\\D)', '\\\\1 \\\\2', seriesname)\n    seriesname = re.sub(r'(\\D)[.]', '\\\\1 ', seriesname)\n    seriesname = re.sub(r'[.](\\D)', ' \\\\1', seriesname)\n    seriesname = seriesname.replace('_', ' ')\n    seriesname = re.sub('-$', '', seriesname)\n    return _replace_series_name(seriesname.strip(),\n                                cfg.CONF.input_series_replacements)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\napply custom replacements to a file name.", "response": "def apply_replacements(cfile, replacements):\n    \"\"\"Applies custom replacements.\n\n    mapping(dict), where each dict contains:\n        'match' - filename match pattern to check against, the filename\n        replacement is applied.\n\n        'replacement' - string used to replace the matched part of the filename\n\n        'is_regex' - if True, the pattern is treated as a\n        regex. If False, simple substring check is used (if\n        'match' in filename). Default is False\n\n        'with_extension' - if True, the file extension is not included in the\n        pattern matching. Default is False\n\n    Example replacements::\n\n        {'match': ':',\n         'replacement': '-',\n         'is_regex': False,\n         'with_extension': False,\n         }\n\n    :param str cfile: name of a file\n    :param list replacements: mapping(dict) filename pattern matching\n                              directives\n    :returns: formatted filename\n    :rtype: str\n    \"\"\"\n    if not replacements:\n        return cfile\n\n    for rep in replacements:\n        if not rep.get('with_extension', False):\n            # By default, preserve extension\n            cfile, cext = os.path.splitext(cfile)\n        else:\n            cfile = cfile\n            cext = ''\n\n        if 'is_regex' in rep and rep['is_regex']:\n            cfile = re.sub(rep['match'], rep['replacement'], cfile)\n        else:\n            cfile = cfile.replace(rep['match'], rep['replacement'])\n\n        # Rejoin extension (cext might be empty-string)\n        cfile = cfile + cext\n\n    return cfile"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nformat episode number into string using configured values.", "response": "def _format_episode_numbers(episodenumbers):\n    \"\"\"Format episode number(s) into string, using configured values.\"\"\"\n    if len(episodenumbers) == 1:\n        epno = cfg.CONF.episode_single % episodenumbers[0]\n    else:\n        epno = cfg.CONF.episode_separator.join(\n            cfg.CONF.episode_single % x for x in episodenumbers)\n\n    return epno"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _format_episode_name(names):\n    if len(names) == 1:\n        return names[0]\n\n    found_name = ''\n    epname = None\n    epno = None\n    numbers = []\n    for cname in names:\n        match = re.match(r'(.*) \\(([0-9]+)\\)$', cname)\n        if found_name != '' and (not match or epname != found_name):\n            # An episode didn't match\n            return cfg.CONF.multiep_join_name_with.join(names)\n\n        if match:\n            epname, epno = match.group(1), match.group(2)\n        else:  # assume that this is the first episode, without number\n            epname = cname\n            epno = 1\n        found_name = epname\n        numbers.append(int(epno))\n\n    return cfg.CONF.multiep_format % {'epname': found_name,\n                                      'episodemin': min(numbers),\n                                      'episodemax': max(numbers)}", "response": "Takes a list of episode names formats them into a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _make_valid_filename(value):\n\n    sysname = platform.system()\n\n    # If the filename starts with a . prepend it with an underscore, so it\n    # doesn't become hidden.\n    # This is done before calling splitext to handle filename of \".\", as\n    # splitext acts differently in python 2.5 and 2.6 - 2.5 returns ('', '.')\n    # and 2.6 returns ('.', ''), so rather than special case '.', this\n    # special-cases all files starting with \".\" equally (since dotfiles have\n    # no extension)\n    if value.startswith('.'):\n        value = cfg.CONF.replacement_character + value\n\n    # Treat extension seperatly\n    value, extension = os.path.splitext(value)\n\n    # Remove any null bytes\n    value = value.replace('\\0', '')\n\n    # Blacklist of characters\n    if sysname == 'Darwin':\n        # : is technically allowed, but Finder will treat it as / and will\n        # generally cause weird behaviour, so treat it as invalid.\n        blacklist = r'/:'\n    elif sysname in ['Linux', 'FreeBSD']:\n        blacklist = r'/'\n    else:\n        # platform.system docs say it could also return \"Windows\" or \"Java\".\n        # Failsafe and use Windows sanitisation for Java, as it could be any\n        # operating system.\n        blacklist = r'\\/:*?\\\"<>|'\n\n    # Append custom blacklisted characters\n    blacklist += cfg.CONF.filename_character_blacklist\n\n    # Replace every blacklisted character with a underscore\n    value = re.sub('[%s]' % re.escape(blacklist),\n                   cfg.CONF.replacement_character, value)\n\n    # Remove any trailing whitespace\n    value = value.strip()\n\n    # There are a bunch of filenames that are not allowed on Windows.\n    # As with character blacklist, treat non Darwin/Linux platforms as Windows\n    if sysname not in ['Darwin', 'Linux']:\n        invalid_filenames = ['CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2',\n                             'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8',\n                             'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5',\n                             'LPT6', 'LPT7', 'LPT8', 'LPT9']\n        if value in invalid_filenames:\n            value = cfg.CONF.replacement_character + value\n\n    # Replace accented characters with ASCII equivalent\n    value = encodeutils.safe_encode(value, encoding='ascii', errors='ignore')\n    extension = encodeutils.safe_encode(extension, encoding='ascii',\n                                        errors='ignore')\n\n    # Truncate filenames to valid/sane length.\n    # NTFS is limited to 255 characters, HFS+ and EXT3 don't seem to have\n    # limits, FAT32 is 254. I doubt anyone will take issue with losing that\n    # one possible character, and files over 254 are pointlessly unweidly\n    max_len = 254\n\n    if len(value + extension) > max_len:\n        if len(extension) > len(value):\n            # Truncate extension instead of filename, no extension should be\n            # this long..\n            new_length = max_len - len(value)\n            extension = extension[:new_length]\n        else:\n            # File name is longer than extension, truncate filename.\n            new_length = max_len - len(extension)\n            value = value[:new_length]\n\n    return encodeutils.safe_decode(value + extension, incoming='ascii')", "response": "Takes a string and makes it into a valid filename."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a filename based on the metadata of the TV series and episode numbers and the media file extension.", "response": "def format_filename(series_name, season_number,\n                    episode_numbers, episode_names,\n                    extension):\n    \"\"\"Generates a filename based on metadata using configured format.\n\n    :param str series_name: name of TV series\n    :param int season_number: the numeric season of series\n    :param list(int) episode_numbers: the numeric episode of the series\n    :param list(str) episode_names: episode title of the series\n    :param str extension: media file extension\n    :returns: formatted filename using input values and configured format\n    :rtype: str\n    \"\"\"\n\n    epdata = {\n        'seriesname': tc.titlecase(_replace_series_name(\n            series_name, cfg.CONF.output_series_replacements) or ''),\n        'seasonnumber': season_number,\n        'episode': _format_episode_numbers(episode_numbers),\n        'episodename': tc.titlecase(_format_episode_name(episode_names)),\n        'ext': extension,\n    }\n\n    value = apply_replacements(\n        cfg.CONF.filename_format_ep % epdata,\n        cfg.CONF.output_filename_replacements)\n\n    return _make_valid_filename(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format_dirname(series_name, season_number):\n\n    data = {\n        'seriesname': _replace_series_name(\n            series_name, cfg.CONF.output_series_replacements),\n        'seasonnumber': season_number,\n    }\n\n    return tc.titlecase(cfg.CONF.directory_name_format % data)", "response": "Generates a directory name based on the metadata of the specified TV."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_library(series_path):\n\n    for location in cfg.CONF.libraries:\n        if os.path.isdir(os.path.join(location, series_path)):\n            return location\n        # already tried the full path; now walk down the path\n        segments = series_path.split(os.sep)[:-1]\n        while segments:\n            seg_path = os.path.join(*segments)\n            # if the directory exists then we found our location\n            if os.path.isdir(os.path.join(location, seg_path)):\n                return location\n            # remove the last element and try again\n            segments = segments[:-1]\n\n    return cfg.CONF.default_library", "response": "Search for the location of a series within the library."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the length in m of the vehicles of this type.", "response": "def setLength(self, typeID, length):\n        \"\"\"setLength(string, double) -> None\n\n        Sets the length in m of the vehicles of this type.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_LENGTH, typeID, length)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setMaxSpeed(self, typeID, speed):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_MAXSPEED, typeID, speed)", "response": "Sets the maximum speed in m/s of the vehicles of this type."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the class of the vehicle of the specified type.", "response": "def setVehicleClass(self, typeID, clazz):\n        \"\"\"setVehicleClass(string, string) -> None\n\n        Sets the class of vehicles of this type.\n        \"\"\"\n        self._connection._sendStringCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_VEHICLECLASS, typeID, clazz)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the current speed factor for the type.", "response": "def setSpeedFactor(self, typeID, factor):\n        \"\"\"setSpeedFactor(string, double) -> None\n\n        .\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_SPEED_FACTOR, typeID, factor)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the maximum speed deviation of the vehicles of this type.", "response": "def setSpeedDeviation(self, typeID, deviation):\n        \"\"\"setSpeedDeviation(string, double) -> None\n\n        Sets the maximum speed deviation of vehicles of this type.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_SPEED_DEVIATION, typeID, deviation)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setEmissionClass(self, typeID, clazz):\n        self._connection._sendStringCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_EMISSIONCLASS, typeID, clazz)", "response": "Sets the emission class of the vehicles of this type."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setWidth(self, typeID, width):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_WIDTH, typeID, width)", "response": "Sets the width of the vehicles of this type."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the height of the type identified by typeID to height.", "response": "def setHeight(self, typeID, height):\n        \"\"\"setHeight(string, double) -> None\n\n        Sets the height in m of vehicles of this type.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_HEIGHT, typeID, height)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setMinGap(self, typeID, minGap):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_MINGAP, typeID, minGap)", "response": "Sets the minimum gap for the vehicle of a specific type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the minimum lateral gap at 50km / h of this type.", "response": "def setMinGapLat(self, typeID, minGapLat):\n        \"\"\"setMinGapLat(string, double) -> None\n\n        Sets the minimum lateral gap at 50km/h of this type.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_MINGAP_LAT, typeID, minGapLat)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the maximum lateral speed of the type.", "response": "def setMaxSpeedLat(self, typeID, speed):\n        \"\"\"setMaxSpeedLat(string, double) -> None\n\n        Sets the maximum lateral speed of this type.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_MAXSPEED_LAT, typeID, speed)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setLateralAlignment(self, typeID, latAlignment):\n        self._connection._sendStringCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_LATALIGNMENT, typeID, latAlignment)", "response": "Sets the preferred lateral alignment of this type."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the shape class of the vehicles of this type.", "response": "def setShapeClass(self, typeID, clazz):\n        \"\"\"setShapeClass(string, string) -> None\n\n        Sets the shape class of vehicles of this type.\n        \"\"\"\n        self._connection._sendStringCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_SHAPECLASS, typeID, clazz)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setAccel(self, typeID, accel):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_ACCEL, typeID, accel)", "response": "Sets the acceleration value for the type identified by typeID."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the deceleration in m/s^2 of the vehicles of this type.", "response": "def setDecel(self, typeID, decel):\n        \"\"\"setDecel(string, double) -> None\n\n        Sets the maximal comfortable deceleration in m/s^2 of vehicles of this type.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_DECEL, typeID, decel)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setEmergencyDecel(self, typeID, decel):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_EMERGENCY_DECEL, typeID, decel)", "response": "Sets the maximal physically possible deceleration in m/s^2 of vehicles of this type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the action step length for the given typeID.", "response": "def setActionStepLength(self, typeID, actionStepLength, resetActionOffset=True):\n        \"\"\"setActionStepLength(string, double, bool) -> None\n\n        Sets the action step length for vehicles of this type. If resetActionOffset == True (default), the \n        next action point is scheduled immediately for all vehicles of the type. \n        If resetActionOffset == False, the interval between the last and the next action point is \n        updated to match the given value for all vehicles of the type, or if the latter is smaller \n        than the time since the last action point, the next action follows immediately.\n        \"\"\"\n        if actionStepLength < 0:\n            raise exceptions.TraCIException(\"Invalid value for actionStepLength. Given value must be non-negative.\")\n        # Use negative value to indicate resetActionOffset == False\n        if not resetActionOffset:\n            actionStepLength*=-1\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_ACTIONSTEPLENGTH, typeID, actionStepLength)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the apparent deceleration in m/s^2 of vehicles of this type.", "response": "def setApparentDecel(self, typeID, decel):\n        \"\"\"setDecel(string, double) -> None\n\n        Sets the apparent deceleration in m/s^2 of vehicles of this type.\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_APPARENT_DECEL, typeID, decel)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the imperfection value for the specified typeID.", "response": "def setImperfection(self, typeID, imperfection):\n        \"\"\"setImperfection(string, double) -> None\n\n        .\n        \"\"\"\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_IMPERFECTION, typeID, imperfection)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setTau(self, typeID, tau):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_TAU, typeID, tau)", "response": "Sets the driver s tau - parameter for the vehicles of the specified type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the color of the current type.", "response": "def setColor(self, typeID, color):\n        \"\"\"setColor(string, (integer, integer, integer, integer)) -> None\n\n        Sets the color of this type.\n        \"\"\"\n        self._connection._beginMessage(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.VAR_COLOR, typeID, 1 + 1 + 1 + 1 + 1)\n        self._connection._string += struct.pack(\"!BBBBB\", tc.TYPE_COLOR, int(\n            color[0]), int(color[1]), int(color[2]), int(color[3]))\n        self._connection._sendExact()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef copy(self, origTypeID, newTypeID):\n        self._connection._sendStringCmd(\n            tc.CMD_SET_VEHICLETYPE_VARIABLE, tc.COPY, origTypeID, newTypeID)", "response": "Copies the specified vType from origTypeID to newTypeID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nroll a die of sides num times sums them adds add", "response": "def roll(cls, num, sides, add):\n        \"\"\"Rolls a die of sides sides, num times, sums them, and adds add\"\"\"\n        rolls = []\n        for i in range(num):\n            rolls.append(random.randint(1, sides))\n        rolls.append(add)\n        return rolls"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a hook to a pangler.", "response": "def subscribe(self, _func=None, needs=(), returns=(), modifies=(),\n            **conditions):\n        \"\"\"Add a hook to a pangler.\n\n        This method can either be used as a decorator for a function or method,\n        or standalone on a callable.\n\n         * `needs` is an iterable of parameters that this hook operates on.\n         * `returns` is an iterable of parameters that this hook will modify\n           and then pass back to the pangler.\n         * `modifies` is a convenient way to specify that this hook both needs\n           and returns a parameter.\n         * The rest of the keyword arguments are parameter predicates.\n\n        \"\"\"\n\n        modifies = set(modifies)\n        parameters = set(needs) | modifies\n        needs = parameters | set(conditions)\n        if not needs:\n            raise ValueError(\"tried to hook nothing\")\n        returns = set(returns) | modifies\n        def deco(func):\n            self.hooks.append(_Hook(\n                func, needs, parameters, returns, conditions))\n            return func\n\n        # If we were passed a function as a positional parameter, then we\n        # shouldn't behave like a decorator.\n        if _func is not None:\n            deco(_func)\n        else:\n            return deco"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntriggers an event. Event parameters are passed as keyword arguments. Passing an `event` argument isn't required, but generally recommended.", "response": "def trigger(self, **event):\n        \"\"\"Trigger an event.\n\n        Event parameters are passed as keyword arguments. Passing an `event`\n        argument isn't required, but generally recommended.\n\n        \"\"\"\n\n        if not event:\n            raise ValueError(\"tried to trigger nothing\")\n        for hook in self.hooks:\n            if hook.matches(event):\n                hook.execute(self, event)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clone(self):\n\n        p = type(self)(self.id)\n        p.hooks = list(self.hooks)\n        p.instance = self.instance\n        return p", "response": "Duplicate a Pangler.\n\n        Returns a copy of this Pangler, with all the same state. Both will be\n        bound to the same instance and have the same `id`, but new hooks will\n        not be shared."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncombining this Pangler with the given set of Panglers.", "response": "def combine(self, *others):\n        \"\"\"Combine other Panglers into this Pangler.\n\n        Returns a copy of this Pangler with all of the hooks from the provided\n        Panglers added to it as well. The new Pangler will be bound to the same\n        instance and have the same `id`, but new hooks will not be shared with\n        this Pangler or any provided Panglers.\n\n        \"\"\"\n\n        p = self.clone()\n        for other in others:\n            p.hooks.extend(other.hooks)\n        return p"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bind(self, instance):\n\n        p = self.clone()\n        p.instance = weakref.ref(instance)\n        return p", "response": "Bind an instance to this Pangler."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbinds an instance to this Pangler using the bound Pangler store.", "response": "def stored_bind(self, instance):\n        \"\"\"Bind an instance to this Pangler, using the bound Pangler store.\n\n        This method functions identically to `bind`, except that it might\n        return a Pangler which was previously bound to the provided instance.\n\n        \"\"\"\n\n        if self.id is None:\n            return self.bind(instance)\n\n        store = self._bound_pangler_store.setdefault(instance, {})\n        p = store.get(self.id)\n        if p is None:\n            p = store[self.id] = self.bind(instance)\n        return p"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive an instance and a class aggregate together some panglers.", "response": "def aggregate(self, instance, owner):\n        \"\"\"Given an instance and a class, aggregate together some panglers.\n\n        Walks every class in the MRO of the `owner` class, including `owner`,\n        collecting panglers exposed as `self.attr_name`. The resulting pangler\n        will be bound to the provided `instance`.\n\n        \"\"\"\n\n        try:\n            p = self.pangler_factory.from_store(instance, self.id)\n        except KeyError:\n            pass\n        else:\n            return p\n        p = self.pangler_factory(self.id)\n        mro = inspect.getmro(owner)\n        others = []\n        for cls in mro:\n            sub_p = getattr(cls, self.attr_name, None)\n            if sub_p is None:\n                continue\n            others.append(sub_p)\n        return p.combine(*others).stored_bind(instance)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef Auth(email=None, password=None):\n    gd_client = SpreadsheetsService()\n    gd_client.source = \"texastribune-ttspreadimporter-1\"\n    if email is None:\n        email = os.environ.get('GOOGLE_ACCOUNT_EMAIL')\n    if password is None:\n        password = os.environ.get('GOOGLE_ACCOUNT_PASSWORD')\n    if email and password:\n        gd_client.ClientLogin(email, password)\n    return gd_client", "response": "Get a reusable google data client."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlike docutils.core.publish_parts, but returns the publisher and sets some default settings, see `default_rst_opts`. Parameters: see `docutils.core` functions for explanation. Example: pub = rst2pub(rst_string) print doctree2dict(pub.document)", "response": "def rst2pub(source, source_path=None, source_class=None,\n            destination_path=None,\n            reader=None, reader_name='standalone',\n            parser=None, parser_name='restructuredtext',\n            writer=None, writer_name='pseudoxml',\n            settings=None, settings_spec=None,\n            settings_overrides=None, config_section=None,\n            enable_exit_status=None):\n    \"\"\"\n    Like docutils.core.publish_parts, but returns the publisher and sets\n    some default settings, see `default_rst_opts`.\n\n    Parameters: see `docutils.core` functions for explanation.\n\n    Example:\n\n        pub = rst2pub(rst_string)\n        print doctree2dict(pub.document)\n\n    \"\"\"\n    if not have_docutils:\n        raise ImportError('docutils library is required to use reStructuredText conversion')\n\n    final_settings_overrides = default_rst_opts.copy()\n    if settings_overrides:\n        final_settings_overrides.update(settings_overrides)\n\n    source_class = source_class or io.StringInput\n\n    output, pub = publish_programmatically(\n        source=source, source_path=source_path, source_class=source_class,\n        destination_class=io.StringOutput,\n        destination=None, destination_path=destination_path,\n        reader=reader, reader_name=reader_name,\n        parser=parser, parser_name=parser_name,\n        writer=writer, writer_name=writer_name,\n        settings=settings, settings_spec=settings_spec,\n        settings_overrides=final_settings_overrides,\n        config_section=config_section,\n        enable_exit_status=enable_exit_status)\n    return pub"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef docinfo2dict(doctree):\n    nodes = doctree.traverse(docutils.nodes.docinfo)\n    md = {}\n    if not nodes:\n        return md\n    for node in nodes[0]:\n        # copied this logic from Sphinx, not exactly sure why they use it, but\n        # I figured it can't hurt\n        if isinstance(node, docutils.nodes.authors):\n            md['authors'] = [author.astext() for author in node]\n        elif isinstance(node, docutils.nodes.TextElement):  # e.g. author\n            md[node.__class__.__name__] = node.astext()\n        else:\n            name, body = node\n            md[name.astext()] = body.astext()\n    return md", "response": "Return the docinfo field list from a doctree as a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_toc(doctree, depth=9223372036854775807, writer_name='html',\n               exclude_first_section=True, href_prefix=None, id_prefix='toc-ref-'):\n    \"\"\"\n    Create a Table of Contents (TOC) from the given doctree\n\n    Returns: (docutils.core.Publisher instance, output string)\n\n    `writer_name`: represents a reST writer name and determines the type of\n        output returned.\n\n    Example:\n\n        pub = blazeutils.rst.rst2pub(toc_rst)\n        pub, html_output = blazeutils.rst.create_toc(pub.document)\n\n        # a full HTML document (probably not what you want most of the time)\n        print html_output\n\n        # just the TOC\n        print pub.writer.parts['body']\n    \"\"\"\n    # copy the doctree since Content alters some settings on the original\n    # document\n    doctree = doctree.deepcopy()\n\n    # we want to be able to customize ids to avoid clashes if needed\n    doctree.settings.auto_id_prefix = id_prefix\n\n    details = {\n        'depth': depth,\n    }\n\n    # Assuming the document has one primary heading and then sub-sections, we\n    # want to be able to give just the sub-sections\n    startnode = None\n    if exclude_first_section:\n        nodes = doctree.traverse(docutils.nodes.section)\n        if nodes:\n            startnode = nodes[0]\n\n    # use the Contents transform to build the TOC node structure from the\n    # document\n    c = Contents(doctree)\n    # this startnode isn't really used as the start node, its only used for\n    # to pull settings from\n    c.startnode = BlankObject(details=details)\n    # since this toc is detached from the rest of the document, we don't want\n    # backlinks\n    c.backlinks = 'none'\n    # build the nodes\n    toc_nodes = c.build_contents(startnode or doctree)\n\n    # create a new document with the new nodes\n    toc_doc = new_document(None)\n    toc_doc += toc_nodes\n\n    # fix fragements that reference the same page\n    if href_prefix:\n        prefix_refids(toc_doc, href_prefix)\n\n    # setup a publisher and publish from the TOC document\n    reader = docutils.readers.doctree.Reader(parser_name='null')\n    pub = Publisher(\n        reader, None, None,\n        source=io.DocTreeInput(toc_doc),\n        destination_class=io.StringOutput\n    )\n    pub.set_writer(writer_name)\n\n    final_settings_overrides = default_rst_opts.copy()\n    pub.process_programmatic_settings(\n        None, final_settings_overrides, None)\n\n    output = pub.publish()\n    return pub, output", "response": "Create a Table of Contents from a given doctree."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rst2html(rst_src, **kwargs):\n    pub = rst2pub(rst_src, settings_overrides=kwargs, writer_name='html')\n    return pub.writer.parts['body']", "response": "Convert a reStructuredText string into a unicode HTML fragment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef print_languages_and_exit(lst, status=1, header=True):\n    if header:\n        print(\"Available languages:\")\n    for lg in lst:\n        print(\"- %s\" % lg)\n    sys.exit(status)", "response": "print a list of languages and exit"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef extract_opts(**opts):\n    values = {}\n    for opt, init in opts.items():\n        try:\n            idx = sys.argv.index('-%s' % opt)\n        except ValueError:\n            continue\n        if idx+1 < len(sys.argv):\n            opts[opt] = sys.argv.pop(idx+1)\n\n        sys.argv.pop(idx)\n\n    return opts", "response": "Small utility to extract a set of one - char options from sys. argv."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses input string and returns list of DDLObjects", "response": "def parse(self, text):\n        '''Parses input string and returns list of DDLObjects'''\n        in_comment = False\n        result = []\n        for s in iter(text.splitlines()):\n            self.log.debug('Parsing string: {}'.format(s))\n            rsc = self.RE_START_COMMENT.match(s)\n            if rsc:\n                if in_comment:\n                    self.log.debug('Double comment start!')\n                in_comment = True\n                comment = rsc.group(1)\n                jdoc = JDOC('', '', comment)\n            if in_comment:\n                rcb = self.RE_COMMENT_BODY.match(s)\n                rp = self.RE_PARAM.match(s)\n                rec = self.RE_END_COMMENT.match(s)\n                if rp:\n                    if rsc:\n                        self.log.debug('Comment start and param on same line!')\n                    param_name = rp.group(1)\n                    param_desc = rp.group(2)\n                    if param_name in ['function', 'trigger', 'procedure']:\n                        rso = self.RE_SCHEMA_OBJECT.match(param_desc)\n                        jdoc.object_type = param_name\n                        if rso:\n                            jdoc.schema_name = rso.group(1)\n                            if jdoc.schema_name:\n                                jdoc.schema_name = jdoc.schema_name.strip(\".\")\n                            if not jdoc.schema_name or jdoc.schema_name == \"\":\n                                jdoc.schema_name = self.default_schema\n                            jdoc.object_name = rso.group(2)\n                    elif param_name in ['return',\n                                        'returns',\n                                        'returning',\n                                        'result']:\n                        jdoc.returns = param_desc\n                    else:\n                        jdoc.add_param(param_name, param_desc)\n                    self.log.debug('Param {} = {}'.format(param_name, param_desc))\n                if rcb:\n                    comment = comment + ' ' + rcb.group(1)\n                    jdoc.comment = comment\n                if rec:\n                    in_comment = False\n                    result.append(copy.deepcopy(jdoc))\n                    del jdoc\n                    self.log.debug('Comment:' + comment)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrenders the blueprint into a temp directory using the context.", "response": "def render(self):\n        \"\"\"Render the blueprint into a temp directory using the context.\"\"\"\n        context = self.context\n        if 'app' not in context:\n            context['app'] = self.application.name\n        temp_dir = self.temp_dir\n        templates_root = self.blueprint.templates_directory\n        for root, dirs, files in os.walk(templates_root):\n            for directory in dirs:\n                directory = os.path.join(root, directory)\n                directory = render_from_string(directory, context)\n                directory = directory.replace(templates_root, temp_dir, 1)\n                os.mkdir(directory)\n            for file in files:\n                full_file = os.path.join(root, file)\n                stat = os.stat(full_file)\n                content = render_from_file(full_file, context)\n                full_file = strip_extension(\n                    render_from_string(full_file, context))\n                full_file = full_file.replace(templates_root, temp_dir, 1)\n                with open(full_file, 'w') as f:\n                    f.write(content)\n                os.chmod(full_file, stat.st_mode)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge(self):\n        temp_dir = self.temp_dir\n        app_dir = self.application.directory\n        for root, dirs, files in os.walk(temp_dir):\n            for directory in dirs:\n                directory = os.path.join(root, directory)\n                directory = directory.replace(temp_dir, app_dir, 1)\n                try:\n                    os.mkdir(directory)\n                except OSError:\n                    pass\n            for file in files:\n                source = os.path.join(root, file)\n                target = source.replace(temp_dir, app_dir, 1)\n                relative_target = target.replace(app_dir, '.')\n                action = 'r'\n                if (\n                    os.path.exists(target)\n                    and not filecmp.cmp(source, target, shallow=False)\n                    and os.stat(target).st_size > 0\n                ):\n                    # target exists, is not empty, and does not\n                    # match source\n                    if target.endswith('__init__.py'):\n                        # default merge __init__.py files\n                        # if non-empty, these should only\n                        # contain imports from submoduiles\n                        action = 'm'\n                    elif target.endswith('base.py'):\n                        # default skip base.py files\n                        # these should be extended by the developer\n                        action = 's'\n                    else:\n                        default = 'm'\n                        action = click.prompt(\n                            style.prompt(\n                                '%s already exists, '\n                                '[r]eplace, [s]kip, or [m]erge?' % (\n                                    relative_target\n                                ),\n                            ),\n                            default=style.default(default)\n                        ) if self.interactive else default\n                        action = click.unstyle(action).lower()\n                        if action not in {'r', 'm', 's'}:\n                            action = default\n\n                if action == 's':\n                    self.stdout.write(\n                        '? %s' % style.white(relative_target),\n                        fg='yellow'\n                    )\n                    continue\n                if action == 'r':\n                    with open(source, 'r') as source_file:\n                        with open(target, 'w') as target_file:\n                            target_file.write(source_file.read())\n                    self.stdout.write(\n                        style.green(\n                            '+ %s' % style.white(relative_target)\n                        )\n                    )\n                if action == 'm':\n                    with open(target, 'r') as target_file:\n                        with open(source, 'r') as source_file:\n                            merged = merge(\n                                target_file.read(),\n                                source_file.read()\n                            )\n                    with open(target, 'w') as target_file:\n                        target_file.write(merged)\n\n                    self.stdout.write(\n                        style.yellow('> %s' % style.white(relative_target))\n                    )", "response": "Merges the rendered blueprint into the application."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates a Gaussian window function in the time domain which will broaden peaks in the frequency domain by the line broadening Hertz.", "response": "def gaussian_window(t, params):\n    \"\"\"\n    Calculates a Gaussian window function in the time domain which will broaden\n    peaks in the frequency domain by params[\"line_broadening\"] Hertz.\n    :param t:\n    :param params:\n    :return:\n    \"\"\"\n    window = suspect.basis.gaussian(t, 0, 0, params[\"line_broadening\"])\n\n    # the above gaussian function returns an area 1 fid, for a windowing\n    # function we need to be area preserving (first point must be 1)\n    return window / window[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mean(array):\n    n = len(array)\n\n    if n < 1:\n        return 0\n    elif n == 1:\n        return array[0]\n    return sum(array) / n", "response": "Return the mean value of a list of divisible numbers."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the mean value of a list of divisible numbers.", "response": "def geomean(array):\n    \"\"\"\n    Return the mean value of a list of divisible numbers.\n    \"\"\"\n    n = len(array)\n\n    if n < 1:\n        return 0\n    elif n == 1:\n        return array[0]\n    return stats.mstats.gmean(array)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef median(array):\n    n = len(array)\n\n    if n < 1:\n        return 0\n    elif n == 1:\n        return array[0]\n\n    sorted_vals = sorted(array)\n    midpoint = int(n / 2)\n    if n % 2 == 1:\n        return sorted_vals[midpoint]\n    else:\n        return (sorted_vals[midpoint - 1] + sorted_vals[midpoint]) / 2.0", "response": "Return the median value of a list of numbers."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the variance of a list of divisible numbers.", "response": "def variance(array):\n    \"\"\"\n    Return the variance of a list of divisible numbers.\n    \"\"\"\n    if len(array) < 2:\n        return 0\n    u = mean(array)\n    return sum([(x - u) ** 2 for x in array]) / (len(array) - 1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns elements which fall within specified interquartile range.", "response": "def filter_iqr(array, lower, upper):\n    \"\"\"\n    Return elements which falls within specified interquartile range.\n\n    Arguments:\n\n        array (list): Sequence of numbers.\n        lower (float): Lower bound for IQR, in range 0 <= lower <= 1.\n        upper (float): Upper bound for IQR, in range 0 <= upper <= 1.\n\n    Returns:\n\n        list: Copy of original list, with elements outside of IQR\n          removed.\n    \"\"\"\n    upper, lower = iqr(array, upper, lower)\n\n    new = list(array)\n    for x in new[:]:\n        if x < lower or x > upper:\n            new.remove(x)\n\n    return new"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef confinterval(array, conf=0.95, normal_threshold=30, error_only=False,\n                 array_mean=None):\n    \"\"\"\n    Return the confidence interval of a list for a given confidence.\n\n    Arguments:\n\n        array (list): Sequence of numbers.\n        conf (float): Confidence interval, in range 0 <= ci <= 1\n        normal_threshold (int): The number of elements in the array is\n          < normal_threshold, use a T-distribution. If the number of\n          elements in the array is >= normal_threshold, use a normal\n          distribution.\n        error_only (bool, optional): If true, return only the size of\n          symmetrical confidence interval, equal to ci_upper - mean.\n        array_mean (float, optional): Optimisation trick for if you\n          already know the arithmetic mean of the array to prevent\n          this function from re-calculating.\n\n    Returns:\n\n        (float, float): Lower and upper bounds on confidence interval,\n          respectively.\n    \"\"\"\n    n = len(array)\n\n    if n < 1:\n        # We have no data.\n        array_mean, c0, c1 = 0, 0, 0\n    elif n == 1:\n        # We have only a single datapoint, so return that value.\n        array_mean, c0, c1 = array[0], array[0], array[0]\n    else:\n        scale = stdev(array) / sqrt(n)\n        # Check if all values are the same.\n        values_all_same = all(x == array[0] for x in array[1:])\n\n        if values_all_same:\n            # If values are all the same, return that value.\n            array_mean, c0, c1 = array[0], array[0], array[0]\n        else:\n            if array_mean is None: array_mean = mean(array)\n            if n < normal_threshold:\n                # We have a \"small\" number of datapoints, so use a\n                # t-distribution.\n                c0, c1 = stats.t.interval(conf, n - 1, loc=array_mean,\n                                          scale=scale)\n            else:\n                # We have a \"large\" number of datapoints, so use a\n                # normal distribution.\n                c0, c1 = stats.norm.interval(conf, loc=array_mean, scale=scale)\n\n    if error_only:\n        return c1 - array_mean\n    else:\n        return c0, c1", "response": "Return the confidence interval of a list of numbers."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconnect to the SPC Web Gateway.", "response": "def start(self):\n        \"\"\"Connect websocket to SPC Web Gateway.\"\"\"\n        self._websocket = AIOWSClient(loop=self._loop,\n                                      session=self._session,\n                                      url=self._ws_url,\n                                      async_callback=self._async_ws_handler)\n        self._websocket.start()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch area and zone info from SPC to initialize.", "response": "async def async_load_parameters(self):\n        \"\"\"Fetch area and zone info from SPC to initialize.\"\"\"\n        zones = await self._async_get_data('zone')\n        areas = await self._async_get_data('area')\n\n        if not zones or not areas:\n            return False\n\n        for spc_area in areas:\n            area = Area(self, spc_area)\n            area_zones = [Zone(area, z) for z in zones\n                          if z['area'] == spc_area['id']]\n            area.zones = area_zones\n            self._areas[area.id] = area\n            self._zones.update({z.id: z for z in area_zones})\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchanges the mode of an area.", "response": "async def change_mode(self, area, new_mode):\n        \"\"\"Set/unset/part set an area.\"\"\"\n        if not isinstance(new_mode, AreaMode):\n            raise TypeError(\"new_mode must be an AreaMode\")\n\n        AREA_MODE_COMMAND_MAP = {\n            AreaMode.UNSET: 'unset',\n            AreaMode.PART_SET_A: 'set_a',\n            AreaMode.PART_SET_B: 'set_b',\n            AreaMode.FULL_SET: 'set'\n        }\n        if isinstance(area, Area):\n            area_id = area.id\n        else:\n            area_id = area\n\n        url = urljoin(self._api_url, \"spc/area/{area_id}/{command}\".format(\n            area_id=area_id, command=AREA_MODE_COMMAND_MAP[new_mode]))\n\n        return await async_request(self._session.put, url)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprocess incoming websocket message.", "response": "async def _async_ws_handler(self, data):\n        \"\"\"Process incoming websocket message.\"\"\"\n        sia_message = data['data']['sia']\n        spc_id = sia_message['sia_address']\n        sia_code = sia_message['sia_code']\n\n        _LOGGER.debug(\"SIA code is %s for ID %s\", sia_code, spc_id)\n\n        if sia_code in Area.SUPPORTED_SIA_CODES:\n            entity = self._areas.get(spc_id, None)\n            resource = 'area'\n        elif sia_code in Zone.SUPPORTED_SIA_CODES:\n            entity = self._zones.get(spc_id, None)\n            resource = 'zone'\n        else:\n            _LOGGER.debug(\"Not interested in SIA code %s\", sia_code)\n            return\n        if not entity:\n            _LOGGER.error(\"Received message for unregistered ID %s\", spc_id)\n            return\n\n        data = await self._async_get_data(resource, entity.id)\n        entity.update(data, sia_code)\n\n        if self._async_callback:\n            ensure_future(self._async_callback(entity))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def _async_get_data(self, resource, id=None):\n        if id:\n            url = urljoin(self._api_url, \"spc/{}/{}\".format(resource, id))\n        else:\n            url = urljoin(self._api_url, \"spc/{}\".format(resource))\n        data = await async_request(self._session.get, url)\n        if not data:\n            return False\n        if id and isinstance(data['data'][resource], list):\n            # for some reason the gateway returns an array with a single\n            # element for areas but not for zones...\n            return data['data'][resource][0]\n        elif id:\n            return data['data'][resource]\n\n        return [item for item in data['data'][resource]]", "response": "Get the data from the resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_bounds(self, ymin, ymax, xmin, xmax, zmin, zmax, edist=None):\n        self.ymin, self.ymax = ymin, ymax\n        self.xmin, self.xmax = xmin, xmax\n        self.zmin, self.zmax = zmin, zmax\n        self.edist = None", "response": "Set Y X Z bounds for the plot."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a loop tuple to the list of loops.", "response": "def add_loop(self, n, common_sta, from_sta, to_sta, stations):\n        \"\"\"Add a loop tuple to :attr:`loops`.\"\"\"\n        self.loops.append((n, common_sta, from_sta, to_sta, stations))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(self):\n        plt = Plot(name_from_filename(self.pltfilename))\n\n        with open(self.pltfilename, 'rb') as pltfile:\n            segment = None\n\n            for line in pltfile:\n                if not line:\n                    continue\n\n                c, val = line[:1], line[1:]\n\n                if c == 'Z':\n                    edist = None\n                    try:\n                        ymin, ymax, xmin, xmax, zmin, zmax = (float(v) for v in val.split())\n                    except ValueError:\n                        ymin, ymax, xmin, xmax, zmin, zmax, _, edist = val.split()\n                        ymin, ymax, xmin, xmax, zmin, zmax, edist = \\\n                            (float(v) for v in (ymin, ymax, xmin, xmax, zmin, zmax, edist))\n                    plt.set_bounds(ymin, ymax, xmin, xmax, zmin, zmax, edist)\n\n                elif c == 'S':\n                    if not plt.name:\n                        plt.name = val.strip()\n\n                elif c == 'G':\n                    plt.utm_zone = int(val)\n\n                elif c == 'O':\n                    plt.datum = val\n\n                elif c == 'N':\n                    date, comment = None, ''  # both date and comment are optional\n                    try:\n                        name, _, m, d, y, comment = val.split(None, 5)\n                        date = datetime.date(int(y), int(m), int(d))\n                    except ValueError:\n                        try:\n                            name, _, m, d, y = val.split()\n                            date = datetime.date(int(y), int(m), int(d))\n                        except ValueError:\n                            name = val\n                    comment = comment[1:].strip()\n                    segment = Segment(name, date, comment)\n\n                elif c == 'M':\n                    flags = None  # flags are optional\n                    try:\n                        y, x, z, name, _, l, u, d, r, _, edist = val.split()\n                    except ValueError:\n                        y, x, z, name, _, l, u, d, r, _, edist, flags = val.split()\n                    cmd = MoveCommand(float(y), float(x), float(z), name[1:],\n                                      float(l), float(r), float(u), float(d), float(edist), flags)\n                    segment.add_command(cmd)\n\n                elif c in ('D', 'd'):\n                    # 'D' for normal stations, 'd' for \"hidden\" stations with the 'P' flag\n                    flags = None\n                    try:\n                        y, x, z, name, _, l, u, d, r, _, edist = val.split()\n                    except ValueError:\n                        y, x, z, name, _, l, u, d, r, _, edist, flags = val.split()\n                    cmd = DrawCommand(float(y), float(x), float(z), name[1:],\n                                      float(l), float(r), float(u), float(d), float(edist), flags)\n                    cmd.cmd = c\n                    segment.add_command(cmd)\n\n                elif c == 'X':\n                    segment.set_bounds(*(float(v) for v in val.split()))\n\n                    # An X-bounds command signifies end of segment\n                    plt.add_segment(segment)\n                    segment = None\n\n                elif c == 'P':\n                    name, y, x, z = val.split()\n                    plt.add_fixed_point(name, (float(y), float(x), float(z)))\n\n                elif c == 'C':\n                    plt.loop_count = int(val)\n\n                elif c == 'R':\n                    count, common, from_sta, to_sta, stations = val.split(None, 4)\n                    plt.add_loop(int(count), common, from_sta, to_sta, stations.split())\n\n                elif c == '\\x1A':\n                    continue  # \"soft EOF\" ascii SUB ^Z\n\n                else:\n                    msg = \"Unknown PLT control code '%s': %s\" % (c, val)\n                    if self.strict_mode:\n                        raise ParseException(msg)\n                    else:\n                        log.warning(msg)\n\n        return plt", "response": "Parse our. PLT file and return a Plot object or raise a ParseException."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scan(phenotype, X, G=None, K=None, covariates=None, progress=True,\n         options=None):\n    \"\"\"Association between genetic variants and phenotype.\n\n    Matrix `X` shall contain the genetic markers (e.g., number of minor\n    alleles) with rows and columns representing samples and genetic markers,\n    respectively.\n\n    The user must specify only one of the parameters `G` and `K` for defining\n    the genetic background.\n\n    Let :math:`N` be the sample size, :math:`S` the number of covariates,\n    :math:`P_c` the number of genetic markers to be tested, and :math:`P_b`\n    the number of genetic markers used for Kinship estimation.\n\n    Args:\n        y          (array_like): Phenotype. Dimension (:math:`N\\\\times 0`).\n        X          (array_like): Candidate genetic markers (or any other\n                                 type of explanatory variable) whose\n                                 association with the phenotype will be\n                                 tested. Dimension (:math:`N\\\\times P_c`).\n        G          (array_like): Genetic markers matrix used internally for\n                                 kinship estimation. Dimension\n                                 (:math:`N\\\\times P_b`).\n        K          (array_like): Kinship matrix. Dimension\n                                 (:math:`N\\\\times N`).\n        covariates (array_like): Covariates. Default is an offset.\n                                 Dimension (:math:`N\\\\times S`).\n        progress    (bool)     : Shows progress. Defaults to `True`.\n\n    Returns:\n        A :class:`lim.genetics.qtl._canonical.CanonicalLRTScan` instance.\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    logger.info('%s association scan has started.', phenotype.likelihood_name)\n\n    if options is None:\n        options = dict()\n\n    if 'fast' not in options:\n        options['fast'] = True\n\n    if 'rank_norm' not in options:\n        options['rank_norm'] = True\n\n    n = phenotype.sample_size\n    covariates = ones((n, 1)) if covariates is None else covariates\n\n    X = _clone(X)\n    G = _clone(G)\n    K = _clone(K)\n\n    if not is_all_finite(X):\n        raise ValueError(\"The candidate matrix X has non-finite values.\")\n\n    if G is not None and not is_all_finite(G):\n        raise ValueError(\"The genetic markers matrix G has non-finite values.\")\n\n    if K is not None and not is_all_finite(K):\n        raise ValueError(\"The Kinship matrix K has non-finite values.\")\n\n    background = Background()\n\n    (Q0, Q1, S0) = _genetic_preprocess(X, G, K, background)\n    qtl = QTLScan(phenotype, covariates, X, Q0, Q1, S0, options)\n    qtl.progress = progress\n    qtl.compute_statistics()\n\n    return qtl", "response": "This function is used to create a canonical LRT scan for a set of genetic variants and a set of genetic variants."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(cls, option, default_value=None):\n        config = cls.__get_instance()\n        for name in option.split(':'):\n            if not name:\n                raise Exception('Incorrect value in path (maybe double `:` or empty path)')\n            if name not in config:\n                return default_value\n            config = config[name]\n        return deepcopy(config)", "response": "Get the value of a given option."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef merge_dicts(*dict_list):\n    # if not isinstance(dict_list, list):\n    #     raise TypeError(\"dict_list is not a list. Please try again\")\n    # print(dict_list)\n    all_dicts = []\n    for ag in dict_list:\n        if isinstance(ag, dict):\n            all_dicts.append(ag)\n    \n    # Get all dictionaries\n    # Merge them\n    # Check if type is there\n    try:\n        qitem = { k: v for d in all_dicts for k, v in d.items() }\n        return qitem\n    except Exception:\n        return {}", "response": "Extract all of the dictionaries from this list then merge them together"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nensures that the dict has all of the information available. If not return what does.", "response": "def filter_query(filter_dict, required_keys):\n    \"\"\"Ensure that the dict has all of the information available. If not, return what does\"\"\"\n    if not isinstance(filter_dict, dict):\n        raise TypeError(\"dict_list is not a list. Please try again\")\n\n    if not isinstance(required_keys, list):\n        raise TypeError(\"dict_list is not a list. Please try again\")\n\n    available = []\n    for k,v in filter_dict.items():\n        # print(k, v)\n        if k in required_keys:\n            available.append(k)\n    return available"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef price_insert_filter(price_dict):\n    if not isinstance(price_dict, dict):\n        raise TypeError(\"dict_list is not a list. Please try again\")\n    required = [\"period\", \"exchange\", \"open\", \"close\", \"high\", \"low\", \"volumefrom\", \"volumeto\"]\n\n    pkeys = price_dict.keys()\n    for r in required:\n        if r not in pkeys:\n            raise KeyError(\"An important key is not available\")\n    return True", "response": "Returns True if the given price_dict has all of the required keys."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef price_query_filter(price_query_dict):\n    if not isinstance(price_query_dict, dict):\n        raise TypeError(\"dict_list is not a list. Please try again\")\n    required = [\"period\", \"exchange\"]\n    pkeys = price_query_dict.keys()\n    for r in required:\n        if r not in pkeys:\n            raise KeyError(\"An important key is not available {}\".format(r))\n    return True", "response": "Ensure that certain keys are available."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef import_path(path):\n    sys.path.insert(0, \".\")\n    parts = path.split(\".\")\n    module = None\n\n    # Import the module as deeply as possible.  Prioritize an attribute chain\n    # over a module chain\n    for i in range(1, len(parts)+1):\n        if module is not None and hasattr(module, parts[i-1]):\n            try:\n                return _import_attributes(module, parts[i-1:])\n            except AttributeError:\n                pass\n        module_path = \".\".join(parts[0:i])\n        module = importlib.import_module(module_path)\n\n    return module", "response": "Imports any valid python module or attribute path as though it were avecite."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pbkdf2_hex(data, salt, iterations=1000, keylen=24, hashfunc=None):\n    return hexlify_(pbkdf2_bin(data, salt, iterations, keylen, hashfunc))", "response": "Like : func : pbkdf2_bin but returns a hex encoded string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a binary digest of the PBKDF2 hash algorithm of data with the given salt.", "response": "def pbkdf2_bin(data, salt, iterations=1000, keylen=24, hashfunc=None):\n    \"\"\"Returns a binary digest for the PBKDF2 hash algorithm of `data`\n    with the given `salt`.  It iterates `iterations` time and produces a\n    key of `keylen` bytes.  By default SHA-1 is used as hash function,\n    a different hashlib `hashfunc` can be provided.\n    \"\"\"\n    hashfunc = hashfunc or hashlib.sha1\n    mac = hmac.new(bytes_(data), None, hashfunc)\n\n    def _pseudorandom(x, mac=mac):\n        h = mac.copy()\n        h.update(bytes_(x))\n        if not PY2:\n            return [x for x in h.digest()]\n        else:\n            return map(ord, h.digest())\n    buf = []\n    for block in range_(1, -(-keylen // mac.digest_size) + 1):\n        rv = u = _pseudorandom(bytes_(salt) + _pack_int(block))\n        for i in range_(iterations - 1):\n            if not PY2:\n                u = _pseudorandom(bytes(u))\n            else:\n                u = _pseudorandom(''.join(map(chr, u)))\n            rv = starmap(xor, zip(rv, u))\n        buf.extend(rv)\n    if not PY2:\n        return bytes(buf)[:keylen]\n    else:\n        return ''.join(map(chr, buf))[:keylen]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns a task on a : class : Carotte. Worker.", "response": "def run_task(self, task_name, task_args=[], task_kwargs={}):\n        \"\"\"\n        Run asynchronous task on a :class:`carotte.Worker`.\n\n        :param string task_name: Name of task to execute\n        :param list task_args: (optional) List of arguments to give to task\n        :param dict task_kwargs: (optional) Dict of keyword arguments\n                                 to give to task\n\n        :returns: :class:`carotte.Task` object\n\n        \"\"\"\n        data = {\n            'action': 'run_task',\n            'name': task_name,\n            'args': task_args,\n            'kwargs': task_kwargs}\n        self.__send_pyobj(data)\n        task = self.__recv_pyobj()\n        task.client = self\n        return task"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the result of a task from the worker.", "response": "def get_task_result(self, task_id):\n        \"\"\"\n        Get task result from worker. If the task is not finished, return None.\n        It's prefered to use :class:`carotte.Task` object directly.\n\n        :param string task_id: Task ID\n\n        :returns: Task dict\n        :rtype: dict\n        \"\"\"\n        data = {\n            'action': 'get_result',\n            'id': task_id\n        }\n        self.__send_pyobj(data)\n        task = self.__recv_pyobj()\n        return task"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nblocks method which wait end of task. is prefered to use : class : carotte. Task object directly", "response": "def wait(self, task_id):\n        \"\"\"\n        Blocking method which wait end of task.\n        It's prefered to use :class:`carotte.Task` object directly\n\n        :param string task_id: Task ID\n\n        :returns: Task dict\n        :rtype: dict\n        \"\"\"\n        data = {\n            'action': 'wait',\n            'id': task_id\n        }\n        self.__send_pyobj(data)\n        task = self.__recv_pyobj(notimeout=True)\n        return task"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_compiler(compiler, **compiler_attrs):\n    if compiler is None or isinstance(compiler, str):\n        cc = ccompiler.new_compiler(compiler=compiler, verbose=0)\n        customize_compiler(cc)\n        if cc.compiler_type == 'mingw32':\n            customize_mingw(cc)\n    else:\n        cc = compiler\n        customize_gcc(cc)\n\n    for name, val in compiler_attrs.items():\n        setattr(cc, name, val)\n\n    return cc", "response": "get and customize a compiler"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transaction_date(self, value):\n        if value:\n            self._transaction_date = parse(value).date() if isinstance(value, type_check) else value", "response": "Force the transaction_date to always be a date\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef settlement_date(self, value):\n        if value:\n            self._settlement_date = parse(value).date() if isinstance(value, type_check) else value", "response": "Set the settlement_date of the oci_settlement attribute."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef execution_time(self, value):\n        if value:\n            self._execution_time = parse(value) if isinstance(value, type_check) else value", "response": "Set the execution_time of the resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the total effect of the net_affecting charges.", "response": "def charges_net_effect(self):\n        \"\"\"\n        The total effect of the net_affecting charges (note affect vs effect here).\n\n        Currently this is single currency only (AMAAS-110).\n\n        Cast to Decimal in case the result is zero (no net_affecting charges).\n\n        :return:\n        \"\"\"\n        return Decimal(sum([charge.charge_value for charge in self.charges.values()\n                            if charge.net_affecting]))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove an item altogether by setting link_list to None. Currently, only links can contain multiple children of the same type. :param link_type: :param link_set: :return:", "response": "def upsert_link_set(self, link_type, link_set):\n        \"\"\"\n        Remove an item altogether by setting link_list to None.\n        Currently, only links can contain multiple children of the same type.\n        :param link_type:\n        :param link_set:\n        :return:\n        \"\"\"\n        if link_set is None:\n            self.links.pop(link_type, None)\n            return\n        links = copy.deepcopy(self.links)\n        links.update({link_type: link_set})\n        self.links = links"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef describe_ingredient(self):\n        resp = random.choice(ingredients)\n        if random.random() < .2:\n            resp = random.choice(foodqualities) + \" \" + resp\n        if random.random() < .2:\n            resp += \" with \" + self.describe_additive()\n        return resp", "response": "tart apple with vinegar."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef describe_dish(self):\n        resp = random.choice(foodpreparations)\n        if random.random() < .85:\n            resp = self.describe_ingredient() + ' ' + resp\n            if random.random() < .2:\n                resp = self.describe_ingredient() + ' and ' + resp\n                if random.random() < .2:\n                    resp = self.describe_ingredient() + ', ' + resp\n        if random.random() < .5:\n            resp += \" with \" + self.describe_additive()\n        elif random.random() < .5:\n            resp += \" with \" + self.describe_ingredient()\n        return self.articleize(resp)", "response": "a burrito. a lettuce burrito with ketchup and raspberry."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef output_compose(info, image_info):\n    '''output as docker-compose format'''\n\n    container = info['Name'][1:]\n\n    conf = info['Config']\n    hconf = info['HostConfig']\n\n    compose = {}\n    compose['container_name'] = str(container)\n    compose['image'] = str(conf['Image'])\n\n    # Volumes\n    if 'Binds' in hconf and isinstance(hconf['Binds'], list):\n        options = []\n        for volume in hconf['Binds']:\n            options.append(str(volume))\n        if len(options) > 0:\n            compose['volumes'] = options\n\n    if 'PortBindings' in hconf and isinstance(hconf['PortBindings'], dict):\n        options = []\n        for binding, hosts in hconf['PortBindings'].items():\n            for host in hosts:\n                portbinding = ''\n                if 'HostIp' in host and host['HostIp']:\n                    portbinding += host['HostIp'] + ':'\n                if 'HostPort' in host and host['HostPort']:\n                    portbinding += host['HostPort'] + ':'\n                portbinding += binding\n                options.append(str(portbinding))\n        if len(options) > 0:\n            compose['ports'] = options\n\n    # Devices\n    if 'Devices' in hconf and isinstance(hconf['Devices'], list):\n        options = []\n        for device in hconf['Devices']:\n            options.append(str(device))\n        if len(options) > 0:\n            compose['devices'] = options\n\n    # RestartPolicy\n    if 'RestartPolicy' in hconf and hconf['RestartPolicy']['Name']:\n        policy = hconf['RestartPolicy']['Name']\n        if hconf['RestartPolicy']['MaximumRetryCount'] > 0:\n            policy += ':' + str(hconf['RestartPolicy']['MaximumRetryCount'])\n        compose['restart'] = str(policy)\n\n    # Privileged\n    if hconf['Privileged']:\n        compose['privileged'] = True\n\n    # Env\n    if isinstance(conf['Env'], list) and len(conf['Env']) > 0:\n        options = []\n        for env in conf['Env']:\n            if env not in image_info['Config']['Env']:\n                options.append(str(env))\n        if len(options) > 0:\n            compose['environment'] = options\n\n    # DNS\n    if 'Dns' in hconf and isinstance(hconf['Dns'], list):\n        options = []\n        for dns in hconf['Dns']:\n            options.append(str(dns))\n        if len(options) > 0:\n            compose['dns'] = options\n\n    # ExposedPorts\n    if 'ExposedPorts' in conf and isinstance(conf['ExposedPorts'], dict):\n        options = []\n        for port, _ in conf['ExposedPorts'].items():\n            if ('ExposedPorts' not in image_info['Config'] or\n                    port not in image_info['Config']['ExposedPorts']):\n                options.append(str(port))\n        if len(options) > 0:\n            compose['expose'] = options\n\n    # User\n    if conf['User'] and image_info['Config']['User'] != conf['User']:\n        compose['user'] = str(conf['User'])\n\n    # WorkingDir\n    if image_info['Config']['WorkingDir'] != conf['WorkingDir']:\n        compose['working_dir'] = str(conf['WorkingDir'])\n\n    # EntryPoint\n    if conf['Entrypoint'] != image_info['Config']['Entrypoint']:\n        if isinstance(conf['Entrypoint'], list):\n            entry = []\n            for entry_item in conf['Entrypoint']:\n                entry.append(str(entry_item))\n            if len(entry) > 0:\n                compose['entrypoint'] = entry\n        elif isinstance(conf['Entrypoint'], str):\n            compose['entrypoint'] = str(conf['Entrypoint'])\n\n    name = str(info['Name'][1:])\n    print(yaml.dump({name:compose}, encoding='utf-8', default_flow_style=False))", "response": "output as docker - compose format"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\noutput as docker - run command format", "response": "def output_command(info, image_info, pretty=False):\n    '''output as docker-run command format'''\n\n    sep = pretty and ' \\\\\\n    ' or ' '\n\n    short_options = ''\n    options = []\n\n    container = info['Name'][1:]\n    conf = info['Config']\n    hconf = info['HostConfig']\n\n    options.append(\"--name={name}\".format(name=container))\n\n    if not conf['AttachStdout']:\n        short_options += 'd'\n\n    if conf['OpenStdin']:\n        short_options += 'i'\n\n    if conf['Tty']:\n        short_options += 't'\n\n    if len(short_options) > 0:\n        options.append('-' + short_options)\n\n    options.append(\"-h {hostname}\".format(hostname=conf['Hostname']))\n\n    # Volumes\n    if 'Binds' in hconf and isinstance(hconf['Binds'], list):\n        for volume in hconf['Binds']:\n            options.append(\"-v {volume}\".format(volume=volume))\n\n    # PortBindings\n    if 'PortBindings' in hconf and isinstance(hconf['PortBindings'], dict):\n        for port, hosts in hconf['PortBindings'].items():\n            for host in hosts:\n                portbinding = ''\n                if 'HostIp' in host and host['HostIp']:\n                    portbinding += host['HostIp'] + ':'\n                if 'HostPort' in host and host['HostPort']:\n                    portbinding += host['HostPort'] + ':'\n                portbinding += port\n                options.append(\"-p {portbinding}\".format(portbinding=portbinding))\n\n    # Devices\n    if 'Devices' in hconf and isinstance(hconf['Devices'], list):\n        for device in hconf['Devices']:\n            options.append(\"--device={device}\".format(device=device))\n\n    # RestartPolicy\n    if 'RestartPolicy' in hconf and hconf['RestartPolicy']['Name']:\n        policy = hconf['RestartPolicy']['Name']\n        if hconf['RestartPolicy']['MaximumRetryCount'] > 0:\n            policy += ':' + str(hconf['RestartPolicy']['MaximumRetryCount'])\n        options.append(\"--restart={policy}\".format(policy=policy))\n\n    # Privileged\n    if hconf['Privileged']:\n        options.append('--privileged')\n\n    # DNS\n    if 'Dns' in hconf and isinstance(hconf['Dns'], list):\n        for dns in hconf['Dns']:\n            options.append(\"-dns={dns}\".format(dns=dns))\n\n    # ExposedPorts\n    if 'ExposedPorts' in conf and isinstance(conf['ExposedPorts'], dict):\n        for port, _ in conf['ExposedPorts'].items():\n            if ('ExposedPorts' not in image_info['Config'] or\n                    port not in image_info['Config']['ExposedPorts']):\n                options.append(\"--expose={port}\".format(port=port))\n\n    # Env\n    if isinstance(conf['Env'], list):\n        for env in conf['Env']:\n            if env not in image_info['Config']['Env']:\n                options.append(\"-e {env}\".format(env=pipes.quote(env)))\n\n    # EntryPoint\n    if conf['Entrypoint'] != image_info['Config']['Entrypoint']:\n        entry = []\n        if isinstance(conf['Entrypoint'], list):\n            for entry_item in conf['Entrypoint']:\n                entry.append(pipes.quote(entry_item))\n        elif isinstance(conf['Entrypoint'], str):\n            entry.append(pipes.quote(conf['Entrypoint']))\n        if len(entry) > 0:\n            options.append(\"--entrypoint={entry}\".format(entry=pipes.quote(' '.join(entry))))\n\n    # WorkingDir\n    if image_info['Config']['WorkingDir'] != conf['WorkingDir']:\n        options.append(\"-w {dir}\".format(dir=pipes.quote(conf['WorkingDir'])))\n\n    # User\n    if conf['User'] and image_info['Config']['User'] != conf['User']:\n        options.append(\"-u {user}\".format(user=pipes.quote(conf['User'])))\n\n    # Cmd\n    cmd = []\n    if conf['Cmd'] != image_info['Config']['Cmd']:\n        if isinstance(conf['Cmd'], list):\n            for cmd_item in conf['Cmd']:\n                cmd.append(pipes.quote(cmd_item))\n        elif isinstance(conf['Cmd'], str):\n            cmd.append(pipes.quote(conf['Cmd']))\n\n    print('# docker-run command for {container}'.format(container=container))\n    cmd_str = 'docker run{sep}{options}{sep}{image}'.format(\n        options=sep.join(options), sep=sep, image=conf['Image'])\n\n    if len(cmd) > 0:\n        cmd_str += ' ' + ' '.join(cmd)\n\n    print(cmd_str)\n    print()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new project.", "response": "def create(name, image, bare):\n    \"\"\"\n    Create a new project.\n    \"\"\"\n    if bool(bare) == bool(image):\n        raise click.UsageError(\"Specify either --bare or image using --image.\")\n\n    path = get_project_path(name)\n\n    print(\"Creating %s...\" % path)\n    try:\n        os.mkdir(path)\n    except FileExistsError:\n        die(\"%s already exists.\" % path)\n\n    if not bare:\n        print(\"Creating container with image %s...\" % image)\n        client = docker.Client()\n        try:\n            client.create_container(\n                image=image,\n                name=get_container_name(name),\n                hostname=name,\n                working_dir='/code/',\n                command='tail -f /dev/null',\n                tty=True,\n                volumes=['/code/'],\n                host_config=client.create_host_config(binds={\n                    path: {'bind': '/code/', 'mode': 'rw'}\n                })\n            )\n        except docker.errors.APIError as error:\n            die(error.explanation.decode())\n\n    enter_project(name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rm(name):\n    path = get_existing_project_path(name)\n\n    click.confirm(\n        'Are you sure you want to delete project %s?' % name, abort=True)\n\n    container_name = get_container_name(name)\n    client = docker.Client()\n    try:\n        client.inspect_container(container_name)\n    except docker.errors.NotFound:\n        pass\n    else:\n        print(\"Removing container %s...\" % container_name)\n        client.remove_container(container_name, v=True, force=True)\n\n    print(\"Removing %s...\" % path)\n    shutil.rmtree(path)", "response": "Remove an existing project and its container."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstop a container in the project.", "response": "def stop(name):\n    \"\"\"\n    Stop project's container.\n    \"\"\"\n    container_name = get_container_name(name)\n    client = docker.Client()\n    try:\n        client.stop(container_name)\n    except docker.errors.NotFound:\n        pass\n    except docker.errors.APIError as error:\n        die(error.explanation.decode())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef elapsed_time_s(self):\n        if self._start_time:\n            return (datetime.datetime.now() - self._start_time).total_seconds()\n        else:\n            return 0", "response": "Returns the amount of time that has elapsed since the timer was started."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _manage_commands():\n    for name, (command, *aliases) in COMMANDS.items():\n        COMMAND_MAPPER[name] = command\n        for alias in aliases:\n            COMMAND_MAPPER[alias] = command\n        COMMAND_ALIASES[name] = aliases", "response": "Build COMMAND_MAPPER and COMMAND_ALIASES dictionaries using COMMANDS\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(name, *args, **kwargs):\n    cmd = COMMAND_MAPPER.get(name)\n    return cmd(*args, **kwargs)", "response": "Find command class for given command name and return it s instance\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove an item from the set. Inverts the add operation.", "response": "def remove(self, item):\n        \"\"\"Remove an item from the set. Inverts the add operation.\n\n        >>> from ngram import NGram\n        >>> n = NGram(['spam', 'eggs'])\n        >>> n.remove('spam')\n        >>> list(n)\n        ['eggs']\n        \"\"\"\n        if item in self:\n            super(NGram, self).remove(item)\n            del self.length[item]\n            for ngram in self.splititem(item):\n                del self._grams[ngram][item]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef version(self, version):\n        if isinstance(version, type_check):\n            self._version = int(version)\n        elif isinstance(version, int):\n            self._version = version", "response": "Cast string versions to int"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns only the JSON attributes required when interfacing with the AMaaS Core services.", "response": "def to_interface(self):\n        \"\"\"\n        Returns only the JSON attributes required when interfacing with the AMaaS Core services.\n        Non-interface attributes are popped out.\n        :return:\n        \"\"\"\n        dict_to_convert = self.__dict__\n        [dict_to_convert.pop(attr) for attr in self.non_interface_attributes()]\n        return self.to_json(dict_to_convert)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stringToDate(fmt=\"%Y-%m-%d\"):\r\n    import time\r\n    import datetime\r\n    def conv_func(s):\r\n        return datetime.date(*time.strptime(s,fmt)[:3])\r\n    return conv_func", "response": "returns a function to convert a string to a datetime. date instance using the formatting string fmt as in time. strftime"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef PyDbLite_to_csv(src,dest=None,dialect='excel'):\r\n    import csv\r\n    fieldnames = [\"__id__\",\"__version__\"]+src.fields\r\n    if dest is None:\r\n        dest = open(os.path.splitext(src.name)[0]+'.csv','w')\r\n    w = csv.DictWriter(dest,fieldnames,dialect)\r\n    first = dict([(f,f) for f in fieldnames])\r\n    w.writerow(first) # first row has the field names\r\n    for r in src:\r\n        if not \"__version__\" in r:\r\n            r[\"__version__\"] = 0\r\n        w.writerow(r)\r\n    dest.close()", "response": "Convert a PyDbLite base to a CSV file"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a CSV file to a PyDbLite object.", "response": "def csv_to_PyDbLite(src,dest,fieldnames=None,fieldtypes=None,dialect='excel'):\r\n    \"\"\"Convert a CSV file to a PyDbLite base\r\n    src is the file object from which csv values are read\r\n    dest is the name of the PyDbLite base\r\n    If fieldnames is not set, the CSV file *must* have row names \r\n    in the first line\r\n    fieldtypes is a dictionary mapping field names to a function\r\n    used to convert the string read from the CSV file to the value\r\n    that will be stored in the PyDbLite base. For instance, if the\r\n    field is an integer, the function is the built-in int() function\"\"\"\r\n    import csv\r\n    import PyDbLite\r\n    if not fieldnames:\r\n        _in = csv.DictReader(open(src),fieldnames=fieldnames)\r\n        _in.next()\r\n        fieldnames = _in.fieldnames\r\n    out = PyDbLite.Base(dest)\r\n    kw = {\"mode\":\"override\"}\r\n    out.create(*_in.fieldnames,**kw)\r\n    default_fieldtypes = {\"__id__\":int,\"__version__\":int}\r\n\r\n    if fieldtypes is None:\r\n        fieldtypes = default_fieldtypes\r\n    else:\r\n        fieldtypes.update(default_fieldtypes)\r\n    _in = csv.DictReader(open(src),fieldnames=fieldnames)\r\n    _in.next()\r\n    for row in _in:\r\n        for k in fieldtypes:\r\n            try:\r\n                row[k] = fieldtypes[k](row[k])\r\n            except:\r\n                print k,row[k],fieldtypes[k]\r\n                raise\r\n        out.insert(**row)\r\n    out.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_series_by_name(self, series_name):\n        try:\n            return self.api.search_series(name=series_name), None\n        except exceptions.TVDBRequestException as err:\n            LOG.exception('search for series %s failed', series_name)\n            return None, _as_str(err)", "response": "Perform lookup for a series by name."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nperforms lookup for a specific series by its id.", "response": "def get_series_by_id(self, series_id):\n        \"\"\"Perform lookup for series\n\n        :param int series_id: series id of series\n        :returns: instance of series\n        :rtype: object\n        \"\"\"\n        try:\n            return self.api.get_series(series_id), None\n        except exceptions.TVDBRequestException as err:\n            LOG.exception('search for series %s failed', series_id)\n            return None, _as_str(err)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nperforming lookup for name of episode numbers for a given series.", "response": "def get_episode_name(self, series, episode_numbers, season_number):\n        \"\"\"Perform lookup for name of episode numbers for a given series.\n\n        :param object series: instance of a series\n        :param list episode_numbers: the episode sequence number\n        :param int season_number: numeric season of series\n        :returns: list of episode name\n        :rtype: list(str)\n        \"\"\"\n        try:\n            episodes = self.api.get_episodes(series.get('id'),\n                                             airedSeason=season_number)\n        except exceptions.TVDBRequestException as err:\n            LOG.exception('episodes for series %s season no %s failed',\n                          series.get('id'), season_number)\n            return None, _as_str(err)\n\n        epnames = []\n        for epno in episode_numbers:\n            epname = _get_epname(episodes, epno)\n            if epname is None:\n                epname = _get_epname(episodes, epno, absolute=True)\n                if epname is None:\n                    return None, None\n\n            epnames.append(epname)\n\n        return epnames, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntakes the parsed JSON output from json. load and checks it for common errors.", "response": "def validate_config_json(pjson):\n        \"\"\"Takes the parsed JSON (output from json.load) from a configuration file \n        and checks it for common errors.\"\"\"\n        # Make sure that the root json is a dict\n        if type(pjson) is not dict:\n            raise ParseError(\"Configuration file should contain a single JSON object/dictionary. Instead got a %s.\" \n                             % type(pjson))\n\n        # if 'configuration' is present it should be a dict of strings and numbers.\n        # The ArgumentParser will do the rest of the validation.\n        configuration = pjson.get('configuration', {})\n        if type(configuration) is not dict:\n            raise ParseError('''\"configuration\" object should be a dict, got %s instead.''' \n                             % type(configuration))\n\n        # Make sure that the 'tests' key is present \n        try:\n            tests = pjson[\"tests\"]\n        except KeyError:\n            raise KeyError(\"Configuration file requires 'tests' attribute.\")\n\n        # Verify that 'options' is a dict if present\n        options = pjson.get('options', {})\n        if type(options) is not dict:\n            raise ParseError('\"options\" attribute must be a dictionary\"')\n\n        # We need to know whether --user-defined-threads option is present to do \n        # the rest of the validation.\n        if '-u' in options.keys() or '--user-defined-threads' in options.keys():\n            ConfigurationValidator.validate_user_threaded_json(pjson)\n        else:\n            ConfigurationValidator.validate_auto_threaded_json(pjson)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntake a parsed JSON dict representing a set of tests in the user - threaded format and validates it.", "response": "def validate_user_threaded_json(pjson):\n        \"\"\"Takes a parsed JSON dict representing a set of tests in the user-threaded \n        format and validates it.\"\"\"\n        tests = pjson[\"tests\"]\n\n        # Verify that 'tests' is a two dimensional list\n        is_2d_list = lambda ls: len(ls) == len(filter(lambda l: type(l) is list, ls))\n        if type(tests) is not list or not is_2d_list(tests):\n            raise ParseError(\"'tests' should be a two-dimensional list of strings when '--user-defined-threads' is present.\")\n\n        # Verify that 'tests' sub-lists are of strings\n        for sublist in tests:\n            for test in sublist:\n                if type(test) is not unicode:\n                    raise TypeError(\n                        \"Expected a unicode string but got %s. 'tests' should be a two-dimensional list of strings when '--user-defined-threads is present.'\" \n                        % test\n                    )\n\n        # Verify that 'environments' key is not present\n        try:\n            pjson[\"environments\"]\n            raise ParseError(\"'environments' list is not allowed when --user-defined-threads is present.\")\n        except KeyError: pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking a parsed JSON dict representing a set of tests in the auto - threaded format and validates it descending recursively if necessary.", "response": "def validate_auto_threaded_json(pjson):\n        \"\"\"Takes a parsed JSON dict representing a set of tests in the auto-threaded\n        format and validates it, descending recursively if necessary.\"\"\"\n        # pjson should be a dict or unicode\n        if not type(pjson) is dict:\n            raise ParseError(\"Expected a JSON object/dictionary or a string representing a test. Instead got %s.\" \n                             % pjson)\n\n        # Make sure that the 'tests' key is present \n        try:\n            tests = pjson[\"tests\"]\n        except KeyError:\n            raise KeyError(\"Test object requires 'tests' attribute.\\nObject: %s\" % \n                           json.dumps(pjson))\n\n        # Verify that tests is a list\n        if type(tests) is not list:\n            raise ParseError(\n                \"Expected 'tests' to be a list but got object of type %s.\\nObject: %s\" %\n                (type(tests), json.dumps(tests))\n            )\n\n        # Verify that 'options' is a dict if present\n        options = pjson.get('options', {})\n        if type(options) is not dict:\n            raise ParseError('\"options\" attribute must be a dictionary')\n\n        # Verify that 'environments' is a list of dicts if present\n        environments = pjson.get('environments', [])\n        is_list_of_dicts = lambda ls: len(ls) == len(filter(lambda d: type(d) is dict, ls))\n        if type(environments) is not list or not is_list_of_dicts(environments):\n            raise ParseError('\"environments\" attribute must be a list of dictionaries. Instead got %s.' % environments)\n\n        for test in tests:\n            if type(test) is unicode:\n                # Base case for recursion\n                pass\n            else:\n                # Recur\n                ConfigurationValidator.validate_auto_threaded_json(test)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_args(self):\n      # Parse sys.argv\n      cli_args = self.parser.parse_args()\n\n      if cli_args.config:\n         # Parse the configuration file\n         config_file = open(cli_args.config, 'r')\n         config_json = json.load(config_file)\n         config_opts = config_json.get('options', {})\n\n         # Validate the configuration file\n         ConfigurationValidator.validate_config_json(config_json)\n\n         # Turn JSON options into a flat list of strings for the parser\n         args = reduce(lambda l, t: l + [str(t[0]), str(t[1])], config_opts.items(), [])\n         args = filter(lambda x: x is not None, args)\n\n         # Pass the configuration file options to the parser\n         config_args = self.parser.parse_args(args=args)\n         config_args.tests = config_json.get('tests', [])\n         config_args.configuration = config_json.get('configuration', {})\n         config_args.environments = config_json.get('environments', [])\n\n         args = config_args\n      else:\n         args = cli_args\n\n      \n      if args.log_level == \"INFO\":\n          args.log_level = LogLevel.INFO\n      elif args.log_level == \"WARN\":\n          args.log_level = LogLevel.WARN\n      elif args.log_level == \"DEBUG\":\n          args.log_level = LogLevel.DEBUG\n      else:\n          args.log_level = LogLevel.ERROR\n\n      return args", "response": "Parses the command - line arguments to this script and returns the resulting\n      options."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addElement(self, *ele):\n        for el in list(Models.flatten(ele)):\n            e = copy.deepcopy(el)\n            self._lattice_eleobjlist.append(e)\n            self._lattice_elenamelist.append(e.name)\n            self._lattice_elecnt += 1\n        # update lattice, i.e. beamline element\n\n        # self._lattice.setConf(Models.makeLatticeString(self._lattice_elenamelist))\n        self._lattice.setConf(Models.makeLatticeDict(self._lattice_elenamelist))\n\n        # positioning elements\n        self.initPos()\n\n        return self._lattice_elecnt", "response": "add element to lattice element list"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef initPos(self, startpos=0.0):\n        spos = startpos\n        for ele in self._lattice_eleobjlist:\n            # print(\"{name:<10s}: {pos:<10.3f}\".format(name=ele.name, pos=spos))\n            ele.setPosition(spos)\n            spos += ele.getLength()", "response": "initialize the elements position in the lattice"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the control configurations regarding to the PV names read PV value", "response": "def getCtrlConf(self, msgout=True):\n        \"\"\" get control configurations regarding to the PV names,\n            read PV value\n\n            :param msgout: print information if True (by default)\n            return updated element object list\n        \"\"\"\n        _lattice_eleobjlist_copy = copy.deepcopy(self._lattice_eleobjlist)\n        if self.mode == 'online':\n            for e in _lattice_eleobjlist_copy:\n                for k in (set(e.simukeys) & set(e.ctrlkeys)):\n                    try:\n                        if msgout:\n                            print(\"Reading from %s...\" % e.ctrlinfo[k]['pv'])\n                        pvval = epics.caget(e.ctrlinfo[k]['pv'])\n                        if pvval is not None:\n                            e.simuinfo[k] = e.unitTrans(pvval, direction='+')\n                            if msgout:\n                                print(\"  Done.\")\n                        else:\n                            if msgout:\n                                print(\"  Failed.\")\n                    except:\n                        pass\n        else:  # self.mode is 'simu' do nothing\n            pass\n        return _lattice_eleobjlist_copy"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef putCtrlConf(self, eleobj, ctrlkey, val, type='raw'):\n        if ctrlkey in eleobj.ctrlkeys:\n            if type == 'raw':\n                newval = val\n            else:  # val should be translated\n                newval = eleobj.unitTrans(val, direction='-')\n            epics.caput(eleobj.ctrlinfo[ctrlkey]['pv'], newval)\n            return True\n        else:\n            return False", "response": "put the value to the control PV field"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn all element configurations as json string file. could be further processed by beamline.Lattice class :param fmt: 'json' (default) or 'dict'", "response": "def getAllConfig(self, fmt='json'):\n        \"\"\"\n            return all element configurations as json string file.\n            could be further processed by beamline.Lattice class\n\n            :param fmt: 'json' (default) or 'dict'\n        \"\"\"\n        for e in self.getCtrlConf(msgout=False):\n            self._lattice_confdict.update(e.dumpConfig(type='simu'))\n        self._lattice_confdict.update(self._lattice.dumpConfig())\n        if fmt == 'json':\n            return json.dumps(self._lattice_confdict)\n        else:\n            return self._lattice_confdict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef updateConfig(self, eleobj, config, type='simu'):\n        eleobj.setConf(config, type=type)", "response": "write new configuration to element object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nflatten recursively defined list of objects", "response": "def flatten(ele):\n        \"\"\" flatten recursively defined list,\n            e.g. [1,2,3, [4,5], [6,[8,9,[10,[11,'x']]]]]\n\n            :param ele: recursive list, i.e. list in list in list ...\n            :return: generator object\n        \"\"\"\n        for el in ele:\n            if isinstance(el, list) or isinstance(el, tuple):\n                for e in Models.flatten(el):\n                    yield e\n            else:\n                yield el"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets elements with given name return list of element objects regarding to name", "response": "def getElementsByName(self, name):\n        \"\"\" get element with given name,\n            return list of element objects regarding to 'name'\n\n            :param name: element name, case sensitive, if elements are\n                auto-generated from LteParser, the name should be lower cased.\n        \"\"\"\n        try:\n            return filter(lambda x: x.name == name, self._lattice_eleobjlist)\n        except:\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprints out all modeled elements", "response": "def printAllElements(self):\n        \"\"\" print out all modeled elements\n        \"\"\"\n        cnt = 1\n        print(\"{id:<3s}: {name:<12s} {type:<10s} {classname:<10s}\"\n              .format(id='ID', name='Name', type='Type', classname='Class Name'))\n        for e in self._lattice_eleobjlist:\n            print(\"{cnt:>03d}: {name:<12s} {type:<10s} {classname:<10s}\"\n                  .format(cnt=cnt, name=e.name, type=e.typename, classname=e.__class__.__name__))\n            cnt += 1"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndraw the lattice visualization of the current object", "response": "def draw(self, startpoint=(0, 0), mode='plain', showfig=False):\n        \"\"\" lattice visualization\n            \n            :param startpoint: start drawing point coords, default: (0, 0)\n            :param showfig: show figure or not, default: False\n            :param mode: artist mode, 'plain' or 'fancy', 'plain' by default\n            :return: patchlist, anotelist, (xmin0, xmax0), (ymin0, ymax0)\n                patchlist: list of element patches\n                anotelist: list of annotations\n                (xmin0, xmax0) and (ymin0, ymax0) are ploting range\n        \"\"\"\n        p0 = startpoint\n        angle = 0.0\n        patchlist = []\n        anotelist = []\n        xmin0, xmax0, ymin0, ymax0 = 0, 0, 0, 0\n        xmin, xmax, ymin, ymax = 0, 0, 0, 0\n        for ele in self._lattice_eleobjlist:\n            ele.setDraw(p0=p0, angle=angle, mode=mode)\n            angle += ele.next_inc_angle\n            # print(ele.name + ele.next_inc_angle + angle)\n            patchlist.extend(ele._patches)\n            if hasattr(ele, '_anote'):\n                anotelist.append(ele._anote)\n            try:\n                p0 = ele.next_p0\n                xyrange = ele._patches[0].get_path().get_extents()\n                xmin, xmax = xyrange.xmin, xyrange.xmax\n                ymin, ymax = xyrange.ymin, xyrange.ymax\n            except:\n                pass\n            xmin0 = min(xmin, xmin0)\n            xmax0 = max(xmax, xmax0)\n            ymin0 = min(ymin, ymin0)\n            ymax0 = max(ymax, ymax0)\n\n        # show figure or not\n        if showfig:\n            fig = plt.figure()\n            ax = fig.add_subplot(111, aspect='equal')\n            [ax.add_patch(i) for i in patchlist]\n            [ax.annotate(s=i['name'],\n                         xy=i['xypos'],\n                         xytext=i['textpos'],\n                         arrowprops=dict(arrowstyle='->'),\n                         rotation=-90,\n                         fontsize='small')\n             for i in anotelist]\n            ax.set_xlim([xmin0 * 2, xmax0 * 2])\n            ax.set_ylim([ymin0 * 2, ymax0 * 2])\n            plt.show()\n\n        return patchlist, anotelist, (xmin0, xmax0), (ymin0, ymax0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef anoteElements(ax, anotelist, showAccName=False, efilter=None, textypos=None, **kwargs):\n        defaultstyle = {'alpha': 0.8, 'arrowprops': dict(arrowstyle='->'),\n                        'rotation': -60, 'fontsize': 'small'}\n        defaultstyle.update(kwargs)\n        anote_list = []\n        if efilter is None:\n            for anote in anotelist:\n                if textypos is None:\n                    textxypos = tuple(anote['textpos'])\n                else:\n                    textxypos = tuple((anote['textpos'][0], textypos))\n                if not showAccName and anote['type'] in ('RFCW', 'RFDF'):\n                    kwstyle = {k: v for k, v in defaultstyle.items()}\n                    kwstyle.pop('arrowprops')\n                    note_text = ax.text(anote['atext']['xypos'][0], anote['atext']['xypos'][1],\n                                        anote['atext']['text'], **kwstyle)\n                else:\n                    note_text = ax.annotate(s=anote['name'], xy=anote['xypos'], xytext=textxypos, **defaultstyle)\n                anote_list.append(note_text)\n        else:\n            if not isinstance(efilter, tuple):\n                filter = tuple(efilter)\n            for anote in anotelist:\n                if anote['type'] in efilter:\n                    if textypos is None:\n                        textxypos = tuple(anote['textpos'])\n                    else:\n                        textxypos = tuple((anote['textpos'][0], textypos))\n                    if not showAccName and anote['type'] in ('RFCW', 'RFDF'):\n                        kwstyle = {k: v for k, v in defaultstyle.items()}\n                        kwstyle.pop('arrowprops')\n                        note_text = ax.text(anote['atext']['xypos'][0], anote['atext']['xypos'][1],\n                                            anote['atext']['text'], **kwstyle)\n                    else:\n                        note_text = ax.annotate(s=anote['name'], xy=anote['xypos'], xytext=textxypos, **defaultstyle)\n                    anote_list.append(note_text)\n        return anote_list", "response": "annotate elements to axes\n            "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndownloading genbank files from NCBI using Biopython Entrez.", "response": "def fetch_gbwithparts(list_of_NC_accessions, email, folder):\n\n    '''Download genbank files from NCBI using Biopython Entrez efetch.\n\n    Args:\n        list_of_NC_accessions (list): a list of strings, e.g ['NC_015758', 'NC_002695']\n        email (string):  NCBI wants your email\n        folder (string): Where the gb files download to, generally './genomes/'\n    '''\n\n    from Bio import Entrez\n    from time import sleep\n\n    print 'downloading genomes... please wait'\n\n    for item in list_of_NC_accessions:\n        Entrez.email = email\n        handle = Entrez.efetch(db=\"nuccore\",\n                               id=item,\n                               retmode='full',\n                               rettype='gbwithparts')\n        data = handle.read()\n\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n\n        with open('%s/%s.gb' % (folder,item), 'w') as textfile:\n            textfile.write(data)\n\n        print 'done downloading %s' % item\n        \n        sleep(2)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_combined_fasta(self, genome_list, genome_dir):\n        '''Generate a combined fasta using the genbank files.\n        \n            Args\n                genome_list (list)\n                genome_dir (string)\n        '''\n\n        fasta = []\n            \n        for genome in genome_list:\n            \n            full_path = genome_dir + genome\n            handle = open(full_path, \"rU\")\n            print 'making combined fasta for', genome\n            try:\n                seq_record = SeqIO.read(handle, 'genbank')\n                org_accession = seq_record.name\n                \n            except AssertionError,e:\n                print str(e), genome\n                        \n            for feature in seq_record.features:\n                if feature.type == 'CDS':\n                    try:                                  \n                        prot_accession = feature.qualifiers['protein_id'][0]\n                        prot_translation = feature.qualifiers['translation'][0]\n                        \n                        newfast = '>' + org_accession + ',' + prot_accession + \\\n                         '\\n' + prot_translation + '\\n'\n                        \n                        #if newfast not in fasta:\n                        fasta.append(newfast)\n                            \n                    except AttributeError,e:\n                        print \"organism %s, protein %s did not have \\\n                        the right attributes\" % (org_accession, prot_accession)\n                        print str(e)\n                    \n                    except KeyError,e:\n                        print \"organism %s, protein %s did not have \\\n                        the right key\" % (org_accession, prot_accession)\n                        print str(e)\n                          \n            handle.close()\n            \n            print \"%s proteins were added\" % len(fasta)\n\n            set_fasta = set(fasta)\n\n            print \"%s unique proteins were added -- dropping redundant ones\" % len(set_fasta)\n                                                \n        faastring = \"\".join(set_fasta)\n\n        write_fasta = open('combined_fasta', 'w')\n        write_fasta.write(faastring)\n        write_fasta.close()\n\n        return set_fasta", "response": "Generate a combined FASTA file for each protein in the list of genbank files."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd proteins to the list of organisms.", "response": "def add_protein_to_organisms(self, orgprot_list):\n\n        '''\n        Protein factory method.\n\n        Iterates through a list of SearchIO hit objects, matches\n        the accession against SeqRecord features for each organism.\n        If there is a match, the new Protein object is created and\n        stored in the protein list of that Organism.\n\n        Args\n            orgprot_list: a list Biopython SearchIO hit objects (I think).\n\n        '''\n\n        for org in self.organisms:\n\n            handle = open(org.genome_path, \"rU\")\n            print 'adding proteins to organism', org.accession\n            try:\n                seq_record = SeqIO.read(handle, \"genbank\")\n\n                feature_list = []\n\n                for id in orgprot_list:\n                    org_id = id.split(',')[0]\n                    prot_id = id.split(',')[1]\n\n                    if org.accession == org_id:\n                        for feature in seq_record.features:\n                            if feature.type == 'CDS':\n                                feat_prot_acc = feature.qualifiers['protein_id'][0]\n                                if feat_prot_acc == prot_id:\n                                    #print 'appending', hit_prot_acc\n                                    org.proteins.append(Protein(feature))\n\n                del(seq_record)\n\n            except ValueError,e:\n                print 'error for ', org.accession, str(e)\n\n            except AssertionError,e:\n                print 'error for ', org.accession, str(e)\n\n            except UnboundLocalError,e:\n                print 'error for ', org.accession, str(e)\n\n            except KeyError,e:\n                print 'error for ', org.accession, str(e)\n\n            handle.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_hits_to_proteins(self, hmm_hit_list):\n\n        '''Add HMMER results to Protein objects'''\n\n        for org in self.organisms:\n            print \"adding SearchIO hit objects for\", org.accession\n\n            for hit in hmm_hit_list:\n                hit_org_id = hit.id.split(',')[0]\n                hit_prot_id = hit.id.split(',')[1]\n\n                if org.accession == hit_org_id:\n                    for prot in org.proteins:\n                        if prot.accession == hit_prot_id:\n                            prot.hmm_hit_list.append(hit)", "response": "Add HMMER results to Protein objects"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds the loci of a given cluster size and maximum gap between members of the cluster.", "response": "def find_loci(self, cluster_size, maxgap, locusview=False, colordict=None):\n        \n        '''\n        Finds the loci of a given cluster size & maximum gap between cluster members.\n\n        Args\n            cluster_size (int): minimum number of genes in the cluster.\n            maxgap (int): max basepair gap between genes in the cluster.\n\n        Kwargs\n            locusview (bool): whether or not a map is generated for the locus_parent_organism\n            colordict (list): pass a pre-made color scheme for identified proteins\n\n        '''\n\n        if colordict != None:\n            self.search.protein_arrow_color_dict = colordict        \n\n        for organism in self.organisms:\n\n            print 'finding loci for', organism.name\n\n            #reset loci if there is something in there already\n            organism.loci = []\n            \n            orghits = []\n            for protein in organism.proteins:\n                if len(protein.hmm_hit_list) > 0:\n                    orghits.append((organism.accession, protein.accession, \n                                    protein.start_bp, protein.end_bp, protein))\n            \n            bp_start_pooled = [hit[2] for hit in orghits]  \n            \n            try:\n                clustered_data = self.cluster_number(bp_start_pooled, maxgap)\n            \n                significant_cluster_list = []\n                for cluster in clustered_data:\n                    if len(cluster) > cluster_size:\n                        significant_cluster_list.append(cluster)\n\n                #print significant_cluster_list\n                \n                for cluster in significant_cluster_list:\n                    proteins_in_locus = []\n                    cluster.sort()\n                    for bp_start in cluster:\n                        for hit in orghits:\n                            if bp_start == hit[2]:\n                                proteins_in_locus.append(hit[4])\n                    \n                    organism.loci.append(Locus(proteins_in_locus, \n                                               organism, \n                                               self.search.query_names, \n                                               locusview))\n\n            except IndexError,e:\n                print 'Index error', str(e), organism.name\n\n            print 'total of', str(len(organism.loci)), 'found for', organism.name"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_hmm_hit_list(self, hmm_hit_list):\n\n        '''\n        take a list of hmm hit results, take needed info,\n\n        '''\n\n        tuplist = []\n\n        for hit in hmm_hit_list:\n            for hsp in hit.hsps:\n                tup = tuplist.append((hit._query_id.split('_')[0],\n                                     hit.bitscore,\n                                     hit.evalue,\n                                     hsp.bias,\n                                     hsp.env_start,\n                                     hsp.env_end))\n    \n        cols = ['name','bitscore','evalue', 'bias', 'hsp_start','hsp_end']\n            \n        df = DataFrame(tuplist, columns=cols)\n        df.set_index('name', inplace=True)\n        return df", "response": "take a list of hmm hit results take needed info"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite a fasta file containing 16S rRNA sequences for a list of Organism objects", "response": "def write_16S_rRNA_fasta(self, org_list):\n\n        '''\n        Writes a fasta file containing 16S rRNA sequences\n        for a list of Organism objects,\n\n        The first 16S sequence found in the seq record object is used,\n        since it looks like there are duplicates\n        '''\n\n        fasta = []\n        for org in org_list:\n\n            handle = open(org.genome_path, \"rU\")\n\n\n            seq_record = SeqIO.read(handle, \"genbank\")\n\n            for feat in seq_record.features:\n                if feat.type == 'rRNA':\n                    if '16S ribosomal' in feat.qualifiers['product'][0]:\n                        start = feat.location.start.position\n                        end = feat.location.end.position\n\n                        if ((end - start) > 1400) & ((end - start) < 1700) :\n\n                            print 'rRNA sequence extracted for', org.accession\n\n                            fasta.append('>' + org.accession +\n                                         '\\n' + \n                                         str(feat.extract(seq_record.seq)) +\n                                          '\\n')\n\n                            org.rRNA16S_sequence = str(feat.extract(seq_record.seq))\n                            \n                            break\n\n                    \n        faastring = \"\".join(fasta)\n        filename = '16S-rRNA.fasta'\n        write_fasta = open(filename, 'w')\n        write_fasta.write(faastring)\n        write_fasta.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef import_tree_order_from_file(self, MyOrganismDB, filename):\n\n        '''\n        Import the accession list that has been ordered by position\n        in a phylogenetic tree. Get the index in the list, and\n        add this to the Organism object. Later we can use this position\n        to make a heatmap that matches up to a phylogenetic tree.\n        '''\n       \n        tree_order = [acc.strip() for acc in open(filename)]\n        #print tree_order\n\n        for org in MyOrganismDB.organisms:\n            for tree_accession in tree_order:\n                #print tree_accession\n                if org.accession == tree_accession:\n                    org.tree_order = tree_order.index(tree_accession)", "response": "Import the accession list that has been ordered by position\n        in a phylogenetic tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_hmmbuild(self):\n\n        '''\n        Generate hmm with hhbuild,\n        output to file. Also stores query names.\n        '''\n\n        for alignment in self.alignment_list:\n\n            print 'building Hmm for', alignment\n\n            alignment_full_path = self.alignment_dir + alignment\n            query_name = alignment.split(\"_\")[0]\n            self.query_names.append(query_name)\n\n            new_hmm= self.hmm_dir + query_name + \".hmm\"\n\n            hmmbuild_output = subprocess.call([\"hmmbuild\", new_hmm,\n             alignment_full_path])\n\n        print 'hhbuild complete for', self.query_names", "response": "Generate hmm with hhbuild output to file. Also stores query names."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef extract_hit_list_from_hmmsearch_results(self):\n\n        '''\n        Make a giant list of all the hit objects from\n        our search\n        '''\n\n        combined_list_of_hits = []\n\n        for result in self.hmm_result_list:\n            fullpath = self.hhsearch_result_folder + result\n            \n\n            se = SearchIO.read(fullpath, 'hmmer3-text')\n\n            sublist = []\n            for hit in se:\n                combined_list_of_hits.append(hit)\n                sublist.append(hit.id)\n            print 'extracted', str(len(sublist)), 'hits for', result\n            \n        return combined_list_of_hits", "response": "Extract the list of all the hits from the HMM search results."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a random color for all proteins in query_names stores these in a dict.", "response": "def make_protein_arrow_color_dict(self, query_names):\n\n        '''\n        Generates a random color for all proteins in query_names,\n        stores these in a dict.\n        '''\n\n        protein_arrow_color_dict = dict()\n\n        for protein in self.query_names:\n            protein_arrow_color_dict[protein] = (random(), random(), random())\n\n        return protein_arrow_color_dict"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\niterate through all the proteins in the DB and creates a hit_dataframe for each protein.", "response": "def parse_proteins(self,OrganismDB):\n\n        '''\n        Iterate through all the proteins in the DB,\n        creates a hit_dataframe for each protein.\n        '''\n\n        for org in OrganismDB.organisms:\n            for prot in org.proteins:\n                if len(prot.hmm_hit_list) > 0:\n                    try:\n                        prot.hit_dataframe = prot.parse_hmm_hit_list(prot.hmm_hit_list)\n                    except ValueError,e:\n                        print 'error for', org.name, prot.accession, str(e)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_best_hit_values_for_proteins(self, OrganismDB):\n\n        '''\n        Iterate through all proteins in the DB,\n        drop duplicates in the hit_dataframe, then store the maximum\n        hit information as protein attributes.\n        '''\n\n        for org in OrganismDB.organisms:\n            print 'setting best hit values for', org.name\n            for prot in org.proteins:\n                if len(prot.hmm_hit_list) > 0:\n                    try:\n                        dd_df = prot.hit_dataframe.drop_duplicates(subset='bitscore')\n                        try:\n                            prot.hit_name_best = dd_df.bitscore.idxmax()\n                            prot.hit_evalue_best = dd_df.ix[prot.hit_name_best].evalue\n                            prot.hit_bitscore_best = dd_df.ix[prot.hit_name_best].bitscore\n                            prot.hit_bias_best = dd_df.ix[prot.hit_name_best].bias\n                            prot.hit_start_best = dd_df.ix[prot.hit_name_best].hsp_start\n                            prot.hit_end_best = dd_df.ix[prot.hit_name_best].hsp_end\n                        except:\n                            print 'could not set best hit values for ', org.name\n\n                    except AttributeError:\n                        pass", "response": "Iterate through all proteins in the DB and set the best hit values for those proteins."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_heatmap(self, unstacked_df, singleletters):\n\n        fig, ax = plt.subplots(num=None, figsize=(10,len(unstacked_df)/3), dpi=80, facecolor='w', edgecolor='k')\n\n\n        #heatmap = ax.pcolor(unstacked_df, cmap=plt.cm.Reds, alpha=2, vmax = 5)\n        #heatmap = ax.pcolor(unstacked_df, cmap=plt.cm.gist_ncar_r, alpha=20, vmax = 20)\n        #heatmap = ax.pcolor(unstacked_df, cmap=plt.cm.YlGnBu, alpha=20, vmax = 2)\n        heatmap = ax.pcolor(unstacked_df, cmap=plt.cm.jet, alpha=10, vmax = 5)\n\n       # ax.set_title('140616 - Esp distribution in actinobacteria')\n\n        #cb = plt.colorbar(heatmap)\n        #cb.set_label('# of copies')\n\n        species_names_only = ['%s locus:%s' % (x[0],str(x[1])[-12:]) for x in unstacked_df.index.values]\n\n        ax.set_aspect('equal')\n        ax.yaxis.set_ticks(range(0, len(unstacked_df.values)))\n        ax.xaxis.set_ticks(range(0, len(unstacked_df.columns)))\n        ax.set_xticklabels(unstacked_df.columns, rotation='90')\n        ax.set_yticklabels(species_names_only)\n        #ax.set_yticklabels(unstacked_df.index.values)\n        ax.tick_params(axis='both', left='off', right='off', bottom='off', top='off')\n        #ax.set_xticks(np.range(data.shape[0])+0.5, minor=False)\n        #ax.set_yticks(np.range(data.shape[1])+0.5, minor=False)\n        #ax.invert_yaxis()\n        #ax.xaxis.tick_top()\n\n        plt.grid(True, color='black', ls='-', linewidth=0.5)\n\n        '''exerimental: displaying text on the heatmap'''\n\n        if singleletters != None:\n\n            for y in range(unstacked_df.values.shape[0]):\n                for x in range(unstacked_df.values.shape[1]):\n                    plt.text(x + 0.5, y + 0.5, '%.4s' % singleletters[(x)],\n                             horizontalalignment='center',\n                             verticalalignment='center',\n                             )  \n        plt.savefig(\"out.svg\")\n        plt.show()", "response": "Make a heatmap of the current cluster state."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef our_IsUsableForDesktopGUI(m):\n        if guess_bitDepth(Q.CGDisplayModeCopyPixelEncoding(m)) != 24:\n                return False\n        if Q.CGDisplayModeGetWidth(m) < 640:\n                return False\n        if Q.CGDisplayModeGetHeight(m) < 480:\n                return False\n        return True", "response": "A more leniant version of CGDisplayModeIsUsableForDesktopGUI"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_modeString(s):\n        refresh, width, height = None, None, None\n        if '@' in s:\n                s, refresh = s.split('@', 1)\n                refresh = int(refresh)\n        if 'x' in s:\n                width, height = [int(x) if x.strip() else None\n                                        for x in s.split('x', 1)]\n        elif s.strip():\n                width = int(s)\n        else:\n                width = None\n        return (width, height, refresh)", "response": "Parses a modeString like 1024 x 768 @ 60 into width height refresh"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format_modes(modes, full_modes=False, current_mode=None):\n        t = table.Table(((\n                '*' if mode == current_mode else '',                         # 0\n                str(Q.CGDisplayModeGetWidth(mode)),                          # 1\n                str(Q.CGDisplayModeGetHeight(mode)),                         # 2\n                '@'+shorter_float_str(Q.CGDisplayModeGetRefreshRate(mode)),  # 3\n                format_pixelEncoding(\n                                Q.CGDisplayModeCopyPixelEncoding(mode)))     # 4\n                        for mode in modes))\n        t.set_key(2, 'height')\n        t.set_key(3, 'rate')\n        t.set_key(4, 'depth')\n        t.set_alignment('height', 'l')\n        t.set_alignment('rate', 'l')\n        t.set_separator('height', ' x ')\n        created_flags_col = False\n        if full_modes:\n                t.append_col(tuple((' '.join(get_flags_of_mode(mode))\n                                        for mode in modes)), key='flags')\n                created_flags_col = True\n        else:\n                # Remove refresh rate and bit depth if they are all the same\n                if len(frozenset(t.get_col('rate'))) == 1:\n                        t.del_col('rate')\n                if len(frozenset(t.get_col('depth'))) == 1:\n                        t.del_col('depth')\n\n                # Show distinct IO flags when several modes appear the same\n                lut = {}\n                for i, row in enumerate(t):\n                        row = tuple(row)\n                        if row not in lut:\n                                lut[row] = []\n                        elif not created_flags_col:\n                                t.append_col(('',) * len(modes), key='flags')\n                        lut[row].append(i)\n                for rw, indices in lut.iteritems():\n                        if len(indices) == 1:\n                                continue\n                        flags = {}\n                        for i in indices:\n                                flags[i] = get_flags_of_mode(modes[i])\n                        common_flags = reduce(lambda x, y: x.intersection(y),\n                                        map(frozenset, flags.itervalues()))\n                        for i in indices:\n                                t[i, 'flags'] = ' '.join(frozenset(flags[i])\n                                                        - common_flags)\n        if created_flags_col:\n                t.set_alignment('flags', 'l')\n        return t", "response": "Formats a list of modes and returns a nice readily printable table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_private_investment(asset_manager_id=None, asset_id=None, client_id=None):\n    attributes = generate_common(asset_manager_id=asset_manager_id, asset_id=asset_id)\n    \"\"\"currency, display_name\"\"\"\n    private_investment = PrivateInvestment(client_id=client_id or random_string(5),\n                                           asset_issuer_id=random_string(8),\n                                           category='Private Equity', \n                                           sub_category='Leverage Buyout Funds',\n                                           num_shares=1000,\n                                           price_share=1000,\n                                           share_type='Ordinary Shares',\n                                           maturity_date=random_date(),\n                                           lock_up_period=52,\n                                           investment_term=52,\n                                           **attributes)\n    return private_investment", "response": "Generates a private investment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the node. :param attributes_flags: Attributes flags. :type attributes_flags: int", "response": "def __initialize_node(self, attributes_flags=int(Qt.ItemIsSelectable | Qt.ItemIsEnabled)):\n        \"\"\"\n        Initializes the node.\n\n        :param attributes_flags: Attributes flags.\n        :type attributes_flags: int\n        \"\"\"\n\n        self[\"traced\"] = umbra.ui.nodes.GraphModelAttribute(name=\"traced\",\n                                                            value=foundations.trace.is_traced(self.__module),\n                                                            flags=attributes_flags)\n        self.update_node_attributes()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_node_attributes(self, attributes_flags=int(Qt.ItemIsSelectable | Qt.ItemIsEnabled)):\n\n        self.traced.value = foundations.trace.is_traced(self.__module)\n        self.traced.roles[Qt.DisplayRole] = foundations.strings.to_string(self.traced.value).title()", "response": "Updates the Node attributes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef safer_format_traceback(exc_typ, exc_val, exc_tb):\n    lines = [\"Uncaught exception:\\n\"]\n    lines.extend(traceback.format_tb(exc_tb))\n    lines.append(\"%r\\n\" % (exc_typ,))\n    lines.append(\"%r\\n\" % (exc_val,))\n    return \"\".join(lines)", "response": "Format an exception traceback into a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef format(self, record):\n        out = dict(\n            Timestamp=int(record.created * 1e9),\n            Type=record.name,\n            Logger=self.logger_name,\n            Hostname=self.hostname,\n            EnvVersion=self.LOGGING_FORMAT_VERSION,\n            Severity=self.SYSLOG_LEVEL_MAP.get(record.levelno,\n                                               self.DEFAULT_SYSLOG_LEVEL),\n            Pid=record.process,\n        )\n\n        # Include any custom attributes set on the record.\n        # These would usually be collected metrics data.\n        fields = dict()\n        for key, value in record.__dict__.items():\n            if key not in self.EXCLUDED_LOGRECORD_ATTRS:\n                fields[key] = value\n\n        # Only include the 'message' key if it has useful content\n        # and is not already a JSON blob.\n        message = record.getMessage()\n        if message:\n            if not message.startswith(\"{\") and not message.endswith(\"}\"):\n                fields[\"msg\"] = message\n\n        # If there is an error, format it for nice output.\n        if record.exc_info is not None:\n            fields[\"error\"] = repr(record.exc_info[1])\n            fields[\"traceback\"] = safer_format_traceback(*record.exc_info)\n\n        out['Fields'] = fields\n\n        return json.dumps(out)", "response": "Formats a log record as JSON."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_candidate_splays(splays, azm, inc, delta=LRUD_DELTA):\n    return [splay for splay in splays\n            if\n            angle_delta(splay['AZM'], azm) <= delta/2\n            and\n            angle_delta(splay['INC'], inc) <= delta/2\n            ]", "response": "Given a list of splay shots find candidates LEFT or RIGHT given target AZM and INC"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a list of splay shots find candidate UP or DOWN given target INC ( 90 or - 90", "response": "def find_candidate_vert_splays(splays, inc, delta=LRUD_DELTA):\n    \"\"\"Given a list of splay shots, find candidate UP or DOWN given target INC (90, or -90)\"\"\"\n    # FIXME: perhaps this is the wrong approach. Should we simply select max of anything with negative/positive INC for DOWN/UP?\n    #return [splay for splay in splays if angle_delta(splay['INC'], inc) <= delta/2]\n    if inc == 90:\n        return [splay for splay in splays if splay['INC'] >= 30]\n    elif inc == -90:\n        return [splay for splay in splays if splay['INC'] <= -30]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef shot2shot(insurvey, inshot, calculate_lrud=True):\n    # FIXME: requires angles in degrees only, no grads\n\n    splays = insurvey.splays[inshot['FROM']]\n    if calculate_lrud and not inshot.is_splay and splays:\n        # Try our best to convert PocketTopo splay shots into LRUDs\n        print '\\n\\n' 'sta %s has %d splays' % (inshot['FROM'], len(splays))\n\n        left_azm, right_azm = (inshot['AZM'] - 90) % 360, (inshot['AZM'] + 90) % 360\n        left_shot, right_shot = None, None\n        left_candidates = find_candidate_splays(splays, left_azm, 0)\n        if left_candidates:\n            left_shot = max(left_candidates, key=lambda shot: hd(shot['INC'], shot['LENGTH']))\n            left = hd(left_shot['INC'], left_shot['LENGTH'])\n        else:\n            left = 0\n        right_candidates = find_candidate_splays(splays, right_azm, 0)\n        if right_candidates:\n            right_shot = max(right_candidates, key=lambda shot: hd(shot['INC'], shot['LENGTH']))\n            right = hd(right_shot['INC'], right_shot['LENGTH'])\n        else:\n            right = 0\n\n        print '\\t' 'left=%.1f  azm=%.1f  right=%.1f' % (left_azm, inshot['AZM'], right_azm)\n        print '\\t' '%d candidate LEFT shots' % len(left_candidates)\n        for splay in left_candidates:\n            print '\\t\\t\\t' + str(splay)\n        print '\\t\\t' '%.1f - Chose: %s' % (left, str(left_shot))\n        print '\\t' '%d candidate RIGHT shots' % len(right_candidates)\n        for splay in right_candidates:\n            print '\\t\\t\\t' + str(splay)\n        print '\\t\\t' '%.1f - Chose: %s' % (right, str(right_shot))\n\n        up_candidates = find_candidate_vert_splays(splays, 90)\n        if up_candidates:\n            up_shot = max(up_candidates, key=lambda splay: vd(splay['INC'], splay['LENGTH']))\n            up = vd(up_shot['INC'], up_shot['LENGTH'])\n        else:\n            up = 0\n        down_candidates = find_candidate_vert_splays(splays, -90)\n        if down_candidates:\n            down_shot = max(down_candidates, key=lambda splay: vd(splay['INC'], splay['LENGTH']))  # TODO: should vd() give negative and we find min()?\n            down = vd(down_shot['INC'], down_shot['LENGTH'])\n        else:\n            down = 0\n\n        print '\\t', inshot, 'LRUD=', ', '.join(('%0.1f' % v) for v in (left, right, up, down))\n        assert(all(v >=0 for v in (left, right, up, down)))\n    else:\n        up, down, left, right = None, None, None, None\n\n    return compass.Shot([\n        ('FROM', inshot['FROM']),\n        # Compass requires a named TO station, so we must invent one for splays\n        ('TO', inshot['TO'] or '%s.s%03d' % (inshot['FROM'], random.randint(0,1000))),\n        ('LENGTH', m2ft(inshot.length)),\n        # BEARING/AZM named inconsistently in Davies to reflect each program's arbitrary name. We\n        # can't use `inshot.azm` here because we need the \"raw\" compass value without declination\n        ('BEARING', inshot['AZM']),\n        ('INC', inshot.inc),\n        ('LEFT', m2ft(left) if left is not None else -9.90),\n        ('UP', m2ft(up) if left is not None else -9.90),\n        ('DOWN', m2ft(down) if left is not None else -9.90),\n        ('RIGHT', m2ft(right) if left is not None else -9.90),  # Compass requires this order!\n        # Compass 'L' flag excludes splays from cave length calculation\n        ('FLAGS', (compass.Exclude.LENGTH, compass.Exclude.PLOT) if inshot.is_splay else ()),\n        # COMMENTS/COMMENT named inconsistently in Davies to reflect each program's arbitrary name\n        ('COMMENTS', inshot['COMMENT'])\n    ])", "response": "Convert a PocketTopo Shot to Compass Shot"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pockettopo2compass(txtfilename, exclude_splays=False, calculate_lrud=False):\n    print 'Converting PocketTopo data file %s ...' % txtfilename\n\n    # Read our PocketTopo .TXT file, averaging triple-shots in the process\n    infile = pockettopo.TxtFile.read(txtfilename, merge_duplicate_shots=True)\n\n    cave_name = os.path.basename(txtfilename).rsplit('.', 1)[0].replace('_', ' ')\n    outfilename = txtfilename.rsplit('.', 1)[0] + '.DAT'\n\n    # Create the Compass DatFile in memory and start building, we'll write to file when done\n    outfile = compass.DatFile(cave_name)\n\n    for insurvey in infile:\n        # Our Compass and PocketTopo Surveys are very similar...\n        outsurvey = compass.Survey(\n            insurvey.name, insurvey.date, comment=insurvey.comment, cave_name=cave_name, declination=insurvey.declination\n        )\n        outsurvey.length_units = 'M'\n        outsurvey.passage_units = 'M'\n        \n        for inshot in insurvey:\n            if inshot.is_splay and exclude_splays:\n                continue  # skip\n\n            # ...but the Shot data fields require some tweaking, see `shot2shot()` for details\n            outshot = shot2shot(insurvey, inshot, calculate_lrud)\n            outsurvey.add_shot(outshot)\n\n        outfile.add_survey(outsurvey)\n\n        # DEBUG\n        #for station, splays in list(insurvey.splays.items()):\n        #    print 'sta %s has %d splays' % (station, len(splays))\n\n    # Finally all built, dump the whole DatFile/Surveys/Shots structure to file\n    outfile.write(outfilename)\n    print 'Wrote Compass data file %s .' % outfilename", "response": "This function converts a PocketTopo. TXT file to a Compass. DAT file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the match for the current location.", "response": "def matchCalculate(self, latlengthname='fullat.hghg'):\n        m0 = 9.10938215e-31\n        e0 = 1.602176487e-19\n        c0 = 299792458\n\n        modparams = ParseParams(self.infile_mod, self.latfile_mod)\n        gamma0 = modparams.getElectronGamma()\n        emitn = modparams.getElectronEmitx()\n        am = modparams.getUndulatorParameter()\n        lambdam = modparams.getUndulatorPeriod()\n\n        radparams = ParseParams(self.infile_rad, self.latfile_rad)\n        au = radparams.getUndulatorParameter()\n        lambdau = radparams.getUndulatorPeriod()\n        imagl = radparams.getChicaneMagnetLength()\n        idril = radparams.getChicaneDriftLength()\n        ibfield = radparams.getChicaneMagnetField()\n\n        lo1, lum, lo2, lo3, lf, lo4, lur, lo5, ld = parseLattice(latlengthname)\n\n        kp, kn = self.qfval, self.qdval\n        Kp = e0 * kp / m0 / c0 / sqrt(gamma0 ** 2 - 1)\n        Kn = e0 * kn / m0 / c0 / sqrt(gamma0 ** 2 - 1)\n\n        lambdas = lambdau / 2.0 / gamma0 ** 2 * (1 + au ** 2) * 1.0e9\n\n        ku = 2.0 * np.pi / lambdau\n        Ku = sqrt(2.0) * au\n        Kbetau = 0.5 * (Ku * ku / gamma0) ** 2\n\n        Km = sqrt(2.0) * am\n        km = 2.0 * np.pi / lambdam\n        Kbetam = 0.5 * (Km * km / gamma0) ** 2\n\n        # print(\" \".join([Kp,Kn,lambdas,ku,Ku,Kbetau,Km,km,Kbetam,lambdau,lambdam])\n\n        N = np.array([lo3, lf * 0.5, lo4, lur, lo5, ld, lo4, lur, lo5, 0.5 * lf])\n        # one FODO period: N[1:], N[0]: drift length before QF\n\n        mx = mathutils.funTransQuadF(Kp, N[1] * lambdau) * mathutils.funTransDrift(\n            N[2] * lambdau) * mathutils.funTransUnduH(N[3] * lambdau) * mathutils.funTransDrift(\n            N[4] * lambdau) * mathutils.funTransQuadF(Kn, N[5] * lambdau) * mathutils.funTransDrift(\n            N[6] * lambdau) * mathutils.funTransUnduH(N[7] * lambdau) * mathutils.funTransDrift(\n            N[8] * lambdau) * mathutils.funTransQuadF(Kp, N[9] * lambdau)\n        if (mx[0, 0] + mx[1, 1]) ** 2 > 4 or mx[0, 1] <= 0:\n            self.matchOK = False\n            return self.matchOK\n\n        my = mathutils.funTransQuadF(-Kp, N[1] * lambdau) * mathutils.funTransDrift(\n            N[2] * lambdau) * mathutils.funTransUnduV(Kbetau, N[3] * lambdau) * mathutils.funTransDrift(\n            N[4] * lambdau) * mathutils.funTransQuadF(-Kn, N[5] * lambdau) * mathutils.funTransDrift(\n            N[6] * lambdau) * mathutils.funTransUnduV(Kbetau, N[7] * lambdau) * mathutils.funTransDrift(\n            N[8] * lambdau) * mathutils.funTransQuadF(-Kp, N[9] * lambdau)\n        if (my[0, 0] + my[1, 1]) ** 2 > 4 or my[0, 1] <= 0:\n            self.matchOK = False\n            return self.matchOK\n\n        # print(mx)\n        # print(my)\n\n        ## twiss parameters of FODO\n        # mx\n        alphax_FODO = (mx[0, 0] - mx[1, 1]) / sqrt(4.0 - (mx[0, 0] + mx[1, 1]) ** 2)\n        betax_FODO = 2.0 * mx[0, 1] / sqrt(4.0 - (mx[0, 0] + mx[1, 1]) ** 2)\n        gammax_FODO = (1.0 + alphax_FODO ** 2) / betax_FODO\n        # my\n        alphay_FODO = (my[0, 0] - my[1, 1]) / sqrt(4.0 - (my[0, 0] + my[1, 1]) ** 2)\n        betay_FODO = 2.0 * my[0, 1] / sqrt(4.0 - (my[0, 0] + my[1, 1]) ** 2)\n        gammay_FODO = (1.0 + alphay_FODO ** 2) / betay_FODO\n\n        ## match to the entrance of radiator\n        # forward match to 'O + QF/2'\n        AX = mathutils.funTransQuadF(Kp, N[1] * lambdau) * mathutils.funTransDrift(N[0] * lambdau)\n        AY = mathutils.funTransQuadF(-Kp, N[1] * lambdau) * mathutils.funTransDrift(N[0] * lambdau)\n        AX = inv(AX)\n        AY = inv(AY)\n        Nx = np.matrix([[AX[0, 0] ** 2, -2 * AX[0, 0] * AX[0, 1], AX[0, 1] ** 2],\n                        [-AX[0, 0] * AX[1, 0], 1 + 2 * AX[0, 1] * AX[1, 0], -AX[0, 1] * AX[1, 1]],\n                        [AX[1, 0] ** 2, -2 * AX[1, 0] * AX[1, 1], AX[1, 1] ** 2]])\n        Ny = np.matrix([[AY[0, 0] ** 2, -2 * AY[0, 0] * AY[0, 1], AY[0, 1] ** 2],\n                        [-AY[0, 0] * AY[1, 0], 1 + 2 * AY[0, 1] * AY[1, 0], -AY[0, 1] * AY[1, 1]],\n                        [AY[1, 0] ** 2, -2 * AY[1, 0] * AY[1, 1], AY[1, 1] ** 2]])\n\n        Bx = Nx * np.matrix([[betax_FODO], [alphax_FODO], [gammax_FODO]])\n        By = Ny * np.matrix([[betay_FODO], [alphay_FODO], [gammay_FODO]])\n\n        betax_rad = Bx[0, 0]\n        betay_rad = By[0, 0]\n        alphax_rad = Bx[1, 0]\n        alphay_rad = By[1, 0]\n        gammax_rad = Bx[2, 0]\n        gammay_rad = By[2, 0]\n        sigmax_rad = sqrt(betax_rad * emitn / gamma0)\n        sigmay_rad = sqrt(betay_rad * emitn / gamma0)\n\n        # matched beam for radiator input \n        self.alphax_rad = alphax_rad\n        self.alphay_rad = alphay_rad\n        self.sigmax_rad = sigmax_rad\n        self.sigmay_rad = sigmay_rad\n\n        ## forward match to mod + chicane, find configurations for mod input\n        AX = mathutils.funTransChica(imagl, idril, ibfield, gamma0, 'x') * mathutils.funTransDrift(\n            lo2 * lambdam) * mathutils.funTransUnduH(lum * lambdam) * mathutils.funTransDrift(lo1 * lambdam)\n        AY = mathutils.funTransChica(imagl, idril, ibfield, gamma0, 'y') * mathutils.funTransDrift(\n            lo2 * lambdam) * mathutils.funTransUnduV(Kbetam, lum * lambdam) * mathutils.funTransDrift(lo1 * lambdam)\n        AX = inv(AX)\n        AY = inv(AY)\n        Nx = np.matrix([[AX[0, 0] ** 2, -2 * AX[0, 0] * AX[0, 1], AX[0, 1] ** 2],\n                        [-AX[0, 0] * AX[1, 0], 1 + 2 * AX[0, 1] * AX[1, 0], -AX[0, 1] * AX[1, 1]],\n                        [AX[1, 0] ** 2, -2 * AX[1, 0] * AX[1, 1], AX[1, 1] ** 2]])\n        Ny = np.matrix([[AY[0, 0] ** 2, -2 * AY[0, 0] * AY[0, 1], AY[0, 1] ** 2],\n                        [-AY[0, 0] * AY[1, 0], 1 + 2 * AY[0, 1] * AY[1, 0], -AY[0, 1] * AY[1, 1]],\n                        [AY[1, 0] ** 2, -2 * AY[1, 0] * AY[1, 1], AY[1, 1] ** 2]])\n        Bx = Nx * np.matrix([[betax_rad], [alphax_rad], [gammax_rad]])\n        By = Ny * np.matrix([[betay_rad], [alphay_rad], [gammay_rad]])\n\n        betax_mod = Bx[0, 0]\n        betay_mod = By[0, 0]\n        alphax_mod = Bx[1, 0]\n        alphay_mod = By[1, 0]\n        gammax_mod = Bx[2, 0]\n        gammay_mod = By[2, 0]\n        sigmax_mod = sqrt(betax_mod * emitn / gamma0)\n        sigmay_mod = sqrt(betay_mod * emitn / gamma0)\n\n        # matched beam for modulator input \n        self.alphax_mod = alphax_mod\n        self.alphay_mod = alphay_mod\n        self.sigmax_mod = sigmax_mod\n        self.sigmay_mod = sigmay_mod\n\n        \"\"\"\n        print(\"gamma0 : %.4e\" % gamma0 )\n        print(\"emitn  : %.4e\" % emitn  )\n        print(\"aw0m   : %.4f\" % am     )\n        print(\"xlamdm : %.4f\" % lambdam)\n        print(\"aw0r   : %.4f\" % au     )\n        print(\"xlamdr : %.4f\" % lambdau)\n        print(\"imagl  : %.4f\" % imagl  )\n        print(\"idril  : %.4f\" % idril  )\n        print(\"ibfield: %.4f\" % ibfield)\n        \"\"\"\n\n        return self.matchOK"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef encode_df(df, data_types={}):\n\n    numbers = []\n    categories = []\n    datetimes = []\n        \n    for column, series in df.iteritems():\n        if column in data_types:\n            dtypes = data_types[column]\n        else:\n            dtypes = {}\n        \n        if 'datetime' in dtypes:\n            index = pd.DatetimeIndex(pd.to_datetime(series.values))\n            df[column] = index.astype(np.int64).astype(float)\n            datetimes.append(column)\n            \n        elif any([dtype in dtypes for dtype in ['category', 'label']]):\n            # If this can be treated as a category, encode it\n            df = pd.get_dummies(df,columns=[column])\n            categories.append(column)\n                    \n        elif 'numeric' in dtypes:\n            df[column] = clean_numbers(df[column].values)\n            df[column] = df[column].astype(float)\n            numbers.append(column)\n            \n        else:\n            df.drop(column,1,inplace=True)\n\n    # Scale continuous columns\n    scaler = MinMaxScaler()\n    df[numbers + datetimes] = scaler.fit_transform(df[numbers + datetimes])\n    \n    return df, categories, numbers, datetimes", "response": "Encode columns so their values are usable in vector operations."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_allowed_internal_commands(self):\n        states = set()\n        for command_name in self._get_all_commands(including_quit=True):\n            if command_name not in ['GREET', 'MSGDATA']:\n                states.add(command_name)\n        return states", "response": "Returns an iterable which includes all allowed internal commands."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding the NOOP and QUIT transitions to all states in the system.", "response": "def _add_help_noop_and_quit_transitions(self):\n        \"\"\"HELP, NOOP and QUIT should be possible from everywhere so we\n        need to add these transitions to all states configured so far.\"\"\"\n        states = set()\n        for state_name in self.state.known_states():\n            if state_name not in ['new', 'finished']:\n                states.add(state_name)\n        for state in states:\n            self._add_state(state, 'NOOP',  state)\n            self._add_state(state, 'HELP',  state)\n            self._add_state(state, 'QUIT',  'finished')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_ehlo_lines(self):\n        lines = []\n        if self._authenticator != None:\n            # TODO: Make the authentication pluggable but separate mechanism\n            # from user look-up.\n            lines.append('AUTH PLAIN')\n        if self._policy != None:\n            lines.extend(self._policy.ehlo_lines(self._message.peer))\n        lines.append('HELP')\n        return lines", "response": "Return the capabilities to be advertised after EHLO."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef handle_input(self, smtp_command, data=None):\n        self._command_arguments = data\n        self.please_close_connection_after_response(False)\n        # SMTP commands must be treated as case-insensitive\n        command = smtp_command.upper()\n        try:\n            try:\n                self.state.execute(command)\n            except StateMachineError:\n                if command not in self.valid_commands:\n                    self.reply(500, 'unrecognized command \"%s\"' % smtp_command)\n                else:\n                    msg = 'Command \"%s\" is not allowed here' % smtp_command\n                    allowed_transitions = self.state.allowed_actions()\n                    if len(allowed_transitions) > 0:\n                        msg += ', expected on of %s' % allowed_transitions\n                        self.reply(503, msg)\n            except InvalidDataError:\n                e = sys.exc_info()[1]\n                self.reply(501, e.msg())\n            except InvalidParametersError:\n                # TODO: Get rid of InvalidParametersError, shouldn't be\n                # necessary anymore\n                e = sys.exc_info()[1]\n                if not e.response_sent:\n                    msg = 'Syntactically invalid %s argument(s)' % smtp_command\n                    self.reply(501, msg)\n            except PolicyDenial:\n                e = sys.exc_info()[1]\n                if not e.response_sent:\n                    self.reply(e.code, e.reply_text)\n        finally:\n            if self.should_close_connection_after_response():\n                self.close_connection()\n            self._command_arguments = None", "response": "Processes the given SMTP command with the given data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef close_connection(self):\n        \"Request a connection close from the SMTP session handling instance.\"\n        if self._is_connected:\n            self._is_connected = False\n            self._command_parser.close_when_done()", "response": "Request a connection close from the SMTP session handling instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating version string in project files", "response": "def update_project_files(cfg, proj_version):\n    \"\"\"\n    Update version string in project files\n\n    :rtype : dict\n    :param cfg:project configuration\n    :param proj_version:current version\n    :return:dict :raise ValueError:\n    \"\"\"\n    counters = {'files': 0, 'changes': 0}\n\n    for project_file in cfg.files:\n        if not project_file.file.exists():\n            print(\"File \\\"%s\\\" not found\" % project_file.filename, file=sys.stderr)\n            continue\n\n        # prepare data\n        date_format = project_file.date_format or cfg.date_format\n\n        rxp = re.compile(project_file.search, project_file.search_flags)\n        replace = project_file.replace % {\n            \"date\": time.strftime(date_format),\n            \"major\": proj_version.major,\n            \"minor\": proj_version.minor,\n            \"patch\": proj_version.patch,\n            \"prerelease\": proj_version.prerelease,\n            \"version\": str(proj_version),\n            \"build\": proj_version.build,\n        }\n\n        # update project files\n        with \\\n                project_file.file.open(mode=\"r\", encoding=project_file.encoding) as fh_in, \\\n                tempfile.NamedTemporaryFile(mode=\"w\", encoding=project_file.encoding, delete=False) as fh_out:\n            if project_file.match == 'line':\n                changes = 0\n                for line in fh_in:\n                    (line, cnt) = rxp.subn(replace, line)\n                    if cnt:\n                        changes += cnt\n                    fh_out.write(line)\n\n                if changes:\n                    counters['files'] += 1\n                    counters['changes'] += changes\n\n            elif project_file.match == 'file':\n                data = fh_in.read()\n                (data, cnt) = rxp.subn(replace, data)\n                if cnt:\n                    counters['files'] += 1\n                    counters['changes'] += cnt\n                fh_out.write(data)\n\n            else:\n                raise ConfigError(\"Unknown match type: \\\"%s\\\"\" % project_file.match)\n\n            fh_out.close()\n\n            shutil.copystat(project_file.filename, fh_out.name)\n            pathlib.Path(fh_out.name).rename(project_file.filename)\n\n    return counters"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving version to version_file and commit changes if required is True", "response": "def save_version_and_update_files(cfg, version_file, version_to_save):\n    \"\"\"Save version to version_file and commit changes if required\n\n    :param cfg:\n    :param version_file:\n    :param version_to_save:\n    :return:\n    \"\"\"\n    with vcs.VCS(cfg.vcs_engine) as vcs_handler:\n        if cfg.commit:\n            vcs_handler.raise_if_cant_commit()\n\n        version_file.write(version_to_save)\n\n        quant = update_project_files(cfg, version_to_save)\n\n        if cfg.commit:\n            files = {str(file.file) for file in cfg.files}\n            files.add(str(cfg.version_file))\n            vcs_handler.add_to_stage(files)\n            vcs_handler.create_commit(cfg.vcs_commit_message % {'version': version_to_save})\n\n    return quant"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ratio(self, ratio):\n        if isinstance(ratio, tuple):\n            self._ratio = ratio\n        else:\n            raise TypeError('Invalid ratio type: %s' % type(ratio))", "response": "Sets the ratio of the corporate action - i. e. the ratio of new shares to old shares."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the canonical time string format.", "response": "def get_time_string(time_gmt=None):\n    \"\"\"The canonical time string format (in UTC).\n\n    :keyword time_gmt: this is a time_struct, datetime class, or None. If None,\n        the current time is used. Its name, time_gmt, is for legacy support for\n        functions that called it before it supported multiple values.\n\n    Changing this function will change all times that projects using simpl\n        return in their APIs.\n    \"\"\"\n    if isinstance(time_gmt, datetime.datetime):\n        time_gmt = time_gmt.timetuple()\n    if time_gmt is None:\n        time_gmt = time.gmtime()\n    if isinstance(time_gmt, time.struct_time):\n        return time.strftime(API_FORMAT, time_gmt)\n    raise TypeError(\"time_gmt must be a time_struct, datetime, or None. A %s \"\n                    \"was passed.\" % type(time_gmt))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching the feature - pacts for a given pull request on github.", "response": "def fetch_feature_pacts(pull_request_url: str) -> FrozenSet[str]:\n    \"\"\"Fetch the feature-pacts for a given pull request on github. This is useful for CI builds\n    that have access to their associated pull requests.\n    Expects a pull_request_url like 'https://github.com/zhammer/morning-cd/pull/17' with a PR body\n    that includes a line 'feature-pacts: zh-feature-a, eh-feature-b'. If there is no 'feature-pacts'\n    line, this will return an empty set.\n    \"\"\"\n    pr_info = _pluck_pull_request_info(pull_request_url)\n    r = requests.get(\n        f'https://api.github.com/repos/{pr_info.owner}/{pr_info.repo}/pulls/{pr_info.number}'\n    )\n    if not r.status_code == requests.codes.all_good:\n        raise GithubPrError(f'Error fetching pr {pr_info} from github. Response: {r.text}.')\n\n    body = cast(str, r.json()['body'])\n    return _pluck_feature_pacts(body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a set of all the feature - pacts in the body.", "response": "def _pluck_feature_pacts(pr_body: str) -> FrozenSet[str]:\n    \"\"\"\n    # Returns set with one feature pact if specified\n    >>> body = 'gitlab: mygitlaburl.com\\\\r\\\\nfeature-pacts: zh-feature-a'\n    >>> _pluck_feature_pacts(body) == frozenset({'zh-feature-a'})\n    True\n\n    # Returns set with multiple feature pacts if specified\n    >>> body = 'gitlab: mygitlaburl.com\\\\r\\\\nfeature-pacts: zh-feature-a eh-feature-b\\\\r\\\\nurgent!'\n    >>> _pluck_feature_pacts(body) == frozenset({'zh-feature-a', 'eh-feature-b'})\n    True\n\n    # Returns empty set if no feature-pacts line\n    >>> body = 'gitlab: mygitlaburl.com\\\\r\\\\n\\\\r\\\\nJust adding some documentation'\n    >>> _pluck_feature_pacts(body)\n    frozenset()\n\n    # Returns empty set if feature-pacts line with no tags\n    >>> body = 'gitlab: mygitlaburl.com\\\\r\\\\n\\\\r\\\\nfeature-pacts:\\\\r\\\\nJust adding some docs'\n    >>> _pluck_feature_pacts(body)\n    frozenset()\n\n    # Raises a GithubPrError if multiple feature-pact lines found\n    >>> body = 'feature-pacts: zh-feature-a\\\\r\\\\nfeature-pacts: eh-feature-b'\n    >>> _pluck_feature_pacts(body)\n    Traceback (most recent call last):\n        ...\n    faaspact_verifier.delivery.github_prs.GithubPrError: ...\n    \"\"\"\n    feature_pact_lines = [line for line in pr_body.split('\\r\\n')\n                          if line.startswith('feature-pacts:')]\n    if not feature_pact_lines:\n        return frozenset()\n    if len(feature_pact_lines) > 1:\n        raise GithubPrError(f'There should only be one feature-pacts line. \"{feature_pact_lines}\"')\n    return frozenset(feature_pact_lines[0].split()[1:])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npluck a PullRequestInfo from a valid github. com url", "response": "def _pluck_pull_request_info(pull_request_url: str) -> PullRequestInfo:\n    \"\"\"\n    # Plucks a PullRequestInfo from  a valid\n    >>> _pluck_pull_request_info('https://github.com/zhammer/morning-cd/pull/17')\n    PullRequestInfo(owner='zhammer', repo='morning-cd', number=17)\n\n    # Raises a GithubPrError on bad urls\n    >>> _pluck_pull_request_info('bad url')\n    Traceback (most recent call last):\n        ...\n    faaspact_verifier.delivery.github_prs.GithubPrError: ...\n    \"\"\"\n    match = re.search(\n        r'github\\.com/(?P<owner>[\\w-]+)/(?P<repo>[\\w-]+)/pull/(?P<number>\\d+)',\n        pull_request_url\n    )\n\n    if not match:\n        raise GithubPrError(f'Couldnt parse url: {pull_request_url}')\n\n    return PullRequestInfo(\n        owner=match.group('owner'),\n        repo=match.group('repo'),\n        number=int(match.group('number'))\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun the command in the current directory and returns the result of the command.", "response": "def run(self, *args, **kwargs):\n        \"\"\"\n        Run this program with Parameters, Redirects, and Pipes. If shell=True, this command is\n        executed as a string directly on the shell; otherwise, it's executed using Popen processes\n        and appropriate streams.\n        :param args: 0 or more of Parameter, Redirect, and Pipe\n        :param kwargs: shell=Bool\n        :return: None\n        \"\"\"\n        # Get default for kwarg shell\n        shell = kwargs.get('shell', False)\n\n        # Output log info for this command\n        run_cmd = self.__generate_cmd(*args, shell=True)\n        log_header = 'Running {}\\n{}\\n'.format(self.software_name, run_cmd)\n        if _Settings.logger._is_active():\n            _Settings.logger._write(log_header)\n        else:\n            sys.stdout.write(log_header)\n\n        # If shell is True, execute this command directly as a string\n        if shell:\n            subprocess.call(run_cmd, shell=True, executable=os.environ['SHELL'])  #TODO Check to see if this works on Windows\n        else:\n            # Get the command blueprint for this call\n            cmd_blueprint = self.__generate_cmd(*args, shell=False)\n            output_stream_filehandles = []\n            blueprint_processes = []\n\n            # For each command in the blueprint, set up streams and Popen object to execute\n            for i, cmd in enumerate(cmd_blueprint):\n                stdin_stream = None if i == 0 else blueprint_processes[i - 1].stdout\n                stdout_filehandle = None\n                stderr_filehandle = None\n\n                # If this command isn't the last in the list, that means the output\n                # is being piped into the next command\n                if i + 1 < len(cmd_blueprint):\n                    stdout_filehandle = subprocess.PIPE\n                # If this is the last command in the list, stdout may be redirected to a file...\n                elif cmd['stdout']:\n                    redir = cmd['stdout']\n                    stdout_filehandle = open(redir.dest, redir.mode)\n                    output_stream_filehandles.append(stdout_filehandle)\n                # ...or it may be set out to the main log file\n                elif _Settings.logger.log_stdout and _Settings.logger.destination:\n                    stdout_filehandle = subprocess.PIPE\n\n                # stderr can be redirected regardless of piping\n                if cmd['stderr']:\n                    redir = cmd['stderr']\n                    stderr_filehandle = open(redir.dest, redir.mode)\n                    output_stream_filehandles.append(stderr_filehandle)\n                # Or it may be sent out to a log file\n                elif (\n                        _Settings.logger.log_stderr\n                        and (_Settings.logger.destination_stderr or _Settings.logger.destination)\n                ):\n                    stderr_filehandle = subprocess.PIPE\n\n                # Create this process as a Popen object, with appropriate streams\n                process = subprocess.Popen(cmd['cmd'], stdin=stdin_stream,\n                                 stdout=stdout_filehandle, stderr=stderr_filehandle)\n                blueprint_processes.append(process)\n\n                # If this is the last command in the list, wait for it to finish\n                if i + 1 == len(cmd_blueprint):\n                    process.wait()\n\n                    # If logging is set, capture stdout (or stderr) to log file\n                    # TODO I think the logic here can be expressed more concisely\n                    if _Settings.logger.log_stdout and _Settings.logger.destination:\n                        for line in process.stdout:\n                            _Settings.logger._write(line)\n                    if (\n                            _Settings.logger.log_stderr\n                            and (_Settings.logger.destination_stderr or _Settings.logger.destination)\n                    ):\n                        for line in process.stderr:\n                            _Settings.logger._write(line, bool(_Settings.logger.destination_stderr))\n\n            # Close all the file handles created for redirects\n            map(lambda f: f.close(), output_stream_filehandles)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef replace_env_vars(conf):\n    d = deepcopy(conf)\n    for key, value in d.items():\n        if type(value) == dict:\n            d[key] = replace_env_vars(value)\n        elif type(value) == str:\n            if value[0] == '$':\n                var_name = value[1:]\n                d[key] = os.environ[var_name]\n\n    return d", "response": "Fill conf with environment variables where appropriate."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef init(self):\n        self.logger.info('Start initialize dir [%s]', self.basePath)\n        # Clean the directory\n        for name in os.listdir(self.basePath):\n            path = os.path.join(self.basePath, name)\n            if os.path.isdir(path):\n                shutil.rmtree(path)\n            else:\n                os.unlink(path)\n        # Prepare dirs and files\n        self.logger.info('Prepare dirs and files')\n        for name in self.DIRS:\n            os.mkdir(os.path.join(self.basePath, name))\n        with open(os.path.join(self.basePath, self.FILE_INDEX), 'wb') as fd:\n            pass\n        with open(os.path.join(self.basePath, self.FILE_SERIAL), 'wb') as fd:\n            print >>fd, 1000\n        # Format the config file\n        env = jinja2.Environment(\n                loader = jinja2.FileSystemLoader(os.path.dirname(os.path.abspath(__file__))),\n                trim_blocks = True,\n                lstrip_blocks = True\n                )\n        template = env.get_template('openssl.config.template')\n        content = template.render(basePath = self.basePath)\n        with open(os.path.join(self.basePath, self.FILE_CONFIG), 'wb') as fd:\n            print >>fd, content", "response": "This method will create the index and serial files and config files and store them in the base path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a root certificate for the current user.", "response": "def createRootCertificate(self, noPass = False, keyLength = 4096):\n        \"\"\"Create a root certificate\n        \"\"\"\n        configPath, keyPath, certPath = \\\n                os.path.join(self.basePath, self.FILE_CONFIG), \\\n                os.path.join(self.basePath, self.DIR_PRIVATE, self.FILE_CA_KEY), \\\n                os.path.join(self.basePath, self.DIR_CERTS, self.FILE_CA_CERT)\n        if os.path.isfile(keyPath):\n            raise ValueError('CA key file exists at [%s]' % keyPath)\n        if os.path.isfile(certPath):\n            raise ValueError('CA certificate file exists at [%s]' % certPath)\n        # Generate the key\n        if subprocess.call([ 'openssl', 'genrsa', '-aes256', '-out', keyPath, str(keyLength) ] if not noPass else [ 'openssl', 'genrsa', '-out', keyPath, str(keyLength) ]) != 0:\n            raise ValueError('Failed to create root key')\n        # Generate the cert\n        if subprocess.call([ 'openssl', 'req', '-config', configPath, '-key', keyPath, '-new', '-x509', '-days', '7300', '-sha256', '-extensions', 'v3_ca', '-out', certPath ]) != 0:\n            raise ValueError('Failed to create root certifcate')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef createClientCertificate(self, name, noPass = True, keyLength = 2048, days = 375):\n        if not name:\n            raise ValueError('Require name')\n        configPath, keyPath, csrPath, certPath = \\\n                os.path.join(self.basePath, self.FILE_CONFIG), \\\n                os.path.join(self.basePath, self.DIR_PRIVATE, '%s.key.pem' % name), \\\n                os.path.join(self.basePath, self.DIR_CSR, '%s.csr.pem' % name), \\\n                os.path.join(self.basePath, self.DIR_CERTS, '%s.cert.pem' % name)\n        if os.path.isfile(keyPath):\n            raise ValueError('Key file exists at [%s]' % keyPath)\n        if os.path.isfile(csrPath):\n            raise ValueError('CSR file exists at [%s]' % csrPath)\n        if os.path.isfile(certPath):\n            raise ValueError('Certificate file exists at [%s]' % certPath)\n        # Generate the key\n        if subprocess.call([ 'openssl', 'genrsa', '-aes256', '-out', keyPath, str(keyLength) ] if not noPass else [ 'openssl', 'genrsa', '-out', keyPath, str(keyLength) ]) != 0:\n            raise ValueError('Failed to create key')\n        # Generate the csr\n        if subprocess.call([ 'openssl', 'req', '-config', configPath, '-key', keyPath, '-new', '-sha256', '-out', csrPath ]) != 0:\n            raise ValueError('Failed to create CSR')\n        # Generate the certificate\n        if subprocess.call([ 'openssl', 'ca', '-config', configPath, '-extensions', 'usr_cert', '-days', str(days), '-notext', '-md', 'sha256', '-in', csrPath, '-out', certPath ]) != 0:\n            raise ValueError('Failed to create certificate')", "response": "Create a client certificate with the specified name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the PHI from the supplied twix header and returns the sanitized version. This consists of: 1) Replacing the patient id and name with strings of lower case x characters. 2) Replacing the patient birthday with 19700101 3) Replacing the patient gender with the number 0 4) All references to the date and time of the exam have all alphanumeric characters replaced by lower case x. Other characters (notably the period) are left unchanged. :param header_string: The header string to be anonymized :return: The anonymized version of the header.", "response": "def anonymize_twix_header(header_string):\n    \"\"\"\n    Removes the PHI from the supplied twix header and returns the sanitized\n    version. This consists of:\n    1) Replacing the patient id and name with strings of lower case x\n    characters.\n    2) Replacing the patient birthday with 19700101\n    3) Replacing the patient gender with the number 0\n    4) All references to the date and time of the exam have all alphanumeric\n    characters replaced by lower case x. Other characters (notably the period)\n    are left unchanged.\n\n    :param header_string: The header string to be anonymized\n    :return: The anonymized version of the header.\n    \"\"\"\n    patient_id = re.search(r\"(<ParamString.\\\"PatientID\\\">  { )(\\\".+\\\")(  }\\n)\", header_string).group(2)\n    header_string = re.sub(patient_id, \"\\\"\" + (\"x\" * (len(patient_id) - 2)) + \"\\\"\", header_string)\n\n    patient_birthday = re.search(r\"(<ParamString.\\\"PatientBirthDay\\\">  { )(\\\".+\\\")(  }\\n)\", header_string).group(2)\n    header_string = re.sub(patient_birthday, \"\\\"19700101\\\"\", header_string)\n\n    patient_name = re.escape(re.search(r\"(<ParamString.\\\"PatientName\\\">  { )(\\\".+\\\")(  }\\n)\", header_string).group(2))\n    # every occurrence of patient_name, replace it with a string where all the\n    # characters apart from the surrounding quotations are replaced with x\n    header_string = re.sub(patient_name, lambda x: re.sub(r\"[^\\\"]\", \"x\", x.group()), header_string)\n\n    patient_gender_span = re.search(r\"(<ParamLong.\\\"PatientSex\\\">  { )(\\d+)(  }\\n)\", header_string).span(2)\n    header_string = header_string[:patient_gender_span[0]] + \"0\" + header_string[patient_gender_span[1]:]\n\n    header_string = re.sub(\"(Sex\\\">\\s+\\{\\s*)(\\d)(\\s*\\})\",\n                           lambda match: \"\".join((match.group(1), \"0\", match.group(3))),\n                           header_string)\n\n    # We need to remove information which contains the date and time of the exam\n    # this is not stored in a helpful way which complicates finding it.\n    # I think that this FrameOfReference parameter is the correct time, it is\n    # certainly the correct date.\n    # As Siemens uses date and time to refer to other scans, we need to censor\n    # any string which contains the date of this exam. Also some references\n    # seem to use the date with the short form of the year so we match that\n    frame_of_reference = re.search(r\"(<ParamString.\\\"FrameOfReference\\\">  { )(\\\".+\\\")(  }\\n)\", header_string).group(2)\n    exam_date_time = frame_of_reference.split(\".\")[10]\n    exam_date = exam_date_time[2:8]\n\n    # any string which contains the exam date has all alpha-numerics replaced\n    # by the character x\n    header_string = re.sub(r\"\\\"[\\d\\.]*{0}[\\d\\.]*\\\"\".format(exam_date),\n                           lambda match: re.sub(r\"\\w\", \"x\", match.group()),\n                           header_string)\n\n    return header_string"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fmt_second(time_total):\n\n    def _ck(t):\n        return t < 10 and \"0%s\" % t or t\n\n    times = int(time_total)\n    h = times / 3600\n    m = times % 3600 / 60\n    s = times % 3600 % 60\n    return \"%s:%s:%s\" % (_ck(h), _ck(m), _ck(s))", "response": ">>> fmt_second 10 - > 00 - > 40"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall frog on the text and return a generator of Token objects.", "response": "def call_frog(text):\n    \"\"\"\n    Call frog on the text and return (sent, offset, word, lemma, pos, morphofeat) tuples\n    \"\"\"\n    \n    host, port = os.environ.get('FROG_HOST', 'localhost:9887').split(\":\")\n    frogclient = FrogClient(host, port, returnall=True)\n    sent = 1\n    offset = 0\n    for word, lemma, morph, morphofeat, ner, chunk, _p1, _p2 in frogclient.process(text):\n        if word is None:\n            sent += 1\n        else:\n            pos = _POSMAP[morphofeat.split(\"(\")[0]]\n            yield Token(sent, offset, word, lemma, pos, morphofeat, ner, chunk)\n            offset += len(word)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef frog_naf(text):\n    naf = KafNafParser(type=\"NAF\")\n    frogclient = FrogClient('localhost', 9887)\n    for token in call_frog(text):\n        wf = naf.create_wf(token.word, token.sent, token.offset)\n        term = naf.create_term(token.lemma, token.pos, token.morphofeat, [wf])\n\n    naf.create_linguistic_processor(\"text\", \"Frog tokenizer\", get_frog_version())\n    naf.create_linguistic_processor(\"term\", \"Frog MBT\", get_frog_version())\n    s = BytesIO()\n    naf.dump(s)\n    return s.getvalue()", "response": "Call from on the text and return a Naf object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvalidating python interpreter version. Only 3. 3 + allowed.", "response": "def validate_python_version():\n    \"\"\"Validate python interpreter version. Only 3.3+ allowed.\"\"\"\n    python_version = LooseVersion(platform.python_version())\n    minimal_version = LooseVersion('3.3.0')\n    if python_version < minimal_version:\n        print(\"Sorry, Python 3.3+ is required\")\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save(self):\n        if self._sheet.readonly:\n            raise ReadOnlyException\n        if not self._changed:\n            # nothing to save\n            return\n        gd_client = self._sheet.client\n        assert gd_client is not None\n        try:\n            entry = gd_client.UpdateRow(self._entry, self._data)\n        except RequestError as e:\n            error_data = e.args[0]\n            if error_data.status == 403:\n                #  Forbidden\n                raise\n            if error_data.status == 409:\n                # conflict\n                raise\n            else:\n                raise\n        self._entry = entry\n        # reset `_changed` flag\n        self._changed = False\n        return entry", "response": "Save the row back to the spreadsheet"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete the row from the spreadsheet", "response": "def delete(self):\n        \"\"\"Delete the row from the spreadsheet\"\"\"\n        if self._sheet.readonly:\n            raise ReadOnlyException\n        gd_client = self._sheet.client\n        assert gd_client is not None\n        return gd_client.DeleteRow(self._entry)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the google data client.", "response": "def get_client(self, email=None, password=None, **__):\n        \"\"\"Get the google data client.\"\"\"\n        if self.client is not None:\n            return self.client\n        return Auth(email, password)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_feed(self):\n        return self.client.GetListFeed(self.key, self.worksheet,\n            visibility='private' if self.is_authed else 'public',\n            # TODO always use projection='values' ? What does full give me?\n            projection='full' if self.is_authed else 'values')", "response": "Get the gdata spreadsheet feed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_worksheets(self):\n        worksheets = self.get_worksheets()\n        return [(x.link[3].href.split('/')[-1], x.title.text)\n            for x in worksheets.entry]", "response": "List what worksheets exist in the system"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef next(self):\n        # I'm pretty sure this is the completely wrong way to go about this, but\n        # oh well, this works.\n        if not hasattr(self, '_iter'):\n            self._iter = self.readrow_as_dict()\n        return self._iter.next()", "response": "Retrieve the next row."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a row to the spreadsheet returns the new row", "response": "def append(self, row_dict):\n        \"\"\"Add a row to the spreadsheet, returns the new row\"\"\"\n        # TODO validate row_dict.keys() match\n        # TODO check self.is_authed\n        entry = self.client.InsertRow(row_dict, self.key, self.worksheet)\n        self.feed.entry.append(entry)\n        return GDataRow(entry, sheet=self, deferred_save=self.deferred_save)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nscheduling a clone of this job.", "response": "def reschedule(self, date, callable_name=None, content_object=None,\n                   expires='7d', args=None, kwargs=None):\n        \"\"\"Schedule a clone of this job.\"\"\"\n        # Resolve date relative to the expected start of the current job.\n        if isinstance(date, basestring):\n            date = parse_timedelta(date)\n        if isinstance(date, datetime.timedelta):\n            date = self.time_slot_start + date\n\n        if callable_name is None:\n            callable_name = self.callable_name\n        if content_object is None:\n            content_object = self.content_object\n        if args is None:\n            args = self.args or []\n        if kwargs is None:\n            kwargs = self.kwargs or {}\n        from django_future import schedule_job\n        return schedule_job(date, callable_name, content_object=content_object,\n                            expires=expires, args=args, kwargs=kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrender a Mako template file to a new file.", "response": "def render_mako_template_to(\n        template, outpath, subsd, only_update=False, cwd=None,\n        prev_subsd=None, create_dest_dirs=False, logger=None,\n        pass_warn_string=True, **kwargs):\n    \"\"\"\n    template: either string of path or file like obj.\n\n    Beware of the only_update option, it pays no attention to\n    an updated subsd.\n\n    pass_warn_string: defult True\n    if True or instance of str:\n    an extra vairable named '_warning_in_the_generated_file_not_to_edit'\n    is passed with a preset (True) or string warning not to\n    directly edit the generated file.\n    \"\"\"\n    if cwd:\n        template = os.path.join(cwd, template)\n        outpath = os.path.join(cwd, outpath)\n    outdir = os.path.dirname(outpath) or '.'  # avoid ''\n\n    if not os.path.exists(outdir):\n        if create_dest_dirs:\n            make_dirs(outdir, logger=logger)\n        else:\n            raise FileNotFoundError(\n                \"Dest. dir. non-existent: {}\".format(outdir))\n\n    msg = None\n    if pass_warn_string is True:\n        subsd['_warning_in_the_generated_file_not_to_edit'] = (\n            \"DO NOT EDIT THIS FILE! (Generated from template: {} using\" +\n            \" Mako python templating engine)\"\n        ).format(os.path.basename(template))\n    elif isinstance(pass_warn_string, str):\n        subsd['_warning_in_the_generated_file_not_to_edit'] =\\\n            pass_warn_string\n\n    if only_update:\n        if prev_subsd == subsd and not \\\n           missing_or_other_newer(outpath, template):\n            if logger:\n                msg = \"Did not re-render {}. (destination newer + same dict)\"\n                logger.info(msg.format(template))\n            return\n\n    if hasattr(template, 'read'):\n        # set in-file handle to provided template\n        ifh = template\n    else:\n        # Assume template is a string of the path to the template\n        ifh = open(template, 'rt')\n\n    template_str = ifh.read()\n\n    kwargs_Template = {'input_encoding': 'utf-8', 'output_encoding': 'utf-8'}\n    kwargs_Template.update(kwargs)\n    with open(outpath, 'wb') as ofh:\n        from mako.template import Template\n        from mako.exceptions import text_error_template\n        try:\n            rendered = Template(\n                template_str, **kwargs_Template).render(**subsd)\n        except:\n            if logger:\n                logger.error(text_error_template().render())\n            else:\n                print(text_error_template().render())\n            raise\n        if logger:\n            logger.info(\"Rendering '{}' to '{}'...\".format(\n                ifh.name, outpath))\n        ofh.write(rendered)\n    return outpath"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a new subclass of namedtuple with default values.", "response": "def defaultnamedtuple(typename, field_names, defaults=()):\n    \"\"\" Generates a new subclass of tuple with default values.\n\n    Parameters\n    ----------\n    typename : string\n        The name of the class.\n    field_names : str or iterable\n        An iterable of splitable string.\n    defaults : iterable\n        Default values for ``field_names``, counting ``[-len(defaults):]``.\n\n    Examples\n    --------\n    >>> Body = defaultnamedtuple('Body', 'x y z density', (1.0,))\n    >>> Body.__doc__\n    'Body(x, y, z, density)'\n    >>> b = Body(10, z=3, y=5)\n    >>> b._asdict()\n    OrderedDict([('x', 10), ('y', 5), ('z', 3), ('density', 1.0)])\n\n    Returns\n    -------\n    A new tuple subclass named ``typename``\n\n    \"\"\"\n    Tuple = namedtuple(typename, field_names)\n    Tuple.__new__.__defaults__ = (None,) * len(Tuple._fields)\n    if isinstance(defaults, Mapping):\n        Tuple.__new__.__defaults__ = tuple(Tuple(**defaults))\n    else:\n        nmissing = len(Tuple._fields) - len(defaults)\n        defaults = (None,)*nmissing + tuple(defaults)\n        Tuple.__new__.__defaults__ = tuple(Tuple(*defaults))\n    return Tuple"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a. TXT filename to a Therion. TH filename", "response": "def convert_filename(txtfilename, outdir='.'):\n    \"\"\"Convert a .TXT filename to a Therion .TH filename\"\"\"\n    return os.path.join(outdir, os.path.basename(txtfilename)).rsplit('.', 1)[0] + '.th'"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite Therion project file for the Therion project", "response": "def thconfig(txtfiles, cavename='cave'):\n    \"\"\"Write `thconfig` file for the Therion project\"\"\"\n    fmts_model = ['lox', '3d', 'dxf', 'kml', 'plt', 'vrml']\n    outfilename = 'thconfig'\n\n    with open(outfilename, 'w') as outfile:\n        for txtfilename in txtfiles:\n            print >> outfile, 'source \"%s\"' % convert_filename(txtfilename)\n        print >> outfile\n\n        for fmt in fmts_model:\n            print >> outfile, 'export model -output \"%s\"' % os.path.join('models', '%s.%s' % (cavename, fmt))\n\n        print >> outfile, 'export map -projection plan -format esri -output \"%s\"' % os.path.join('models', 'gis')\n\n        print 'Wrote Therion project file %s .' % outfilename"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwraps around a class with a regular expression.", "response": "def wrap_around_re(aClass, wildcard, advice):\n    \"\"\"\n    Same as wrap_around but works with regular expression based\n    wildcards to map which methods are going to be used.\n    \"\"\"\n    matcher = re.compile(wildcard)\n    for aMember in dir(aClass):\n        realMember = getattr(aClass, aMember)\n        if callable(realMember) and aMember[:6]!=\"__wrap\" and \\\n           aMember[:9]!=\"__proceed\" and \\\n           matcher.match(aMember):\n            wrap_around(realMember, advice)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wrap_around(method, advice, instances=[]):\n    _permission_to_touch_wraps.acquire()\n    try:\n        methods_name, methods_class, _ = _names_mce(method)\n\n        if methods_name[:2]==\"__\" and not hasattr(methods_class,methods_name):\n            methods_name=\"_\"+methods_class.__name__+methods_name\n\n        # Check if __proceed method is implemented in the class\n        try:\n            getattr(methods_class,'__proceed')\n        except:\n            setattr(methods_class, '__proceed_stack', _proceed_stack_method)\n            setattr(methods_class,'__proceed', _proceed_method)\n\n        # Check how many times this method has been wrapped\n        methodwrapcount = wrap_count(method)\n\n        # Rename the original method: it will be __wrapped/n/origmethodname\n        # where /n/ is the number of wraps around it\n        wrapped_method_name = \"__wrapped\" + str(methodwrapcount) + methods_name\n        orig_method = getattr( methods_class, methods_name)\n        setattr(methods_class, wrapped_method_name, orig_method)\n\n        # Add the wrap (that is, the advice) as a new method\n        wrapper_method_name = \"__wrap\" + str(methodwrapcount) + methods_name\n        setattr(methods_class, wrapper_method_name, advice)\n\n        # Add __wrap_enabled/n/methodname attribute that is used for\n        # enabling and disabling the wrap on the fly. By default the wrap\n        # is enabled.\n        enabled_attr_name = \"__wrap_enabled\" + str(methodwrapcount) + methods_name\n        setattr(methods_class, enabled_attr_name, 1)\n\n        # Generate condition: should this wrap be executed when the method is called\n        cond_execute_wrap=\"self.\" + enabled_attr_name\n        if len(instances)>0:\n            instanceids_attr_name=\"__wrap_instanceids\"+str(methodwrapcount)+methods_name\n            if _python_version >= (2,4):\n                setattr(methods_class,instanceids_attr_name,set([id(i) for i in instances]))\n            else: # slower implementation for older pythons\n                setattr(methods_class,instanceids_attr_name,[id(i) for i in instances])\n            cond_execute_wrap=\"(\"+cond_execute_wrap+\")\" + \\\n                               \"and (id(self) in self.\"+instanceids_attr_name+\")\"\n\n        # Replace the original method by a method that\n        # 1) sets which method should be executed in the next proceed call\n        # 2) calls the wrap (advice)\n\n        new_code = \"def \" + methods_name + \"(self,*args,**keyw):\\n\" +\\\n                   \"\\tif not (\" + cond_execute_wrap + \"):\\n\" +\\\n                   \"\\t\\treturn self.\" + wrapped_method_name + \"(*args,**keyw)\\n\" +\\\n                   \"\\tstack=self.__proceed_stack()\\n\" +\\\n                   \"\\tstack.append( _Proceed_stack_entry(self.\" + wrapped_method_name + \",'\" + methods_class.__name__ + \".\" + methods_name + \"'))\\n\" +\\\n                   \"\\ttry: retval = self.\" + wrapper_method_name + \"(*args,**keyw)\\n\" +\\\n                   \"\\tfinally:\\n\" +\\\n                   \"\\t\\tstack.pop()\\n\" +\\\n                   \"\\t\\tif len(stack)==0: _remove_proceed_stack(self)\\n\" +\\\n                   \"\\treturn retval\\n\"\n        new_method = _create_function(new_code, methods_name)\n        new_method.__aspects_wrapid=methodwrapcount\n        new_method.__aspects_orig=orig_method\n        # setattr(new_method,'__aspects_enabled',1)\n        # new_method.__name__=methods_name\n        setattr(methods_class, methods_name, new_method)\n        return methodwrapcount\n    finally: _permission_to_touch_wraps.release()", "response": "This function will be deprecated. It will be deprecated."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef peel_around(method):\n    _permission_to_touch_wraps.acquire() # released in finally part\n    try:\n        if hasattr(method,'__aspects_enabled'): # new-style aspect, easy!\n            method.__aspects_rmf(method.__name__,method.__aspects_orig)\n            return method.__aspects_adv\n        \n        methods_name = method.__name__\n        methods_class = method.im_class\n\n        wc = wrap_count(method)-1\n\n        if wc==-1: return None\n\n        wrapped = getattr(methods_class, '__wrapped' + str(wc) + methods_name)\n        setattr(methods_class, methods_name, wrapped)\n\n        removed_adv = getattr(methods_class, '__wrap'+str(wc)+methods_name)\n        del methods_class.__dict__['__wrapped'+str(wc)+methods_name]\n        del methods_class.__dict__['__wrap'+str(wc)+methods_name]\n\n        return removed_adv\n    finally: _permission_to_touch_wraps.release()", "response": "This function will be deprecated. It will be deprecated."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wrap_count(method):\n    number = 0\n    while hasattr(method, '__aspects_orig'):\n        number += 1\n        method = method.__aspects_orig\n    return number", "response": "Returns the number of wrap around given method."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn triplet of names Method Class and Enabled attr name.", "response": "def _names_mce(method, wrap_number=None):\n    \"\"\"\n    Returns triplet of names: Method, it's Class and wrap's Enabled\n    attr name.  If enabled attr name does not exist (that is, there is\n    no wrap wrap_number on the method), AspectsException is raised.\n    \"\"\"\n    methods_name = method.__name__\n    methods_class = method.im_class\n    if wrap_number!=None:\n        enabled_attr_name = \"__wrap_enabled\" + str(wrap_number) + methods_name\n        if not hasattr(methods_class, enabled_attr_name):\n            raise AspectsException(\"Method %s does not have wrap with number %s\"\n                                   % (methods_name, wrap_number))\n    else: enabled_attr_name=None\n    return methods_name, methods_class, enabled_attr_name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsee http://star.pst.qub.ac.uk/idl/BYTSCL.html note that IDL uses slightly different formulae for bytscaling floats and ints. here we apply only the FLOAT formula...", "response": "def bytscl(array, maximum=None , minimum=None , nan=0, top=255 ):\r\n    \"\"\"\r\n    see http://star.pst.qub.ac.uk/idl/BYTSCL.html\r\n    note that IDL uses slightly different formulae for bytscaling floats and ints. \r\n    here we apply only the FLOAT formula...\r\n    \"\"\"\r\n    if maximum is None: maximum = np.nanmax(array)\r\n    if minimum is None: minimum = np.nanmin(array)\r\n    return np.maximum(np.minimum(((top+1.0)*(array-minimum)/(maximum-minimum)).astype(np.int16), top),0)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the positions needed for resampling a gappy vector", "response": "def argresample(a,**kwargs):\r\n    '''\r\n    This function returns the positions needed for resampling a \"gappy\" vector \r\n    \r\n    :keyword dt: Force sampling at a given resolution. Otherwise uses main data sampling (computed by getting the median value of the derivative)\r\n    '''\r\n    \r\n    dt=kwargs.get('dt',np.median(deriv(a)))\r\n    \r\n    h,_=np.histogram(a, bins=(a.max()-a.min())/dt + 1, range=[a.min()-dt/2.,a.max()+dt/2.])\r\n    \r\n    return h.astype(bool)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef isiterable(item):\r\n    if isinstance(item, collections.Iterable):\r\n        if not isinstance(item,(str,unicode))  :return True\r\n        else : return False\r\n    else : False", "response": "Check if item is iterable ans is not a string or unicode"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef deriv(*args):\r\n    x = args[0]\r\n    n = x.size\r\n    if n < 3 : raise Exception('Parameters must have at least 3 points')\r\n\r\n\r\n    if (len(args) == 2) :\r\n        y=args[1]\r\n        if n != y.size : raise 'Vectors must have same size'\r\n    \r\n        #;df/dx = y0*(2x-x1-x2)/(x01*x02)+y1*(2x-x0-x2)/(x10*x12)+y2*(2x-x0-x1)/(x20*x21)\r\n        #; Where: x01 = x0-x1, x02 = x0-x2, x12 = x1-x2, etc.\r\n    \r\n        if isinstance(x,np.ma.masked_array) :  x = x.data                # Convert masked arrays to classic arrays\r\n        if not isinstance(x,np.float) : x.astype(np.float) #;If not floating type, ensure floating... \r\n        \r\n        x12 = x - np.roll(x,-1)                                      #;x1 - x2\r\n        x01 = np.roll(x,1) - x                                       #;x0 - x1\r\n        x02 = np.roll(x,1) - np.roll(x,-1)                           #;x0 - x2\r\n    \r\n        d = np.roll(y,1) * (x12 / (x01*x02)) \\\r\n            + y * (1./x12 - 1./x01) \\\r\n            - np.roll(y,-1) * (x01 / (x02 * x12))                    #Middle points\r\n        \r\n        \r\n        #Formulae for the first and last points:\r\n        d[0] = y[0] * (x01[1]+x02[1])/(x01[1]*x02[1]) \\\r\n            - y[1] * x02[1]/(x01[1]*x12[1]) \\\r\n            + y[2] * x01[1]/(x02[1]*x12[1])                          #;First point\r\n        n2 = n-2\r\n        d[n-1] = -y[n-3] * x12[n2]/(x01[n2]*x02[n2]) \\\r\n            + y[n-2] * x02[n2]/(x01[n2]*x12[n2]) \\\r\n            - y[n-1] * (x02[n2]+x12[n2]) / (x02[n2]*x12[n2])             #;Last point\r\n\r\n    #Equally spaced point case\r\n    else :\r\n        d = (np.roll(x,-1) - np.roll(x,1))/2.\r\n        d[0] = (-3.0*x[0] + 4.0*x[1] - x[2])/2.\r\n        d[n-1] = (3.*x[n-1] - 4.*x[n-2] + x[n-3])/2.\r\n\r\n    return d", "response": "Returns the derivative of the given variable."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rms(array):\r\n    #;time should be the last dimension\r\n      \r\n#    IF sz[ndims-1] EQ 1 THEN RETURN, 0.\r\n    \r\n    nans = np.where(~np.isnan(array))\r\n    cnt=len(nans)\r\n    \r\n    if (cnt == 0) : return np.NaN\r\n    \r\n    nval=np.nansum(~np.isnan(array))\r\n    \r\n    mn = np.nansum(array) / nval\r\n\r\n    return np.sqrt(np.nansum((array - mn)**2.0)/nval)", "response": "Returns the root - mean - squared deviation of an array."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef message(MSG_LEVEL,msg,verbose=1):\r\n    \r\n    caller=get_caller()\r\n    if MSG_LEVEL <= verbose :  print('[{0}.{1}()] {2}'.format(__name__,caller.co_name,msg))", "response": "MESSAGE : print function wrapper."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, instance, condition):\n        item = self.dbi.get(condition)\n        if item is None:\n            return None\n        item.update(instance.as_dict())\n        self.dbi.update(item, condition)\n        return item.eid", "response": "Update the record id of the specified instance in the database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save(self, instance):\n        cond = tinydb.where('original') == instance.original\n        eid = self.update(instance, cond)\n        if eid is None:\n            return self.create(instance)\n        return eid", "response": "Save the instance to the database"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setZoom(self, viewID, zoom):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_GUI_VARIABLE, tc.VAR_VIEW_ZOOM, viewID, zoom)", "response": "Sets the zoom factor for the given view."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the current offset for the given view.", "response": "def setOffset(self, viewID, x, y):\n        \"\"\"setOffset(string, double, double) -> None\n\n        Set the current offset for the given view.\n        \"\"\"\n        self._connection._beginMessage(\n            tc.CMD_SET_GUI_VARIABLE, tc.VAR_VIEW_OFFSET, viewID, 1 + 8 + 8)\n        self._connection._string += struct.pack(\"!Bdd\", tc.POSITION_2D, x, y)\n        self._connection._sendExact()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the current coloring scheme for the given view.", "response": "def setSchema(self, viewID, schemeName):\n        \"\"\"setSchema(string, string) -> None\n\n        Set the current coloring scheme for the given view.\n        \"\"\"\n        self._connection._sendStringCmd(\n            tc.CMD_SET_GUI_VARIABLE, tc.VAR_VIEW_SCHEMA, viewID, schemeName)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setBoundary(self, viewID, xmin, ymin, xmax, ymax):\n        self._connection._beginMessage(\n            tc.CMD_SET_GUI_VARIABLE, tc.VAR_VIEW_BOUNDARY, viewID, 1 + 8 + 8 + 8 + 8)\n        self._connection._string += struct.pack(\"!Bdddd\",\n                                                tc.TYPE_BOUNDINGBOX, xmin, ymin, xmax, ymax)\n        self._connection._sendExact()", "response": "This method sets the current boundary for the given view."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef screenshot(self, viewID, filename):\n        self._connection._sendStringCmd(\n            tc.CMD_SET_GUI_VARIABLE, tc.VAR_SCREENSHOT, viewID, filename)", "response": "Saves a screenshot for the given viewID to the given filename."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstarting tracking the given vehicle on the given view.", "response": "def trackVehicle(self, viewID, vehID):\n        \"\"\"trackVehicle(string, string) -> None\n\n        Start visually tracking the given vehicle on the given view.\n        \"\"\"\n        self._connection._sendStringCmd(\n            tc.CMD_SET_GUI_VARIABLE, tc.VAR_TRACK_VEHICLE, viewID, vehID)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the shape of the node.", "response": "def setShape(self, shape):\n        \"\"\"Set the shape of the node.\n\n        Shape must be a list containing x,y,z coords as numbers\n        to represent the shape of the node.\n        \"\"\"\n        for pp in shape:\n            if len(pp) != 3:\n                raise ValueError('shape point must consist of x,y,z')\n        self._shape3D = shape\n        self._shape = [(x, y) for x, y, z in shape]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load(self, args):\n        self._queue.append(tc.CMD_LOAD)\n        self._string += struct.pack(\"!BiB\", 0, 1 + 4 + 1 + 1 + 4 + sum(map(len, args)) + 4 * len(args), tc.CMD_LOAD)\n        self._packStringList(args)\n        self._sendExact()", "response": "Load a simulation from the given arguments."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes a simulation step and simulate up to the given millisecond in sim time.", "response": "def simulationStep(self, step=0):\n        \"\"\"\n        Make a simulation step and simulate up to the given millisecond in sim time.\n        If the given value is 0 or absent, exactly one step is performed.\n        Values smaller than or equal to the current sim time result in no action.\n        \"\"\"\n        self._queue.append(tc.CMD_SIMSTEP)\n        self._string += struct.pack(\"!BBi\", 1 +\n                                    1 + 4, tc.CMD_SIMSTEP, step)\n        result = self._sendExact()\n        for subscriptionResults in self._subscriptionMapping.values():\n            subscriptionResults.reset()\n        numSubs = result.readInt()\n        responses = []\n        while numSubs > 0:\n            responses.append(self._readSubscription(result))\n            numSubs -= 1\n        return responses"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the timeout for nagios - compliant output", "response": "def set_timeout(self, timeout=None, code=None):\n        \"\"\"\n        set the timeout for plugin operations\n        when timeout is reached, exit properly with nagios-compliant output\n\n        arguments:\n            timeout: timeout in seconds\n            code: exit status code\n        \"\"\"\n        if timeout is None:\n            timeout = self.args.timeout if self.args.timeout else 10\n        if code is None:\n            code = UNKNOWN\n        self._timeout_delay = timeout\n        self._timeout_code = code\n        signal.signal(signal.SIGALRM, self._timeout_handler)\n        signal.alarm(timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef finish(self, code=None, message=None, perfdata=None, extdata=None):\n        if code is None:\n            code = self.get_code()\n        if message is None:\n            message = self.get_message(msglevels=[code])\n        if perfdata is None:\n            perfdata = self.get_perfdata()\n        if extdata is None:\n            extdata = self.get_extdata()\n        self.exit(code=code, message=message,\n                  perfdata=perfdata, extdata=extdata)", "response": "This function is used to add results to the internal function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the arguments from command - line and returns a dictionary containing the parsed arguments", "response": "def parse_args(self, arguments=None):\n        \"\"\"\n        parses the arguments from command-line\n\n        arguments:\n            optional argument list to parse\n\n        returns:\n            a dictionnary containing the arguments\n        \"\"\"\n        self._args = self.parser.parse_args(arguments)\n        return self.args"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_threshold(value, warning=None, critical=None):\n        if critical is not None:\n            if not isinstance(critical, Threshold):\n                critical = Threshold(critical)\n            if not critical.check(value):\n                return CRITICAL\n        if warning is not None:\n            if not isinstance(warning, Threshold):\n                warning = Threshold(warning)\n            if not warning.check(value):\n                return WARNING\n        return OK", "response": "Checks a value against warning and critical thresholds."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a result to the internal result list", "response": "def add_result(self, code, message=None):\n        \"\"\"\n        add a result to the internal result list\n\n        arguments:\n            same arguments as for Result()\n        \"\"\"\n        self._results.append(Result(code, message))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_code(self):\n        code = UNKNOWN\n        for result in self._results:\n            if code == UNKNOWN or (result.code < UNKNOWN\n                                   and result.code > code):\n                code = result.code\n        return code", "response": "Returns the final code for multi - checks\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a string that can be used to create a new message for mult - checks", "response": "def get_message(self, msglevels=None, joiner=None):\n        \"\"\"\n        the final message for mult-checks\n\n        arguments:\n            msglevels: an array of all desired levels (ex: [CRITICAL, WARNING])\n            joiner: string used to join all messages (default: ', ')\n\n        returns:\n            one-line message created with input results\n            or None if there are none\n        \"\"\"\n        messages = []\n        if joiner is None:\n            joiner = ', '\n        if msglevels is None:\n            msglevels = [OK, WARNING, CRITICAL]\n        for result in self._results:\n            if result.code in msglevels:\n                messages.append(result.message)\n        return joiner.join([msg for msg in messages if msg])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a perfdata to the internal perfdata list", "response": "def add_perfdata(self, *args, **kwargs):\n        \"\"\"\n        add a perfdata to the internal perfdata list\n\n        arguments:\n            the same arguments as for Perfdata()\n        \"\"\"\n        self._perfdata.append(Perfdata(*args, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse(self, threshold):\n        match = re.search(r'^(@?)((~|\\d*):)?(\\d*)$', threshold)\n\n        if not match:\n            raise ValueError('Error parsing Threshold: {0}'.format(threshold))\n\n        if match.group(1) == '@':\n            self._inclusive = True\n\n        if match.group(3) == '~':\n            self._min = float('-inf')\n        elif match.group(3):\n            self._min = float(match.group(3))\n        else:\n            self._min = float(0)\n\n        if match.group(4):\n            self._max = float(match.group(4))\n        else:\n            self._max = float('inf')\n\n        if self._max < self._min:\n            raise ValueError('max must be superior to min')", "response": "Parse the internal threshold string and set the internal values of the internal attributes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if a value is correct according to threshold arguments", "response": "def check(self, value):\n        \"\"\"\n        check if a value is correct according to threshold\n\n        arguments:\n            value: the value to check\n        \"\"\"\n        if self._inclusive:\n            return False if self._min <= value <= self._max else True\n        else:\n            return False if value > self._max or value < self._min else True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_route(self, handle_cls, path, name, category, \n                  handle_params={}, is_menu=False, \n                  order=time.time(),is_open=True, oem=False,**kwargs):\n        \"\"\" \u6ce8\u518c\u6743\u9650\n        \"\"\"\n        if not path: return\n        if path in self.routes:\n            if self.routes[path].get('oem'):\n                return\n\n        self.routes[path] = dict(\n            path=path,  # \u6743\u9650url\u8def\u5f84\n            name=name,  # \u6743\u9650\u540d\u79f0\n            category=category,  # \u6743\u9650\u76ee\u5f55\n            is_menu=is_menu,  # \u662f\u5426\u5728\u8fb9\u680f\u663e\u793a\u4e3a\u83dc\u5355\n            oprs=[],  # \u5173\u8054\u7684\u64cd\u4f5c\u5458\n            order=order,  # \u6392\u5e8f\n            is_open=is_open,  # \u662f\u5426\u5f00\u653e\u6388\u6743\n            oem=oem #\u662f\u5426\u5b9a\u5236\u529f\u80fd\n        )\n        self.routes[path].update(**kwargs)\n        self.add_handler(handle_cls, path, handle_params)", "response": "add_route - Add a route to the routing table"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbinding the given Opr to all routes", "response": "def bind_super(self, opr):\n        \"\"\" \u4e3a\u8d85\u7ea7\u7ba1\u7406\u5458\u6388\u6743\u6240\u6709\u6743\u9650\n        \"\"\"\n        for path in self.routes:\n            route = self.routes.get(path)\n            route['oprs'].append(opr)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bind_opr(self, opr, path):\n        if not path or path not in self.routes:\n            return\n        oprs = self.routes[path]['oprs']\n        if opr not in oprs:\n            oprs.append(opr)", "response": "bind an opr to a path"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unbind_opr(self, opr, path=None):\n        if path:\n            self.routes[path]['oprs'].remove(opr)\n        else:\n            for path in self.routes:\n                route = self.routes.get(path)\n                if route and opr in route['oprs']:\n                    route['oprs'].remove(opr)", "response": "Unbind an OPP from a path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_opr_category(self, opr, category):\n        for path in self.routes:\n            route = self.routes[path]\n            if opr in route['oprs'] and route['category'] == category:\n                return True\n        return False", "response": "Check if an OPR is in a category."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild a list of menus", "response": "def build_menus(self, order_cats=[]):\n        \"\"\" \u751f\u6210\u5168\u5c40\u5185\u5b58\u83dc\u5355\"\"\"\n        menus = [{'category': _cat, 'items': []} for _cat in order_cats]\n        for path in self.routes:\n            route = self.routes[path]\n            for menu in menus:\n                if route['category'] == menu['category']:\n                    menu['items'].append(route)\n        return menus"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match(self, opr, path):\n        _url = urlparse.urlparse(path)\n        if not _url.path or not opr:\n            return False\n        if _url.path in self.free_routes:\n            return True\n        if _url.path not in self.routes:\n            return False\n        return opr in self.routes[_url.path]['oprs']", "response": "Check if the path matches the opr"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef legs(self, legs):\n        if legs is not None:\n            if not isinstance(legs, list):\n                raise ValueError(\"Invalid type for asset legs: %s\" % type(legs).__name__)\n            if not all([isinstance(leg, dict) for leg in legs]):\n                raise ValueError(\"All asset legs must be dictionaries\")\n            self._legs = legs", "response": "Sets the legs that make up the multi - legged asset."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmerging several dictionaries into a single dict.", "response": "def merge(d, *dicts):\n    \"\"\"\n    Recursively merges dictionaries\n    \"\"\"\n\n    for d_update in dicts:\n        if not isinstance(d, dict):\n            raise TypeError(\"{0} is not a dict\".format(d))\n\n        dict_merge_pair(d, d_update)\n\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dict_merge_pair(d1, d2):\n    for key in d2:\n        if key in d1 and isinstance(d1[key], dict) and \\\n           isinstance(d2[key], dict):\n            dict_merge_pair(d1[key], d2[key])\n        else:\n            d1[key] = d2[key]\n\n    return d1", "response": "Recursively merges values from d2 into d1."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the address of the first entry in the interpreter state.", "response": "def interp_head_addr(self):\n        \"\"\"Returns PtrTo(PtrTo(PyInterpreterState)) value\"\"\"\n        if self._interp_head_addr is not None:\n            return self._interp_head_addr\n        try:\n            interp_head_addr = self.get_interp_head_addr_through_symbol()\n        except SymbolNotFound:\n            logger.debug(\"Could not find interp_head symbol\")\n            # Hard way\n            interp_head_addr = self.get_interp_head_addr_through_PyInterpreterState_Head()\n        self._interp_head_addr = interp_head_addr\n        return interp_head_addr"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning pointers to all GC tracked objects", "response": "def get_all_objects(self):\n        \"Return pointers to all GC tracked objects\"\n        for i, generation in enumerate(self.gc_generations):\n            generation_head_ptr = pygc_head_ptr = generation.head.get_pointer()\n            generation_head_addr = generation_head_ptr._value\n            while True:\n                # _PyObjectBase_GC_UNTRACK macro says that\n                # gc_prev always points to some value\n                # there is still a race condition if PyGC_Head\n                # gets free'd and overwritten just before we look\n                # at him\n                pygc_head_ptr = pygc_head_ptr.deref().gc_next\n                if pygc_head_ptr._value == generation_head_addr:\n                    break\n                yield pygc_head_ptr.deref().get_object_ptr()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nestablishes a connection to a TraCI - Server and return the connection object.", "response": "def connect(port=8813, numRetries=10, host=\"localhost\", proc=None):\n    \"\"\"\n    Establish a connection to a TraCI-Server and return the\n    connection object. The connection is not saved in the pool and not\n    accessible via traci.switch. It should be safe to use different\n    connections established by this method in different threads.\n    \"\"\"\n    for wait in range(1, numRetries + 2):\n        try:\n            return Connection(host, port, proc)\n        except socket.error as e:\n            print(\"Could not connect to TraCI server at %s:%s\" %\n                  (host, port), e)\n            if wait < numRetries + 1:\n                print(\" Retrying in %s seconds\" % wait)\n                time.sleep(wait)\n    raise FatalTraCIError(str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nestablishing a connection to a TraCI - Server and store it under the given label.", "response": "def init(port=8813, numRetries=10, host=\"localhost\", label=\"default\"):\n    \"\"\"\n    Establish a connection to a TraCI-Server and store it under the given\n    label. This method is not thread-safe. It accesses the connection\n    pool concurrently.\n    \"\"\"\n    _connections[label] = connect(port, numRetries, host)\n    switch(label)\n    return getVersion()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef start(cmd, port=None, numRetries=10, label=\"default\"):\n    if port is None:\n        port = sumolib.miscutils.getFreeSocketPort()\n    sumoProcess = subprocess.Popen(cmd + [\"--remote-port\", str(port)])\n    _connections[label] = connect(port, numRetries, \"localhost\", sumoProcess)\n    switch(label)\n    return getVersion()", "response": "Start a sumo server using cmd establish a connection to it and store it under the given label."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake a simulation step and simulate up to the given millisecond in sim time.", "response": "def simulationStep(step=0):\n    \"\"\"\n    Make a simulation step and simulate up to the given millisecond in sim time.\n    If the given value is 0 or absent, exactly one step is performed.\n    Values smaller than or equal to the current sim time result in no action.\n    \"\"\"\n    global _stepListeners\n    responses = _connections[\"\"].simulationStep(step)\n    for listener in _stepListeners:\n        listener.step(step)\n    return responses"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a step listener to the internal list of _stepListeners.", "response": "def addStepListener(listener):\n    \"\"\"addStepListener(traci.StepListener) -> bool\n\n    Append the step listener (its step function is called at the end of every call to traci.simulationStep())\n    Returns True if the listener was added successfully, False otherwise.\n    \"\"\"\n    if issubclass(type(listener), StepListener):\n        _stepListeners.append(listener)\n        return True\n    warnings.warn(\n        \"Proposed listener's type must inherit from traci.StepListener. Not adding object of type '%s'\" % type(listener))\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef removeStepListener(listener):\n    if listener in _stepListeners:\n        _stepListeners.remove(listener)\n        return True\n    warnings.warn(\n        \"removeStepListener(listener): listener %s not registered as step listener\" % str(listener))\n    return False", "response": "Removes the given listener from the traci s step listener container. Returns True if the listener was removed successfully False if the listener was not registered as step listener."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndirect from amaasclass to the dictionary of the children class", "response": "def direct_to_class(amaasclass):\n    \"\"\"direct from amaasclass (first params given in the row) to the dictionary of the children class\"\"\"\n    if amaasclass in ASSET:\n        return CHILDREN_CLASS['asset']\n    elif amaasclass in PARTY:\n        return CHILDREN_CLASS['party']\n    elif amaasclass in TRANSACTION:\n        return CHILDREN_CLASS['transaction']\n    elif amaasclass in BOOK:\n        return CHILDREN_CLASS['book']\n    elif amaasclass in CORPORATE_ACTION:\n        return CHILDREN_CLASS['corporate_action']\n    elif amaasclass in MARKET_DATA:\n        return None #None for now\n    else:\n        return CHILDREN_CLASS['asset_manager']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef interface_direct_class(data_class):\n    if data_class in ASSET:\n        interface = AssetsInterface()\n    elif data_class in PARTY:\n        interface = PartiesInterface()\n    elif data_class in BOOK:\n        interface = BooksInterface()\n    elif data_class in CORPORATE_ACTION:\n        interface = CorporateActionsInterface()\n    elif data_class in MARKET_DATA:\n        interface = MarketDataInterface()\n    elif data_class in TRANSACTION:\n        interface = TransactionsInterface()\n    else:\n        interface = AssetManagersInterface()\n    return interface", "response": "help to direct to the correct interface interacting with DB by class name only"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhelps to direct to the correct interface interacting with DB by csvpath", "response": "def interface_direct_csvpath(csvpath):\n    \"\"\"help to direct to the correct interface interacting with DB by csvfile path\"\"\"\n    with open(csvpath) as csvfile:\n        reader = csv.DictReader(csvfile)\n        for row in reader:\n            data_class = row.pop('amaasclass', '')\n            return interface_direct_class(data_class)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprocesses the _dict to correct dict to be called by class constructor constructor", "response": "def process_normal(_dict):\n    \"\"\"\n    this method process the _dict to correct dict to be called by class constructor\n    this method will be imported and called by main csv uploader function\n    \"\"\"\n    cooked_dict = group_raw_to_formatted_string_dict(_dict)\n    data_class = cooked_dict.pop('amaasclass', '')\n    children_class_dict = direct_to_class(data_class)\n    tasty_dict = dict()\n    for cooked_key, cooked_value in cooked_dict.items():\n        if cooked_key in CHILDREN_SIGNAL:\n            processed_dict = {cooked_key: formatted_string_to_others(cooked_value, children_class_dict[cooked_key])}\n        elif cooked_key == 'links':\n            processed_dict = {cooked_key: formatted_string_to_links(cooked_value, children_class_dict[cooked_key])}\n        else:\n            processed_dict = {cooked_key: process_value_with_header(cooked_key, cooked_value)}\n        tasty_dict.update(processed_dict)\n    return tasty_dict"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset satellite name using ( cf. notes on file names in alti_data. __init__", "response": "def set_sats(self):\r\n        '''\r\n        set satellite name using (cf. notes on file names in `altimetry.data.alti_data.__init__`)\r\n        '''\r\n        if self.count == 0 : return\r\n        \r\n        for enum in enumerate(self.filelist):\r\n            \r\n            if hasattr(self, 'id') : sat = self.id\r\n            elif (self.datatype == 'DT') | (self.datatype == 'NRT') | (self.datatype == 'PISTACH') : sat = [enum[1].split('_')[2]]\r\n            elif (self.datatype == 'CTOH') : sat = [enum[1].split('.')[-4]]\r\n            else : sat = 'N/A'\r\n            \r\n            if len(sat) == 1 : sat*self.filelist_count[enum[0]]\r\n            self.sat=np.append(self.sat,sat)\r\n            \r\n        self.sat=np.ma.array(self.sat,mask=False)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read(self,filename,datatype=None,slaext=False,**kwargs):\r\n        '''\r\n        reader method.\r\n        \r\n        :parameter filename: name of the file to load.\r\n        :keyword datatype: choose between DT/NRT/PISTACH/CTOH or other formats to call the corresponding reader. If datatype is :\r\n        \r\n           * DT or NRT or PISTACH : calls :func:`altimetry.data.alti_data.read_sla` or :func:`altimetry.data.alti_data.read_slaext`\r\n           * CTOH : calls :func:`altimetry.data.alti_data.read_CTOH`\r\n           * else : calls :func:`altimetry.data.alti_data.read_nc`, based on :class:`altimetry.tools.nctools.nc` object.\r\n        \r\n        :keyword slaext: force using :func:`altimetry.data.alti_data.read_slaext`\r\n        \r\n        .. note:: This method is call from :meth:`altimetry.data.hydro_data.__init__` and returns a data structure to be handled by :meth:`altimetry.data.hydro_data.update_dataset`\r\n        \r\n        '''\r\n        \r\n        fname,extension = os.path.splitext(filename)\r\n        \r\n        if os.path.basename(filename).count('.') > os.path.basename(filename).count('_'): delim='.'\r\n        else : delim = '_'\r\n        \r\n        #Get data type\r\n        if datatype is None :\r\n            if os.path.basename(filename).split(delim)[0] == 'ctoh' : datatype='CTOH'\r\n            if os.path.basename(filename).split(delim)[0] == 'PISTACH' : datatype='PISTACH'\r\n            if os.path.basename(filename).split(delim)[0] == 'nrt' : datatype='NRT'\r\n            if os.path.basename(filename).split(delim)[0] == 'dt' : datatype='DT'\r\n#        else :\r\n#            datatype='RAW' #Setup default as raw NetCDF file\r\n        \r\n        self.datatype=datatype\r\n        \r\n        if (datatype == 'DT') | (datatype == 'NRT') | (datatype == 'PISTACH') :\r\n            if slaext : outStr=self.read_slaext(filename,datatype=datatype,**kwargs)\r\n            else : outStr=self.read_sla(filename,datatype=datatype,**kwargs)\r\n            if outStr.has_key('_dimensions'): self.update_fid_list(os.path.basename(filename),outStr['_dimensions']['time'])\r\n        elif (datatype == 'CTOH') :\r\n            outStr=self.read_CTOH(filename,**kwargs)\r\n            if outStr.has_key('_dimensions'): self.update_fid_list(os.path.basename(filename),outStr['_dimensions']['time'])\r\n        else: #Setup default as raw NetCDF file\r\n            outStr=self.read_nc(filename,**kwargs)\r\n            if outStr.has_key('_dimensions'): self.update_fid_list(os.path.basename(filename),outStr['_dimensions'][outStr['_dimensions'].keys()[1]])\r\n        \r\n        \r\n        return outStr", "response": "Reads the ISO 8601 file and returns a new object with the metadata."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading a single AVISO Along - Track products from a file.", "response": "def read_sla(self,filename,params=None,force=False,timerange=None,datatype=None,**kwargs):\r\n        \r\n        \"\"\"\r\n        Read AVISO Along-Track products\r\n        \r\n        :return outStr: Output data structure containing all recorded parameters as specificied by NetCDF file PARAMETER list.\r\n        :author: Renaud Dussurget\r\n        \"\"\"\r\n        \r\n        from time import time\r\n        from datetime import timedelta\r\n#        a = time()\r\n        \r\n        self.message(2,'Reading AVISO DT data ({0})'.format(datatype))\r\n        \r\n                #Open file\r\n        self._filename = filename\r\n        try:\r\n            self._ncfile = ncfile(self._filename, \"r\")\r\n        except Exception,e:\r\n            self.warning(1, repr(e))\r\n            return {}\r\n        \r\n        #Get delimiter\r\n        if os.path.basename(filename).count('.') > os.path.basename(filename).count('_'): delim='.'\r\n        else : delim = '_'\r\n        \r\n        #Gat sat name\r\n        splitted=os.path.basename(filename).split(delim)\r\n        if len(splitted) > 3 :\r\n            if (datatype == 'DT') | (datatype == 'NRT') : sat_name = splitted[2] if splitted[0] == 'nrt' else splitted[3]\r\n            elif datatype == 'PISTACH' : sat_name = 'J2'\r\n            else : sat_name = 'J2'\r\n        else :\r\n            sat_name=\"N/A\"\r\n        \r\n     \r\n        #Get list of recorded parameters:\r\n        par_list=[i.encode() for i in self._ncfile.variables.keys()]\r\n        for i in ['BeginDates','Longitudes','Latitudes'] : par_list.pop(par_list.index(i))\r\n        nparam=len(par_list)\r\n        \r\n        self.message(2,'Recorded parameters : '+str(nparam)+' -> '+str(par_list))\r\n     \r\n        lon = self.load_ncVar('Longitudes',**kwargs)\r\n        lon['data'] = recale(lon['data'], degrees=True, zero_2pi=True) #shift longitudes\r\n        lat = self.load_ncVar('Latitudes',**kwargs)\r\n        \r\n#        lon = self.load_ncVar('Longitudes',Longitudes=(self.limit[1],self.limit[3]),**kwargs)\r\n#        lon['data'] = recale(lon['data'], degrees=True, zero_2pi=True) #shift longitudes\r\n#        lat = self.load_ncVar('Latitudes',Latitudes=(self.limit[0],self.limit[1]),**kwargs)\r\n\r\n        \r\n        #Extract within limits\r\n        ind, flag = in_limits(lon['data'],lat['data'],limit=self.limit)\r\n        dim_lon = lon['_dimensions']\r\n        lat = lat['data'].compress(flag)\r\n        lon = lon['data'].compress(flag)\r\n#         dist=cumulative_distance(lat, lon)\r\n        \r\n        sz=np.shape(lon)\r\n        ndims=np.size(sz)\r\n        \r\n        #Get dates\r\n        stDate = self.load_ncVar('BeginDates',**kwargs)['data']\r\n        dumVar = self.load_ncVar('Cycles',**kwargs)\r\n        nbCyc = dumVar['data']\r\n        Ncycs = dumVar['_dimensions']['Cycles']\r\n        Ntra = dumVar['_dimensions']['Tracks']\r\n        nbTra = self.load_ncVar('Tracks',**kwargs)['data']\r\n        \r\n#        if np.size(stDate) == 1 : stDate.\r\n        \r\n        DeltaT = self._ncfile.variables['DeltaT'][:]  / 86400. #* self._ncfile.variables['DeltaT'].scale_factor\r\n        npts = self.load_ncVar('NbPoints',**kwargs)['data']\r\n        dumind=np.cumsum(npts)\r\n        \r\n        #Loop 1\r\n#        date=np.ma.array([],mask=[])\r\n#        cycles=np.ma.array([],mask=[])\r\n#        tracks=np.ma.array([],mask=[])\r\n#        for i in xrange(Ncycs) :\r\n#            np.ma.concatenate((nbTra,nbTra))\r\n#        \r\n#        for i,nc in enumerate(nbCyc.data.flatten()):\r\n#            N=npts[i]\r\n#            curInd=np.array(list(set(xrange(dumind[i]-N,dumind[i]) if N > 0 else []).intersection(ind)))\r\n#            ncur=len(curInd)\r\n#            date=np.ma.concatenate((date,(curInd - dumind[0])*DeltaT+stDate.flatten()[i]))\r\n#            cycles=np.ma.concatenate((cycles,np.ma.array((nbCyc.data.flatten()[i],)*ncur)))#,mask=np.repeat(nbCyc.mask[i][j],ncur))))\r\n#            tracks=np.ma.concatenate((tracks,np.ma.array((nbTra.data.flatten()[i],)*ncur)))\r\n        \r\n        #Loop 2\r\n        \r\n        date = ()\r\n        cycles = ()\r\n        tracks = ()\r\n        \r\n#        rowind = (0,)*Ntra\r\n        \r\n#        nind=0\r\n#        for i in xrange(Ncycs): nind+=(npts*(~nbCyc.mask.T[i])).sum()\r\n        \r\n        indcopy=ind.copy()\r\n#        npts_copy=npts.copy()\r\n        npts[npts.mask]=0\r\n        dumind[dumind.mask]=0\r\n        \r\n        nbTra_copy=nbTra.copy()\r\n        \r\n        toto=npts.copy()\r\n        \r\n        concat_npts = not( nbCyc.shape[-1] > 1)\r\n        \r\n        #loop over cycles\r\n        for i in np.arange(1,Ncycs,1.0,dtype=int) :\r\n            nbTra=np.ma.concatenate((nbTra,nbTra_copy))\r\n            if concat_npts : npts=np.ma.concatenate((npts,tuple((~nbCyc.T[i].mask)*1*npts)))\r\n#            rowind+=(i,)*Ntra      \r\n        \r\n        if concat_npts: npts=npts.reshape(nbCyc.shape[::-1]).T\r\n        else : npts=nbCyc\r\n        \r\n        nbTra=nbTra.reshape(nbCyc.shape[::-1]).T\r\n#        rowind=np.reshape(rowind,nbCyc.shape[::-1]).T\r\n        \r\n#        npts.mask=nbCyc.mask\r\n        nbTra.mask=nbCyc.mask\r\n        \r\n        npts=npts.flatten()\r\n        nbTra=nbTra.flatten()\r\n#        rowind=rowind.flatten()\r\n        \r\n        nbCyc_flatten=nbCyc.flatten()\r\n        nbTra_flatten=nbTra.flatten()\r\n        stDate_flatten=stDate.flatten()\r\n        \r\n#        nind=0\r\n        \r\n        outInd=[]\r\n        \r\n        for i,nc in enumerate(nbCyc.data.flatten()):\r\n            N=npts[i]\r\n            Nprev=npts[i-Ncycs] if i >= (Ncycs) and np.remainder(float(i),Ncycs) == 0 else 0\r\n            indcopy-=Nprev #if rowind[i] == 0 else 0\r\n            curInd=tuple(sorted(set(xrange(N) if N > 0 else []).intersection(indcopy)))\r\n            ncur=len(curInd)\r\n#            nind+=ncur\r\n            outInd+=map(operator.sub, curInd,(( (curInd[0] if len(curInd) > 0 else 0) - (outInd[-1] +1 if len(outInd) > 0 else 0) - len(ind)*(np.remainder(float(i),Ncycs)),)*ncur))\r\n            curInd=tuple(map(operator.mul, curInd, (DeltaT,)*ncur))     \r\n            date+=tuple(map(operator.add, curInd, (stDate_flatten[i],)*ncur))\r\n            cycles+=(nbCyc_flatten[i],)*ncur\r\n            tracks+=(nbTra_flatten[i],)*ncur\r\n        \r\n        date=np.ma.masked_array(date,mask=False)\r\n        cycles=np.ma.masked_array(cycles,mask=False)\r\n        tracks=np.ma.masked_array(tracks,mask=False)\r\n                \r\n        #Loop 3\r\n#        date=np.ma.array([],mask=[])\r\n#        cycles=np.ma.array([],mask=[])\r\n#        tracks=np.ma.array([],mask=[])\r\n#        for j in xrange(Ncycs) :\r\n#            for i,N in enumerate(npts.data) :\r\n##                curFg=(ind >= dumind[i]-N) & (ind <= dumind[i])\r\n#                curInd=np.array(list(set(xrange(dumind[i]-N,dumind[i]) if N > 0 else []).intersection(ind)))\r\n#                ncur=len(curInd)\r\n#                date=np.ma.concatenate((date,(curInd - dumind[0])*DeltaT+stDate[i][j]))\r\n#                cycles=np.ma.concatenate((cycles,np.ma.array((nbCyc.data[i][j],)*ncur)))#,mask=np.repeat(nbCyc.mask[i][j],ncur))))\r\n#                tracks=np.ma.concatenate((tracks,np.ma.array((nbTra.data[i],)*ncur)))#,mask=np.repeat(nbCyc.mask[i][j],ncur))))\r\n        \r\n        outInd=np.array(outInd,dtype=int)\r\n        \r\n        #Check output index\r\n#         print outInd.shape[0],npts.cumsum().max()\r\n        \r\n        nt=len(date)\r\n        date.mask=(False,)*nt\r\n        cycles.mask=date.mask\r\n        tracks.mask=date.mask\r\n#        date=date.reshape((Ncycs,)+(npts.sum(),)).T\r\n#        mask=date.mask\r\n#        date=date.compressed()\r\n#        cycles=cycles.reshape((Ncycs,)+(npts.sum(),)).T.compressed()\r\n#        tracks=tracks.reshape((Ncycs,)+(npts.sum(),)).T.compressed()\r\n        \r\n        \r\n#        lon=np.repeat(lon,Ncycs)\r\n#        lat=np.repeat(lat,Ncycs)\r\n#        mask=~lon.mask\r\n        \r\n        dimStr = dim_lon\r\n        dimStr.pop('Data')\r\n        nrec=len(date)\r\n        dimStr.update({'time':nrec})\r\n        \r\n        for i in ['DeltaT','NbPoints','Cycles','Tracks','DataIndexes'] : par_list.pop(par_list.index(i))\r\n        \r\n        outStr={'_dimensions':dimStr,\r\n                'lon':lon,\r\n                'lat':lat,\r\n                'date':date,\r\n                'cycle':cycles,\r\n                'track':tracks}\r\n        \r\n        \r\n        \r\n        for param in par_list :\r\n            a = time()\r\n            dumVar = self.load_ncVar(param,Data=ind,**kwargs) #Load variables            \r\n            runtime = time() - a\r\n#            print 'runtime:', timedelta(seconds=runtime)\r\n            \r\n            dimStr=dumVar['_dimensions']\r\n            dimStr.pop('Cycles')\r\n            dimStr.pop('Data')\r\n            dimStr['time']=nrec\r\n            dimStr['_ndims']=len(dimStr.keys())-1\r\n            \r\n            #update dimensions\r\n            curDim = [str(dimname) for dimname in dimStr.keys()[1:]] #[str(dimname) for dimname in self._ncfile.variables['LONGITUDE'].dimensions]\r\n            curDimval = [dimStr[dim] for dim in curDim] #[len(self._ncfile.dimensions[dimname]) for dimname in curDim]\r\n            flag = [(np.array(dimname) == outStr['_dimensions'].keys()).sum() == 0 for dimname in curDim] #find dimensions to update\r\n            dimUpdate = np.array(curDim).compress(flag)\r\n            for enum in enumerate(dimUpdate) : \r\n                self.message(3, 'Appending dimensions {0}:{1} to dataStructure'.format(enum[1],np.array(curDimval).compress(flag)[enum[0]]))\r\n                outStr['_dimensions'].update({enum[1]:np.array(curDimval).compress(flag)[enum[0]]}) #Append new dimension\r\n                outStr['_dimensions']['_ndims']+=1 #update dimension counts\r\n            \r\n#            dumStr = {param.lower() : dumVar['data']}\r\n            dumStr = {param.lower() : dumVar['data'].flatten()[outInd]}\r\n#            cmd = 'dumStr = {\\''+param.lower()+'\\':dumVar[\\'data\\']}'\r\n#            self.message(4, 'exec : '+cmd)\r\n#            exec(cmd)\r\n            outStr.update(dumStr)\r\n        \r\n        id=np.repeat(sat_name,outStr['_dimensions']['time'])\r\n        \r\n        \r\n        outStr.update({'id':id})\r\n        self._ncfile.close()\r\n        \r\n        #Checkit [len(outStr[k]) for k in outStr.keys()]\r\n        return outStr"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_slaext(self,filename,params=None,force=False,timerange=None,datatype=None,**kwargs):\r\n        \r\n        \"\"\"\r\n        Read AVISO Along-Track SLAEXT regional products\r\n        \r\n        :return outStr: Output data structure containing all recorded parameters as specificied by NetCDF file PARAMETER list.\r\n        :author: Renaud Dussurget\r\n        \"\"\"\r\n        \r\n        self.message(2,'Reading SLAext data ({0})'.format(datatype))\r\n        self.message(2,'Loading %s' % (filename))\r\n        \r\n        #Open file\r\n        self._filename = filename\r\n        try:\r\n            self._ncfile = ncfile(self._filename, \"r\")\r\n        except Exception,e:\r\n            self.warning(1, repr(e))\r\n            return {}\r\n        \r\n        #Get delimiter\r\n        if os.path.basename(filename).count('.') > os.path.basename(filename).count('_'): delim='.'\r\n        else : delim = '_'\r\n        \r\n        #Gat sat name\r\n        splitted=os.path.basename(filename).split(delim)\r\n        if (datatype == 'DT') | (datatype == 'NRT') : sat_name = splitted[2] if splitted[0] == 'nrt' else splitted[3]\r\n        if datatype == 'PISTACH' : sat_name = 'J2'\r\n        \r\n     \r\n        #Get list of recorded parameters:\r\n        par_list=[i.encode() for i in self._ncfile.variables.keys()]\r\n        for i in ['time','longitude','latitude'] : par_list.pop(par_list.index(i))\r\n        nparam=len(par_list)\r\n        \r\n        self.message(2,'Recorded parameters : '+str(nparam)+' -> '+str(par_list))\r\n     \r\n        lon = self.load_ncVar('longitude',**kwargs)\r\n        lon['data'] = recale(lon['data'], degrees=True, zero_2pi=True) #shift longitudes\r\n        lat = self.load_ncVar('latitude',**kwargs)\r\n\r\n        \r\n        #Extract within limits\r\n        ind, flag = in_limits(lon['data'],lat['data'],limit=self.limit)\r\n        dim_lon = lon['_dimensions']\r\n        lat = lat['data'].compress(flag)\r\n        lon = lon['data'].compress(flag)\r\n        dist=cumulative_distance(lat, lon)\r\n        \r\n        sz=np.shape(lon)\r\n        ndims=np.size(sz)\r\n        \r\n        id=np.repeat(sat_name,sz)\r\n            \r\n        date = self.load_ncVar('time',time=ind,**kwargs)\r\n        dimStr = date['_dimensions']\r\n        date=date['data']\r\n                \r\n        outStr=varStr(dimensions=dimStr)\r\n        \r\n        outStr.update({'lon':lon})\r\n        outStr.update({'lat':lat})\r\n        outStr.update({'date':date})\r\n        outStr.update({'id':id})\r\n        #{'_dimensions':dimStr,'lon':lon,'lat':lat,'date':date}\r\n        \r\n        for param in par_list :\r\n            dumVar = self.load_ncVar(param,time=ind,**kwargs) #Load variables\r\n            dimStr=dumVar['_dimensions']\r\n            \r\n            #update dimensions\r\n            curDim = [str(dimname) for dimname in dimStr.keys()[1:]] #[str(dimname) for dimname in self._ncfile.variables['LONGITUDE'].dimensions]\r\n            curDimval = [dimStr[dim] for dim in curDim] #[len(self._ncfile.dimensions[dimname]) for dimname in curDim]\r\n            flag = [(np.array(dimname) == outStr['_dimensions'].keys()).sum() == 0 for dimname in curDim] #find dimensions to update\r\n            dimUpdate = np.array(curDim).compress(flag)\r\n            for enum in enumerate(dimUpdate) : \r\n                self.message(3, 'Appending dimensions {0}:{1} to dataStructure'.format(enum[1],np.array(curDimval).compress(flag)[enum[0]]))\r\n                outStr['_dimensions'].update({enum[1]:np.array(curDimval).compress(flag)[enum[0]]}) #Append new dimension\r\n                if not isinstance(outStr['_dimensions'],dimStr) : outStr['_dimensions']['_ndims']+=1 #update dimension counts\r\n            \r\n            cmd = 'dumStr = {\\''+param.lower()+'\\':dumVar[\\'data\\']}'\r\n            self.message(4, 'exec : '+cmd)\r\n            exec(cmd)\r\n            outStr.update(dumStr)\r\n        \r\n        self._ncfile.close()\r\n        \r\n        return outStr", "response": "Read a regional products from a NetCDF file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_CTOH(self,filename,params=None,force=False,timerange=None,datatype=None,**kwargs):\r\n        \r\n        \"\"\"\r\n        Read AVISO Along-Track SLA regional products\r\n        \r\n        :return outStr: Output data structure containing all recorded parameters as specificied by NetCDF file PARAMETER list.\r\n        :author: Renaud Dussurget\r\n        \"\"\"\r\n        \r\n        #Open file\r\n        self._filename = filename\r\n        try:\r\n            self._ncfile = ncfile(self._filename, \"r\")\r\n        except Exception,e:\r\n            self.warning(1, repr(e))\r\n            return {}\r\n\r\n        \r\n        #Get file infos from filename\r\n        \r\n        #Get delimiter\r\n        delim = '.'\r\n        \r\n        #Gat sat name\r\n        splitted=os.path.basename(filename).split(delim)\r\n        sat_name = splitted[3]\r\n        track = np.ma.masked_array(int(splitted[-2]))\r\n        ntracks=1\r\n     \r\n        #Get list of recorded parameters:\r\n        par_list=[i.encode() for i in self._ncfile.variables.keys()]\r\n        for i in ['cycle','lon','lat'] : par_list.pop(par_list.index(i))\r\n        nparam=len(par_list)\r\n        \r\n        self.message(2,'Recorded parameters : '+str(nparam)+' -> '+str(par_list))\r\n     \r\n        lon = self.load_ncVar('lon',**kwargs)\r\n        lon['data'] = recale(lon['data'], degrees=True, zero_2pi=True) #shift longitudes\r\n        lat = self.load_ncVar('lat',**kwargs)\r\n\r\n        \r\n        #Extract within limits\r\n        ind, flag = in_limits(lon['data'],lat['data'],limit=self.limit)\r\n        latout = lat.pop('data').compress(flag)\r\n        lonout = lon.pop('data').compress(flag)\r\n        nlon = len(lonout)\r\n        \r\n        #Get cycles\r\n        cycle = self.load_ncVar('cycle',time=ind,**kwargs)\r\n        cycleout = cycle.pop('data')\r\n        ncycles = len(cycleout)\r\n        \r\n        N = ncycles * nlon\r\n        \r\n        mask=np.repeat(lonout.mask,ncycles) & np.repeat(latout.mask,ncycles) & np.repeat(cycleout.mask,nlon)\r\n        \r\n        #update index\r\n        ind = np.repeat(ind, ncycles)\r\n        \r\n        \r\n        lon={'_dimensions':{'_ndims':1,'time':N},\r\n             '_attributes':lon['_attributes'],\r\n             'data':np.ma.masked_array(np.repeat(lonout.data,ncycles),mask=mask),\r\n             'long_name':'longitude'}\r\n#         lon.update()\r\n        \r\n        lat={'_dimensions':{'_ndims':1,'time':N},\r\n             '_attributes':lat['_attributes'],\r\n             'data':np.ma.masked_array(np.repeat(latout.data,ncycles),mask=mask),\r\n             'long_name':'latitude'}\r\n        \r\n        cycle={'_dimensions':{'_ndims':1,'time':N},\r\n               '_attributes':cycle['_attributes'],\r\n             'data':np.ma.masked_array(np.repeat(cycleout.data,nlon).reshape((ncycles,nlon)).T.flatten(),mask=mask),\r\n             'long_name':'cycle_number'}\r\n        \r\n        track={'_dimensions':{'_ndims':1,'time':N},\r\n               'data':np.ma.masked_array(np.repeat(track,N),mask=mask),\r\n               'long_name':'track_number'}\r\n        \r\n        outStr={'_dimensions':{'_ndims':1,'time':N},\r\n                'lon':lon,\r\n                'lat':lat,\r\n                'track':track,\r\n                'cycle':cycle}\r\n        \r\n        for param in par_list :\r\n            dumVar = self.load_ncVar(param,time=ind,**kwargs) #Load variables\r\n            dimStr=dumVar.pop('_dimensions')\r\n            attrStr=dumVar.pop('_attributes')\r\n            \r\n            #Get dimension properties\r\n#             curDim = [str(dimname) for dimname in dimStr.keys()[1:]] #[str(dimname) for dimname in self._ncfile.variables['LONGITUDE'].dimensions]\r\n#             curDimval = [dimStr[dim] for dim in curDim] #[len(self._ncfile.dimensions[dimname]) for dimname in curDim]\r\n            \r\n            #Repeat if only 1 dim\r\n            if dimStr['_ndims'] == 1:\r\n                dumVar={'data':np.ma.repeat(dumVar.pop('data'),N/dimStr[dimStr.keys()[dimStr['_ndims']]])}\r\n            #Else flatten\r\n            else :\r\n                dumVar={'data':dumVar.pop('data').flatten()}\r\n                \r\n            #update with dimensions\r\n            dumVar['_dimensions']=outStr['_dimensions'].copy()\r\n            dumVar['_attributes']=attrStr\r\n                  \r\n            cmd = 'dumStr = {\\''+param.lower()+'\\':dumVar}'\r\n            self.message(4, 'exec : '+cmd)\r\n            exec(cmd)\r\n            outStr.update(dumStr)\r\n        \r\n#         id={'_dimensions':{'_ndims':1,'time':N},\r\n#             'data':np.repeat(sat_name,N)}\r\n#          \r\n#          \r\n#         outStr.update({'id':id})\r\n        self._ncfile.close()\r\n        \r\n        return outStr", "response": "Read a file and return a dictionary containing all recorded parameters as specificied by NetCDF file PARAMETER list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_nc(self,filename,**kwargs):\r\n        '''\r\n        data reader based on :class:`altimetry.tools.nctools.nc` object.\r\n        \r\n        .. note:: THIS can be VERY powerful!\r\n        '''\r\n        \r\n        #Set filename\r\n        self._filename = filename\r\n        \r\n        remove_existing = kwargs.get('remove_existing',True)\r\n        \r\n        #Read data from NetCDF\r\n        obj=nctools.nc(verbose=self.verbose,limit=self.limit,use_local_dims=True)\r\n        outStr=obj.read(filename,**kwargs)\r\n        \r\n        #Remove attributes already existing in data object\r\n        for a in self.__dict__.keys():\r\n            if outStr.has_key(a) and not a.startswith('_') :\r\n                if remove_existing :\r\n                    outStr.pop(a)\r\n                    self.message(2, 'Attribute {0} already exists - removing it (set remove_existing to False instead)'.format(a))\r\n        \r\n        return outStr", "response": "Reads the specified file and returns a string containing the data in the format that is expected by the NetCDF library."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef track_list(self,*args):\r\n        '''\r\n        return the list of tracks contained if the dataset\r\n        '''\r\n        noargs = len(args) == 0\r\n        return np.unique(self.track) if noargs else np.unique(self.track.compress(args[0]))", "response": "Returns the list of tracks contained in the dataset\r\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the list of cycles contained if the dataset is not None", "response": "def cycle_list(self,*args):\r\n        '''\r\n        return the list of cycles contained if the dataset\r\n        '''\r\n        noargs = len(args) == 0\r\n        return np.unique(self.cycle) if noargs else np.unique(self.cycle.compress(args[0]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reorder(self,*args,**kwargs):\r\n        '''\r\n        Reorders data vectors in 2D (ie. with dimensions (CYCLE,RECORD)). This is useful to get a hovmoller-type matrix of each variable.\r\n        \r\n        :example: To plot a hovmoller for a given variable, do ::\r\n           \r\n           .. code-block:: pyhton\r\n              \r\n              data=alti_data('/my/dir/my_files_pattern*.nc') #concatenate the files\r\n              data.reorder() #reorder data\r\n              pcolormesh(data.lat,data.cycle,data.sla); show() #plot the hovmoller\r\n           \r\n        .. note:: This only works for data reprojected along a nominal track.\r\n        '''\r\n        #update time range with real value\r\n        trange_str = self.time_range()[0]\r\n        cycle_list = self.cycle_list()\r\n        track_list=self.track_list()\r\n        \r\n        #Solve precision problem (for unique)!\r\n        precision=np.finfo(self.lon.dtype).precision-2 #9\r\n        self.lon=self.lon.round(decimals=precision)\r\n        self.lat=self.lat.round(decimals=precision)\r\n            \r\n        #Detect recurrent  lon/lat/track triplets\r\n        self.message(2, 'Detect recurrent lon/lat/track triplets')\r\n        triplets = np.unique(zip(*(self.lon, self.lat, self.track)))\r\n        \r\n        \r\n        #Sort by track (we do not sort using other columns to preserve descending/ascending order)\r\n        triplets=np.ma.array(sorted(triplets, key=operator.itemgetter(2)))\r\n        \r\n        #Get main variables\r\n        lon = triplets[:,0]\r\n        lat = triplets[:,1]\r\n        tracknb = triplets[:,2]\r\n        \r\n        #!!!!\r\n        #PROBLEM WITH UNIQUE!!!! DUPLICATES ARE STILL PRESENT! \r\n        \r\n        track=track_list\r\n        cycle=cycle_list\r\n        \r\n        N=len(lon)\r\n        ntracks=len(track_list)\r\n        ncycles=len(cycle_list)\r\n        \r\n        ind = np.arange(N)\r\n        \r\n    #    dst = atools.calcul_distance(lat, lon)\r\n        \r\n        #Get local index on nominal tracks (THIS IS long)\r\n        #TODO: replace this lines by lines using set() - much much faster!!!\r\n        self.message(2, 'Computing space and time indices')\r\n        \r\n        \r\n        xid = np.array([np.where((ln == lon) & (self.lat[i] == lat))[0][0] for i,ln in enumerate(self.lon) ])\r\n        tid = np.array([np.where(c == cycle_list)[0][0] for c in self.cycle])\r\n        \r\n        #PROBLE\r\n        \r\n        #Get object attributes to reform\r\n        varSize = np.array([np.size(self.__dict__[k]) for k in self.__dict__.keys()])\r\n        par_list=np.array(self.__dict__.keys())[varSize == self._dimensions['time']].tolist()\r\n        \r\n        #Refine param list\r\n        for par in ['lon','lat','track','cycle'] :\r\n            par_list.pop(par_list.index(par))\r\n            self.__setattr__(par,locals()[par])\r\n            \r\n        #Set new dimensions array\r\n        self._dimensions=OrderedDict({'_ndims':3,'cycle':ncycles,'record':N,'track':ntracks})\r\n        record=np.ma.array(ind,mask=np.zeros(N,dtype=bool))\r\n        \r\n        #Update lon, lat, track and cycle arrays\r\n        lon.mask=np.zeros(N,dtype=bool)\r\n        lat.mask=np.zeros(N,dtype=bool)\r\n        tracknb.mask=np.zeros(N,dtype=bool)\r\n        track.mask=np.zeros(ntracks,dtype=bool)\r\n        cycle.mask=np.zeros(ncycles,dtype=bool)\r\n        \r\n        lon.__setattr__('_dimensions',{'_ndims':1,'record':N}); lon.__setattr__('long_name','longitude')\r\n        lat.__setattr__('_dimensions',{'_ndims':1,'record':N}); lat.__setattr__('long_name','latitude')\r\n        tracknb.__setattr__('_dimensions',{'_ndims':1,'record':ntracks}); track.__setattr__('long_name','track_number')\r\n        track.__setattr__('_dimensions',{'_ndims':1,'track':ntracks}); track.__setattr__('long_name','track_list')\r\n        cycle.__setattr__('_dimensions',{'_ndims':1,'cycle':ncycles}); cycle.__setattr__('long_name','cycle_number')\r\n        record.__setattr__('_dimensions',{'_ndims':1,'record':N}); record.__setattr__('long_name','record_index')\r\n        \r\n        self.lon=lon\r\n        self.lat=lat\r\n        self.tracknb=tracknb\r\n        self.track=track\r\n        self.cycle=cycle\r\n        self.record=record\r\n        \r\n        #Init output matrices using object fields\r\n        for par in par_list :\r\n            self.message(2, 'Reforming {0}'.format(par))\r\n            locals()[par]=np.ma.array(np.zeros((ncycles,N)),mask=np.ones((ncycles,N),dtype=bool),dtype=self.__getattribute__(par).dtype)\r\n            locals()[par][tid,xid]=self.__getattribute__(par)\r\n            locals()[par].__setattr__('_dimensions',{'_ndims':2,'cycle':ncycles,'record':N})\r\n            if hasattr(self.__dict__[par],'__dict__') :\r\n                #Remove attributes already in output variable\r\n                attrStr=OrderedDict()\r\n                null=[attrStr.update({a:self.__dict__[par].__dict__[a]}) for a in self.__dict__[par].__dict__.keys() if not locals()[par].__dict__.has_key(a)]\r\n                locals()[par].__dict__.update(attrStr)\r\n            self.__setattr__(par,locals()[par])\r\n        \r\n        par_list=np.append(par_list,['lon','lat','tracknb','track','cycle','record'])\r\n        self.par_list=par_list", "response": "Reorders the data vectors in 2D."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute the central time for each pass.", "response": "def pass_time(self):\r\n        '''\r\n        Compute the central time for each passes.\r\n        \r\n        .. note:: this must be called AFTER having called :meth:`altimetry.data.alti_data.reorder` as it looks for the CYCLE and RECORD dimensions.\r\n        .. note:: The methodology to compute the central time is to interpolate the time along the track at missing points, and then reading the value at point N/2.\r\n        '''\r\n        date=self.date\r\n        nt=self._dimensions['cycle']\r\n        N=self._dimensions['record']\r\n        for t in np.arange(nt):\r\n            poly=np.polyfit(np.arange(N)[~date.mask[t,:]], date[t,:][~date.mask[t,:]], 1)\r\n            date[t,:][date.mask[t,:]]=poly[0]*np.arange(N)[date.mask[t,:]] + poly[1]\r\n        date.mask=False\r\n        return date[:,N/2]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_application_instance():\n\n    instance = QApplication.instance()\n    if not instance:\n        instance = QApplication(sys.argv)\n    return instance", "response": "Returns the current QApplication instance or create one if it doesn t exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses given location data.", "response": "def parse_location(data):\n    \"\"\"\n    Parses given location data.\n\n    :param data: Exception.\n    :type data: Exception\n    :return: Location object.\n    :rtype: Location\n    \"\"\"\n\n    tokens = data.split(\",\")\n    location = Location(directories=[], files=[], filters_in=[], filters_out=[], targets=[])\n    if not tokens:\n        return location\n\n    for token in tokens:\n        token = token.strip()\n        if not token:\n            continue\n\n        if foundations.common.path_exists(token):\n            if os.path.isdir(token):\n                location.directories.append(token)\n            else:\n                location.files.append(token)\n        else:\n            match = re.match(\"(?P<filterIn>\\*\\.\\w+)\", token)\n            if match:\n                location.filters_in.append(fnmatch.translate(match.group(\"filterIn\")))\n                continue\n            match = re.match(\"!(?P<filterOut>\\*\\.\\w+)\", token)\n            if match:\n                location.filters_out.append(fnmatch.translate(match.group(\"filterOut\")))\n                continue\n            match = re.match(\"\\<(?P<target>[\\w ]+)\\>\", token)\n            if match:\n                location.targets.append(match.group(\"target\"))\n                continue\n    return location"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the resource file path matching the given name.", "response": "def get_resource_path(name, raise_exception=False):\n    \"\"\"\n    Returns the resource file path matching the given name.\n\n    :param name: Resource name.\n    :type name: unicode\n    :param raise_exception: Raise the exception.\n    :type raise_exception: bool\n    :return: Resource path.\n    :rtype: unicode\n    \"\"\"\n\n    if not RuntimeGlobals.resources_directories:\n        RuntimeGlobals.resources_directories.append(\n            os.path.normpath(os.path.join(umbra.__path__[0], Constants.resources_directory)))\n\n    for path in RuntimeGlobals.resources_directories:\n        path = os.path.join(path, name)\n        if foundations.common.path_exists(path):\n            LOGGER.debug(\"> '{0}' resource path: '{1}'.\".format(name, path))\n            return path\n\n    if raise_exception:\n        raise umbra.exceptions.ResourceExistsError(\n            \"{0} | No resource file path found for '{1}' name!\".format(__name__, name))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_sections_file_parser(file):\n\n    if not foundations.common.path_exists(file):\n        raise foundations.exceptions.FileExistsError(\n            \"{0} | '{1}' sections file doesn't exists!\".format(__name__, file))\n\n    sections_file_parser = SectionsFileParser(file)\n    sections_file_parser.parse()\n    return sections_file_parser", "response": "Returns a sections file parser."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef store_last_browsed_path(data):\n\n    if type(data) in (tuple, list, QStringList):\n        data = [foundations.strings.to_string(path) for path in data]\n        last_browsed_path = foundations.common.get_first_item(data)\n    elif type(data) in (unicode, QString):\n        data = last_browsed_path = foundations.strings.to_string(data)\n    else:\n        raise TypeError(\"{0} | '{1}' type is not supported!\".format(__name__, type(data)))\n\n    if foundations.common.path_exists(last_browsed_path):\n        last_browsed_path = os.path.normpath(last_browsed_path)\n        if os.path.isfile(last_browsed_path):\n            last_browsed_path = os.path.dirname(last_browsed_path)\n\n        LOGGER.debug(\"> Storing last browsed path: '%s'.\", last_browsed_path)\n        RuntimeGlobals.last_browsed_path = last_browsed_path\n    return data", "response": "Stores the last browsed path in the data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef QVariant_to_string(data):\n\n    if isinstance(data, QVariant):\n        data = data.toString()\n\n    data = QString(data)\n    return foundations.strings.to_string(data)", "response": "Converts given QVariant data as a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nblocking given instance signals before calling the given attribute with given arguments and then unblocks the signals.", "response": "def signals_blocker(instance, attribute, *args, **kwargs):\n    \"\"\"\n    Blocks given instance signals before calling the given attribute with \\\n    given arguments and then unblocks the signals.\n\n    :param instance: Instance object.\n    :type instance: QObject\n    :param attribute: Attribute to call.\n    :type attribute: QObject\n    :param \\*args: Arguments.\n    :type \\*args: \\*\n    :param \\*\\*kwargs: Keywords arguments.\n    :type \\*\\*kwargs: \\*\\*\n    :return: Object.\n    :rtype: object\n    \"\"\"\n\n    value = None\n    try:\n        hasattr(instance, \"blockSignals\") and instance.blockSignals(True)\n        value = attribute(*args, **kwargs)\n    finally:\n        hasattr(instance, \"blockSignals\") and instance.blockSignals(False)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshow a wait cursor while processing. :param object: Object to decorate. :type object: object :return: Object. :rtype: object", "response": "def show_wait_cursor(object):\n    \"\"\"\n    Shows a wait cursor while processing.\n\n    :param object: Object to decorate.\n    :type object: object\n    :return: Object.\n    :rtype: object\n    \"\"\"\n\n    @functools.wraps(object)\n    def show_wait_cursorWrapper(*args, **kwargs):\n        \"\"\"\n        Shows a wait cursor while processing.\n\n        :param \\*args: Arguments.\n        :type \\*args: \\*\n        :param \\*\\*kwargs: Keywords arguments.\n        :type \\*\\*kwargs: \\*\\*\n        :return: Object.\n        :rtype: object\n        \"\"\"\n\n        QApplication.setOverrideCursor(Qt.WaitCursor)\n        value = None\n        try:\n            value = object(*args, **kwargs)\n        finally:\n            QApplication.restoreOverrideCursor()\n            return value\n\n    return show_wait_cursorWrapper"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting given height to given QToolBox widget.", "response": "def set_toolBox_height(tool_box, height=32):\n    \"\"\"\n    Sets given height to given QToolBox widget.\n\n    :param toolbox: ToolBox.\n    :type toolbox: QToolBox\n    :param height: Height.\n    :type height: int\n    :return: Definition success.\n    :rtype: bool\n    \"\"\"\n\n    for button in tool_box.findChildren(QAbstractButton):\n        button.setMinimumHeight(height)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_children_padding(widget, types, height=None, width=None):\n\n    for type in types:\n        for child in widget.findChildren(type):\n            child.setStyleSheet(\"{0}{{height: {1}px; width: {2}px;}}\".format(\n                type.__name__,\n                child.fontMetrics().height() + (height if height is not None else 0) * 2,\n                child.fontMetrics().width(child.text()) + (width if width is not None else 0) * 2))\n    return True", "response": "Sets given Widget children padding."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef print_http_nfc_lease_info(info):\n    print 'Lease timeout: {0.leaseTimeout}\\n' \\\n          'Disk Capacity KB: {0.totalDiskCapacityInKB}'.format(info)\n    device_number = 1\n    if info.deviceUrl:\n        for device_url in info.deviceUrl:\n            print 'HttpNfcLeaseDeviceUrl: {1}\\n' \\\n                  'Device URL Import Key: {0.importKey}\\n' \\\n                  'Device URL Key: {0.key}\\n' \\\n                  'Device URL: {0.url}\\n' \\\n                  'Device URL Size: {0.fileSize}\\n' \\\n                  'SSL Thumbprint: {0.sslThumbprint}\\n'.format(device_url,\n                                                               device_number)\n            if not device_url.targetId:\n                print \"No targetId found for this device\"\n                print \"Device is not eligible for export. This could be a mounted iso or img of some sort\"\n                print \"It will NOT be downloaded\\n\"\n\n            device_number += 1\n    else:\n        print 'No devices were found.'", "response": "Prints information about the lease and its HTTP URLs for up and download file backings."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbreaks down vSphere SOAP cookie into a vSphere cookie and returns the vSphere cookie as a dictionary with cookie_name and cookie_text.", "response": "def break_down_cookie(cookie):\n    \"\"\" Breaks down vSphere SOAP cookie\n    :param cookie: vSphere SOAP cookie\n    :type cookie: str\n    :return: Dictionary with cookie_name: cookie_value\n    \"\"\"\n    cookie_a = cookie.split(';')\n    cookie_name = cookie_a[0].split('=')[0]\n    cookie_text = ' {0}; ${1}'.format(cookie_a[0].split('=')[1],\n                                      cookie_a[1].lstrip())\n    return {cookie_name: cookie_text}"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download_device(headers, cookies, temp_target_disk,\n                    device_url, lease_updater,\n                    total_bytes_written, total_bytes_to_write):\n    \"\"\" Download disk device of HttpNfcLease.info.deviceUrl\n    list of devices\n    :param headers: Request headers\n    :type cookies: dict\n    :param cookies: Request cookies (session)\n    :type cookies: dict\n    :param temp_target_disk: file name to write\n    :type temp_target_disk: str\n    :param device_url: deviceUrl.url\n    :type device_url: str\n    :param lease_updater:\n    :type lease_updater: LeaseProgressUpdater\n    :param total_bytes_written: Bytes written so far\n    :type total_bytes_to_write: long\n    :param total_bytes_to_write: VM unshared storage\n    :type total_bytes_to_write: long\n    :return:\n    \"\"\"\n    with open(temp_target_disk, 'wb') as handle:\n        response = requests.get(device_url, stream=True,\n                                headers=headers,\n                                cookies=cookies, verify=False)\n        # response other than 200\n        if not response.ok:\n            response.raise_for_status()\n        # keeping track of progress\n        current_bytes_written = 0\n        written_pct = 0\n        print \"Exporting from vCenter...\"\n        print \"\"\n        last_time = 0\n        for block in response.iter_content(chunk_size=1073741824):\n            # filter out keep-alive new chunks\n            if block:\n                handle.write(block)\n                handle.flush()\n                os.fsync(handle.fileno())\n\n            prev_pct = written_pct\n            # Percent is unreliable as i can't find a way to know the size of the disk compressed\n            current_bytes_written += len(block)\n            # written_pct_float = (float(current_bytes_written + total_bytes_written) / float(total_bytes_to_write) * 100)\n            # written_pct = int(written_pct_float)\n            # Only do the bytes to gb conversion every 5 seconds\n            if int(time.time()) > last_time + 3:\n                dl_in_mb = (total_bytes_written + current_bytes_written) /1024 /1024\n                last_time = int(time.time())\n\n            print (\"\\r {} Mb Downloaded \".format(dl_in_mb)),\n\n        #    if written_pct > prev_pct:\n        #       lease_updater.progressPercent = int(written_pct)\n\n    return current_bytes_written", "response": "Download disk device of HttpNfcLease. info. deviceUrl and write it to temp_target_disk."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nattempt to connect to vCenter and return a SmartConnect object", "response": "def vcenter_connect(self):\n        \"\"\"\n        Attempt to connect to vCenter\n        :return:\n        \"\"\"\n        try:\n            si = SmartConnect(\n                host=self.host,\n                user=self.user,\n                pwd=self.password,\n                port=self.port)\n            # disconnect vc\n            atexit.register(Disconnect, si)\n        except vim.fault.InvalidLogin as e:\n            print \"Unable to connect to vcenter because of: {}\".format(e.msg)\n            sys.exit(5)\n        return si"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_vm_obj(self):\n        uuid = VcenterInterfaces.get_vcenter_vm_uuid_by_name(self.host, self.user, self.password, self.name)\n        # connect to vc\n\n        # Getting VM data\n        vm_obj = self.vcenter_conn.content.searchIndex.FindByUuid(None, uuid, True, True)\n        # VM does exist\n        if not vm_obj:\n            print 'VM {} does not exist'.format(uuid)\n            sys.exit(1)\n\n        # VM must be powered off to export\n        if not vm_obj.runtime.powerState == \\\n                vim.VirtualMachine.PowerState.poweredOff:\n            print 'VM {} must be powered off'.format(vm_obj.name)\n            sys.exit(1)\n\n        return vm_obj", "response": "Search for vm in vcenter and return the object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvalidating that the save directory exists if not create it", "response": "def validate_save_dir(self):\n        \"\"\"\n        Validate that the save directory exists, if not, create it\n        :return: str directory\n        \"\"\"\n        # checking if working directory exists\n        print 'Working dir: {} '.format(self.workdir)\n        if not os.path.isdir(self.workdir):\n            print 'Creating working directory {}'.format(self.workdir)\n            os.mkdir(self.workdir)\n        # actual target directory for VM\n        target_directory = os.path.join(self.workdir, self.vm_obj.config.instanceUuid)\n        print 'Target dir: {}'.format(target_directory)\n        if not os.path.isdir(target_directory):\n            print 'Creating target dir {}'.format(target_directory)\n            os.mkdir(target_directory)\n        return target_directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_ovf_descriptor(self, ovf_files):\n        print 'Getting OVF Manager'\n        ovf_manager = self.vcenter_conn.content.ovfManager\n        print 'Creating OVF Descriptor'\n        ovf_parameters = vim.OvfManager.CreateDescriptorParams()\n        ovf_parameters.name = self.name\n        ovf_parameters.ovfFiles = ovf_files\n        vm_descriptor_result = ovf_manager.CreateDescriptor(obj=self.vm_obj,\n                                                            cdp=ovf_parameters)\n        if vm_descriptor_result.error:\n            raise vm_descriptor_result.error[0].fault\n        else:\n            vm_descriptor = vm_descriptor_result.ovfDescriptor\n            target_ovf_descriptor_path = os.path.join(self.vm_dl_path,\n                                                      self.name + '.ovf')\n            print 'Writing OVF Descriptor {}'.format(\n                target_ovf_descriptor_path)\n            with open(target_ovf_descriptor_path, 'wb') as handle:\n                handle.write(vm_descriptor)", "response": "Write the OVF Descriptor to a file"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexports OVf of currently iterated VM.", "response": "def export_ovf(self):\n        \"\"\"\n        Exports OVf of currently iterated VM (dictated by api.env.hosts)\n        :return: ovf location\n        \"\"\"\n\n        # Breaking down SOAP Cookie &\n        # creating Header\n        soap_cookie = self.vcenter_conn._stub.cookie\n        cookies = break_down_cookie(soap_cookie)\n        headers = {'Accept': 'application/x-vnd.vmware-streamVmdk'}  # not required\n        # Getting HTTP NFC Lease\n        http_nfc_lease = self.vm_obj.ExportVm()\n\n        # starting lease updater\n        lease_updater = LeaseProgressUpdater(http_nfc_lease, 30)\n        lease_updater.start()\n        # Creating list for ovf files which will be value of\n        # ovfFiles parameter in vim.OvfManager.CreateDescriptorParams\n        ovf_files = list()\n        total_bytes_written = 0\n        # http_nfc_lease.info.totalDiskCapacityInKB not real\n        # download size\n        total_bytes_to_write = self.vm_obj.summary.storage.unshared\n\n        while True:\n            if http_nfc_lease.state == vim.HttpNfcLease.State.ready:\n                print 'HTTP NFC Lease Ready'\n                print_http_nfc_lease_info(http_nfc_lease.info)\n\n                for deviceUrl in http_nfc_lease.info.deviceUrl:\n                    if not deviceUrl.targetId:\n                        continue\n\n                    temp_target_disk = os.path.join(self.vm_dl_path,\n                                                    self.name)\n                    temp_target_disk += \".vmdk\"\n                    print '\\nDownloading {} to {}'.format(deviceUrl.url,\n                                                          temp_target_disk)\n                    current_bytes_written = download_device(\n                        headers=headers, cookies=cookies,\n                        temp_target_disk=temp_target_disk,\n                        device_url=deviceUrl.url,\n                        lease_updater=lease_updater,\n                        total_bytes_written=total_bytes_written,\n                        total_bytes_to_write=total_bytes_to_write)\n                    # Adding up file written bytes to total\n                    total_bytes_written += current_bytes_written\n                    print 'Creating OVF file for {}'.format(temp_target_disk)\n                    # Adding Disk to OVF Files list\n                    ovf_file = vim.OvfManager.OvfFile()\n                    ovf_file.deviceId = deviceUrl.key\n                    ovf_file.path = deviceUrl.targetId\n                    ovf_file.size = current_bytes_written\n                    ovf_files.append(ovf_file)\n                break\n            elif http_nfc_lease.state == vim.HttpNfcLease.State.initializing:\n                print 'HTTP NFC Lease Initializing.'\n            elif http_nfc_lease.state == vim.HttpNfcLease.State.error:\n                raise Exception(\"HTTP NFC Lease error: {}\".format(\n                    http_nfc_lease.state.error))\n            sleep(2)\n            self.write_ovf_descriptor(ovf_files)\n            # ending lease\n            http_nfc_lease.HttpNfcLeaseProgress(100)\n            http_nfc_lease.HttpNfcLeaseComplete()\n            # stopping thread\n            lease_updater.stop()\n        print 'VMDK saved at: {}'.format(temp_target_disk)\n        return temp_target_disk"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef release():\n\n    with settings(warn_only=True):\n        r = local(clom.git['diff-files']('--quiet', '--ignore-submodules', '--'))\n\n    if r.return_code != 0:\n        abort('There are uncommitted changes, commit or stash them before releasing')\n\n    version = open('VERSION.txt').read().strip()\n\n    existing_tag = local(clom.git.tag('-l', version), capture=True)\n    if not existing_tag.strip():\n        print('Releasing %s...' % version)\n        local(clom.git.tag(version))\n\n    if confirm('Push %s to pypi?' % version, default=True):\n        local(clom.git.push('origin', 'HEAD'))\n        local(clom.git.push('origin', version))\n        local(clom.python('setup.py', 'sdist', 'upload'))", "response": "Release current version to pypi\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef history_file(self, value):\n\n        if value is not None:\n            assert type(value) is unicode, \"'{0}' attribute: '{1}' type is not 'unicode'!\".format(\n                \"history_file\", value)\n        self.__history_file = value", "response": "Setter for **self. __history_file ** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef paths(self, value):\n\n        if value is not None:\n            assert type(value) in (tuple, list), \"'{0}' attribute: '{1}' type is not 'tuple' or 'list'!\".format(\n                \"paths\", value)\n            for element in value:\n                assert type(element) is unicode, \"'{0}' attribute: '{1}' type is not 'unicode'!\".format(\n                    \"paths\", element)\n                assert os.path.exists(element), \"'{0}' attribute: '{1}' directory doesn't exists!\".format(\"paths\",\n                                                                                                          element)\n        self.__paths = value", "response": "Setter for **self. paths** attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, patch, default=None):\n\n        try:\n            return self.__getitem__(patch)\n        except KeyError as error:\n            return default", "response": "Get given patch value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_patch(self, name, path):\n\n        patch = foundations.strings.get_splitext_basename(path)\n        LOGGER.debug(\"> Current patch: '{0}'.\".format(patch))\n\n        directory = os.path.dirname(path)\n        not directory in sys.path and sys.path.append(directory)\n\n        module = __import__(patch)\n        if hasattr(module, \"apply\") and hasattr(module, \"UID\"):\n            self.__patches[name] = Patch(name=name,\n                                         path=path,\n                                         module=module,\n                                         apply=getattr(module, \"apply\"),\n                                         uid=getattr(module, \"UID\"))\n        else:\n            raise umbra.exceptions.PatchInterfaceError(\n                \"{0} | '{1}' is not a valid patch and has been rejected!\".format(self.__class__.__name__, patch))\n        return True", "response": "Registers given patch.\n\n        :param name: Patch name.\n        :type name: unicode\n        :param path: Patch path.\n        :type path: unicode\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register_patches(self):\n\n        if not self.__paths:\n            return False\n\n        unregistered_patches = []\n        for path in self.paths:\n            for file in foundations.walkers.files_walker(path, (\"\\.{0}$\".format(self.__extension),), (\"\\._\",)):\n                name = foundations.strings.get_splitext_basename(file)\n                if not self.register_patch(name, file):\n                    unregistered_patches.append(name)\n\n        if not unregistered_patches:\n            return True\n        else:\n            raise umbra.exceptions.PatchRegistrationError(\n                \"{0} | '{1}' patches failed to register!\".format(self.__class__.__name__,\n                                                                 \", \".join(unregistered_patches)))", "response": "Registers the patches.\n\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\napplies given patch. :param patch: Patch. :type patch: Patch :return: Method success. :rtype: bool", "response": "def apply_patch(self, patch):\n        \"\"\"\n        Applies given patch.\n\n        :param patch: Patch.\n        :type patch: Patch\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        history_file = File(self.__history_file)\n        patches_history = history_file.cache() and [line.strip() for line in history_file.content] or []\n\n        if patch.uid not in patches_history:\n            LOGGER.debug(\"> Applying '{0}' patch!\".format(patch.name))\n            if patch.apply():\n                history_file.content = [\"{0}\\n\".format(patch.uid)]\n                history_file.append()\n            else:\n                raise umbra.exceptions.PatchApplyError(\"{0} | '{1}' patch failed to apply!\".format(\n                    self.__class__.__name__, patch.path))\n        else:\n            LOGGER.debug(\"> '{0}' patch is already applied!\".format(patch.name))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\napply the patches. :return: Method success. :rtype: bool", "response": "def apply_patches(self):\n        \"\"\"\n        Applies the patches.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        success = True\n        for name, patch in sorted(self):\n            success = self.apply_patch(patch)\n        return success"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the patch with given uid.", "response": "def get_patch_from_uid(self, uid):\n        \"\"\"\n        Returns the patch with given uid.\n\n        :param uid: Patch uid.\n        :type uid: unicode\n        :return: Patch.\n        :rtype: Patch\n        \"\"\"\n\n        for name, patch in self:\n            if patch.uid == uid:\n                return patch"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef style(self, value):\n\n        if value is not None:\n            assert type(value) is Style, \"'{0}' attribute: '{1}' type is not 'Style'!\".format(\"style\", value)\n            style = Style()\n            for item in (self.__default_style, value):\n                style.update(item)\n            value = style\n        self.__style = value", "response": "Sets the style of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef paint(self, painter, option, index):\n\n        if option.state & QStyle.State_MouseOver:\n            styleSheet = self.__style.hover\n        elif option.state & QStyle.State_Selected:\n            styleSheet = self.__style.highlight\n        else:\n            styleSheet = self.__style.default\n\n        self.__label.setStyleSheet(styleSheet)\n        data = index.model().data(index, Qt.DisplayRole)\n        self.__label.setText(umbra.ui.common.QVariant_to_string(data))\n        self.__label.setFixedSize(option.rect.size())\n        painter.save()\n        painter.translate(option.rect.topLeft())\n        self.__label.render(painter)\n        painter.restore()", "response": "Reimplement the QStyledItemDelegate. paint method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef call_openssl(cmd, message, silent=False):\n    if silent:\n        with open(os.devnull, 'w') as devnull:\n            return subprocess.check_call(cmd, shell=True, stdout=devnull,\n                                         stderr=subprocess.STDOUT)\n    else:\n        print message\n        return subprocess.check_call(cmd, shell=True)", "response": "Calls a command in openssl - style"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a private key for the specified file", "response": "def gen_private_key(filepath, silent=False):\n    \"\"\"\n    generate ssl private key\n    :param filepath: file path to the key file\n    :param silent: whether to suppress output\n    \"\"\"\n    cmd = 'openssl genrsa -out {} 2048'.format(filepath)\n    message = 'generate private key {}'.format(filepath)\n    call_openssl(cmd, message, silent)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gen_self_signed_cert(filepath, keyfile, days, silent=False):\n    cmd = (\n        'openssl req -x509 -new -nodes -key {} -days {} -out {} -subj \"{}\"'\n    ).format(keyfile, days, filepath, SUBJECT)\n    message = 'generate self signed certificate {} for {} days'.format(\n        filepath, days)\n    call_openssl(cmd, message, silent)", "response": "Generate self signed ssl certificate for a given file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate SSL certificate request", "response": "def gen_cert_request(filepath, keyfile, config, silent=False):\n    \"\"\"\n    generate certificate request\n    :param filepath: file path to the certificate request\n    :param keyfile: file path to the private key\n    :param silent: whether to suppress output\n    \"\"\"\n    message = 'generate ssl certificate request'\n    cmd = (\n        'openssl req -new -key {} -out {} -subj \"{}\"'\n        ' -extensions v3_req -config {}').format(\n            keyfile, filepath, SUBJECT, config)\n    call_openssl(cmd, message, silent)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsign a certificate request", "response": "def sign_cert_request(filepath, cert_req, ca_crt, ca_key, days, extfile,\n                      silent=False):\n    \"\"\"\n    generate self signed ssl certificate, i.e. a private CA certificate\n    :param filepath: file path to the key file\n    :param keyfile: file path to the private key\n    :param days: valid duration for the certificate\n    :param silent: whether to suppress output\n    \"\"\"\n    message = 'sign certificate request'\n    cmd = ('openssl x509 -req -in {} -CA {} -CAkey {} -CAcreateserial'\n           ' -out {} -days {} -extfile {} -extensions v3_req').format(\n               cert_req, ca_crt, ca_key, filepath, days, extfile)\n    call_openssl(cmd, message, silent)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gen_ca_cert(filename, dirname, days, silent=False):\n    keyfile = os.path.join(dirname, '{}.key'.format(filename))\n    ca_crt = os.path.join(dirname, '{}.crt'.format(filename))\n    gen_private_key(keyfile, silent)\n    gen_self_signed_cert(ca_crt, keyfile, days, silent)", "response": "Generate a CA key and certificate key pair."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a non CA key and certificate pair for a private key and certificate.", "response": "def gen_non_ca_cert(filename, dirname, days, ip_list, dns_list,\n                    ca_crt, ca_key, silent=False):\n    \"\"\"\n    generate a non CA key and certificate key pair signed by the private\n    CA key and crt.\n    :param filename: prefix for the key and cert file\n    :param dirname: name of the directory\n    :param days: days of the certificate being valid\n    :ip_list: a list of ip address to be included in the certificate\n    :dns_list: a list of dns names to be included in the certificate\n    :ca_key: file path to the CA key\n    :ca_crt: file path to the CA crt\n    :param silent: whether to suppress output\n    \"\"\"\n    key_file = os.path.join(dirname, '{}.key'.format(filename))\n    req = os.path.join(dirname, '{}.csr'.format(filename))\n    crt = os.path.join(dirname, '{}.crt'.format(filename))\n    gen_private_key(key_file, silent)\n    alt_names = []\n\n    for ind, ip in enumerate(ip_list):\n        alt_names.append('IP.{} = {}'.format(ind + 1, ip))\n    for ind, dns in enumerate(dns_list):\n        alt_names.append('DNS.{} = {}'.format(ind + 1, dns))\n\n    conf = tempfile.mktemp()\n    open(conf, 'w').write(SUBJECT_ALT_NAME + '\\n'.join(alt_names))\n    gen_cert_request(req, key_file, conf, silent)\n    sign_cert_request(crt, req, ca_crt, ca_key, days, conf, silent)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\noutput the text format of the ssl certificate", "response": "def check_cert(certfile):\n    \"\"\"\n    output the text format of the certificate\n    :param filepath: file path to the ssl certificate\n    :returns: string\n    \"\"\"\n    cmd = 'openssl x509 -in {} -text -noout'.format(certfile)\n    out = subprocess.check_output(cmd, shell=True)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_key_cert_match(keyfile, certfile):\n    key_modulus = subprocess.check_output(\n        'openssl rsa -noout -modulus -in {}'.format(keyfile),\n        shell=True)\n    cert_modulus = subprocess.check_output(\n        'openssl x509 -noout -modulus -in {}'.format(certfile),\n        shell=True)\n    return key_modulus == cert_modulus", "response": "check if the ssl key matches the ssl certificate\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef argument_parser():\n    parser = argparse.ArgumentParser(\n        description='openssl wrapper')\n    parser.add_argument('--ca', action='store_true', default=False,\n                        dest='is_ca',\n                        help='Is it a Certificate Authority certificate?')\n    parser.add_argument('-f', '--filename', type=str, default='localhost',\n                        help='File name prefix of the key and certificate.')\n    parser.add_argument('-d', '--dirname', type=str, default=DEFAULT_CERTS_DIR,\n                        help='Destination directory name.')\n    parser.add_argument('--days', type=int, default=500,\n                        help='Duration of certificate.')\n    parser.add_argument('--ip', nargs='*', default=['127.0.0.1'],\n                        help='IP address.')\n    parser.add_argument('--dns', nargs='*', default=['localhost'],\n                        help='DNS')\n    parser.add_argument('--silent', action='store_true',\n                        help='should the output from the shell be silenced?')\n    return parser", "response": "Returns an argument parser for the command line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint help for all available modules.", "response": "def help(*args):\n    \"\"\"Prints help.\"\"\"\n    from . import commands\n    parser = argparse.ArgumentParser(prog=\"%s %s\" % (__package__, help.__name__), description=help.__doc__)\n    parser.add_argument('COMMAND', help=\"command to show help for\", nargs=\"?\", choices=__all__)\n    args = parser.parse_args(args)\n    if args.COMMAND:\n        for l in getattr(commands, args.COMMAND)('-h'):\n            yield l\n    else:\n        parser.parse_args(['-h'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes a new fragments repository.", "response": "def init(*args):\n    \"\"\"Initialize a new fragments repository. Repository is in a directory named _fragments/, created in either the current working directory, or FRAGMENTS_ROOT if specified.\"\"\"\n    parser = argparse.ArgumentParser(prog=\"%s %s\" % (__package__, init.__name__), description=init.__doc__)\n    parser.add_argument('FRAGMENTS_ROOT', help=\"root directory in which to create the _fragments/ directory\", nargs=\"?\")\n    args = parser.parse_args(args)\n\n    try:\n        config = FragmentsConfig()\n    except ConfigurationFileCorrupt:\n        config = FragmentsConfig(autoload=False)\n        os.rename(config.path, config.path + '.corrupt')\n        config.dump()\n    except ConfigurationFileNotFound:\n        config = FragmentsConfig(autoload=False)\n        config.dump()\n    except ConfigurationDirectoryNotFound:\n        if args.FRAGMENTS_ROOT:\n            configuration_parent = os.path.realpath(args.FRAGMENTS_ROOT)\n        else:\n            configuration_parent = os.getcwd()\n        if os.access(configuration_parent, os.R_OK|os.W_OK):\n            configuration_path = os.path.join(configuration_parent, configuration_directory_name)\n            os.mkdir(configuration_path)\n            config = FragmentsConfig(configuration_path, autoload=False)\n            config.dump()\n        else:\n            raise ExecutionError(\"Could not create fragments directory in '%s', aborting.\\n(Do you have the correct permissions?)\" % configuration_parent)\n    else:\n        raise ExecutionError(\"Current fragments configuration found in '%s', aborting.\" % config.path)\n    yield \"Fragments configuration created in '%s'\" % config.path"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the current status of the fragments repository, limited to FILENAME(s) if specified. Limit output to files with status STATUS, if present.", "response": "def status(*args):\n    \"\"\"\n    Get the current status of the fragments repository, limited to FILENAME(s) if specified.\n    Limit output to files with status STATUS, if present.\n    \"\"\"\n    parser = argparse.ArgumentParser(prog=\"%s %s\" % (__package__, status.__name__), description=status.__doc__)\n    parser.add_argument('FILENAME', help=\"files to show status for\", nargs=\"*\", default=['.'])\n    parser.add_argument('-l', '--limit', type=str, dest=\"STATUS\", default='MDAE ', action=\"store\", help=\"limit to files in STATUS\")\n    args = parser.parse_args(args)\n\n    config = FragmentsConfig()\n    yield \"%s configuration version %s.%s.%s\" % ((__package__,) + config['version'])\n    yield \"stored in %s\" % config.directory\n    for s, curr_path in _iterate_over_files(args.FILENAME, config, statuses=args.STATUS):\n        yield _status_to_color.get(s, str)('%s\\t%s' % (s, os.path.relpath(curr_path)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef follow(*args):\n    parser = argparse.ArgumentParser(prog=\"%s %s\" % (__package__, follow.__name__), description=follow.__doc__)\n    parser.add_argument('FILENAME', help=\"files to follow\", nargs=\"+\")\n    args = parser.parse_args(args)\n\n    config = FragmentsConfig()\n    for s, filename in _iterate_over_files(args.FILENAME, config, statuses='?'):\n        fullpath = os.path.realpath(filename)\n        if fullpath.startswith(config.root):\n            key = os.path.relpath(fullpath, config.root)\n            if key in config['files']:\n                yield \"'%s' is already being followed\" % os.path.relpath(filename)\n                continue\n            if os.access(fullpath, os.W_OK|os.R_OK):\n                file_sha = _file_key(key)\n                config['files'][key] = file_sha\n                yield \"'%s' is now being followed (SHA-256: '%s')\" % (os.path.relpath(filename), file_sha)\n            else:\n                yield \"Could not access '%s' to follow it\" % os.path.relpath(filename)\n        else:\n            yield \"Could not follow '%s'; it is outside the repository\" % os.path.relpath(filename)\n    config.dump()", "response": "Follow a file or directory."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef diff(*args):\n    parser = argparse.ArgumentParser(prog=\"%s %s\" % (__package__, diff.__name__), description=diff.__doc__)\n    parser.add_argument('FILENAME', help=\"file(s) to show changes in\", nargs=\"*\", default=['.'])\n    parser.add_argument('-U', '--unified', type=int, dest=\"NUM\", default=3, action=\"store\", help=\"number of lines of context to show\")\n    args = parser.parse_args(args)\n\n    config = FragmentsConfig()\n\n    for s, curr_path in _iterate_over_files(args.FILENAME, config, statuses='MAD'):\n        key = os.path.relpath(curr_path, config.root)\n        if key not in config['files']:\n            yield \"Could not diff '%s', it is not being followed\" % os.path.relpath(curr_path)\n            continue\n\n        if s in 'MAD':\n            repo_lines = []\n            curr_lines = []\n            if s in 'MA':\n                with _smart_open(curr_path, 'r') as curr_file:\n                    curr_lines = curr_file.readlines()\n            if s in 'MD':\n                repo_path = os.path.join(config.directory, config['files'][key])\n                with _smart_open(repo_path, 'r') as repo_file:\n                    repo_lines = repo_file.readlines()\n            weave = Weave()\n            weave.add_revision(1, repo_lines, [])\n            weave.add_revision(2, curr_lines, [])\n            for l in _full_diff(weave.merge(1, 2), key, context_lines=args.NUM):\n                yield l", "response": "Show differences between committed and uncommitted versions limited to FILENAME if specified."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncommits changes to the fragments repository limited to FILENAME if specified.", "response": "def commit(*args):\n    \"\"\"Commit changes to the fragments repository, limited to FILENAME(s) if specified.\"\"\"\n    parser = argparse.ArgumentParser(prog=\"%s %s\" % (__package__, commit.__name__), description=commit.__doc__)\n    parser.add_argument('FILENAME', help=\"file(s) to commit\", nargs=\"*\", default=['.'])\n    args = parser.parse_args(args)\n\n    config = FragmentsConfig()\n\n    for s, curr_path in _iterate_over_files(args.FILENAME, config, statuses='MAD'):\n        key = os.path.relpath(curr_path, config.root)\n        if key not in config['files']:\n            yield \"Could not commit '%s' because it is not being followed\" % os.path.relpath(curr_path)\n            continue\n\n        if s in 'MA':\n            repo_path = os.path.join(config.directory, config['files'][key])\n            with _smart_open(repo_path, 'w') as repo_file:\n                with _smart_open(curr_path, 'r') as curr_file:\n                    repo_file.write(curr_file.read())\n            os.utime(repo_path, os.stat(curr_path)[7:9])\n            yield \"'%s' committed\" % os.path.relpath(curr_path)\n        elif s == 'D':\n            yield \"Could not commit '%s' because it has been removed, instead revert or forget it\" % os.path.relpath(curr_path)\n        elif s == ' ':\n            yield \"Could not commit '%s' because it has not been changed\" % os.path.relpath(curr_path)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fork(*args):\n    parser = argparse.ArgumentParser(prog=\"%s %s\" % (__package__, fork.__name__), description=fork.__doc__)\n    parser.add_argument('SOURCE_FILENAME', help=\"old file names\", nargs=\"+\")\n    parser.add_argument('TARGET_FILENAME', help=\"new file name\")\n    parser.add_argument('-U', '--unified', type=int, dest=\"NUM\", default=3, action=\"store\", help=\"number of lines of context to use\")\n    args = parser.parse_args(args)\n\n    config = FragmentsConfig()\n    new_path = os.path.realpath(args.TARGET_FILENAME)\n    new_key = os.path.relpath(new_path, config.root)\n    if new_key in config['files']:\n        yield \"Could not fork into '%s', it is already followed\" % os.path.relpath(args.TARGET_FILENAME)\n        return\n    if os.access(new_path, os.R_OK|os.W_OK):\n        yield \"Could not fork into '%s', the file already exists\" % os.path.relpath(args.TARGET_FILENAME)\n        return\n\n    old_filenames = []\n    for s, old_name in _iterate_over_files(args.SOURCE_FILENAME, config, statuses='MA ?'):\n        old_path = os.path.realpath(old_name)\n        if s == 'D' or not os.access(old_path, os.R_OK):\n            yield \"Skipping '%s' while forking, it does not exist\" % os.path.relpath(old_path)\n        else:\n            old_filenames.append(old_path)\n            if s == '?':\n                yield \"Warning, '%s' not being followed\" % os.path.relpath(old_path)\n\n    if not old_filenames:\n        yield \"Could not fork; no valid source files specified\"\n        return\n\n    weave = Weave()\n\n    with _smart_open(old_filenames[0], 'r') as new_file:\n        new_lines = new_file.readlines()\n    previous_revision = 1\n    weave.add_revision(previous_revision, new_lines, [])\n    for old_name in old_filenames[1:]:\n        current_revision = previous_revision + 1\n        with _smart_open(old_name, 'r') as old_file:\n            weave.add_revision(current_revision, old_file.readlines(), [])\n        new_lines = []\n        diff_output = weave.merge(previous_revision, current_revision)\n        i = 0\n        while i < len(diff_output):\n            line_or_conflict = diff_output[i]\n            if isinstance(line_or_conflict, tuple):\n                old, new = line_or_conflict\n                following_conflict_index = 0  # index of furthest following conflict within args.NUM lines\n                for j, loc in enumerate(diff_output[i+1:i+1+args.NUM]):\n                    if isinstance(loc, tuple):\n                        following_conflict_index = j\n                new_lines.extend(['\\n'] * (following_conflict_index+1))  # add a blank line for each line and conflict we are skipping\n                i += following_conflict_index\n            else:\n                new_lines.append(line_or_conflict)\n            i += 1\n        previous_revision = current_revision + 1\n        weave.add_revision(previous_revision, new_lines, [])\n\n    with _smart_open(new_path, 'w') as new_file:\n        new_file.writelines(new_lines)\n    yield \"Forked new file in '%s', remember to follow and commit it\" % os.path.relpath(args.TARGET_FILENAME)\n    config.dump()", "response": "Fork a new file into a new file in the target file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fcd2dri(inpFCD, outSTRM, ignored):\n    # print >> outSTRM, \"v1\\n<t>,<v>,<grad>,<n>\\n[s],[km/h],[%],[1/min]\\n\"\n    print(\"v1\\n<t>,<v>,<grad>\\n[s],[km/h],[%]\", file=outSTRM)\n    for q in inpFCD:\n        if q.vehicle:\n            for v in q.vehicle:\n                percSlope = math.sin(float(v.slope)) * 100.\n                print(\"%s,%.3f,%s\" % (\n                    sumolib._intTime(q.time), float(v.speed) * 3.6, percSlope), file=outSTRM)", "response": "Reformats the contents of the given fcd - output file into a. dri file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef net2str(net, outSTRM):\n    if outSTRM is not None:\n        print(\"Str-Id,Sp,SegAnX,SegEnX,SegAnY,SegEnY\", file=outSTRM)\n    sIDm = sumolib._Running()\n    for e in net._edges:\n        eid = sIDm.g(e._id)\n        if outSTRM is not None:\n            c1 = e._from._coord\n            c2 = e._to._coord\n            print(\"%s,%s,%s,%s,%s,%s\" %\n                  (eid, len(e._lanes), c1[0], c2[0], c1[1], c2[1]), file=outSTRM)\n    return sIDm", "response": "Writes the network object given as inpNET as a. str file readable by PHEM."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreformatting the contents of the given fcd - output file into a. fzp file.", "response": "def fcd2fzp(inpFCD, outSTRM, further):\n    \"\"\"\n    Reformats the contents of the given fcd-output file into a .fzp file, readable\n    by PHEM. The fcd-output \"fcd\" must be a valid file name of an fcd-output.\n\n    The \"sIDm\" parameter must be a map from SUMO-edge ids to their numerical\n    representation as generated by toSTR(inpNET, outSTRM).\n    Returns two maps, the first from vehicle ids to a numerical representation,\n    the second from vehicle type ids to a numerical representation.\n    \"\"\"\n    sIDm = further[\"phemStreetMap\"]\n    if outSTRM is not None:\n        print(\n            \"t,WeltX,WeltY,Veh. No,v,Gradient,veh.Typ-Id,Str-Id\", file=outSTRM)\n    vIDm = sumolib._Running(further[\"orig-ids\"], True)\n    vtIDm = sumolib._Running()\n    vtIDm.g(\"PKW\")\n    vtIDm.g(\"PKW_equipped\")\n    vtIDm.g(\"LKW\")\n    vtIDm.g(\"BUS\")\n    for q in inpFCD:\n        if q.vehicle:\n            for v in q.vehicle:\n                vid = vIDm.g(v.id)\n                aType = _convType(v.type)\n                vtid = vtIDm.g(aType)\n                sid = sIDm.g(v.edge)\n                percSlope = math.sin(float(v.slope)) * 100.\n                if outSTRM is not None:\n                    print(\"%s,%s,%s,%s,%.3f,%s,%s,%s\" % (\n                        sumolib._intTime(q.time), float(v.x), float(v.y),\n                        vid, float(v.speed) * 3.6, percSlope, vtid, sid), file=outSTRM)\n    return vIDm, vtIDm"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef vehicleTypes2flt(outSTRM, vtIDm):\n    for q in sorted(vtIDm._m):\n        print(\"%s,%s,%s\" %\n              (vtIDm.g(q), \"<VEHDIR>\\PC\\PC_%s.GEN\" % q, 1.), file=outSTRM)", "response": "Writes the vehicle ids stored in vtIDm to outSTRM."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the issue date of the asset", "response": "def issue_date(self, value):\n        \"\"\"\n        The date on which the asset is issued\n        :param value:\n        :return:\n        \"\"\"\n        self._issue_date = parse(value).date() if isinstance(value, type_check) else value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the maturity_date attribute of the asset set", "response": "def maturity_date(self, value):\n        \"\"\"\n        The date on which the asset matures and no longer holds value\n        :param value:\n        :return:\n        \"\"\"\n        self._maturity_date = parse(value).date() if isinstance(value, type_check) else value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving a file to a specific file.", "response": "def save(self, filesto, upload_to=None, name=None, secret=None, prefix=None,\n             allowed=None, denied=None, max_size=None, **kwargs):\n        \"\"\"\n        Except for `filesto`, all of these parameters are optional, so only\n        bother setting the ones relevant to *this upload*.\n\n        filesto\n        :   A `werkzeug.FileUploader`.\n\n        upload_to\n        :   Relative path to where to upload\n\n        secret\n        :   If True, instead of the original filename, a random one'll\n             be used.\n\n        prefix\n        :   To avoid race-conditions between users uploading files with\n            the same name at the same time. If `secret` is True, this\n            will be ignored.\n\n        name\n        :   If set, it'll be used as the name of the uploaded file.\n            Instead of a string, this can also be a callable.\n\n        allowed\n        :   List of allowed file extensions. `None` to allow all\n            of them. If the uploaded file doesn't have one of these\n            extensions, an `UnsupportedMediaType` exception will be\n            raised.\n\n        denied\n        :   List of forbidden extensions. Set to `None` to disable.\n            If the uploaded file *does* have one of these extensions, a\n            `UnsupportedMediaType` exception will be raised.\n\n        max_size\n        :   Maximum file size, in bytes, that file can have.\n            Note: The attribute `max_content_length` defined in the\n            `request` object has higher priority.\n\n        \"\"\"\n        if not filesto:\n            return None\n        upload_to = upload_to or self.upload_to\n        secret = secret or self.secret\n        prefix = prefix or self.prefix\n        original_filename = filesto.filename\n        allowed = allowed or self.allowed\n        denied = denied or self.denied\n\n        self.validate(filesto, allowed, denied, max_size)\n\n        if callable(upload_to):\n            filepath = upload_to(original_filename)\n        else:\n            filepath = upload_to\n\n        oname, ext = os.path.splitext(original_filename)\n        if name:\n            new_name = name(original_filename) if callable(name) else name\n        else:\n            new_name = get_random_filename() if secret else prefix + oname\n\n        filename = get_unique_filename(self.base_path, filepath, new_name, ext=ext)\n        fullpath = os.path.join(\n            make_dirs(self.base_path, filepath),\n            filename\n        )\n        filesto.save(fullpath)\n        filesize = os.path.getsize(fullpath)\n\n        # Post validation\n        if max_size and filesize > max_size:\n            self.delete_file(fullpath)\n            raise RequestEntityTooLarge\n\n        return os.path.join(filepath, filename)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntransforms a xxx hex color to xxxxxx.", "response": "def normalize_hex(hex_color):\n    \"\"\"Transform a xxx hex color to xxxxxx.\n    \"\"\"\n    hex_color = hex_color.replace('#', '').lower()\n    length = len(hex_color)\n    if length in (6, 8):\n        return '#' + hex_color\n    if length not in (3, 4):\n        return None\n    strhex = u'#%s%s%s' % (\n        hex_color[0] * 2,\n        hex_color[1] * 2,\n        hex_color[2] * 2)\n    if length == 4:\n        strhex += hex_color[3] * 2\n    return strhex"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef normalize_rgb(r, g, b, a):\n    r = int(r, 10)\n    g = int(g, 10)\n    b = int(b, 10)\n    if a:\n        a = float(a) * 256\n    if r > 255 or g > 255 or b > 255 or (a and a > 255):\n        return None\n    color = '#%02x%02x%02x' % (r, g, b)\n    if a:\n        color += '%02x' % int(a)\n    return color", "response": "Transform a rgb color to hex color."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a generic numpy ndarray into an MRSData instance by copying the MRS specific parameters from self into new_array.", "response": "def inherit(self, new_array):\n        \"\"\"\n        Converts a generic numpy ndarray into an MRSData instance by copying\n        its own MRS specific parameters. This is useful when performing some\n        processing on the MRSData object gives a bare NDArray result.\n\n        :param new_array: the ndarray to be converted to MRSData\n        :return: a new MRSData instance with data from new_array and parameters from self.\n        \"\"\"\n        cast_array = new_array.view(MRSData)\n        cast_array._dt = self.dt\n        cast_array._f0 = self.f0\n        cast_array._te = self.te\n        cast_array.ppm0 = self.ppm0\n        cast_array.voxel_dimensions = self.voxel_dimensions\n        cast_array.transform = self.transform\n        cast_array.metadata = self.metadata\n        return cast_array"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the Fourier transformed and shifted data", "response": "def spectrum(self):\n        \"\"\"\n        Returns the Fourier transformed and shifted data\n\n        :return:\n        \"\"\"\n        return numpy.fft.fftshift(numpy.fft.fft(self, axis=-1), axes=-1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef time_axis(self):\n        return numpy.arange(0.0, self.dt * self.np, self.dt)", "response": "Returns an array of the sample times in seconds for each point in the FID."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef frequency_axis(self):\n        return numpy.linspace(-self.sw / 2, self.sw / 2, self.np, endpoint=False)", "response": "Returns an array of frequencies in Hertz ranging from - sw / 2 to np."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an array of frequencies in PPM.", "response": "def frequency_axis_ppm(self):\n        \"\"\"\n        Returns an array of frequencies in PPM.\n\n        :return:\n        \"\"\"\n        return numpy.linspace(self.hertz_to_ppm(-self.sw / 2.0),\n                              self.hertz_to_ppm(self.sw / 2.0),\n                              self.np, endpoint=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_scanner(self, x, y, z):\n        if self.transform is None:\n            raise ValueError(\"No transform set for MRSData object {}\".format(self))\n\n        transformed_point = self.transform * numpy.matrix([x, y, z, 1]).T\n\n        return numpy.squeeze(numpy.asarray(transformed_point))[0:3]", "response": "Converts a 3d position in MRSData space to the scanner reference frame."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a 3d position in the scanner reference frame to the MRSData space.", "response": "def from_scanner(self, x, y, z):\n        \"\"\"\n        Converts a 3d position in the scanner reference frame to the MRSData space\n\n        :param x:\n        :param y:\n        :param z:\n        :return:\n        \"\"\"\n        if self.transform is None:\n            raise ValueError(\"No transform set for MRSData object {}\".format(self))\n\n        transformed_point = numpy.linalg.inv(self.transform) * numpy.matrix([x, y, z, 1]).T\n\n        return numpy.squeeze(numpy.asarray(transformed_point))[0:3]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert OAI string to MARC XML string.", "response": "def _oai_to_xml(marc_oai):  # TODO: move this to MARC XML parser?\n    \"\"\"\n    Convert OAI to MARC XML.\n\n    Args:\n        marc_oai (str): String with either OAI or MARC XML.\n\n    Returns:\n        str: String with MARC XML.\n    \"\"\"\n    record = MARCXMLRecord(marc_oai)\n    record.oai_marc = False\n\n    return record.to_XML()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds proper XML namespace to the MARC XML record.", "response": "def _add_namespace(marc_xml):\n    \"\"\"\n    Add proper XML namespace to the `marc_xml` record.\n\n    Args:\n        marc_xml (str): String representation of the XML record.\n\n    Returns:\n        str: XML with namespace.\n    \"\"\"\n    dom = marc_xml\n\n    if isinstance(dom, basestring):\n        dom = dhtmlparser.parseString(marc_xml)\n\n    root = dom.find(\"root\")\n    if root:\n        root[0].params = {}\n\n    for record in dom.find(\"record\"):\n        record.params = {}\n\n    collections = dom.find(\"collection\")\n    if not collections:\n        record = dom.find(\"record\")[0]\n        return XML_TEMPLATE.replace(\"$CONTENT\", str(record))\n\n    for col in collections:\n        col.params[\"xmlns\"] = \"http://www.loc.gov/MARC21/slim\"\n        col.params[\"xmlns:xsi\"] = \"http://www.w3.org/2001/XMLSchema-instance\"\n        col.params[\"xsi:schemaLocation\"] = \"http://www.loc.gov/MARC21/slim \" + \\\n                   \"http://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd\"\n\n    return str(dom)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading the content of a file.", "response": "def _read_content_or_path(content_or_path):\n    \"\"\"\n    If `content_or_path` contains ``\\\\n``, return it. Else assume, that it is\n    path and read file at that path.\n\n    Args:\n        content_or_path (str): Content or path to the file.\n\n    Returns:\n        str: Content.\n\n    Raises:\n        IOError: whhen the file is not found.\n    \"\"\"\n    if \"\\n\" in content_or_path.strip():\n        return content_or_path\n\n    if not os.path.exists(content_or_path):\n        raise IOError(\"File '%s' doesn't exists!\" % content_or_path)\n\n    with open(content_or_path) as f:\n        return f.read()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads MARC XML or OAI file and return XML in required format with all necessities.", "response": "def _read_marcxml(xml):\n    \"\"\"\n    Read MARC XML or OAI file, convert, add namespace and return XML in\n    required format with all necessities.\n\n    Args:\n        xml (str): Filename or XML string. Don't use ``\\\\n`` in case of\n                   filename.\n\n    Returns:\n        obj: Required XML parsed with ``lxml.etree``.\n    \"\"\"\n    # read file, if `xml` is valid file path\n    marc_xml = _read_content_or_path(xml)\n\n\n    # process input file - convert it from possible OAI to MARC XML and add\n    # required XML namespaces\n    marc_xml = _oai_to_xml(marc_xml)\n    marc_xml = _add_namespace(marc_xml)\n\n    file_obj = StringIO.StringIO(marc_xml)\n\n    return ET.parse(file_obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _read_template(template):\n    template = _read_content_or_path(template)\n    file_obj = StringIO.StringIO(template)\n\n    return ET.parse(file_obj)", "response": "Read XSLT template.\n\n    Args:\n        template (str): Filename or XML string. Don't use ``\\\\n`` in case of\n                        filename.\n\n    Returns:\n        obj: Required XML parsed with ``lxml.etree``."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntransforming xml using XSLT template.", "response": "def xslt_transformation(xml, template):\n    \"\"\"\n    Transform `xml` using XSLT `template`.\n\n    Args:\n        xml (str): Filename or XML string. Don't use ``\\\\n`` in case of\n                   filename.\n        template (str): Filename or XML string. Don't use ``\\\\n`` in case of\n                        filename.\n\n    Returns:\n        str: Transformed `xml` as string.\n    \"\"\"\n    transformer = ET.XSLT(\n        _read_template(template)\n    )\n    newdom = transformer(\n        _read_marcxml(xml)\n    )\n\n    return ET.tostring(newdom, pretty_print=True, encoding=\"utf-8\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef process(self, data):\n        fields = []\n        for res in data:\n            for epname, out in six.iteritems(res.status):\n                fields.append(\n                    [out.get('state'),\n                     epname,\n                     out.get('formatted_filename'),\n                     out.get('messages')])\n\n        if fields:\n            table.write_output(fields)", "response": "Process the results from episode processing."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef log(fn):\n\n    def func(*args, **kwargs):\n        arg_string = \"\"\n        for i in range(0, len(args)):\n            var_name = fn.__code__.co_varnames[i]\n            if var_name != \"self\":\n                arg_string += var_name + \":\" + str(args[i]) + \",\"\n        arg_string = arg_string[0:len(arg_string) - 1]\n        string = (RED + BOLD + '>> ' + END + 'Calling {0}({1})'.format(fn.__code__.co_name, arg_string))\n        if len(kwargs):\n            string = (RED + BOLD + '>> ' + END + 'Calling {0} with args {1} and kwargs {2}'.format(fn.__code__.co_name,\n                                                                                                   arg_string, kwargs))\n        print(string)\n        result = fn(*args, **kwargs)\n        string = BLUE + BOLD + '<< ' + END + 'Return {0} with result :{1}'.format(fn.__code__.co_name, result)\n        print(string)\n        return result\n\n    return func", "response": "Log a function that takes a list of parameters and returns a result - takes no arguments\n    logs parameters and result - takes no arguments\nApps"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfunction decorator to log parameters and result of a function", "response": "def logx(supress_args=[], supress_all_args=False, supress_result=False, receiver=None):\n    \"\"\"\n    logs parameters and result\n    takes arguments\n        supress_args - list of parameter names to supress\n        supress_all_args - boolean to supress all arguments\n        supress_result - boolean to supress result\n        receiver - custom logging function which takes a string as input; defaults to logging on stdout\n    \"\"\"\n\n    def decorator(fn):\n        def func(*args, **kwargs):\n            if not supress_all_args:\n                arg_string = \"\"\n                for i in range(0, len(args)):\n                    var_name = fn.__code__.co_varnames[i]\n                    if var_name != \"self\" and var_name not in supress_args:\n                        arg_string += var_name + \":\" + str(args[i]) + \",\"\n                arg_string = arg_string[0:len(arg_string) - 1]\n                string = (RED + BOLD + '>> ' + END + 'Calling {0}({1})'.format(fn.__code__.co_name, arg_string))\n                if len(kwargs):\n                    string = (\n                        RED + BOLD + '>> ' + END + 'Calling {0} with args {1} and kwargs {2}'.format(\n                            fn.__code__.co_name,\n                            arg_string, kwargs))\n                if receiver:\n                    receiver(string)\n                else:\n                    print(string)\n\n            result = fn(*args, **kwargs)\n            if not supress_result:\n                string = BLUE + BOLD + '<< ' + END + 'Return {0} with result :{1}'.format(fn.__code__.co_name, result)\n                if receiver:\n                    receiver(string)\n                else:\n                    print(string)\n            return result\n\n        return func\n\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef value_check(arg_name, pos, allowed_values):\n\n    def decorator(fn):\n\n        # brevity compromised in favour of readability\n        def logic(*args, **kwargs):\n            arg_count = len(args)\n            if arg_count:\n                if pos < arg_count:\n                    if args[pos] in allowed_values:\n                        return fn(*args, **kwargs)\n                    else:\n                        raise ValueError(\n                            \"'{0}' at position {1} not in allowed values {2}\".format(args[pos], pos, allowed_values))\n                else:\n                    if arg_name in kwargs:\n                        value = kwargs[arg_name]\n                        if value in allowed_values:\n                            return fn(*args, **kwargs)\n                        else:\n                            raise ValueError(\"'{0}' is not an allowed kwarg\".format(arg_name))\n                    else:\n                        # partially applied functions because of incomplete args, let python handle this\n                        return fn(*args, **kwargs)\n            else:\n                if arg_name in kwargs:\n                    value = kwargs[arg_name]\n                    if value in allowed_values:\n                        return fn(*args, **kwargs)\n                else:\n                    raise ValueError(\"'{0}' is not an allowed kwarg\".format(arg_name))\n\n        return logic\n\n    return decorator", "response": "A function decorator that checks if a function is allowed for a specific value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nallowing type checking at runtime for args or kwargs", "response": "def type_check(arg_name, pos, reqd_type):\n    \"\"\"\n    allows type checking at runtime for args or kwargs\n    \"\"\"\n\n    def decorator(fn):\n\n        # brevity compromised in favour of readability\n        def logic(*args, **kwargs):\n            arg_count = len(args)\n            if arg_count:\n                if pos < arg_count:\n                    if isinstance(args[pos], reqd_type):\n                        return fn(*args, **kwargs)\n                    else:\n                        raise TypeError(\"'{0}' at position {1} not of type {2}\".format(args[pos], pos, reqd_type))\n                else:\n                    if arg_name in kwargs:\n                        value = kwargs[arg_name]\n                        if isinstance(value, reqd_type):\n                            return fn(*args, **kwargs)\n                        else:\n                            raise TypeError(\"'{0}' is not of type {1}\".format(arg_name, reqd_type))\n                    else:\n                        # partially applied functions because of incomplete args, let python handle this\n                        return fn(*args, **kwargs)\n            else:\n                if arg_name in kwargs:\n                    value = kwargs[arg_name]\n                    if isinstance(value, reqd_type):\n                        return fn(*args, **kwargs)\n                else:\n                    raise TypeError(\"'{0}' is not of type {1}\".format(arg_name, reqd_type))\n\n        return logic\n\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes the Widget ui.", "response": "def __initialize_ui(self):\n        \"\"\"\n        Initializes the Widget ui.\n        \"\"\"\n\n        self.setAutoScroll(True)\n        self.setSelectionMode(QAbstractItemView.ExtendedSelection)\n        self.setIndentation(self.__tree_view_indentation)\n        self.setDragDropMode(QAbstractItemView.DragOnly)\n        self.setHeaderHidden(True)\n\n        self.__set_default_ui_state()\n\n        # Signals / Slots.\n        self.model().modelReset.connect(self.__set_default_ui_state)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __set_default_ui_state(self, *args):\n\n        LOGGER.debug(\"> Setting default View state!\")\n\n        if not self.model():\n            return\n\n        self.expandAll()\n\n        for column in range(len(self.model().horizontal_headers)):\n            self.resizeColumnToContents(column)", "response": "Sets the Widget default ui state."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dragEnterEvent(self, event):\n\n        LOGGER.debug(\"> '{0}' widget drag enter event accepted!\".format(self.__class__.__name__))\n        event.accept()", "response": "Reimplement the QTabWidget. dragEnterEvent method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dropEvent(self, event):\n\n        LOGGER.debug(\"> '{0}' widget drop event accepted!\".format(self.__class__.__name__))\n        self.content_dropped.emit(event)", "response": "Reimplement the QTabWidget. dropEvent method."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef t_DOCCOMMENT(t):\n    if pos == -1:\n        pos = t.value.rfind('\\'\\'\\'')\n    t.value = '/**' + t.value[3:pos] + '**/'\n    return t", "response": "t is a DOCCOMMENT token"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef t_NATIVEPHP(t):\n    r'<\\?php((?!<\\?php)[\\s\\S])*\\?>[ \\t]*(?=\\n)'\n    lineNoInc(t)\n    t.value = t.value[6:].lstrip()\n    pos2 = t.value.rfind('?>')\n    t.value = t.value[0:pos2].rstrip()\n    # print t.value\n    return t", "response": "t is a token that is used to parse the native PHP code"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef t_INDENTIFIER(t):\n    r'(\\$?[_a-zA-Z][_a-zA-Z0-9]*)|(__[A-Z_]+__)'\n    if t.value in reserved:\n        t.type = t.value.upper()\n        if t.value in reservedMap:\n            t.value = reservedMap[t.value]\n    elif t.value in strStatment:\n        t.type = 'STATEMENT'\n    return t", "response": "A function to handle the INDENTIFIER types."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef default_target(self, value):\n\n        if value is not None:\n            assert type(value) is unicode, \"'{0}' attribute: '{1}' type is not 'unicode'!\".format(\n                \"default_target\", value)\n            assert os.path.exists(value), \"'{0}' attribute: '{1}' file doesn't exists!\".format(\"default_target\", value)\n        self.__default_target = value", "response": "Setter for **self. __default_target ** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef targets_format(self, value):\n\n        if value is not None:\n            assert type(value) is unicode, \"'{0}' attribute: '{1}' type is not 'unicode'!\".format(\n                \"targets_format\", value)\n            assert os.path.exists(value), \"'{0}' attribute: '{1}' file doesn't exists!\".format(\"targets_format\", value)\n        self.__targets_format = value", "response": "Setter for **self. __targets_format** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef default_line_color(self, value):\n\n        if value is not None:\n            assert type(value) is QColor, \"'{0}' attribute: '{1}' type is not 'QColor'!\".format(\n                \"default_line_color\", value)\n        self.__default_line_color = value", "response": "Set the default color of the log entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the Widget ui.", "response": "def __initialize_ui(self):\n        \"\"\"\n        Initializes the Widget ui.\n        \"\"\"\n\n        umbra.ui.common.set_window_default_icon(self)\n\n        self.__model = SearchResultsModel(self)\n        self.__delegate = RichText_QStyledItemDelegate(self)\n\n        self.Search_Results_treeView.setParent(None)\n        self.Search_Results_treeView = SearchResults_QTreeView(self,\n                                                               self.__model,\n                                                               message=\"No Search Result to view!\")\n        self.Search_Results_treeView.setItemDelegate(self.__delegate)\n        self.Search_Results_treeView.setObjectName(\"Search_Results_treeView\")\n        self.Search_Results_frame_gridLayout.addWidget(self.Search_Results_treeView, 0, 0)\n        self.__view = self.Search_Results_treeView\n        self.__view.setContextMenuPolicy(Qt.ActionsContextMenu)\n        self.__view_add_actions()\n\n        self.__search_patterns_model = self.__container.search_and_replace.search_patterns_model\n        self.Search_comboBox.setModel(self.__container.search_and_replace.search_patterns_model)\n        self.Search_comboBox.setInsertPolicy(QComboBox.InsertAtTop)\n        self.Search_comboBox.completer().setCaseSensitivity(Qt.CaseSensitive)\n\n        self.__replace_with_patterns_model = self.__container.search_and_replace.replace_with_patterns_model\n        self.Replace_With_comboBox.setModel(self.__container.search_and_replace.replace_with_patterns_model)\n        self.Replace_With_comboBox.setInsertPolicy(QComboBox.InsertAtTop)\n        self.Replace_With_comboBox.completer().setCaseSensitivity(Qt.CaseSensitive)\n\n        self.Where_lineEdit.setParent(None)\n        self.Where_lineEdit = Search_QLineEdit(self)\n        self.Where_lineEdit.setObjectName(\"Where_lineEdit\")\n        self.Where_frame_gridLayout.addWidget(self.Where_lineEdit, 0, 0)\n        self.__locations_menu = QMenu()\n        for title, location in self.__locations.iteritems():\n            self.__locations_menu.addAction(self.__container.engine.actions_manager.register_action(\n                \"Actions|Umbra|Components|factory.script_editor|Search In Files|{0}\".format(title),\n                text=\"{0}\".format(title),\n                slot=functools.partial(self.__add_location, location)))\n        self.Where_lineEdit.search_active_label.set_menu(self.__locations_menu)\n        self.Where_lineEdit.setPlaceholderText(\"Use the magnifier to add locations!\")\n\n        self.installEventFilter(ValidationFilter(self))\n\n        # Signals / Slots.\n        self.__view.selectionModel().selectionChanged.connect(self.__view_selectionModel__selectionChanged)\n        self.__view.doubleClicked.connect(self.__view__doubleClicked)\n        self.__search_patterns_model.pattern_inserted.connect(functools.partial(\n            self.__patterns_model__pattern_inserted, self.Search_comboBox))\n        self.__replace_with_patterns_model.pattern_inserted.connect(functools.partial(\n            self.__patterns_model__pattern_inserted, self.Replace_With_comboBox))\n        self.Search_pushButton.clicked.connect(self.__Search_pushButton__clicked)\n        self.Close_pushButton.clicked.connect(self.__Close_pushButton__clicked)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __view_add_actions(self):\n\n        self.__view.addAction(self.__container.engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|Search In Files|Replace All\",\n            slot=self.__view_replace_all_action__triggered))\n        self.__view.addAction(self.__container.engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|Search In Files|Replace Selected\",\n            slot=self.__view_replace_selected_action__triggered))\n        separator_action = QAction(self.__view)\n        separator_action.setSeparator(True)\n        self.__view.addAction(separator_action)\n        self.__view.addAction(self.__container.engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|Search In Files|Save All\",\n            slot=self.__view_save_all_action__triggered))\n        self.__view.addAction(self.__container.engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|Search In Files|Save Selected\",\n            slot=self.__view_save_selected_action__triggered))", "response": "Adds the actions to the view."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __add_location(self, type, *args):\n\n        if type == \"directory\":\n            location = umbra.ui.common.store_last_browsed_path((QFileDialog.getExistingDirectory(self,\n                                                                                                 \"Add Directory:\",\n                                                                                                 RuntimeGlobals.last_browsed_path)))\n        elif type == \"file\":\n            location = umbra.ui.common.store_last_browsed_path((QFileDialog.getOpenFileName(self,\n                                                                                            \"Add File:\",\n                                                                                            RuntimeGlobals.last_browsed_path,\n                                                                                            \"All Files (*)\")))\n        elif type == \"editors\":\n            location = self.__targets_format.format(self.__default_target)\n        elif type == \"include_filter\":\n            location = self.__filters_in_format.format(self.__default_filter_in)\n        elif type == \"exclude_filter\":\n            location = self.__filters_out_format.format(self.__default_filter_out)\n\n        location and self.Where_lineEdit.setText(\", \".join(filter(bool, (foundations.strings.to_string(\n            self.Where_lineEdit.text()), location))))", "response": "Adds the location of the current context menu entry."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nformatting the given occurence and returns the matching rich html text.", "response": "def __format_occurence(self, occurence):\n        \"\"\"\n        Formats the given occurence and returns the matching rich html text.\n\n        :param occurence: Occurence to format.\n        :type occurence: Occurence\n        :return: Rich text.\n        :rtype: unicode\n        \"\"\"\n\n        color = \"rgb({0}, {1}, {2})\"\n        span_format = \"<span style=\\\"color: {0};\\\">{{0}}</span>\".format(color.format(self.__default_line_color.red(),\n                                                                                     self.__default_line_color.green(),\n                                                                                     self.__default_line_color.blue()))\n        line = foundations.strings.to_string(occurence.text)\n        start = span_format.format(line[:occurence.column])\n        pattern = \"<b>{0}</b>\".format(line[occurence.column:occurence.column + occurence.length])\n        end = span_format.format(line[occurence.column + occurence.length:])\n        return \"\".join((start, pattern, end))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __format_replace_metrics(self, file, metrics):\n\n        color = \"rgb({0}, {1}, {2})\"\n        span_format = \"<span style=\\\"color: {0};\\\">{{0}}</span>\".format(color.format(self.__default_line_color.red(),\n                                                                                     self.__default_line_color.green(),\n                                                                                     self.__default_line_color.blue()))\n        dir_name, base_name = (os.path.dirname(file), os.path.basename(file))\n\n        return \"\".join((span_format.format(\"'\"),\n                        span_format.format(dir_name),\n                        span_format.format(os.path.sep),\n                        base_name,\n                        span_format.format(\"' file: '\"),\n                        foundations.strings.to_string(metrics),\n                        span_format.format(\"' occurence(s) replaced!\")))", "response": "Formats the given replace metrics and returns the matching rich html text."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __highlight_occurence(self, file, occurence):\n\n        if not self.__container.get_editor(file):\n            cache_data = self.__files_cache.get_content(file)\n            if cache_data:\n                document = cache_data.document or self.__get_document(cache_data.content)\n                self.__container.load_document(document, file)\n                self.__uncache(file)\n            else:\n                self.__container.load_file(file)\n        else:\n            self.__container.set_current_editor(file)\n\n        if not occurence:\n            return\n\n        cursor = self.__container.get_current_editor().textCursor()\n        cursor.setPosition(occurence.position, QTextCursor.MoveAnchor)\n        cursor.setPosition(occurence.position + occurence.length, QTextCursor.KeepAnchor)\n        self.__container.get_current_editor().setTextCursor(cursor)", "response": "Highlights given file occurence."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a QTextDocument instance with given content.", "response": "def __get_document(self, content):\n        \"\"\"\n        Returns a `QTextDocument <http://doc.qt.nokia.com/qtextdocument.html>`_ class instance\n        with given content.\n\n        :return: Document.\n        :rtype: QTextDocument\n        \"\"\"\n\n        document = QTextDocument(QString(content))\n        document.clearUndoRedoStacks()\n        document.setModified(False)\n        return document"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __replace_within_document(self, document, occurrences, replacement_pattern):\n\n        cursor = QTextCursor(document)\n        cursor.beginEditBlock()\n        offset = count = 0\n        for occurence in sorted(occurrences, key=lambda x: x.position):\n            cursor.setPosition(offset + occurence.position, QTextCursor.MoveAnchor)\n            cursor.setPosition(offset + occurence.position + occurence.length, QTextCursor.KeepAnchor)\n            cursor.insertText(replacement_pattern)\n            offset += len(replacement_pattern) - occurence.length\n            count += 1\n        cursor.endEditBlock()\n        return count", "response": "Replaces given pattern occurrences in given document."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the current search and replace settings.", "response": "def __get_settings(self):\n        \"\"\"\n        Returns the current search and replace settings.\n\n        :return: Settings.\n        :rtype: dict\n        \"\"\"\n\n        return {\"case_sensitive\": self.Case_Sensitive_checkBox.isChecked(),\n                \"whole_word\": self.Whole_Word_checkBox.isChecked(),\n                \"regular_expressions\": self.Regular_Expressions_checkBox.isChecked()}"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninterrupts the current search.", "response": "def __interrupt_search(self):\n        \"\"\"\n        Interrupt the current search.\n        \"\"\"\n\n        if self.__search_worker_thread:\n            self.__search_worker_thread.quit()\n            self.__search_worker_thread.wait()\n            self.__container.engine.stop_processing(warning=False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncache given file. :param file: File to cache. :type file: unicode :param content: File content. :type content: list :param document: File document. :type document: QTextDocument", "response": "def __cache(self, file, content, document):\n        \"\"\"\n        Caches given file.\n\n        :param file: File to cache.\n        :type file: unicode\n        :param content: File content.\n        :type content: list\n        :param document: File document.\n        :type document: QTextDocument\n        \"\"\"\n\n        self.__files_cache.add_content(**{file: CacheData(content=content, document=document)})"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the Model Nodes using given search results.", "response": "def set_search_results(self, search_results):\n        \"\"\"\n        Sets the Model Nodes using given search results.\n\n        :param search_results: Search results.\n        :type search_results: list\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        root_node = umbra.ui.nodes.DefaultNode(name=\"InvisibleRootNode\")\n        for search_result in search_results:\n            search_file_node = SearchFileNode(name=search_result.file,\n                                              parent=root_node)\n            search_file_node.update(search_result)\n            width = \\\n                max(self.__default_line_number_width,\n                    max([len(foundations.strings.to_string(occurence.line)) for occurence in\n                         search_result.occurrences]))\n            for occurence in search_result.occurrences:\n                formatter = \"{{0:>{0}}}\".format(width)\n                name = \"{0}:{1}\".format(formatter.format(occurence.line + 1).replace(\" \", \"&nbsp;\"),\n                                        self.__format_occurence(occurence))\n                search_occurence_node = SearchOccurenceNode(name=name,\n                                                            parent=search_file_node)\n                search_occurence_node.update(occurence)\n        self.__model.initialize_model(root_node)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_replace_results(self, replace_results):\n\n        root_node = umbra.ui.nodes.DefaultNode(name=\"InvisibleRootNode\")\n        for file, metrics in sorted(replace_results.iteritems()):\n            replace_result_node = ReplaceResultNode(name=self.__format_replace_metrics(file, metrics),\n                                                    parent=root_node,\n                                                    file=file)\n        self.__model.initialize_model(root_node)\n        return True", "response": "Sets the Model Nodes using given replace results."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch user defined locations for search pattern.", "response": "def search(self):\n        \"\"\"\n        Searchs user defined locations for search pattern.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        self.__interrupt_search()\n\n        search_pattern = self.Search_comboBox.currentText()\n        replacement_pattern = self.Replace_With_comboBox.currentText()\n        if not search_pattern:\n            return False\n\n        SearchAndReplace.insert_pattern(search_pattern, self.__search_patterns_model)\n        SearchAndReplace.insert_pattern(replacement_pattern, self.__replace_with_patterns_model)\n\n        location = umbra.ui.common.parse_location(\n            foundations.strings.to_string(self.Where_lineEdit.text()) or\n            self.__targets_format.format(self.__default_target))\n        self.__ignore_hidden_files and location.filters_out.append(\"\\\\\\.|/\\.\")\n\n        settings = self.__get_settings()\n\n        self.__search_worker_thread = Search_worker(self, search_pattern, location, settings)\n        # Signals / Slots.\n        self.__search_worker_thread.searchFinished.connect(self.__search_worker_thread__searchFinished)\n\n        self.__container.engine.worker_threads.append(self.__search_worker_thread)\n        self.__container.engine.start_processing(\"Searching In Files ...\")\n        self.__search_worker_thread.start()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreplace user defined files search pattern occurrences with replacement pattern using given nodes. :param nodes: Nodes. :type nodes: list :return: Method success. :rtype: bool", "response": "def replace(self, nodes):\n        \"\"\"\n        Replaces user defined files search pattern occurrences with replacement pattern using given nodes.\n\n        :param nodes: Nodes.\n        :type nodes: list\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        files = {}\n        for node in nodes:\n            if node.family == \"SearchFile\":\n                files[node.file] = node.children\n            elif node.family == \"SearchOccurence\":\n                file = node.parent.file\n                if not file in files:\n                    files[file] = []\n                files[file].append(node)\n\n        replacement_pattern = self.Replace_With_comboBox.currentText()\n        SearchAndReplace.insert_pattern(replacement_pattern, self.__replace_with_patterns_model)\n\n        replace_results = {}\n        for file, occurrences in files.iteritems():\n            editor = self.__container.get_editor(file)\n            if editor:\n                document = editor.document()\n            else:\n                cache_data = self.__files_cache.get_content(file)\n                if cache_data is None:\n                    LOGGER.warning(\n                        \"!> {0} | '{1}' file doesn't exists in files cache!\".format(self.__class__.__name__, file))\n                    continue\n\n                content = self.__files_cache.get_content(file).content\n                document = self.__get_document(content)\n                self.__cache(file, content, document)\n            replace_results[file] = self.__replace_within_document(document, occurrences, replacement_pattern)\n\n        self.set_replace_results(replace_results)\n        self.__container.engine.notifications_manager.notify(\n            \"{0} | '{1}' pattern occurence(s) replaced in '{2}' files!\".format(self.__class__.__name__,\n                                                                               sum(replace_results.values()),\n                                                                               len(replace_results.keys())))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_files(self, nodes):\n\n        metrics = {\"Opened\": 0, \"Cached\": 0}\n        for node in nodes:\n            file = node.file\n            if self.__container.get_editor(file):\n                if self.__container.save_file(file):\n                    metrics[\"Opened\"] += 1\n                    self.__uncache(file)\n            else:\n                cache_data = self.__files_cache.get_content(file)\n                if cache_data is None:\n                    LOGGER.warning(\n                        \"!> {0} | '{1}' file doesn't exists in files cache!\".format(self.__class__.__name__, file))\n                    continue\n\n                if cache_data.document:\n                    file_handle = File(file)\n                    file_handle.content = [cache_data.document.toPlainText().toUtf8()]\n                    if file_handle.write():\n                        metrics[\"Cached\"] += 1\n                        self.__uncache(file)\n                else:\n                    LOGGER.warning(\n                        \"!> {0} | '{1}' file document doesn't exists in files cache!\".format(self.__class__.__name__,\n                                                                                             file))\n\n        self.__container.engine.notifications_manager.notify(\n            \"{0} | '{1}' opened file(s) and '{2}' cached file(s) saved!\".format(self.__class__.__name__,\n                                                                                metrics[\"Opened\"],\n                                                                                metrics[\"Cached\"]))", "response": "Saves user defined files using give nodes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_service():\n    global _SERVICE_MANAGER\n\n    if _SERVICE_MANAGER is None:\n        _SERVICE_MANAGER = driver.DriverManager(\n            namespace='tvrenamer.data.services',\n            name=cfg.CONF.lookup_service,\n            invoke_on_load=True)\n    return _SERVICE_MANAGER.driver", "response": "Load the configured service."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_ncVar(varName, nc=None, **kwargs):\r\n        '''\r\n        Loads a variable from the NetCDF file and saves it as a data structure.\r\n        \r\n        :parameter varName: variable name\r\n        :keywords kwargs: additional keyword arguments for slicing the dataset. Keywords should be named the name of the dimensions to subsample along and associated value should be a length 2 or 3 tuple (min,max,<step>).\r\n        \r\n        .. note: slices are provided in this interval : [min,max] (ie. including both extremities)\r\n        \r\n        '''\r\n        \r\n        if (nc is None) : raise Exception('No Netcdf file passed')\r\n        \r\n        var = nc.variables[varName]\r\n        \r\n        var.set_auto_maskandscale(False)\r\n        \r\n        #Load dimensions\r\n        varDim = [str(dim) for dim in var.dimensions]\r\n        missDim=len(varDim) == 0\r\n        if (missDim):\r\n            warn('No dimension found - creating it')\r\n            sh=var[:].shape\r\n            varDimval = sh\r\n            varDim = ['dim_%02i' % (i+1) for i in xrange(len(varDimval))]\r\n        else : varDimval = [len(nc.dimensions[dimname]) for dimname in varDim]\r\n        \r\n        #Load Attributes\r\n        attrStr=var.__dict__\r\n        \r\n        ind_list = [] #Init index list\r\n        dims = OrderedDict({'_ndims':0}) #Init dimensions\r\n        \r\n        dstr=[]\r\n        shape=()\r\n\r\n        #Construct index list\r\n        #looping on variable dimension list\r\n        for vid,vn in enumerate(varDim) :\r\n            \r\n            #No indexation on current dimension\r\n            if not kwargs.has_key(vn) :\r\n                dstr=np.append(dstr,':')\r\n                sz=np.long(varDimval[vid])\r\n#                ind_list.append(range(varDimval[vid])) # if no restriction in kargs then equivalent to [:]\r\n#                dims.update({vn:varDimval[vid]})\r\n            \r\n            #Data is indexed along current dimension\r\n            else :\r\n                drange=kwargs[vn]\r\n                if len(drange) == 2 : drange = drange + (1,)\r\n                if nc.variables.has_key(vn) : #Check if current dimension exists\r\n                    dumvar = nc.variables[vn][:]\r\n                else :\r\n                    dumvar = np.arange(len(nc.dimensions[vn]))\r\n                if vn.startswith('lon') : dumvar=recale(dumvar,degrees=True)\r\n                fg=(dumvar >= drange[0]) & (dumvar <= drange[1])\r\n                if fg.sum() == 0 :\r\n                    #retry switrhcing lon/lat\r\n                    dumvar=recale(dumvar,degrees=True)\r\n                    drange=tuple(recale(drange,degrees=True))#.astype(np.long))\r\n                    fg=(dumvar >= drange[0]) & (dumvar <= drange[1])\r\n                if fg.sum() == 0 :\r\n                    raise IndexError('{0} {1} is not matching given dimensions {2}'.format(vn,(np.nanmin(nc.variables[vn][:]),np.nanmax(nc.variables[vn][:])),drange))\r\n                if len(fg) == 1 :\r\n                    dstr=np.append(dstr,':')\r\n                    sz=1L\r\n                elif len(fg) == 0:\r\n                    sz=0L\r\n                else :\r\n                    dumind=np.arange(varDimval[vid],dtype=long).compress(fg)\r\n                    bg=dumind[0]\r\n                    en=dumind[-1]+1\r\n                    st=long(drange[2])\r\n                    dstr=np.append(dstr,'{0}:{1}:{2}'.format(bg,en,st))\r\n                    sz = np.long(np.mod(np.float(en-bg-1)/st,np.float(en-bg)) + 1.)\r\n            \r\n            dims.update({vn:sz})\r\n            shape = shape + (sz,)\r\n#                if isinstance(dumind, np.ndarray) : dumind = dumind.tolist() #Rq: tolist() can take a very long time to run on large arrays\r\n#                if type(dumind) is not list : dumind = [dumind] \r\n#                ind_list.append(dumind)\r\n#                dims.update({vn:len(dumind)})\r\n        \r\n#        #check index list\r\n#        sz = [np.size(i) for i in ind_list]\r\n        \r\n        dstr=','.join(dstr) #invert dimension list for numpy\r\n#        dstr=','.join(dstr[::-1]) #invert dimension list for numpy\r\n        if missDim : cmd = 'varOut = var[:]'\r\n        else : cmd = 'varOut = var[{0}]'.format(dstr)\r\n        exec(cmd)\r\n        \r\n        #find empty variables\r\n#        if not (atools.where_list([0], shape)[0] == -1) : varOut = var[[0]][[]]\r\n#        else : varOut = var[ind_list]\r\n        \r\n        #Mask it!\r\n        if var.__dict__.has_key('_FillValue') :\r\n            fill_value=var._FillValue\r\n            mask = varOut == var._FillValue\r\n        elif var.__dict__.has_key('missing_value') :\r\n            fill_value=var._FillValue\r\n            mask = varOut == var._FillValue\r\n        else :\r\n            fill_value = None\r\n            mask = np.zeros(varOut.shape, dtype='bool')\r\n        \r\n        #Scale it\r\n        #note : we do not use the *= or += operators to force casting to scaling attribute types\r\n        if var.__dict__.has_key('scale') : varOut = varOut * var.scale\r\n        elif var.__dict__.has_key('scale_factor') : varOut = varOut * var.scale_factor\r\n        if var.__dict__.has_key('add_offset') : varOut = varOut + var.add_offset\r\n        \r\n        #Set masks properly\r\n        if isinstance(varOut, np.ndarray) : varOut = np.ma.masked_array(varOut, mask=mask,dtype=varOut.dtype,fill_value=fill_value)\r\n        elif isinstance(varOut, np.ma.masked_array) : var.mask = mask\r\n        elif np.isscalar(varOut) : varOut = np.ma.masked_array([varOut], mask=mask,dtype=varOut.dtype,fill_value=fill_value) #Case of a scalar: cast to array and force having a shape\r\n        else :\r\n\t\t\ttry: varOut = np.ma.masked_array(np.array(varOut), mask=np.array(mask),dtype=varOut.dtype,fill_value=fill_value)   \r\n\t\t\texcept: raise Exception('This data type (%s) has not been defined - code it!' % type(varOut))\r\n        \r\n        #Update masked data properly\r\n        varOut.data[varOut.mask]=varOut.fill_value\r\n        \r\n        #Switch dimensions \r\n        if not missDim : varOut=np.transpose(varOut,tuple(range(len(dims.keys()[1:]))[::-1]))\r\n        \r\n        #Build up output structure\r\n        dims.update({'_ndims':len(dims.keys()[1:])})\r\n        outStr = {'_dimensions':dims, 'data':varOut}\r\n        \r\n        #Add variable attributes\r\n        for A in var.__dict__.keys():\r\n            outStr[A]=var.getncattr(A)\r\n        \r\n        return outStr", "response": "Load a variable from the NetCDF file and saves it as a data structure."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds dimensions to the current object", "response": "def add(self,dimlist,dimvalues):\r\n        '''\r\n        add dimensions\r\n        \r\n        :parameter dimlist: list of dimensions\r\n        :parameter dimvalues: list of values for dimlist\r\n        '''\r\n        for i,d in enumerate(dimlist):\r\n            self[d] = dimvalues[i]\r\n        \r\n        self.set_ndims()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self,dimlist):\r\n        '''\r\n        get dimensions\r\n        :parameter dimlist: list of dimensions\r\n        '''\r\n        out=()\r\n        for i,d in enumerate(dimlist):\r\n            out+=(super(dimStr, self).get(d,None),)\r\n         \r\n        return out", "response": "get dimensions\r\n        :parameter dimlist: list of dimensions"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npops - removes the first element from the ordered dictionary.", "response": "def pop(self,*args):\r\n        '''\r\n        pop dimensions\r\n        :parameter dimlist: list of dimensions\r\n        :return: popped dimensions (tuple)\r\n        \r\n        .. note: overrides :func:`OrderedDict.pop`\r\n        '''\r\n        nargs=len(args)\r\n        dimlist=args[0] if isiterable(args[0]) else [args[0]]\r\n        missing=args[1] if nargs > 1 else None \r\n        out=()\r\n        for d in dimlist:\r\n            out+=(super(dimStr, self).pop(d,missing),)\r\n            if out[-1] == missing : self.set_ndims()\r\n        \r\n        return out if len(out) > 1 else out[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add(self,attrlist,attrvalues):\r\n        '''\r\n        add an attribute\r\n        \r\n        :parameter dimlist: list of dimensions\r\n        :parameter dimvalues: list of values for dimlist\r\n        '''\r\n        for i,d in enumerate(attrlist):\r\n            self[d] = attrvalues[i]", "response": "add an attribute to the list of dimensions and values for the specified list of attributes"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pop(self,*args):\r\n        '''\r\n        pop dimensions from data structure.\r\n        :parameter dimlist: list of dimensions\r\n        :return: popped dimensions (tuple)\r\n        \r\n        .. note: overrides :func:`OrderedDict.pop`\r\n        '''\r\n        \r\n        nargs=len(args)\r\n        dimlist=args[0] if isiterable(args[0]) else [args[0]]\r\n        missing=args[1] if nargs > 1 else None\r\n        out=()\r\n        for d in dimlist:\r\n            out+=(super(attrStr, self).pop(d,missing),)\r\n        \r\n        return out if len(out) > 1 else out[0]", "response": "pop from the dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npushes a new variable from a given data structure to the existing dataset.", "response": "def push(self,*args,**kwargs):#file,varName,value,**kwargs):\r\n        '''\r\n        append a variable from a given data structure to the existing dataset.\r\n        \r\n        :parameter optional file:\r\n        :parameter name: variable name\r\n        :parameter value: data\r\n        \r\n        :keyword start: broadcast the data to a portion of the dataset. starting index.\r\n        :keyword counts: broadcast the data to a portion of the dataset. number of counts.\r\n        :keyword stride: broadcast the data to a portion of the dataset. stepping along dimension.\r\n        \r\n        '''\r\n        \r\n        reload = False\r\n        \r\n        #Get arguments\r\n        largs=list(args)\r\n        if os.path.exists(largs[0]) :\r\n            file = largs.pop(0)\r\n            self._filename = file\r\n            reload = True\r\n        name = largs.pop(0)\r\n        value = largs.pop(0)\r\n        \r\n        #Get keywords\r\n        start = kwargs.get('start',None)\r\n        counts = kwargs.get('counts',None)\r\n        stride = kwargs.get('stride',None)\r\n        \r\n        \r\n        file = self._filename\r\n        \r\n        if self.verbose == 1 : self.message(1, 'Writing data into file {0}'.format(os.path.basename(file)))\r\n        elif self.verbose > 1 : self.message(2, 'Writing data into file {0}'.format(file))\r\n        ncf=ncfile(file, 'a', format='NETCDF4', clobber=False)\r\n     \r\n        #Get list of recorded parameters:\r\n        par_list = ncf.variables.keys()\r\n        \r\n        #Check if variable exists\r\n        if 'sla' not in par_list : createVariable = True\r\n        else : createVariable = False\r\n        \r\n        \r\n        if not createVariable :\r\n            var=ncf.variables[name]\r\n            \r\n            #Get dimensions\r\n            fileDims=OrderedDict({'_ndims':len(var.dimensions)})\r\n            [fileDims.update({str(d):len(ncf.dimensions[d])}) for d in var.dimensions]\r\n            \r\n            if start is None : start = [0 for sh in var.shape]\r\n            else : start = start[::-1]\r\n            if counts is None : counts = [sh for sh in var.shape]\r\n            else : counts = counts[::-1]\r\n            if stride is None : stride = [1 for sh in var.shape]\r\n            else : stride = stride[::-1]\r\n            \r\n            #Transpose before write\r\n            value=np.transpose(value)\r\n            strides=var[:].strides\r\n            \r\n            #Construct indices (cf.http://docs.scipy.org/doc/numpy-1.5.x/reference/arrays.indexing.html)\r\n            ind=()\r\n            for i in np.arange(len(start)) : ind+=(slice(start[i],start[i]+counts[i],strides[i]),)\r\n            \r\n            #Push data into file\r\n            try : var[ind]=value[:]\r\n            except ValueError : self.Error('Input variable {0} {1} cannot be broadcasted into {2}'.format(name,value.shape,os.path.basename(file)))\r\n            \r\n            #Check if variable is in agreement with dimensions\r\n#            dimStr=self._dimensions #Get dimensions  \r\n            \r\n            ncf.close()\r\n            \r\n            \r\n        else :\r\n            self.Error('This option is not yet implemented')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write(self, data, outfile, clobber=False,format='NETCDF4'):\r\n        '''\r\n        Write a netCDF file using a data structure.\r\n        \r\n        :parameter data: data structure\r\n        :parameter outfile: output file\r\n        :keyword clobber: erase file if it already exists\r\n        :keyword format: NetCDF file format.\r\n        \r\n        .. note :: the data structure requires a \"_dimensions\" field (dimension structure)\r\n        '''\r\n        \r\n        #Open file\r\n        if self.verbose == 1 : self.message(1, 'Writing data file {}'.format(os.path.basename(outfile)))\r\n        elif self.verbose > 1 : self.message(2, 'Writing data file {}'.format(outfile))\r\n        root_grp=ncfile(outfile, 'w', format=format, clobber=clobber)\r\n#        root_grp.description = 'nctools.write() file'\r\n        \r\n        #Get attributes\r\n        if data.has_key('_attributes'):\r\n            self.message(2, 'Adding attributes data')\r\n            attrStr=data.pop('_attributes')\r\n            self.message(4, 'Attribute list (N={0}) :[{1}]'.format(len(attrStr.keys()), ','.join(attrStr.keys())) )\r\n            root_grp.setncatts(attrStr)\r\n        \r\n        #Get dimensions\r\n        dimDict=data.pop('_dimensions')\r\n        ndims=dimDict.pop('_ndims')\r\n        dimlist = dimDict.keys()\r\n        dimVal = dimDict.values()\r\n        \r\n        #Get variables\r\n        parlist = data.keys()\r\n        \r\n        \r\n        # Set up dimensions\r\n        \r\n        #Put dimensions\r\n        for d in dimlist :\r\n            self.message(2, 'Adding D {0}={1}'.format(d,dimDict[d]))\r\n            root_grp.createDimension(d, dimDict[d])\r\n        \r\n#        if data.has_key('p')  : self.Error('Variable name \\'p\\' is not available for use as NetCDF variable name')\r\n        \r\n        #Loop over variables\r\n        for p in parlist :\r\n            \r\n            self.message(4,'Looping parameter list : %s' %p)\r\n            \r\n            #Get dimensions for current variable\r\n            if not data[p].has_key('_dimensions') : warn('_dimension attribute is not set for variable'+p)\r\n            pardim=data[p].pop('_dimensions') if data[p].has_key('_dimensions') else dimStr()\r\n            if isinstance(pardim,dimStr) : pardim=tuple(pardim.keys())\r\n            elif isinstance(pardim,dict) :pardim=tuple(pardim.keys()[1:]) if pardim.has_key(\"_ndims\") else tuple(pardim.keys())\r\n            elif isinstance(pardim,list) : pardim = tuple(pardim)\r\n            elif isinstance(pardim,tuple) : pass\r\n            else : self.Error('_dimensions must be dict, list or tuple - not {0}'.type(pardim))\r\n            \r\n            #Convert to numpy array if scalar or non numpy\r\n            if not hasattr(data[p]['data'],'__iter__') or not hasattr(data[p]['data'], 'dtype'):  data[p]['data']=np.array(data[p]['data'])\r\n\r\n            #Get _FillValue if possible\r\n#            if hasattr(data[p]['data'],'fill_value') : data[p]['_FillValue']=data[p]['data'].fill_value \r\n\r\n#            if not (data[p]['data'].dtype == '|S6') and not (data[p]['data'].dtype == '|S2') :\r\n            self.message(2, 'Adding V {0} (dims={{{1}}},attr={{{2}}})'.\r\n                         format(p,\r\n                                ', '.join(['\\'{0}\\':{1}'.format(d,dimDict[d]) for d in pardim]),\r\n                                ', '.join(['\\'{0}\\':{1}'.format(d,data[p][d]) for d in data[p].keys() if (d != '_dimensions') and (d != 'data')]) )\r\n                         )\r\n            \r\n            if locals().has_key(p) : self.Error('Variable name \\'{0}\\' is already declared - change variable name'.format(p))\r\n            \r\n            #Scale it back\r\n            ##############\r\n            \r\n            #look at scaler factors and offsets in both attributes and data structure keys\r\n            scale_factor=scale_factor=data[p].get('scale_factor',None)\r\n            if scale_factor is None : scale_factor=data[p].get('scale',None)\r\n            if scale_factor is None and hasattr(data[p]['data'],'__dict__') : scale_factor=data[p]['data'].__dict__.get('scale_factor',None)  \r\n            if scale_factor is None and hasattr(data[p]['data'],'__dict__') : scale_factor=data[p]['data'].__dict__.get('scale',None) \r\n            \r\n            \r\n            offset=data[p].get('add_offset',None) \r\n            if offset is None and hasattr(data[p]['data'],'__dict__') : offset=data[p]['data'].__dict__.get('add_offset',None)\r\n            \r\n            #Apply scaling and prepare message\r\n            scale_msg='Apply scaling : {}'.format(p)\r\n            if scale_factor is not None :\r\n                data[p]['data'] = data[p]['data'] / scale_factor\r\n                scale_msg+=' / {0}'.format(scale_factor)\r\n            if offset is not None :\r\n                data[p]['data'] = data[p]['data'] - offset\r\n                scale_msg+=' - {0}'.format(offset)\r\n            \r\n            #show message\r\n            if scale_factor is not None or offset is not None :\r\n                self.message(2,scale_msg)\r\n            \r\n            #Apply fill_value as argument to createVariable function\r\n            if hasattr(data[p]['data'],'fill_value') :\r\n                locals()[p] = root_grp.createVariable(p,\r\n                                               data[p]['data'].dtype if not str(data[p]['data'].dtype).startswith('|S') else 'S1',\r\n                                               pardim,\r\n                                               fill_value=data[p]['data'].fill_value)\r\n            else :\r\n                locals()[p] = root_grp.createVariable(p,\r\n                                               data[p]['data'].dtype if not str(data[p]['data'].dtype).startswith('|S') else 'S1',\r\n                                               pardim)\r\n            \r\n            #Get data and compare to current dimensions\r\n            dumVar=data[p].pop('data')\r\n            ncsh=tuple([long(dimVal[dimlist.index(d)]) for d in pardim if d in dimlist])\r\n            ncdimname=tuple([d for d in pardim if d in dimlist])\r\n            \r\n            #Transposition is done if provided dimensions is not in phase with data dimensions (and if provided dimensions has no unlimited dimensions)\r\n            if not ncsh == dumVar.shape and ncsh.count(0) == 0:\r\n                dimOrder=tuple([ncsh.index(dsh) for dsh in dumVar.shape if dsh in ncsh])\r\n                self.message(2, 'Transposing data axes {0}{1}'.format(ncdimname,dimOrder)) #Make it a bit more explicit...\r\n                if len(dimOrder) > 0:\r\n                    dumVar=dumVar.transpose(dimOrder)\r\n            \r\n            #Transpose data before writing it into file\r\n            locals()[p][:]=dumVar\r\n            #.transpose(tuple(range(len(pardim))[::-1])) #old stuff\r\n                \r\n            #Update with attribute list\r\n            attrDict=locals()[p].__dict__\r\n            attrDict.update(data[p])\r\n            [attrDict.pop(k) for k in  locals()[p].__dict__.keys()]\r\n            \r\n            \r\n            #Get common attributes first\r\n            attrDict.pop('_FillValue',None)\r\n            locals()[p].setncatts(attrDict)\r\n#            for a in attrDict :\r\n#                if not hasattr(locals()[p],a) :\r\n#                    locals()[p].setncattr(a,data[p][a])\r\n        \r\n        self.message(2, 'Closing file')\r\n        root_grp.close()\r\n\r\n        return True", "response": "Write a netCDF file using a data structure."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading data from a NetCDF file and updates the object with the loaded data.", "response": "def read(self,file_pattern,**kwargs):\r\n        '''\r\n        Read data from a NetCDF file\r\n        \r\n        :parameter file_pattern: a file pattern to be globbed (:func:`glob.glob`) or a file list.\r\n        :keyword kwargs: additional keywords to be passed to :meth:`altimetry.tools.nctools.nc.load` (eg. extracting a subset of the file)\r\n        ''' \r\n        \r\n        #Setup file list\r\n        if isinstance(file_pattern, str) : ls = glob.glob(file_pattern)\r\n        elif isinstance(file_pattern,np.ndarray) :\r\n            ls = file_pattern.tolist()\r\n            file_pattern = file_pattern[0]\r\n        \r\n        if len(ls) == 0 :\r\n            self.Error('File pattern not matched : ' + file_pattern)\r\n                \r\n        self.filelist = [os.path.basename(i) for i in ls]\r\n        self.filelist_count = [0] * len(self.filelist)\r\n        enum = list(enumerate(ls))\r\n        enum = zip(*enum)\r\n        \r\n        self.fid_list = np.array(enum[0])\r\n        self.dirname = os.path.dirname(os.path.abspath(file_pattern))\r\n        \r\n        self.par_list = np.array([])\r\n        self.dim_list = np.array([])\r\n        self._dimensions = OrderedDict({'_ndims':0})\r\n         \r\n        #Loop over data files\r\n        #####################\r\n        for i in np.arange(len(self.fid_list)) :\r\n            \r\n            #Read data file\r\n            ###############\r\n            filename = os.path.join(self.dirname,self.filelist[i])\r\n            self.message(1, \"Loading \" + os.path.basename(filename))\r\n            \r\n            res = self.load(filename, **kwargs) #read() function is specific of each class\r\n            #self.update_dataset(res) #update class with loaded data\r\n            \r\n            #self.check_variables()\r\n        \r\n        #self.update()\r\n\r\n        return(res)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a NetCDF file and return a dictionary containing all recorded parameters.", "response": "def load(self, filename, params=None, force=False, depthrange=None, timerange=None, output_is_dict=True, **kwargs):\r\n        \"\"\"\r\n        NetCDF data loader\r\n        \r\n        :parameter filename: file name\r\n        :parameter params: a list of variables to load (default : load ALL variables).\r\n        \r\n        :parameter depthrange: if a depth dimension is found, subset along this dimension.\r\n        :parameter timerange: if a time dimension is found, subset along this dimension. \r\n\r\n        .. note:: using :attr:`altimetry.tools.nctools.limit` allows subsetting to a given region.\r\n\r\n        :parameter kwargs: additional arguments for subsetting along given dimensions.\r\n        \r\n        .. note:: You can index along any dimension by providing the name of the dimensions to subsample along. Values associated to the provided keywords should be a length 2 or 3 tuple (min,max,<step>) (cf. :func:`altimetry.data.nctools.load_ncVar`).\r\n        \r\n        :keyword output_is_dict: data structures are dictionnaries (eg. my_hydro_data.variable['data']). If false uses an object with attributes (eg. my_hydro_data.variable.data). \r\n        \r\n        :return  {type:dict} outStr: Output data structure containing all recorded parameters as specificied by NetCDF file PARAMETER list.\r\n        \r\n        :author: Renaud Dussurget\r\n        \r\n\r\n        \"\"\"\r\n        \r\n        if (params is not None) & isinstance(params,str): params=[params]\r\n        \r\n        #Open file\r\n        self._filename = filename\r\n        try:\r\n            ncf = ncfile(self._filename, \"r\")\r\n        except Exception,e:\r\n            warn(repr(e),stacklevel=2)\r\n            return {}\r\n        \r\n        #Load global attributes\r\n        akeys = ncf.ncattrs()\r\n        attrStr=OrderedDict()\r\n        for A in akeys : attrStr.update({A:ncf.getncattr(A)})\r\n     \r\n        #Get list of recorded parameters:\r\n        dum = ncf.variables.keys()\r\n        nparam = np.shape(dum)[0]\r\n    #        par_list=np.array([''.join(ncf.variables.keys()[0,i,:].compressed()) for i in np.arange(nparam)])\r\n        par_list = np.array(['{0}'.format(v) for v in ncf.variables.keys()])\r\n        \r\n        #remove empty items and update nparam\r\n        par_list = par_list.compress([len(par) != 0 for par in par_list])\r\n        nparam = par_list.size\r\n        \r\n        if nparam == 0 : self.Error('File has no data ({0})'.format(self._filename))\r\n        \r\n        #Get dimensions\r\n        ncdimlist = np.array(['{0}'.format(d) for d in ncf.dimensions.keys()])\r\n        ndims = len(ncdimlist)\r\n        dimStr = OrderedDict()\r\n        dimStr.update({'_ndims':ndims})\r\n    \r\n        if ndims == 0 : self.Error('File has no dimensions ({0})'.format(self._filename))\r\n        \r\n        #Check for the presence of strategic dimensions\r\n        checkedDims = np.array(['lon', 'lat', 'time', 'depth'])\r\n        existDim = -np.ones(4,dtype=int)\r\n        if not self.use_local_dims :\r\n            for i,d in enumerate(ncdimlist) :\r\n                if ( (d.lower().startswith('lon')) | (d.lower().find('longitude') != -1) ) & (d.find('LatLon') ==-1) : existDim[0]=i\r\n                if ( (d.lower().startswith('lat')) | (d.lower().find('latitude') != -1) ) & (d.find('LatLon') ==-1): existDim[1]=i\r\n                if (d.lower().startswith('time')) | (d.lower().startswith('date')) : existDim[2]=i\r\n                if (d.lower().startswith('lev')) | (d.lower().startswith('dep')) : existDim[3]=i\r\n                    \r\n#            existDim[0] = np.where([d.lower().startswith('lon') | (d.lower().find('longitude') != -1) for d in ncdimlist])[0]\r\n#            existDim[1] = np.where([d.lower().startswith('lat') | (d.lower().find('latitude') != -1) for d in ncdimlist])[0]\r\n#            existDim[2] = np.where([(d.lower().startswith('time')) | (d.lower().startswith('date')) for d in ncdimlist])[0]\r\n#            existDim[3] = np.where([(d.lower().startswith('lev')) | (d.lower().startswith('dep')) for d in ncdimlist])[0]\r\n        \r\n        identified = existDim > -1\r\n        \r\n#        checkedDims[identified]=checkedDims[identified][existDim.compress(identified).astype(int)]\r\n#        checkedDims=checkedDims[identified]\r\n        \r\n#        for cn, vn in enumerate(checkedDims) : dimStr.update({cn:len(ncf.dimensions[vn])})\r\n        \r\n        #Update dimension structure with identified dimensions\r\n        #Load dimensional variables\r\n        #TODO : Add scaling here in case...\r\n        for i,d in enumerate(existDim) : \r\n            if identified[i] :\r\n                dimStr.update({ncdimlist[d]:len(ncf.dimensions[ncdimlist[d]])}) #Append dimension\r\n                cmd =  'load_ncVar(\\'' + ncdimlist[d] + '\\',nc=ncf)'\r\n                self.message(4, 'loading : {0}={1}'.format(checkedDims[i],cmd))\r\n                locals()[checkedDims[i]]=load_ncVar(ncdimlist[d], nc=ncf,**kwargs)\r\n\r\n        missdims=set(ncdimlist)\r\n        missdims.difference_update(ncdimlist[existDim[identified]])\r\n        missdims=list(missdims)\r\n\r\n        for i,d in enumerate(missdims) :\r\n            dimStr.update({d:len(ncf.dimensions[d])})\r\n            if ncf.variables.has_key(d) :\r\n                cmd = 'load_ncVar(\\'' + d + '\\',nc=ncf)'\r\n                self.message(4, 'loading : {0}={1}'.format(d,cmd))\r\n                locals()[d]=load_ncVar(d, nc=ncf,**kwargs)\r\n                        \r\n            #If the variable associated to the dimension do not exist, generate it\r\n            else :\r\n                self.message(1, '[WARNING] Netcdf file not standard - creating data for {0} dimnsion'.format(d))\r\n                ndim=len(ncf.dimensions[d])\r\n                cmd = '=var'\r\n                self.message(4, 'loading : {0}={1}'.format(d,cmd))\r\n                locals()[d]={'_dimensions':{'_ndims':1,d:ndim}, 'data':np.arange(ndim)}\r\n        \r\n#        #Update dimension structure with identified dimensions\r\n#        for cn, vn in zip(*(checkedDims[identified], ncdimlist[identified])) : dimStr.update({cn:len(ncf.dimensions[vn])})\r\n#        for vn in ncdimlist[~identified] : dimStr.update({vn:len(ncf.dimensions[vn])})\r\n        \r\n        \r\n        #Load dimensional variables\r\n        #TODO : Add scaling here in case...\r\n#        for cn, vn in zip(*(checkedDims[identified], ncdimlist[identified])) :\r\n##            cmd = 'self.'+cn+'=ncf.variables[\\''+vn+'\\'][:]'\r\n#            cmd = cn + '=load_ncVar(\\'' + vn + '\\',nc=ncf)'\r\n#            self.message(4, 'exec : ' + cmd)\r\n#            exec(cmd)\r\n#            \r\n#        for vn in ncdimlist[~identified] :\r\n##            cmd = 'self.'+vn+'=ncf.variables[\\''+vn+'\\'][:]'\r\n#            cmd = vn + '=load_ncVar(\\'' + vn + '\\',nc=ncf)'\r\n#            self.message(4, 'exec : ' + cmd)\r\n#            exec(cmd)\r\n            \r\n        #Update dimlist with dimensions present in the object\r\n#        dimlist = np.append(checkedDims[identified], ncdimlist[~identified])\r\n\r\n        dimlist=ncdimlist.copy()\r\n#        dimlist[existDim[identified]]=checkedDims[identified]\r\n        if identified.sum() > 0 : dimlist[existDim[identified]]=checkedDims[identified]\r\n        else : dimlist = dimlist[[]]\r\n        \r\n#        for d in ncdimlist[checkedDims[identified]] :\r\n#            if not d.startswith('_') : dimlist = np.append(dimlist,d)\r\n#        dimlist=[(d if not d.startswith('_') else None) for d in dimStr.keys()]\r\n        \r\n        if params is not None :\r\n            if force : par_list = [i.upper() for i in params]\r\n            else :par_list = list(set(params).intersection(par_list))\r\n        else : par_list = par_list.tolist()\r\n        \r\n        #remove dimensional  variable\r\n        for d in ncdimlist[existDim[identified]] :\r\n            par_list.pop(par_list.index(d))\r\n        \r\n        self.message(2, 'Recorded parameters : ' + str(nparam) + ' -> ' + str(par_list))\r\n     \r\n        \r\n        #Extract within limits\r\n        if (existDim[0] > -1) & (existDim[1] > -1):\r\n            llind, flag = in_limits(lon['data'],lat['data'], limit=self.limit)\r\n            if isinstance(flag,tuple) :\r\n                lon['data'] = recale(lon['data'].compress(flag[0]),degrees=True)\r\n                lon['_dimensions'][lon['_dimensions'].keys()[1]] = flag[0].sum()\r\n                lat['data'] = lat['data'].compress(flag[1])\r\n                lat['_dimensions'][lat['_dimensions'].keys()[1]] = flag[1].sum()\r\n            else :\r\n                lon['data'] = recale(lon['data'].compress(flag),degrees=True)\r\n                lon['_dimensions'][lon['_dimensions'].keys()[1]] = flag.sum()\r\n                lat['data'] = lat['data'].compress(flag)\r\n                lat['_dimensions'][lat['_dimensions'].keys()[1]] = flag.sum()\r\n            \r\n            locals()[ncdimlist[existDim[0]]]=lon.copy()\r\n            locals()[ncdimlist[existDim[1]]]=lat.copy()\r\n            \r\n            dimStr.update({ncdimlist[existDim[0]]:len(lon['data'])})\r\n            dimStr.update({ncdimlist[existDim[1]]:len(lat['data'])})\r\n#            self.message(4, 'self.lon & self.lat updated')\r\n        \r\n        if (existDim[2] > -1):\r\n            if (timerange is not None) : timeflag = (time['data'] >= np.min(timerange)) & (time['data'] <= np.max(timerange))\r\n            else : timeflag = np.ones(len(time['data']), dtype=bool)\r\n            if timeflag.sum() == 0 : self.Error('No data within specified depth range (min/max = {0}/{1})'.format(np.min(time), np.max(time)))\r\n            time['data'] = time['data'].compress(timeflag)\r\n            time['_dimensions'][time['_dimensions'].keys()[1]] = timeflag.sum()\r\n            locals()[ncdimlist[existDim[2]]]=time.copy()\r\n            dimStr.update({ncdimlist[existDim[2]]:len(time['data'])})\r\n#            self.message(4, 'self.lon & self.lat updated')\r\n        \r\n        #Extract within depth range\r\n        if (existDim[3] > -1):\r\n            if (depthrange is not None) : depthflag = (depth['data'] >= np.min(depthrange)) & (depth['data'] <= np.max(depthrange))\r\n            else : depthflag = np.ones(len(depth['data']), dtype=bool)\r\n            if depthflag.sum() == 0 : self.Error('No data within specified depth range (min/max = {0}/{1})'.format(np.min(depth), np.max(depth)))\r\n            depth['data'] = depth['data'].compress(depthflag)\r\n            depth['_dimensions'][depth['_dimensions'].keys()[1]] = depthflag.sum()\r\n            locals()[ncdimlist[existDim[3]]]=depth.copy()\r\n            dimStr.update({ncdimlist[existDim[3]]:len(depth['data'])})\r\n        \r\n        #Create output data structure\r\n        outStr = OrderedDict()\r\n        outStr.update({'_dimensions':dimStr})\r\n        outStr.update({'_attributes':attrStr})\r\n        \r\n        if (existDim[0] > -1) : outStr.update({ncdimlist[existDim[0]]:lon})\r\n        if (existDim[1] > -1) : outStr.update({ncdimlist[existDim[1]]:lat})\r\n        if (existDim[2] > -1) : outStr.update({ncdimlist[existDim[2]]:time})\r\n        if (existDim[3] > -1) : outStr.update({ncdimlist[existDim[3]]:depth})\r\n        \r\n        \r\n        #Update object with remaining variables\r\n        for d in dimlist.compress([not outStr.has_key(f) for f in dimlist]) :\r\n#            cmd = 'outStr.update({\\''+d+'\\':'+d+'[\\'data\\']})'\r\n            cmd = 'outStr.update({\\''+d+'\\':'+d+'})'\r\n            self.message(4, 'exec : '+cmd)\r\n            exec(cmd)\r\n        \r\n        ncdimStr=outStr.copy()\r\n        #Get dimension lengths\r\n        shape=()\r\n        for d in dimlist: shape += np.shape(locals()[d]['data'])\r\n        \r\n        ndims = np.size(shape)\r\n     \r\n#        #Create dimension structure\r\n#        curDim = [str(dimname) for dimname in dimStr.keys()[1:]] #[str(dimname) for dimname in ncf.variables['LONGITUDE'].dimensions]\r\n#        curDimval = [dimStr[dim] for dim in curDim] #[len(ncf.dimensions[dimname]) for dimname in curDim]\r\n#   \r\n#        outStr={'_dimensions':{'_ndims':ndims,'nbpoints':sz[0]},'lon':lon,'lat':lat,'date':date}\r\n        \r\n#        for d in dimlist : outStr.update({d:self.__dict__[d]})\r\n\r\n        #Sort NCDIMLIST to match DIMLIST\r\n#        ncdimlist[np.sort(existDim.astype(np.int)[identified])]=ncdimlist[existDim[identified].tolist()]\r\n\r\n        #Setup kwargs with current dimensionnal properties\r\n        for d, ncd in zip(*(dimlist,ncdimlist)):\r\n            if not kwargs.has_key(ncd) :\r\n                if kwargs.has_key(d) :\r\n                    \r\n                    kwargs.update({ncd:kwargs[d]})\r\n                    del kwargs[d]\r\n                else :\r\n                    dvar=ncdimStr[d]['data']\r\n                    if isinstance(dvar,np.ma.masked_array) : kwargs.update({ncd:(np.nanmin(dvar.data),np.nanmax(dvar.data))})\r\n                    else : kwargs.update({ncd:(np.nanmin(dvar),np.nanmax(dvar))})\r\n#            else :\r\n#                outStr['NbLatitudes']['data']        \r\n        for param in par_list :\r\n#            dumVar = load_ncVar(param,  nc=ncf, lon=llind[0], lat=llind[1], time=np.arange(len(time['data'])).compress(timeflag),**kwargs) #Load variables\r\n#            dumVar = load_ncVar(param,  nc=ncf, longitude=(self.limit[1],self.limit[3]), latitude=(self.limit[0],self.limit[2]), time=(self.time.min(),self.time.max()),**kwargs) #Load variables\r\n            \r\n            \r\n            dumVar = load_ncVar(param,  nc=ncf, **kwargs) #Load variables\r\n#            dimStr = dumVar['_dimensions']\r\n            \r\n            #update dimensions\r\n#            curDim = [str(dimname) for dimname in dimStr.keys()[1:]] #[str(dimname) for dimname in ncf.variables['LONGITUDE'].dimensions]\r\n#            curDimval = [dimStr[dim] for dim in curDim] #[len(ncf.dimensions[dimname]) for dimname in curDim]\r\n            \r\n#            curDim = dimlist[where_list(curDim, ncdimlist.tolist())] #Convert to object dimension names\r\n#            curDim = dimlist[where_list(curDim, dimlist.tolist())] #Convert to object dimension names (???)\r\n            \r\n##            curDim = [str(dimname) for dimname in ncf.variables[param].dimensions]\r\n##            curDimval = [len(ncf.dimensions[dimname]) for dimname in curDim]\r\n#            flag = [(np.array(dimname) == outStr['_dimensions'].keys()).sum() == 0 for dimname in curDim] #find dimensions to update\r\n#            dimUpdate = np.array(curDim).compress(flag)\r\n#            for enum in enumerate(dimUpdate) : \r\n#                self.message(2, 'Appending dimensions {0}:{1} to dataStructure'.format(enum[1], np.array(curDimval).compress(flag)[enum[0]]))\r\n#                outStr['_dimensions'].update({enum[1]:np.array(curDimval).compress(flag)[enum[0]]}) #Append new dimension\r\n#                outStr['_dimensions']['_ndims'] += 1 #update dimension counts\r\n            \r\n#            cmd = 'dumStr = {\\'' + param + '\\':dumVar[\\'data\\']}'\r\n\r\n\r\n            #Set list as variable with attributes\r\n#            if (not output_is_dict):\r\n#                var=dumVar.pop('data')\r\n#                for k in dumVar.keys():\r\n#                    setattr(var, k, dumVar.pop(k))\r\n#                dumVar=var.copy()\r\n            \r\n            cmd = 'dumStr = {\\'' + param + '\\':dumVar}'\r\n            self.message(4, 'exec : ' + cmd)\r\n            exec(cmd)\r\n            outStr.update(dumStr)\r\n            \r\n            #Update output dimensions with extracted dimensions\r\n            for ddum in dumStr[param]['_dimensions'].keys()[1:] :\r\n                if outStr['_dimensions'].get(ddum) != dumStr[param]['_dimensions'][ddum] : outStr['_dimensions'][ddum]=dumStr[param]['_dimensions'][ddum]\r\n            \r\n#            cmd = 'self.'+param+'='\r\n        \r\n        ncf.close()\r\n        return outStr"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dictionary containing the attributes of a NetCDF file.", "response": "def attributes(self, filename, **kwargs):\r\n        \"\"\"\r\n        Get attributes of a NetCDF file\r\n        \r\n        :return {type:dict} outStr: Attribute structure.\r\n        :author: Renaud Dussurget\r\n        \"\"\"\r\n        \r\n        #Open file\r\n        self._filename = filename\r\n        ncf = ncfile(self._filename, \"r\")\r\n     \r\n        #Get list of recorded parameters:\r\n        keys = ncf.__dict__.keys()\r\n        outStr = OrderedDict()\r\n        for a in keys: outStr.update({a:ncf.__getattr__(a)})\r\n\r\n        return outStr"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_message(self, app_mxit_id, target_user_ids, message='', contains_markup=True,\n                     spool=None, spool_timeout=None, links=None, scope='message/send'):\n        \"\"\"\n        Send a message (from a Mxit app) to a list of Mxit users\n        \"\"\"\n\n        data = {\n            'From': app_mxit_id,\n            'To': \",\".join(target_user_ids),\n            'Body': message,\n            'ContainsMarkup': contains_markup\n        }\n\n        if spool:\n            data['Spool'] = spool\n        if spool_timeout:\n            data['SpoolTimeOut'] = spool_timeout\n        if links:\n            data['Links'] = links\n\n        return _post(\n            token=self.oauth.get_app_token(scope),\n            uri='/message/send',\n            data=data\n        )", "response": "Send a message to a list of Mxit users"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_user_to_user_message(self, from_user_id, target_user_ids, message='', contains_markup=True,\n                                  scope='message/user'):\n        \"\"\"\n        Send a message (from a Mxit user) to a list of Mxit users\n        \"\"\"\n        return _post(\n            token=self.oauth.get_user_token(scope),\n            uri='/message/send',\n            data={\n                'From': from_user_id,\n                'To': \",\".join(target_user_ids),\n                'Body': message,\n                'ContainsMarkup': contains_markup\n            }\n        )", "response": "Send a message to a list of Mxit users"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves the Mxit user s internal user ID", "response": "def get_user_id(self, mxit_id, scope='profile/public'):\n        \"\"\"\n        Retrieve the Mxit user's internal \"user ID\"\n        No user authentication required\n        \"\"\"\n        user_id = _get(\n            token=self.oauth.get_app_token(scope),\n            uri='/user/lookup/' + urllib.quote(mxit_id)\n        )\n\n        if user_id.startswith('\"') and user_id.endswith('\"'):\n            user_id = user_id[1:-1]\n\n        return user_id"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve the Mxit user s current status message", "response": "def get_status(self, mxit_id, scope='profile/public'):\n        \"\"\"\n        Retrieve the Mxit user's current status\n        No user authentication required\n        \"\"\"\n        status = _get(\n            token=self.oauth.get_app_token(scope),\n            uri='/user/public/statusmessage/' + urllib.quote(mxit_id)\n        )\n\n        if status.startswith('\"') and status.endswith('\"'):\n            status = status[1:-1]\n\n        return status"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_status(self, message, scope='status/write'):\n        return _put(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/statusmessage',\n            data=message\n        )", "response": "Set the Mxit user s status"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve the Mxit user s display name", "response": "def get_display_name(self, mxit_id, scope='profile/public'):\n        \"\"\"\n        Retrieve the Mxit user's display name\n        No user authentication required\n        \"\"\"\n        display_name = _get(\n            token=self.oauth.get_app_token(scope),\n            uri='/user/public/displayname/' + urllib.quote(mxit_id)\n        )\n\n        if display_name.startswith('\"') and display_name.endswith('\"'):\n            display_name = display_name[1:-1]\n\n        return display_name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_avatar(self, mxit_id, output_file_path=None, scope='profile/public'):\n        data = _get(\n            token=self.oauth.get_app_token(scope),\n            uri='/user/public/avatar/' + urllib.quote(mxit_id)\n        )\n\n        if output_file_path:\n            with open(output_file_path, 'w') as f:\n                f.write(data)\n        else:\n            return data", "response": "Retrieve the Mxit user s avatar"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_avatar(self, scope='avatar/write'):\n        return _delete(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/avatar'\n        )", "response": "Delete the Mxit user s avatar"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve the Mxit user s basic profile", "response": "def get_basic_profile(self, user_id, scope='profile/public'):\n        \"\"\"\n        Retrieve the Mxit user's basic profile\n        No user authentication required\n        \"\"\"\n        profile = _get(\n            token=self.oauth.get_app_token(scope),\n            uri='/user/profile/' + urllib.quote(user_id)\n        )\n\n        try:\n            return json.loads(profile)\n        except:\n            raise MxitAPIException('Error parsing profile data')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_full_profile(self, scope='profile/private'):\n        profile = _get(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/profile'\n        )\n\n        try:\n            return json.loads(profile)\n        except:\n            raise MxitAPIException('Error parsing profile data')", "response": "Retrieve the Mxit user s full profile"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the Mxit user s profile with the specified parameters.", "response": "def update_profile(self, about_me=None, display_name=None, email=None, first_name=None, gender=None, last_name=None,\n                       mobile_number=None, relationship_status=None, title=None, where_am_i=None,\n                       scope='profile/write'):\n        \"\"\"\n        Update the Mxit user's profile\n        User authentication required with the following scope: 'profile/write'\n        \"\"\"\n\n        data = {}\n        if about_me:\n            data['AboutMe'] = about_me\n        if display_name:\n            data['DisplayName'] = display_name\n        if email:\n            data['Email'] = email\n        if first_name:\n            data['FirstName'] = first_name\n        if gender:\n            data['Gender'] = gender\n        if last_name:\n            data['LastName'] = last_name\n        if mobile_number:\n            data['MobileNumber'] = mobile_number\n        if relationship_status:\n            data['RelationshipStatus'] = relationship_status\n        if title:\n            data['Title'] = title\n        if where_am_i:\n            data['WhereAmI'] = where_am_i\n\n        if data:\n            _put(\n                token=self.oauth.get_user_token(scope),\n                uri='/user/profile',\n                data=data\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a contact to the user s socialgraph", "response": "def add_contact(self, contact_id, scope='contact/invite'):\n        \"\"\"\n        Add a contact\n        contact_id can either be the mxit ID of a service or a Mxit user\n        User authentication required with the following scope: 'contact/invite'\n        \"\"\"\n        return _put(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/socialgraph/contact/' + urllib.quote(contact_id)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_contact_list(self, list_filter, skip=None, count=None, scope='graph/read'):\n        params = {\n            'filter': list_filter\n        }\n        if skip:\n            params['skip'] = skip\n        if count:\n            params['count'] = count\n\n        contact_list = _get(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/socialgraph/contactlist?' + urllib.urlencode(params)\n        )\n\n        try:\n            return json.loads(contact_list)\n        except:\n            raise MxitAPIException('Error parsing contact_list data')", "response": "Retrieve the Mxit user s full contact list"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_friend_suggestions(self, scope='graph/read'):\n        suggestions = _get(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/socialgraph/suggestions'\n        )\n\n        try:\n            return json.loads(suggestions)\n        except:\n            raise MxitAPIException('Error parsing suggestions data')", "response": "Retrieve the Mxit user s full profile s suggestions"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving a list of the Mxit user s gallery folders", "response": "def get_gallery_folder_list(self, scope='content/read'):\n        \"\"\"\n        Retrieve a list of the Mxit user's gallery folders\n        User authentication required with the following scope: 'content/read'\n        \"\"\"\n        folder_list = _get(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/media'\n        )\n        try:\n            return json.loads(folder_list)\n        except:\n            raise MxitAPIException('Error parsing gallery folder list')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new folder in the Mxit user s gallery", "response": "def create_gallery_folder(self, folder_name, scope='content/write'):\n        \"\"\"\n        Create a new folder in the Mxit user's gallery\n        User authentication required with the following scope: 'content/write'\n        \"\"\"\n        return _post(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/media/' + urllib.quote(folder_name)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_gallery_folder(self, folder_name, scope='content/write'):\n        return _delete(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/media/' + urllib.quote(folder_name)\n        )", "response": "Delete a folder in Mxit user s gallery\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rename_gallery_folder(self, old_folder_name, new_folder_name, scope='content/write'):\n        return _put(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/media/' + urllib.quote(old_folder_name),\n            data=new_folder_name\n        )", "response": "Rename a folder in the Mxit user s gallery\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeletes a file in the Mxit user s gallery", "response": "def delete_gallery_file(self, file_id, scope='content/write'):\n        \"\"\"\n        Delete a file in the Mxit user's gallery\n        User authentication required with the following scope: 'content/write'\n        \"\"\"\n        return _delete(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/media/file/' + urllib.quote(file_id)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrename a file in the Mxit user s gallery", "response": "def rename_gallery_file(self, file_id, new_file_name, scope='content/write'):\n        \"\"\"\n        Rename a file in the Mxit user's gallery\n        User authentication required with the following scope: 'content/write'\n        \"\"\"\n        return _put(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/media/file/' + urllib.quote(file_id),\n            data=new_file_name\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupload a file to a folder in Mxit user s gallery", "response": "def upload_gallery_file(self, folder_name, file_name, data=None, input_file_path=None,\n                            prevent_share=False, content_type=\"image/png\", scope='content/write'):\n        \"\"\"\n        Upload a file to a folder in the Mxit user's gallery\n        User authentication required with the following scope: 'content/write'\n        \"\"\"\n        if input_file_path:\n            with open(input_file_path, 'rb') as f:\n                data = f.read()\n\n        if not data:\n            raise ValueError('Either the data of a file or the path to a file must be provided')\n\n        params = {\n            'fileName': file_name,\n            'preventShare': 'true' if prevent_share else 'false',\n        }\n\n        return _post(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/media/file/' + urllib.quote(folder_name) + '?' + urllib.urlencode(params),\n            data=data,\n            content_type=content_type,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_gallery_item_list(self, folder_name, skip=None, count=None, scope='content/read'):\n\n        params = {}\n        if skip:\n            params['skip'] = skip\n        if count:\n            params['count'] = count\n\n        qs = '?' + urllib.urlencode(params) if params else ''\n\n        folder_item_list = _get(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/media/list/' + urllib.quote(folder_name) + qs\n        )\n        try:\n            return json.loads(folder_item_list)\n        except:\n            raise MxitAPIException('Error parsing gallery folder list')", "response": "Get the item listing in a given folder in the Mxit user s gallery\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a file in the Mxit user s gallery", "response": "def get_gallery_file(self, file_id, output_file_path=None, scope='content/read'):\n        \"\"\"\n        Get a file in the Mxit user's gallery\n        User authentication required with the following scope: 'content/read'\n        \"\"\"\n        data = _get(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/media/content/' + urllib.quote(file_id)\n        )\n\n        if output_file_path:\n            with open(output_file_path, 'w') as f:\n                f.write(data)\n        else:\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuploads a file to store and returns a FileId once file offer has been sent.", "response": "def upload_file_and_send_file_offer(self, file_name, user_id, data=None, input_file_path=None,\n                                        content_type='application/octet-stream', auto_open=False,\n                                        prevent_share=False, scope='content/send'):\n        \"\"\"\n        Upload a file of any type to store and return a FileId once file offer has been sent.\n        No user authentication required\n        \"\"\"\n        if input_file_path:\n            with open(input_file_path, 'rb') as f:\n                data = f.read()\n\n        if not data:\n            raise ValueError('Either the data of a file or the path to a file must be provided')\n\n        params = {\n            'fileName': file_name,\n            'userId': user_id,\n            'autoOpen': 'true' if auto_open else 'false',\n            'preventShare': 'true' if prevent_share else 'false',\n        }\n\n        return _post(\n            token=self.oauth.get_app_token(scope),\n            uri='/user/media/file/send?' + urllib.urlencode(params),\n            data=data,\n            content_type=content_type\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_file_offer(self, file_id, user_id, auto_open=False, scope='content/send'):\n\n        params = {\n            'UserId': user_id,\n            'autoOpen': 'true' if auto_open else 'false'\n        }\n\n        return _post(\n            token=self.oauth.get_app_token(scope),\n            uri='/user/media/file/send/' + urllib.quote(file_id) + '?' + urllib.urlencode(params)\n        )", "response": "Send an offer to a user for content to be downloaded."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves the Mxit user s cover image", "response": "def get_cover_image(self, output_file_path=None, scope='profile/public'):\n        \"\"\"\n        Retrieve the Mxit user's cover image\n        No user authentication required\n        \"\"\"\n        data = _get(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/cover'\n        )\n\n        if output_file_path:\n            with open(output_file_path, 'w') as f:\n                f.write(data)\n        else:\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_cover_image(self, data=None, input_file_path=None, scope='avatar/write',\n                        content_type='application/octet-stream'):\n        \"\"\"\n        Set the Mxit user's cover image\n        User authentication required with the following scope: 'avatar/write' (cover image and avatars are treated the same)\n        \"\"\"\n        if input_file_path:\n            with open(input_file_path, 'rb') as f:\n                data = f.read()\n\n        if not data:\n            raise ValueError('Either the data of an image file or the path to an image file must be provided')\n\n        return _post(\n            token=self.oauth.get_user_token(scope),\n            uri='/user/cover',\n            data=data,\n            content_type=content_type,\n            )", "response": "Set the Mxit user s cover image"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning a local command.", "response": "def run(quiet, args):\n    \"\"\"Run a local command.\n\n    Examples:\n\n    $ django run manage.py runserver\n\n    ...\n    \"\"\"\n    if not args:\n        raise ClickException('pass a command to run')\n\n    cmd = ' '.join(args)\n    application = get_current_application()\n    name = application.name\n    settings = os.environ.get('DJANGO_SETTINGS_MODULE', '%s.settings' % name)\n    return application.run(\n        cmd,\n        verbose=not quiet,\n        abort=False,\n        capture=True,\n        env={\n            'DJANGO_SETTINGS_MODULE': settings\n        }\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(self, file):\n\t\tif isfile(file):\n\t\t\ttry:\n\t\t\t\tconfig = load_source(\"config\", file)\n\t\t\texcept Exception as e:\n\t\t\t\traise ExceptionInConfigError(e)\n\t\t\toption_missing = False\n\t\t\tvalues = {}\n\t\t\tfor option in self.options:\n\t\t\t\t# Make sure all options are avaliable (validators aren't run in this case\n\t\t\t\t# because there are no values defined)\n\t\t\t\tif option.name not in dir(config):\n\t\t\t\t\tvalues[option.name] = option.default_value\n\t\t\t\t\toption_missing = True\n\t\t\t\telse:\n\t\t\t\t\t# Retrieve the option value\n\t\t\t\t\tvalue = getattr(config, option.name)\n\t\t\t\t\t# Make sure validator passes\n\t\t\t\t\tif option.validator != None:\t\n\t\t\t\t\t\t# If validation doesn't pass\n\t\t\t\t\t\tif not option.validator(value):\n\t\t\t\t\t\t\t# Resort to default value\n\t\t\t\t\t\t\tvalues[option.name] = option.default_value\n\t\t\t\t\t\t\tif self.validation_failed != None:\n\t\t\t\t\t\t\t\tself.validation_failed(option.name, value)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\traise ValidationError(option.name)\n\t\t\t\t\t\t\toption_missing = True\n\t\t\t\t\t\t# If validation passes\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tvalues[option.name] = value\n\t\t\t\t\telse:\n\t\t\t\t\t\tvalues[option.name] = value\n\t\t\t\tif option_missing:\n\t\t\t\t\tself.dump(file)\n\t\t\treturn _EditableConfig(values, self.options, file, \n\t\t\t\tvalidation_failed=self.validation_failed, debug=self.debug)\n\t\telse:\n\t\t\terror = \"'%s' not found\" % file\n\t\t\traise FileNotFoundError(error) if version.startswith(\"3\") else IOError(error)", "response": "Loads the config file and returns the actual read - and editable config object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, option):\n\t\tif option.__class__ == Option:\n\t\t\tfor _option in self.options:\n\t\t\t\tif option.name == _option.name:\n\t\t\t\t\traise OptionDuplicateError(_option.name)\n\t\t\tself.options.append(option)\n\t\telse:\n\t\t\traise TypeError(\"invalid type supplied\")", "response": "Adds an option to a Config instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove(self, option):\n\t\tif option.__class__ == Option:\n\t\t\tif option in self.options:\n\t\t\t\tdel self.options[self.options.index(option)]\n\t\t\telse:\n\t\t\t\traise OptionNotFoundError(option.name)\n\t\telse:\n\t\t\traise TypeError(\"invalid type supplied\")", "response": "Removes an option from a Config instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns contents of config file as string OUT", "response": "def dumps(self):\n\t\t\"\"\"\n\t\tReturns contents of config file as string\n\t\tOUT: out (type: str, hint: config content)\n\t\t\"\"\"\n\t\tout = \"\"\n\t\tfor option in self.options:\n\t\t\tvalue = make_value(option.default_value)\n\t\t\tout += \"%s = %s%s\\n\" % (option.name, value, \n\t\t\t\t(\" # %s\" % option.comment) if option.comment else \"\")\n\t\treturn out.rstrip(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting colouring on if STDOUT is a terminal device", "response": "def auto():\n\t\"\"\"set colouring on if STDOUT is a terminal device, off otherwise\"\"\"\n\ttry:\n\t\tStyle.enabled = False\n\t\tStyle.enabled = sys.stdout.isatty()\n\texcept (AttributeError, TypeError):\n\t\tpass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a GitHub style auto - generated anchor from a header line string.", "response": "def create_anchor_from_header(header, existing_anchors=None):\n    \"\"\"\n    Creates GitHub style auto-generated anchor tags from header line strings\n\n    :param header: The portion of the line that should be converted\n    :param existing_anchors: A dictionary of AnchorHub tags to auto-generated\n        anchors\n    :return: A string auto-generated anchor in the GitHub format\n    \"\"\"\n    # Strip white space on the left/right and make lower case\n    out = header.strip().lower()\n\n    # Replace groups of white space with hyphens\n    out = re.sub(r\"\\s+\", lambda x: \"-\", out, flags=re.UNICODE)\n\n    # Remove characters that aren't alphanumeric, hyphens, or spaces\n    out = re.sub(r\"[^\\w\\- ]+\", lambda x: \"\", out, flags=re.UNICODE)\n    if existing_anchors and out in existing_anchors.values():\n        i = 1\n        while (out + \"-\" + str(i)) in existing_anchors:\n            i += 1\n        return out + \"-\" + str(i)\n    else:\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _provider_state_fixtures_with_params(\n        provider_state_fixture_by_descriptor: Dict[str, ProviderStateFixture],\n        provider_states: Tuple[ProviderState, ...]\n) -> List[Tuple[ProviderStateFixture, Dict]]:\n    \"\"\"Get a list of provider states fixtures for an interaction with their parameters.\n    Raises an UnsupportedProviderStateError on the first provider state in an interaction\n    that isn't supported by the provider.\n    \"\"\"\n    provider_state_fixtures_with_params: List[Tuple[ProviderStateFixture, Dict]] = []\n    for provider_state in provider_states:\n        provider_state_fixture = provider_state_fixture_by_descriptor.get(provider_state.descriptor)\n        if not provider_state_fixture:\n            raise UnsupportedProviderStateError(\n                f'Missing expected provider state: {provider_state}'\n            )\n        if provider_state.params:\n            fixture_params = _pluck_parameter_names(provider_state_fixture)\n            if not frozenset(provider_state.params.keys()) == fixture_params:\n                raise UnsupportedProviderStateError(\n                    'Expected provider state params dont match those of '\n                    + f'provider. Expected: {provider_state}. Actual: {fixture_params}.'\n                )\n        provider_state_fixtures_with_params.append(\n            (provider_state_fixture, provider_state.params or {})\n        )\n\n    return provider_state_fixtures_with_params", "response": "Returns a list of provider states fixtures that have their parameters set."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _pluck_parameter_names(provider_state_fixture: Callable) -> FrozenSet[str]:\n    signature = inspect.signature(provider_state_fixture)\n    return frozenset(signature.parameters.keys())", "response": "Pluck the parameter names of a function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun all given provider states as a contextmanager.", "response": "def _use_provider_states(\n        provider_state_fixtures_with_params: List[Tuple[ProviderStateFixture, Dict]]\n) -> Generator:\n    \"\"\"Run all given provider states as a contextmanager.\"\"\"\n    with contextlib.ExitStack() as stack:\n        for provider_state_fixture, params in provider_state_fixtures_with_params:\n            stack.enter_context(provider_state_fixture(**params))\n\n        yield"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_rows(self):\n        rows = []\n        if check_table_exists(self.tracker.dbcon_master, self.name):\n            rows.extend(get_rows(self.tracker.dbcon_master, self.name))\n        if self.tracker.dbcon_part and check_table_exists(self.tracker.dbcon_part, self.name):\n            rows.extend(get_rows(self.tracker.dbcon_part, self.name))\n        return rows", "response": "Attempt to load the statistic from the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_first(self, n=1):\n        rows = []\n        # Get values from the partial db first\n        if self.tracker.dbcon_master and check_table_exists(self.tracker.dbcon_master, self.name):\n            rows.extend(get_first_row(self.tracker.dbcon_master, self.name, n))\n        # Then add rows from the master if required\n        if len(rows) < n and self.tracker.dbcon_part and check_table_exists(self.tracker.dbcon_part, self.name):\n            rows.extend(get_first_row(self.tracker.dbcon_part, self.name, n))\n        return rows[:n]", "response": "Retrieve the first n rows from the table\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves the last n rows from the table", "response": "def get_last(self, n=1):\n        \"\"\"\n        Retrieve the last n rows from the table\n        :param n: number of rows to return\n        :return: list of rows\n        \"\"\"\n        rows = []\n        # Get values from the partial db first\n        if self.tracker.dbcon_part and check_table_exists(self.tracker.dbcon_part, self.name):\n            rows.extend(get_last_row(self.tracker.dbcon_part, self.name, n))\n        # Then add rows from the master if required\n        if len(rows) < n and check_table_exists(self.tracker.dbcon_master, self.name):\n            rows.extend(get_last_row(self.tracker.dbcon_master, self.name, n))\n        return rows[-n:]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef xsDateTime_parse(xdt_str, local_tz=None):\n    if not isinstance(xdt_str, basestring):\n        raise InvalidXSDateTime(\n            \"Expecting str or unicode, got {}.\".format(type(xdt_str))\n        )\n\n    try:\n        # This won't parse the offset (or other tzinfo)\n        naive_dt = datetime.strptime(xdt_str[0:XSDT_TZ_OFFSET], XSDT_FMT)\n    except:\n        raise InvalidXSDateTime(\"Malformed date/time ('%s').\" % (xdt_str,))\n\n    naive_len = XSDT_TZ_OFFSET\n    offset_len = len(xdt_str) - naive_len\n    offset_str = xdt_str[-offset_len:]\n    offset_hours = None\n    offset_minutes = None\n    offset_sign = 1\n    parsed = None\n\n    # Parse fractional seconds if present\n    fsec_i = 0\n    if not offset_len:\n        parsed = naive_dt\n    elif offset_str[0] is '.':\n        if offset_len > 1:\n            fsec_i = 1\n            fsec_chr = offset_str[fsec_i]\n            fsec = ''\n            while fsec_chr.isdigit():\n                fsec += fsec_chr\n                fsec_i += 1\n                if fsec_i >= offset_len:\n                    break\n                fsec_chr = offset_str[fsec_i]\n            fsec = float('.'+fsec)\n            naive_dt += timedelta(milliseconds=fsec*1000)\n        else:\n            raise InvalidXSDateTime('Malformed fractional seconds.')\n\n    # Reset offset length and set offset string to actual offset,\n    # if we found fractional seconds -- otherwise this is all a noop\n    offset_len -= fsec_i\n    if offset_len:\n        offset_str = offset_str[fsec_i:fsec_i+offset_len+1]\n    else:\n        offset_str = ''\n\n    # Get local timezone info using local_tz (tzinfo)\n    # throws pytz.exceptions.UnknownTimezoneError\n    # on bad timezone name\n    if local_tz is None:\n        local_tz = DEFAULT_LOCAL_TZ\n\n    # Parse offset\n    if not offset_len:\n        # If there is no offset, assume local time\n        # and return the naive datetime we have\n        parsed = naive_dt\n        return parsed\n    # +00:00\n    elif offset_len is 6:\n        if offset_str[0] not in \"+-\":\n            raise InvalidXSDateTime(\"Malformed offset (missing sign).\")\n        elif offset_str[0] is '-':\n            offset_sign = -1\n        try:\n            offset_hours = int(offset_str[1:3])\n        except:\n            raise InvalidXSDateTime(\"Malformed offset (invalid hours '%s')\"\n                                    % (offset_str[1:3],))\n        if offset_str[3] is not ':':\n            raise InvalidXSDateTime(\"Colon missing in offset (no colon).\")\n        try:\n            offset_minutes = int(offset_str[4:6])\n        except:\n            raise InvalidXSDateTime(\"Malformed offset (invalid minutes '%s')\"\n                                    % (offset_str[4:6],))\n        offset = offset_hours * 60 + offset_minutes\n        offset *= offset_sign\n        faux_timezone = XSDateTimezone(offset_hours, offset_minutes, offset_sign)\n        parsed = naive_dt.replace(tzinfo=faux_timezone)\n    # Z\n    elif offset_len is 1:\n        if offset_str is 'Z':\n            parsed = naive_dt.replace(tzinfo=XSDateTimezone())\n        else:\n            raise InvalidXSDateTime(\"Unrecognized timezone identifier '%s'.\" %\n                                    (offset_str,))\n    else:\n        raise InvalidXSDateTime(\"Malformed offset '%s'.\" % (offset_str,))\n\n    # We've parsed the offset str. now,\n    # Flatten datetime w/ tzinfo into a\n    # Naive datetime, utc\n    offset = parsed.utcoffset()\n    parsed = parsed.replace(tzinfo=None)\n    if offset is not None:\n        parsed -= offset\n    # Add utc timezone info\n    parsed = utc_tz.localize(parsed)\n    # Convert to local timezone and make naive again\n    parsed = parsed.astimezone(local_tz).replace(tzinfo=None)\n\n    return parsed", "response": "Parses xsDateTime string and returns a datetime in local time according to local_tz."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the current utcoffset for a timezone. Uses DEFAULT_LOCAL_TZ by default.", "response": "def current_offset(local_tz=None):\n    \"\"\"\n    Returns current utcoffset for a timezone. Uses\n    DEFAULT_LOCAL_TZ by default. That value can be\n    changed at runtime using the func below.\n    \"\"\"\n    if local_tz is None:\n        local_tz = DEFAULT_LOCAL_TZ\n    dt = local_tz.localize(datetime.now())\n    return dt.utcoffset()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef status(self):\n        return {\n            self.original: {\n                'formatted_filename': self.out_location,\n                'state': self.state,\n                'messages': '\\n\\t'.join(self.messages),\n            }\n        }", "response": "Provides current status of processing episode."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the file and sets the properties of the object.", "response": "def parse(self):\n        \"\"\"Extracts component keys from filename.\n\n        :raises tvrenamer.exceptions.InvalidFilename:\n            when filename was not parseable\n        :raises tvrenamer.exceptions.ConfigValueError:\n            when regex used for parsing was incorrectly configured\n        \"\"\"\n\n        self.clean_name = formatter.apply_replacements(\n            self.name, cfg.CONF.input_filename_replacements)\n\n        output = parser.parse_filename(self.clean_name)\n\n        if output is None:\n            self.messages.append(\n                'Invalid filename: unable to parse {0}'.format(\n                    self.clean_name))\n            LOG.info(self.messages[-1])\n            raise exc.InvalidFilename(self.messages[-1])\n\n        self.episode_numbers = output.get('episode_numbers')\n        if self.episode_numbers is None:\n            self.messages.append(\n                'Regex does not contain episode number group, '\n                'should contain episodenumber, episodenumber1-9, '\n                'or episodenumberstart and episodenumberend\\n\\n'\n                'Pattern was:\\n' + output.get('pattern'))\n            LOG.info(self.messages[-1])\n            raise exc.ConfigValueError(self.messages[-1])\n\n        self.series_name = output.get('series_name')\n        if self.series_name is None:\n            self.messages.append(\n                'Regex must contain seriesname. Pattern was:\\n' +\n                output.get('pattern'))\n            LOG.info(self.messages[-1])\n            raise exc.ConfigValueError(self.messages[-1])\n\n        self.series_name = formatter.clean_series_name(self.series_name)\n        self.season_number = output.get('season_number')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads metadata from a data service to improve naming.", "response": "def enhance(self):\n        \"\"\"Load metadata from a data service to improve naming.\n\n        :raises tvrenamer.exceptions.ShowNotFound:\n            when unable to find show/series name based on parsed name\n        :raises tvrenamer.exceptions.EpisodeNotFound:\n            when unable to find episode name(s) based on parsed data\n        \"\"\"\n\n        series, error = self.api.get_series_by_name(self.series_name)\n\n        if series is None:\n            self.messages.append(str(error))\n            LOG.info(self.messages[-1])\n            raise exc.ShowNotFound(str(error))\n\n        self.series_name = self.api.get_series_name(series)\n        self.episode_names, error = self.api.get_episode_name(\n            series, self.episode_numbers, self.season_number)\n\n        if self.episode_names is None:\n            self.messages.append(str(error))\n            LOG.info(self.messages[-1])\n            raise exc.EpisodeNotFound(str(error))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting the name of the media file based on enhanced metadata.", "response": "def format_name(self):\n        \"\"\"Formats the media file based on enhanced metadata.\n\n        The actual name of the file and even the name of the directory\n        structure where the file is to be stored.\n        \"\"\"\n        self.formatted_filename = formatter.format_filename(\n            self.series_name, self.season_number,\n            self.episode_numbers, self.episode_names,\n            self.extension)\n\n        self.formatted_dirname = self.location\n        if cfg.CONF.move_files_enabled:\n            self.formatted_dirname = formatter.format_location(\n                self.series_name, self.season_number)\n\n        self.out_location = os.path.join(self.formatted_dirname,\n                                         self.formatted_filename)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrename the media file to formatted name.", "response": "def rename(self):\n        \"\"\"Renames media file to formatted name.\n\n        After parsing data from initial media filename and searching\n        for additional data to using a data service, a formatted\n        filename will be generated and the media file will be renamed\n        to the generated name and optionally relocated.\n        \"\"\"\n        renamer.execute(self.original, self.out_location)\n        if cfg.CONF.move_files_enabled:\n            LOG.debug('relocated: %s', self)\n        else:\n            LOG.debug('renamed: %s', self)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a list of available bundles.", "response": "def get_bundle_list(self, href=None, limit=None, embed_items=None,\n                        embed_tracks=None, embed_metadata=None,\n                        embed_insights=None):\n        \"\"\"Get a list of available bundles.\n\n        'href' the relative href to the bundle list to retriev. If None,\n        the first bundle list will be returned.\n        'limit' the maximum number of bundles to include in the result.\n        'embed_items' whether or not to expand the bundle data into the\n        result.\n        'embed_tracks' whether or not to expand the bundle track data\n        into the result.\n        'embed_metadata' whether or not to expand the bundle metadata\n        into the result.\n        'embed_insights' whether or not to expand the bundle insights\n        into the result.\n\n        NB: providing values for 'limit', 'embed_*' will override either\n        the API default or the values in the provided href.\n\n        Returns a data structure equivalent to the JSON returned by the API.\n\n        If the response status is not 2xx, throws an APIException.\n        If the JSON to python data struct conversion fails, throws an\n        APIDataException.\"\"\"\n\n        # Argument error checking.\n        assert limit is None or limit > 0\n\n        j = None\n        if href is None:\n            j = self._get_first_bundle_list(limit,\n                                            embed_items,\n                                            embed_tracks,\n                                            embed_metadata,\n                                            embed_insights)\n        else:\n            j = self._get_additional_bundle_list(href, limit,\n                                                 embed_items,\n                                                 embed_tracks,\n                                                 embed_metadata,\n                                                 embed_insights)\n\n        # Convert the JSON to a python data struct.\n\n        return self._parse_json(j)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a list of available bundles.", "response": "def _get_first_bundle_list(self, limit=None,\n                               embed_items=None,\n                               embed_tracks=None,\n                               embed_metadata=None,\n                               embed_insights=None):\n        \"\"\"Get a list of available bundles.\n\n        'limit' may be None, which implies API default.  If not None,\n        must be > 1.\n        'embed_items' True will embed item data in the result.\n        'embed_tracks' True will embed track data in the embedded items.\n        'embed_metadata' True will embed metadata in the embedded items.\n        'embed_insights' True will embed insights in the embedded items.\n\n        Note that including tracks and metadata without including items\n        is meaningless.\n\n        Returns the raw JSON returned by the API.\n\n        If the response status is not 2xx, throws an APIException.\"\"\"\n\n        # Prepare the data we're going to include in our query.\n        path = '/' + __api_version__ + '/' + BUNDLES_PATH\n\n        data = None\n        fields = {}\n        if limit is not None:\n            fields['limit'] = limit\n        embed = helper.process_embed(embed_items=embed_items,\n                                     embed_tracks=embed_tracks,\n                                     embed_metadata=embed_metadata,\n                                     embed_insights=embed_insights)\n        if embed is not None:\n            fields['embed'] = embed\n\n        if len(fields) > 0:\n            data = fields\n\n        raw_result = self.get(path, data)\n\n        if raw_result.status < 200 or raw_result.status > 202:\n            raise APIException(raw_result.status, raw_result.json)\n        else:\n            result = raw_result.json\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bundle_list_map(self, func, bundle_collection=None):\n        has_next = True\n        next_href = None  # if None, retrieves first page\n        stopped = False\n\n        while has_next and not stopped:\n            # Get a page and perform the requested function.\n            if bundle_collection is None:\n                bundle_collection = self.get_bundle_list(next_href)\n            for i in bundle_collection['_links']['items']:\n                href = i['href']\n                if func(self, href) is False:\n                    stopped = True\n                    break\n            # Check for following page.\n            if not stopped:\n                next_href = None\n                if 'next' in bundle_collection['_links']:\n                    next_href = bundle_collection['_links']['next']['href']\n                    bundle_collection = None\n                if next_href is None:\n                    has_next = False", "response": "Execute func on every bundle in a collection."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_bundle(self, name=None, media_url=None,\n                      audio_channel=None, metadata=None, notify_url=None,\n                      external_id=None):\n        \"\"\"Create a new bundle.\n\n        'metadata' may be None, or an object that can be converted to a JSON\n        string.  See API documentation for restrictions.  The conversion\n        will take place before the API call.\n\n        All other parameters are also optional. For information about these\n        see https://api.clarify.io/docs#!/audio/v1audio_post_1.\n\n        Returns a data structure equivalent to the JSON returned by the API.\n\n        If the response status is not 2xx, throws an APIException.\n        If the JSON to python data struct conversion fails, throws an\n        APIDataException.\"\"\"\n\n        # Prepare the data we're going to include in our bundle creation.\n        path = '/' + __api_version__ + '/' + BUNDLES_PATH\n\n        data = None\n\n        fields = {}\n        if name is not None:\n            fields['name'] = name\n        if media_url is not None:\n            fields['media_url'] = media_url\n        if audio_channel is not None:\n            fields['audio_channel'] = audio_channel\n        if metadata is not None:\n            fields['metadata'] = json.dumps(metadata)\n        if notify_url is not None:\n            fields['notify_url'] = notify_url\n        if external_id is not None:\n            fields['external_id'] = external_id\n\n        if len(fields) > 0:\n            data = fields\n\n        raw_result = self.post(path, data)\n\n        if raw_result.status < 200 or raw_result.status > 202:\n            raise APIException(raw_result.status, raw_result.json)\n\n        # Convert the JSON to a python data struct.\n\n        return self._parse_json(raw_result.json)", "response": "Create a new bundle."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeletes a bundle. :param href: the relative href to the bundle. :type href: string, may not be None :return: nothing :raises APIException: If the response code is not 204.", "response": "def delete_bundle(self, href=None):\n        \"\"\"\n        Delete a bundle.\n\n        :param href: the relative href to the bundle.\n        :type href: string, may not be None\n        :return: nothing\n        :raises APIException: If the response code is not 204.\n        \"\"\"\n\n        # Argument error checking.\n        assert href is not None\n\n        raw_result = self.delete(href)\n\n        if raw_result.status != 204:\n            raise APIException(raw_result.status, raw_result.json)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_bundle(self, href=None, embed_tracks=False,\n                   embed_metadata=False, embed_insights=False):\n        \"\"\"Get a bundle.\n\n        'href' the relative href to the bundle. May not be None.\n        'embed_tracks' determines whether or not to include track\n        information in the response.\n        'embed_metadata' determines whether or not to include metadata\n        information in the response.\n        'embed_insights' determines whether or not to include insights\n        information in the response.\n\n        Returns a data structure equivalent to the JSON returned by the API.\n\n        If the response status is not 2xx, throws an APIException.\n        If the JSON to python data struct conversion fails, throws an\n        APIDataException.\"\"\"\n\n        # Argument error checking.\n        assert href is not None\n\n        data = None\n        fields = {}\n        embed = helper.process_embed(embed_items=False,\n                                     embed_tracks=embed_tracks,\n                                     embed_metadata=embed_metadata,\n                                     embed_insights=embed_insights)\n        if embed is not None:\n            fields['embed'] = embed\n\n        if len(fields) > 0:\n            data = fields\n\n        raw_result = self.get(href, data)\n\n        if raw_result.status < 200 or raw_result.status > 202:\n            raise APIException(raw_result.status, raw_result.json)\n\n        # Convert the JSON to a python data struct.\n\n        return self._parse_json(raw_result.json)", "response": "Get a bundle from the API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_bundle(self, href=None, name=None,\n                      notify_url=None, version=None,\n                      external_id=None):\n        \"\"\"Update a bundle.  Note that only the 'name' and 'notify_url' can\n        be update.\n\n        'href' the relative href to the bundle. May not be None.\n        'name' the name of the bundle.  May be None.\n        'notify_url' the URL for notifications on this bundle.\n        'version' the object version.  May be None; if not None, must be\n        an integer, and the version must match the version of the\n        bundle.  If not, a 409 conflict error will cause an APIException\n        to be thrown.\n        'external_id' an arbitrary id (string) you can associate with this bundle.\n                      May be None.\n\n        Returns a data structure equivalent to the JSON returned by the API.\n\n        If the response status is not 2xx, throws an APIException.\n        If the JSON to python data struct conversion fails, throws an\n        APIDataException.\"\"\"\n\n        # Argument error checking.\n        assert href is not None\n        assert version is None or isinstance(version, int)\n\n        # Prepare the data we're going to include in our bundle update.\n        data = None\n\n        fields = {}\n        if name is not None:\n            fields['name'] = name\n        if notify_url is not None:\n            fields['notify_url'] = notify_url\n        if version is not None:\n            fields['version'] = version\n        if external_id is not None:\n            fields['external_id'] = external_id\n\n        if len(fields) > 0:\n            data = fields\n\n        raw_result = self.put(href, data)\n\n        if raw_result.status < 200 or raw_result.status > 202:\n            raise APIException(raw_result.status, raw_result.json)\n\n        # Convert the JSON to a python data struct.\n\n        return self._parse_json(raw_result.json)", "response": "Update a bundle.  Note that only the 'name' and 'notify_url' can\n        be update.\n\n        'href' the relative href to the bundle. May not be None.\n        'name' the name of the bundle.  May be None.\n        'notify_url' the URL for notifications on this bundle.\n        'version' the object version.  May be None; if not None, must be\n        an integer, and the version must match the version of the\n        bundle.  If not, a 409 conflict error will cause an APIException\n        to be thrown.\n        'external_id' an arbitrary id (string) you can associate with this bundle.\n                      May be None.\n\n        Returns a data structure equivalent to the JSON returned by the API.\n\n        If the response status is not 2xx, throws an APIException.\n        If the JSON to python data struct conversion fails, throws an\n        APIDataException."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_metadata(self, href=None, metadata=None, version=None):\n\n        # Argument error checking.\n        assert href is not None\n        assert metadata is not None\n        assert version is None or isinstance(version, int)\n\n        # Prepare the data we're going to include in our bundle update.\n        data = None\n\n        fields = {}\n        if version is not None:\n            fields['version'] = version\n        fields['data'] = json.dumps(metadata)\n\n        data = fields\n\n        raw_result = self.put(href, data)\n\n        if raw_result.status < 200 or raw_result.status > 202:\n            raise APIException(raw_result.status, raw_result.json)\n\n        # Convert the JSON to a python data struct.\n\n        return self._parse_json(raw_result.json)", "response": "Update the metadata in a bundle."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_metadata(self, href=None):\n\n        # Argument error checking.\n        assert href is not None\n\n        raw_result = self.delete(href)\n\n        if raw_result.status != 204:\n            raise APIException(raw_result.status, raw_result.json)", "response": "Delete metadata.\n\n        'href' the relative href to the bundle. May not be None.\n\n        Returns nothing.\n\n        If the response status is not 204, throws an APIException."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_track(self, href=None, media_url=None, label=None,\n                     audio_channel=None):\n        \"\"\"Add a new track to a bundle.  Note that the total number of\n        allowable tracks is limited. See the API documentation for\n        details.\n\n        'href' the relative href to the tracks list. May not be None.\n        'media_url' public URL to media file. May not be None.\n        'label' short name for the track. May be None.\n        'audio_channel' the channel(s) to use in a stereo file. May be\n        None. For details see the API documentation.\n\n        Returns a data structure equivalent to the JSON returned by the\n        API.\n\n        If the response status is not 2xx, or if the maximum number of\n        tracks is exceeded, throws an APIException.  If the JSON to\n        python data struct conversion fails, throws an\n        APIDataException.\"\"\"\n\n        # Argument error checking.\n        assert href is not None\n        assert media_url is not None\n\n        # Prepare the data we're going to write.\n        data = None\n\n        fields = {}\n        fields['media_url'] = media_url\n        if label is not None:\n            fields['label'] = label\n        if audio_channel is not None:\n            fields['audio_channel'] = audio_channel\n\n        if len(fields) > 0:\n            data = fields\n\n        raw_result = self.post(href, data)\n\n        if raw_result.status < 200 or raw_result.status > 202:\n            raise APIException(raw_result.status, raw_result.json)\n\n        # Convert the JSON to a python data struct.\n\n        return self._parse_json(raw_result.json)", "response": "Add a new track to a bundle."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_track_at_index(self, href=None, index=None):\n\n        # Argument error checking.\n        assert href is not None\n\n        # Deal with any parameters that need to be passed in.\n        data = None\n\n        fields = {}\n        if index is not None:\n            fields['track'] = index\n\n        if len(fields) > 0:\n            data = fields\n\n        raw_result = self.delete(href, data)\n\n        if raw_result.status != 204:\n            raise APIException(raw_result.status, raw_result.json)", "response": "Delete a track at the given index."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_track(self, href=None):\n\n        # Argument error checking.\n        assert href is not None\n\n        raw_result = self.delete(href)\n\n        if raw_result.status != 204:\n            raise APIException(raw_result.status, raw_result.json)", "response": "Delete a track.\n\n        'href' the relative index of the track. May not be none.\n\n        Returns nothing.\n\n        If the response status is not 204, throws and APIException."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrequest an insight to be run on a bundle.", "response": "def request_insight(self, href, insight):\n        \"\"\"Requests an insight to be run.\n\n        Normally insights are set to automatically run so you will NOT need\n        to call this method -- use get_insight() instead.\n        However, non-autorun insights can be requested using this method (for\n        example high-accuracy transcripts or closed captions). If the insight\n        has already been run on this bundle, the existing results are returned.\n\n        'href' Is the uri to a bundles insights. May not be None. Typically\n        you will get this from the 'clarify:insights' link relation of a bundle.\n\n        'insight' is the name of the insight you are requesting.\n\n        Returns a data structure equivalent to the JSON returned by the API.\n\n        If the response status is not 2xx, throws an APIException.\n        If the JSON to python data struct conversion fails, throws an\n        APIDataException.\"\"\"\n\n        assert href is not None\n        assert insight is not None\n\n        fields = {\n            'insight': insight\n        }\n\n        raw_result = self.post(href, fields)\n\n        if raw_result.status < 200 or raw_result.status > 202:\n            raise APIException(raw_result.status, raw_result.json)\n\n        # Convert the JSON to a python data struct.\n        return self._parse_json(raw_result.json)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the data from an insight with data links such as captions.", "response": "def get_data(self, href=None):\n        \"\"\"Gets data from an insight with data links such as captions.\n\n        'href' the relative href to the data. May not be None.\n\n        Returns the content of the data as a string.\n\n        If the response status is not 2xx, throws an APIException.\n        \"\"\"\n\n        # Argument error checking.\n        assert href is not None\n\n        raw_result = self.get(href)\n\n        if raw_result.status < 200 or raw_result.status > 202:\n            raise APIException(raw_result.status, raw_result.json)\n\n        return raw_result.json"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a model from the API.", "response": "def _get_simple_model(self, href=None):\n        \"\"\"Get a model\n\n        'href' the relative href to the model. May not be None.\n\n        Returns a data structure equivalent to the JSON returned by the\n        API.\n\n        If the response status is not 2xx, throws an APIException.\n        If the JSON to python data struct conversion fails, throws an\n        APIDataException.\"\"\"\n\n        # Argument error checking.\n        assert href is not None\n\n        raw_result = self.get(href)\n\n        if raw_result.status < 200 or raw_result.status > 202:\n            raise APIException(raw_result.status, raw_result.json)\n\n        # Convert the JSON to a python data struct.\n\n        return self._parse_json(raw_result.json)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch a media collection.", "response": "def search(self, href=None,\n               query=None, query_fields=None, query_filter=None,\n               limit=None, embed_items=None, embed_tracks=None,\n               embed_metadata=None, embed_insights=None, language=None):\n\n        \"\"\"Search a media collection.\n\n        'href' the relative href to the bundle list to retriev. If None,\n               the first bundle list will be returned.\n        'query' See API docs for full description. May not be None if\n                href is None.\n        'query_fields' See API docs for full description. May be None.\n                       Ignored if href is not None.\n        'query_filter' See API docs for full description. May be None.\n                       Ignored if href is not None.\n        'limit' the maximum number of bundles to include in the result.\n        'embed_items' whether or not to expand the bundle data into the\n                      result.\n        'embed_tracks' whether or not to expand the bundle track data\n                       into the result.\n        'embed_metadata' whether or not to expand the bundle metadata\n                         into the result.\n        'embed_insights' whether or not to expand the bundle insights\n                         into the result.\n        'language' the 2 letter language code of the language to search\n                         in. Ignored if href is not None.\n\n        NB: providing values for 'limit', 'embed_*' will override either\n        the API default or the values in the provided href.\n\n        Returns a data structure equivalent to the JSON returned by the\n        API.\n\n        If the response status is not 2xx, throws an APIException.\n        If the JSON to python data struct conversion fails, throws an\n        APIDataException.\"\"\"\n\n        # Argument error checking.\n        assert query is not None\n        assert limit is None or limit > 0\n\n        if href is None:\n            j = self._search_p1(query, query_fields, query_filter, limit,\n                                embed_items, embed_tracks, embed_metadata,\n                                embed_insights, language)\n\n        else:\n            j = self._search_pn(href, limit, embed_items, embed_tracks,\n                                embed_insights, embed_metadata)\n\n        # Convert the JSON to a python data struct.\n\n        return self._parse_json(j)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfunction called to retrieve the first page of the page.", "response": "def _search_p1(self, query=None, query_fields=None, query_filter=None,\n                   limit=None, embed_items=None, embed_tracks=None,\n                   embed_metadata=None, embed_insights=None, language=None):\n        \"\"\"Function called to retrieve the first page.\"\"\"\n\n        # Prepare the data we're going to include in our query.\n        path = '/' + __api_version__ + '/' + SEARCH_PATH\n\n        data = None\n        fields = {}\n        fields['query'] = query\n        if query_fields is not None:\n            fields['query_fields'] = query_fields\n        if query_filter is not None:\n            fields['filter'] = query_filter\n        if limit is not None:\n            fields['limit'] = limit\n        embed = helper.process_embed(embed_items=embed_items,\n                                     embed_tracks=embed_tracks,\n                                     embed_metadata=embed_metadata,\n                                     embed_insights=embed_insights)\n        if embed is not None:\n            fields['embed'] = embed\n\n        if len(fields) > 0:\n            data = fields\n\n        raw_result = self.get(path, data)\n\n        if raw_result.status < 200 or raw_result.status > 202:\n            raise APIException(raw_result.status, raw_result.json)\n        else:\n            result = raw_result.json\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _search_pn(self, href=None, limit=None,\n                   embed_items=None, embed_tracks=None, embed_metadata=None,\n                   embed_insights=None):\n        \"\"\"Function called to retrieve pages 2-n.\"\"\"\n\n        url_components = urlparse(href)\n        path = url_components.path\n        data = parse_qs(url_components.query)\n\n        # Change all lists into discrete values.\n        for key in data.keys():\n            data[key] = data[key][0]\n\n        # Deal with limit overriding.\n        if limit is not None:\n            data['limit'] = limit\n\n        # Deal with embeds overriding.\n        final_embed = helper.process_embed_override(data.get('embed'),\n                                                    embed_items,\n                                                    embed_tracks,\n                                                    embed_metadata,\n                                                    embed_insights)\n        if final_embed is not None:\n            data['embed'] = final_embed\n\n        raw_result = self.get(path, data)\n\n        if raw_result.status < 200 or raw_result.status > 202:\n            raise APIException(raw_result.status, raw_result.json)\n        else:\n            result = raw_result.json\n\n        return result", "response": "Function called to retrieve pages 2 - n."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets all the headers we need to need", "response": "def _get_headers(self):\n        \"\"\"Get all the headers we're going to need:\n\n        1. Authorization\n        2. Content-Type\n        3. User-agent\n\n        Note that the User-agent string contains the library name, the\n        libary version, and the python version. This will help us track\n        what people are using, and where we should concentrate our\n        development efforts.\"\"\"\n\n        user_agent = __api_lib_name__ + '/' + __version__ + '/' + \\\n            PYTHON_VERSION\n\n        headers = {'User-Agent': user_agent,\n                   'Content-Type': 'application/x-www-form-urlencoded'}\n        if self.key:\n            headers['Authorization'] = 'Bearer ' + self.key\n        return headers"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, path, data=None):\n\n        # Argument error checking.\n        assert path is not None\n\n        # Execute the request.\n        response = self.conn.request('GET', path, data, self._get_headers())\n\n        # Extract the result.\n        self._last_status = response_status = response.status\n        response_content = response.data.decode()\n\n        return Result(status=response_status, json=response_content)", "response": "Executes a GET request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute a DELETE request.", "response": "def delete(self, path, data=None):\n        \"\"\"Executes a DELETE.\n\n        'path' may not be None. Should include the full path to the\n        resoure.\n        'data' may be None or a dictionary.\n\n        Returns a named tuple that includes:\n\n        status: the HTTP status code\n        json: the returned JSON-HAL\n\n        If the key was not set, throws an APIConfigurationException.\"\"\"\n\n        # Argument error checking.\n        assert path is not None\n        assert data is None or isinstance(data, dict)\n\n        # Execute the request.\n        response = self.conn.request('DELETE', path, data,\n                                     self._get_headers())\n\n        # Extract the result.\n        self._last_status = response_status = response.status\n        response_content = response.data.decode()\n\n        # return (status, json)\n        return Result(status=response_status, json=response_content)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes a PUT request.", "response": "def put(self, path, data):\n        \"\"\"Executes a PUT.\n\n        'path' may not be None. Should include the full path to the\n        resoure.\n        'data' may be None or a dictionary.\n\n        Returns a named tuple that includes:\n\n        status: the HTTP status code\n        json: the returned JSON-HAL\n\n        If the key was not set, throws an APIConfigurationException.\"\"\"\n\n        # Argument error checking.\n        assert path is not None\n        assert data is None or isinstance(data, dict)\n\n        # Execute the request.\n        if data is None:\n            data = {}\n        response = self.conn.request_encode_body('PUT', path, data,\n                                                 self._get_headers(), False)\n\n        # Extract the result.\n        self._last_status = response_status = response.status\n        response_content = response.data.decode()\n\n        return Result(status=response_status, json=response_content)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_json(self, jstring=None):\n\n        # Argument error checking.\n        assert jstring is not None\n\n        result = None\n\n        try:\n            result = json.loads(jstring)\n        except (ValueError) as exception:\n            msg = 'Unable to convert JSON string to Python data structure.'\n            raise APIDataException(exception, jstring, msg)\n\n        return result", "response": "Parse a string of JSON and return a Python data structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_status(self):\n\n        result = ''\n        if self._data_struct is not None:\n            result = self._data_struct[KEY_STATUS]\n        return result", "response": "Return the status embedded in the JSON error response body and the key - value - dict containing the status of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_message(self):\n\n        result = ''\n        if self._data_struct is not None:\n            result = self._data_struct[KEY_MESSAGE]\n        return result", "response": "Return the message embedded in the JSON error response body or an empty string if the JSON couldn t be parsed."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_code(self):\n\n        result = ''\n        if self._data_struct is not None:\n            result = self._data_struct[KEY_CODE]\n        return result", "response": "Return the code embedded in the JSON error response body or an empty string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_o_tail_products(term: IEquationTerm):\n\n    if not isinstance(term, IEquationTerm):\n        raise ValueError(\"expected IEquationTerm, got '{}'\".format(type(term)))\n\n    currently_analyzed = set()\n    already_analyzed = dict()\n\n    def analyze_and_remember(term: IEquationTerm):\n        if term in currently_analyzed:\n            raise ValueError(\"found a loop leading to '{}'\".format(term))\n        if term in already_analyzed:\n            return already_analyzed[term]\n        currently_analyzed.add(term)\n        result = get_o_product(term)\n        already_analyzed[term] = result\n        currently_analyzed.remove(term)\n        return result\n\n    def get_o_product(term: IEquationTerm):\n        if term.processed_term is None:\n            return None\n        if term.processed_term.operation != CategoryOperations.ARROW:\n            return None\n        if term.processed_term.source.is_zero():\n            return None\n        if term.processed_term.source.is_identity():\n            return None\n        if term.processed_term.sink.is_zero():\n            return term\n        return analyze_and_remember(term.processed_term.sink)\n\n\n    all_terms = set()\n\n    def collect_terms(term: IEquationTerm):\n        if term in all_terms:\n            return\n        all_terms.add(term)\n        if term.processed_term is None:\n            return\n        collect_terms(term.processed_term.source)\n        collect_terms(term.processed_term.sink)\n\n    collect_terms(term)\n\n    for processed_term in all_terms:\n        analyze_and_remember(processed_term)\n\n    o_products = [i for i in already_analyzed.values() if i is not None]\n    o_products.sort()\n    return o_products", "response": "Get the tail products of a single element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nranking features using Random Forest classifier and Random Forest regressor and the recursive feature elimination", "response": "def rank_features(self, inputs: pd.DataFrame, targets: pd.DataFrame, problem_type='classification') -> pd.DataFrame:\n        \"\"\" Rank features using Random Forest classifier and the recursive feature elimination\n\n        \"\"\"\n        try:\n\n            X = normalize( \\\n                                inputs.apply(pd.to_numeric, errors='coerce') \\\n                                .applymap(lambda x: 0.0 if np.isnan(x) else x) \\\n                                .values, axis=0)\n            y = targets.iloc[:,0].values\n            original_columns = list(inputs)\n            print(original_columns)\n\n            if problem_type == 'classification':\n                predictor = RandomForestClassifier()\n            else:\n                predictor = RandomForestRegressor()\n\n            rfe = RFE(predictor, n_features_to_select=1)\n            rfe = rfe.fit(X, y)\n            \n            best_features = [original_columns[i-1] for i in rfe.ranking_]\n\n        except:\n            logging.exception(\"Failed\")\n            # If any error occurs, just return indices in original order\n            # In the future we should consider a better error handling strategy\n            best_features = [i for i in range(inputs.shape[1])]\n\n        return best_features"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_story(new):\n    url = URLS['item'].format(new)\n    try:\n        data = req.get(url)\n    except req.ConnectionError:\n        raise\n    except req.Timeout:\n        raise req.Timeout('A timeout problem occurred.')\n    except req.TooManyRedirects:\n        raise req.TooManyRedirects('The request exceeds the configured number\\\n            of maximum redirections.')\n    else:\n        return data.json()", "response": "Return a story of the given ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a list of stories for each item of the list.", "response": "def create_list_stories(\n    list_id_stories, number_of_stories, shuffle, max_threads\n):\n    \"\"\"Show in a formatted way the stories for each item of the list.\"\"\"\n\n    list_stories = []\n    with ThreadPoolExecutor(max_workers=max_threads) as executor:\n        futures = {\n            executor.submit(get_story, new)\n            for new in list_id_stories[:number_of_stories]\n        }\n\n        for future in tqdm(\n            as_completed(futures),\n            desc='Getting results',\n            unit=' news',\n        ):\n            list_stories.append(future.result())\n\n    if shuffle:\n        random.shuffle(list_stories)\n    return list_stories"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rot(inputArray, theta=0, pc=(0, 0)):\n        if not isinstance(inputArray, np.ndarray):\n            inputArray = np.array(inputArray)\n\n        if not isinstance(pc, np.ndarray):\n            pc = np.array(pc)\n\n        theta = theta / 180.0 * np.pi  # degree to rad\n        mr = np.array([\n            [np.cos(theta), -np.sin(theta)],\n            [np.sin(theta), np.cos(theta)],\n        ])\n        return np.dot(mr, (inputArray - pc).transpose()).transpose() + pc.transpose()", "response": "rotate input array with angle of theta"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of copied input matplotlib patches", "response": "def copy_patches(ptches0):\n        \"\"\" return a list of copied input matplotlib patches \n            \n        :param ptches0: list of matploblib.patches objects\n        :return: copyed patches object\n        \"\"\"\n        if not isinstance(ptches0, list):\n            ptches0 = list(ptches0)\n        copyed_ptches = []\n        for pt in ptches0:\n            pth = pt.get_path().deepcopy()\n            ptch = patches.PathPatch(pth,\n                                     lw=pt.get_lw(),\n                                     fc=pt.get_fc(),\n                                     ec=pt.get_ec(),\n                                     alpha=pt.get_alpha())\n            copyed_ptches.append(ptch)\n        return copyed_ptches"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset common information update MagBlock. comminfo", "response": "def setCommInfo(infostr):\n        \"\"\" set common information, update MagBlock.comminfo\n\n        :param infostr: should be met one of the following options:\n\n                            * infostr is a dict, {k1:v1, k2:v2}\n                            * infostr is a string, with format like: \"k1=v1, k2=v2\"\n        \"\"\"\n        if isinstance(infostr, dict):\n            for k, v in infostr.items():\n                MagBlock.comminfo[k] = v\n        elif isinstance(infostr, str):\n            for k, v in MagBlock.str2dict(infostr).items():\n                MagBlock.comminfo[k] = v\n        else:\n            print(\"Information string ERROR.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef str2dict(istr):\n        if 'lattice' not in istr.lower():\n            tmpstr = istr.replace(',', '=').split('=')\n        else:\n            tmpstr = istr.split('=')\n        k = [i.strip() for i in tmpstr[0::2]]\n        v = [i.strip() for i in tmpstr[1::2]]\n        return dict(zip(k, v))", "response": "translate string into dict"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset information for different type dict", "response": "def setConf(self, conf, type='simu'):\n        \"\"\" set information for different type dict,\n\n        :param conf: configuration information, str or dict\n        :param type: simu, ctrl, misc\n        \"\"\"\n        if conf is None:\n            return\n        else:\n            if isinstance(conf, str):\n                conf = MagBlock.str2dict(conf)\n            self.setConfDict[type](conf)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef printConfig(self, type='simu'):\n        print(\"{s1}{s2:^22s}{s1}\".format(s1=\"-\" * 10, s2=\"Configuration START\"))\n        print(\"Element name: {en} ({cn})\".format(en=self.name, cn=self.__class__.__name__))\n        if self._spos is not None:\n            print(\"Position: s = {pos:.3f} [m]\".format(pos=float(self._spos)))\n        self.prtConfigDict[type]()\n        print(\"{s1}{s2:^22s}{s1}\".format(s1=\"-\" * 10, s2=\"Configuration END\"))", "response": "print information about the current element"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting out control configs", "response": "def _printCtrlConf(self):\n        \"\"\" get PV value and print out\n        \"\"\"\n        if self.ctrlinfo:\n            print(\"Control configs:\")\n            for k, v in sorted(self.ctrlinfo.items(), reverse=True):\n                pv = v['pv']\n                rval = epics.caget(pv)\n                if rval is None:\n                    val = ''\n                else:\n                    val = self.unitTrans(rval, direction='+')\n                print(\"  {k:6s} = {pv:6s}, raw: {rval:>6s}, real: {val:>6s}\".format(k=str(k),\n                                                                                    pv=str(pv),\n                                                                                    rval=str(rval),\n                                                                                    val=str(val)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _dumpOnlineConf(self, format):\n        oinfod = {k: v for k, v in self.simuinfo.items()}\n        for k in (set(oinfod.keys()) & set(self.ctrlkeys)):\n            oinfod[k] = self.ctrlinfo[k]\n        return {self.name.upper(): {self.typename: oinfod}}", "response": "dump online configuration json string for online modeling"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef showDraw(self, fignum=1):\n        if self._patches == []:\n            print(\"Please setDraw() before showDraw(), then try again.\")\n            return\n        else:\n            fig = plt.figure(fignum)\n            fig.clear()\n            ax = fig.add_subplot(111, aspect='equal')\n            [ax.add_patch(i) for i in self._patches]\n            bbox = self._patches[0].get_path().get_extents()\n            x0 = 2.0 * min(bbox.xmin, bbox.ymin)\n            x1 = 2.0 * max(bbox.xmax, bbox.ymax)\n            ax.set_xlim(x0, x1)\n            ax.set_ylim(x0, x1)\n            # x1,y1=tuple(self.nextp0)\n            # x2,y2=tuple(self.nextp1)\n            # x3,y3=tuple(self.nextpc)\n            # ax.plot([x1,x2,x3], [y1,y2,y3], 'o')#, ms=5, fc='b', ec='b')\n            x, y = tuple(self.next_p0)\n            ax.plot(x, y, 'o', ms=10, c='b')\n\n            ax.annotate(s=self._anote['name'],\n                        xy=self._anote['xypos'],\n                        xytext=self._anote['textpos'],\n                        textcoords='data',\n                        arrowprops=dict(arrowstyle='->'),\n                        rotation=-90,\n                        fontsize='small')\n\n            fig.canvas.draw()\n            plt.grid()\n            plt.show()", "response": "show the element drawing\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the transport matrix for a given electron energy", "response": "def calcTransM(self, gamma=None, type='simu', incsym=-1):\n        \"\"\" calculate transport matrix\n\n        :param gamma: electron energy measured by mc^2\n        :param type: configuration type, 'simu' (simulation mode) or 'online' (online mode)\n        :param incsym: incident symmetry, -1, 0, 1\n        :return: transport matrix\n        :rtype: numpy array\n        \"\"\"\n        sconf = self.getConfig(type=type)\n        bend_length = sconf['l']\n        theta = sconf['angle']\n        rho = bend_length / np.sin(theta)\n        # rho = np.sqrt(gamma**2-1)*m0*c0/bend_field/e0\n        # theta = np.arcsin(bend_length/rho)\n        self.transM = mathutils.transRbend(theta, rho, gamma, incsym)\n        if gamma is not None:\n            m0 = 9.10938215e-31\n            e0 = 1.602176487e-19\n            c0 = 299792458.0\n            self._bend_field = np.sqrt(gamma ** 2 - 1) * m0 * c0 / rho / e0\n            self._rho = rho\n            self.setConf({'rho': self._rho, 'field': self._bend_field}, type='misc')\n        self.transM_flag = True\n        return self.transM"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calcTransM(self, gamma=None):\n        sconf = self.getConfig(type='simu')\n        if 'l' in sconf:\n            l = float(sconf['l'])\n        else:\n            l = 0\n        self.transM = mathutils.transDrift(l, gamma)\n        self.transM_flag = True\n        return self.transM", "response": "calculate transport matrix\n\n        :param gamma: electron energy measured by mc^2\n        :return: transport matrix\n        :rtype: numpy array"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setDraw(self, p0=(0, 0), angle=0, mode='plain'):\n        sconf = self.getConfig(type='simu')\n        if 'l' in sconf:\n            self._style['length'] = float(sconf['l'])\n        else:\n            self._style['length'] = 0\n        self._style['angle'] = angle\n        _theta = angle / 180.0 * np.pi  # deg to rad\n        _length = self._style['length']\n        _lw = self._style['lw']\n        _fancyc = self._style['color']\n        _alpha = self._style['alpha']\n        _plainc = MagBlock._MagBlock__styleconfig_dict['drift']['color']\n\n        #\n        #   |\n        # --p0--p1--\n        #   |\n        # \n        if mode == 'plain':\n            x0, y0 = p0\n            x1, y1 = x0 + _length, y0 + _length * np.tan(_theta)\n            pc = x0 + 0.5 * _length, (y0 + y1) * 0.5\n            vs = [(x0, y0), (x1, y1)]\n            cs = [Path.MOVETO, Path.LINETO]\n            pth = Path(vs, cs)\n            ptch = patches.PathPatch(pth, lw=_lw, fc=_plainc, ec=_plainc, alpha=_alpha)\n            self._patches = []\n            self._patches.append(ptch)\n            self.next_p0 = x1, y1\n            self.next_inc_angle = 0\n        else:  # fancy mode, same as plain, could be more fancy(Apr.08, 2016)\n            x0, y0 = p0\n            # x1, y1 = x0 + _length, y0 + _length * np.tan(_theta)\n            # pc = x0 + 0.5*_length, (y0 + y1)*0.5\n\n            x1, y1 = x0, y0 + 0.5 * _length\n            x2, y2 = x1 + 1. / 3.0 * _length, y1\n            x3, y3 = x2 + 1. / 3.0 * _length, y1\n            x4, y4 = x3 + 1. / 3.0 * _length, y1\n            x5, y5 = x4, y0\n            x6, y6 = x5, y5 - 0.5 * _length\n            x7, y7 = x3, y6\n            x8, y8 = x3, y7 + 1. / 3.0 * _length\n            x9, y9 = x2, y8\n            x10, y10 = x9, y7\n            x11, y11 = x0, y7\n            pc = (x0 + x5) * 0.5, (y0 + y5) * 0.5\n\n            verts1 = [\n                (x0, y0),\n                (x1, y1),\n                (x2, y2),\n                pc,\n                (x3, y3),\n                (x4, y4),\n                (x5, y5),\n                (x6, y6),\n                (x7, y7),\n                (x8, y8),\n                (x9, y9),\n                (x10, y10),\n                (x11, y11),\n                (x0, y0),\n            ]\n\n            codes1 = [\n                Path.MOVETO,\n                Path.LINETO,\n                Path.LINETO,\n                Path.LINETO,\n                Path.LINETO,\n                Path.LINETO,\n                Path.LINETO,\n                Path.LINETO,\n                Path.LINETO,\n                Path.LINETO,\n                Path.LINETO,\n                Path.LINETO,\n                Path.LINETO,\n                Path.CLOSEPOLY,\n            ]\n            pth = Path(verts1, codes1)\n            ptch = patches.PathPatch(pth, lw=_lw, fc=_fancyc, ec=_fancyc, alpha=_alpha)\n            self._patches = []\n            self._patches.append(ptch)\n            # self.next_p0 = x1, y1\n            self.next_p0 = x5, y5\n            self.next_inc_angle = 0\n\n        self._anote = {'xypos': pc, 'textpos': pc, 'name': self.name.upper(), 'type': self.typename}", "response": "set element visualization drawing"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets element visualization drawing", "response": "def setDraw(self, p0=(0, 0), angle=0, mode='plain'):\n        \"\"\" set element visualization drawing\n            \n        :param p0: start drawing position, (x,y)\n        :param angle: rotation angle [deg] of drawing central point, angle is rotating from x-axis to be '+' or '-', '+': anticlockwise, '-': clockwise\n        :param mode: artist mode, 'plain' or 'fancy', 'plain' by default\n        \"\"\"\n\n        sconf = self.getConfig(type='simu')\n        self._style['w'] = float(sconf['l'])  # element width\n        _width = self._style['w']\n        _height = self._style['h']\n        _fc = self._style['fc']\n        _ec = self._style['ec']\n        _alpha = self._style['alpha']\n        _kval = float(sconf['k1'])\n        _lw = self._style['lw']\n\n        if mode == 'plain':\n            # _kval >= 0:\n            #    p1---p2\n            #    |    |\n            #    |    |\n            # ---p0---p3---\n            #\n            # _kval < 0:\n            # ---p0---p3---\n            #    |    |\n            #    |    |\n            #    p1---p2\n\n            x0, y0 = p0\n\n            if _kval >= 0:\n                x1, y1 = x0, y0 + _height\n            else:\n                x1, y1 = x0, y0 - _height\n\n            x2, y2 = x0 + _width, y1\n            x3, y3 = x2, y0\n\n            vs = [(x0, y0), (x1, y1), (x2, y2), (x3, y3), (x0, y0)]\n            cs = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n            pth = Path(vs, cs)\n            ptch = patches.PathPatch(pth, fc=_fc, ec=_ec, alpha=_alpha, lw=_lw)\n\n            self._patches = []\n            self._patches.append(ptch)\n            self.next_p0 = x3, y3\n            self.next_inc_angle = 0\n        else:  # fancy mode\n            #       p1\n            #     /    \\\n            # --p0  pc  p2(nextp0)---\n            #     \\    /\n            #       p3\n\n            x0, y0 = p0\n            x1, y1 = x0 + _width * 0.5, y0 + _height * 0.5\n            x2, y2 = x1 + _width * 0.5, y0\n            x3, y3 = x1, y0 - _height * 0.5\n            pc = x0 + _width * 0.5, y0\n\n            vs0 = [\n                (x0, y0),\n                (x1, y1),\n                (x2, y2),\n                (x3, y3),\n                (x0, y0)\n            ]\n            vs = MagBlock.rot(vs0, theta=angle, pc=p0)\n            cs = [\n                Path.MOVETO,\n                Path.CURVE3,\n                Path.CURVE3,\n                Path.CURVE3,\n                Path.CURVE3\n            ]\n            pth = Path(vs, cs)\n            ptch = patches.PathPatch(pth, fc=_fc, ec=_ec, alpha=_alpha, lw=_lw)\n\n            self._patches = []\n            self._patches.append(ptch)\n            pout = x0 + _width, y0  # the right most point in x-axis\n            self.next_p0 = tuple(MagBlock.rot(pout, theta=angle, pc=p0).tolist())\n            self.next_inc_angle = 0\n\n        pc = x0 + 0.5 * _width, y0\n        self._anote = {'xypos': pc, 'textpos': pc, 'name': self.name.upper(), 'type': self.typename}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating transport matrix :param gamma: electron energy measured by mc^2 :return: transport matrix :rtype: numpy array", "response": "def calcTransM(self, gamma=None, type='simu'):\n        \"\"\"calculate transport matrix\n\n        :param gamma: electron energy measured by mc^2\n        :return: transport matrix\n        :rtype: numpy array\n        \"\"\"\n        sconf = self.getConfig(type=type)\n        l = float(sconf['l'])\n        k1 = self.getK1(type='ctrl')\n        self.transM = mathutils.transQuad(l, k1, gamma)\n        self.transM_flag = True\n        return self.transM"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getK1(self, type='simu'):\n        if type == 'ctrl':\n            pv = self.ctrlinfo.get('k1')['pv']\n            rval = epics.caget(pv)\n            if rval is None:\n                val = self.getConfig(type='simu')['k1']\n            else:\n                val = self.unitTrans(rval, direction='+')\n            return val\n        else:\n            return self.getConfig(type='simu')['k1']", "response": "get quad k1 value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setDraw(self, p0=(0, 0), angle=0, mode='plain'):\n        sconf = self.getConfig(type='simu')\n        if 'l' in sconf:\n            self._style['length'] = float(sconf['l'])\n        else:\n            self._style['length'] = 0\n        self._style['angle'] = angle\n        _theta = angle / 180.0 * np.pi  # deg to rad\n        _length = self._style['length']\n        _lw = self._style['lw']\n        _color = self._style['color']\n        _alpha = self._style['alpha']\n        _height = self._style['h']\n        if 'freq' in sconf:\n            freqi = int(float(sconf['freq']) / 2856.0e6)\n        else:\n            freqi = 0\n\n        if freqi == 1:\n            _fancyc = '#FFDDBB'  # S band\n            _text = 'S'\n        elif freqi == 2:\n            _fancyc = '#5E5EFF'  # C band\n            _text = 'C'\n        elif freqi == 4:\n            _fancyc = '#8800FF'  # X band\n            _text = 'X'\n        else:\n            _fancyc = '#FFBB00'  # other\n            _text = '..'\n\n        #\n        #   p1-------p2\n        #   |        |\n        # --p0       p3--\n        #   |        |\n        #   p5-------p4\n        #\n        if mode == 'plain':\n            x0, y0 = p0\n            x1, y1 = x0, y0 + 0.5 * _height\n            x2, y2 = x0 + _length, y1\n            x3, y3 = x2, y0\n            x4, y4 = x3, y0 - 0.5 * _height\n            x5, y5 = x0, y4\n            vs = [(x0, y0), (x1, y1), (x2, y2), (x3, y3), (x4, y4), (x5, y5), (x0, y0)]\n            cs = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n            pth = Path(vs, cs)\n            ptch = patches.PathPatch(pth, lw=_lw, fc='w', ec=_color, alpha=_alpha)\n            self._patches = []\n            self._patches.append(ptch)\n            self.next_p0 = x3, y3\n            self.next_inc_angle = 0\n            pc = (x0 + x3) * 0.5, (y0 + y3) * 0.5\n        else:  # fancy mode, \n            x0, y0 = p0\n            x1, y1 = x0, y0 + 0.5 * _height\n            x2, y2 = x0 + _length, y1\n            x3, y3 = x2, y0\n            x4, y4 = x3, y0 - 0.5 * _height\n            x5, y5 = x0, y4\n            vs = [(x0, y0), (x1, y1), (x2, y2), (x3, y3), (x4, y4), (x5, y5), (x0, y0)]\n            cs = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n            pth = Path(vs, cs)\n            ptch = patches.PathPatch(pth, lw=_lw, fc=_fancyc, ec=_fancyc, alpha=_alpha)\n            self._patches = []\n            self._patches.append(ptch)\n            self.next_p0 = x3, y3\n            self.next_inc_angle = 0\n            pc = (x0 + x3) * 0.5, (y0 + y3) * 0.5\n\n        self._atext = {'xypos': pc, 'text': _text}\n        self._anote = {'xypos': pc, 'textpos': pc, 'name': self.name.upper(), 'type': self.typename,\n                       'atext': self._atext}", "response": "set element visualization drawing"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting element visualization drawing", "response": "def setDraw(self, p0=(0, 0), angle=0, mode='plain'):\n        \"\"\" set element visualization drawing\n            \n        :param p0: start drawing position, (x,y)\n        :param angle: angle [deg] between x-axis, angle is rotating from x-axis to be '+' or '-', '+': clockwise, '-': anticlockwise\n        :param mode: artist mode, 'plain' or 'fancy', 'plain' by default\n        \"\"\"\n        sconf = self.getConfig(type='simu')\n        if 'l' in sconf:\n            self._style['length'] = float(sconf['l'])\n        else:\n            self._style['length'] = 0\n        self._style['angle'] = angle\n        _theta = angle / 180.0 * np.pi  # deg to rad\n        _length = self._style['length']\n        _lw = self._style['lw']\n        _color = self._style['color']\n        _alpha = self._style['alpha']\n\n        #\n        # --p0-------p1--\n        # \n        if mode == 'plain':\n            x0, y0 = p0\n            x1, y1 = x0 + _length, y0 + _length * np.tan(_theta)\n            vs = [(x0, y0), (x1, y1)]\n            cs = [Path.MOVETO, Path.LINETO]\n            pth = Path(vs, cs)\n            ptch = patches.PathPatch(pth, lw=_lw, fc=_color, ec=_color, alpha=_alpha)\n            self._patches = []\n            self._patches.append(ptch)\n            self.next_p0 = x1, y1\n            self.next_inc_angle = 0\n        else:  # fancy mode, same as plain, could be more fancy(Apr.08, 2016)\n            x0, y0 = p0\n            x1, y1 = x0 + _length, y0 + _length * np.tan(_theta)\n            vs = [(x0, y0), (x1, y1)]\n            cs = [Path.MOVETO, Path.LINETO]\n            pth = Path(vs, cs)\n            ptch = patches.PathPatch(pth, lw=_lw, fc=_color, ec=_color, alpha=_alpha)\n            self._patches = []\n            self._patches.append(ptch)\n            self.next_p0 = x1, y1\n            self.next_inc_angle = 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_fixtures(self, competition=None, team=None, timeFrame=None, matchday=None, season=None, venue=None, league=None):    \n        self.logger.debug(f'Getting fixtures with the following parameters: {locals()}')\n        filters = []\n        if competition is not None:\n            if timeFrame is not None and matchday is not None:\n                raise IncorrectMethodCallException(\"Please filter by either timeFrame or matchday.\")\n            elif timeFrame is not None and matchday is None:\n                filters.append(self.__createFilter('timeFrame', timeFrame))\n            elif timeFrame is None and matchday is not None:\n                filters.append(self.__createFilter('matchday', matchday))\n\n            competition_id = self.__get_competition_id(competition)\n            fixtures = self._request('competitions', competition_id, 'fixtures', filters=filters)\n            if team is not None:\n                fixtures['fixtures'] = list(filter(lambda fixture: fixture['_links']['homeTeam']['href'] == team['_links']['self']['href'] or fixture['_links']['awayTeam']['href'] == team['_links']['self']['href'], fixtures['fixtures']))\n                fixtures['count'] = len(fixtures['fixtures']) \n        elif team is not None:\n            if venue is not None:\n                filters.append(self.__createFilter('venue', venue))\n            if season is not None and timeFrame is not None:\n                raise IncorrectMethodCallException(\"Please filter by either timeFrame or season.\")\n            elif season is not None:\n                filters.append(self.__createFilter('season', season))\n            elif timeFrame is not None:\n                filters.append(self.__createFilter('timeFrame', timeFrame))\n\n            team_id = self.__get_team_id(team)\n            fixtures = self._request('teams', team_id, 'fixtures', filters=filters)\n        else:\n            if league is not None:\n                filters.append(self.__createFilter('league', league))\n            if timeFrame is not None:\n                filters.append(self.__createFilter('timeFrame', timeFrame))\n            \n            fixtures = self._request('fixtures', filters=filters)\n        return fixtures", "response": "This method returns a list of fixtures."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a single fixture.", "response": "def get_fixture(self, fixture_id, head2head=None):\n        \"\"\"\n        Loads a single fixture.\n\n        Args:\n            * fixture_id (str): the id of the fixture\n            * head2head (int, optional): load the previous n fixture of the two teams\n\n        Returns:\n            * :obj: json: the fixture-json\n        \"\"\"\n        filters = []\n        if head2head is not None and int(head2head) > 0:\n            self.logger.debug(f'Getting fixture {fixture_id}. head2head is {head2head}.')\n            filters.append(self.__createFilter('head2head', head2head))\n        else:\n            self.logger.debug(f'Getting fixture {fixture_id}.')\n\n        return self._request('fixtures', fixture_id, filters=filters)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_players(self, team):\n        team_id = self.__get_team_id(team)\n        self.logger.debug(f'Getting players of team {team_id}.')\n        return self._request('teams', team_id, 'players')", "response": "Get the players of a team."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef append_rows(self, rows, between, refresh_presision):\n\t\tfor r in rows:\n\t\t\tMeasurement.register_or_check(finish=r[0], mean=r[1]/between, between=between, refresh_presision=refresh_presision, configuration=self)", "response": "Transform the rows of data to Measurements.\n\n\t\t\tKeyword arguments : rows -- an array of datetime integral_measurements in seconds between - time between integral_measurements in seconds between - time between integral_measurements in seconds refresh_presision -- time between sensor values that compose the integral_measurements in seconds"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef go_inactive(self, dt=datetime.utcnow().replace(tzinfo=pytz.UTC)):\n\t\tself.end = dt\n\t\tself.save()", "response": "Make the configuration object inactive."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nregistering the measurements if it has measurements and close the configuration on disk", "response": "def register_measurements(self, end, rows, between, refresh_presision):\n\t\t\"\"\"Register the measurements if it has measurements and close the configuration, if it hasen't got measurements clean the temporal file on disk.\n\n\t\t\tKeyword arguments:\n\t\t\tf -- open memory file\n\t\t\tend -- datetime of the moment when the configuration go inactive\n\t\t\tbetween -- time between integral_measurements in seconds\n\t\t\trefresh_presision -- time between sensor values that compose the integral_measurements\n\t\t\t\"\"\"\n\t\tif not self.end and len(rows) > 0:\n\t\t\tself.append_rows(rows, between, refresh_presision)\n\t\t\tself.go_inactive(end)\n\t\t\tself.save()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npropose a name for the backup file.", "response": "def get_backup_filename(self, path):\n\t\t\"\"\"Proposes a name for the backup file.\n\n\t\t\tKeyword arguments:\n\t\t\tpath -- temporal filename\n\t\t\t\"\"\"\n\t\thead = datetime.utcnow().replace(tzinfo=pytz.UTC).strftime(\"%Y%m%d%H%M%S\")\n\t\tself.backup = \"stations/backup/%s.%s\" % (head, path)\n\t\treturn self.backup"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_or_check(klass, finish, mean, between, refresh_presision, configuration):\n\t\tm, created = klass.objects.get_or_create(finish=finish, configuration=configuration)\n\t\tif created:\n\t\t\tm.mean=mean\n\t\t\tm.between=between\n\t\t\tm.refresh_presision=refresh_presision\n\t\t\tm.save()\n\t\telse:\n\t\t\tdiff = abs(float(m.mean) - mean)\n\t\t\tif not(diff < 0.006 and m.between == between and m.refresh_presision == refresh_presision):\n\t\t\t\traise InvalidMeasurementError(\"There are diferents values for the same measurement.\")\n\t\treturn m", "response": "Register or update the active configurations."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun all script for this systems.", "response": "def main():\n    # config file\n    conf = Config()\n    actions = []\n\n    debuglevel = logging.ERROR\n    for it in sys.argv[1:]:\n        if it == (\"-v\"):\n            debuglevel = logging.WARNING\n        elif it == (\"-vv\"):\n            debuglevel = logging.INFO\n        elif it == (\"-vvv\"):\n            debuglevel = logging.DEBUG\n        if it == (\"--valid\"):\n            actions.append(\"valid\")\n\n    conf.debuglevel = debuglevel\n\n    srv = ServerApp(conf)\n    status = srv.login(conf.token)\n\n    if not status:\n        sys.exit(100)\n\n    # pick up and run events\n    \"\"\" Run all script for this systems. \"\"\"\n    srv.do_all_actions(conf)\n\n    \"\"\" send data for monitoring \"\"\"\n    if conf.monitoring:\n        srv.monitoring()\n\n    \"\"\" create repo for web project - apache2/uwsgi\"\"\"\n    if conf.webproject:\n        #data =  srv.get_all_projects()\n        #content = aray2xml(data)\n\n        \"\"\" Check all repository on this system. \"\"\"\n        srv.check_repo_all()\n\n        \"\"\" Recount size of full disk in all project on this system. \"\"\"\n        srv.check_size_all()\n\n        \"\"\" reset owners for projects \"\"\"\n        srv.check_rights()\n\n        \"\"\" check running services \"\"\"\n        srv.check_services()\n\n        mng = manager(conf)\n        for it in actions:\n            fc = getattr(mng, it)\n            fc()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_allowed(allow, disallow):\n    if allow is None and disallow is None:\n        return SUMO_VEHICLE_CLASSES\n    elif disallow is None:\n        return allow.split()\n    else:\n        disallow = disallow.split()\n        return tuple([c for c in SUMO_VEHICLE_CLASSES if c not in disallow])", "response": "Normalize the given string attributes as a list of all allowed vClasses."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addJunctionPos(shape, fromPos, toPos):\n    result = list(shape)\n    if fromPos != shape[0]:\n        result = [fromPos] + result\n    if toPos != shape[-1]:\n        result.append(toPos)\n    return result", "response": "Extends shape with the given positions in case they differ from the\n    existing endpoints."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the shape of the lane in 2d.", "response": "def getShape(self, includeJunctions=False):\n        \"\"\"Returns the shape of the lane in 2d.\n\n        This function returns the shape of the lane, as defined in the net.xml\n        file. The returned shape is a list containing numerical\n        2-tuples representing the x,y coordinates of the shape points.\n\n        For includeJunctions=True the returned list will contain\n        additionally the coords (x,y) of the fromNode of the\n        corresponding edge as first element and the coords (x,y)\n        of the toNode as last element.\n\n        For internal lanes, includeJunctions is ignored and the unaltered\n        shape of the lane is returned.\n        \"\"\"\n\n        if includeJunctions and not self._edge.isSpecial():\n            if self._shapeWithJunctions is None:\n                self._shapeWithJunctions = addJunctionPos(self._shape,\n                                                          self._edge.getFromNode().getCoord(),\n                                                          self._edge.getToNode().getCoord())\n            return self._shapeWithJunctions\n        return self._shape"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getShape3D(self, includeJunctions=False):\n\n        if includeJunctions and not self._edge.isSpecial():\n            if self._shapeWithJunctions3D is None:\n                self._shapeWithJunctions3D = addJunctionPos(self._shape3D,\n                                                            self._edge.getFromNode(\n                                                            ).getCoord3D(),\n                                                            self._edge.getToNode().getCoord3D())\n            return self._shapeWithJunctions3D\n        return self._shape3D", "response": "Returns the shape of the lane in 3d."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves compiled regular expressions for supported filename formats", "response": "def get_expressions():\n    \"\"\"Retrieve compiled pattern expressions.\n\n    :returns: compiled regular expressions for supported filename formats\n    :rtype: list\n    \"\"\"\n\n    if len(_EXPRESSIONS) == len(FILENAME_PATTERNS):\n        return _EXPRESSIONS\n\n    for cpattern in FILENAME_PATTERNS:\n        _EXPRESSIONS.append(re.compile(cpattern, re.VERBOSE))\n    return _EXPRESSIONS"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean_dict_keys(d):\n    new_d = {}\n    for (k, v) in d.iteritems():\n        new_d[str(k)] = v\n    return new_d", "response": "Convert all keys of the dict d to ascii - strings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef json_dumps(cls, obj, **kwargs):\n        if 'cls' not in kwargs:\n            kwargs['cls'] = cls.json_encoder\n        return json.dumps(obj, **kwargs)", "response": "A rewrap of json. dumps done for one reason - to inject a custom cls kwarg"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef assemble_request(method, params=tuple(), id=0):\n        if not isinstance(method, (str, unicode)):\n            raise TypeError('\"method\" must be a string (or unicode string).')\n        if not isinstance(params, (tuple, list)):\n            raise TypeError(\"params must be a tuple/list.\")\n\n        return {\n            \"method\": method,\n            \"params\": params,\n            \"id\": id\n        }", "response": "Assemble a JSON - RPC - Request object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nserializes a JSON - RPC - Notification object", "response": "def assemble_notification_request(method, params=tuple()):\n        \"\"\"serialize a JSON-RPC-Notification\n\n        :Parameters: see dumps_request\n        :Returns:   | {\"method\": \"...\", \"params\": ..., \"id\": null}\n                    | \"method\", \"params\" and \"id\" are always in this order.\n        :Raises:    see dumps_request\n        \"\"\"\n        if not isinstance(method, (str, unicode)):\n            raise TypeError('\"method\" must be a string (or unicode string).')\n        if not isinstance(params, (tuple, list)):\n            raise TypeError(\"params must be a tuple/list.\")\n\n        return {\n            \"method\": method,\n            \"params\": params,\n            \"id\": None\n        }"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a JSON - RPC - formatted message and return a dictionary of method name params id and params.", "response": "def parse_request(cls, jsonrpc_message):\n        \"\"\"We take apart JSON-RPC-formatted message as a string and decompose it\n        into a dictionary object, emitting errors if parsing detects issues with\n        the format of the message.\n\n        :Returns:   | [method_name, params, id] or [method_name, params]\n                    | params is a tuple/list\n                    | if id is missing, this is a Notification\n        :Raises:    RPCParseError, RPCInvalidRPC, RPCInvalidMethodParams\n        \"\"\"\n        try:\n            data = cls.json_loads(jsonrpc_message)\n        except ValueError, err:\n            raise errors.RPCParseError(\"No valid JSON. (%s)\" % str(err))\n\n        if not isinstance(data, dict):\n            raise errors.RPCInvalidRPC(\"No valid RPC-package.\")\n        if \"method\" not in data:\n            raise errors.RPCInvalidRPC(\"\"\"Invalid Request, \"method\" is missing.\"\"\")\n        if not isinstance(data[\"method\"], (str, unicode)):\n            raise errors.RPCInvalidRPC(\"\"\"Invalid Request, \"method\" must be a string.\"\"\")\n        if \"id\" not in data:\n            data[\"id\"] = None #be liberal\n        if \"params\" not in data:\n            data[\"params\"] = ()     #be liberal\n        if not isinstance(data[\"params\"], (list, tuple)):\n            raise errors.RPCInvalidRPC(\"\"\"Invalid Request, \"params\" must be an array.\"\"\")\n        if len(data) != 3:\n            raise errors.RPCInvalidRPC(\"\"\"Invalid Request, additional fields found.\"\"\")\n\n        # notification / request\n        if data[\"id\"] is None:\n            return data[\"method\"], data[\"params\"] #notification\n        else:\n            return data[\"method\"], data[\"params\"], data[\"id\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a JSON - RPC response and return a list of result and id.", "response": "def parse_response(cls, jsonrpc_message):\n        \"\"\"de-serialize a JSON-RPC Response/error\n\n        :Returns: | [result, id] for Responses\n        :Raises:  | RPCFault+derivates for error-packages/faults, RPCParseError, RPCInvalidRPC\n                  | Note that for error-packages which do not match the\n                    V2.0-definition, RPCFault(-1, \"Error\", RECEIVED_ERROR_OBJ)\n                    is raised.\n        \"\"\"\n        try:\n            data = cls.json_loads(jsonrpc_message)\n        except ValueError, err:\n            raise errors.RPCParseError(\"No valid JSON. (%s)\" % str(err))\n        if not isinstance(data, dict):\n            raise errors.RPCInvalidRPC(\"No valid RPC-package.\")\n        if \"id\" not in data:\n            raise errors.RPCInvalidRPC(\"\"\"Invalid Response, \"id\" missing.\"\"\")\n        if \"result\" not in data:\n            data[\"result\"] = None #be liberal\n        if \"error\" not in data:\n            data[\"error\"] = None #be liberal\n        if len(data) != 3:\n            raise errors.RPCInvalidRPC(\"\"\"Invalid Response, additional or missing fields.\"\"\")\n\n        #error\n        if data[\"error\"] is not None:\n            if data[\"result\"] is not None:\n                raise errors.RPCInvalidRPC(\"\"\"Invalid Response, one of \"result\" or \"error\" must be null.\"\"\")\n            #v2.0 error-format\n            if (\n                isinstance(data[\"error\"], dict) and\n                \"code\" in data[\"error\"] and\n                \"message\" in data[\"error\"] and\n                (\n                    len(data[\"error\"]) == 2 or\n                    (\"data\" in data[\"error\"] and len(data[\"error\"])==3)\n                )\n            ):\n                if \"data\" not in data[\"error\"]:\n                    error_data = None\n                else:\n                    error_data = data[\"error\"][\"data\"]\n\n                if data[\"error\"][\"code\"] == errors.PARSE_ERROR:\n                    raise errors.RPCParseError(error_data)\n                elif data[\"error\"][\"code\"] == errors.INVALID_REQUEST:\n                    raise errors.RPCInvalidRPC(error_data)\n                elif data[\"error\"][\"code\"] == errors.METHOD_NOT_FOUND:\n                    raise errors.RPCMethodNotFound(error_data)\n                elif data[\"error\"][\"code\"] == errors.INVALID_METHOD_PARAMS:\n                    raise errors.RPCInvalidMethodParams(error_data)\n                elif data[\"error\"][\"code\"] == errors.INTERNAL_ERROR:\n                    raise errors.RPCInternalError(error_data)\n                elif data[\"error\"][\"code\"] == errors.PROCEDURE_EXCEPTION:\n                    raise errors.RPCProcedureException(error_data)\n                elif data[\"error\"][\"code\"] == errors.AUTHENTIFICATION_ERROR:\n                    raise errors.RPCAuthentificationError(error_data)\n                elif data[\"error\"][\"code\"] == errors.PERMISSION_DENIED:\n                    raise errors.RPCPermissionDenied(error_data)\n                elif data[\"error\"][\"code\"] == errors.INVALID_PARAM_VALUES:\n                    raise errors.RPCInvalidParamValues(error_data)\n                else:\n                    raise errors.RPCFault(data[\"error\"][\"code\"], data[\"error\"][\"message\"], error_data)\n            #other error-format\n            else:\n                raise errors.RPCFault(-1, \"Error\", data[\"error\"])\n        #result\n        else:\n            return data[\"result\"], data[\"id\"]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nassembling a JSON - RPC - Request object.", "response": "def assemble_request(method, params=None, notification=False):\n        \"\"\"serialize JSON-RPC-Request\n\n        :Parameters:\n            - method: the method-name (str/unicode)\n            - params: the parameters (None/list/tuple/dict)\n            - notification: bool\n        :Returns:   | {\"jsonrpc\": \"2.0\", \"method\": \"...\", \"params\": ..., \"id\": ...}\n                    | \"jsonrpc\", \"method\", \"params\" and \"id\" are always in this order.\n                    | \"params\" is omitted if empty\n        :Raises:    TypeError if method/params is of wrong type or\n                    not JSON-serializable\n        \"\"\"\n\n        if not isinstance(method, (str, unicode)):\n            raise TypeError('\"method\" must be a string (or unicode string).')\n        if params and not isinstance(params, (tuple, list, dict)):\n            raise TypeError(\"params must be a tuple/list/dict or None.\")\n\n        base = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method\n        }\n\n        if params:\n            base[\"params\"] = params\n\n        if not notification:\n            base['id'] = str(uuid.uuid4())\n\n        return base"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the traps exceptions generated by __parse_single_request and returns them into values of request_id and error in the returned tuple.", "response": "def _parse_single_request_trap_errors(cls, request_data):\n        \"\"\"Traps exceptions generated by __parse_single_request and\n        converts them into values of request_id and error in the\n        returned tuple.\n\n        :Returns: (method_name, params_object, request_id, error)\n                Where:\n                - method_name is a str (or None when error is set)\n                - params_object is one of list/tuple/dict/None\n                - request_id is long/int/string/None\n                - error is an instance of errors.RPCFault subclass or None\n        \"\"\"\n        try:\n            method, params, request_id = cls._parse_single_request(request_data)\n            return method, params, request_id, None\n        except errors.RPCFault as ex:\n            return None, None, ex.request_id, ex"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_request(cls, request_string):\n        try:\n            batch = cls.json_loads(request_string)\n        except ValueError as err:\n            raise errors.RPCParseError(\"No valid JSON. (%s)\" % str(err))\n\n        if isinstance(batch, (list, tuple)) and batch:\n            # batch is true batch.\n            # list of parsed request objects, is_batch_mode_flag\n            return [cls._parse_single_request_trap_errors(request) for request in batch], True\n        elif isinstance(batch, dict):\n            # `batch` is actually single request object\n            return [cls._parse_single_request_trap_errors(batch)], False\n\n        raise errors.RPCInvalidRequest(\"Neither a batch array nor a single request object found in the request.\")", "response": "This method parses out the request string and returns a list of tuples each tuple is a result of parsing each individual item in the batch."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_single_response(cls, response_data):\n\n        if not isinstance(response_data, dict):\n            raise errors.RPCInvalidRequest(\"No valid RPC-package.\")\n\n        if \"id\" not in response_data:\n            raise errors.RPCInvalidRequest(\"\"\"Invalid Response, \"id\" missing.\"\"\")\n\n        request_id = response_data['id']\n\n        if \"jsonrpc\" not in response_data:\n            raise errors.RPCInvalidRequest(\"\"\"Invalid Response, \"jsonrpc\" missing.\"\"\", request_id)\n        if not isinstance(response_data[\"jsonrpc\"], (str, unicode)):\n            raise errors.RPCInvalidRequest(\"\"\"Invalid Response, \"jsonrpc\" must be a string.\"\"\")\n        if response_data[\"jsonrpc\"] != \"2.0\":\n            raise errors.RPCInvalidRequest(\"\"\"Invalid jsonrpc version.\"\"\", request_id)\n\n        error = response_data.get('error', None)\n        result = response_data.get('result', None)\n\n        if error and result:\n            raise errors.RPCInvalidRequest(\"\"\"Invalid Response, only \"result\" OR \"error\" allowed.\"\"\", request_id)\n\n        if error:\n            if not isinstance(error, dict):\n                raise errors.RPCInvalidRequest(\"Invalid Response, invalid error-object.\", request_id)\n\n            if not (\"code\" in error and \"message\" in error):\n                raise errors.RPCInvalidRequest(\"Invalid Response, invalid error-object.\", request_id)\n\n            error_data = error.get(\"data\", None)\n\n            if error['code'] in errors.ERROR_CODE_CLASS_MAP:\n                raise errors.ERROR_CODE_CLASS_MAP[error['code']](error_data, request_id)\n            else:\n                error_object = errors.RPCFault(error_data, request_id)\n                error_object.error_code = error['code']\n                error_object.message = error['message']\n                raise error_object\n\n        return result, request_id", "response": "Parse a single response from the server into a list of objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_response(cls, response_string):\n        try:\n            batch = cls.json_loads(response_string)\n        except ValueError as err:\n            raise errors.RPCParseError(\"No valid JSON. (%s)\" % str(err))\n\n        if isinstance(batch, (list, tuple)) and batch:\n            # batch is true batch.\n            # list of parsed request objects, is_batch_mode_flag\n            return [cls._parse_single_response_trap_errors(response) for response in batch], True\n        elif isinstance(batch, dict):\n            # `batch` is actually single response object\n            return [cls._parse_single_response_trap_errors(batch)], False\n\n        raise errors.RPCParseError(\"Neither a batch array nor a single response object found in the response.\")", "response": "This method parses the response string into a list of tuples each tuple is a tuple describing the individual item in the response."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(self):\n        headers = dict()\n        if self.tfa_token:\n            headers[\"X-GitHub-OTP\"] = self.tfa_token\n        token_name = self.app_name + platform.node()  # node specific in case the user has multiple hosts\n        payload = dict(note=token_name, scopes=self.scopes)\n        response = requests.post(\n                self.api_url + \"authorizations\", auth=(self.user, self.password),\n                headers=headers, json=payload\n        )\n\n        if response.status_code == 401 and \"required\" in response.headers.get(\"X-GitHub-OTP\", \"\"):\n            raise TFARequired(\"TFA required for the user\")\n        if response.status_code == 422:\n            raise AlreadyExistsError(\"APP already exists. Please delete {} token\".format(token_name))\n        if response.status_code == 401:\n            raise BadPassword(\"Bad User/Password\")\n        response.raise_for_status()\n        return response.json()[\"token\"]", "response": "Creates a token in the application"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_github_markdown_writer(opts):\n    assert hasattr(opts, 'wrapper_regex')\n    atx = MarkdownATXWriterStrategy(opts, 'ATX headers')\n    setext = MarkdownSetextWriterStrategy(opts, 'Setext headers')\n    inline = MarkdownInlineLinkWriterStrategy(opts, 'inline links')\n    ref = MarkdownReferenceLinkWriterStrategy(opts, 'reference links')\n    code_block_switch = ghswitches.code_block_switch\n\n    strategies = [atx, setext, inline, ref]\n    switches = [code_block_switch]\n\n    return Writer(strategies, switches=switches)", "response": "Creates a Writer object designed for parsing and writing Markdown files using GitHub style anchor transformation."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall externally when the transport is ready.", "response": "def make_connection(self, transport, address):\n        \"\"\"Called externally when the transport is ready.\"\"\"\n        self.connected = True\n        self.transport = transport\n        self.connection_made(address)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a nicely formatted table of all the PIP commands installed on this system.", "response": "def make_command_table(entry_points):\n    \"\"\"\n    Return a nicely formatted table of all the PIP commands installed on this \n    system to incorporate into the help text.  The table will have two columns.  \n    The first will list the commands that comprise the main pipeline and the \n    second will list all the other miscellaneous helper functions.\n    \"\"\"\n    import itertools\n\n    # Split every command installed on the system into two categories: those \n    # that are part of the main pipeline and those that are just utilities or \n    # helpers.  Pipeline scripts start with numbers, helper scripts don't.\n\n    pipeline_commands = []\n    helper_commands = []\n\n    for command in sorted(entry_points):\n        if re.match('\\d+_', command):\n            pipeline_commands.append(command)\n        else:\n            helper_commands.append(command)\n\n    # Figure out what the longest pipeline command is, so we know how much to \n    # indent the helper commands.\n\n    col_width = 0\n    for command in pipeline_commands:\n        col_width = max(len(command), col_width)\n\n    # Make the table.\n\n    rows = []\n    columns = itertools.izip_longest(\n            pipeline_commands, helper_commands, fillvalue='')\n\n    for commands in columns:\n        row = '        {0[0]:{1}}   {0[1]}'.format(commands, col_width)\n        rows.append(row)\n\n    return '\\n'.join(rows)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the most similar command to the given unknown command.", "response": "def did_you_mean(unknown_command, entry_points):\n    \"\"\"\n    Return the command with the name most similar to what the user typed.  This \n    is used to suggest a correct command when the user types an illegal \n    command.\n    \"\"\"\n    from difflib import SequenceMatcher\n    similarity = lambda x: SequenceMatcher(None, x, unknown_command).ratio()\n    did_you_mean = sorted(entry_points, key=similarity, reverse=True)\n    return did_you_mean[0]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprovide a notifier exception handler.", "response": "def notify_exception_handler(*args):\n    \"\"\"\n    Provides a notifier exception handler.\n\n    :param \\*args: Arguments.\n    :type \\*args: \\*\n    :return: Definition success.\n    :rtype: bool\n    \"\"\"\n\n    callback = RuntimeGlobals.components_manager[\"factory.script_editor\"].restore_development_layout\n    foundations.exceptions.base_exception_handler(*args)\n    cls, instance = foundations.exceptions.extract_exception(*args)[:2]\n    RuntimeGlobals.notifications_manager.exceptify(message=\"{0}\".format(instance), notification_clicked_slot=callback)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding the blocks starting from start until stop.", "response": "def blocks(self, start=None, stop=None):\n        \"\"\" Yields blocks starting from ``start``.\n\n            :param int start: Starting block\n            :param int stop: Stop at this block\n            :param str mode: We here have the choice between\n                 * \"head\": the last block\n                 * \"irreversible\": the block that is confirmed by 2/3 of all block producers and is thus irreversible!\n        \"\"\"\n        # Let's find out how often blocks are generated!\n        block_interval = self.config().get(\"STEEMIT_BLOCK_INTERVAL\")\n\n        if not start:\n            start = self.get_current_block_num()\n\n        # We are going to loop indefinitely\n        while True:\n\n            # Get chain properies to identify the\n            head_block = self.get_current_block_num()\n\n            # Blocks from start until head block\n            for blocknum in range(start, head_block + 1):\n                # Get full block\n                block = self.steem.rpc.get_block(blocknum)\n                block.update({\"block_num\": blocknum})\n                yield block\n\n            # Set new start\n            start = head_block + 1\n\n            if stop and start > stop:\n                break\n\n            # Sleep for one block\n            time.sleep(block_interval)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ops(self, start=None, stop=None, only_virtual_ops=False):\n\n        # Let's find out how often blocks are generated!\n        block_interval = self.config().get(\"STEEMIT_BLOCK_INTERVAL\")\n\n        if not start:\n            start = self.get_current_block_num()\n\n        # We are going to loop indefinitely\n        while True:\n\n            # Get chain properies to identify the\n            head_block = self.get_current_block_num()\n\n            # Blocks from start until head block\n            for block_num in range(start, head_block + 1):\n                # Get full block\n                yield from self.steem.rpc.get_ops_in_block(block_num, only_virtual_ops)\n\n            # Set new start\n            start = head_block + 1\n\n            if stop and start > stop:\n                break\n\n            # Sleep for one block\n            time.sleep(block_interval)", "response": "Yields all operations in the specified block."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stream(self, filter_by=list(), *args, **kwargs):\n        if isinstance(filter_by, str):\n            filter_by = [filter_by]\n\n        for event in self.ops(*args, **kwargs):\n            op_type, op = event['op']\n            if not filter_by or op_type in filter_by:\n                yield {\n                    **op,\n                    \"type\": op_type,\n                    \"timestamp\": parse_time(event.get(\"timestamp\")),\n                    \"block_num\": event.get(\"block\"),\n                    \"trx_id\": event.get(\"trx_id\"),\n                }", "response": "Yields a stream of all blocks in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nestimates block number from given time string", "response": "def get_block_from_time(self, timestring, error_margin=10):\n        \"\"\" Estimate block number from given time\n\n            :param str timestring: String representing time\n            :param int error_margin: Estimate block number within this interval (in seconds)\n\n        \"\"\"\n        known_block = self.get_current_block()['block_num']\n        known_block_timestamp = self.block_timestamp(known_block)\n        timestring_timestamp = parse_time(timestring).timestamp()\n        delta = known_block_timestamp - timestring_timestamp\n        block_delta = delta / 3\n        guess_block = known_block - block_delta\n        guess_block_timestamp = self.block_timestamp(guess_block)\n        error = timestring_timestamp - guess_block_timestamp\n        while abs(error) > error_margin:\n            guess_block += error / 3\n            guess_block_timestamp = self.block_timestamp(guess_block)\n            error = timestring_timestamp - guess_block_timestamp\n        return int(guess_block)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fromCSV(csvfile,out=None,fieldnames=None,fmtparams=None,conv_func={},\r\n    empty_to_None=[]):\r\n    \"\"\"Conversion from CSV to PyDbLite\r\n    csvfile : name of the CSV file in the file system\r\n\r\n    out : path for the new PyDbLite base in the file system\r\n\r\n    fieldnames : list of field names. If set to None, the field names must\r\n    be present in the first line of the CSV file\r\n    \r\n    fmtparams : the format parameters for the CSV file, as described in \r\n    the csv module of the standard distribution\r\n    \r\n    conv_func is a dictionary mapping a field name to the function used to\r\n    convert the string read in the CSV to the appropriate Python type. For\r\n    instance if field \"age\" must be converted to an integer :\r\n    conv_func[\"age\"] = int\r\n    \r\n    empty_to_None is a list of the fields such that when the value read in\r\n    the CSV file is the empty string, the field value is set to None\r\n    \"\"\"\r\n    import csv\r\n    import time\r\n    import datetime\r\n    \r\n    if out is None:\r\n        out = os.path.splitext(csvfile)[0]+\".pdl\"\r\n        \r\n    if fieldnames is None:\r\n        # read field names in the first line of CSV file\r\n        reader = csv.reader(open(csvfile))\r\n        fieldnames = reader.next()\r\n\r\n    reader = csv.DictReader(open(csvfile),fieldnames,fmtparams)\r\n    reader.next() # skip first line\r\n\r\n    db = PyDbLite.Base(out)\r\n\r\n    conv_func.update({\"__id__\":int})\r\n    auto_id = not \"__id__\" in fieldnames\r\n    fieldnames = [ f for f in fieldnames if not f in (\"__id__\") ]\r\n    \r\n    kw = {\"mode\":\"override\"}\r\n    db.create(*fieldnames,**kw)\r\n    print db.fields\r\n    \r\n    next_id = 0\r\n    records = {}\r\n    while True:\r\n        try:\r\n            record = reader.next()\r\n        except StopIteration:\r\n            break\r\n        if auto_id:\r\n            record[\"__id__\"] = next_id\r\n            next_id += 1\r\n        # replace empty strings by None\r\n        for field in empty_to_None:\r\n            if not record[field]:\r\n                record[field] = None\r\n        # type conversion\r\n        for field in conv_func:\r\n            if not isinstance(conv_func[field],(tuple,list)):\r\n                record[field] = conv_func[field](record[field])\r\n            else:\r\n                # date or datetime\r\n                date_class,date_fmt = conv_func[field]\r\n                if not record[field]:\r\n                    record[field] = None\r\n                else:\r\n                    time_tuple = time.strptime(record[field],date_fmt)\r\n                    if date_class is datetime.date:\r\n                        time_tuple = time_tuple[:3]\r\n                    record[field] = date_class(*time_tuple)\r\n        records[record[\"__id__\"]] = record\r\n    db.records = records\r\n    db.commit()\r\n    print len(db)\r\n    return db", "response": "Convert a CSV file to a new PyDbLite object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef in_period(period, dt=None):\n\n    if dt is None:\n        dt = datetime.now()\n\n    # transform whatever crazy format we're given and turn it into\n    # something like this:\n    #\n    # md{1}|hr{midnight-noon},md{2}|hr{noon-midnight}\n    period = re.sub(r\"^\\s*|\\s*$\", '', period)\n    period = re.sub(r\"\\s*(?={|$)\", '', period)\n    period = re.sub(r\",\\s*\", ',', period)\n    period = re.sub(r\"\\s*-\\s*\", '-', period)\n    period = re.sub(r\"{\\s*\", '{', period)\n    period = re.sub(r\"\\s*}\\s*\", '}', period)\n    period = re.sub(r\"}(?=[^,])\", '}|', period)\n    period = period.lower()\n\n    if period == '':\n        return True\n\n    sub_periods = re.split(',', period)\n\n    # go through each sub-period until one matches (OR logic)\n    for sp in sub_periods:\n        if _is_in_sub_period(sp, dt):\n            return True\n\n    return False", "response": "Determines if a datetime is within a certain time period."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_scale(scale_exp):\n\n    m = re.search(\"(\\w+?)\\{(.*?)\\}\", scale_exp)\n    if m is None:\n        raise InvalidFormat('Unable to parse the given time period.')\n    scale = m.group(1)\n    range = m.group(2)\n\n    if scale not in SCALES:\n        raise InvalidFormat('%s is not a valid scale.' % scale)\n\n    ranges = re.split(\"\\s\", range)\n\n    return scale, ranges", "response": "Parses a scale expression and returns the scale and a list of ranges."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding and return full command to use with subprocess. Popen for git tag", "response": "def tag(version, params):\n        \"\"\"Build and return full command to use with subprocess.Popen for 'git tag' command\n\n        :param version:\n        :param params:\n        :return: list\n        \"\"\"\n        cmd = ['git', 'tag', '-a', '-m', 'v%s' % version, str(version)]\n        if params:\n            cmd.extend(params)\n\n        return cmd"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting command using subprocess. Popen and return code stdout and stderr.", "response": "def _exec(cmd):\n        \"\"\"Execute command using subprocess.Popen\n        :param cmd:\n        :return: (code, stdout, stderr)\n        \"\"\"\n        process = subprocess.Popen(cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n\n        # pylint: disable=unexpected-keyword-arg\n        (stdout, stderr) = process.communicate(timeout=defaults.DEFAULT_VCS_TIMEOUT)\n\n        return process.returncode, stdout.decode(), stderr.decode()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates VCS tag :param version: :param params: :return:", "response": "def create_tag(self, version, params):\n        \"\"\"Create VCS tag\n\n        :param version:\n        :param params:\n        :return:\n        \"\"\"\n        cmd = self._command.tag(version, params)\n\n        (code, stdout, stderr) = self._exec(cmd)\n\n        if code:\n            raise errors.VCSError('Can\\'t create VCS tag %s. Process exited with code %d and message: %s' % (\n                version, code, stderr or stdout))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef raise_if_cant_commit(self):\n        cmd = self._command.status()\n\n        (code, stdout, stderr) = self._exec(cmd)\n\n        if code:\n            raise errors.VCSError('Can\\'t verify VCS status. Process exited with code %d and message: %s' % (\n                code, stderr or stdout))\n\n        for line in stdout.splitlines():\n            if line.startswith(('??', '!!')):\n                continue\n            raise errors.VCSStateError(\"VCS status doesn't allow to commit. Please commit or stash your changes and try again\")", "response": "Verify VCS status and raise an error if commit is disallowed"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_commit(self, message):\n        cmd = self._command.commit(message)\n\n        (code, stdout, stderr) = self._exec(cmd)\n\n        if code:\n            raise errors.VCSError('Commit failed. Process exited with code %d and message: %s' % (\n                code, stderr or stdout))", "response": "Create commit command and return the new version of the record set."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_to_stage(self, paths):\n        cmd = self._command.add(paths)\n\n        (code, stdout, stderr) = self._exec(cmd)\n\n        if code:\n            raise errors.VCSError('Can\\'t add paths to VCS. Process exited with code %d and message: %s' % (\n                code, stderr + stdout))", "response": "Stage given files to the VCS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connection_made(self, address):\n        logger.info(\"connection made to {}\".format(address))\n        self.count = 0\n        self.connected = True\n        self.transport.write(b'Echo Me')", "response": "When the connection is made send something."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of MemMaps and values for a given symbol.", "response": "def find_symbol(pid, symbol):\n    \"\"\"Return [(MemMap, value), ...]\"\"\"\n    for mapping in read_proc_maps(pid):\n\n        if not mapping.filename or not os.path.exists(mapping.filename):\n            continue\n        # We're interested only in the main mapping for each library\n        # It looks like executable bit and 0 offset suits our needs\n        if 'x' not in mapping.perms or mapping.offset:\n            continue\n\n        offset = find_symbol_in_file(mapping.filename, symbol)\n\n        # This is probably horribly wrong, we say\n        # that symbol has absolute value if it is located in executable\n        absolute = os.path.samefile(mapping.filename, get_pid_executable(pid))\n\n        if offset is not None:\n            yield mapping, offset, absolute"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nserialize the provided template according to the language specifications.", "response": "def serialize(template, options=SerializerOptions()):\n    \"\"\"Serialize the provided template according to the language\n    specifications.\"\"\"\n    context = SerializerContext(options)\n    context.serialize(flatten(template))\n    return context.output"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprints provided string to the output.", "response": "def write(self, string):\n        \"\"\"Print provided string to the output.\"\"\"\n        self._output += self._options.indentation_character * \\\n            self._indentation + string + '\\n'"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nserializes tag and print it to the output.", "response": "def serialize(self, tag):\n        \"\"\"Serialize tag and print it to the output.\"\"\"\n        try:\n            tag.serialize(self)\n        except (AttributeError, TypeError):\n            self.write(str(tag))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_children(self, value, defined):\n        self.children = value\n        self.children_defined = defined\n        return self", "response": "Set the children of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the children of the span block.", "response": "def set_children(self, children):\n        \"\"\"Set children of the span block.\"\"\"\n        if isinstance(children, tuple):\n            self._children = list(children)\n        else:\n            self._children = [children]\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npush a notification to a Pushed application.", "response": "def push_app(self, content, content_url=None):\n        '''Push a notification to a Pushed application.\n\n        Param: content -> content of Pushed notification message\n               content_url (optional) -> enrich message with URL\n        Returns Shipment ID as string\n        '''\n        parameters = {\n            'app_key': self.app_key,\n            'app_secret': self.app_secret\n        }\n        return self._push(content, 'app', parameters, content_url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef push_channel(self, content, channel, content_url=None):\n        '''Push a notification to a Pushed channel.\n\n        Param: content -> content of Pushed notification message\n               channel -> string identifying a Pushed channel\n               content_url (optional) -> enrich message with URL\n        Returns Shipment ID as string\n        '''\n        parameters = {\n            'app_key': self.app_key,\n            'app_secret': self.app_secret,\n            'target_alias': channel\n        }\n        return self._push(content, 'channel', parameters, content_url)", "response": "Push a notification to a Pushed channel."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npushing a notification to a specific pushed user.", "response": "def push_user(self, content, access_token, content_url=None):\n        '''Push a notification to a specific pushed user.\n\n        Param: content -> content of Pushed notification message\n               access_token -> OAuth access token\n               content_url (optional) -> enrich message with URL\n        Returns Shipment ID as string\n        '''\n        parameters = {\n            'app_key': self.app_key,\n            'app_secret': self.app_secret,\n            'access_token': access_token\n        }\n        return self._push(content, 'user', parameters, content_url)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef push_pushed_id(self, content, pushed_id, content_url=None):\n        '''Push a notification to a specific pushed user by Pushed ID.\n\n        Param: content -> content of Pushed notification message\n               pushed_id -> user's pushed ID\n               content_url (optional) -> enrich message with URL\n        Returns Shipment ID as string\n        '''\n        parameters = {\n            'app_key': self.app_key,\n            'app_secret': self.app_secret,\n            'pushed_id': pushed_id,\n            'target_alias': 'Nothing'   # Required, but seems unused\n        }\n        return self._push(content, 'pushed_id', parameters, content_url)", "response": "Push a notification to a specific pushed user by Pushed ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexchanges a temporary OAuth2 code for an access token.", "response": "def access_token(self, code):\n        '''Exchange a temporary OAuth2 code for an access token.\n\n        Param: code -> temporary OAuth2 code from a Pushed callback\n        Returns access token as string\n        '''\n        parameters = {\"code\": code}\n        access_uri = \"/\".join([BASE_URL, API_VERSION, ACCESS_TOKEN])\n        # RFC non-compliant response prevents use of standard OAuth modules\n        success, response = self._request(access_uri, parameters)\n        if success:\n            return response['response']['data']['access_token']\n        else:\n            raise PushedAPIError(\n                response['error']['type'],\n                response['error']['message']\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing OAuth2 authorization link.", "response": "def authorization_link(self, redirect_uri):\n        '''Construct OAuth2 authorization link.\n\n        Params:    redirect_uri -> URI for receiving callback with token\n        Returns authorization URL as string\n        '''\n        args = '?client_id=%s&redirect_uri=%s' % (\n            self.app_key,\n            redirect_uri\n        )\n        uri = \"/\".join([BASE_URL, API_VERSION, OAUTH, args])\n        return uri"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_admins_from_django(homedir):\n    return [\"root@localhost\"]\n    \"\"\" Get admin's emails from django settings \"\"\"\n    path = homedir + \"/settings/basic.py\"\n    if not os.path.exists(path):\n        path = homedir + \"/settings.py\"\n\n    if not os.path.exists(path):\n        return\n\n    mod = compiler.parseFile(path)\n    for node in mod.node.nodes:\n        try:\n            if node.asList()[0].name == \"ADMINS\":\n                # print dir(node.asList()[1].nodes)\n                # print node.asList()[1].nodes\n                return [it.nodes[1].value for it in node.asList()[1].asList()]\n        except:\n            pass", "response": "Get admin s emails from django settings"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions for sending email though gmail", "response": "def send_mail(subject, body, email_from, emails_to):\n    \"\"\" Funxtion for sending email though gmail \"\"\"\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = email_from\n    msg['To'] = \", \".join(emails_to)\n    s = smtplib.SMTP('smtp.gmail.com', 587)\n    s.ehlo()  # for tls add this line\n    s.starttls()  # for tls add this line\n    s.ehlo()  # for tls add this line\n    s.login(SMTP_USERNAME, SMTP_PASSWORD)\n    s.sendmail(email_from, emails_to, msg.as_string())\n    s.quit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef format_argspec_plus(fn, grouped=True):\n    spec = callable(fn) and inspect.getargspec(fn) or fn\n    args = inspect.formatargspec(*spec)\n    if spec[0]:\n        self_arg = spec[0][0]\n    elif spec[1]:\n        self_arg = '%s[0]' % spec[1]\n    else:\n        self_arg = None\n    apply_pos = inspect.formatargspec(spec[0], spec[1], spec[2])\n    defaulted_vals = spec[3] is not None and spec[0][0-len(spec[3]):] or ()\n    apply_kw = inspect.formatargspec(spec[0], spec[1], spec[2], defaulted_vals,\n                                     formatvalue=lambda x: '=' + x)\n    if grouped:\n        return dict(args=args, self_arg=self_arg,\n                    apply_pos=apply_pos, apply_kw=apply_kw)\n    else:\n        return dict(args=args[1:-1], self_arg=self_arg,\n                    apply_pos=apply_pos[1:-1], apply_kw=apply_kw[1:-1])", "response": "Returns a dictionary of formatted introspected function arguments."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _num_required_args(func):\n    try:\n        spec = inspect.getargspec(func)\n        if spec.varargs:\n            return None\n        num_defaults = len(spec.defaults) if spec.defaults else 0\n        return len(spec.args) - num_defaults\n    except TypeError:\n        return None", "response": "Number of required arguments for a function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndecorating a function to emit a deprecation warning with the given message.", "response": "def deprecate(message):\n    \"\"\"\n        Decorate a function to emit a deprecation warning with the given\n        message.\n    \"\"\"\n    @decorator\n    def decorate(fn, *args, **kw):\n        warnings.warn(message, DeprecationWarning, 2)\n        return fn(*args, **kw)\n    return decorate"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncatch exceptions and email them using `send_mail_func` which should accept a single string argument which will be the traceback to be emailed. Will re-raise original exception if calling `send_mail_func` raises an exception. Provide a logging.Logger instance for `logger` if desired (recommended). The exceptions this decorator handled can be adjusted by setting `catch` to an Exception class or tuple of exception classes that should be handled.", "response": "def exc_emailer(send_mail_func, logger=None, catch=Exception, print_to_stderr=True):\n    \"\"\"\n        Catch exceptions and email them using `send_mail_func` which should\n        accept a single string argument which will be the traceback to be\n        emailed. Will re-raise original exception if calling `send_mail_func`\n        raises an exception.\n\n        Provide a logging.Logger instance for `logger` if desired (recommended).\n\n        The exceptions this decorator handled can be adjusted by setting `catch`\n        to an Exception class or tuple of exception classes that should be\n        handled.\n\n    \"\"\"\n    # if they don't give a logger, use our own\n    if logger is None:\n        logger = log\n\n    @decorator\n    def decorate(fn, *args, **kwargs):\n        exc_info = None\n        try:\n            return fn(*args, **kwargs)\n        except catch as e:\n            body = format_exc()\n            exc_info = sys.exc_info()\n            error_msg = 'exc_mailer() caught an exception, email will be sent.'\n            logger.exception(error_msg)\n            if print_to_stderr:\n                print(error_msg + '  ' + str(e), file=sys.stderr)\n            try:\n                send_mail_func(body)\n            except Exception:\n                logger.exception('exc_mailer(): send_mail_func() threw an exception, '\n                                 'logging it & then re-raising original exception')\n                six.reraise(exc_info[0], exc_info[1], exc_info[2])\n        finally:\n            # delete the traceback so we don't have garbage collection issues.\n            # see warning at: http://docs.python.org/library/sys.html#sys.exc_info\n            if exc_info is not None:\n                del exc_info\n    return decorate"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef memoize(method_to_wrap):\n    memoize_key = '_memoize_cache_{0}'.format(id(method_to_wrap))\n\n    @wrapt.decorator\n    def inner_memoize(wrapped, instance, args, kwargs):\n        if instance is None and inspect.isclass(wrapped):\n            # Wrapped function is a class and we are creating an\n            # instance of the class. Don't support this case, just\n            # return straight away.\n\n            return wrapped(*args, **kwargs)\n\n        # Retrieve the cache, attaching an empty one if none exists.\n        cache = instance.__dict__.setdefault(memoize_key, {})\n\n        # Now see if entry is in the cache and if it isn't then call\n        # the wrapped function to generate it.\n\n        try:\n            key = (args, frozenset(kwargs.items()))\n            return cache[key]\n\n        except KeyError:\n            result = cache[key] = wrapped(*args, **kwargs)\n            return result\n\n    def reset_memoize(target, *args):\n        target.__dict__[memoize_key] = {}\n\n    decorated = inner_memoize(method_to_wrap)\n    decorated.reset_memoize = reset_memoize\n    return decorated", "response": "Decorator that creates a memoization of the given method."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef edit_block(object):\n\n    @functools.wraps(object)\n    def edit_block_wrapper(*args, **kwargs):\n        \"\"\"\n        Handles edit blocks undo states.\n\n        :param \\*args: Arguments.\n        :type \\*args: \\*\n        :param \\*\\*kwargs: Keywords arguments.\n        :type \\*\\*kwargs: \\*\\*\n        :return: Object.\n        :rtype: object\n        \"\"\"\n\n        if args:\n            cursor = foundations.common.get_first_item(args).textCursor()\n            cursor.beginEditBlock()\n        value = None\n        try:\n            value = object(*args, **kwargs)\n        finally:\n            if args:\n                cursor.endEditBlock()\n            return value\n\n    return edit_block_wrapper", "response": "Handles edit blocks undo states."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nanchor the text cursor position.", "response": "def anchor_text_cursor(object):\n    \"\"\"\n    Anchors the text cursor position.\n\n    :param object: Object to decorate.\n    :type object: object\n    :return: Object.\n    :rtype: object\n    \"\"\"\n\n    @functools.wraps(object)\n    def anchor_text_cursorWrapper(*args, **kwargs):\n        \"\"\"\n        Anchors the text cursor position.\n\n        :param \\*args: Arguments.\n        :type \\*args: \\*\n        :param \\*\\*kwargs: Keywords arguments.\n        :type \\*\\*kwargs: \\*\\*\n        :return: Object.\n        :rtype: object\n        \"\"\"\n\n        if args:\n            if hasattr(foundations.common.get_first_item(args), \"store_text_cursor_anchor\"):\n                foundations.common.get_first_item(args).store_text_cursor_anchor()\n\n        value = object(*args, **kwargs)\n\n        if args:\n            if hasattr(foundations.common.get_first_item(args), \"restore_text_cursor_anchor\"):\n                foundations.common.get_first_item(args).store_text_cursor_anchor()\n\n        return value\n\n    return anchor_text_cursorWrapper"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef center_text_cursor(object):\n\n    @functools.wraps(object)\n    def center_text_cursor_wrapper(*args, **kwargs):\n        \"\"\"\n        Centers the text cursor position.\n\n        :param \\*args: Arguments.\n        :type \\*args: \\*\n        :param \\*\\*kwargs: Keywords arguments.\n        :type \\*\\*kwargs: \\*\\*\n        :return: Object.\n        :rtype: object\n        \"\"\"\n\n        if args:\n            if hasattr(foundations.common.get_first_item(args), \"setCenterOnScroll\"):\n                foundations.common.get_first_item(args).setCenterOnScroll(True)\n\n        value = object(*args, **kwargs)\n\n        if args:\n            if hasattr(foundations.common.get_first_item(args), \"setCenterOnScroll\"):\n                foundations.common.get_first_item(args).setCenterOnScroll(False)\n\n        return value\n\n    return center_text_cursor_wrapper", "response": "Centers the text cursor position."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef search_pattern(self, value):\n\n        if value is not None:\n            assert type(value) in (unicode, QString), \\\n                \"'{0}' attribute: '{1}' type is not 'unicode' or 'QString'!\".format(\"search_pattern\", value)\n        self.__search_pattern = value", "response": "Setter for **self. __search_pattern** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef maximum_font_point_size(self, value):\n\n        if value is not None:\n            assert type(value) in (int, float), \"'{0}' attribute: '{1}' type is not 'int' or 'float'!\".format(\n                \"maximum_font_point_size\", value)\n            assert value > self.__minimum_font_point_size, \\\n                \"'{0}' attribute: '{1}' need to be exactly superior to '{2}'!\".format(\n                    \"maximum_font_point_size\", value, self.__minimum_font_point_size)\n        self.__maximum_font_point_size = value", "response": "Sets the value of the maximum font point size attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wheelEvent(self, event):\n\n        if event.modifiers() == Qt.ControlModifier:\n            if event.delta() == 120:\n                self.zoom_in()\n            elif event.delta() == -120:\n                self.zoom_out()\n            event.ignore()\n        else:\n            QPlainTextEdit.wheelEvent(self, event)", "response": "Reimplementes the QPlainTextEdit. wheelEvent method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __select_text_under_cursor_blocks(self, cursor):\n\n        start_block = self.document().findBlock(cursor.selectionStart()).firstLineNumber()\n        end_block = self.document().findBlock(cursor.selectionEnd()).firstLineNumber()\n        cursor.setPosition(self.document().findBlockByLineNumber(start_block).position())\n        cursor.movePosition(QTextCursor.StartOfLine, QTextCursor.MoveAnchor)\n        cursor.movePosition(QTextCursor.Down, QTextCursor.KeepAnchor, end_block - start_block)\n        cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)", "response": "Selects the document text under cursor blocks."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn current document selected text metrics.", "response": "def get_selected_text_metrics(self):\n        \"\"\"\n        Returns current document selected text metrics.\n\n        :return: Selected text metrics.\n        :rtype: tuple\n        \"\"\"\n\n        selected_text = self.get_selected_text()\n        if not selected_text:\n            return tuple()\n\n        return (selected_text, self.get_cursor_line(), self.get_cursor_column() - len(selected_text))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstores the document cursor anchor.", "response": "def store_text_cursor_anchor(self):\n        \"\"\"\n        Stores the document cursor anchor.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        self.__text_cursor_anchor = (self.textCursor(),\n                                     self.horizontalScrollBar().sliderPosition(),\n                                     self.verticalScrollBar().sliderPosition())\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef restore_text_cursor_anchor(self):\n\n        if not self.__text_cursor_anchor:\n            return False\n\n        text_cursor, horizontal_scroll_bar_slider_position, vertical_scroll_bar_slider_position = self.__text_cursor_anchor\n        self.setTextCursor(text_cursor)\n        self.horizontalScrollBar().setSliderPosition(horizontal_scroll_bar_slider_position)\n        self.verticalScrollBar().setSliderPosition(vertical_scroll_bar_slider_position)\n        return True", "response": "Restores the document cursor anchor."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the character before the cursor.", "response": "def get_previous_character(self):\n        \"\"\"\n        Returns the character before the cursor.\n\n        :return: Previous cursor character.\n        :rtype: QString\n        \"\"\"\n\n        cursor = self.textCursor()\n        cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.KeepAnchor)\n        return cursor.selectedText()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the next character after the cursor.", "response": "def get_next_character(self):\n        \"\"\"\n        Returns the character after the cursor.\n\n        :return: Next cursor character.\n        :rtype: QString\n        \"\"\"\n\n        cursor = self.textCursor()\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor)\n        return cursor.selectedText()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the document words.", "response": "def get_words(self):\n        \"\"\"\n        Returns the document words.\n\n        :return: Document words.\n        :rtype: list\n        \"\"\"\n\n        words = []\n        block = self.document().findBlockByLineNumber(0)\n        while block.isValid():\n            blockWords = foundations.strings.get_words(foundations.strings.to_string(block.text()))\n            if blockWords:\n                words.extend(blockWords)\n            block = block.next()\n        return words"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the document word under cursor. Using Qt legacy", "response": "def get_word_under_cursor_legacy(self):\n        \"\"\"\n        Returns the document word under cursor ( Using Qt legacy \"QTextCursor.WordUnderCursor\" ).\n\n        :return: Word under cursor.\n        :rtype: QString\n        \"\"\"\n\n        cursor = self.textCursor()\n        cursor.select(QTextCursor.WordUnderCursor)\n        return cursor.selectedText()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the document word under cursor.", "response": "def get_word_under_cursor(self):\n        \"\"\"\n        Returns the document word under cursor.\n\n        :return: Word under cursor.\n        :rtype: QString\n        \"\"\"\n\n        if not re.match(r\"^\\w+$\", foundations.strings.to_string(self.get_previous_character())):\n            return QString()\n\n        cursor = self.textCursor()\n        cursor.movePosition(QTextCursor.PreviousWord, QTextCursor.MoveAnchor)\n        cursor.movePosition(QTextCursor.EndOfWord, QTextCursor.KeepAnchor)\n        return cursor.selectedText()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_partial_word_under_cursor(self):\n\n        if not re.match(r\"^\\w+$\", foundations.strings.to_string(self.get_previous_character())):\n            return QString()\n\n        cursor = self.textCursor()\n        position = cursor.position()\n        cursor.movePosition(QTextCursor.PreviousWord, QTextCursor.KeepAnchor)\n        return cursor.selectedText()", "response": "Returns the document partial word under cursor."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the content of the current document while providing undo capability.", "response": "def set_content(self, content):\n        \"\"\"\n        Sets document with given content while providing undo capability.\n\n        :param content: Content to set.\n        :type content: list\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        cursor = self.textCursor()\n        cursor.movePosition(QTextCursor.Start, QTextCursor.MoveAnchor)\n        cursor.movePosition(QTextCursor.End, QTextCursor.KeepAnchor)\n        cursor.removeSelectedText()\n        for line in content:\n            self.moveCursor(QTextCursor.End)\n            self.insertPlainText(line)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete the document lines under cursor.", "response": "def delete_lines(self):\n        \"\"\"\n        Deletes the document lines under cursor.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        cursor = self.textCursor()\n        self.__select_text_under_cursor_blocks(cursor)\n        cursor.removeSelectedText()\n        cursor.deleteChar()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nduplicates the document lines under cursor. :return: Method success. :rtype: bool", "response": "def duplicate_lines(self):\n        \"\"\"\n        Duplicates the document lines under cursor.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        cursor = self.textCursor()\n        self.__select_text_under_cursor_blocks(cursor)\n        text = cursor.selectedText()\n\n        cursor.setPosition(cursor.block().next().position())\n        cursor.position() == cursor.document().firstBlock().position() and cursor.setPosition(\n            cursor.document().lastBlock().position())\n\n        start_position = cursor.position()\n        cursor.insertText(text)\n        end_position = cursor.position()\n        cursor.insertText(QChar(QChar.ParagraphSeparator))\n\n        cursor.setPosition(start_position, QTextCursor.MoveAnchor)\n        cursor.setPosition(end_position, QTextCursor.KeepAnchor)\n        self.setTextCursor(cursor)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef move_lines(self, direction=QTextCursor.Up):\n\n        cursor = self.textCursor()\n        if (direction == QTextCursor.Up and cursor.block() == cursor.document().firstBlock()) or \\\n                (direction == QTextCursor.Down and cursor.block() == cursor.document().lastBlock()):\n            return False\n\n        self.__select_text_under_cursor_blocks(cursor)\n        text = cursor.selectedText()\n        cursor.removeSelectedText()\n        cursor.deleteChar()\n\n        cursor.setPosition(cursor.block().next().position() if direction == QTextCursor.Down else\n                           cursor.block().previous().position())\n        if cursor.position() == cursor.document().firstBlock().position() and direction == QTextCursor.Down:\n            cursor.movePosition(QTextCursor.End)\n            cursor.insertText(QChar(QChar.ParagraphSeparator))\n\n        start_position = cursor.position()\n        cursor.insertText(text)\n        end_position = cursor.position()\n        not cursor.atEnd() and cursor.insertText(QChar(QChar.ParagraphSeparator))\n\n        cursor.setPosition(start_position, QTextCursor.MoveAnchor)\n        cursor.setPosition(end_position, QTextCursor.KeepAnchor)\n        self.setTextCursor(cursor)\n\n        return True", "response": "Moves the document lines under cursor."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search(self, pattern, **kwargs):\n\n        settings = foundations.data_structures.Structure(**{\"case_sensitive\": False,\n                                                            \"whole_word\": False,\n                                                            \"regular_expressions\": False,\n                                                            \"backward_search\": False,\n                                                            \"wrap_around\": True})\n        settings.update(kwargs)\n\n        self.__search_pattern = pattern\n\n        if settings.regular_expressions:\n            pattern = QRegExp(pattern)\n            pattern.setCaseSensitivity(Qt.CaseSensitive if settings.case_sensitive else Qt.CaseInsensitive)\n\n        flags = QTextDocument.FindFlags()\n        if settings.case_sensitive:\n            flags = flags | QTextDocument.FindCaseSensitively\n        if settings.whole_word:\n            flags = flags | QTextDocument.FindWholeWords\n        if settings.backward_search:\n            flags = flags | QTextDocument.FindBackward\n\n        cursor = self.document().find(pattern, self.textCursor(), flags)\n        if not cursor.isNull():\n            self.setTextCursor(cursor)\n            return True\n        else:\n            if settings.wrap_around:\n                self.store_text_cursor_anchor()\n                cursor = self.textCursor()\n                if settings.backward_search:\n                    cursor.movePosition(QTextCursor.End, QTextCursor.MoveAnchor)\n                else:\n                    cursor.movePosition(QTextCursor.Start, QTextCursor.MoveAnchor)\n                self.setTextCursor(cursor)\n                settings.wrap_around = False\n                if self.search(pattern, **settings):\n                    return True\n                else:\n                    self.restore_text_cursor_anchor()", "response": "Searches given pattern text in the document."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef search_next(self):\n\n        pattern = self.get_selected_text() or self.__search_pattern\n        if not pattern:\n            return False\n\n        return self.search(pattern, **{\"case_sensitive\": True,\n                                       \"whole_word\": False,\n                                       \"regular_expressions\": False,\n                                       \"backward_search\": False,\n                                       \"wrap_around\": True})", "response": "Search the next search pattern in the document."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch the previous search pattern in the document.", "response": "def search_previous(self):\n        \"\"\"\n        Searchs the previous search pattern in the document.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        pattern = self.get_selected_text() or self.__search_pattern\n        if not pattern:\n            return False\n\n        return self.search(pattern, **{\"case_sensitive\": True,\n                                       \"whole_word\": False,\n                                       \"regular_expressions\": False,\n                                       \"backward_search\": True,\n                                       \"wrap_around\": True})"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreplacing current given pattern occurence in the document with replacement pattern.", "response": "def replace(self, pattern, replacement_pattern, **kwargs):\n        \"\"\"\n        Replaces current given pattern occurence in the document with the replacement pattern.\n\n        Usage::\n\n            >>> script_editor = Umbra.components_manager.get_interface(\"factory.script_editor\")\n            True\n            >>> codeEditor = script_editor.get_current_editor()\n            True\n            >>> codeEditor.replace(search_pattern, replacement_pattern, case_sensitive=True, whole_word=True, \\\nregular_expressions=True, backward_search=True, wrap_around=True)\n            True\n\n        :param pattern: Pattern to replace.\n        :type pattern: unicode\n        :param replacement_pattern: Replacement pattern.\n        :type replacement_pattern: unicode\n        :param \\*\\*kwargs: Format settings.\n        :type \\*\\*kwargs: dict\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        settings = foundations.data_structures.Structure(**{\"case_sensitive\": False,\n                                                            \"regular_expressions\": False})\n        settings.update(kwargs)\n\n        selected_text = self.get_selected_text()\n        regex = \"^{0}$\".format(\n            pattern if settings.regular_expressions else re.escape(foundations.strings.to_string(pattern)))\n        flags = int() if settings.case_sensitive else re.IGNORECASE\n        if not selected_text or not re.search(regex, selected_text, flags=flags):\n            self.search(pattern, **kwargs)\n            return False\n\n        cursor = self.textCursor()\n        metrics = self.get_selected_text_metrics()\n        if cursor.isNull():\n            return False\n\n        if not cursor.hasSelection():\n            return False\n\n        cursor.insertText(replacement_pattern)\n\n        self.patterns_replaced.emit([metrics])\n\n        self.search(pattern, **kwargs)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef replace_all(self, pattern, replacement_pattern, **kwargs):\n\n        edit_cursor = self.textCursor()\n\n        edit_cursor.movePosition(QTextCursor.Start, QTextCursor.MoveAnchor)\n        self.setTextCursor(edit_cursor)\n\n        patterns_replaced = []\n        while True:\n            if not self.search(pattern, **kwargs):\n                break\n\n            cursor = self.textCursor()\n            metrics = self.get_selected_text_metrics()\n            if cursor.isNull():\n                break\n\n            if not cursor.hasSelection():\n                break\n            cursor.insertText(replacement_pattern)\n            patterns_replaced.append(metrics)\n\n        self.patterns_replaced.emit(patterns_replaced)\n\n        return True", "response": "Replaces every given pattern occurrences in the document with the replacement pattern."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef go_to_line(self, line):\n\n        cursor = self.textCursor()\n        cursor.setPosition(self.document().findBlockByNumber(line - 1).position())\n        self.setTextCursor(cursor)\n        return True", "response": "Moves the text cursor to given line."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef go_to_column(self, column):\n\n        cursor = self.textCursor()\n        cursor.setPosition(cursor.block().position() + column)\n        self.setTextCursor(cursor)\n        return True", "response": "Moves the text cursor to the given column."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmove the text cursor to given position.", "response": "def go_to_position(self, position):\n        \"\"\"\n        Moves the text cursor to given position.\n\n        :param position: Position to go to.\n        :type position: int\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        cursor = self.textCursor()\n        cursor.setPosition(position)\n        self.setTextCursor(cursor)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef toggle_word_wrap(self):\n\n        self.setWordWrapMode(not self.wordWrapMode() and QTextOption.WordWrap or QTextOption.NoWrap)\n        return True", "response": "Toggles document word wrap."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntoggles document white spaces display.", "response": "def toggle_white_spaces(self):\n        \"\"\"\n        Toggles document white spaces display.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        text_option = self.get_default_text_option()\n        if text_option.flags().__int__():\n            text_option = QTextOption()\n            text_option.setTabStop(self.tabStopWidth())\n        else:\n            text_option.setFlags(\n                text_option.flags() | QTextOption.ShowTabsAndSpaces | QTextOption.ShowLineAndParagraphSeparators)\n        self.set_default_text_option(text_option)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_font_increment(self, value):\n\n        font = self.font()\n        point_size = font.pointSize() + value\n        if point_size < self.__minimum_font_point_size or point_size > self.__maximum_font_point_size:\n            return False\n\n        font.setPointSize(point_size)\n        self.setFont(font)\n        return True", "response": "Sets the font size increment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the language description from given language grammar file.", "response": "def get_language_description(grammar_file):\n    \"\"\"\n    Gets the language description from given language grammar file.\n\n    :param grammar_file: Language grammar.\n    :type grammar_file: unicode\n    :return: Language description.\n    :rtype: Language\n    \"\"\"\n\n    LOGGER.debug(\"> Processing '{0}' grammar file.\".format(grammar_file))\n\n    sections_file_parser = foundations.parsers.SectionsFileParser(grammar_file)\n    sections_file_parser.parse(strip_quotation_markers=False)\n\n    name = sections_file_parser.get_value(\"Name\", \"Language\")\n    if not name:\n        raise LanguageGrammarError(\"{0} | '{1}' attribute not found in '{2}' file!\".format(__name__,\n                                                                                           \"Language|Name\",\n                                                                                           grammar_file))\n\n    extensions = sections_file_parser.get_value(\"Extensions\", \"Language\")\n    if not extensions:\n        raise LanguageGrammarError(\"{0} | '{1}' attribute not found in '{2}' file!\".format(__name__,\n                                                                                           \"Language|Extensions\",\n                                                                                           grammar_file))\n\n    highlighter = get_object_from_language_accelerators(sections_file_parser.get_value(\"Highlighter\", \"Accelerators\"))\n    completer = get_object_from_language_accelerators(sections_file_parser.get_value(\"Completer\", \"Accelerators\"))\n    pre_input_accelerators = sections_file_parser.get_value(\"PreInputAccelerators\", \"Accelerators\")\n    pre_input_accelerators = pre_input_accelerators and [get_object_from_language_accelerators(accelerator)\n                                                         for accelerator in pre_input_accelerators.split(\"|\")] or ()\n    post_input_accelerators = sections_file_parser.get_value(\"PostInputAccelerators\", \"Accelerators\")\n    post_input_accelerators = post_input_accelerators and [get_object_from_language_accelerators(accelerator)\n                                                           for accelerator in post_input_accelerators.split(\"|\")] or ()\n\n    visual_accelerators = sections_file_parser.get_value(\"VisualAccelerators\", \"Accelerators\")\n    visual_accelerators = visual_accelerators and [get_object_from_language_accelerators(accelerator)\n                                                   for accelerator in visual_accelerators.split(\"|\")] or ()\n\n    indent_marker = sections_file_parser.section_exists(\"Syntax\") and sections_file_parser.get_value(\"IndentMarker\",\n                                                                                                     \"Syntax\") or \\\n                    DEFAULT_INDENT_MARKER\n    comment_marker = sections_file_parser.section_exists(\"Syntax\") and \\\n                     sections_file_parser.get_value(\"CommentMarker\", \"Syntax\") or \"\"\n    comment_block_marker_start = sections_file_parser.section_exists(\"Syntax\") and \\\n                                 sections_file_parser.get_value(\"CommentBlockMarkerStart\", \"Syntax\") or \"\"\n    comment_block_marker_end = sections_file_parser.section_exists(\"Syntax\") and \\\n                               sections_file_parser.get_value(\"CommentBlockMarkerEnd\", \"Syntax\") or \"\"\n    symbols_pairs = sections_file_parser.section_exists(\"Syntax\") and \\\n                    sections_file_parser.get_value(\"SymbolsPairs\", \"Syntax\") or {}\n\n    if symbols_pairs:\n        associated_pairs = foundations.data_structures.Lookup()\n        for pair in symbols_pairs.split(\"|\"):\n            associated_pairs[pair[0]] = pair[1]\n        symbols_pairs = associated_pairs\n\n    indentation_symbols = sections_file_parser.section_exists(\"Syntax\") and \\\n                          sections_file_parser.get_value(\"IndentationSymbols\", \"Syntax\")\n    indentation_symbols = indentation_symbols and indentation_symbols.split(\"|\") or ()\n\n    rules = []\n    attributes = sections_file_parser.sections.get(\"Rules\")\n    if attributes:\n        for attribute in sections_file_parser.sections[\"Rules\"]:\n            pattern = sections_file_parser.get_value(attribute, \"Rules\")\n            rules.append(umbra.ui.highlighters.Rule(name=foundations.namespace.remove_namespace(attribute),\n                                                    pattern=QRegExp(pattern)))\n\n    tokens = []\n    dictionary = sections_file_parser.get_value(\"Dictionary\", \"Accelerators\")\n    if dictionary:\n        dictionary_file = os.path.join(os.path.dirname(grammar_file), dictionary)\n        if foundations.common.path_exists(dictionary_file):\n            with open(dictionary_file, \"r\") as file:\n                for line in iter(file):\n                    line = line.strip()\n                    line and tokens.append(line)\n        else:\n            LOGGER.warning(\n                \"!> {0} | '{1}' language dictionary file doesn't exists and will be skipped!\".format(__name__,\n                                                                                                     dictionary_file))\n\n    theme = get_object_from_language_accelerators(sections_file_parser.get_value(\"Theme\", \"Accelerators\")) or \\\n            umbra.ui.highlighters.DEFAULT_THEME\n\n    attributes = {\"name\": name,\n                  \"file\": grammar_file,\n                  \"parser\": sections_file_parser,\n                  \"extensions\": extensions,\n                  \"highlighter\": highlighter,\n                  \"completer\": completer,\n                  \"pre_input_accelerators\": pre_input_accelerators,\n                  \"post_input_accelerators\": post_input_accelerators,\n                  \"visual_accelerators\": visual_accelerators,\n                  \"indent_marker\": indent_marker,\n                  \"comment_marker\": comment_marker,\n                  \"comment_block_marker_start\": comment_block_marker_start,\n                  \"comment_block_marker_end\": comment_block_marker_end,\n                  \"symbols_pairs\": symbols_pairs,\n                  \"indentation_symbols\": indentation_symbols,\n                  \"rules\": rules,\n                  \"tokens\": tokens,\n                  \"theme\": theme}\n\n    for attribute, value in sorted(attributes.iteritems()):\n        if attribute == \"rules\":\n            LOGGER.debug(\"> Registered '{0}' syntax rules.\".format(len(value)))\n        elif attribute == \"tokens\":\n            LOGGER.debug(\"> Registered '{0}' completion tokens.\".format(len(value)))\n        else:\n            LOGGER.debug(\"> Attribute: '{0}', Value: '{1}'.\".format(attribute, value))\n\n    return Language(**attributes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gblocks(self,\n                new_path = None,\n                seq_type = 'nucl' or 'prot'):\n        \"\"\"Apply the gblocks filtering algorithm to the alignment.\n        See http://molevol.cmima.csic.es/castresana/Gblocks/Gblocks_documentation.html\n        Need to rename all sequences, because it will complain with long names.\"\"\"\n        # Temporary path #\n        if new_path is None: final = self.__class__(new_temp_path())\n        else:                final = self.__class__(new_path)\n        # Mapping every sequence name with a random name #\n        orig_name_to_temp = {seq.description: 'name' + str(i) for i,seq in enumerate(self)}\n        temp_name_to_orig = {v: k for k, v in orig_name_to_temp.items()}\n        # Rename every sequence with a random name #\n        temp_fasta = self.rename_sequences(orig_name_to_temp)\n        # Options #\n        if seq_type == 'nucl': t_option = \"-t=d\"\n        if seq_type == 'prot': t_option = \"-t=p\"\n        # Run it #\n        result = sh.gblocks91(temp_fasta.path, t_option, '-p=n', \"-b4=3\", \"-b3=20\", \"-b5=a\", _ok_code=[0,1])\n        created_file = temp_fasta.path + '-gb'\n        assert os.path.exists(created_file)\n        # Check errors #\n        if \"Execution terminated\" in result.stdout: raise Exception(\"gblocks crashed again.\")\n        # Back #\n        temp_fasta.rename_sequences(temp_name_to_orig, final)\n        # Return #\n        return final", "response": "Apply the gblocks filtering algorithm to the alignment."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndispatch a tree build call.", "response": "def build_tree(self, *args, **kwargs):\n        \"\"\"Dispatch a tree build call. Note that you need at least four\n        taxa to express some evolutionary history on an unrooted tree.\"\"\"\n        # Check length #\n        assert len(self) > 3\n        # Default option #\n        algorithm = kwargs.pop(kwargs, None)\n        if algorithm is None: algorithm = 'raxml'\n        # Dispatch #\n        if algorithm is 'raxml':    return self.build_tree_raxml(*args, **kwargs)\n        if algorithm is 'fasttree': return self.build_tree_fast(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding a tree with RAxML.", "response": "def build_tree_raxml(self,\n                   new_path    = None,\n                   seq_type    = 'nucl' or 'prot',\n                   num_threads = None,\n                   free_cores  = 2,\n                   keep_dir    = False):\n        \"\"\"Make a tree with RAxML.\"\"\"\n        # Check output #\n        if new_path is None: new_path = self.prefix_path + '.tree'\n        # What model to choose #\n        if seq_type == 'nucl': model = \"GTRGAMMA\"\n        if seq_type == 'prot': model = \"PROTGAMMAJTTF\"\n        # Threads #\n        if num_threads is None: num_threads = multiprocessing.cpu_count() - free_cores\n        else:                   num_threads = int(num_threads) - free_cores\n        num_threads = max(1, num_threads)\n        # Run it #\n        temp_dir = new_temp_dir()\n        sh.raxml811('-m', model, \"-T\", num_threads, '-p', 1, '-s', self.path, '-n', 'tree', '-w', temp_dir, '-f', 'a', '-x', 1, '-N', 'autoMR')\n        # Move into place #\n        if keep_dir:\n            shutil.rmtree(new_path)\n            shutil.move(temp_dir, new_path)\n        if not keep_dir:\n            shutil.move(temp_dir + 'RAxML_bestTree.tree', new_path)\n        # Return #\n        return FilePath(new_path)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_tree_fast(self, new_path=None, seq_type='nucl' or 'prot'):\n        # Check output #\n        if new_path is None: new_path = self.prefix_path + '.tree'\n        # Command #\n        command_args = []\n        if seq_type == 'nucl': command_args += ['-nt']\n        command_args += ['-gamma']\n        command_args += ['-out', new_path]\n        command_args += [self.path]\n        # Run it #\n        sh.FastTree(*command_args)\n        # Return #\n        return FilePath(new_path)", "response": "Build a tree with FastTree."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run():\n    # set the LOCPATH to find locale files in the virtualenv instance or\n    # system /usr/share/locale location. needed by gettext\n    # for translation files.\n    os.environ['LOCPATH'] = os.path.join(sys.prefix, 'share', 'locale')\n    if os.environ.get('LANGUAGE') == 'C':\n        os.environ['LANGUAGE'] = 'en'\n    _ostype = nn.provider_check()\n    if not _ostype:\n        raise UnableToFindProviderException\n    import_str = 'netshow.%s.show' % _ostype\n    nn.import_module(import_str).run()", "response": "Executes run function from netshow plugin identified\n    from the provider check."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef i18n_app(providername):\n    install_location = pkg_resources.require('netshow-core-lib')[0].location\n    translation_loc = os.path.join(install_location, '..', '..', '..', 'share', 'locale')\n\n    _translate = gettext.translation(providername, translation_loc,\n                                     fallback=True)\n\n    return _translate.lgettext", "response": "returns a Example\n    that has cli output functions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef event_detail(self, event_detail):\n        if event_detail is not None:\n            if isinstance(event_detail, str):\n                self._event_detail = event_detail\n            else:\n                try:\n                    for key, val in event_detail.items():\n                        if isinstance(val, date):\n                            event_detail[key] = str(val)\n                    self._event_detail = json.dumps(event_detail)\n                except TypeError:\n                    raise TypeError('Passed in event detail object are not json serializable.Please check the format')", "response": "Set the event_detail property of the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the business date of the resource.", "response": "def business_date(self, business_date):\n        \"\"\"\n        Force the business_date to always be a date\n        :param business_date:\n        :return:\n        \"\"\"\n        if business_date is not None:\n            if isinstance(business_date, str):\n                self._business_date = parse(business_date).date()\n            else:\n                self._business_date= business_date"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the Widget ui.", "response": "def __initialize_ui(self):\n        \"\"\"\n        Initializes the Widget ui.\n        \"\"\"\n\n        self.setAttribute(Qt.WA_DeleteOnClose)\n        self.setWordWrapMode(QTextOption.NoWrap)\n\n        self.setAcceptDrops(True)\n\n        if platform.system() == \"Windows\" or platform.system() == \"Microsoft\":\n            fontFamily, fontSize = self.__default_fonts_settings[\"Windows\"]\n        elif platform.system() == \"Darwin\":\n            fontFamily, fontSize = self.__default_fonts_settings[\"Darwin\"]\n        elif platform.system() == \"Linux\":\n            fontFamily, fontSize = self.__default_fonts_settings[\"Linux\"]\n        font = QFont(fontFamily)\n        font.setPointSize(fontSize)\n        self.setFont(font)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __set_document_signals(self):\n\n        # Signals / Slots.\n        self.document().contentsChanged.connect(self.contents_changed.emit)\n        self.document().contentsChanged.connect(self.__document__contents_changed)\n        self.document().modificationChanged.connect(self.modification_changed.emit)\n        self.document().modificationChanged.connect(self.__document__modification_changed)", "response": "Connects the editor document signals."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_title(self, title=None):\n\n        if not title:\n            # TODO: https://bugreports.qt-project.org/browse/QTBUG-27084\n            # titleTemplate = self.is_modified() and \"{0} *\" or \"{0}\"\n            # title = titleTemplate.format(self.get_file_short_name())\n            title = self.get_file_short_name()\n\n        LOGGER.debug(\"> Setting editor title to '{0}'.\".format(title))\n        self.__title = title\n        self.setWindowTitle(title)\n\n        self.title_changed.emit()\n        return True", "response": "Sets the editor title."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_file(self, file=None, is_modified=False, is_untitled=False):\n\n        LOGGER.debug(\"> Setting '{0}' editor file.\".format(file))\n        self.__file = file\n        self.__is_untitled = is_untitled\n        self.set_modified(is_modified)\n        self.set_title()\n        return True", "response": "Sets the file to be used for the current editor."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an untitled editor file name.", "response": "def get_untitled_file_name(self):\n        \"\"\"\n        Returns an untitled editor file name.\n\n        :return: Untitled file name.\n        :rtype: unicode\n        \"\"\"\n\n        name = \"{0} {1}.{2}\".format(\n            self.__default_file_name, Editor._Editor__untitled_name_id, self.default_file_extension)\n        Editor._Editor__untitled_name_id += 1\n        LOGGER.debug(\"> Next untitled file name: '{0}'.\".format(name))\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_document(self, document, file=None, language=None):\n\n        document.setDocumentLayout(QPlainTextDocumentLayout(document))\n        self.setDocument(document)\n        self.set_file(file)\n        self.set_language(language)\n        self.__set_document_signals()\n\n        self.file_loaded.emit()\n        return True", "response": "Loads given document into the editor."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new editor file.", "response": "def new_file(self):\n        \"\"\"\n        Creates a new editor file.\n\n        :return: File name.\n        :rtype: unicode\n        \"\"\"\n\n        file = self.get_untitled_file_name()\n        LOGGER.debug(\"> Creating '{0}' file.\".format(file))\n        self.set_file(file, is_modified=False, is_untitled=True)\n        self.__set_document_signals()\n        return file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread and loads given file into the editor.", "response": "def load_file(self, file):\n        \"\"\"\n        Reads and loads given file into the editor.\n\n        :param File: File to load.\n        :type File: unicode\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if not foundations.common.path_exists(file):\n            raise foundations.exceptions.FileExistsError(\n                \"{0} | '{1}' file doesn't exists!\".format(self.__class__.__name__,\n                                                          file))\n\n        LOGGER.debug(\"> Loading '{0}' file.\".format(file))\n        reader = foundations.io.File(file)\n        self.setPlainText(reader.read())\n        self.set_file(file)\n        self.__set_document_signals()\n        self.file_loaded.emit()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reload_file(self, is_modified=True):\n\n        if not foundations.common.path_exists(self.__file):\n            raise foundations.exceptions.FileExistsError(\"{0} | '{1}' file doesn't exists!\".format(\n                self.__class__.__name__, self.__file))\n\n        LOGGER.debug(\"> Reloading '{0}' file.\".format(self.__file))\n        reader = foundations.io.File(self.__file)\n        if reader.cache():\n            self.set_content(reader.content)\n            self.set_file(self.__file, is_modified=is_modified)\n\n            self.file_reloaded.emit()\n            return True", "response": "Reloads the current editor file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving the editor file content.", "response": "def save_file(self):\n        \"\"\"\n        Saves the editor file content.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if not self.__is_untitled and foundations.common.path_exists(self.__file):\n            return self.write_file(self.__file)\n        else:\n            return self.save_fileAs()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_fileAs(self, file=None):\n\n        file = file or umbra.ui.common.store_last_browsed_path(\n            QFileDialog.getSaveFileName(self, \"Save As:\", self.__file))\n        if not file:\n            return False\n\n        return self.write_file(foundations.strings.to_string(file))", "response": "Saves the editor file content either using given file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite the editor file content into given file.", "response": "def write_file(self, file):\n        \"\"\"\n        Writes the editor file content into given file.\n\n        :param file: File to write.\n        :type file: unicode\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        LOGGER.debug(\"> Writing '{0}' file.\".format(file))\n        writer = foundations.io.File(file)\n        writer.content = [self.toPlainText().toUtf8()]\n        if writer.write():\n            self.set_file(file)\n\n            self.file_saved.emit()\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclosing the editor file.", "response": "def close_file(self):\n        \"\"\"\n        Closes the editor file.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if not self.is_modified():\n            LOGGER.debug(\"> Closing '{0}' file.\".format(self.__file))\n\n            self.file_closed.emit()\n            return True\n\n        choice = message_box.message_box(\"Warning\", \"Warning\",\n                                         \"'{0}' document has been modified!\\nWould you like to save your changes?\".format(\n                                             self.get_file_short_name()),\n                                         buttons=QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel)\n        if choice == QMessageBox.Save:\n            if self.save_file():\n                LOGGER.debug(\"> Closing '{0}' file.\".format(self.__file))\n                return True\n        elif choice == QMessageBox.Discard:\n            LOGGER.debug(\"> Discarding '{0}' file.\".format(self.__file))\n\n            self.file_closed.emit()\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef submit(script, workspace, **params):\n    from klab import cluster, process\n\n    # Make sure the rosetta symlink has been created.\n\n    if not os.path.exists(workspace.rosetta_dir):\n        raise pipeline.RosettaNotFound(workspace)\n\n    # Parse some job parameters for the keyword arguments.\n\n    params = dict((k, v) for k, v in params.items() if v is not None)\n    test_run = params.get('test_run', False)\n    nstruct = params.get('nstruct')\n    max_runtime = params.get('max_runtime', '6:00:00')\n    max_memory = params.get('max_memory', '1G')\n\n    if test_run:\n        nstruct = 1\n\n    if nstruct is None:\n        raise TypeError(\"submit() requires the keyword argument 'nstruct' for production runs.\")\n\n    # Use Jinja to render the XML script that will be passed to rosetta.\n\n    finalize_protocol(workspace, params)\n\n    # Submit the job and put it immediately into the hold state.\n\n    qsub_command = 'qsub', '-h', '-cwd',\n    qsub_command += '-o', workspace.log_dir,\n    qsub_command += '-j', 'y',\n    qsub_command += '-t', '1-{0}'.format(nstruct),\n    qsub_command += '-l', 'h_rt={0}'.format(max_runtime),\n    qsub_command += '-l', 'mem_free={0}'.format(max_memory),\n    qsub_command += pipeline.big_job_path(script),\n    qsub_command += workspace.focus_dir,\n\n    status = process.check_output(qsub_command)\n    status_pattern = re.compile(r'Your job-array (\\d+).[0-9:-]+ \\(\".*\"\\) has been submitted')\n    status_match = status_pattern.match(status)\n\n    if not status_match:\n        print status\n        sys.exit()\n\n    # Figure out the job id, then make a params file specifically for it.\n\n    job_id = status_match.group(1)\n\n    with open(workspace.job_info_path(job_id), 'w') as file:\n        json.dump(params, file)\n\n    # Release the hold on the job.\n\n    qrls_command = 'qrls', job_id\n    process.check_output(qrls_command)\n    print status,", "response": "Submit a job with the given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef initiate():\n    print_debug_header()\n\n    workspace = pipeline.workspace_from_dir(sys.argv[1])\n    workspace.cd_to_root()\n\n    job_info = read_job_info(workspace.job_info_path(os.environ['JOB_ID']))\n    job_info['job_id'] = int(os.environ['JOB_ID'])\n    job_info['task_id'] = int(os.environ['SGE_TASK_ID']) - 1\n\n    return workspace, job_info", "response": "Return some relevant information about the currently running job."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef auth_url(self, scope):\n        params = {\n            'response_type': 'code',\n            'client_id': self.__client_id,\n            'redirect_uri': self.__redirect_uri,\n            'scope': scope\n        }\n\n        if self.__state is not None:\n            params['state'] = self.__state\n\n        return settings.AUTH_ENDPOINT + '/authorize?' + urllib.urlencode(params)", "response": "Gets the url a user needs to give up a user token"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the auth token from a user s response", "response": "def get_user_token(self, scope, code=None):\n        \"\"\"Gets the auth token from a user's response\"\"\"\n\n        user_token = self.__get_user_token(scope)\n\n        if user_token:\n            return user_token\n\n        if self.__cache is not None:\n            token = self.__cache.get(self.__user_token_cache_key())\n            if token:\n                return token\n\n        if self.__redirect_uri is None or code is None:\n            raise MxitAPIParameterException()\n\n        self.__user_token = None\n\n        payload = {\n            'grant_type': 'authorization_code',\n            'code': code,\n            'redirect_uri': self.__redirect_uri\n        }\n\n        url = settings.AUTH_ENDPOINT + '/token'\n        r = post(url, data=payload, auth=HTTPBasicAuth(self.__client_id, self.__client_secret), verify=self.__verify_cert)\n        if r.status_code == 200:\n            data = r.json()\n            self.__set_user_token(scope, data[u'access_token'])\n            if self.__cache is not None:\n                self.__cache.set(self.__user_token_cache_key(scope), str(data[u'access_token']),\n                                 data[u'expires_in'] - 300)\n\n        user_token = self.__get_user_token(scope)\n\n        if not user_token:\n            raise MxitAPIException(\"Failed to retrieve user token for '%s' scope\" % scope)\n\n        return user_token"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the app auth token for a given scope", "response": "def get_app_token(self, scope):\n        \"\"\"Gets the app auth token\"\"\"\n\n        app_token = self.__get_app_token(scope)\n\n        if app_token:\n            return app_token\n\n        if self.__cache is not None:\n            token = self.__cache.get(self.__app_token_cache_key(scope))\n            if token:\n                return token\n\n        self.__app_token = None\n\n        payload = {\n            'grant_type': 'client_credentials',\n            'scope': scope\n        }\n\n        url = settings.AUTH_ENDPOINT + '/token'\n        r = post(url, data=payload, auth=HTTPBasicAuth(self.__client_id, self.__client_secret), verify=self.__verify_cert)\n        if r.status_code == 200:\n            data = r.json()\n            self.__set_app_token(scope, data[u'access_token'])\n            if self.__cache is not None:\n                self.__cache.set(self.__app_token_cache_key(scope), str(data[u'access_token']),\n                                 data[u'expires_in'] - 300)\n\n        app_token = self.__get_app_token(scope)\n\n        if not app_token:\n            raise MxitAPIException(\"Failed to retrieve app token for '%s' scope\" % scope)\n\n        return app_token"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nverifies a password against a passed hash", "response": "def verify(password, hash):\n    \"\"\"\n    Verify a password against a passed hash\n    \"\"\"\n    _, algorithm, cost, salt, password_hash = hash.split(\"$\")\n\n    password = pbkdf2.pbkdf2_hex(password, salt, int(cost) * 500)\n\n    return _safe_str_cmp(password, password_hash)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_local_dict(self):\n        try:\n            return getattr(THREAD_STORE, self.namespace)\n        except AttributeError:\n            local_var = dict(*self.args, **self.kwargs)\n            setattr(THREAD_STORE, self.namespace, local_var)\n            return local_var", "response": "Retrieve or initialize the thread - local data to use."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_validation_workspaces(name, rounds=None):\n    workspaces = []\n\n    if rounds is not None:\n        rounds = indices_from_str(rounds)\n    else:\n        rounds = itertools.count(1)\n\n    for round in rounds:\n        workspace = pipeline.ValidatedDesigns(name, round)\n        if not workspace.exists(): break\n        workspaces.append(workspace)\n\n    if not workspaces:\n        scripting.print_error_and_die('No validated designs found.')\n\n    return workspaces", "response": "Find all the workspaces containing validated designs."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the reasonable designs in a list of workspaces.", "response": "def find_reasonable_designs(workspaces, condition=None, verbose=False):\n    \"\"\"\n    Return a list of design where the representative model has a restraint\n    distance less that the given threshold.  The default threshold (1.2) is\n    fairly lenient.\n    \"\"\"\n    print \"Loading designs...\"\n\n    designs = []\n\n    if condition is None:\n        condition = 'restraint_dist < 1.2'\n\n    for workspace in workspaces:\n        for directory in workspace.output_subdirs:\n            if verbose:\n                print '  ' + directory\n\n            design = structures.Design(directory)\n            vars = design.structures.iloc[design.rep].to_dict()\n            if pd.eval(condition, local_dict=vars):\n                designs.append(design)\n\n    return designs"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates all the information it needs.", "response": "def calculate_quality_metrics(metrics, designs, verbose=False):\n    \"\"\"\n    Have each metric calculate all the information it needs.\n    \"\"\"\n    for metric in metrics:\n        if metric.progress_update:\n            print metric.progress_update\n        metric.load(designs, verbose)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreporting the quality metrics for the given designs.", "response": "def report_quality_metrics(designs, metrics, path, clustering=False):\n    \"\"\"\n    Create a nicely formatted spreadsheet showing all the designs and metrics.\n    \"\"\"\n    import xlsxwriter\n    print \"Reporting quality metrics...\"\n\n    # Open a XLSX worksheet.\n\n    workbook = xlsxwriter.Workbook(path)\n    worksheet = workbook.add_worksheet()\n\n    workbook.formats[0].border = 1\n    workbook.formats[0].border_color = 'gray'\n\n    # Setup the cell background color highlights.\n\n    from matplotlib.cm import ScalarMappable\n    from matplotlib.colors import LinearSegmentedColormap\n\n    best_color = np.array([93, 175, 219]) / 255    # UCSF Blue (70%)\n    worst_color = np.array([255, 255, 255]) / 255\n    color_table = {\n            'red':   [(0.0, worst_color[0], worst_color[0]),\n                      (1.0,  best_color[0],  best_color[0])],\n            'green': [(0.0, worst_color[1], worst_color[1]),\n                      (1.0,  best_color[1],  best_color[1])],\n            'blue':  [(0.0, worst_color[2], worst_color[2]),\n                      (1.0,  best_color[2],  best_color[2])],\n    }\n    color_map = LinearSegmentedColormap('highlight', color_table)\n\n    # Write the header row.\n    for col, metric in enumerate(metrics):\n        cell = xlsxwriter.utility.xl_col_to_name(col) + '1'\n        format = workbook.add_format(metric.header_format())\n        worksheet.write(cell, metric.title, format)\n        worksheet.set_column(col, col, metric.width)\n\n    # Write the data rows.\n\n    designs = designs[:]\n    designs.sort(key=lambda x: x.restraint_dist)\n    designs.sort(key=lambda x: x.sequence_cluster)\n\n    for col, metric in enumerate(metrics):\n        face_values = [metric.face_value(x) for x in designs]\n        score_values = np.array([metric.score_value(x) for x in designs])\n        cell_format = metric.cell_format()\n\n        if metric.color:\n            color_spectrum = ScalarMappable(cmap=color_map)\n            rgba = (255 * color_spectrum.to_rgba(score_values)).astype(int)\n            colors = ['#{:02x}{:02x}{:02x}'.format(*x) for x in rgba]\n\n        for index, face_value in enumerate(face_values):\n            if face_value is None:\n                continue\n            if metric.color:\n                cell_format.update({\n                    'bg_color': colors[index],\n                    'border_color': '#c7c7c7',\n                    'border': 1 })\n\n            format_handle = workbook.add_format(cell_format)\n            worksheet.write(index + 1, col, face_value, format_handle)\n\n    # Write the XLSX file.\n\n    workbook.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a PDF showing the score vs. RMSD funnels for all the reasonable designs.", "response": "def report_score_vs_rmsd_funnels(designs, path):\n    \"\"\"\n    Create a PDF showing the score vs. RMSD funnels for all the reasonable\n    designs.  This method was copied from an old version of this script, and\n    does not currently work.\n    \"\"\"\n    from matplotlib.backends.backend_pdf import PdfPages\n    import matplotlib.pyplot as plt\n\n    print \"Reporting score vs RMSD funnels...\"\n\n    pdf = PdfPages(path)\n    designs = sorted(designs, key=lambda x: x.fancy_path)\n\n    for index, design in enumerate(designs):\n        plt.figure(figsize=(8.5, 11))\n        plt.suptitle(design.fancy_path)\n\n        axes = plt.subplot(2, 1, 1)\n        plot_score_vs_dist(axes, design, metric=\"Max COOH Distance\")\n\n        axes = plt.subplot(2, 1, 2)\n        plot_score_vs_dist(axes, design, metric=\"Loop RMSD\")\n\n        pdf.savefig(orientation='portrait')\n        plt.close()\n\n    pdf.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating pymol sessions for each reasonable design representative.", "response": "def report_pymol_sessions(designs, directory):\n    \"\"\"\n    Create pymol session for each reasonable design representative.  This\n    method was copied from an old version of this script, and does not\n    currently work.\n    \"\"\"\n    print \"Reporting pymol sessions...\"\n\n    if os.path.exists(directory): shutil.rmtree(directory)\n    os.mkdir(directory)\n\n    with open('pymol_modes.txt') as file:\n        import yaml\n        base_config = yaml.load_cell(file)['Present design in pymol']\n\n    for design in designs:\n        decoy = design.representative\n        config = base_config + ' save ' + os.path.join(\n                directory, design.get_fancy_path('.pse')) + ';'\n\n        score_vs_distance.open_in_pymol(design, decoy, config, gui=False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef annotate_designs(designs, symbol='+'):\n    max_seq_cluster = 0\n    max_struct_cluster = 0\n\n    for design in designs:\n        max_seq_cluster = max(max_seq_cluster, design.sequence_cluster)\n        max_struct_cluster = max(max_struct_cluster, design.structure_cluster)\n\n    seq_digits = len(str(max_seq_cluster))\n    struct_digits = len(str(max_struct_cluster))\n\n    def update_header(pattern, str, header):\n        if re.search(pattern, header):\n            return re.sub(pattern, str, header)\n        else:\n            return header.rstrip() + ' ' + str\n\n    for design in designs:\n        seq_str = 'seq{:0{}}'.format(design.sequence_cluster, seq_digits)\n        struct_str = 'struct{:0{}}'.format(design.structure_cluster, struct_digits)\n\n        # Find any existing annotations.\n\n        annotation_path = os.path.join(design.directory, 'notes.txt')\n\n        try:\n            with open(annotation_path) as file:\n                annotation_lines = [x.strip() for x in file.readlines()]\n        except IOError:\n            annotation_lines = []\n\n        # If there are existing annotations and the first line starts with the \n        # symbol, assume that the line was previously inserted by this function\n        # and should now be updated with the most recent information:\n\n        if annotation_lines and annotation_lines[0].startswith(symbol):\n            header = annotation_lines[0]\n            header = update_header(r'seq\\d+', seq_str, header)\n            header = update_header(r'struct\\d+', struct_str, header)\n            annotation_lines[0] = header\n\n        # Otherwise, insert the annotation above the existing lines.\n\n        else:\n            header = '{} {} {}'.format(symbol, seq_str, struct_str)\n            annotation_lines.insert(0, header)\n\n        with open(annotation_path, 'w') as file:\n            file.write('\\n'.join(annotation_lines))", "response": "This function will annotate the sequence and structure cluster for all the possible designs identified by this script."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef queryset_to_dict(qs, key='pk', singular=True):\n    if singular:\n        result = {}\n        for u in qs:\n            result.setdefault(getattr(u, key), u)\n    else:\n        result = defaultdict(list)\n        for u in qs:\n            result[getattr(u, key)].append(u)\n    return result", "response": "Given a queryset will transform it into a dictionary based on key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef attach_foreignkey(objects, field, related=[], database=None):\n\n    if not objects:\n        return\n\n    if database is None:\n        database = list(objects)[0]._state.db\n\n    is_foreignkey = isinstance(field, SingleRelatedObjectDescriptor)\n\n    if not is_foreignkey:\n        field = field.field\n        accessor = '_%s_cache' % field.name\n        model = field.rel.to\n        lookup = 'pk'\n        column = field.column\n        key = lookup\n    else:\n        accessor = field.cache_name\n        field = field.related.field\n        model = field.model\n        lookup = field.name\n        column = 'pk'\n        key = field.column\n\n    objects = [o for o in objects if (related or getattr(o, accessor, False) is False)]\n\n    if not objects:\n        return\n\n    # Ensure values are unique, do not contain already present values, and are not missing\n    # values specified in select_related\n    values = distinct(filter(None, (getattr(o, column) for o in objects)))\n    if values:\n        qs = model.objects.filter(**{'%s__in' % lookup: values})\n        if database:\n            qs = qs.using(database)\n        if related:\n            qs = qs.select_related(*related)\n\n        queryset = queryset_to_dict(qs, key=key)\n    else:\n        queryset = {}\n\n    for o in objects:\n        setattr(o, accessor, queryset.get(getattr(o, column)))", "response": "This method is used to attach a foreign key to a list of objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get(self, url):\n        self.logger.info(f'Sending request: {RequestHandler.BASE_URL+url}')\n        req = requests.get(RequestHandler.BASE_URL+url, headers=self.headers)\n        self.logger.info(f'Request returned with status code {req.status_code}')\n\n        if req.status_code == requests.codes.ok:\n            return req\n\n        if req.status_code == requests.codes.bad:\n            raise APIErrorException('Invalid request. Check parameters.', req.status_code)\n\n        if req.status_code == requests.codes.forbidden:\n            raise APIErrorException('This resource is restricted', req.status_code)\n\n        if req.status_code == requests.codes.not_found:\n            raise APIErrorException('This resource does not exist. Check parameters', req.status_code)\n\n        if req.status_code == requests.codes.too_many_requests:\n            raise APIErrorException('You have exceeded your allowed requests per minute/day', req.status_code)", "response": "Handles api. football - data. org requests"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming various normalization functions on opts the provided namespace.", "response": "def normalize(opts):\n    \"\"\"\n    Performs various normalization functions on opts, the provided namespace. It\n    is assumed that opts has already been validated with\n    anchorhub.validation_opts.validate().\n\n    :param opts: a namespace containing options for AnchorHub\n    :return: a namespace with the attributes modified\n    \"\"\"\n    opts_dict = vars(opts)\n    add_is_dir(opts_dict)\n    ensure_directories_end_in_separator(opts_dict)\n    add_abs_path_directories(opts_dict)\n    add_open_close_wrappers(opts_dict)\n    add_wrapper_regex(opts_dict)\n    return Bunch(opts_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd the absolute path of the input and output directories to the opts_dict that will be modified by the user.", "response": "def add_abs_path_directories(opts_dict):\n    \"\"\"\n    Adds 'abs_input' and 'abs_output' to opts_dict\n\n    :param opts_dict: dictionary that will be modified\n    \"\"\"\n    assert_has_input_output(opts_dict)\n    opts_dict['abs_input'] = path.abspath(opts_dict['input'])\n    if opts_dict['is_dir']:\n        # Only add path separator to input if it is a directory\n        opts_dict['abs_input'] += get_path_separator()\n    opts_dict['abs_output'] = path.abspath(opts_dict['output']) + \\\n        get_path_separator()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nensure that the input and output directories are added in the path separator.", "response": "def ensure_directories_end_in_separator(opts_dict):\n    \"\"\"\n    Adds a path separator to the end of the input and output directories,\n    if they don't already have them.\n\n    :param opts_dict: dictionary that will be modified\n    \"\"\"\n    assert_has_input_output(opts_dict)\n    assert 'is_dir' in opts_dict\n    if opts_dict['is_dir']:\n        opts_dict['input'] = add_suffix(opts_dict['input'],\n                                        get_path_separator())\n    opts_dict['output'] = add_suffix(opts_dict['output'], get_path_separator())"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a regular expression for the specified wrapper to the dictionary that will be modified.", "response": "def add_wrapper_regex(opts_dict):\n    \"\"\"\n    Adds the regular expression for the specified wrapper to opts_dict. It\n    is assumed the dictionary has the keys 'open' and 'close'\n\n    The regular expression will match the following, in order:\n\n    1. The wrapper 'open' pattern\n    2. Followed by any amount of white space (or none)\n    3. Followed by a '#' character\n    4. Followed by one or more non-whitespace characters, but _not_ matching\n    the wrapper 'open' pattern, or the wrapper 'close' pattern\n    5. Followed by any amount of white space (or none)\n    6. Followed by the wrapper 'close' pattern\n\n    For example, it would match the following string, assuming the default\n    curly brace wrapper pattern:\n    '{ #tag }'\n\n    But it would _not_ match this:\n    '{{ #tag }}'\n    :param opts_dict: Dictionary that will be modified.\n    \"\"\"\n    opn = re.escape(opts_dict['open'])\n    close = re.escape(opts_dict['close'])\n\n    p = opn         # The opening pattern\n    p += r\"\\s*\"     # Any amount of white space\n    p += r\"#\"       # Hash '#' sign\n    # 1+ non-whitespace characters that don't make the open or close pattern\n    p += r\"((?!\" + opn + r\")(?!\" + close +\")\\S)+\"\n    p += r\"\\s*\"     # Any amount of white space\n    p += close      # The closing pattern\n\n    opts_dict['wrapper_regex'] = p"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of indexes of substr in string.", "response": "def get_substring_idxs(substr, string):\n    \"\"\"\n    Return a list of indexes of substr. If substr not found, list is\n    empty.\n\n    Arguments:\n        substr (str): Substring to match.\n        string (str): String to match in.\n\n    Returns:\n        list of int: Start indices of substr.\n    \"\"\"\n    return [match.start() for match in re.finditer(substr, string)]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef truncate(string, maxchar):\n    if maxchar < 4:\n        raise TruncateError(\"Maxchar must be > 3\")\n\n    if len(string) <= maxchar:\n        return string\n    else:\n        return string[:maxchar - 3] + \"...\"", "response": "Truncates a string to a maximum number of characters."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef diff(s1, s2):\n    return levenshtein(s1, s2) / max(len(s1), len(s2))", "response": "Return a normalised Levenshtein distance between two strings."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lock_up_period(self, lock_up_period):\n        try:\n            if isinstance(lock_up_period, (str, int)):\n                self._lock_up_period = int(lock_up_period)\n        except Exception:\n            raise ValueError('invalid input of lock up period %s, cannot be converted to an int' %\n                             lock_up_period)", "response": "This method is used to set the lockup period of the user s entry."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef investment_term(self, investment_term):\n        try:\n            if isinstance(investment_term, (str, int)):\n                self._investment_term = int(investment_term)\n        except Exception:\n            raise ValueError('invalid input of investment type %s, cannot be converted to an int' %\n                             investment_term)", "response": "This method is used to set the investment term."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef local_machine():\n    common_conf()\n    env.machine = 'local'\n    env.pg_admin_role = settings.LOCAL_PG_ADMIN_ROLE\n    env.db_backup_dir = settings.DJANGO_PROJECT_ROOT\n    env.media_backup_dir = settings.DJANGO_PROJECT_ROOT\n\n    # Not sure what this is good for. Not used in our fabfile.\n    # env.media_root = settings.DJANGO_MEDIA_ROOT\n    # env.local_db_password = settings.DJANGO_DB_PASSWORD\n\n    env.db_role = settings.DATABASES['default']['USER']\n    env.db_name = settings.DATABASES['default']['NAME']", "response": "Option to do something on local machine."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\noptions to do something on the development server.", "response": "def dev():\n    \"\"\"Option to do something on the development server.\"\"\"\n    common_conf()\n    env.user = settings.LOGIN_USER_DEV\n    env.machine = 'dev'\n    env.host_string = settings.HOST_DEV\n    env.hosts = [env.host_string, ]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stage():\n    common_conf()\n    env.user = settings.LOGIN_USER_STAGE\n    env.machine = 'stage'\n    env.host_string = settings.HOST_STAGE\n    env.hosts = [env.host_string, ]", "response": "Option to do something on the staging server."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\noption to do something on the production server.", "response": "def prod():\n    \"\"\"Option to do something on the production server.\"\"\"\n    common_conf()\n    env.user = settings.LOGIN_USER_PROD\n    env.machine = 'prod'\n    env.host_string = settings.HOST_PROD\n    env.hosts = [env.host_string, ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_dummy_scores(iteratable, score=0):\n    for seq in iteratable:\n        seq.letter_annotations[\"phred_quality\"] = (score,)*len(seq)\n        yield seq", "response": "Add zero scores to all sequences"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nschedules a job. `date` may be a datetime.datetime or a datetime.timedelta. The callable to be executed may be specified in two ways: - set `callable_name` to an identifier ('mypackage.myapp.some_function'). - specify an instance of a model as content_object and set `callable_name` to a method name ('do_job') The scheduler will not attempt to run the job if its expiration date has passed.", "response": "def schedule_job(date, callable_name, content_object=None, expires='7d',\n                 args=(), kwargs={}):\n    \"\"\"Schedule a job.\n\n    `date` may be a datetime.datetime or a datetime.timedelta.\n\n    The callable to be executed may be specified in two ways:\n     - set `callable_name` to an identifier ('mypackage.myapp.some_function').\n     - specify an instance of a model as content_object and set\n       `callable_name` to a method name ('do_job')\n\n    The scheduler will not attempt to run the job if its expiration date has\n    passed.\n\n    \"\"\"\n    # TODO: allow to pass in a real callable, but check that it's a global\n    assert callable_name and isinstance(callable_name, basestring), callable_name\n    if isinstance(date, basestring):\n        date = parse_timedelta(date)\n    if isinstance(date, datetime.timedelta):\n        date = datetime.datetime.now() + date\n    job = ScheduledJob(callable_name=callable_name, time_slot_start=date)\n    if expires:\n        if isinstance(expires, basestring):\n            expires = parse_timedelta(expires)\n        if isinstance(expires, datetime.timedelta):\n            expires = date + expires\n        job.time_slot_end = expires\n    if content_object:\n        job.content_object = content_object\n    job.args = args\n    job.kwargs = kwargs\n    job.save()\n    return job"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run_jobs(delete_completed=False, ignore_errors=False, now=None):\n    if ScheduledJob.objects.filter(status='running'):\n        raise ValueError('jobs in progress found; aborting')\n    if now is None:\n        now = datetime.datetime.now()\n\n    expire_jobs(now)\n    schedule_sticky_jobs()\n    start_scheduled_jobs(now, delete_completed, ignore_errors)", "response": "Run scheduled jobs.\n\n    You may specify a date to be treated as the current time."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main(argv=None):\n    # Get command line arguments, validate them, and normalize them\n    opts = cmdparse.parse_args(argv)\n    assert validate_opts.validate(opts)\n    opts = normalize_opts.normalize(opts)\n\n    if opts.verbose:\n        # Update client: print input and output directories\n        messages.print_input_output(opts)\n\n    file_paths = fileparse.get_file_list(opts)\n    assert validate_files.validate(file_paths, opts)\n\n    if opts.verbose and opts.is_dir:\n        # Update client: print files that will be parsed\n        messages.print_files(opts, file_paths)\n\n    # For now, only using default GitHub Markdown for parsing\n    # Collect tag/anchor combinations\n    collector = make_github_markdown_collector(opts)\n    anchors, duplicate_tags = collector.collect(file_paths)\n    assert validate_anchors.validate(anchors, duplicate_tags, opts)\n\n    # Write files using previously found AnchorHub tags and generated anchors\n    writer = make_github_markdown_writer(opts)\n    counter = writer.write(file_paths, anchors, opts)\n\n    if opts.verbose:\n        if opts.is_dir:\n            # Update client: print files that had modifications\n            messages.print_modified_files(opts, anchors)\n        # Print summary statistics\n        messages.print_summary_stats(counter)", "response": "Entry point for AnchorHub. Takes in command - line arguments finds files to parse within the input directory and outputs parsed files to the output directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of states that can result from processing this event", "response": "def can(self, event):\n        \"\"\"\n        returns a list of states that can result from processing this event\n        \"\"\"\n        return [t.new_state for t in self._transitions if t.event.equals(event)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_faulty(self, event):\n        for each in self._faults:\n            if each.name.upper() == event.name.upper():\n                return True\n        return False", "response": "returns a boolean if fault processing is handled for this event"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if the event is ignored.", "response": "def is_ignored(self, event):\n        \"\"\"\n        :param event:\n        :return: boolean\n        \"\"\"\n        for each in self._ignored:\n            if event.name == each:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing the current event and process the next state", "response": "def consume(self, event):\n        \"\"\"\n        process the current event, setup new state and teardown current state\n        \"\"\"\n        future_states = self.can(event)\n\n        new_state = future_states[0]\n        if len(future_states) > 1:\n            new_state = self.choose(event)\n        event.execute()\n        self.process(event)\n        new_state.setup(event, self)\n        self.teardown(event)\n        return new_state"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a valid transition to this state", "response": "def on(self, event, new_state):\n        \"\"\"\n        add a valid transition to this state\n        \"\"\"\n        if self.name == new_state.name:\n            raise RuntimeError(\"Use loop method to define {} -> {} -> {}\".format(self.name, event.name, new_state.name))\n        self._register_transition(event, new_state)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding the names of the events that are not acceptable but discarded to the set of ignored events.", "response": "def ignores(self, *args):\n        \"\"\"\n        :param args: Event objects\n        :returns: None\n        Any event that is ignored is acceptable but discarded\n        \"\"\"\n        for event in args:\n            self._ignored.add(event.name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd an event or list of events that produces a predefined error", "response": "def faulty(self, *args):\n        \"\"\"\n        add an event or list of events that produces a predefined error\n        an event is only added if its not already there\n        \"\"\"\n        for each in args:\n            if not self.is_faulty(each):\n                self._faults.add(each)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling failure and error processing for event", "response": "def handle_fault(self, event):\n        \"\"\"\n        handle failure/error processing for event\n        \"\"\"\n        msg = \"Faulty event '{}' with payload '{}' was received by state '{}'\".format(event.name, event.payload, self.name)\n        raise RuntimeError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nensures counter exists in Consul.", "response": "def _ensure_counter(self):\n        \"\"\"Ensure counter exists in Consul.\"\"\"\n        if self._counter_path not in self._client.kv:\n            self._client.kv[self._counter_path] = ''.zfill(self._COUNTER_FILL)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _ensure_queue(self):\n        if self._queue_path not in self._client.kv:\n            self._client.kv[self._queue_path] = None", "response": "Ensure queue exists in Consul."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a task from the queue.", "response": "def get(self):\n        \"\"\"Get a task from the queue.\"\"\"\n        tasks = self._get_avaliable_tasks()\n        if not tasks:\n            return None\n        name, data = tasks[0]\n        self._client.kv.delete(name)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nput a task into the queue.", "response": "def put(self, value, priority=100):\n        \"\"\"\n        Put a task into the queue.\n\n        Args:\n            value (str): Task data.\n            priority (int): An optional priority as an integer with at most 3 digits.\n                Lower values signify higher priority.\n        \"\"\"\n        task_name = '{}{:03d}_{}'.format(self.TASK_PREFIX, priority, self._counter)\n        path = posixpath.join(self._queue_path, task_name)\n        self._client.kv[path] = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget all tasks present in the queue.", "response": "def _get_avaliable_tasks(self):\n        \"\"\"Get all tasks present in the queue.\"\"\"\n        base_task = posixpath.join(self._queue_path, self.TASK_PREFIX)\n        tasks = self._client.kv.find(prefix=base_task)\n        return sorted(tasks.items())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _counter(self):\n        count = int(self._client.kv[self._counter_path])\n        count += 1\n        count_str = str(count).zfill(self._COUNTER_FILL)\n        self._client.kv[self._counter_path] = count_str\n        return count_str", "response": "Returns the current task counter."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning to parse beamline with MAD - 8 input format", "response": "def madParser(mad_filename, idbl=\"BL\"):\n    \"\"\"function to parse beamline with MAD-8 input format\n\n    :param mad_filename: lattice filename with mad-8 like format\n    :param idbl: beamline to be used that defined in lattice file, \n                 default value is ``BL``\n    :return: list of dict that contains magnetic elements\n    :rtype: list\n\n    :Example:\n\n    >>> import beamline\n    >>> beamlinelist = beamline.blparser.madParser('LPA.list', 'BL2')\n    >>> print(beamlinelist)\n    [{'type': 'drift', 'l': '0.1', 'ID': 'd0'},\n    {'type': 'quad', 'k1': '75', 'angle': '75', 'l': '0.1', 'ID': 'q1'},\n    {'type': 'drift', 'l': '0.18', 'ID': 'd3'},\n    {'type': 'quad', 'k1': '-75', 'angle': '75', 'l': '0.1', 'ID': 'q2'},\n    {'type': 'drift', 'l': '0.27', 'ID': 'd6'},\n    {'type': 'rbend', 'angle': '10', 'l': '0.1', 'ID': 'b1'},\n    {'type': 'drift', 'l': '1.0', 'ID': 'd8'},\n    {'type': 'rbend', 'angle': '-5', 'l': '0.1', 'ID': 'b2'},\n    {'type': 'drift', 'l': '0.45', 'ID': 'd4'},\n    {'type': 'quad', 'k1': '75', 'angle': '75', 'l': '0.1', 'ID': 'q1'}]\n\n    .. only:: builder_html\n\n    :download:`Download LPA.list <../../../lattice/LPA.list>` for reference.\n\n    \"\"\"\n\n    \"\"\" # linux way\n    cmd1 = \"/bin/grep -m1 -i line \" + mad_filename + \" | sed 's/.*(\\(.*\\)).*/\\\\1/'\"\n    try:\n        import subprocess\n        beamline = subprocess.check_output(cmd1,shell=True).strip()\n    except AttributeError:\n        import os\n        beamline = os.popen4(cmd1)[1].read().strip()\n    \"\"\"\n    idbl = idbl.lower()\n    for line in open(mad_filename, 'r'):\n        line = ''.join(line.lower().strip().split())\n        if line.startswith(idbl + ':line'):\n            beamline = line.replace(idbl + ':line=', '').replace('(', '').replace(')', '').split(',')\n            break\n\n    try:\n        fid = open(mad_filename, 'r')\n        elementlist = []\n        for element in beamline:\n            while True:\n                line = fid.readline().lower().strip()\n                if line.startswith(element + ':'):\n                    elementline = ''.join(line.split()).lower()\n                    break\n            if not line:\n                print(\"element: \" + element + \" not found.\")\n                exit()\n\n            fid.seek(0, 0)\n            idx1 = elementline.find(':')\n            idx2 = elementline.find(',')\n            elementtype = elementline[idx1 + 1:idx2]\n            ltmp1 = elementline[idx2 + 1:].replace('=', ' ').replace(',', ' ').split()\n            elementparams = dict(zip(ltmp1[0::2], ltmp1[1::2]))\n            elementparams[\"type\"] = elementtype\n            elementparams[\"ID\"] = element\n            elementlist.append(elementparams)\n        fid.close()\n    except UnboundLocalError:\n        print(\"beamline \" + idbl + \" not found\")\n        exit()\n\n    return elementlist"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of table names.", "response": "def tables(self):\n        \"\"\"\n        Returns a list of table names.\n\n        Example:\n\n            >>> db.tables\n            [\"bar\", \"foo\"]\n\n        Returns:\n\n            list of str: One string for each table name.\n        \"\"\"\n        select = (\"SELECT name FROM sqlite_master\",)\n        query = self.execute(*select)\n        result = query.fetchall()\n\n        # Filter first column from rows.\n        return [row[0] for row in result]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef schema(self):\n        def _info2columns(info):\n            return tuple((column[\"name\"], column[\"type\"]) for column in info)\n\n        def _table2tuple(table):\n            return (table, _info2columns(self.table_info(table)))\n\n        return [_table2tuple(table) for table in self.tables]", "response": "Returns the schema of all tables and returns the name and type of the columns."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn information about the named table.", "response": "def table_info(self, table):\n        \"\"\"\n        Returns information about the named table.\n\n        See: https://www.sqlite.org/pragma.html#pragma_table_info\n\n        Example:\n\n            >>> db.table_info(\"foo\")\n            [{\"name\": \"id\", \"type\": \"integer\", \"primary key\": True,\n              \"notnull\": False, \"default_value\": None}]\n\n        Arguments:\n\n            name (str): The name of the table to lookup.\n\n        Returns:\n\n            list of dicts: One dict per column. Each dict contains the\n              keys: \"name\", \"type\", \"primary key\", \"notnull\", and\n              \"default_value\".\n\n        Raises:\n\n            sql.OperationalError: If table does not exist.\n        \"\"\"\n        def _row2dict(row):\n            return {\n                \"name\": row[1],\n                \"type\": row[2].lower(),\n                \"notnull\": row[3] == 1,\n                \"default_value\": row[4],\n                \"primary_key\": row[5] == 1\n            }\n\n        if table not in self.tables:\n            raise sql.OperationalError(\"Cannot retrieve information about \"\n                                       \"missing table '{0}'\".format(table))\n\n        query = self.execute(\"PRAGMA table_info({table})\".format(table=table))\n        return [_row2dict(row) for row in query]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns whether a table or the entire database is empty.", "response": "def isempty(self, tables=None):\n        \"\"\"\n        Return whether a table or the entire database is empty.\n\n        A database is empty is if it has no tables. A table is empty\n        if it has no rows.\n\n        Arguments:\n\n            tables (sequence of str, optional): If provided, check\n              that the named tables are empty. If not provided, check\n              that all tables are empty.\n\n        Returns:\n\n            bool: True if tables are empty, else false.\n\n        Raises:\n\n            sql.OperationalError: If one or more of the tables do not\n              exist.\n        \"\"\"\n        tables = tables or self.tables\n\n        for table in tables:\n            if self.num_rows(table) > 0:\n                return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new table.", "response": "def create_table(self, name, schema):\n        \"\"\"\n        Create a new table.\n\n        If the table already exists, nothing happens.\n\n        Example:\n\n            >>> db.create_table(\"foo\", ((\"id\", \"integer primary key\"),\n                                        (\"value\", \"text\")))\n\n        Arguments:\n\n           name (str): The name of the table to create.\n           schema (sequence of tuples): A list of (name, type) tuples\n             representing each of the columns.\n        \"\"\"\n        columns = [\" \".join(column) for column in schema]\n        self.execute(\"CREATE TABLE IF NOT EXISTS {name} ({columns})\"\n                     .format(name=name, columns=\",\".join(columns)))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_table_from(self, name, src):\n        # Lookup the command which was used to create the \"src\" table.\n        query = self.execute(\"SELECT sql FROM sqlite_master WHERE \"\n                             \"type='table' and name=?\", (src,))\n        try:\n            cmd = query.fetchone()[0]\n        except TypeError:\n            raise sql.OperationalError(\"Cannot copy non-existent table '{0}'\"\n                                       .format(src))\n\n        # Modify the original command to replace the old table name\n        # with the new one.\n        new_cmd = re.sub(\"(CREATE TABLE) \\w+\", \"\\\\1 \" + name, cmd,\n                         re.IGNORECASE)\n\n        # Execute this new command.\n        self.execute(new_cmd)", "response": "Create a new table with same schema as the source."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a carbon copy of the source table to the target table.", "response": "def copy_table(self, src, dst):\n        \"\"\"\n        Create a carbon copy of the source table.\n\n        Arguments:\n\n            src (str): The name of the table to copy.\n            dst (str): The name of the target duplicate table.\n\n        Raises:\n\n            sql.OperationalError: If source table does not exist.\n        \"\"\"\n        # Create table.\n        self.create_table_from(dst, src)\n\n        # Copy contents of src to dst.\n        self.execute(\"INSERT INTO {dst} SELECT * FROM {src}\"\n                     .format(dst=dst, src=src))\n\n        # Commit changes.\n        self.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef export_csv(self, table, output=None, columns=\"*\", **kwargs):\n        import pandas.io.sql as panda\n\n        # Determine if we're writing to a file or returning a string.\n        isfile = output is not None\n        output = output or StringIO()\n\n        if table not in self.tables:\n            raise SchemaError(\"Cannot find table '{table}'\"\n                              .format(table=table))\n\n        # Don't print row indexes by default.\n        if \"index\" not in kwargs:\n            kwargs[\"index\"] = False\n\n        table = panda.read_sql(\"SELECT {columns} FROM {table}\"\n                               .format(columns=columns, table=table),\n                               self.connection)\n        table.to_csv(output, **kwargs)\n        return None if isfile else output.getvalue()", "response": "Export a table to a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef attr(**context):\n    #TODO(Jim Zhan) FIXME\n    def decorator(func):\n        def wrapped_func(*args, **kwargs):\n            for key, value in context.items():\n                print key, value\n            return func(*args, **kwargs)\n        return wraps(func)(decorator)\n    return decorator", "response": "Decorator that adds attributes into a single object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef timeit(func):\n    @wraps(func)\n    def wrapped_func(*args, **kwargs):\n        start  = timer()\n        result = func(*args, **kwargs)\n        cost   = timer() - start\n        logger.debug('<method: %s> finished in %2.2f sec' % (func.__name__, cost))\n        return result\n    return wrapped_func", "response": "Decorator that logs the cost time of a function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npicking frame info from current caller s frame.", "response": "def traceback(frame, parent=False):\n    \"\"\"Pick frame info from current caller's `frame`.\n\n    Args:\n        * frame: :type:`frame` instance, use :func:`inspect.currentframe`.\n        * parent: whether to get outer frame (caller) traceback info, :data:`False` by default.\n\n    Returns:\n        :class:`inspect.Trackback` instance from :data:`frame` or its parent frame.\n    \"\"\"\n    # Traceback(filename='<stdin>', lineno=1, function='<module>', code_context=None, index=None)\n    if parent is True:\n        # frame itself will always be placed @ the first index of its outerframes.\n        outers = inspect.getouterframes(frame)\n        traceback = (len(outers) == 1) and None or inspect.getframeinfo(outers[1][0])\n    else:\n        traceback = inspect.getframeinfo(frame)\n    return traceback"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef data(self, index, role=Qt.DisplayRole):\n\n        if role == Qt.DisplayRole:\n            node = self.get_node(index)\n            if node.family == \"Editor\":\n                data = self.__editor_node_format.format(node.name)\n            elif node.family == \"File\":\n                data = self.__file_node_format.format(node.name)\n            elif node.family == \"Directory\":\n                data = self.__directory_node_format.format(node.name)\n            elif node.family == \"Project\":\n                if node is self.sourceModel().default_project_node:\n                    data = self.__default_project_node_format.format(node.name)\n                else:\n                    data = self.__project_node_format.format(node.name)\n            else:\n                data = QVariant()\n            return data\n        else:\n            return QSortFilterProxyModel.data(self, index, role)", "response": "Reimplemented to return the data for the object at the given index"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the Node at given index.", "response": "def get_node(self, index):\n        \"\"\"\n        Returns the Node at given index.\n\n        :param index: Index.\n        :type index: QModelIndex\n        :return: Node.\n        :rtype: AbstractCompositeNode\n        \"\"\"\n\n        index = self.mapToSource(index)\n        if not index.isValid():\n            return self.sourceModel().root_node\n\n        return index.internalPointer() or self.sourceModel().root_node"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsorts words in a list of words.", "response": "def sort_words(vertex_source, edge_source, window=2, pagerank_config={'alpha': 0.85, }):\n    \"\"\"\u5c06\u5355\u8bcd\u6309\u5173\u952e\u7a0b\u5ea6\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\n\n    Keyword arguments:\n    vertex_source   --  \u4e8c\u7ef4\u5217\u8868\uff0c\u5b50\u5217\u8868\u4ee3\u8868\u53e5\u5b50\uff0c\u5b50\u5217\u8868\u7684\u5143\u7d20\u662f\u5355\u8bcd\uff0c\u8fd9\u4e9b\u5355\u8bcd\u7528\u6765\u6784\u9020pagerank\u4e2d\u7684\u8282\u70b9\n    edge_source     --  \u4e8c\u7ef4\u5217\u8868\uff0c\u5b50\u5217\u8868\u4ee3\u8868\u53e5\u5b50\uff0c\u5b50\u5217\u8868\u7684\u5143\u7d20\u662f\u5355\u8bcd\uff0c\u6839\u636e\u5355\u8bcd\u4f4d\u7f6e\u5173\u7cfb\u6784\u9020pagerank\u4e2d\u7684\u8fb9\n    window          --  \u4e00\u4e2a\u53e5\u5b50\u4e2d\u76f8\u90bb\u7684window\u4e2a\u5355\u8bcd\uff0c\u4e24\u4e24\u4e4b\u95f4\u8ba4\u4e3a\u6709\u8fb9\n    pagerank_config --  pagerank\u7684\u8bbe\u7f6e\n    \"\"\"\n    sorted_words = []\n    word_index = {}\n    index_word = {}\n    _vertex_source = vertex_source\n    _edge_source = edge_source\n    words_number = 0\n    for word_list in _vertex_source:\n        for word in word_list:\n            if not word in word_index:\n                word_index[word] = words_number\n                index_word[words_number] = word\n                words_number += 1\n\n    graph = np.zeros((words_number, words_number))\n\n    for word_list in _edge_source:\n        for w1, w2 in combine(word_list, window):\n            if w1 in word_index and w2 in word_index:\n                index1 = word_index[w1]\n                index2 = word_index[w2]\n                graph[index1][index2] = 1.0\n                graph[index2][index1] = 1.0\n\n    nx_graph = nx.from_numpy_matrix(graph)\n    scores = nx.pagerank(nx_graph, **pagerank_config)\n    sorted_scores = sorted(scores.items(), key=lambda item: item[1], reverse=True)\n    for index, score in sorted_scores:\n        item = AttrDict(word=index_word[index], weight=score)\n        sorted_words.append(item)\n\n    return sorted_words"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef extend_config(config, config_items):\n    for key, val in list(config_items.items()):\n        if hasattr(config, key):\n            setattr(config, key, val)\n\n    return config", "response": "Extend the config with the values in config_items."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend a multi - message to the peer.", "response": "def multiline_push(self, code, lines):\n        \"\"\"Send a multi-message to the peer (using the correct SMTP line\n        terminators (usually only called from the SMTPSession).\"\"\"\n        for line in lines[:-1]:\n            answer = '%s-%s' % (code, line)\n            self.push(answer)\n        self.push(code, lines[-1])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef push(self, code, msg=None):\n        if msg is None:\n            msg = str(code)\n        else:\n            msg = '%s %s' % (code, msg)\n\n        if not msg.endswith(self.LINE_TERMINATOR):\n            msg += self.LINE_TERMINATOR\n        self._channel.write(msg)", "response": "Send a message to the peer using the correct line terminators\n           ."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _remove_leading_dots_for_smtp_transparency_support(self, input_data):\n        regex = re.compile('^\\.\\.', re.MULTILINE)\n        data_without_transparency_dots = regex.sub('.', input_data)\n        return re.sub('\\r\\n', '\\n', data_without_transparency_dots)", "response": "Uses the input data to recover the original payload ( includes the leading dots for SMTP transparency support."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends some data to the client.", "response": "def write(self, data):\n        \"\"\"Sends some data to the client.\"\"\"\n        # I don't want to add a separate 'Client disconnected' logic for sending.\n        # Therefore I just ignore any writes after the first error - the server\n        # won't send that much data anyway. Afterwards the read will detect the\n        # broken connection and we quit.\n        if self._ignore_write_operations:\n            return\n        assert self.is_connected()\n        try:\n            self._connection.send(data.encode('ascii'))\n        except socket.error:\n            self.close()\n            self._ignore_write_operations = True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef realpath(path):\n    if path == '~':\n        return userdir\n\n    if path == '/':\n        return sysroot\n\n    if path.startswith('/'):\n        return os.path.abspath(path)\n\n    if path.startswith('~/'):\n        return os.path.expanduser(path)\n\n    if path.startswith('./'):\n        return os.path.abspath(os.path.join(os.path.curdir, path[2:]))\n\n    return os.path.abspath(path)", "response": "Create the real absolute path for the given path."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find(pattern, path=os.path.curdir, recursive=False):\n    root = realpath(path)\n\n    Finder = lambda item: regex.is_regex(pattern) \\\n                    and pattern.match(item) or (pattern == item)\n\n    if recursive:\n        for base, dirs, files in os.walk(root, topdown=True):\n            for segment in itertools.chain(filter(Finder, files), filter(Finder, dirs)):\n                yield FS(os.path.join(base, segment))\n\n    else:\n        for segment in filter(Finder, os.listdir(root)):\n            yield(os.path.join(root, segment))", "response": "Find absolute file paths with the given re pattern."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncopying the current item to the given dest path.", "response": "def copy(self, dest):\n        \"\"\"\n        Copy item to the given `dest` path.\n\n        Args:\n            * dest: destination path to copy.\n        \"\"\"\n        if os.path.isfile(self.path):\n            shutil.copy2(self.path, dest)\n        else:\n            shutil.copytree(self.path, dest, symlinks=False, ignore=None)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self):\n        if os.path.isfile(self.path):\n            if not os.path.exists(self.path):\n                with open(self.path, 'w') as fileobj:\n                    fileobj.write('')\n        else:\n            os.makedirs(self.path)", "response": "Create item under file system with its path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting the file or folder itself from file system.", "response": "def delete(self):\n        \"\"\"\n        Delete the file/folder itself from file system.\n        \"\"\"\n        if os.path.isfile(self.path):\n            os.remove(self.path)\n        else:\n            shutil.rmtree(self.path)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(self):\n        if not os.path.exists(self.path):\n            with open(self.path, 'w') as fileobj:\n                fileobj.write('')", "response": "Create a new item under file system with its path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _ancestry_line(self):\n        '''\n        Returns the ancestry of this dict, back to the first dict that we don't\n        recognize or that has more than one backer.\n        '''\n        b = self._get_backers()\n\n        while len(b) == 1:\n            yield b[0]\n            if not hasattr(b[0], '_get_backers'):\n                break\n            b = b[0]._get_backers()", "response": "Returns the ancestry of this dict back to the first dict that we don t recognize."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves environment vars and makes Python boolean replacements", "response": "def get(key, default=None):\n    \"\"\"Retrieves env vars and makes Python boolean replacements\"\"\"\n    val = os.environ.get(key, default)\n    \n    if val == 'True':\n        val = True\n    elif val == 'False':\n        val = False\n    return val"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read(env_file=\".env\"):\n    try:\n        with open(env_file) as f:\n            content = f.read()\n\n    except IOError:\n        content = ''\n\n    for line in content.splitlines():\n\n        m1 = re.match(r'\\A([A-Za-z_0-9]+)=(.*)\\Z', line)\n        if m1:\n            key, val = m1.group(1), m1.group(2)\n            m2 = re.match(r\"\\A'(.*)'\\Z\", val)\n            if m2:\n                val = m2.group(1)\n            m3 = re.match(r'\\A\"(.*)\"\\Z', val)\n            if m3:\n                val = re.sub(r'\\\\(.)', r'\\1', m3.group(1))\n            os.environ.setdefault(key, val)", "response": "Reads the environment variables from a. env file located in the project root and sets them as environment variables."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef record_date(self, value):\n        if value:\n            self._record_date = parse(value).date() if isinstance(value, type_check) else value", "response": "Set the record date."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef declared_date(self, value):\n        if value:\n            self._declared_date = parse(value).date() if isinstance(value, type_check) else value", "response": "Set the declared date of the corporate action."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nacquires the lock. A lock can be claimed if any of these conditions are true: 1. The lock is unheld by anyone. 2. The lock is held but the 'force' argument is set. 3. The lock is held by the current process. Arguments: replace_stale (bool, optional) If true, lock can be aquired from stale processes. A stale process is one which currently owns the parent lock, but no process with that PID is alive. force (bool, optional): If true, ignore any existing lock. If false, fail if lock already claimed. Returns: LockFile: self. Raises: UnableToAcquireLockError: If the lock is already claimed (not raised if force option is used).", "response": "def acquire(self, replace_stale=False, force=False):\n        \"\"\"\n        Acquire the lock.\n\n        A lock can be claimed if any of these conditions are true:\n            1. The lock is unheld by anyone.\n            2. The lock is held but the 'force' argument is set.\n            3. The lock is held by the current process.\n\n        Arguments:\n            replace_stale (bool, optional) If true, lock can be aquired from\n                stale processes. A stale process is one which currently owns\n                the parent lock, but no process with that PID is alive.\n            force (bool, optional): If true, ignore any existing\n              lock. If false, fail if lock already claimed.\n\n        Returns:\n            LockFile: self.\n\n        Raises:\n            UnableToAcquireLockError: If the lock is already claimed\n              (not raised if force option is used).\n        \"\"\"\n\n        def _create_lock():\n            LockFile.write(self.path, os.getpid(), time.time())\n\n        if self.islocked:\n            lock_owner_pid = self.pid\n\n            if self.owned_by_self:\n                pass  # don't replace existing lock\n            elif force:\n                _create_lock()\n            elif replace_stale and not system.isprocess(lock_owner_pid):\n                _create_lock()\n            else:\n                raise UnableToAcquireLockError(self)\n        else:  # new lock\n            _create_lock()\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef release(self, force=False):\n        # There's no lock, so do nothing.\n        if not self.islocked:\n            return\n\n        if self.owned_by_self or force:\n            os.remove(self.path)\n        else:\n            raise UnableToReleaseLockError(self)", "response": "Release lock.\n\n        To release a lock, we must already own the lock.\n\n        Arguments:\n            force (bool, optional): If true, ignore any existing lock owner.\n\n        Raises:\n            UnableToReleaseLockError: If the lock is claimed by another\n              process (not raised if force option is used)."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read(path):\n        if fs.exists(path):\n            with open(path) as infile:\n                components = infile.read().split()\n                pid = int(components[0])\n                date = datetime.date.fromtimestamp(float(components[1]))\n            return pid, date\n        else:\n            return None, None", "response": "Reads the contents of a LockFile."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting the contents of a LockFile.", "response": "def write(path, pid, timestamp):\n        \"\"\"\n        Write the contents of a LockFile.\n\n        Arguments:\n            path (str): Path to lockfile.\n            pid (int): The integer process ID.\n            timestamp (datetime): The time the lock was aquired.\n        \"\"\"\n        with open(path, \"w\") as lockfile:\n            print(pid, timestamp, file=lockfile)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef import_foreign(name, custom_name=None):\n    if lab.is_python3():\n        io.error((\"Ignoring attempt to import foreign module '{mod}' \"\n                  \"using python version {major}.{minor}\"\n                  .format(mod=name, major=sys.version_info[0],\n                          minor=sys.version_info[1])))\n        return\n\n    custom_name = custom_name or name\n\n    f, pathname, desc = imp.find_module(name, sys.path[1:])\n    module = imp.load_module(custom_name, f, pathname, desc)\n    f.close()\n\n    return module", "response": "Imports a module with a custom name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a new GreatCircle archive with the given parameters.", "response": "def calcul_distance(*args):\r\n    \"\"\"\r\n    ;+\r\n    ; CALCUL_DISTANCE : fonction permettant de calculer la distance entre deux points sur la sphere\r\n    ;\r\n    ; @Author : Mathilde FAILLOT (LEGOS/CTOH), 2005\r\n    ; @History :\r\n    ;    - 2005 : First release, source:<br />\r\n    ;             Weisstein, Eric W. \"Great Circle.\" From MathWorld--A Wolfram Web Resource. http://mathworld.wolfram.com/GreatCircle.html<br /> \r\n    ;    - 2008 : Renaud DUSSURGET, optimization + vectors + Mercurial<br />\r\n    ;    - Feb. 2009 : RD, debug on repeated positions removal<br />\r\n    ;    - March 2010 : RD, force coordinates to FLOATS if Floating-Point operand errors<br />\r\n    ;    - Nov. 2010 : 2 params option for calculating distance vector\r\n    ;    - Apr. 2012 : Converted to Python\r\n    ;-\r\n    \"\"\"\r\n#def calcul_distance(norepeat=False, *args):\r\n    \r\n    lon_a_in = args[1]\r\n    lat_a_in = args[0]\r\n    \r\n    if np.size(lon_a_in) != np.size(lat_a_in) : raise 'Error : arguments are not the same size'\r\n    \r\n    if len(args) == 2 :\r\n        lon_b_in = lon_a_in\r\n        lat_b_in = lat_a_in\r\n        lon_a_in = get_zero_element(lon_a_in)\r\n        lat_a_in = get_zero_element(lat_a_in)\r\n    elif len(args) == 4 :\r\n        lat_b_in = args[2]\r\n        lon_b_in = args[3]\r\n        if np.size(lon_b_in) != np.size(lat_b_in) : raise 'Error : arguments are not the same size'\r\n    else :\r\n        print \"ERROR\"\r\n        return -1\r\n\r\n    #   Define constants\r\n    \r\n    #Degree to radians conversion\r\n    #deg_rad = np.pi/360.0\r\n    \r\n    #Earth radius (km)\r\n    rt = 6378.137\r\n    \r\n    #;Remove repeated positions\r\n    #IF (KEYWORD_SET(NOREPEAT)) THEN id = WHERE(~((lon_b_in EQ lon_a_in[0]) * (lat_b_in EQ lat_a_in[0])),okCnt) ELSE okcnt = 1 \r\n    #IF (okCnt EQ 0) THEN RETURN lon_a_in, DOUBLE(0.)\r\n\r\n    #Degree to radians conversion\r\n    lon_a = np.deg2rad(lon_a_in)\r\n    lat_a = np.deg2rad(lat_a_in)\r\n    lon_b = np.deg2rad(lon_b_in)\r\n    lat_b = np.deg2rad(lat_b_in)\r\n\r\n\r\n    #;   calcul de la distance entre les deux points consideres\r\n#    interm = (np.cos(lon_b) * np.cos(lat_b)) * (np.cos(lon_a) * np.cos(lat_a)) + \\\r\n#      (np.sin(lon_a) * np.cos(lat_a)) * (np.sin(lon_b) * np.cos(lat_b)) + \\\r\n#      np.sin(lat_a) * np.sin(lat_b)\r\n    \r\n#    interm = (np.cos(lon_b) * np.cos(lat_b)) * (np.cos(lon_a) * np.cos(lat_a)) + \\\r\n#      (np.sin(lon_a) * np.cos(lat_a)) * (np.sin(lon_b) * np.cos(lat_b)) + \\\r\n#      np.sin(lat_a) * np.sin(lat_b)\r\n\r\n    interm = np.cos(lat_a) * np.cos(lat_b) * np.cos(lon_a - lon_b) + np.sin(lat_a) * np.sin(lat_b) #Wolfram Math World definition\r\n    \r\n    dist = rt * np.arccos(interm)\r\n    \r\n    #Remove computation errors\r\n    fgerr=(lon_b == lon_a) & (lat_b == lat_a)\r\n    if fgerr.sum() > 0 :\r\n        if np.size(dist) == 1 : dist = 0. \r\n        else : dist[fgerr] = 0.\r\n    \r\n    return dist"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cumulative_distance(lat, lon,dist_int=None):\r\n    '''\r\n    ;+\r\n    ; CUMULATIVE_DISTANCE : permet de calculer la distance le long d'une ligne.\r\n    ;\r\n    ; @Author : Renaud DUSSURGET, LEGOS/CTOH\r\n    ; @History :\r\n    ;    - Feb. 2009 : First release (adapted from calcul_distance)\r\n    ;-\r\n    '''\r\n\r\n    #   Define constants\r\n    \r\n    #Degree to radians conversion\r\n    #deg_rad = np.pi/360.0\r\n    \r\n    #Earth radius (km)\r\n    rt = 6378.137\r\n    \r\n    #;Remove repeated positions\r\n    #IF (KEYWORD_SET(NOREPEAT)) THEN id = WHERE(~((lon_b_in EQ lon_a_in[0]) * (lat_b_in EQ lat_a_in[0])),okCnt) ELSE okcnt = 1 \r\n    #IF (okCnt EQ 0) THEN RETURN lon_a_in, DOUBLE(0.)\r\n\r\n    nelts=lon.size\r\n\r\n    #Degree to radians conversion\r\n    lon_a = np.deg2rad(lon[0:nelts - 1])\r\n    lon_b = np.deg2rad(lon[1:nelts])\r\n    lat_a = np.deg2rad(lat[0:nelts - 1])\r\n    lat_b = np.deg2rad(lat[1:nelts])\r\n    \r\n    interm = np.cos(lat_a) * np.cos(lat_b) * np.cos(lon_a - lon_b) + np.sin(lat_a) * np.sin(lat_b) #Wolfram Math World definition\r\n    \r\n    dist_int=np.append(0,rt*np.arccos(interm))\r\n    \r\n    return dist_int.cumsum()", "response": "Returns the cumulative distance between two points."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef VincentyDistance(lon1_in,lat1_in,lon2_in,lat2_in,ELLIPSOID='GRS-80'):\r\n    lng1 = np.deg2rad(lon1_in)\r\n    lat1 = np.deg2rad(lat1_in)\r\n    lng2 = np.deg2rad(lon2_in)\r\n    lat2 = np.deg2rad(lat2_in)\r\n\r\n    major, minor, f = ELLIPSOIDS[ELLIPSOID]\r\n\r\n    delta_lng = lng2 - lng1\r\n\r\n    reduced_lat1 = np.arctan((1 - f) * np.tan(lat1))\r\n    reduced_lat2 = np.arctan((1 - f) * np.tan(lat2))\r\n\r\n    sin_reduced1, cos_reduced1 = np.sin(reduced_lat1), np.cos(reduced_lat1)\r\n    sin_reduced2, cos_reduced2 = np.sin(reduced_lat2), np.cos(reduced_lat2)\r\n\r\n    lambda_lng = delta_lng\r\n    lambda_prime = 2 * np.pi\r\n\r\n    iter_limit = 20\r\n\r\n    while abs(lambda_lng - lambda_prime) > 10e-12 and iter_limit > 0:\r\n        sin_lambda_lng, cos_lambda_lng = np.sin(lambda_lng), np.cos(lambda_lng)\r\n\r\n        sin_sigma = np.sqrt( (cos_reduced2 * sin_lambda_lng) ** 2 +\r\n                             (cos_reduced1 * sin_reduced2 -\r\n                              sin_reduced1 * cos_reduced2 * cos_lambda_lng) ** 2\r\n                            )\r\n\r\n        if sin_sigma == 0:\r\n            return 0 # Coincident points\r\n\r\n        cos_sigma = (\r\n            sin_reduced1 * sin_reduced2 +\r\n            cos_reduced1 * cos_reduced2 * cos_lambda_lng\r\n        )\r\n\r\n        sigma = np.arctan2(sin_sigma, cos_sigma)\r\n\r\n        sin_alpha = (\r\n            cos_reduced1 * cos_reduced2 * sin_lambda_lng / sin_sigma\r\n        )\r\n        cos_sq_alpha = 1 - sin_alpha ** 2\r\n\r\n        if cos_sq_alpha != 0:\r\n            cos2_sigma_m = cos_sigma - 2 * (\r\n                sin_reduced1 * sin_reduced2 / cos_sq_alpha\r\n            )\r\n        else:\r\n            cos2_sigma_m = 0.0 # Equatorial line\r\n\r\n        C = f / 16. * cos_sq_alpha * (4 + f * (4 - 3 * cos_sq_alpha))\r\n\r\n        lambda_prime = lambda_lng\r\n        lambda_lng = (\r\n            delta_lng + (1 - C) * f * sin_alpha * (\r\n                sigma + C * sin_sigma * (\r\n                    cos2_sigma_m + C * cos_sigma * (\r\n                        -1 + 2 * cos2_sigma_m ** 2\r\n                    )\r\n                )\r\n            )\r\n        )\r\n        iter_limit -= 1\r\n\r\n    if iter_limit == 0:\r\n        raise ValueError(\"Vincenty formula failed to converge!\")\r\n\r\n    u_sq = cos_sq_alpha * (major ** 2 - minor ** 2) / minor ** 2\r\n\r\n    A = 1 + u_sq / 16384. * (\r\n        4096 + u_sq * (-768 + u_sq * (320 - 175 * u_sq))\r\n    )\r\n\r\n    B = u_sq / 1024. * (256 + u_sq * (-128 + u_sq * (74 - 47 * u_sq)))\r\n\r\n    delta_sigma = (\r\n        B * sin_sigma * (\r\n            cos2_sigma_m + B / 4. * (\r\n                cos_sigma * (\r\n                    -1 + 2 * cos2_sigma_m ** 2\r\n                ) - B / 6. * cos2_sigma_m * (\r\n                    -3 + 4 * sin_sigma ** 2\r\n                ) * (\r\n                    -3 + 4 * cos2_sigma_m ** 2\r\n                )\r\n            )\r\n        )\r\n    )\r\n\r\n    s = minor * A * (sigma - delta_sigma)\r\n    return s", "response": "Calculates the geodesic distance between two points using the formula described in the ELLIPSOIDS dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nplotting the MRS - data on the specified axes.", "response": "def plot(xdata, ydata, plot_type='', plot_params={}, ax=None):\n    \"\"\"\n    Generic function for plotting any kind of MRS data. Uses matplotlib's pyplot for plotting\n    but automatically applies MRS-data specific formatting parameters. \n    \n    Parameters\n    ----------\n    xdata : array_like\n            Data to plot on x-axis\n    ydata : array_like\n            Data to plot on y-axis\n    plot_type : string-optional\n                Type of plot to generate. Determines some default plotting parameters, if they are specified.\n                Currently implemented: ['spectrum', 'fids']\n    plot_params : dictionary-optional\n                  Dictionary of parameters to use for generating the graph and formatting the axes. \n                  If plot_params = {}, default parameters are used.\n    ax : axis handle-optional\n                   If not empty, add the plot to this axis, instead of generating a new figure + axis\n                  \n    Returns\n    -------\n    fig_handle : figure handle\n                Handle of the figure the data was added to\n    line_handles : 2D line object handle(s)\n                    List of handles to each of the line objects added to the current axis\n    ax : axes handle\n                   Handle of the axes data was added to\n     \n    \"\"\"\n    import numpy as np\n    from cycler import cycler\n    import matplotlib.pyplot as plt\n   \n    \n    # Check on the shape of the input data\n    if ydata.shape[0] != xdata.shape[0] and ydata.shape[1] != xdata.shape[0]:\n        # Throw an error\n        pass\n    elif ydata.shape[0] != xdata.shape[0]:\n        # Transpose the data\n        ydata = ydata.T\n\n        \n    # Get the plot parameters. Start with defaults, and then update to include any \n    # changes passed in to the function\n    params = get_default_plot_params(plot_type)\n    params.update(plot_params)\n\n    if ax is None:\n        if params['suppress_fig']:\n            # Suppress drawing the figure\n            plt.ioff()\n        fig_handle=plt.figure(figsize=params['figsize'],facecolor='w')  \n        ax = fig_handle.add_subplot(1,1,1)\n\n    # Set the color order cycle that will be applied to any lines added to the current axis        \n    ax.set_prop_cycle(cycler('color',params['color_order']))\n    \n    if params['use_colormap'] and len(ydata.shape)>1:\n        # Override the color order using the specified color map\n        # Distribute colormap colors evenly spaced for all the lines in the plot\n    \n        # Get the colors from the selected colormap to use for color cycling\n        cmap = plt.get_cmap(params['colormap'])\n        co = [cmap(ii) for ii in np.linspace(0.0,0.9,ydata.shape[1])]  \n        ax.set_prop_cycle(cycler('color',co))\n    \n    #Add data to the axis    \n    ax.plot(xdata,ydata)  \n\n    # Apply the plot parameters\n    ax = apply_plot_params(params,ax)\n    \n    if params['overlay_average']:\n        # Check on the dimensions of the data\n        if len(ydata.shape)>1:\n            ydata_mean = np.average(ydata,axis=1)\n            ax.hold('on')\n            ax.plot(xdata, ydata_mean, linewidth=2, color=params['overlay_average_color'])\n\n        else:\n            print('Ignoring ''overlay_average'', ydata is 1D')\n    \n    plt.tight_layout()              \n    \n    if params['save_fig']:\n        # Save the figure to the specified location\n        plt.savefig(params['output_fig_path'],transparent=True)\n\n    # Turn plot interactivity back on in case it was turned off\n    plt.ion()\n    fig_handle = plt.gcf()\n    line_handles = ax.get_lines()\n    \n    if params['autoclose']:\n        # Close the figure containing the current axes\n        plt.close(ax.figure)\n        fig_handle = []\n        line_handles = []\n        ax = []\n            \n\n    return fig_handle, ax, line_handles"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef apply_plot_params(plot_params,ax):\n    \n    import matplotlib.pyplot as plt\n\n    if plot_params['xlim'] is not None: \n        ax.set_xlim(plot_params['xlim'])\n        \n        if plot_params['reverse_x'] and plot_params['xlim'][0] < plot_params['xlim'][1]:\n            ax.invert_xaxis()            \n            \n    elif plot_params['reverse_x']:\n        ax.invert_xaxis()\n    \n    if plot_params['ylim'] is not None: ax.set_ylim(plot_params['ylim'])\n        \n    ax.grid(plot_params['grid'])\n    ax.set_title(plot_params['title'],fontsize=plot_params['fontsize'],y=1.02)\n    ax.set_xlabel(plot_params['xlabel'],fontsize=plot_params['tick_fontsize'])\n    ax.set_ylabel(plot_params['ylabel'],fontsize=plot_params['tick_fontsize'])\n    ax.set_axis_bgcolor(plot_params['axis_bg_color'])\n    \n    # Apply some properties to the line(s)\n    line_handles = ax.get_lines()\n    plt.setp(line_handles, lw=plot_params['line_width'], ls=plot_params['line_style'],\n             marker=plot_params['marker'])\n    \n    if plot_params['line_color'] is not 'default':\n        plt.setp(line_handles,'color', plot_params['line_color'])\n\n    \n    # Autoscale data on the y-axis to reflect changes to the x-axis\n    if plot_params['autoscale_y']:\n        ax = autoscale_y(ax,margin=0.05)\n    \n    if plot_params['use_sci_format_yaxis']:\n        # Use scientific notation for the y-axis labels\n        ax.ticklabel_format(axis='y',style='sci',scilimits=(-2,2))\n    \n    if plot_params['use_sci_format_xaxis']:\n        # Use scientific notation for the x-axis labels\n        ax.ticklabel_format(axis='x',style='sci',scilimits=(-2,2))\n    \n    ax.tick_params(labelsize=plot_params['tick_fontsize'])\n        \n    return ax", "response": "Apply parameters to current axis."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_default_plot_params(plot_type=''):    \n    \n    default_plot_params = {\n    \n        'autoclose': False,  \n        'autoscale_y':True,\n        'axis_bg_color':'w',\n        'colormap':'summer',\n        'color_order': ['#0072b2','#d55e00', '#009e73', '#cc79a7', '#f0e442', '#56b4e9'], #Seaborn 'colorblind'\n        'figsize':(8,6), #Inches        \n        'fontsize':14,        \n        'grid':'on',\n        'interactive': True,\n        'line_color':'default',\n        'line_style':'-',\n        'line_width': 2.0,\n        'marker':None,\n        'output_fig_path':'test',\n        'output_fig_type':'png',\n        'overlay_average':False,\n        'overlay_average_color': '#424949',\n        'reverse_x': False,\n        'save_fig': False,    \n        'suppress_fig':False,\n        'tick_fontsize':12,\n        'title':'',\n        'use_colormap':False,\n        'use_sci_format_xaxis':False,\n        'use_sci_format_yaxis':True,\n        'xlabel':'',\n        'xlim':None,\n        'ylabel':'',\n        'ylim':None,        \n        \n        }\n        \n    # Some other good choices for color order!\n    # 'color_order': ['#4c72b0', '#55a868', '#c44e52', '#8172b2', '#ccb974', '#64b5cd'] #Based on a Seaborn 'deep' color palette\n    # 'color_order': ['#4878cf', '#6acc65', '#d65f5f', '#b47cc7', '#c4ad66', '#77bedb'] #Seaborn 'muted'\n    # 'color_order': ['#92c6ff', '#97f0aa', '#ff9f9a', '#d0bbff', '#fffea3', '#b0e0e6'] #Seaborn 'pastel'\n    \n    # Add more default plot-type specific parameters to the dictionary                  \n    if plot_type is 'spectrum': # Best for plotting 1-5 lines on the same axis\n        default_plot_params.update({'reverse_x':True})\n        \n    elif plot_type is 'fid': # Best for plotting 1-5 lines on the same axis\n        default_plot_params.update({'reverse_x':False})\n        \n    elif plot_type is 'spectra': # Best for plotting >5 lines on the same axis\n        default_plot_params.update({'reverse_x':True,'line_width':1.0,\n        'overlay_average':True})\n        \n    elif plot_type is 'fids': # Best for plotting >5 lines on the same axis\n        default_plot_params.update({'reverse_x':False,'line_width':1.0,\n        'overlay_average':True})\n        \n    else:\n        # Note: Here is a good spot to add customized plotting parameters for specific kinds of plots\n        pass\n            \n                       \n    return default_plot_params", "response": "Returns the default parameters for a single object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_user_profile(sender, instance, created, **kwargs):\n    if created:\n        profile = UserProfile.objects.get_or_create(user=instance)[0]\n        profile.hash_pass = create_htpasswd(instance.hash_pass)\n        profile.save()\n    else:\n        # update password\n        try:\n            up = UserProfile.objects.get(user=instance.id)\n            up.hash_pass = create_htpasswd(instance.hash_pass)\n            up.save()\n        except AttributeError:\n            pass", "response": "Create the UserProfile when a new User is saved"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate_range_values(request, label, kwargs):\n    value = kwargs.get(label, request.query.get(label))\n    if value:\n        kwargs[label] = int(value)\n        if kwargs[label] < 0 or kwargs[label] > MAX_PAGE_SIZE:\n            raise ValueError", "response": "Ensure value contained in label is a positive integer."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_pagination_headers(data, offset, limit, response, uripath,\n                             resource_name):\n    \"\"\"Add pagination headers to the bottle response.\n\n    See docs in :func:`paginated`.\n    \"\"\"\n    items = data.get('results') or data.get('data') or {}\n    count = len(items)\n    try:\n        total = int(data['collection-count'])\n    except (ValueError, TypeError, KeyError):\n        total = None\n    if total is None and offset == 0 and (limit is None or limit > len(items)):\n        total = count\n\n    # Set 'content-range' header\n    response.set_header(\n        'Content-Range',\n        \"%s %d-%d/%s\" % (resource_name, offset, offset + max(count - 1, 0),\n                         total if total is not None else '*')\n    )\n\n    partial = False\n    if offset:\n        partial = True  # Any offset automatically means we've skipped data\n    elif total is None and count == limit:\n        # Unknown total, but first page is full (so there may be more)\n        partial = True  # maybe more records in next page\n    elif total > count:\n        # Known total and not all records returned\n        partial = True\n\n    if partial:\n        uripath = uripath.strip('/')\n        response.status = 206  # Partial\n\n        # Add Next page link to http header\n        if total is None or (offset + limit) < total - 1:\n            nextfmt = (\n                '</%s?limit=%d&offset=%d>; rel=\"next\"; title=\"Next page\"')\n            response.add_header(\n                \"Link\", nextfmt % (uripath, limit, offset + limit)\n            )\n\n        # Add Previous page link to http header\n        if offset > 0 and (offset - limit) >= 0:\n            prevfmt = ('</%s?limit=%d&offset=%d>; rel=\"previous\"; '\n                       'title=\"Previous page\"')\n            response.add_header(\n                \"Link\", prevfmt % (uripath, limit, offset - limit)\n            )\n\n        # Add first page link to http header\n        if offset > 0:\n            firstfmt = '</%s?limit=%d>; rel=\"first\"; title=\"First page\"'\n            response.add_header(\n                \"Link\", firstfmt % (uripath, limit))\n\n        # Add last page link to http header\n        if (total is not None and  # can't calculate last page if unknown total\n                limit and  # if no limit, then any page is the last page!\n                limit < total):\n            lastfmt = '</%s?offset=%d>; rel=\"last\"; title=\"Last page\"'\n            if limit and total % limit:\n                last_offset = total - (total % limit)\n            else:\n                last_offset = total - limit\n            response.add_header(\n                \"Link\", lastfmt % (uripath, last_offset))", "response": "Add pagination headers to the bottle response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef process_params(request, standard_params=STANDARD_QUERY_PARAMS,\n                   filter_fields=None, defaults=None):\n    \"\"\"Parse query params.\n\n    Parses, validates, and converts query into a consistent format.\n\n    :keyword request: the bottle request\n    :keyword standard_params: query params that are present in most of our\n        (opinionated) APIs (ex. limit, offset, sort, q, and facets)\n    :keyword filter_fields: list of field names to allow filtering on\n    :keyword defaults: dict of params and their default values\n    :retuns: dict of query params with supplied values (string or list)\n    \"\"\"\n    if not filter_fields:\n        filter_fields = []\n    unfilterable = (set(request.query.keys()) - set(filter_fields) -\n                    set(standard_params))\n    if unfilterable:\n        bottle.abort(400,\n                     \"The following query params were invalid: %s. \"\n                     \"Try one (or more) of %s.\" %\n                     (\", \".join(unfilterable),\n                      \", \".join(filter_fields)))\n    query_fields = defaults or {}\n    for key in request.query:\n        if key in filter_fields:\n            # turns ?netloc=this.com&netloc=that.com,what.net into\n            # {'netloc': ['this.com', 'that.com', 'what.net']}\n            matches = request.query.getall(key)\n            matches = list(itertools.chain(*(k.split(',') for k in matches)))\n            if len(matches) > 1:\n                query_fields[key] = matches\n            else:\n                query_fields[key] = matches[0]\n    if 'sort' in request.query:\n        sort = request.query.getall('sort')\n        sort = list(itertools.chain(*(\n            comma_separated_strings(str(k)) for k in sort)))\n        query_fields['sort'] = sort\n    if 'q' in request.query:\n        search = request.query.getall('q')\n        search = list(itertools.chain(*(\n            comma_separated_strings(k) for k in search\n            if k)))\n        query_fields['q'] = search\n    return query_fields", "response": "Parses and converts query params into a consistent format."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nformatting error responses properly, return the response body. This function can be attached to the Bottle instance as the default_error_handler function. It is also used by the FormatExceptionMiddleware.", "response": "def httperror_handler(error):\n    \"\"\"Format error responses properly, return the response body.\n\n    This function can be attached to the Bottle instance as the\n    default_error_handler function. It is also used by the\n    FormatExceptionMiddleware.\n    \"\"\"\n    status_code = error.status_code or 500\n    output = {\n        'code': status_code,\n        'message': error.body or UNEXPECTED_ERROR,\n        'reason': bottle.HTTP_CODES.get(status_code) or None,\n    }\n    if bottle.DEBUG:\n        LOG.warning(\"Debug-mode server is returning traceback and error \"\n                    \"details in the response with a %s status.\",\n                    error.status_code)\n        if error.exception:\n            output['exception'] = repr(error.exception)\n        else:\n            if any(sys.exc_info()):\n                output['exception'] = repr(sys.exc_info()[1])\n            else:\n                output['exception'] = None\n\n        if error.traceback:\n            output['traceback'] = error.traceback\n        else:\n            if any(sys.exc_info()):\n                # Otherwise, format_exc() returns \"None\\n\"\n                # which is pretty silly.\n                output['traceback'] = traceback.format_exc()\n            else:\n                output['traceback'] = None\n\n    # overwrite previous body attr with json\n    if isinstance(output['message'], bytes):\n        output['message'] = output['message'].decode(\n            'utf-8', errors='replace')\n\n    # Default type and writer to json.\n    accept = bottle.request.get_header('accept') or 'application/json'\n    writer = functools.partial(\n        json.dumps, sort_keys=True, indent=4)\n    error.set_header('Content-Type', 'application/json')\n    if 'json' not in accept:\n        if 'yaml' in accept:\n            if not yaml:\n                LOG.warning(\"Yaml requested but pyyaml is not installed.\")\n            else:\n                error.set_header('Content-Type', 'application/x-yaml')\n                writer = functools.partial(\n                    yaml.safe_dump,\n                    default_flow_style=False,\n                    indent=4)\n            # html could be added here.\n\n    error.body = [writer(output).encode('utf8')]\n    return error.body"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends an email using the given template.", "response": "def send_email(template_name, context=None, *args, **kwargs):\n    \"\"\"\n    Send a templated email.\n\n    To generate the message used for the email, the method first\n    searches for an HTML template with the given name\n    (eg: <template>.html), and renders it with the provided context. The\n    process is repeated for the plain text message except a 'txt'\n    extension is used. All other options are forwarded to Django's\n    ``send_mail`` function.\n\n    Args:\n        template_name:\n            The name of the template to use without an extension. The\n            extensions ``html`` and ``txt`` are appended to the template\n            name and then rendered to provide the email content.\n        context:\n            A dictionary containing the context to render the message\n            with. Defaults to an empty dictionary.\n\n    Returns:\n        ``1`` if the email is succesfully sent and ``0`` otherwise. The\n        return values come from Django's ``send_mail`` function.\n\n    Throws:\n        NoTemplatesException:\n            If neither the HTML nor plain text template can be loaded.\n    \"\"\"\n    context = context or {}\n\n    try:\n        html = render_to_string(\n            context=context,\n            template_name='{}.html'.format(template_name),\n        )\n    except TemplateDoesNotExist:\n        html = ''\n\n    try:\n        text = render_to_string(\n            context=context,\n            template_name='{}.txt'.format(template_name),\n        )\n    except TemplateDoesNotExist:\n        text = ''\n\n    if not html and not text:\n        raise NoTemplatesException(template_name)\n\n    return mail.send_mail(\n        *args,\n        html_message=html,\n        message=text,\n        **kwargs\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the number of ptn for a given unit", "response": "def get_ptn(unit):\n    \"\"\"\u83b7\u53d6\u6587\u672c\u884c\u7684\u4e2d\u6587\u5b57\u7b26\u7684\u4e2a\u6570\n\n    Keyword arguments:\n    unit                    -- \u6587\u672c\u884c\n    Return:\n        ptn                 -- \u7eaf\u6587\u672c\u6570\n    \"\"\"\n    ptn = 0\n    match_re = re.findall(chinese, unit)\n    if match_re:\n        string = ''.join(match_re)\n        ptn = len(string)\n    return int(ptn)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_sn(unit):\n    sn = 0\n    match_re = re.findall(str(sentence_delimiters), unit)\n    if match_re:\n        string = ''.join(match_re)\n        sn = len(string)\n    return int(sn)", "response": "Get the number of words in a single word"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_nn(unit):\n    nn = 0\n    match_re = re.findall(number, unit)\n    if match_re:\n        string = ''.join(match_re)\n        nn = len(string)\n    return int(nn)", "response": "Returns the number of the given unit"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_spn(unit):\n    spn = 0\n    match_re = re.findall(no_chinese, unit)\n    if match_re:\n        string = ''.join(match_re)\n        spn = len(string)\n    return int(spn)", "response": "Returns the number of spn of a given unit"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_scn(unit):\n    scn = 0\n    list = cut_for_search(unit)\n    for x in list:\n        for y in chinese_character:\n            if x == y:\n                scn += len(y)\n    return int(scn)", "response": "Get the number of words in a single word"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform validation operations on opts and returns True if all tests are successful.", "response": "def _validate(opts):\n    \"\"\"\n    Perform validation operations on opts, a namespace created from\n    command-line arguments. Returns True if all validation tests are successful.\n\n    Runs validation() methods in validate_input.py, validate_extensions.py,\n    validate_overwrite.py, and validate_wrapper.py\n\n    Required attributes on opts:\n    * input: String giving the path to input files\n    * output: String giving the path to output destination\n    * wrapper: String specifying the wrapper format\n    * extensions: List of strings specifying the file extensions to look for\n    * overwrite: Boolean specifying whether the original input files should\n                 be overridden\n\n    :param opts: namespace containing necessary parameters\n    :raises ValidationException: if one or more of the tests are unsuccessful\n    :raises ValueError: if opts is not a namespace with the correct parameters\n    :return: True, if all tests are successful\n    \"\"\"\n    if all([vi.validate(opts),\n            ve.validate(opts),\n            vw.validate(opts),\n            vo.validate(opts)]):\n        return True\n    else:\n        raise ValidationException(\"Arguments did not pass validation. Check \"\n                                  \"your inputs.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the structures in the given directory and return a variety of score and distance metrics for the structures found in the given directory.", "response": "def load(pdb_dir, use_cache=True, job_report=None, require_io_dir=True):\n    \"\"\"\n    Return a variety of score and distance metrics for the structures found in\n    the given directory.  As much information as possible will be cached.  Note\n    that new information will only be calculated for file names that haven't\n    been seen before.  If a file changes or is deleted, the cache will not be\n    updated to reflect this and you may be presented with stale data.\n    \"\"\"\n\n    # Make sure the given directory seems to be a reasonable place to look for\n    # data, i.e. it exists and contains PDB files.\n\n    if not os.path.exists(pdb_dir):\n        raise IOError(\"'{}' does not exist\".format(pdb_dir))\n    if not os.path.isdir(pdb_dir):\n        raise IOError(\"'{}' is not a directory\".format(pdb_dir))\n    if not os.listdir(pdb_dir):\n        raise IOError(\"'{}' is empty\".format(pdb_dir))\n    if not glob.glob(os.path.join(pdb_dir, '*.pdb*')):\n        raise IOError(\"'{}' doesn't contain any PDB files\".format(pdb_dir))\n\n    # The given directory must also be a workspace, so that the restraint file\n    # can be found and used to calculate the \"restraint_dist\" metric later on.\n\n    try:\n        workspace = pipeline.workspace_from_dir(pdb_dir)\n    except pipeline.WorkspaceNotFound:\n        raise IOError(\"'{}' is not a workspace\".format(pdb_dir))\n    if require_io_dir and not any(\n            os.path.samefile(pdb_dir, x) for x in workspace.io_dirs):\n        raise IOError(\"'{}' is not an input or output directory\".format(pdb_dir))\n\n    # Find all the structures in the given directory, then decide which have\n    # already been cached and which haven't.\n\n    pdb_paths = glob.glob(os.path.join(pdb_dir, '*.pdb.gz'))\n    base_pdb_names = set(os.path.basename(x) for x in pdb_paths)\n    cache_path = os.path.join(pdb_dir, 'metrics.pkl')\n    metadata_path = os.path.join(pdb_dir, 'metrics.yml')\n\n    cached_records = []\n    uncached_paths = pdb_paths\n    metadata = {}\n\n    if use_cache:\n        try:\n            cached_records = pd.read_pickle(cache_path).to_dict('records')\n            cached_paths = set(x['path'] for x in cached_records)\n            uncached_paths = [\n                    pdb_path for pdb_path in pdb_paths\n                    if os.path.basename(pdb_path) not in cached_paths]\n\n            with codecs.open(metadata_path, encoding='utf8') as file:\n                metadata_list = [ScoreMetadata(**x) for x in yaml.safe_load(file)]\n                metadata = {x.name: x for x in metadata_list}\n\n        except:\n            cached_records = []\n            uncached_paths = pdb_paths\n            metadata = {}\n\n    # Calculate score and distance metrics for the uncached paths, then combine\n    # the cached and uncached data into a single data frame.\n\n    uncached_records, uncached_metadata = \\\n            read_and_calculate(workspace, uncached_paths)\n\n    all_records = pd.DataFrame(cached_records + uncached_records)\n    metadata.update(uncached_metadata)\n\n    # Make sure all the expected metrics were calculated.\n\n    expected_metrics = [\n            'total_score',\n            'restraint_dist',\n            'sequence',\n    ]\n    for metric in expected_metrics:\n        if metric not in all_records:\n            print all_records.keys()\n            raise IOError(\"'{}' wasn't calculated for the models in '{}'\".format(metric, pdb_dir))\n\n    # If everything else looks good, cache the data frame so we can load faster\n    # next time.\n\n    all_records.to_pickle(cache_path)\n    with codecs.open(metadata_path, 'w', encoding='utf8') as file:\n        yaml.safe_dump([v.to_dict() for k,v in metadata.items()], file)\n\n    # Report how many structures had to be cached, in case the caller is\n    # interested, and return to loaded data frame.\n\n    if job_report is not None:\n        job_report['new_records'] = len(uncached_records)\n        job_report['old_records'] = len(cached_records)\n\n    return all_records, metadata"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading the given PDB file and calculate the variety of score and distance metrics for each structure.", "response": "def read_and_calculate(workspace, pdb_paths):\n    \"\"\"\n    Calculate a variety of score and distance metrics for the given structures.\n    \"\"\"\n\n    # Parse the given restraints file.  The restraints definitions are used to\n    # calculate the \"restraint_dist\" metric, which reflects how well each\n    # structure achieves the desired geometry. Note that this is calculated\n    # whether or not restraints were used to create the structures in question.\n    # For example, the validation runs don't use restraints but the restraint\n    # distance is a very important metric for deciding which designs worked.\n\n    restraints = parse_restraints(workspace.restraints_path)\n\n    # Calculate score and distance metrics for each structure.\n\n    from klab.bio.basics import residue_type_3to1_map\n\n    records = []\n    metadata = {}\n    num_restraints = len(restraints) + 1\n    atom_xyzs = {}\n    fragment_size = 0\n\n    # It's kinda hard to tell which lines are part of the score table.  The \n    # first column has some pretty heterogeneous strings (examples below) and \n    # all the other columns are just numbers.  My strategy here is to try to \n    # make a regular expression that matches all of these examples, with the \n    # exception of the ligand.  I think the ligand will simply be too \n    # heterogeneous to match, and the purpose of this is to get dunbrack \n    # scores, which the ligand doesn't have.\n    #\n    #   MET:NtermProteinFull_1\n    #   ASN_2\n    #   LYS:protein_cutpoint_lower_39\n    #   ASP:protein_cutpoint_upper_40\n    #   ALA:CtermProteinFull_124\n    #   HIS_D_224\n    #   pdb_EQU_250\n\n    score_table_pattern = re.compile(\n            r'^[A-Z]{3}(?:_[A-Z])?'  # Residue name with optional tautomer.\n            r'(?::[A-Za-z_]+)?'      # Optional patch type.\n            r'_([0-9]+) '            # Residue number preceded by underscore.\n    )                                # The terminal space is important to match\n                                     # the full residue number.\n\n    for i, path in enumerate(sorted(pdb_paths)):\n        record = {'path': os.path.basename(path)}\n        sequence = \"\"\n        sequence_map = {}\n        last_residue_id = None\n        dunbrack_index = None\n        dunbrack_scores = {}\n\n        # Update the user on our progress, because this is often slow.\n\n        sys.stdout.write(\"\\rReading '{}' [{}/{}]\".format(\n            os.path.relpath(os.path.dirname(path)), i+1, len(pdb_paths)))\n        sys.stdout.flush()\n\n        # Read the PDB file, which we are assuming is gzipped.\n\n        try:\n            with gzip.open(path) as file:\n                lines = file.readlines()\n        except IOError:\n            print \"\\nFailed to read '{}'\".format(path)\n            continue\n\n        if not lines:\n            print \"\\n{} is empty\".format(path)\n            continue\n\n        # Get different information from different lines in the PDB file.  Some\n        # of these lines are specific to different simulations.\n\n        for line in lines:\n            line = line.decode('utf8')\n\n            score_table_match = \\\n                    dunbrack_index and score_table_pattern.match(line)\n\n            if line.startswith('pose'):\n                meta = ScoreMetadata(\n                        name='total_score',\n                        title='Total Score',\n                        unit='REU',\n                        order=1,\n                )\n                record['total_score'] = float(line.split()[1])\n                metadata[meta.name] = meta\n\n            elif line.startswith('label'):\n                fields = line.split()\n                dunbrack_index = fields.index('fa_dun')\n\n            elif score_table_match:\n                residue_id = int(score_table_match.group(1))\n                for restraint in restraints:\n                    if residue_id in restraint.residue_ids:\n                        dunbrack_score = float(line.split()[dunbrack_index])\n                        dunbrack_scores[residue_id] = dunbrack_score\n                        break\n\n            elif line.startswith('rmsd'):\n                meta = ScoreMetadata(\n                        name='loop_rmsd',\n                        title='Loop RMSD (Backbone Heavy-Atom)',\n                        unit='\u00c5',\n                        guide=1.0, lower=0.0, upper='95%', order=4,\n                )\n                record[meta.name] = float(line.split()[1])\n                metadata[meta.name] = meta\n\n            elif line.startswith('  all_heavy_atom_unsats'):\n                meta = ScoreMetadata(\n                        name='buried_unsats',\n                        title='Buried Unsatsified H-Bonds',\n                        order=5,\n                )\n                record[meta.name] = float(line.split()[2])\n                metadata[meta.name] = meta\n\n            elif line.startswith('  sc_heavy_atom_unsats'):\n                meta = ScoreMetadata(\n                        name='buried_unsats_sidechain',\n                        title='Buried Unsatisfied H-Bonds (Sidechain)',\n                        order=5,\n                )\n                record[meta.name] = float(line.split()[2])\n                metadata[meta.name] = meta\n\n            elif line.startswith('  bb_heavy_atom_unsats'):\n                meta = ScoreMetadata(\n                        name='buried_unsats_backbone',\n                        title='Buried Unsatisfied H-Bonds (Backbone)',\n                        order=5,\n                )\n                record[meta.name] = float(line.split()[2])\n                metadata[meta.name] = meta\n\n            elif line.startswith('time'):\n                meta = ScoreMetadata(\n                        name='simulation_time',\n                        title='Simulation Time',\n                        unit='sec',\n                        order=5,\n                )\n                record[meta.name] = float(line.split()[1])\n                metadata[meta.name] = meta\n\n            elif line.startswith('FragmentScoreFilter '):\n                fragment_size = line.split()[2].split('-')[0]\n\n            elif line.startswith('FSF') or line.startswith('FragmentScoreFilter_metric'):\n                splitline = line.split()\n                if splitline[1] == 'Max':\n                    max_res = 0\n                    max_crmsd = 0\n                    if splitline[3] == 'res:':\n                        max_res = splitline[3]\n                        meta = ScoreMetadata(\n                                name='max_fragment_crmsd_position',\n                                title = 'Max {}-Residue Fragment RMSD \\\n(C-Alpha) Position'.format(fragment_size),\n                                order=7)\n                    elif splitline[3] == 'score:':\n                        max_crmsd = splitline[3]\n                        meta = ScoreMetadata(\n                                name='max_fragment_crmsd_score',\n                                title = 'Max {}-Residue Fragment RMSD \\\n(C-Alpha)'.format(fragment_size),\n                                order=7)\n\n                elif splitline[1] == 'Min':\n                    min_res = 0\n                    min_crmsd = 0\n                    if splitline[3] == 'res:':\n                        min_res = splitline[3]\n                        meta = ScoreMetadata(\n                                name='min_fragment_crmsd_position',\n                                title = 'Min {}-Residue Fragment RMSD \\\n(C-Alpha) Position'.format(fragment_size),\n                                order=8)\n                    elif splitline[3] == 'score:':\n                        min_crmsd = splitline[3]\n                        meta = ScoreMetadata(\n                                name='min_fragment_crmsd_score',\n                                title = 'Min {}-Residue Fragment RMSD \\\n(C-Alpha)'.format(fragment_size),\n                                order=8)\n\n                elif splitline[1] == 'Avg':\n                    meta = ScoreMetadata(\n                            name='avg_fragment_crmsd',\n                            title='Avg {}-Residue Fragment RMSD \\\n(C-Alpha)'.format(fragment_size),\n                            order=9)\n                else:\n                    position = splitline[2]\n                    crmsd = splitline[4]\n                    meta = ScoreMetadata(\n                            name='fragment_crmsd_pos_{}'.format(position),\n                            title='{}-Residue Fragment RMSD at Res {} \\\n(C-Alpha)'.format(fragment_size,position),\n                            order=6)\n\n                record[meta.name] = float(splitline[4])\n                metadata[meta.name] = meta\n\n            elif line.startswith('EXTRA_SCORE'):\n                tokens = line[len('EXTRA_SCORE_'):].rsplit(None, 1)\n                meta = parse_extra_metric(tokens[0], 5)\n                record[meta.name] = float(tokens[1])\n                metadata[meta.name] = meta\n\n            elif line.startswith('EXTRA_METRIC'):\n                tokens = line[len('EXTRA_METRIC '):].rsplit(None, 1)\n\n                # Ignore the BuriedUnsat filter.  It just reports 911 every \n                # time, and we extract the actual buried unsat information from \n                # some other lines it adds to the PDB.\n                if tokens[0] == 'IGNORE':\n                    continue\n                if tokens[0] == 'Buried Unsatisfied H-Bonds [-|#]':\n                    continue\n\n                meta = parse_extra_metric(tokens[0], 5)\n                record[meta.name] = float(tokens[1])\n                metadata[meta.name] = meta\n\n            elif (line.startswith('ATOM') or line.startswith('HETATM')):\n                atom_name = line[12:16].strip()\n                residue_id = int(line[22:26].strip())\n                residue_name = line[17:20].strip()\n\n                # Keep track of this model's sequence.\n\n                if residue_id != last_residue_id:\n                    if line.startswith('ATOM'): \n                        one_letter_code = residue_type_3to1_map.get(residue_name, 'X')\n                        sequence += one_letter_code\n                        sequence_map[residue_id] = one_letter_code\n                        last_residue_id = residue_id\n                    elif line.startswith('HETATM'):\n                        sequence_map[residue_id] = 'X'\n                        last_residue_id = residue_id\n\n                # Save the coordinate for this atom.  This will be used later \n                # to calculate restraint distances.\n\n                atom_xyzs[atom_name, residue_id] = xyz_to_array((\n                        line[30:38], line[38:46], line[46:54]))\n\n        # Calculate how well each restraint was satisfied.\n\n        restraint_values = {}\n        restraint_values_by_residue = {}\n        is_sidechain_restraint = {}\n        restraint_units = {\n                'dist': '\u00c5',\n                'angle': '\u00b0',\n        }\n\n        for restraint in restraints:\n            d = restraint.distance_from_ideal(atom_xyzs)\n            metric = restraint.metric\n            backbone_atoms = set(['N', 'C', 'CA', 'O'])\n            backbone_restraint = backbone_atoms.issuperset(restraint.atom_names)\n\n            restraint_values.setdefault(metric, []).append(d)\n            restraint_values_by_residue.setdefault(metric, {})\n            for i in restraint.residue_ids:\n                restraint_values_by_residue[metric].setdefault(i, []).append(d)\n                is_sidechain_restraint[i] = (not backbone_restraint) \\\n                        or is_sidechain_restraint.get(i, False)\n\n        for metric, values in restraint_values.items():\n            meta = ScoreMetadata(\n                    name='restraint_{0}'.format(metric),\n                    title='Restraint Satisfaction',\n                    unit=restraint_units[metric],\n                    guide=1.0, lower=0.0, upper='95%', order=2,\n            )\n            record[meta.name] = np.max(values)\n            metadata[meta.name] = meta\n\n        for metric, values_by_residue in restraint_values_by_residue.items():\n            if len(values_by_residue) <= 1:\n                continue\n\n            for i in values_by_residue:\n                # I want to put the amino acid in these names, because I think \n                # it looks nice, but it causes problems for positions that can \n                # mutate.  So I assume that if a position has a sidechain \n                # restraint, it must not be allowed to mutate.\n                aa = sequence_map[i] if is_sidechain_restraint[i] else 'X'\n                res = '{0}{1}'.format(aa, i)\n                meta = ScoreMetadata(\n                        name='restraint_{0}_{1}'.format(metric, res.lower()),\n                        title='Restraint Satisfaction for {0}'.format(res),\n                        unit=restraint_units[metric],\n                        guide=1.0, lower=0.0, upper='95%', order=3,\n                )\n                record[meta.name] = np.max(values_by_residue[i])\n                metadata[meta.name] = meta\n\n        # Finish calculating some records that depend on the whole structure.\n\n        record['sequence'] = sequence\n        for i, score in dunbrack_scores.items():\n            aa = sequence_map[i] if is_sidechain_restraint[i] else 'X'\n            res = '{0}{1}'.format(aa, i)\n            meta = ScoreMetadata(\n                    name='dunbrack_score_{0}'.format(res.lower()),\n                    title='Dunbrack Score for {0}'.format(res),\n                    unit='REU',\n                    order=5,\n            )\n            record[meta.name] = score\n            metadata[meta.name] = meta\n\n        records.append(record)\n\n    if pdb_paths:\n        sys.stdout.write('\\n')\n\n    return records, metadata"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing an extra metric description into a ScoreMetadata object.", "response": "def parse_extra_metric(desc, default_order=None):\n    \"\"\"\n    Parse a filter name to get information about how to interpret and display \n    that filter.  For example, consider the following filter name:\n\n        \"Foldability Filter [+|guide 0.1]\"\n\n    Everything outside the brackets is the name of the filter.  This is \n    converted into a simpler name which can be referred to later on by making \n    everything lower case, dropping anything inside of parentheses, replacing \n    non-ASCII characters with ASCII ones (on a best-effort basis, some letters \n    may be dropped), and replacing spaces and dashes with underscores (expect \n    trailing spaces, which are removed).\n\n    Everything in the brackets provides metadata about the filter.  All \n    metadata is optional.  Different pieces of metadata are separated by \n    vertical bars, and do not have to be labeled.  If unlabeled, the metadata \n    are interpreted in the following order:\n\n    1. Direction (i.e. '+' or '-', are higher or lower values better?)\n    2. Unit (i.e. how to label the metric?)\n    3. Order (i.e. how to sort a list of filters?)\n    4. Guide (i.e. where should a dashed line be drawn in the GUI?)\n    5. Lower limit (i.e. the default lower limit in the GUI)\n    6. Upper limit (i.e. the default upper limit in the GUI)\n\n    If labeled, the data can appear in any order.  The labels corresponding to \n    the above arguments are abbreviated as follows: 'dir', 'unit', 'order', \n    'guide', 'lower', 'upper'.  No unlabeled metadata can appear after any \n    labeled metadata.\n    \"\"\"\n    meta = re.search(r'\\[\\[?(.*?)\\]\\]?', desc)\n\n    if not meta:\n        return ScoreMetadata(desc, order=default_order)\n\n    args = {}\n    if default_order is not None:\n        args['order'] = default_order\n\n    title = desc[:meta.start()] + desc[meta.end():]\n    tokens = meta.group(1).split('|')\n    default_keys = 'dir', 'unit', 'order', 'guide', 'min', 'max'\n    default_ok = True\n\n    for i, token in enumerate(tokens):\n        try:\n            key, value = token.strip().split(None, 1)\n            # Stop using the defaults once we've been given an explicit key.\n            default_ok = False\n        except ValueError:\n            if default_ok and i < len(default_keys):\n                key, value = default_keys[i], token\n            else:\n                raise IOError(\"Unknown key for '{0}' in filter '{1}'\".format(token, desc))\n\n        args[key] = value\n\n    return ScoreMetadata(title, **args)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef angle(array_of_xyzs):\n    ab = array_of_xyzs[0] - array_of_xyzs[1]\n    cb = array_of_xyzs[2] - array_of_xyzs[1]\n    return np.arccos((np.dot(ab,cb)) / (np.sqrt(ab[0]**2 + ab[1]**2  \\\n        + ab[2]**2) * np.sqrt(cb[0]**2 + cb[1]**2 + cb[2]**2)))", "response": "Calculates the angle between three coordinate points. Used for Angle constraints."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dihedral(array_of_xyzs):\n    p1 = array_of_xyzs[0]\n    p2 = array_of_xyzs[1]\n    p3 = array_of_xyzs[2]\n    p4 = array_of_xyzs[3]\n\n    vector1 = -1.0 * (p2 - p1)\n    vector2 = p3 - p2\n    vector3 = p4 - p3\n\n    # Normalize vector so as not to influence magnitude of vector\n    # rejections\n    vector2 /= np.linalg.norm(vector2)\n\n    # Vector rejections:\n    # v = projection of vector1 onto plane perpendicular to vector2\n    #   = vector1 - component that aligns with vector2\n    # w = projection of vector3 onto plane perpendicular to vector2\n    #   = vector3 = component that aligns with vector2\n    v = vector1 - np.dot(vector1, vector2) * vector2\n    w = vector3 - np.dot(vector3, vector2) * vector2\n\n    # Angle between v and w in a plane that is the torsion angle\n    # v and w not normalized explicitly, but we use tan so that doesn't\n    # matter\n    x = np.dot(v, w)\n    y = np.dot(np.cross(vector2, v), w)\n    principle_dihedral = np.arctan2(y,x)\n    # I'm leaving this variable explicit because it should be clear that\n    # we need to make sure there are no non-principle angles that better\n    # satisfy the constraint for some reason, but that needs to be done\n    # outside this function. \n    return principle_dihedral", "response": "Calculates the dihedral angle between four coordinate points. Used for dihedral constraints. \n    Calculates the principle dihedral angle between four coordinate points. Used for dihedral constraints."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a subset of the designs in the given workspace based on the conditions specified in the pick file.", "response": "def make_picks(workspace, pick_file=None, clear=False, use_cache=True, dry_run=False, keep_dups=False):\n    \"\"\"\n    Return a subset of the designs in the given data frame based on the \n    conditions specified in the given \"pick\" file.\n\n    An example pick file is show below::\n\n        threshold:\n        - restraint_dist < 1\n        - buried_unsatisfied_h_bonds < 1\n\n        pareto:\n        - total_score\n        - restraint_dist\n        - foldability\n\n        depth: 1\n        epsilon: 0.5%\n\n    Any designs not meeting the conditions set in the \"threshold\" section will \n    be discarded.  Any designs that are non-dominated with respect to the \n    metrics listed in the \"Pareto\" section will be kept.  The \"depth\" and \n    \"epsilon\" parameters provide a measure of control over how many designs \n    are included in the Pareto front.\n    \"\"\"\n    # Read the rules for making picks from the given file.\n\n    if pick_file is None:\n        pick_file = workspace.pick_file\n\n    if not os.path.exists(pick_file):\n        raise IOError(\"\"\"\\\nCould not find '{}'.\n\nEither specify a pick file on the command line, or create a file called \n`pick.yml` and put in a directory in your workspace that corresponds to the \nstep you want it to apply to.\"\"\")\n\n    import yaml\n    with open(pick_file) as file:\n        rules = yaml.load(file)\n\n    print \"Picking designs according to '{0}'.\".format(os.path.relpath(pick_file))\n    print\n\n    pareto = rules.get('pareto', [])\n    thresholds = rules.get('threshold', [])\n\n    known_keys = 'threshold', 'pareto', 'depth', 'epsilon'\n    unknown_keys = set(rules) - set(known_keys)\n\n    if unknown_keys:\n        not_understood = '\\n'.join('    ' + x for x in sorted(unknown_keys))\n        did_you_mean = '\\n'.join('    ' + x for x in known_keys)\n        raise IOError(\"\"\"\\\nThe following parameters in '{2}' are not understood:\n{0}\n\nDid you mean:\n{1}\\n\"\"\".format(not_understood, did_you_mean, os.path.relpath(pick_file)))\n\n    # Load all the metrics for the models we're picking from.\n\n    if clear:\n        workspace.clear_inputs()\n\n    predecessor = workspace.predecessor\n    metrics = []\n    metadata = {}\n\n    for input_dir in predecessor.output_subdirs:\n        submetrics, submetadata = load(\n                input_dir,\n                use_cache=use_cache,\n        )\n        submetrics['abspath'] = submetrics.apply(\n                lambda row: os.path.abspath(os.path.join(input_dir, row['path'])),\n                axis='columns',\n        )\n        metrics.append(submetrics)\n        metadata.update(submetadata)\n\n    metrics = pd.concat(metrics, ignore_index=True)\n\n    # Check to make sure we know about all the metrics we were given, and \n    # produce a helpful error if we find something unexpected (e.g. maybe a \n    # typo?).  This is a little complicated for the threshold queries, because \n    # running them is the only way to find out if they have any problems.\n\n    unknown_metrics = set(pareto) - set(metadata)\n\n    for query in thresholds:\n        try:\n            metrics.query(query)\n        except pd.core.computation.ops.UndefinedVariableError as err:\n            # Kinda gross, but we have to parse the error message to get the \n            # name of the metric causing the problem.\n            unknown_metric = re.search(\"'(.+)'\", str(err)).group(1)\n            unknown_metrics.add(unknown_metric)\n\n    if unknown_metrics:\n        not_understood = '\\n'.join('    ' + x for x in sorted(unknown_metrics))\n        did_you_mean = '\\n'.join('    ' + x for x in sorted(metadata))\n        raise IOError(\"\"\"\\\nThe following metrics are not understood:\n{0}\n\nDid you mean:\n{1}\\n\"\"\".format(not_understood, did_you_mean))\n\n    # Tell the user whether high or low values are favored for each metric \n    # included in the Pareto front, so they can confirm that we're doing the \n    # right thing.\n    \n    if pareto:\n        print \"\"\"\\\nPlease confirm whether high (+) or low (-) values should be preferred for each \nof the following metrics:\"\"\"\n\n        for metric in rules['pareto']:\n            print \"  ({dir}) {metric}\".format(\n                    metric=metric,\n                    dir=metadata[metric].direction)\n\n        print\n        print \"\"\"\\\nIf there's an error, it's probably because you didn't specify a direction in \nthe name of the filter, e.g. \"Foldability [+]\".  To avoid this problem in the \nfuture, add the appropriate direction (in square brackets) to the filter name \nin 'filters.xml'.  To fix the immediate problem, go into the directory \ncontaining your design PDBs, manually edit the file called 'metrics.yml', and \ncorrect the 'dir' field for any metrics necessary.\"\"\"\n        print\n\n    # Figure out how long the longest status message will be, so we can get our \n    # output to line up nicely.\n\n    class StatusBar:\n        update_line = \"  {0}:\"\n\n        def __init__(self):\n            self.w1 = 30\n\n        def init(self, df):\n            self.n = len(df)\n            self.w2 = len(str(self.n))\n            return \"{message:<{w1}} {n:>{w2}}\".format(\n                    message=\"Total number of designs\",\n                    n=self.n, w1=self.w1, w2=self.w2)\n\n        def update(self, df, status):\n            dn = len(df) - self.n\n            self.n = len(df)\n            return \"{message:<{w1}} {n:>{w2}} {dn:>{w3}}\".format(\n                    message=self.update_line.format(status),\n                    n=self.n, dn='(-{})'.format(abs(dn)),\n                    w1=self.w1, w2=self.w2, w3=self.w2+3)\n\n        def adjust_width(self, status):\n            self.w1 = max(self.w1, len(self.update_line.format(status)))\n\n\n\n    status = StatusBar()\n    for query in thresholds:\n        status.adjust_width(repr(query))\n\n    print status.init(metrics)\n\n    # Ignore any designs that are missing data.\n\n    metrics.dropna(inplace=True)\n    print status.update(metrics, \"minus missing data\")\n\n    # Keep only the lowest scoring model for each set of identical sequences.\n\n    if not keep_dups:\n        groups = metrics.groupby('sequence', group_keys=False)\n        metrics = groups.\\\n                apply(lambda df: df.ix[df.total_score.idxmin()]).\\\n                reset_index(drop=True)\n        print status.update(metrics, 'minus duplicate sequences')\n\n    # Remove designs that don't pass the given thresholds.\n\n    for query in thresholds:\n        metrics = metrics.query(query)\n        print status.update(metrics, repr(query))\n\n    # Remove designs that aren't in the Pareto front.\n\n    if pareto:\n        def progress(i, depth, j, front): #\n            sys.stdout.write('\\x1b[2K\\r  minus Pareto dominated:    calculating... [{}/{}] [{}/{}]'.format(i, depth, j, front))\n            if i == depth and j == front:\n                sys.stdout.write('\\x1b[2K\\r')\n            sys.stdout.flush()\n\n        metrics = find_pareto_front(\n                metrics, metadata, pareto,\n                depth=rules.get('depth', 1),\n                epsilon=rules.get('epsilon'),\n                progress=progress,\n        )\n        print status.update(metrics, 'minus Pareto dominated')\n\n    # Remove designs that have already been picked.\n\n    existing_inputs = set(\n            os.path.abspath(os.path.realpath(x))\n            for x in workspace.input_paths)\n    metrics = metrics.query('abspath not in @existing_inputs')\n    print status.update(metrics, 'minus current inputs')\n\n    # Symlink the picked designs into the input directory of the next round.\n\n    if not dry_run:\n        existing_ids = set(\n                int(x[0:-len('.pdb.gz')])\n                for x in os.listdir(workspace.input_dir)\n                if x.endswith('.pdb.gz'))\n        next_id = max(existing_ids) + 1 if existing_ids else 0\n\n        for id, picked_index in enumerate(metrics.index, next_id):\n            target = metrics.loc[picked_index]['abspath']\n            link_name = os.path.join(workspace.input_dir, '{0:04}.pdb.gz')\n            scripting.relative_symlink(target, link_name.format(id))\n\n    print\n    print \"Picked {} designs.\".format(len(metrics))\n\n    if dry_run:\n        print \"(Dry run: no symlinks created.)\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_pareto_front(metrics, metadata, columns, depth=1, epsilon=None, progress=None):\n\n    # Bail out if the data frame is empty, because otherwise the Pareto front \n    # calculation will choke on something.\n    if len(metrics) == 0:\n        return metrics\n\n    # https://github.com/matthewjwoodruff/pareto.py\n    import pareto\n\n    indices_from_cols = lambda xs: [metrics.columns.get_loc(x) for x in xs]\n    percentile = lambda x, q: metrics[x].quantile(q/100)\n    epsilons = [\n            (epsilon or 1e-7) * abs(percentile(x, 90) - percentile(x, 10)) / (90 - 10)\n            for x in columns\n    ]\n    maximize = [x for x in columns if metadata[x].direction == '+']\n    maximize_indices = indices_from_cols(maximize)\n    column_indices = indices_from_cols(columns)\n\n    def boxify(df): #\n        boxed_df = pd.DataFrame()\n        for col, eps in zip(columns, epsilons):\n            boxed_df[col] = np.floor(df[col] / eps)\n        return boxed_df\n\n    mask = np.zeros(len(metrics), dtype='bool')\n    too_close = np.zeros(len(metrics), dtype='bool')\n    all_boxes = boxify(metrics)\n    labeled_metrics = metrics.copy()\n    labeled_metrics['_pip_index'] = range(len(metrics))\n    id = labeled_metrics.columns.get_loc('_pip_index')\n\n    for i in range(depth):\n        # Figure out which points are within epsilon of points that are already \n        # in the front, so they can be excluded from the search.  Without this, \n        # points that are rejected for being too similar at one depth will be \n        # included in the next depth.\n        # \n        # This check is unfortunately very expensive, so we skip it for the \n        # default value of epsilon, which is so small (1e-7) that we assume no \n        # points will be rejected for being too similar.\n\n        if epsilon is None:\n            candidates = [labeled_metrics[~mask]]\n        else:\n            front_boxes = boxify(metrics[mask])\n            for j, (_, row) in enumerate(front_boxes.iterrows()):\n                if progress: progress(i+1, depth, j+1, len(front_boxes))\n                too_close |= all_boxes.apply(\n                        lambda x: (x == row).all(), axis='columns')\n\n            candidates = [labeled_metrics[too_close == False]]\n\n        front = pareto.eps_sort(\n                candidates, column_indices, epsilons, maximize=maximize_indices)\n\n        for row in front:\n            assert not mask[row[id]]\n            mask[row[id]] = True\n\n    return metrics[mask]", "response": "This function returns a subset of the given metrics that are Pareto optimal with respect to respectTo \n        to the given columns."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts us to mixed case notation", "response": "def case_us2mc(x):\n    \"\"\" underscore to mixed case notation \"\"\"\n    return re.sub(r'_([a-z])', lambda m: (m.group(1).upper()), x)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef listen_init(self):\n        self.dispatcher = ObjectDispatch(self)\n        self.factory = MsgPackProtocolFactory(self.dispatcher)\n        self.server = UnixServer(self.loop, self.factory, self.path)\n        self.server.start()", "response": "Setup the service to listen for clients."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self):\n        self.signal_init()\n        self.listen_init()\n        self.logger.info('starting')\n        self.loop.start()", "response": "Run the event loop."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef terminate(self, reason=None):\n        self.logger.info('terminating')\n        self.loop.unloop(pyev.EVUNLOOP_ALL)", "response": "Terminate the service with a reason."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef memorize(func):\n    @wraps(func)\n    def wrapped_func(*args, **kwargs):\n        if (len(args) > 0 and len(kwargs) > 0): \n            cacheKey = list(args)\n            cacheKey.append(kwargs)\n        elif (len(args) > 0): \n            cacheKey = args\n        else:\n            cacheKey = func.__name__\n            \n        global __cache__\n        result = __cache__.get(cacheKey)\n        if result is None:\n            result = func(*args, **kwargs)\n            __cache__[cacheKey] = result\n        return result\n\n    return wrapped_func", "response": "Decorator to memorize the calculated result."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef modify(self, current_modified_line, anchors, file_path, file_lines=None,\n               index=None):\n        \"\"\"\n        Removes the trailing AnchorHub tag from the end of the line being\n        examined.\n\n        :param current_modified_line: string representing the the line at\n            file_lines[index] _after_ any previous modifications from other\n            WriterStrategy objects\n        :param anchors: Dictionary mapping string file paths to inner\n            dictionaries. These inner dictionaries map string AnchorHub tags\n            to string generated anchors\n        :param file_path: string representing the file_path of the current\n            file being examined by this WriterStrategy\n        :param file_lines: List of strings corresponding to lines in a text file\n        :param index: index of file_lines corresponding to the current line\n        :return: string. A version of current_modified_line that has the\n            AnchorHub tag removed from the end of it\n        \"\"\"\n        open_wrapper_index = current_modified_line.rfind(self._open)\n        # '- 1' removes trailing space. May want to modify to completely\n        # strip whitespace at the end, instead of only working for a single\n        # space\n        return current_modified_line[:open_wrapper_index - 1] + \"\\n\"", "response": "This method is used to modify the current_modified_line of the current object with the AnchorHub tags at the end of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreplace all AnchorHub tag-using inline links in this line and edit them to use :param current_modified_line: string representing the the line at file_lines[index] _after_ any previous modifications from other WriterStrategy objects: :param anchors: Dictionary mapping string file paths to inner dictionaries. These inner dictionaries map string AnchorHub tags to string generated anchor :param file_path: string representing the file_path of the current file being examined by this WriterStrategy :param file_lines: List of strings corresponding to lines in a text file :param index: index of file_lines corresponding to the current line :return: string. current_modified_line with all inline links that use AnchorHub tags replaced with their associated generated anchors", "response": "def modify(self, current_modified_line, anchors, file_path, file_lines=None,\n               index=None):\n        \"\"\"\n        Replace all AnchorHub tag-using inline links in this line and edit\n        them to use\n\n        :param current_modified_line: string representing the the line at\n            file_lines[index] _after_ any previous modifications from other\n            WriterStrategy objects:\n        :param anchors: Dictionary mapping string file paths to inner\n            dictionaries. These inner dictionaries map string AnchorHub tags\n            to string generated anchor\n        :param file_path: string representing the file_path of the current\n            file being examined by this WriterStrategy\n        :param file_lines: List of strings corresponding to lines in a text file\n        :param index: index of file_lines corresponding to the current line\n        :return: string. current_modified_line with all inline links that use\n            AnchorHub tags replaced with their associated generated anchors\n        \"\"\"\n        changed_line = \"\"  # Will be built up piece by piece as we find links\n        links = self._get_link_indices(current_modified_line)\n\n        # Used to keep track of what we've parsed in current_modified_line\n        last_index = 0\n\n        for link in links:\n            # These indices are relative to current_modified_line\n            link_start_index = link[0]  # Start index in current_modified_line\n            link_end_index = link[1]  # End index in current_modified_line\n            link_text = current_modified_line[link_start_index:link_end_index]\n\n            # This index is relative to link_text\n            url_start = self._link_start_regex.search(link_text).end()\n            url_text = link_text[url_start:len(link_text) - 1].strip()\n\n            # This index is relative to url_text\n            hash_index = url_text.find('#')  # index of '#' in url_text\n\n            link_path = url_text[:hash_index]\n            tag = url_text[hash_index + 1:]\n\n            if link_path == \"\":\n                # Link points to tag in this file\n                file_key = file_path\n            else:\n                file_key = self._get_file_key(file_path, link_path)\n\n            if self._file_has_tag_anchor_keypair(anchors, file_key, tag):\n                # The tag used on this link was specified as an AnchorHub tag\n                # Add existing text up to (and including) the # mark\n                changed_line += current_modified_line[last_index:\n                                                      link_start_index +\n                                                      url_start + hash_index+1]\n                # Add the the generated anchor, plus a closing parenthesis\n                changed_line += anchors[file_key][tag] + ')'\n            else:\n                # The tag used is a normal anchor tag: don't change it\n                changed_line += current_modified_line[last_index:link_end_index]\n            last_index = link_end_index\n        # Add the end of the line back on\n        changed_line += current_modified_line[last_index:]\n        return changed_line"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_file_key(self, file_path, link_path):\n        if os.path.isabs(link_path):\n            return link_path\n        else:\n            file_dir = os.path.dirname(file_path)\n            joined_path = os.path.join(file_dir, link_path)\n            return os.path.abspath(joined_path)", "response": "Finds the absolute path of the link_path relative to file_path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a list of tuples containing start and end indices of inline tags links", "response": "def _get_link_indices(self, current_modified_line):\n        \"\"\"\n        Get a list of tuples containing start and end indices of inline\n        anchor links\n\n        :param current_modified_line: The line being examined for links\n        :return: A list containing tuples of the form (start, end),\n        the starting and ending indices of inline anchors links.\n        \"\"\"\n        # List of (start_index, end_index) tuples for each link in the line\n        links = []\n        for m in self._link_regex.finditer(current_modified_line):\n            links.append(m.span())\n        return links"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _file_has_tag_anchor_keypair(self, anchors, file_key, tag):\n        return file_key in anchors and tag in anchors[file_key]", "response": "Returns True if the file_key is in the anchors dictionary and tag is in the file associated with the file_key and tag."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of seas for a given date.", "response": "def date2seas( date, seas=['DJF','MAM','JJA','SON'], shift=1):\r\n    \"\"\"\r\n    #===============================================================================\r\n    # ;+\r\n    # ;\r\n    # ; CDO_date2seas : provides the equivalent CDO season to a julian date array\r\n    # ;\r\n    # ; @param date {in}{required}{type=NUMERIC} julian date (CNES days)\r\n    # ; @keyword seas {in}{optional}{type=STRING} seasons vector !! CAUTION !! This <br />\r\n    # ;   must be accompanied by the SHIFT variable\r\n    # ; @keyword shift {in}{optional}{type=NUMERIC} Backward in time offset of the \r\n    # ;   first element of SEAS vector in number of months from January <br />\r\n    # ;   (e.g. Decembre -> 1, Novembre -> 2, etc... )\r\n    # ; \r\n    # ;\r\n    # ;-\r\n    #===============================================================================\r\n    \"\"\"\r\n        \r\n\r\n    corr_months=np.roll(np.arange(12).reshape((4,3))+1,shift)\r\n    \r\n    nt = len(date)\r\n    outvec=(cnes_convert(date))[1]\r\n    month=np.array([d.month for d in outvec])\r\n    outseas_ind=-np.ones(nt)\r\n#    outseas=np.repeat('   ',nt)\r\n    \r\n    for i,m in enumerate(month) : outseas_ind[i] = int(np.where(m == corr_months)[0])\r\n    outseas =[seas[int(i)] for i in outseas_ind]\r\n    \r\n    return outseas, outseas_ind"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cnes2modis(cnes_date,YYYYDDDHHMM=None,YYYYDDD=True):\r\n\r\n    #Setup defaults\r\n    if YYYYDDDHHMM is None : YYYYDDDHHMM = False\r\n    if YYYYDDD : YYYYDDDHHMM = False\r\n    if YYYYDDDHHMM : YYYYDDD = False\r\n\r\n    str,obj=cnes_convert(cnes_date)\r\n    dat=[o.strftime(\"%Y%j%H%M\") for o in obj]\r\n    \r\n    return dat", "response": "Convert CNES julian days to MODIS data format"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a string that represents the CNES date in the given MODIS date format.", "response": "def modis2cnes(modis_date):\r\n    \"\"\"\r\n    #+\r\n    # MODIS2CNES : Convert MODIS date format to CNES JULIAN DAYS (YYYYDDD or YYYYDDDHHMM)\r\n    # \r\n    # @author: Renaud DUSSURGET (LER PAC/IFREMER)\r\n    # @history: Created by RD on 29/10/2012\r\n    #\r\n    #-\r\n    \"\"\"\r\n\r\n    if not isinstance(modis_date,list) : modis_date=[modis_date]\r\n\r\n    if len(modis_date[0]) ==  7 :\r\n        obj=[datetime.datetime.strptime(d,\"%Y%j\") for d in modis_date] \r\n    else :\r\n        obj=[datetime.datetime.strptime(d,\"%Y%j%H%M\") for d in modis_date]\r\n    \r\n#    str,obj=cnes_convert(modis_date)\r\n    dat=[o.strftime(\"%d/%m/%Y-%H:%M\") for o in obj]\r\n    \r\n    return cnes_convert(dat)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef coerce_one(schema=str):\n    def validate(val):\n        \"\"\"Unpack a single item from the inputs sequence and run validation.\n\n        NOTE(larsbutler): This code is highly opinionated for bottle, since\n        bottle query params are wrapped in a list, even if there is just a\n        single value for a given parameter.\n        \"\"\"\n        [value] = val\n        return volup.Coerce(schema)(value)\n    return validate", "response": "Expects the input sequence to contain a single value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef coerce_many(schema=str):\n    def validate(val):\n        \"\"\"Apply schema check/version to each item.\"\"\"\n        return [volup.Coerce(schema)(x) for x in val]\n    return validate", "response": "Expects the input to be a sequence of items which conform to schema."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _generate_message(self):\n        reformatted_paths = (\n            ''.join(\n                \"[%s]\" % str(x)\n                # If it's not a string, don't put quotes around it. We do this,\n                # for example, when the value is an int, in the case of a list\n                # index.\n                if isinstance(x, six.integer_types)\n                # Otherwise, assume the path node is a string and put quotes\n                # around the key name, as if we were drilling down into a\n                # nested dict.\n                else \"['%s']\" % str(x)\n                for x in error.path\n            )\n            for error in self.errors\n        )\n\n        messages = (error.msg for error in self.errors)\n        # combine each path with its message:\n        zipped = zip(reformatted_paths, messages)\n        combined_messages = (\n            '%(path)s: %(messages)s' % dict(path=path, messages=message)\n            for path, message in zipped\n        )\n\n        return '\\n'.join(sorted(combined_messages))", "response": "Generate a message for each path attribute and each message."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nterminates an instance and create an image from a terminated host", "response": "def terminate_and_create_image(name):\n    '''\n    Create an image from a terminated host (with auto_delete_boot_disk=False)\n\n    Args:\n        name: The name of the image\n    '''\n    node = _host_node()\n    operation = _gcp().instances().delete(project=DEFAULT_PROJECT, zone=DEFAULT_ZONE,\n                                          instance=node['real_name']).execute()\n    while True:\n        status = get_zone_operation_status(operation=operation)\n        if status == 'DONE':\n            break\n\n        print 'Terminating instance [OPERATION %s]' % status\n        time.sleep(5)\n\n    body = {\n        'name': name,\n        'sourceDisk': node['source_disk'],\n    }\n\n    operation = _gcp().images().insert(project=DEFAULT_PROJECT, body=body).execute()\n    while True:\n        status = get_global_operation_status(operation=operation)\n        if status == 'DONE':\n            break\n\n        print 'Creating image [OPERATION %s]' % status\n        time.sleep(5)\n\n    print 'Created image: %s' % operation['targetLink']"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npops multiple keys off a dict like object", "response": "def multi_pop(d, *args):\n    \"\"\" pops multiple keys off a dict like object \"\"\"\n    retval = {}\n    for key in args:\n        if key in d:\n            retval[key] = d.pop(key)\n    return retval"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef csvtolist(inputstr):\n    reader = csv.reader([inputstr], skipinitialspace=True)\n    output = []\n    for r in reader:\n        output += r\n    return output", "response": "converts a csv string into a list"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake a sequence and make it unique.", "response": "def unique(seq, preserve_order=True):\n    \"\"\"\n        Take a sequence and make it unique.  Not preserving order is faster, but\n        that won't matter so much for most uses.\n\n        copied from: http://www.peterbe.com/plog/uniqifiers-benchmark/uniqifiers_benchmark.py\n    \"\"\"\n    if preserve_order:\n        # f8 by Dave Kirby\n        # Order preserving\n        seen = set()\n        seen_add = seen.add  # lookup method only once\n        return [x for x in seq if x not in seen and not seen_add(x)]\n    # f9\n    # Not order preserving\n    return list({}.fromkeys(seq).keys())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a prettified version of the SQL as a list of lines to help in creating a useful diff between two SQL statements.", "response": "def prettifysql(sql):\n    \"\"\"Returns a prettified version of the SQL as a list of lines to help\n    in creating a useful diff between two SQL statements.\"\"\"\n    pretty = []\n    for line in sql.split('\\n'):\n        pretty.extend([\"%s,\\n\" % x for x in line.split(',')])\n    return pretty"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a unified diff of two strings.", "response": "def diff(actual, expected):\n    \"\"\"\n        normalize whitespace in actual and expected and return unified diff\n    \"\"\"\n    return '\\n'.join(list(\n        difflib.unified_diff(actual.splitlines(), expected.splitlines())\n    ))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter_dict(d, cb):\n\n    return {k: v for k, v in d.items() if cb(k, v)}", "response": "Filter a dictionary based on a function"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef model_to_dict(model, exclude=None):\n    exclude = exclude or []\n    exclude.append('_sa_instance_state')\n    return {k: v for k, v in model.__dict__.items() if k not in exclude}", "response": "Extract a SQLAlchemy model instance to a dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rank_features(self, inputs: pd.DataFrame) -> pd.DataFrame:\n\n        pca = PCA()\n\n        try:\n            pca.fit(normalize( \\\n                            inputs.apply(pd.to_numeric, errors='coerce') \\\n                            .applymap(lambda x: 0.0 if np.isnan(x) else x) \\\n                            .values, axis=0))\n\n            importance_on1stpc= np.argsort( \\\n                                np.absolute( \\\n                                pca.components_[0,:]))[::-1]\n\n            scores = [np.absolute(pca.components_[0,i]) for i in importance_on1stpc]\n        except:\n            logging.exception(\"Failed\")\n            # If any error occurs, just return indices in original order\n            # In the future we should consider a better error handling strategy\n            importance_on1stpc = [i for i in range(inputs.shape[0])]\n            scores = [0.0 for i in importance_on1stpc]\n\n        return pd.DataFrame({'features': importance_on1stpc, 'scores': scores})", "response": "Perform PCA and return a list of the indices of the most important entry - level features for each principal - level entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the roles of the hierarchy.", "response": "def roles(self, value):\n        \"\"\"\n        Setter for **self.__roles** attribute.\n\n        :param value: Attribute value.\n        :type value: dict\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is dict, \"'{0}' attribute: '{1}' type is not 'dict'!\".format(\"roles\", value)\n            for key in value:\n                assert type(key) is Qt.ItemDataRole, \"'{0}' attribute: '{1}' type is not 'Qt.ItemDataRole'!\".format(\n                    \"roles\", key)\n        self.__roles = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the flags of the object.", "response": "def flags(self, value):\n        \"\"\"\n        Setter for **self.__flags** attribute.\n\n        :param value: Attribute value.\n        :type value: int\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is int, \"'{0}' attribute: '{1}' type is not 'int'!\".format(\"flags\", value)\n        self.__flags = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef attribute_changed(self):\n\n        for model in umbra.ui.models.GraphModel.find_model(self):\n            headers = model.horizontal_headers.values()\n            if not self.name in headers:\n                continue\n\n            model.attribute_changed(model.find_node(self), headers.index(self.name))\n        return True", "response": "Triggers the host model attribute changed method."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef node_changed(self):\n\n        for model in umbra.ui.models.GraphModel.find_model(self):\n            model.node_changed(self)\n        return True", "response": "Triggers the host model changed method."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef system_exit_exception_handler(*args):\n\n    reporter = Reporter()\n    reporter.Footer_label.setText(\n        \"The severity of this exception is critical, <b>{0}</b> cannot continue and will now close!\".format(\n            Constants.application_name))\n\n    base_exception_handler(*args)\n\n    foundations.core.exit(1)\n\n    return True", "response": "Provides a system exit exception handler."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef critical_exception_handler(object):\n\n    @functools.wraps(object)\n    def critical_exception_handler_wrapper(*args, **kwargs):\n        \"\"\"\n        Marks an object that would system exit in case of critical exception.\n\n        :param \\*args: Arguments.\n        :type \\*args: \\*\n        :param \\*\\*kwargs: Keywords arguments.\n        :type \\*\\*kwargs: \\*\\*\n        \"\"\"\n\n        _exceptions__frame__ = True\n\n        try:\n            return object(*args, **kwargs)\n        except Exception as error:\n            system_exit_exception_handler(error)\n\n    return critical_exception_handler_wrapper", "response": "Decorator that handles critical exception."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninstalling the exceptions reporter.", "response": "def install_exception_reporter(report=True):\n    \"\"\"\n    Installs the exceptions reporter.\n\n    :param report: Report to Crittercism.\n    :type report: bool\n    :return: Reporter instance.\n    :rtype: Reporter\n    \"\"\"\n\n    reporter = Reporter(report=report)\n    sys.excepthook = reporter\n    return reporter"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef report(self, value):\n\n        if value is not None:\n            assert type(value) is bool, \"'{0}' attribute: '{1}' type is not 'bool'!\".format(\"report\", value)\n        self.__report = value", "response": "Sets the value of the\n        attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef enabled(self, value):\n\n        if value is not None:\n            assert type(value) is bool, \"'{0}' attribute: '{1}' type is not 'bool'!\".format(\"enabled\", value)\n        self.__enabled = value", "response": "Sets the enabled flag."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __initialize_ui(self):\n\n        LOGGER.debug(\"> Initializing '{0}' Widget ui.\".format(self.__class__.__name__))\n\n        self.__view = self.Reporter_webView\n\n        self.setWindowTitle(\"{0} - Reporter\".format(Constants.application_name))\n        self.Footer_label.setText(self.__footerText)\n        self.__initialize_context_ui()\n\n        self.__set_html()\n\n        # Signals / Slots.\n        self.Copy_Report_pushButton.clicked.connect(self.__Copy_Report_pushButton__clicked)\n        self.Disable_Reporter_pushButton.clicked.connect(self.__Disable_Reporter_pushButton__clicked)", "response": "Initializes the Widget ui."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the context Widget ui.", "response": "def __initialize_context_ui(self):\n        \"\"\"\n        Sets the context Widget ui.\n        \"\"\"\n\n        if foundations.common.is_internet_available():\n            text = self.__onlineText\n        else:\n            text = self.__offlineText\n        self.Header_label.setText(text)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the html content with given body tag content.", "response": "def __get_html(self, body=None):\n        \"\"\"\n        Returns the html content with given body tag content.\n\n        :param body: Body tag content.\n        :type body: unicode\n        :return: Html.\n        :rtype: unicode\n        \"\"\"\n\n        output = []\n        output.append(\"<html>\")\n        output.append(\"<head>\")\n        for javascript in (self.__jquery_javascript,\n                           self.__crittercism_javascript,\n                           self.__reporter_javascript):\n            output.append(\"<script type=\\\"text/javascript\\\">\")\n            output.append(javascript)\n            output.append(\"</script>\")\n        output.append(\"<style type=\\\"text/css\\\">\")\n        output.append(self.__style)\n        output.append(\"</style>\")\n        output.append(\"</head>\")\n        if body is not None:\n            output.append(body)\n        else:\n            output.append(\"<body>\")\n            output.append(\"<div id=\\\"report\\\">\")\n            output.append(\"</div>\")\n            output.append(\"</body>\")\n        output.append(\"</html>\")\n        return \"\\n\".join(output)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the html content in the View using given body.", "response": "def __set_html(self, html=None):\n        \"\"\"\n        Sets the html content in the View using given body.\n\n        :param html: Html content.\n        :type html: unicode\n        \"\"\"\n\n        self.__html = self.__get_html(html)\n        self.__view.setHtml(self.__html)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __update_html(self, html):\n\n        if platform.system() in (\"Windows\", \"Microsoft\"):\n            html = re.sub(r\"((?:[a-zA-Z]\\:|\\\\\\\\[\\w\\.]+\\\\[\\w.$]+)\\\\(?:[\\w]+\\\\)*\\w([\\w.])+)\",\n                          lambda x: foundations.strings.to_forward_slashes(x.group(1)),\n                          html)\n\n        html = foundations.strings.replace(html, OrderedDict([('\"', '\\\\\"'), (\"\\n\", \"\")]))\n        self.__evaluate_javascript(\"$(\\\"#report\\\").html(\\\"{0}\\\");\".format(html))", "response": "Updates the View with given html content."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle_exception(self, *args):\n\n        if not self.__enabled:\n            return\n\n        cls, instance, trcback = foundations.exceptions.extract_exception(*args)\n\n        LOGGER.info(\"{0} | Handling '{1}' exception!\".format(\n            self.__class__.__name__, foundations.strings.to_string(cls)))\n\n        self.__initialize_context_ui()\n\n        self.__update_html(self.format_html_exception(cls, instance, trcback))\n\n        self.show()\n        self.__report and self.report_exception_to_crittercism(cls, instance, trcback)\n        foundations.exceptions.base_exception_handler(cls, instance, trcback)\n        self.exec_()", "response": "Handles given exception.\n\n        :param \\*args: Arguments.\n        :type \\*args: \\*"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nformat given exception as an html text.", "response": "def format_html_exception(*args):\n        \"\"\"\n        Formats given exception as an html text.\n\n        :param \\*args: Arguments.\n        :type \\*args: \\*\n        :return: Exception html text.\n        :rtype: unicode\n        \"\"\"\n\n        escape = lambda x: foundations.strings.replace(x,\n                                                       OrderedDict([(\"&\", \"&amp;\"), (\"<\", \"&lt;\"), (\">\", \"&gt;\")]))\n        format = lambda x: foundations.strings.replace(x.expandtabs(8),\n                                                       OrderedDict(\n                                                           [(\"\\n\\n\", \"\\n \\n\"), (\"\\n\\n\", \"\\n \\n\"), (\" \", \"&nbsp;\"),\n                                                            (\"\\n\", \"<br/>\\n\")]))\n\n        verbose = 10\n        cls, instance, trcback = args\n        stack = foundations.exceptions.extract_stack(foundations.exceptions.get_inner_most_frame(trcback), verbose)\n\n        python = \"Python {0}: {1}\".format(sys.version.split()[0], sys.executable)\n        date = time.ctime(time.time())\n\n        html = []\n        html.append(\n            \"<div class=\\\"header\\\"><span class=\\\"floatRight textAlignRight\\\"><h4>{0}<br/>{1}</h4></span><h2>{2}</h2></div>\".format(\n                python, date, escape(foundations.strings.to_string(cls))))\n\n        html.append(\"<div class=\\\"traceback\\\">\")\n        for line in foundations.exceptions.format_exception(cls, instance, trcback):\n            html.append(\"{0}<br/>\".format(format(escape(line))))\n        html.append(\"</div>\")\n\n        html.append(\"<div class=\\\"content\\\">\")\n        html.append(\"<p>An unhandled exception occured in <b>{0} {1}</b>! \\\n                Sequence of calls leading up to the exception, in their occurring order:</p>\".format(\n            Constants.application_name, Constants.version))\n        html.append(\"<br/>\")\n        html.append(\"<div class=\\\"stack\\\">\")\n        for frame, file_name, line_number, name, context, index in stack:\n            location = \"<b>{0}{1}</b>\".format(escape(name) if name != \"<module>\" else \"\",\n                                              inspect.formatargvalues(*inspect.getargvalues(frame)))\n            html.append(\n                \"<div class=\\\"location\\\">File <a href=file://{0}>\\\"{0}\\\"</a>, line <b>{1}</b>, in {2}</div><br>\".format(\n                    file_name, line_number, location))\n            html.append(\"<div class=\\\"context\\\">\")\n            for i, line in enumerate(context):\n                if i == index:\n                    html.append(\"<span class=\\\"highlight\\\">{0}&nbsp;{1}</span>\".format(\n                        line_number - index + i, format(line)))\n                else:\n                    html.append(\"{0}&nbsp;{1}\".format(line_number - index + i, format(line)))\n            html.append(\"</div>\")\n            html.append(\"<br/>\")\n        html.append(\"</div>\")\n        html.append(\"</div>\")\n        html.append(\"<div class=\\\"exception\\\">\")\n        for line in traceback.format_exception_only(cls, instance):\n            html.append(\"<b>{0}</b>\".format(format(line)))\n        html.append(\"</div>\")\n\n        html.append(\"<div class=\\\"debug\\\">\")\n        html.append(\"<p>Frames locals by stack ordering, innermost last:</p>\")\n        for frame, locals in foundations.exceptions.extract_locals(trcback):\n            name, file_name, line_number = frame\n            html.append(\n                \"<div class=\\\"frame\\\">Frame \\\"{0}\\\" in <a href=file://{1}>\\\"{1}\\\"</a> file, line <b>{2}</b>:</div>\".format(\n                    escape(name), file_name, line_number))\n            html.append(\"<br/>\")\n            html.append(\"<div class=\\\"locals\\\">\")\n            arguments, nameless_args, keyword_args, locals = locals\n            has_arguments, has_locals = any((arguments, nameless_args, keyword_args)), any(locals)\n            has_arguments and html.append(\"<div class=\\\"cls\\\"><b>{0}</b></div><ul>\".format(\"Arguments:\"))\n            for key, value in arguments.iteritems():\n                html.append(\"<li><b>{0}</b> = {1}</li>\".format(key, escape(value)))\n            for value in nameless_args:\n                html.append(\"<li><b>{0}</b></li>\".format(escape(value)))\n            for key, value in sorted(keyword_args.iteritems()):\n                html.append(\"<li><b>{0}</b> = {1}</li>\".format(key, escape(value)))\n            has_arguments and html.append(\"</ul>\")\n            has_locals and html.append(\"<div class=\\\"cls\\\"><b>{0}</b></div><ul>\".format(\"Locals:\"))\n            for key, value in sorted(locals.iteritems()):\n                html.append(\"<li><b>{0}</b> = {1}</li>\".format(key, escape(value)))\n            has_locals and html.append(\"</ul>\")\n            html.append(\"</div>\")\n            html.append(\"<br/>\")\n        html.append(\"</div>\")\n\n        return \"\".join(html)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nformatting given exception as a text.", "response": "def formatTextException(*args):\n        \"\"\"\n        Formats given exception as a text.\n\n        :param \\*args: Arguments.\n        :type \\*args: \\*\n        :return: Exception text.\n        :rtype: unicode\n        \"\"\"\n\n        format = lambda x: re.sub(r\"^(\\s+)\", lambda y: \"{0} \".format(\".\" * len(y.group(0))), x.rstrip().expandtabs(4))\n\n        verbose = 10\n        cls, instance, trcback = args\n        stack = foundations.exceptions.extract_stack(foundations.exceptions.get_inner_most_frame(trcback), verbose)\n\n        text = []\n        text.append(foundations.strings.to_string(cls))\n        text.append(\"\")\n\n        for line in foundations.exceptions.format_exception(cls, instance, trcback):\n            text.append(format(\"{0}\".format(format(line))))\n        text.append(\"\")\n\n        text.append(\"An unhandled exception occured in {0} {1}!\".format(Constants.application_name,\n                                                                        Constants.version))\n        text.append(\"Sequence of calls leading up to the exception, in their occurring order:\")\n        text.append(\"\")\n\n        for frame, file_name, line_number, name, context, index in stack:\n            location = \"{0}{1}\".format(name if name != \"<module>\" else \"\",\n                                       inspect.formatargvalues(*inspect.getargvalues(frame)))\n            text.append(\"File \\\"{0}\\\", line {1}, in {2}\".format(file_name, line_number, location))\n            for i, line in enumerate(context):\n                if i == index:\n                    text.append(format(\"\\t{0} {1} <===\".format(line_number - index + i, format(format(line)))))\n                else:\n                    text.append(format(\"\\t{0} {1}\".format(line_number - index + i, format(format(line)))))\n            text.append(\"\")\n        for line in traceback.format_exception_only(cls, instance):\n            text.append(\"{0}\".format(format(line)))\n        text.append(\"\")\n\n        text.append(\"Frames locals by stack ordering, innermost last:\")\n        text.append(\"\")\n        for frame, locals in foundations.exceptions.extract_locals(trcback):\n            name, file_name, line_number = frame\n            text.append(\"Frame \\\"{0}\\\" in \\\"{1}\\\" file, line {2}:\".format(name, file_name, line_number))\n            arguments, nameless_args, keyword_args, locals = locals\n            has_arguments, has_locals = any((arguments, nameless_args, keyword_args)), any(locals)\n            has_arguments and text.append(format(\"\\tArguments:\"))\n            for key, value in arguments.iteritems():\n                text.append(format(\"\\t\\t{0} = {1}\".format(key, value)))\n            for value in nameless_args:\n                text.append(format(\"\\t\\t{0}\".format(value)))\n            for key, value in sorted(keyword_args.iteritems()):\n                text.append(format(\"\\\\tt{0} = {1}\".format(key, value)))\n            has_locals and text.append(format(\"\\tLocals:\"))\n            for key, value in sorted(locals.iteritems()):\n                text.append(format(\"\\t\\t{0} = {1}\".format(key, value)))\n            text.append(\"\")\n\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef report_exception_to_crittercism(self, *args):\n\n        if foundations.common.is_internet_available():\n            cls, instance, trcback = args\n\n            title = re.escape(\"\".join(map(lambda x: x.strip(), traceback.format_exception_only(cls, instance))))\n            file = trcback.tb_frame.f_code.co_filename\n            line_number = trcback.tb_lineno\n            stack = repr(map(str, self.formatTextException(cls, instance, trcback)))\n\n            javascript = \"Crittercism.logExternalException(\\\"{0}\\\", \\\"{1}\\\", {2}, {3});\".format(\n                title, file, line_number, stack)\n            self.__evaluate_javascript(javascript)\n            LOGGER.info(\"{0} | Exception report sent to Crittercism!\".format(self.__class__.__name__))\n            return True\n        else:\n            LOGGER.warning(\"!> {0} | Failed sending exception report to Crittercism!\".format(self.__class__.__name__))\n            return False", "response": "Reports given exception to Crittercism."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndoes a web request and manage response.", "response": "async def async_request(session, url, **kwargs):\n    \"\"\"Do a web request and manage response.\"\"\"\n    try:\n        with async_timeout.timeout(10):\n            _LOGGER.debug(\"Sending %s to %s\", kwargs, url)\n            response = await session(url, **kwargs)\n        if response.status != 200:\n            _LOGGER.error(\"HTTP status %d, response %s.\",\n                          response.status, (await response.text()))\n            return False\n        result = await response.json()\n    except asyncio.TimeoutError:\n        _LOGGER.error(\"Timeout getting SPC data from %s.\", url)\n        return False\n    except aiohttp.ClientError:\n        _LOGGER.error(\"Error getting SPC data from %s.\", url)\n        return False\n    else:\n        _LOGGER.debug(\"HTTP request response: %s\", result)\n\n    if result['status'] != 'success':\n        _LOGGER.error(\n            \"SPC Web Gateway call unsuccessful for resource: %s\", url)\n        return False\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the timer key name.", "response": "def get_key_name(self, environ, response_interception, exception=None):\n        \"\"\"Get the timer key name.\n\n        :param environ: wsgi environment\n        :type environ: dict\n        :param response_interception: dictionary in form\n            {'status': '<response status>', 'response_headers': [<response headers], 'exc_info': <exc_info>}\n            This is the interception of what was passed to start_response handler.\n        :type response_interception: dict\n        :param exception: optional exception happened during the iteration of the response\n        :type exception: Exception\n\n        :return: string in form '{{UNDERSCORED_PATH}}.{{METHOD}}.{{STATUS_CODE}}'\n        :rtype: str\n        \"\"\"\n        status = response_interception.get('status')\n        status_code = status.split()[0]  # Leave only the status code.\n        # PATH_INFO can be empty, so falling back to '/' in that case\n        path = CHAR_RE.sub(self.separator, (environ['PATH_INFO'].rstrip('\\/') or '/')[1:])\n        parts = [path, environ['REQUEST_METHOD'], status_code]\n        if exception:\n            parts.append(exception.__class__.__name__)\n        return '.'.join(parts)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends the actual timing stats.", "response": "def send_stats(self, start, environ, response_interception, exception=None):\n        \"\"\"Send the actual timing stats.\n\n        :param start: start time in seconds since the epoch as a floating point number\n        :type start: float\n        :param environ: wsgi environment\n        :type environ: dict\n        :param response_interception: dictionary in form\n            {'status': '<response status>', 'response_headers': [<response headers], 'exc_info': <exc_info>}\n            This is the interception of what was passed to start_response handler.\n        :type response_interception: dict\n        :param exception: optional exception happened during the iteration of the response\n        :type exception: Exception\n        \"\"\"\n        # It could happen that start_response wasn't called or it failed, so we might have an empty interception\n        if response_interception:\n            # Create the timer object and send the data to statsd.\n            key_name = self.get_key_name(environ, response_interception, exception=exception)\n            timer = self.statsd_client.timer(key_name)\n            timer._start_time = start\n            timer.stop()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef editor(self, value):\n\n        if value is not None:\n            assert type(value) is Editor, \"'{0}' attribute: '{1}' type is not 'Editor'!\".format(\"editor\", value)\n        self.__editor = value", "response": "Sets the Editor attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_layout(self):\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        sizer.Add(self.canvas, 1, wx.EXPAND)\n        hbox = wx.BoxSizer(wx.HORIZONTAL)\n        if self.toolbar is not None:\n            self.toobar = MyToolbar(self.canvas)\n            self.toobar.Realize()\n            hbox.Add(self.toobar, 0, wx.EXPAND | wx.RIGHT, 10)\n        self.pos_st = wx.StaticText(self, label='')\n        hbox.Add(self.pos_st, 0, wx.ALIGN_CENTER_VERTICAL)\n        sizer.Add(hbox, 0, wx.EXPAND | wx.BOTTOM, 0)\n        self.SetSizerAndFit(sizer)", "response": "set layout of the log entry"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting figure and canvas with the same color", "response": "def set_color(self, rgb_tuple):\n        \"\"\" set figure and canvas with the same color.\n\n        :param rgb_tuple: rgb color tuple, e.g. (255, 255, 255) for white color\n        \"\"\"\n        if rgb_tuple is None:\n            rgb_tuple = wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNFACE).Get()\n        clr = [c / 255.0 for c in rgb_tuple]\n        self.figure.set_facecolor(clr)\n        self.figure.set_edgecolor(clr)\n        self.canvas.SetBackgroundColour(wx.Colour(*rgb_tuple))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads a png or jpeg image into a bitmap buffer.", "response": "def load_image(buf, request_components=0):\n    \"\"\"Load a png or jpeg image into a bitmap buffer.\n\n    Args:\n        buf (Buffer): Buffer to load\n        request_components (int): If you want to force number of components\n\n    Returns:\n\n        A tuple containing:\n\n        - Bitmap buffer\n        - width of bitmap\n        - height of bitmap\n        - number of components\n    \"\"\"\n    x = ffi.new('int*')\n    y = ffi.new('int*')\n    n = ffi.new('int*')\n\n    cbuf = ffi.from_buffer(buf)\n\n    bitmap = lib.stbi_load_from_memory(\n        ffi.cast('unsigned char*', cbuf), len(buf), x, y, n,\n        request_components\n    )\n\n    pybuffer = ffi.buffer(bitmap, x[0]*y[0]*n[0])\n\n    return pybuffer, x[0], y[0], n[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the value of multiple attributes.", "response": "def set_attributes(self, **attributes_dict):\n        \"\"\"\n        Set the value of multiple attributes.\n        :param attributes_dict dict: a dictionary containing key-value pairs as attribute names and values to be set\n        :returns: the resource itself\n        \"\"\"\n        for attr_name, attr_value in attributes_dict.items():\n            self.set_attr(attr_name, attr_value)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, parent=None):\n        if self.id:\n            return self.update(parent=parent)\n        else:\n            return self.create(parent=parent)", "response": "Creates or updates the resource if it already has an id."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(self, parent=None, **relationships):\n        if self.id:\n            raise self.ResourceError('cannot create a resource with an existing ID')\n        data = self.__class__._process_request(\n            connection.post,\n            parent=parent,\n            payload=self.payload(),\n            relationships=self._relationships_payload(relationships)\n        )\n        return self._reload(data)", "response": "Creates the resource. This will trigger an api POST request.\n        :param parent ResourceBase: the parent of the resource - used for nesting the request url, optional\n        :param **relationships: any number of lists as keyword arguments to be submitted as relationships\n            for the request, e.g. relationship_name=[resource1, resource2]\n        :raises ResourceError: if the resource has an id (already exists)\n        :returns: the resource itself"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, parent=None):\n        if not self.id:\n            raise self.ResourceError('cannot update a resource without an ID')\n        data = self.__class__._process_request(\n            connection.patch,\n            parent=parent,\n            id=self.id,\n            payload=self.payload()\n        )\n        return self._reload(data)", "response": "Updates the resource with the new data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef payload(self):\n        payload = {'type': self.resource_type(), 'attributes': self.attributes}\n        if self.id:\n            payload['id'] = self.id\n        return payload", "response": "Renders the resource payload."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(cls, parent=None):\n        data = cls._process_request(connection.get, parent=parent)\n        return cls._load_resources(data)", "response": "Gets all resources of the given type and parent."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of all resources of the given type and parent.", "response": "def filter(cls, parent=None, **filters):\n        \"\"\"\n        Gets all resources of the given type and parent (if provided) which match the given filters.\n        This will trigger an api GET request.\n        :param parent ResourceBase: the parent of the resource - used for nesting the request url, optional\n        :param **filters: any number of keyword arguments to filter by, e.g name='example name'\n        :returns: a list of matching resources\n        \"\"\"\n        data = cls._process_filter_request(parent, **filters)\n        return cls._load_resources(data)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find(cls, id, parent=None):\n        try:\n            data = cls._process_request(connection.get, parent=parent, id=id)\n            return cls._load_resource(data)\n        except connection.RequestError as error:\n            raise cls.ResourceError(error)", "response": "Gets the resource of the given type and parent with matching id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef first_or_create(cls, parent=None, **attributes):\n        existing_resource = cls.find_by(parent, **attributes)\n        if existing_resource:\n            return existing_resource\n        return cls(**attributes).create()", "response": "Tries to find the first resource with the same attributes creates the resource if no matches are found."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef first_or_initialize(cls, parent=None, **attributes):\n        existing_resource = cls.find_by(parent, **attributes)\n        if existing_resource:\n            return existing_resource\n        return cls(**attributes)", "response": "Tries to find the first resource with the same attributes initialized the resource if no matches are found."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the first resource of the given type and parent with matching attributes.", "response": "def find_by(cls, parent=None, **attributes):\n        \"\"\"\n        Gets the first resource of the given type and parent (if provided) with matching attributes.\n        This will trigger an api GET request.\n        :param parent ResourceBase: the parent of the resource - used for nesting the request url, optional\n        :param **attributes: any number of keyword arguments as attributes to search the resource by\n        :returns: the matching resource, None if not found\n        :raises ResourceError: if the no valid attributes are provided\n        \"\"\"\n        all_nones = not all(attributes.values())\n        if not attributes or all_nones:\n            raise cls.ResourceError('at least one attribute must be provided')\n        matches = cls.filter(parent, **attributes)\n        if matches:\n            return matches[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wait_time(self, value):\n\n        if value is not None:\n            assert type(value) in (int, float), \"'{0}' attribute: '{1}' type is not 'int' or 'float'!\".format(\n                \"wait_time\", value)\n            assert value >= 0, \"'{0}' attribute: '{1}' need to be positive!\".format(\"wait_time\", value)\n        self.__wait_time = value", "response": "Setter for **self. __wait_time** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the value of the text color attribute.", "response": "def text_color(self, value):\n        \"\"\"\n        Setter for **self.__text_color** attribute.\n\n        :param value: Attribute value.\n        :type value: int or QColor\n        \"\"\"\n\n        if value is not None:\n            assert type(value) in (Qt.GlobalColor, QColor), \\\n                \"'{0}' attribute: '{1}' type is not 'int' or 'QColor'!\".format(\"text_color\", value)\n        self.__text_color = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_message(self, message, text_alignement=Qt.AlignLeft, text_color=None, wait_time=None):\n\n        QSplashScreen.showMessage(\n            self, message, text_alignement, self.__text_color if text_color is None else text_color)\n\n        # Force QSplashscreen refresh.\n        QApplication.processEvents()\n\n        foundations.core.wait(self.__wait_time if wait_time is None else wait_time)", "response": "Implements the QSplashScreen. showMessage method."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef genweights(p,q,dt,error=None , n=False):\r\n    \r\n    p = np.abs(p)\r\n    q = np.abs(q)\r\n  \r\n    #check inputs\r\n    if (-p > q) : raise \"genweights : P must be lesser than q\"\r\n  \r\n    #Build matrices\r\n    N = p + q\r\n    T = N + 1\r\n    A = np.matrix(np.zeros((T,T)))\r\n    A[T-1,:] = np.append(np.repeat(1.0,N),0)\r\n    sn = np.arange(T) - p\r\n    sn = sn.compress(sn != 0)\r\n    for i in np.arange(len(sn)) :\r\n        A[i,:] = np.append(((1./sn)*(-sn[i]/2.)),sn[i]**2.*dt**2./4.) #Eq.11 (PL) \r\n        A[i,i] = -1.\r\n        \r\n    B = np.zeros(T)\r\n    B[N] = 1.0\r\n  \r\n    #Compute the coefficients\r\n    cn=np.dot(A.I,B)##B\r\n#    cn=cn.transpose()\r\n    cn=np.array([i for i in cn.flat])\r\n    cn = cn[0:N] #Check the indices\r\n  \r\n    #Compute the error\r\n    error = np.sqrt(np.sum(cn.transpose()/(sn*dt))**2. + np.sum( (cn.transpose()/(sn*dt))**2. ) );\r\n  \r\n    return cn, sn if n else cn", "response": "Returns a new GENWEIGTHS object with the optimal weigthing coefficients."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef optimal_slope(cn,n,dt,z,i):\r\n\r\n#Return optimal slope\r\n    #FIX : This version uses a regular grid (uses n * dt)\r\n    #      We should rather use an irregular grid (real array of along-track distances)\r\n  \r\n    #; 1st member EQ 0 if filter centered\r\n    dh = np.nansum((-cn)/(n * dt)) * z[i] \\\r\n        + np.nansum(cn / (n * dt) * z[i+n])\r\n    return dh", "response": "Returns a new word word"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef powell_leben_filter_km(*args,**kwargs):\r\n    \r\n    \r\n    #From Powell and Leben, 2004. JAOT.\r\n    #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n    \r\n    lon = args[0]\r\n    lat = args[1]\r\n    nu = args[2]\r\n    dst = calcul_distance(lat,lon) * 1e3 #distance in meters\r\n    \r\n    n=nu.size\r\n\r\n    #We use a p+q filter (default 2 1Hz points on each side ~ 12km)\r\n    #-> Set p & q distances to defaults if they don't exist    \r\n    p = kwargs.pop('p',12.)\r\n    q = kwargs.pop('q',12.)\r\n    verbose = kwargs.pop('verbose',False)\r\n        \r\n    dt = np.median(dst[1:] - dst[:-1])   #Median point-to-point distance in meters\r\n      \r\n    #Get the corresponding number of points rounded to the nearest integer\r\n    pn=np.round((p*1e3)/dt).astype(int)\r\n    qn=np.round((q*1e3)/dt).astype(int)\r\n    \r\n    if pn + qn > n : raise 'Filtering window is too large wrt array length'\r\n     \r\n    #Compute weights\r\n    #;;;;;;;;;;;;;;;\r\n    \r\n    #Initialise all possible configurations of filters\r\n    #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n    cn = []#=np.array([])   #array of weigth arrays\r\n    nout= [] #np.array([]) #array of point indices in filter arrays\r\n    pout=np.ndarray(pn+qn+1) #array containg number of points before any filter\r\n    qout=np.ndarray(pn+qn+1) #array containg number of points after any filter\r\n      \r\n      \r\n    #Compute each filter configuration\r\n    #1)Start with increasing number of points before point\r\n    #2)Compute full resolution filter (p & q points before and after filter)\r\n    #3)Finish with a deacreasing number of points after filter\r\n    \r\n    #1)Weights before\r\n    for i in np.arange(pn):\r\n        w,n=genweights(i,qn,dt,n=True)\r\n        cn.append(w)\r\n        nout.append(n)\r\n        pout[i]=i\r\n        qout[i]=qn\r\n        \r\n    #2)Centered weights\r\n    w,n=genweights(pn,qn,dt,n=True)\r\n    cn.append(w)\r\n    nout.append(n)\r\n    pout[pn]=pn\r\n    qout[pn]=qn\r\n        \r\n    #3)Weights after\r\n    for i in np.arange(pn+1, pn+1+qn):\r\n        w,n=genweights(pn,pn+qn-i,dt,n=True)\r\n        cn.append(w)\r\n        nout.append(n)\r\n        pout[i]=pn\r\n        qout[i]=pn+qn-i\r\n        \r\n    #find track edges and gaps\r\n    #;;;;;;;;;;;;;;;;;;;;;;;;;\r\n    empty = np.where(np.isnan(nu))[0]\r\n    ok = np.where(~np.isnan(nu))[0]\r\n    emptycnt = empty.size\r\n    okcnt = ok.size\r\n    \r\n    st = np.min(ok) #start point\r\n    en = np.max(ok) #end of track\r\n        \r\n    #Initiate dh for slope calculation, Eq. (5)\r\n    dh = np.repeat(np.nan,nu.size)\r\n      \r\n    #Loop over valid points in track\r\n    #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n    for i in np.arange(okcnt):\r\n        \r\n        #find valid points within filter width around filter center\r\n        #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n        cur = np.arange(pn+qn+1)+ok[i]-pn               #Points around filter center +-p/q points\r\n        cur = np.sort(list(set(cur).intersection(set(ok))))  #intersection of filter window with valid points\r\n        curcnt = cur.size\r\n        \r\n        #check points currently selected\r\n        #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n        if (curcnt > 1) :\r\n            #Be careful -> This is intended to select points following directly central point regularly (without gaps within window)\r\n            #We'll see that for a hi-rate case, we'll be able to accept gaps within filter window\r\n            #FIX:this might be buggy...\r\n            a = np.where(np.append(0,cur[1:] - cur[:-1]) == 1)[0]  #select following valid points\r\n            b = np.where(np.append(cur[:-1] - cur[1:],0) ==  -1)[0] #select preceeding valid points\r\n            aftcnt = a.size\r\n            befcnt = b.size\r\n            \r\n#          b = WHERE([cur[:-1] - cur[1:],0] EQ -1,befcnt) ; select preceeding valid points\r\n            #If there are points at least before OR after central point, keep going, otherwise switch to next point\r\n            if (aftcnt != 0) & (befcnt != 0):\r\n                cur = cur[np.sort(list(set(a).union(b)))] #Get the union of valid points before and after central point\r\n                curcnt = cur.size\r\n            else : curcnt =0\r\n        else : curcnt =0\r\n        \r\n        #Adapt filter length to current case\r\n        #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n        #(We know how many points are following directly before and after)\r\n        \r\n        if (curcnt != 0) :\r\n            \r\n            #Get number of points before and after central point\r\n            #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            nbef = ok[i] - cur[0]\r\n            naft = cur[curcnt - 1] - ok[i]\r\n          \r\n            #If we have less than p or q on each side, we'll set full filter width to\r\n            #the greater size, and reduce the smaller size\r\n            #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            if (naft > nbef) & (naft+nbef > qn) : naft=pn\r\n            if (naft < nbef) & (naft+nbef > pn) : nbef=qn\r\n          \r\n            #Select adapted filter in filter list\r\n            #(given by pout and qout)\r\n            #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            which=(np.where((nbef == pout) & (naft == qout)))[0]\r\n            nwhich = which.size\r\n          \r\n            #If we have found a filter, we use it, otherwise we issue a warning message and flag the point\r\n            if (nwhich > 0) : dh[ok[i]] = optimal_slope(cn[which],nout[which],dt,nu,ok[i])\r\n            else :\r\n                if (verbose) : print \"[WARNING] No available filter for point no.{0}\".format(ok[i])\r\n                dh[ok[i]] = np.NaN #If no suitable filter, flag the data\r\n       \r\n    #Compute currents with given slope\r\n    #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n    \r\n    #Compute gravitational & coriolis forces\r\n    g = gravity(lat)\r\n    f = coriolis(lat)\r\n\r\n    #Get geostrophic velocities\r\n    try :\r\n        ug = - (g*dh) / (f)\r\n    except ValueError :\r\n        print 'error'\r\n  \r\n    #Inverse sign of ug for descending tracks as Coriolis is oriented to the right\r\n    #northward\r\n    if (not track_orient(lon,lat)) : #descending tracks\r\n        ug *=-1\r\n    \r\n    return ug", "response": "Creates a new GSSHAPY powell with a given set of parameters."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef geost_1d(*args,**kwargs) : #(lon,lat,nu): OR (dst,nu)\r\n    \r\n    lon = args[0]\r\n    lat = args[1]\r\n    \r\n    dst = args[2] if len(args) == 4 else calcul_distance(lat,lon) * 1e3 #distance in meters\r\n    nu = args [3] if len(args) == 4 else args[2]\r\n    \r\n    isVector = len(np.shape(nu)) == 1 \r\n    \r\n    #Reshape nu if vector\r\n    if isVector : nu=np.reshape(nu,(len(nu),1))\r\n    \r\n    nt = np.shape(nu)[1] if not isVector else 1\r\n    sh = nu.shape\r\n    nufilt=np.ma.array(np.empty(sh),mask=True,dtype=nu.dtype)\r\n    \r\n    pl04 = kwargs.pop('pl04',False)\r\n    filter = kwargs.pop('filter', None)\r\n    strict = kwargs.pop('strict',False)\r\n    verbose = kwargs.pop('verbose',False)\r\n    \r\n    if filter is not None :\r\n        for t in np.arange(nt) : \r\n            nufilt[:,t] =loess(nu[:,t],dst,filter*1e3)\r\n        nu=nufilt\r\n    \r\n    if pl04 :\r\n        ug = np.ma.array(np.empty(sh),mask=True,dtype=nu.dtype)\r\n        for t in np.arange(nt) :\r\n            ug[:,t] = powell_leben_filter_km(lon,lat,nu[:,t],verbose=verbose,**kwargs)\r\n        if isVector : ug=ug.flatten()\r\n        return ug\r\n    \r\n    #If strict option is set to True, compute gradients at mid-distance between points\r\n    if strict :\r\n        lon = (lon[1:] - lon[:-1])/2. + lon[0:-1]\r\n        lat = (lat[1:] - lat[:-1])/2. + lat[0:-1]\r\n    \r\n    \r\n    #Compute gravitational & coriolis forces\r\n    if strict : sh = (sh[0]-1,sh[1])\r\n    g = np.repeat(gravity(lat),nt).reshape(sh)\r\n    f = np.repeat(coriolis(lat),nt).reshape(sh)\r\n    \r\n    #Compute SSH 1st derivative\r\n#    dh = deriv(dst,nu) #(deriv is very bad...)\r\n    \r\n    \r\n    dh = np.ma.array(np.empty(sh),mask=True,dtype=nu.dtype)\r\n    for t in np.arange(nt) :\r\n        dh[:,t] = (nu[1:,t] - nu[:-1,t])/(dst[1:] - dst[:-1]) if strict else deriv(dst,nu[:,t])\r\n      \r\n    #Compute geostrophy\r\n#    print f\r\n#    print g\r\n#    print dh\r\n    ug = - (g*dh) / (f)\r\n  \r\n    #Inverse sign of ug for descending tracks as Coriolis is oriented to the right\r\n    #northward\r\n    if (not track_orient(lon,lat)) : #descending tracks\r\n        ug *=-1\r\n    \r\n    if isVector : ug=ug.flatten()\r\n    \r\n    return (lon,lat,ug) if strict else ug", "response": "A function that returns a single geostrophic velocity component."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef grid_track(lat,lon,sla,remove_edges=None,backbone=None,interp_over_continents=True):\r\n    \r\n    \r\n    \r\n    #Find gaps in data\r\n    if backbone is not None :\r\n        backlon=backbone[0]\r\n        backlat=backbone[1]\r\n        ascending=track_orient(lon,lat)\r\n        dst=calcul_distance(backlat[0],backlon[0],lat,lon)\r\n        if ascending : dst[lat < backlat[0]]*=-1\r\n        if not ascending : dst[lat > backlat[0]]*=-1\r\n        dstback=calcul_distance(backlat,backlon)\r\n        dx = dstback[1:] - dstback[:-1]\r\n        mn_dx = np.median(dx)\r\n        bins = np.round(dstback.max() / mn_dx)+1\r\n        range=(0/2.,mn_dx * bins) - mn_dx/2\r\n#        dfback=list(set(dstback).difference(set(dst)))\r\n        bhist,bbin_edges=np.histogram(dstback, bins=bins, range=range)\r\n        continent=np.where(bhist==0)[0]\r\n        if remove_edges is None : remove_edges=False\r\n    else :\r\n        dst=calcul_distance(lat,lon)\r\n        #Find gaps in data\r\n        dx = dst[1:] - dst[:-1]\r\n        mn_dx = np.median(dx)\r\n        bins = np.ceil(dst.max() / mn_dx) + 1\r\n        range=(0/2.,mn_dx * bins) - mn_dx/2\r\n        \r\n        if remove_edges is None : remove_edges=True\r\n    \r\n    \r\n    hist,bin_edges=np.histogram(dst, bins=bins, range=range) #We have binned the data along a regular grid of size (bins) in the range (range)\r\n                                                             #Missing data is thus represented by no data in a given bin\r\n    \r\n    #Remove leading and trailing edges (and synchronise bin_edges)\r\n    if remove_edges == True :\r\n        while hist[0] == 0 : \r\n            hist=np.delete(hist,[0])\r\n            bin_edges=np.delete(bin_edges,[0])\r\n        while hist[-1] == 0 :\r\n            hist=np.delete(hist,[len(hist)-1])\r\n            bin_edges=np.delete(bin_edges,[len(bin_edges)-1])\r\n    \r\n    nH =len(hist)\r\n    \r\n    #Get filled bins indices\r\n    ok = np.arange(len(hist)).compress(np.logical_and(hist,True or False))\r\n    empty = np.arange(len(hist)).compress(~np.logical_and(hist,True or False)) \r\n    \r\n    if isinstance(sla,np.ma.masked_array) : outsla = np.ma.masked_array(np.repeat(sla.fill_value,nH),mask=np.ones(nH,dtype=bool),dtype=sla.dtype)\r\n    else : outsla = np.ma.masked_array(np.repeat(np.ma.default_fill_value(1.0),nH),mask=np.ones(nH,dtype=bool),dtype=np.float32)\r\n    if isinstance(sla,np.ma.masked_array) : outlon = np.ma.masked_array(np.repeat(lon.fill_value,nH),mask=np.ones(nH,dtype=bool),dtype=lon.dtype)\r\n    else : outlon = np.ma.masked_array(np.repeat(np.ma.default_fill_value(1.0),nH),mask=np.ones(nH,dtype=bool),dtype=np.float32)\r\n    if isinstance(sla,np.ma.masked_array) : outlat = np.ma.masked_array(np.repeat(lat.fill_value,nH),mask=np.ones(nH,dtype=bool),dtype=lat.dtype)\r\n    else : outlat = np.ma.masked_array(np.repeat(np.ma.default_fill_value(1.0),nH),mask=np.ones(nH,dtype=bool),dtype=np.float32)\r\n    \r\n    outdst = bin_edges [:-1]+ mn_dx/2 #distances is taken at bins centers\r\n    outsla[ok] = sla\r\n    outlon[ok] = lon\r\n    outlat[ok] = lat\r\n    \r\n    #Remove land mass point if asked\r\n    if not interp_over_continents :\r\n        sempty=np.sort(np.array(list(set(empty).difference(set(continent)))))\r\n    else : sempty=empty.copy()\r\n    \r\n    #Fill the gaps if there are some\r\n    if len(empty) > 0 : \r\n        #Interpolate lon,lat @ empty positions\r\n        outlon[empty] = interp1d(ok, outlon[ok], empty, kind='cubic', fill_value=lon.fill_value)\r\n        outlat[empty] = interp1d(ok, outlat[ok], empty, kind='cubic', fill_value=lat.fill_value)\r\n    if len(sempty) > 0 :outsla[sempty] = interp1d(ok, outsla[ok], empty, kind=0, fill_value=sla.fill_value) #0-th order Spline interpolation\r\n    \r\n    outlon.mask[outlon.data == outlon.fill_value] = outlon.fill_value\r\n    outlat.mask[outlat.data == outlat.fill_value] = outlat.fill_value\r\n    outsla.mask[outsla.data == outsla.fill_value] = outsla.fill_value\r\n    \r\n    \r\n    #Get gap properties\r\n    ind=np.arange(len(hist))\r\n    dhist=(hist[1:] - hist[:-1])\r\n    \r\n    #Remove edge gaps\r\n    if (dhist!=0).sum()> 0 :\r\n        if (dhist[dhist!=0])[0] == 1 : dhist[(np.arange(nH)[dhist!=0])[0]]=0 #This do not count start and end of track as gaps\r\n    if (dhist!=0).sum()> 0 :\r\n        if (dhist[dhist!=0])[-1] == -1 : dhist[(np.arange(nH)[dhist!=0])[-1]]=0\r\n    st=ind[dhist==-1]+1\r\n    en=ind[dhist==1]\r\n    gaplen=(en-st) + 1\r\n    ngaps=len(st)\r\n    gapedges=np.array([st,en])\r\n    \r\n    #Get empty bin flag\r\n    interpolated=~hist.astype('bool')\r\n    \r\n    return outdst, outlon, outlat, outsla, gaplen, ngaps, gapedges, interpolated", "response": "This function is used to track gaps in a single altimetry grid."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef grid_track_backbone(lat,lon,sla,backlat,backlon,fill=None):\r\n    \r\n    #Find gaps in data\r\n    dst=calcul_distance(backlat[0],backlon[0],lat,lon)\r\n    dstback=calcul_distance(backlat,backlon)\r\n    dx = dstback[1:] - dstback[:-1]\r\n    mn_dx = np.median(dx)\r\n    \r\n    bins = np.ceil(dstback.max() / mn_dx) + 1\r\n    range=(0/2.,mn_dx * bins) - mn_dx/2\r\n    hist,bin_edges=np.histogram(dst, bins=bins, range=range) #We have binned the data along a regular grid of size (bins) in the range (range)\r\n                                                             #Missing data is thus represented by no data in a given bin\r\n    \r\n    #Get filled bins indices\r\n    ok = np.arange(len(hist)).compress(np.logical_and(hist,True or False))\r\n    empty = np.arange(len(hist)).compress(~np.logical_and(hist,True or False)) \r\n    \r\n    outsla = np.repeat(np.NaN,len(hist))\r\n    outlon = np.repeat(np.NaN,len(hist))\r\n    outlat = np.repeat(np.NaN,len(hist))\r\n    outdst = bin_edges [:-1]+ mn_dx/2 #distances is taken at bins centers\r\n    outsla[ok] = sla\r\n    outlon[ok] = lon\r\n    outlat[ok] = lat\r\n    \r\n    #Fill the gaps if there are some\r\n    if (fill is not None) & (len(empty) > fill) : \r\n        #Interpolate lon,lat @ empty positions\r\n        outlon[empty] = interp1d(ok, outlon[ok], empty, kind='cubic')\r\n        outlat[empty] = interp1d(ok, outlat[ok], empty, kind='cubic')\r\n        outsla[empty] = interp1d(ok, outsla[ok], empty, spline=True)\r\n    \r\n    #Get empty bin flag\r\n    interpolated=(~hist.astype('bool'))\r\n    \r\n    return outdst, outlon, outlat, outsla, dx, interpolated", "response": "This function is used to detect gaps in a set of altimetry data and rebin them along a regular grid."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfill the gaps in the same location with the data in the given sla.", "response": "def fill_gaps(lat,lon,sla,mask,remove_edges=False):\r\n    \"\"\"\r\n    # FILL_GAPS\r\n    # @summary: This function allow interpolating data in gaps, depending on gap size. Data must be regularly gridded\r\n    # @param lat {type:numeric} : latitude\r\n    # @param lon {type:numeric} : longitude\r\n    # @param sla {type:numeric} : data\r\n    # @return:\r\n    #    outdst : resampled distance\r\n    #    outlon : resampled longitude\r\n    #    outlat : resampled latitude\r\n    #    outsla : resampled data\r\n    #    gaplen : length of the longest gap in data\r\n    #    ngaps : number of detected gaps in data\r\n    #    dx : average spatial sampling\r\n    #    interpolated : True when data was interpolated (empty bin)\r\n    #\r\n    # @author: Renaud DUSSURGET (RD) - LER/PAC, Ifremer\r\n    # @change: Created by RD, July 2012\r\n    #    29/08/2012 : Major change -> number of output variables changes (added INTERPOLATED), and rebinning modified\r\n    #    06/11/2012 : Included in alti_tools lib\r\n    \"\"\"\r\n    \r\n    dst=calcul_distance(lat,lon)\r\n    \r\n    #Find gaps in data\r\n    dx = dst[1:] - dst[:-1]\r\n    mn_dx = np.median(dx)\r\n    nx=len(sla)\r\n\r\n    flag=~mask\r\n    \r\n    #Get filled bins indices\r\n    outsla = sla.copy()\r\n    outlon = lon.copy()\r\n    outlat = lat.copy()\r\n    outind = np.arange(nx)\r\n    \r\n    #Replace missing data on edges by the latest valid point\r\n    first=np.where((flag))[0].min()\r\n    last=np.where((flag))[0].max()\r\n    if remove_edges :\r\n        outsla=outsla[first:last+1]\r\n        outlon=outlon[first:last+1]\r\n        outlat=outlat[first:last+1]\r\n        outind=outind[first:last+1]\r\n        mask=mask[first:last+1]\r\n        flag=flag[first:last+1]\r\n    else:\r\n        outsla[0:first] = outsla[first]\r\n        outsla[last:] = outsla[last]\r\n    \r\n    #Get gap properties\r\n    hist=np.ones(nx,dtype=int)\r\n    hist[outsla.mask]=0\r\n    while hist[0] == 0 : \r\n        hist=np.delete(hist,[0])\r\n    while hist[-1] == 0 :\r\n        hist=np.delete(hist,[len(hist)-1])\r\n    \r\n    ind=np.arange(len(hist))\r\n    dhist=(hist[1:] - hist[:-1])\r\n    st=ind.compress(dhist==-1)+1\r\n    en=ind.compress(dhist==1)\r\n    gaplen=(en-st) + 1\r\n    ngaps=len(st)\r\n    gapedges=np.array([st,en])\r\n    \r\n    \r\n    ok = np.where(flag)[0]\r\n    empty = np.where(mask)[0] \r\n    \r\n    #Fill the gaps if there are some\r\n    if len(empty) > 0 : \r\n        #Interpolate lon,lat @ empty positions\r\n        outsla[empty] = interp1d(ok, outsla[ok], empty)\r\n    \r\n    #Get empty bin flag\r\n    interpolated=~hist.astype('bool')\r\n    \r\n    return outsla, outlon, outlat, outind, ngaps, gapedges, gaplen, interpolated"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef histogram(data, bins=None, binsize=1., min=None, max=None, rev=False, use_weave=True, verbose=0):\r\n\r\n    if not have_scipy:\r\n        use_weave=False\r\n     \r\n    dowhere=False\r\n    s = data.argsort()\r\n    if min is not None:\r\n        dmin = min\r\n        dowhere=True\r\n    else:\r\n        dmin = data[s[0]]\r\n\r\n    if max is not None:\r\n        dmax = max\r\n        dowhere=True\r\n    else:\r\n        dmax = data[s[-1]]\r\n\r\n    bsize = float(binsize)\r\n#    except TypeError :\r\n#        print '[Warning] TypeError reached - type {0}'.format(type(binsize[0]))\r\n#        bsize = binsize\r\n#    finally : pass\r\n\r\n    if dowhere:\r\n        # where will preserve order, so subscript with s\r\n        w,=numpy.where( (data[s] >= dmin) & (data[s] <= dmax) )\r\n        if w.size == 0:\r\n            raise ValueError(\"No data in specified min/max range\\n\")\r\n        s = s[w]\r\n\r\n    nbin = numpy.int64( (dmax-dmin)/bsize ) + 1\r\n\r\n    if bins is not None :\r\n        s = bins\r\n        nbin = len(s)\r\n\r\n    if rev:\r\n        revsize = s.size + nbin+1\r\n        revind = numpy.zeros(revsize, dtype='i8')\r\n    else:\r\n        # this is just a dummy variable\r\n        revind=numpy.zeros(1, dtype='i8')\r\n    hist = numpy.zeros(nbin, dtype='i8')\r\n\r\n    # populate the array from nbin+1:nbin+1+s.size\r\n    # with the sort indices.  Simultaneosly record bin\r\n    # edges at the beginning of reverse indices\r\n\r\n    if use_weave:\r\n        _weave_dohist(data, s, bsize, hist, revind, dorev=rev,verbose=verbose)\r\n    else:\r\n        _dohist(data, s, bsize, hist, revind, dorev=rev)\r\n\r\n    if rev:\r\n        return hist, revind\r\n    else:\r\n        return hist", "response": "Returns a new histogram of the given data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _weave_dohist(data, s, binsize, hist, rev, dorev=False, verbose=0):\r\n\r\n    if dorev:\r\n        dorev=1\r\n    else:\r\n        dorev=0\r\n    \"\"\"\r\n    Weave version of histogram with reverse_indices\r\n\r\n    s is an index into data, sorted and possibly a subset\r\n    \"\"\"\r\n    code = \"\"\"\r\n\r\n    int64_t nbin = hist.size();\r\n    int64_t binnum_old = -1;\r\n\r\n    // index of minimum value\r\n    int64_t imin = s(0);\r\n    for (int64_t i=0; i<s.size(); i++) {\r\n\r\n        int64_t offset = i+nbin+1;\r\n        int64_t data_index = s(i);\r\n\r\n\r\n        if (dorev) {\r\n            rev(offset) = data_index;\r\n        }\r\n\r\n        int64_t binnum = (int64_t) ( (data(data_index)-data(imin))/binsize);\r\n\r\n        if (binnum >= 0 && binnum < nbin) {\r\n            if (dorev && (binnum > binnum_old) ) {\r\n                int64_t tbin = binnum_old + 1;\r\n                while (tbin <= binnum) {\r\n                    rev(tbin) = offset;\r\n                    tbin++;\r\n                }\r\n            }\r\n            hist(binnum) = hist(binnum) + 1;\r\n            binnum_old = binnum;\r\n        }\r\n    }\r\n\r\n    int64_t tbin = binnum_old + 1;\r\n    while (tbin <= nbin) {\r\n        if (dorev) {\r\n            rev(tbin) = rev.size();\r\n        }\r\n        tbin++;\r\n    }\r\n\r\n    \"\"\"\r\n\r\n    scipy.weave.inline(code, ['data','s','binsize','hist','rev','dorev'],\r\n                       type_converters = scipy.weave.converters.blitz, verbose=verbose)\r\n    return", "response": "Weave version of histogram with reverse indices"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the weighted mean error and optionally standard deviation of the array.", "response": "def wmom(arrin, weightsin, inputmean=None, calcerr=False, sdev=False):\r\n    \"\"\"\r\n    NAME:\r\n      wmom()\r\n      \r\n    PURPOSE:\r\n      Calculate the weighted mean, error, and optionally standard deviation\r\n      of an input array.\r\n\r\n    CALLING SEQUENCE:\r\n     wmean,werr = wmom(arr, weights, inputmean=None, calcerr=False, sdev=False)\r\n    \r\n    INPUTS:\r\n      arr: A numpy array or a sequence that can be converted.\r\n      weights: A set of weights for each elements in array.\r\n    OPTIONAL INPUTS:\r\n      inputmean: An input mean value, around which them mean is calculated.\r\n      calcerr=False: Calculate the weighted error.  By default the error\r\n        is calculated as 1/sqrt( weights.sum() ).  In this case it is\r\n        calculated as sqrt( (w**2 * (arr-mean)**2).sum() )/weights.sum()\r\n      sdev=False: If True, also return the weighted standard deviation \r\n        as a third element in the tuple.\r\n\r\n    OUTPUTS:\r\n      wmean, werr: A tuple of the weighted mean and error. If sdev=True the\r\n         tuple will also contain sdev: wmean,werr,wsdev\r\n\r\n    REVISION HISTORY:\r\n      Converted from IDL: 2006-10-23. Erin Sheldon, NYU\r\n\r\n   \"\"\"\r\n    from numpy import float64\r\n    \r\n    # no copy made if they are already arrays\r\n    arr = numpy.array(arrin, ndmin=1, copy=False)\r\n    weights = numpy.array(weightsin, ndmin=1, copy=False)\r\n    \r\n    # Weights is forced to be type double. All resulting calculations\r\n    # will also be double\r\n    if weights.dtype != float64:\r\n        weights = numpy.array(weights, dtype=float64)\r\n  \r\n    wtot = weights.sum()\r\n        \r\n    # user has input a mean value\r\n    if inputmean is None:\r\n        wmean = ( weights*arr ).sum()/wtot\r\n    else:\r\n        wmean=float(inputmean)\r\n\r\n    # how should error be calculated?\r\n    if calcerr:\r\n        werr2 = ( weights**2 * (arr-wmean)**2 ).sum()\r\n        werr = numpy.sqrt( werr2 )/wtot\r\n    else:\r\n        werr = 1.0/numpy.sqrt(wtot)\r\n\r\n    # should output include the weighted standard deviation?\r\n    if sdev:\r\n        wvar = ( weights*(arr-wmean)**2 ).sum()/wtot\r\n        wsdev = numpy.sqrt(wvar)\r\n        return wmean,werr,wsdev\r\n    else:\r\n        return wmean,werr"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the mean and standard deviation of an array with sigma clipping.", "response": "def sigma_clip(arrin, niter=4, nsig=4, extra={}, verbose=False):\r\n    \"\"\"\r\n    NAME:\r\n      sigma_clip()\r\n      \r\n    PURPOSE:\r\n      Calculate the mean/stdev of an array with sigma clipping. Iterate\r\n      niter times, removing elements that are outside nsig, and recalculating\r\n      mean/stdev.\r\n\r\n    CALLING SEQUENCE:\r\n      mean,stdev = sigma_clip(arr, niter=4, nsig=4, extra={})\r\n    \r\n    INPUTS:\r\n      arr: A numpy array or a sequence that can be converted.\r\n\r\n    OPTIONAL INPUTS:\r\n      niter: number of iterations, defaults to 4\r\n      nsig: number of sigma, defaults to 4\r\n\r\n    OUTPUTS:\r\n      mean,stdev: A tuple containing mean and standard deviation.\r\n    OPTIONAL OUTPUTS\r\n      extra={}: Dictionary containing the array of used indices in\r\n         extra['index']\r\n\r\n    REVISION HISTORY:\r\n      Converted from IDL: 2006-10-23. Erin Sheldon, NYU\r\n\r\n   \"\"\"\r\n    arr = numpy.array(arrin, ndmin=1, copy=False)\r\n\r\n    index = numpy.arange( arr.size )\r\n\r\n    for i in numpy.arange(niter):\r\n        m = arr[index].mean()\r\n        s = arr[index].std()\r\n\r\n        if verbose:\r\n            sys.stdout.write('iter %s\\tnuse: %s\\tmean %s\\tstdev %s\\n' % \\\r\n                (i+1, index.size,m,s))\r\n\r\n        clip = nsig*s\r\n\r\n        w, = numpy.where( (numpy.abs(arr[index]) - m) < clip )\r\n\r\n        if w.size == 0:\r\n            sys.stderr.write(\"nsig too small. Everything clipped on iteration %d\" % i+1)\r\n            return m,s\r\n\r\n\r\n        index = index[w]\r\n\r\n    # Calculate final stats\r\n    amean = arr[index].mean()\r\n    asig = arr[index].std()\r\n\r\n    extra['index'] = index\r\n    return amean, asig"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconfigures application and setups logging.", "response": "def prepare_service(args=None):\n    \"\"\"Configures application and setups logging.\"\"\"\n    options.register_opts(cfg.CONF)\n    services.load_service_opts(cfg.CONF)\n    _configure(args)\n    _setup_logging()\n\n    cfg.CONF.log_opt_values(logging.getLogger(), logging.DEBUG)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef base64_encode(data):\n    total = len(data)\n    result = []\n    mod = 0\n    for i in range(total):\n        cur = ord(data[i])\n        mod = i % 3\n        if mod == 0:\n            result.append(__enc64__[cur >> 2])\n        elif mod == 1:\n            prev = ord(data[i - 1])\n            result.append(__enc64__[((prev & 3) << 4) | (cur >> 4)])\n        elif mod == 2:\n            prev = ord(data[i - 1])\n            result.append(__enc64__[(prev & 0x0f) << 2 | cur >> 6])\n            result.append(__enc64__[cur & 0x3f])\n    if mod == 0:\n        result.append(__enc64__[(cur & 3) << 4])\n        result.append(__enc64__[64] * 2)\n    elif mod == 1:\n        result.append(__enc64__[(cur & 0x0f) << 2])\n        result.append(__enc64__[64])\n    return \"\".join(result)", "response": "Base 64 encoder for a sequence of bytes."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbases 64 decoder for a sequence of bytes.", "response": "def base64_decode(data):\n    \"\"\"\n    Base 64 decoder\n    \"\"\"\n    data = data.replace(__enc64__[64], '')\n    total = len(data)\n    result = []\n    mod = 0\n    for i in range(total):\n        mod = i % 4\n        cur = __enc64__.index(data[i])\n        if mod == 0:\n            continue\n        elif mod == 1:\n            prev = __enc64__.index(data[i - 1])\n            result.append(chr(prev << 2 | cur >> 4))\n        elif mod == 2:\n            prev = __enc64__.index(data[i - 1])\n            result.append(chr((prev & 0x0f) << 4 | cur >> 2))\n        elif mod == 3:\n            prev = __enc64__.index(data[i - 1])\n            result.append(chr((prev & 3) << 6 | cur))\n\n    return \"\".join(result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the number of seconds that passed since self. started as float.", "response": "def get_timedelta(self, now=None):\n        \"\"\"\n        Returns number of seconds that passed since ``self.started``, as float.\n        None is returned if ``self.started`` was not set yet.\n        \"\"\"\n        def datetime_to_time(timestamp):\n            atime = time.mktime(timestamp.timetuple())\n            atime += timestamp.microsecond / 10.0**6\n            return atime\n        if self.started is not None:\n            now = now or datetime.datetime.now()\n            started_time = datetime_to_time(self.started)\n            now_time = datetime_to_time(now)\n            return now_time - started_time\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render(self):\n        elements = [self.render_element(e) for e in self.widgets]\n        progressbar = self.separator.join(elements)\n        width = get_terminal_width()\n        if width:\n            # leave last column for cursor\n            progressbar = progressbar.ljust(width - 1)\n        return progressbar", "response": "Returns the current s bar state as a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main(args, stop=False):\n    daemon = AMQPDaemon(\n        con_param=getConParams(\n            settings.RABBITMQ_ALEPH_LINK_EXPORT_VIRTUALHOST\n        ),\n        queue=settings.RABBITMQ_ALEPH_LINK_EXPORT_INPUT_QUEUE,\n        out_exch=settings.RABBITMQ_ALEPH_LINK_EXPORT_EXCHANGE,\n        out_key=settings.RABBITMQ_ALEPH_LINK_EXPORT_OUTPUT_KEY,\n        react_fn=reactToAMQPMessage,\n        glob=globals()                # used in deserializer\n    )\n\n    if not stop and args and args.foreground:  # run at foreground\n        daemon.run()\n    else:\n        daemon.run_daemon()", "response": "Main entry point for the Aleph link export."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstrip a prefix from a string if the string starts with the prefix.", "response": "def strip_prefix(string, strip):\n    \"\"\"\n    Strips a prefix from a string, if the string starts with the prefix.\n\n    :param string: String that should have its prefix removed\n    :param strip: Prefix to be removed\n    :return: string with the prefix removed if it has the prefix, or else it\n        just returns the original string\n    \"\"\"\n    import re\n    strip_esc = re.escape(strip)\n    if re.match(strip_esc, string):\n        return string[len(strip):]\n    else:\n        return string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngoing through a list of strings and removes the specified prefix from each string in place.", "response": "def strip_prefix_from_list(list, strip):\n    \"\"\"\n    Goes through a list of strings and removes the specified prefix from the\n    beginning of each string in place.\n\n    :param list: a list of strings to be modified in place\n    :param strip: a string specifying the prefix to remove from the list\n    \"\"\"\n    for i in range(len(list)):\n        list[i] = strip_prefix(list[i], strip)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates rates for Fx Forward based on others.", "response": "def calculate_rates(base_currency, counter_currency, forward_rate=None, fwd_points=None, spot_reference=None):\n    \"\"\"Calculate rates for Fx Forward based on others.\"\"\"\n    if base_currency not in DIVISOR_TABLE:\n        divisor = DIVISOR_TABLE.get(counter_currency, DEFAULT_DIVISOR)\n        if forward_rate is None and fwd_points is not None and spot_reference is not None:\n            forward_rate = spot_reference + fwd_points / divisor\n        elif forward_rate is not None and fwd_points is None and spot_reference is not None:\n            fwd_points = (forward_rate - spot_reference) * divisor\n        elif forward_rate is not None and fwd_points is not None and spot_reference is None:\n            spot_reference = forward_rate - fwd_points / divisor\n\n    rates = {}\n    if forward_rate is not None:\n        rates['forward_rate'] = forward_rate\n\n    if fwd_points is not None:\n        rates['fwd_points'] = fwd_points\n\n    if spot_reference is not None:\n        rates['spot_reference'] = spot_reference\n\n    return rates"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninterpolates the pointlist with gaps in the previous key.", "response": "def interpolate_using_previous(pointlist):\n    '''\n    Throw\n        InterpolationError\n            if a key has no non-null values\n\n    Return\n        pointlist without gaps\n    '''\n    pl = pointlist # alias\n    npl = [] # new, interpolated pointlist\n\n    if len(pl) < 1:\n        raise InterpolationError('Empty list cannot be interpolated')\n\n    first_nonnull = [None, None]\n\n    # Find first non-nulls\n    for i in [0, 1]:\n        for p in pl:\n            if p[i] is not None:\n                first_nonnull[i] = p[i]\n                break\n\n    if first_nonnull[0] == None or first_nonnull[1] == None:\n        # No good values found for every key\n        raise InterpolationError('No non-null values to interpolate against: ' + str(first_nonnull))\n\n    prev_nonnull = first_nonnull\n\n    for p in pl:\n        np = list(p)  # Copy point, this way we avoid modifying the original.\n        for k in [0, 1]:\n            if np[k] is None:\n                np[k] = prev_nonnull[k]\n            else:\n                prev_nonnull[k] = np[k]\n        npl.append(np)\n\n    return npl"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef finalise(output=None, figsize=None, tight=True, **kwargs):\n    import matplotlib.pyplot as plt\n\n    # Set figure size.\n    if figsize is not None:\n        plt.gcf().set_size_inches(*figsize)\n\n    # Set plot layout.\n    if tight:\n        plt.tight_layout()\n\n    if output is None:\n        plt.show()\n    else:\n        plt.savefig(output, **kwargs)\n        io.info(\"Wrote\", output)\n    plt.close()", "response": "Finalise a single object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ShowErrorBarCaps(ax):\n    for ch in ax.get_children():\n        if str(ch).startswith('Line2D'):\n            ch.set_markeredgewidth(1)\n            ch.set_markersize(8)", "response": "Show error bar caps on Seaborn axes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_class(self, instance, name=None):\n        prefix_name = name or instance.__class__.__name__\n\n        for e in dir(instance):\n            if e[0][0] != \"_\":\n                self.register_function(\n                    getattr(instance, e),\n                    name=\"%s.%s\" % (prefix_name, e)\n                )", "response": "Add all functions of a class - instance to the RPC - services."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef process_method(self, method, args, kwargs, request_id=None, **context):\n        return method(*([] if args is None else args), **({} if kwargs is None else kwargs))", "response": "Executes the actual method with args kwargs and request_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses a list of requests into a list of response objects.", "response": "def process_requests(self, requests, **context):\n        \"\"\"\n        Turns a list of request objects into a list of\n        response objects.\n\n        :param requests: A list of tuples describing the RPC call\n        :type requests: list[list[callable,object,object,list]]\n        :param context:\n            A dict with additional parameters passed to handle_request_string and process_requests\n            Allows wrapping code to pass additional parameters deep into parsing stack, override this\n            method and fold the parameters as needed into tha method call.\n            Imagine capturing authentication / permissions data from headers, converting them into\n            actionable / flag objects and putting them into **context.\n            Then override this method and fold the arguments into the call\n            (which may be a decorated function, where decorator unfolds the params and calls the actual method)\n            By default, context is not passed to method call below.\n        \"\"\"\n\n        ds = self._data_serializer\n\n        responses = []\n        for method, params, request_id, error in requests:\n\n            if error: # these are request message validation errors\n                if error.request_id: # no ID = Notification. We don't reply\n                    responses.append(ds.assemble_error_response(error))\n                continue\n\n            if method not in self:\n                if request_id:\n                    responses.append(ds.assemble_error_response(\n                        errors.RPCMethodNotFound(\n                            'Method \"%s\" is not found.' % method,\n                            request_id\n                        )\n                    ))\n                continue\n\n            try:\n                args = []\n                kwargs = {}\n                if isinstance(params, dict):\n                    kwargs = params\n                elif params: # and/or must be type(params, list):\n                    args = params\n                result = self.process_method(\n                    self[method],\n                    args,\n                    kwargs,\n                    request_id=request_id,\n                    **context\n                )\n                if request_id:\n                    responses.append(ds.assemble_response(result, request_id))\n            except errors.RPCFault as ex:\n                if request_id:\n                    responses.append(ds.assemble_error_response(ex))\n            except Exception as ex:\n                if request_id:\n                    responses.append(ds.assemble_error_response(\n                        errors.RPCInternalError(\n                            'While processing the follwoing message (\"%s\",\"%s\",\"%s\") ' % (method, params, request_id) +\\\n                            'encountered the following error message \"%s\"' % ex.message,\n                            request_id=request_id,\n                            message=ex.message\n                        )\n                    ))\n\n        return responses"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle a request string and return the JSON response.", "response": "def handle_request_string(self, request_string, **context):\n        \"\"\"Handle a RPC-Request.\n\n        :param request_string: the received rpc-string\n        :param context:\n            A dict with additional parameters passed to process_requests and process_method\n            Allows wrapping code to pass additional parameters deep into parsing stack, override process_method\n            method and fold the parameters as needed into tha method call.\n            Imagine capturing authentication / permissions data from headers, converting them into\n            actionable / flag objects and putting them into **context.\n            Then override this method and fold the arguments into the call\n            (which may be a decorated function, where decorator unfolds the params and calls the actual method)\n            By default, context is not passed to method call below.\n        :return: the encoded (serialized as string) JSON of the response\n        \"\"\"\n\n        ds = self._data_serializer\n\n        try:\n            requests, is_batch_mode = ds.parse_request(request_string)\n        except errors.RPCFault as ex:\n            return ds.json_dumps(ds.assemble_error_response(ex))\n        except Exception as ex:\n            return ds.json_dumps(ds.assemble_error_response(\n                errors.RPCInternalError(\n                    'While processing the follwoing message \"%s\" ' % request_string +\\\n                    'encountered the following error message \"%s\"' % ex.message\n                )\n            ))\n\n        responses = self.process_requests(requests, **context)\n\n        if not responses:\n            return None\n\n        try:\n            if is_batch_mode:\n                return ds.json_dumps(responses)\n            else:\n                return ds.json_dumps(responses[0])\n        except Exception as ex:\n            return json.dumps(\n                ds.assemble_error_response(\n                    errors.RPCInternalError(\n                        'While processing the follwoing message \"%s\" ' % request_string +\\\n                        'encountered the following error message \"%s\"' % ex.message\n                    )\n                )\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a Statistic object in the Tracker.", "response": "def track_statistic(self, name, description='', max_rows=None):\n        \"\"\"\n        Create a Statistic object in the Tracker.\n        \"\"\"\n        if name in self._tables:\n            raise TableConflictError(name)\n        if max_rows is None:\n            max_rows = AnonymousUsageTracker.MAX_ROWS_PER_TABLE\n        self.register_table(name, self.uuid, 'Statistic', description)\n        self._tables[name] = Statistic(name, self, max_rows=max_rows)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a State object in the Tracker.", "response": "def track_state(self, name, initial_state, description='', max_rows=None, **state_kw):\n        \"\"\"\n        Create a State object in the Tracker.\n        \"\"\"\n        if name in self._tables:\n            raise TableConflictError(name)\n        if max_rows is None:\n            max_rows = AnonymousUsageTracker.MAX_ROWS_PER_TABLE\n        self.register_table(name, self.uuid, 'State', description)\n        self._tables[name] = State(name, self, initial_state, max_rows=max_rows, **state_kw)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a Timer object in the Tracker.", "response": "def track_time(self, name, description='', max_rows=None):\n        \"\"\"\n        Create a Timer object in the Tracker.\n        \"\"\"\n        if name in self._tables:\n            raise TableConflictError(name)\n        if max_rows is None:\n            max_rows = AnonymousUsageTracker.MAX_ROWS_PER_TABLE\n        self.register_table(name, self.uuid, 'Timer', description)\n        self._tables[name] = Timer(name, self, max_rows=max_rows)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a Sequence object in the Tracker.", "response": "def track_sequence(self, name, checkpoints, description='', max_rows=None):\n        \"\"\"\n        Create a Sequence object in the Tracker.\n        \"\"\"\n        if name in self._tables:\n            raise TableConflictError(name)\n        if max_rows is None:\n            max_rows = AnonymousUsageTracker.MAX_ROWS_PER_TABLE\n        self.register_table(name, self.uuid, 'Sequence', description)\n        self._tables[name] = Sequence(name, self, checkpoints, max_rows=max_rows)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef submit_statistics(self):\n        if not self._hq.get('api_key', False) or not self._enabled:\n            return\n        for r in ('uuid', 'application_name', 'application_version'):\n            if not getattr(self, r, False):\n                return False\n        self['__submissions__'] += 1\n\n        try:\n            # To ensure the usage tracker does not interfere with script functionality, catch all exceptions so any\n            # errors always exit nicely.\n            tableinfo = self.get_table_info()\n            # Get the last row from each table\n            json_data = database_to_json(self.dbcon_master, tableinfo)\n            json_data.update(database_to_json(self.dbcon_part, tableinfo))\n\n            payload = {'API Key': self._hq['api_key'],\n                       'User Identifier': self.uuid,\n                       'Application Name': self.application_name,\n                       'Application Version': self.application_version,\n                       'Data': json_data\n                       }\n\n            # For tables with data that has not yet been writen to the database (ie inital values),\n            # add them manually to the payload\n            for name, info in tableinfo.iteritems():\n                if name not in payload['Data']:\n                    table = self[name]\n                    if table is None:\n                        continue\n                    if isinstance(table, State):\n                        data = 'No State' if table._state == NO_STATE else table._state\n                    else:\n                        data = table.count\n                    tableinfo[name]['data'] = data\n                    payload['Data'][name] = tableinfo[name]\n\n            try:\n                response = requests.post(self._hq['host'] + '/usagestats/upload',\n                                         data=json.dumps(payload),\n                                         timeout=self.HQ_DEFAULT_TIMEOUT)\n            except Exception as e:\n                logging.error(e)\n                response = False\n\n            if response and response.status_code == 200:\n                success = True\n                logger.debug('Submission to %s successful.' % self._hq['host'])\n            else:\n                success = False\n\n            # If we have a partial database, merge it into the local master and create a new partial\n            if self.dbcon_part and success:\n                merge_databases(self.dbcon_master, self.dbcon_part)\n\n                # Clear the partial database now that the stats have been uploaded\n                for table in get_table_list(self.dbcon_part):\n                    clear_table(self.dbcon_part, table)\n\n            return success\n        except Exception as e:\n            logger.error(e)\n            self['__submissions__'].delete_last()\n            self.stop_watcher()\n            return False", "response": "Submit statistics to the FTP server."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a CSV file for the latest usage stats.", "response": "def database_to_csv(self, path, orderby='type'):\n        \"\"\"\n        Create a CSV file for the latest usage stats.\n        :param path: path to output CSV file\n        :param dbconn_master: master database connection\n        :param dbconn_part: partial database connection\n        :param tableinfo: table header information\n        \"\"\"\n        tableinfo = self.get_table_info()\n        stats_master = database_to_json(self.dbcon_master, tableinfo)\n        stats_partial = database_to_json(self.dbcon_part, tableinfo)\n        with open(path, 'w') as f:\n            csvfile = csv.writer(f)\n            csvfile.writerow(['Name', 'Type', 'Value', 'Description'])\n            rows = []\n            for tablename, info in tableinfo.iteritems():\n                # Attempt to get the latest stat (from partial), if it doesn't exist get it from master\n                value = stats_partial.get(tablename, {}).get('data', ValueError) or stats_master.get(tablename, {}).get('data', ValueError)\n                if value is ValueError:\n                    # The trackable was registered but no table values are found\n                    value = self[tablename].current_value\n                    if value is NO_STATE:\n                        value = 'No Initial State'\n\n                rows.append([tablename, info['type'], value, info['description']])\n\n            if orderby == 'type':\n                rows.sort(key=lambda x: x[1]) # Sort by type\n            elif orderby == 'name':\n                rows.sort(key=lambda x: x[0])  # Sort by type\n            csvfile.writerows(rows)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a CSV report of the trackables.", "response": "def to_file(self, path, precision='%.2g'):\n        \"\"\"\n        Create a CSV report of the trackables\n        :param path: path to file\n        :param precision: numeric string formatter\n        \"\"\"\n        table_info = self.get_table_info()\n\n        def dump_rows(rows):\n            if len(rows) > 1:\n                for row in rows:\n                    csv_writer.writerow(row)\n                csv_writer.writerow([])\n\n        with open(path, 'wb') as _f:\n            csv_writer = csv.writer(_f)\n\n            state_rows = [['States']]\n            state_rows += [['Name', 'Description', 'State', 'Number of Changes']]\n            for state in self.states:\n                state_rows.append([state.name, table_info[state.name]['description'], state.state, state.count])\n            dump_rows(state_rows)\n\n            stat_rows = [['Statistics']]\n            stat_rows += [['Name', 'Description', 'Total', 'Average']]\n            for stat in self.statistics:\n                if stat.name == '__submissions__':\n                    continue\n                stat_rows.append([stat.name, table_info[stat.name]['description'], stat.count, stat.get_average(0)])\n                dump_rows(stat_rows)\n\n            timer_rows = [['Timers']]\n            timer_rows += [['Name', 'Description', 'Average Seconds', 'Total Seconds', 'Total Minutes', 'Total Hours', 'Total Days']]\n            for timer in self.timers:\n                timer_rows.append([timer.name, table_info[timer.name]['description'],\n                                   precision % timer.get_average(0), precision % timer.total_seconds, precision % timer.total_minutes,\n                                   precision % timer.total_hours, precision % timer.total_days])\n                dump_rows(timer_rows)\n\n            sequence_rows = [['Sequences']]\n            sequence_rows += [['Name', 'Description', 'Sequence', 'Number of Completions']]\n            for sequence in self.sequences:\n                checkpoints = '-->'.join(map(str, sequence.get_checkpoints()))\n                sequence_rows.append([sequence.name, table_info[sequence.name]['description'], checkpoints, sequence.count])\n                dump_rows(sequence_rows)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_from_configuration(cls, path, uuid, **kwargs):\n        cfg = ConfigParser.ConfigParser()\n        kw = {}\n        with open(path, 'r') as _f:\n            cfg.readfp(_f)\n            if cfg.has_section('General'):\n                general = dict(cfg.items('General'))\n                kw['filepath'] = kwargs.get('filepath', False) or general['filepath']\n                kw['application_name'] = general.get('application_name', '')\n                kw['application_version'] = general.get('application_version', '')\n                kw['submit_interval_s'] = int(general.get('submit_interval_s', 0))\n                kw['check_interval_s'] = int(general.get('check_interval_s', 0))\n                kw['debug'] = bool(general.get('debug', False))\n\n            if cfg.has_section('HQ'):\n                hq_params = dict(cfg.items('HQ'))\n            else:\n                hq_params = None\n\n        kw.update(**kwargs)\n        tracker = cls(uuid, **kw)\n        if hq_params:\n            tracker.setup_hq(**hq_params)\n\n        return tracker", "response": "Load FTP server credentials from a configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start_watcher(self):\n        if self._watcher and self._watcher.is_alive:\n            self._watcher_enabled = True\n        else:\n            logger.debug('Starting watcher.')\n            self._watcher = threading.Thread(target=self._watcher_thread, name='usage_tracker')\n            self._watcher.setDaemon(True)\n            self._watcher_enabled = True\n            self._watcher.start()", "response": "Start the watcher thread that tries to upload usage statistics."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _requires_submission(self):\n        if self.dbcon_part is None:\n            return False\n\n        tables = get_table_list(self.dbcon_part)\n        nrows = 0\n        for table in tables:\n            if table == '__submissions__':\n                continue\n            nrows += get_number_of_rows(self.dbcon_part, table)\n        if nrows:\n            logger.debug('%d new statistics were added since the last submission.' % nrows)\n        else:\n            logger.debug('No new statistics were added since the last submission.')\n\n        t0 = datetime.datetime.now()\n        s = self['__submissions__']\n        last_submission = s.get_last(1)\n        if last_submission:\n            logger.debug('Last submission was %s' % last_submission[0]['Time'])\n            t_ref = datetime.datetime.strptime(last_submission[0]['Time'], Table.time_fmt)\n        else:\n            t_ref = datetime.datetime.fromtimestamp(os.path.getmtime(self.filepath))\n\n        submission_interval_passed = (t0 - t_ref).total_seconds() > self.submit_interval_s\n        submission_required = bool(submission_interval_passed and nrows)\n        if submission_required:\n            logger.debug('A submission is overdue.')\n        else:\n            logger.debug('No submission required.')\n        return submission_required", "response": "Returns True if the time since the last submission is greater than the submission interval."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _catchall_enabled(app):\n    while hasattr(app, 'app'):\n        if isinstance(app, bottle.Bottle):\n            break\n        app = app.app\n    if hasattr(app, 'catchall'):\n        return app.catchall\n    else:\n        return bottle.default_app().catchall", "response": "Check the bottle app for catchall."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef line_cont_after_delim(ctx, s, line_len=40, delim=(',',),\n                          line_cont_token='&'):\n    \"\"\"\n    Insert newline (with preceeding `line_cont_token`) afer\n    passing over a delimiter after traversing at least `line_len`\n    number of characters\n\n    Mako convenience function. E.g. fortran does not\n    accpet lines of arbitrary length.\n    \"\"\"\n    last = -1\n    s = str(s)\n    for i, t in enumerate(s):\n        if t in delim:\n            if i > line_len:\n                if last == -1:\n                    raise ValueError(\n                        'No delimiter until already past line_len')\n                i = last\n                return s[:i+1] + line_cont_token + '\\n ' + \\\n                    line_cont_after_delim(\n                        ctx, s[i+1:], line_len, delim)\n            last = i\n    return s", "response": "A convenience function that returns a string that is a line of length line_len with a delimiter after traversing at least line_len characters."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\napplies changes in SOURCE_FILENAME that were made since last commit, where possible. Limit application to TARGET_FILENAME(s) if specified. Files that conflict in their entirety will be skipped. Smaller conflicts will be written to the file as conflict sections. In interactive mode, you can use the following commands: y - include this change n - do not include this change a - include this change and all remaining changes d - done, do not include this change nor any remaining changes j - leave this change undecided, see next undecided change k - leave this change undecided, see previous undecided change ? - interactive apply mode help", "response": "def apply(*args):\n    \"\"\"\n    Apply changes in SOURCE_FILENAME that were made since last commit, where possible.\n    Limit application to TARGET_FILENAME(s) if specified.\n    Files that conflict in their entirety will be skipped.\n    Smaller conflicts will be written to the file as conflict sections.\n\n    In interactive mode, you can use the following commands:\n\n        y - include this change\n        n - do not include this change\n        a - include this change and all remaining changes\n        d - done, do not include this change nor any remaining changes\n        j - leave this change undecided, see next undecided change\n        k - leave this change undecided, see previous undecided change\n        ? - interactive apply mode help\n    \"\"\"\n    parser = argparse.ArgumentParser(prog=\"%s %s\" % (__package__, apply.__name__), description=apply.__doc__)\n    parser.add_argument('SOURCE_FILENAME', help=\"file containing changes to be applied\")\n    parser.add_argument('TARGET_FILENAME', help=\"file(s) to apply changes to\", nargs='*', default=['.'])\n    parser.add_argument('-U', '--unified', type=int, dest=\"NUM\", default=3, action=\"store\", help=\"number of lines of context to show\")\n    group = parser.add_mutually_exclusive_group()\n    group.add_argument(\"-i\", \"--interactive\", action=\"store_true\" , default=True , dest=\"interactive\", help=\"interactively select changes to apply\")\n    group.add_argument(\"-a\", \"--automatic\"  , action=\"store_false\", default=False, dest=\"interactive\", help=\"automatically apply all changes\")\n    args = parser.parse_args(args)\n\n    config = FragmentsConfig()\n    weave = Weave()\n    changed_path = os.path.realpath(args.SOURCE_FILENAME)\n    changed_key = os.path.relpath(changed_path, config.root)\n    if changed_key not in config['files']:\n        yield \"Could not apply changes in '%s', it is not being followed\" % os.path.relpath(changed_path)\n        return\n    elif not os.access(changed_path, os.R_OK|os.W_OK):\n        yield \"Could not apply changes in '%s', it no longer exists on disk\" % os.path.relpath(changed_path)\n        return\n\n    old_path = os.path.join(config.directory, config['files'][changed_key])\n\n    if not os.access(old_path, os.R_OK|os.W_OK):\n        yield \"Could not apply changes in '%s', it has never been committed\" % os.path.relpath(changed_path)\n        return\n\n    old_revision = 1\n    with _smart_open(old_path, 'r') as old_file:\n        weave.add_revision(old_revision, old_file.readlines(), [])\n    new_revision = 2\n    with _smart_open(changed_path, 'r') as new_file:\n        weave.add_revision(new_revision, new_file.readlines(), [])\n\n    diff = weave.merge(old_revision, new_revision)\n\n    # Select the chunks to be applied, possibly interactively\n    preserve_changes = {}\n    discard_changes = {}\n    display_groups = list(_split_diff(diff, context_lines=args.NUM))\n    index = 0\n    apply_all = None\n    while display_groups:\n        display_group = display_groups[index]\n        if apply_all is None:\n            for dl in _diff_group(display_group):\n                yield dl\n        while True:\n            if args.interactive and apply_all is None:\n                response = (yield Prompt(\"Apply this change? [ynadjk?]\"))\n                if not response:\n                    continue\n                response = response.lower()\n            if not args.interactive or response.startswith('y') or apply_all is True:\n                for old_line, new_line, line_or_conflict in display_group:\n                    if isinstance(line_or_conflict, tuple):\n                        preserve_changes[(old_line, new_line)] = line_or_conflict\n                display_groups.pop(index)\n                break\n            elif response.startswith('n') or apply_all is False:\n                for old_line, new_line, line_or_conflict in display_group:\n                    if isinstance(line_or_conflict, tuple):\n                        discard_changes[(old_line, new_line)] = line_or_conflict\n                display_groups.pop(index)\n                break\n            elif response == 'j':\n                index = (index + 1) % len(display_groups)\n                break\n            elif response == 'k':\n                index = (index - 1) % len(display_groups)\n                break\n            elif response == 'a':\n                index = 0\n                apply_all = True\n                break\n            elif response == 'd':\n                index = 0\n                apply_all = False\n                break\n            elif response == '?':\n                for l in apply.__doc__.split('\\n')[-8:-1]:\n                    yield l.strip()\n\n    if not preserve_changes:\n        yield \"No changes in '%s' to apply.\" % os.path.relpath(changed_path)\n        return\n\n    # Build the changed file to be applied\n    changes_to_apply = []\n\n    i = 0\n    old_line = 0\n    new_line = 0\n    while i < len(diff):\n        line_or_conflict = diff[i]\n        if isinstance(line_or_conflict, tuple):\n            old, new = line_or_conflict\n            if (old_line, new_line) in preserve_changes:\n                changes_to_apply.extend(new)\n            elif (old_line, new_line) in discard_changes:\n                changes_to_apply.extend(old)\n            else:  # pragma: no cover\n                raise Exception(\"Catastrophic error in selecting diff chunks. Please report a bug.\")\n            old_line += len(old)\n            new_line += len(new)\n            i += 1\n        else:\n            old_line += 1\n            new_line += 1\n            i += 1\n            changes_to_apply.append(line_or_conflict)\n\n    # Apply the changes across other files\n    current_revision = changed_revision = 3\n    weave.add_revision(changed_revision, changes_to_apply, [1])\n\n    for s, other_path in _iterate_over_files(args.TARGET_FILENAME, config, statuses='MAD '):\n        if other_path == changed_path:\n            continue  # don't try to apply changes to ourself\n        current_revision += 1\n        with _smart_open(other_path, 'r') as other_file:\n            weave.add_revision(current_revision, other_file.readlines(), [])\n        merge_result = weave.cherry_pick(changed_revision, current_revision)  # Can I apply changes in changed_revision onto this other file?\n        if len(merge_result) == 1 and isinstance(merge_result[0], tuple):\n            # total conflict, skip\n            yield \"Changes in '%s' cannot apply to '%s', skipping\" % (os.path.relpath(changed_path), os.path.relpath(other_path))\n        elif tuple in set(type(mr) for mr in merge_result):\n            # some conflicts exist\n            with _smart_open(other_path, 'w') as other_file:\n                for line_or_conflict in merge_result:\n                    if isinstance(line_or_conflict, tuple):\n                        other_file.write('>'*7 + '\\n')\n                        for line in line_or_conflict[0]:\n                            other_file.write(line)\n                        other_file.write('='*7 + '\\n')\n                        for line in line_or_conflict[1]:\n                            other_file.write(line)\n                        other_file.write('>'*7 + '\\n')\n                    else:\n                        other_file.write(line_or_conflict)\n            yield \"Conflict merging '%s' into '%s'\" % (os.path.relpath(changed_path), os.path.relpath(other_path))\n        else:\n            # Merge is clean:\n            with _smart_open(other_path, 'w') as other_file:\n                other_file.writelines(merge_result)\n            yield \"Changes in '%s' applied cleanly to '%s'\" % (os.path.relpath(changed_path), os.path.relpath(other_path))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlaunching cmd and treat its stdout as a file object", "response": "def cmd_as_file(cmd, *args, **kwargs):\n    \"\"\"Launch `cmd` and treat its stdout as a file object\"\"\"\n    kwargs['stdout'] = subprocess.PIPE\n    stdin = kwargs.pop('stdin', None)\n    if isinstance(stdin, basestring):\n        with tempfile.TemporaryFile() as stdin_file:\n            stdin_file.write(stdin)\n            stdin_file.seek(0)\n            kwargs['stdin'] = stdin_file\n            p = subprocess.Popen(cmd, *args, **kwargs)\n    else:\n        p = subprocess.Popen(cmd, *args, **kwargs)\n    try:\n        yield p.stdout\n    finally:\n        p.stdout.close()\n        if p.wait():\n            raise subprocess.CalledProcessError(p.returncode, cmd)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the list of tables in the database", "response": "def tables(self):\r\n        \"\"\"Return the list of table names in the database\"\"\"\r\n        tables = []\r\n        self.cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\r\n        for table_info in self.cursor.fetchall():\r\n            if table_info[0] != 'sqlite_sequence':\r\n                tables.append(table_info[0])\r\n        return tables"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nopening an existing database", "response": "def open(self):\r\n        \"\"\"Open an existing database\"\"\"\r\n        if self._table_exists():\r\n            self.mode = \"open\"\r\n            # get table info\r\n            self._get_table_info()\r\n            return self\r\n        else:\r\n            # table not found\r\n            raise IOError,\"Table %s doesn't exist\" %self.name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_table_info(self):\r\n        self.fields = []\r\n        self.field_info = {}\r\n        self.cursor.execute('PRAGMA table_info (%s)' %self.name)\r\n        for field_info in self.cursor.fetchall():\r\n            fname = field_info[1].encode('utf-8')\r\n            self.fields.append(fname)\r\n            ftype = field_info[2].encode('utf-8')\r\n            info = {'type':ftype}\r\n            # can be null ?\r\n            info['NOT NULL'] = field_info[3] != 0\r\n            # default value\r\n            default = field_info[4]\r\n            if isinstance(default,unicode):\r\n               default = guess_default_fmt(default)\r\n            info['DEFAULT'] = default\r\n            self.field_info[fname] = info", "response": "Inspect the base to get field names"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef conv(self,field_name,conv_func):\r\n        if field_name not in self.fields:\r\n            raise NameError,\"Unknown field %s\" %field_name\r\n        self.conv_func[field_name] = conv_func", "response": "When a record is returned by a SELECT ask conversion of\r\n            specified field value with the specified function"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef insert(self,*args,**kw):\r\n        if args:\r\n            kw = dict([(f,arg) for f,arg in zip(self.fields,args)])\r\n\r\n        ks = kw.keys()\r\n        s1 = \",\".join(ks)\r\n        qm = ','.join(['?']*len(ks))\r\n        sql = \"INSERT INTO %s (%s) VALUES (%s)\" %(self.name,s1,qm)\r\n        self.cursor.execute(sql,kw.values())\r\n        # return last row id\r\n        return self.cursor.lastrowid", "response": "Insert a record in the database Returns the record identifier"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self,removed):\r\n        sql = \"DELETE FROM %s \" %self.name\r\n        if isinstance(removed,dict):\r\n            # remove a single record\r\n            _id = removed['__id__']\r\n            sql += \"WHERE rowid = ?\"\r\n            args = (_id,)\r\n        else:\r\n            # convert iterable into a list (to be able to sort it)\r\n            removed = [ r for r in removed ]\r\n            if not removed:\r\n                return 0\r\n            args = [ r['__id__'] for r in removed ]\r\n            sql += \"WHERE rowid IN (%s)\" %(','.join(['?']*len(args)))\r\n        self.cursor.execute(sql,args)\r\n        return len(removed)", "response": "Remove a single record or the records in an iterable\r\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self,record,**kw):\r\n        vals = self._make_sql_params(kw)\r\n        sql = \"UPDATE %s SET %s WHERE rowid=?\" %(self.name,\r\n            \",\".join(vals))\r\n        self.cursor.execute(sql,kw.values()+[record['__id__']])", "response": "Update the record with new keys and values"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _make_sql_params(self,kw):\r\n        return ['%s=?' %k for k in kw.keys() ]\r\n        for k,v in kw.iteritems():\r\n            vals.append('%s=?' %k)\r\n        return vals", "response": "Make a list of strings to pass to an SQL statement\r\n            from the dictionary kw with Python types"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _make_record(self,row):\r\n        res = dict(zip(['__id__']+[f for f in self.fields],row))\r\n        for field_name in self.conv_func:\r\n            res[field_name] = self.conv_func[field_name](res[field_name])\r\n        return res", "response": "Make a record dictionary from the result of a fetch_"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __initialize_ui(self):\n\n        self.setAutoScroll(True)\n        self.setIndentation(self.__tree_view_indentation)\n        self.setRootIsDecorated(False)\n        self.setDragDropMode(QAbstractItemView.DragOnly)\n\n        self.header().hide()\n\n        self.setSortingEnabled(True)\n        self.sortByColumn(0, Qt.AscendingOrder)\n\n        self.__set_default_ui_state()\n\n        # Signals / Slots.\n        self.model().modelReset.connect(self.__set_default_ui_state)", "response": "Initializes the Widget ui."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setModel(self, model):\n\n        LOGGER.debug(\"> Setting '{0}' model.\".format(model))\n\n        if not model:\n            return\n\n        umbra.ui.views.Abstract_QTreeView.setModel(self, model)", "response": "Set the model of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef faasport(func: Faasport) -> Faasport:\n    global user_faasport\n\n    if user_faasport is not None:\n        raise RuntimeError('Multiple definitions of faasport.')\n\n    user_faasport = func\n    return func", "response": "Decorator that registers the user s faasport function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch for the key = True case and confirm no more than one parameter has that property.", "response": "def _find_parameter(cls, dct):\n        '''Search for the 'key=True' case, and confirm no more than one parameter has that property.'''\n\n        num_found = 0\n        field = None\n\n        for key, val in dct.iteritems():\n            if isinstance(val, DataType) and val.is_key:\n                field = key\n                num_found += 1\n\n        if num_found > 1:\n            raise SetupError(502)\n        elif num_found == 0:\n            return False\n\n        dct['_cbs_key_field'] = field\n        dct['key'] = cls._build_prop(field)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef uri(self):\n        if self.__modified:\n            self.__uri = self.__parse_uri()\n\n        return self.__uri", "response": "Return the URI of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef uri(self, value):\n        if value == self.__uri:\n            return\n\n        match = URI_REGEX.match(value)\n        if match is None:\n            raise ValueError('Unable to match URI from `{}`'.format(value))\n\n        for key, value in match.groupdict().items():\n            setattr(self, key, value)", "response": "Attempt to validate URI and split into individual values"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __parse_uri(self):\n        if self.scheme:\n            scheme = '{}://'.format(self.scheme)\n        else:\n            scheme = ''\n\n        credentials = self.username or ''\n        password = self.password or ''\n\n        if credentials and password:\n            credentials = self.username + ':' + self.password\n        if credentials:\n            credentials += '@'\n\n        if self.port:\n            location = '{}:{}'.format(self.host, self.port)\n        else:\n            location = self.host\n\n        path = self.path or ''\n\n        if self.query:\n            query = '?' + self.query\n        else:\n            query = ''\n\n        if self.fragment:\n            fragment = '#' + self.fragment\n        else:\n            fragment = ''\n\n        return scheme + credentials + location + path + query + fragment", "response": "Parse complete URI from all values"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_path(target, path, value, separator='/'):\n    parts = path.split(separator)\n    current = target\n    for part in parts[:-1]:\n        if part not in current:\n            current[part] = current = {}\n        else:\n            current = current[part]\n    current[parts[-1]] = value", "response": "Writes a value deep into a dict building any intermediate keys."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading a value from a dict supporting a deep path as a key.", "response": "def read_path(source, path, separator='/'):\n    \"\"\"Read a value from a dict supporting a deep path as a key.\n\n    :param source: a dict to read data from\n    :param path: a key or path to a key (path is delimited by `separator`)\n    :keyword separator: the separator used in the path (ex. Could be \".\" for a\n        json/mongodb type of value)\n    \"\"\"\n    parts = path.strip(separator).split(separator)\n    current = source\n    for part in parts[:-1]:\n        if part not in current:\n            return\n        current = current[part]\n        if not isinstance(current, dict):\n            return\n    return current.get(parts[-1])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks a dict for the existence of a value given a path to it.", "response": "def path_exists(source, path, separator='/'):\n    \"\"\"Check a dict for the existence of a value given a path to it.\n\n    :param source: a dict to read data from\n    :param path: a key or path to a key (path is delimited by `separator`)\n    :keyword separator: the separator used in the path (ex. Could be \".\" for a\n        json/mongodb type of value)\n    \"\"\"\n    if path == separator and isinstance(source, dict):\n        return True\n    parts = path.strip(separator).split(separator)\n    if not parts:\n        return False\n    current = source\n    for part in parts:\n        if not isinstance(current, dict):\n            return False\n        if part not in current:\n            return False\n        current = current[part]\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef split_dict(data, filter_keys=None):  # flake8: noqa\n    def key_match(key, filter_keys):\n        \"\"\"Determine whether or not key is in filter_keys.\"\"\"\n        if key in filter_keys:\n            return True\n        if key is None:\n            return False\n        for reg_expr in [pattern for pattern in filter_keys\n                         if hasattr(pattern, \"search\")\n                         and callable(getattr(pattern, \"search\"))]:\n            if reg_expr.search(key):\n                return True\n        return False\n\n    def recursive_split(data, filter_keys=None):\n        \"\"\"Return split dict or list if it contains any matching fields.\"\"\"\n        if filter_keys is None:  # Safer than default value\n            filter_keys = []\n        clean = None\n        matching = None\n        has_matching_data = False\n        has_clean_data = False\n        if isinstance(data, list):\n            clean = []\n            matching = []\n            for value in data:\n                if isinstance(value, dict):\n                    clean_value, matching_value = recursive_split(\n                        value, filter_keys=filter_keys)\n                    if matching_value is not None:\n                        matching.append(matching_value)\n                        has_matching_data = True\n                    else:\n                        matching.append({})  # placeholder\n                    if clean_value is not None:\n                        clean.append(clean_value)\n                        has_clean_data = True\n                    else:\n                        clean.append({})  # placeholder\n                elif isinstance(value, list):\n                    clean_value, matching_value = recursive_split(\n                        value, filter_keys=filter_keys)\n                    if matching_value is not None:\n                        matching.append(matching_value)\n                        has_matching_data = True\n                    else:\n                        matching.append([])  # placeholder\n                    if clean_value is not None:\n                        clean.append(clean_value)\n                        has_clean_data = True\n                    else:\n                        clean.append([])\n                else:\n                    clean.append(value)\n                    matching.append(None)  # placeholder\n                    has_clean_data = True\n        elif isinstance(data, dict):\n            clean = {}\n            matching = {}\n            for key, value in data.items():\n                if key_match(key, filter_keys):\n                    has_matching_data = True\n                    matching[key] = value\n                elif isinstance(value, dict):\n                    clean_value, matching_value = recursive_split(\n                        value, filter_keys=filter_keys)\n                    if matching_value is not None:\n                        has_matching_data = True\n                        matching[key] = matching_value\n                    if clean_value is not None:\n                        has_clean_data = True\n                        clean[key] = clean_value\n                elif isinstance(value, list):\n                    clean_value, matching_value = recursive_split(\n                        value, filter_keys=filter_keys)\n                    if matching_value is not None:\n                        has_matching_data = True\n                        matching[key] = matching_value\n                    if clean_value is not None:\n                        has_clean_data = True\n                        clean[key] = clean_value\n                else:\n                    has_clean_data = True\n                    clean[key] = value\n        if has_matching_data:\n            if has_clean_data:\n                return clean, matching\n            else:\n                return None, matching\n        else:\n            if has_clean_data:\n                return clean, None\n            else:\n                return data, None\n    clean, matching = recursive_split(data, filter_keys=filter_keys)\n    return clean, matching", "response": "Recursively split a dictionary into two dicts."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dict from a delimited string.", "response": "def kwarg(string, separator='='):\n    \"\"\"Return a dict from a delimited string.\"\"\"\n    if separator not in string:\n        raise ValueError(\"Separator '%s' not in value '%s'\"\n                         % (separator, string))\n    if string.strip().startswith(separator):\n        raise ValueError(\"Value '%s' starts with separator '%s'\"\n                         % (string, separator))\n    if string.strip().endswith(separator):\n        raise ValueError(\"Value '%s' ends with separator '%s'\"\n                         % (string, separator))\n    if string.count(separator) != 1:\n        raise ValueError(\"Value '%s' should only have one '%s' separator\"\n                         % (string, separator))\n    key, value = string.split(separator)\n    return {key: value}"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprovides a more helpful message if there are too few arguments.", "response": "def error(self, message, print_help=False):\n        \"\"\"Provide a more helpful message if there are too few arguments.\"\"\"\n        if 'too few arguments' in message.lower():\n            target = sys.argv.pop(0)\n            sys.argv.insert(\n                0, os.path.basename(target) or os.path.relpath(target))\n            message = (\"%s. Try getting help with `%s --help`\"\n                       % (message, \" \".join(sys.argv)))\n        if print_help:\n            self.print_help()\n        else:\n            self.print_usage()\n        sys.stderr.write('\\nerror: %s\\n' % message)\n        sys.exit(2)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute a shell command locally.", "response": "def execute(command, cwd=None, strip=True):\n    \"\"\"Execute a shell command (containing no shell operators) locally.\n\n    If 'command' is a string, it will be split into args to be passed\n    to Popen. If 'command' is a list, it will be passed to Popen as is.\n\n    Returns the output from the command.\n\n    Raises SimplCalledProcessError on any non-zero exit status unless\n    an OSError (a common error when attempting Popen calls) is raised.\n\n    :param command:         shell command to be executed. if the value is\n                            a string, it will be split using shlex.split()\n                            to return a shell-like syntax as a list. if the\n                            value is a list, it will be passed directly to\n                            popen.\n    :param cwd:             The working directory will be changed\n                            to `cwd` before the command is executed. Note\n                            that this directory is not considered when\n                            searching the executable, so you can't specify\n                            the program's path relative to this argument.\n                            Value should not be quoted or shell escaped,\n                            since it is passed directly to os.chdir() by\n                            subprocess.Popen\n    :param strip:           Strip the output of whitespace using str.strip()\n    :returns:               The output of the command (stdout + stderr) if\n                            the returncode is zero, otherwise raises\n                            SimplCalledProcessError\n\n    Notes:\n    In this function, Popen is called with stderr=subprocess.STDOUT, which\n    sends all stderr to stdout.\n    \"\"\"\n    if isinstance(command, six.string_types):\n        cmd = shlex.split(command)\n        LOG.debug(\"Command after split: %s\", cmd)\n    elif isinstance(command, list):\n        cmd = command\n        command = \" \".join(cmd)\n    else:\n        raise TypeError(\"'command' should be a string or a list\")\n    LOG.debug(\"Executing `%s` on local machine\", command)\n    if cwd:\n        cwd = pipes.quote(cwd)\n    pope = subprocess.Popen(\n        cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=cwd,\n        universal_newlines=True)\n    out, err = pope.communicate()\n    assert not err\n    out = out.strip() if strip else out\n    if pope.returncode != 0:\n        raise exceptions.SimplCalledProcessError(\n            pope.returncode, command, output=out)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstarting the OpenID authentication process.", "response": "def startOpenID(request):\n    \"\"\"\n    Start the OpenID authentication process.  Renders an\n    authentication form and accepts its POST.\n\n    * Renders an error message if OpenID cannot be initiated\n\n    * Requests some Simple Registration data using the OpenID\n      library's Simple Registration machinery\n\n    * Generates the appropriate trust root and return URL values for\n      this application (tweak where appropriate)\n\n    * Generates the appropriate redirect based on the OpenID protocol\n      version.\n    \"\"\"\n    if request.POST:\n        # Start OpenID authentication (mojeid url)\n        openid_url = request.POST['openid_identifier']\n        c = getConsumer(request)\n        error = None\n\n        if request.session.has_key(Discovery.PREFIX + c.session_key_prefix):\n            del request.session[Discovery.PREFIX + c.session_key_prefix]\n\n        if not request.POST.has_key('ns'):\n            OpenIDServiceEndpoint.openid_type_uris = SERVICE_NS\n        else:\n            OpenIDServiceEndpoint.openid_type_uris = request.POST.getlist('ns')\n\n        try:\n            auth_request = c.begin(openid_url)\n        except DiscoveryFailure, e:\n            # Some other protocol-level failure occurred.\n            error = \"OpenID discovery error: %s\" % (str(e),)\n\n        if error:\n            # Render the page with an error.\n            return renderIndexPage(request, error=error)\n\n        # Add Simple Registration request information.  Some fields\n        # are optional, some are required.  It's possible that the\n        # server doesn't support sreg or won't return any of the\n        # fields.\n        if request.POST.has_key('sreg'):\n            sreg_request = sreg.SRegRequest(\n                optional=[], required=request.POST.getlist('sreg'))\n            auth_request.addExtension(sreg_request)\n\n        if True:  # request.POST.has_key('ax'):\n            # Add Attribute Exchange request information.\n            ax_request = ax.FetchRequest()\n            # XXX - uses myOpenID-compatible schema values, which are\n            # not those listed at axschema.org.\n            # for uri in request.POST.getlist('ax'):\n            for uri in AX_ATTRIBUTES:\n                ax_request.add(\n                    ax.AttrInfo(uri, required=True))\n            auth_request.addExtension(ax_request)\n\n        # Add PAPE request information.  We'll ask for\n        # phishing-resistant auth and display any policies we get in\n        # the response.\n        requested_policies = []\n        policy_prefix = 'policy_'\n        for k, v in request.POST.iteritems():\n            # print k,v\n            if k.startswith(policy_prefix):\n                policy_attr = k[len(policy_prefix):]\n                if policy_attr in PAPE_POLICIES:\n                    requested_policies.append(getattr(pape, policy_attr))\n\n        print requested_policies\n        if requested_policies:\n            pape_request = pape.Request(requested_policies)\n            auth_request.addExtension(pape_request)\n\n        # Compute the trust root and return URL values to build the\n        # redirect information.\n        trust_root = util.getViewURL(request, startOpenID)\n        return_to = util.getViewURL(request, finishOpenID)\n\n        # Send the browser to the server either by sending a redirect\n        # URL or by generating a POST form.\n        if auth_request.shouldSendRedirect():\n            url = auth_request.redirectURL(trust_root, return_to)\n            return HttpResponseRedirect(url)\n        else:\n            # Beware: this renders a template whose content is a form\n            # and some javascript to submit it upon page load.  Non-JS\n            # users will have to click the form submit button to\n            # initiate OpenID authentication.\n            form_id = 'openid_message'\n            form_html = auth_request.formMarkup(trust_root, return_to,\n                                                False, {'id': form_id})\n            return direct_to_template(\n                request, 'consumer/request_form.html', {'html': form_html})\n\n    return renderIndexPage(request)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfinish the OpenID authentication process.", "response": "def finishOpenID(request):\n    \"\"\"\n    Finish the OpenID authentication process.  Invoke the OpenID\n    library with the response from the OpenID server and render a page\n    detailing the result.\n    \"\"\"\n    result = {}\n\n    # Because the object containing the query parameters is a\n    # MultiValueDict and the OpenID library doesn't allow that, we'll\n    # convert it to a normal dict.\n\n    # OpenID 2 can send arguments as either POST body or GET query\n    # parameters.\n    request_args = util.normalDict(request.GET)\n    if request.method == 'POST':\n        request_args.update(util.normalDict(request.POST))\n\n    if request_args:\n        c = getConsumer(request)\n\n        # Get a response object indicating the result of the OpenID\n        # protocol.\n        return_to = util.getViewURL(request, finishOpenID)\n        response = c.complete(request_args, return_to)\n\n        # Get a Simple Registration response object if response\n        # information was included in the OpenID response.\n        sreg_response = {}\n        ax_items = {}\n        if response.status == consumer.SUCCESS:\n            sreg_response = sreg.SRegResponse.fromSuccessResponse(response)\n\n            ax_response = ax.FetchResponse.fromSuccessResponse(response)\n            if ax_response:\n                ax_items = ax_response.data\n\n        # Get a PAPE response object if response information was\n        # included in the OpenID response.\n        pape_response = None\n        if response.status == consumer.SUCCESS:\n            pape_response = pape.Response.fromSuccessResponse(response)\n\n            if not pape_response.auth_policies:\n                pape_response = None\n\n        # Map different consumer status codes to template contexts.\n        results = {\n            consumer.CANCEL:\n            {'message': 'OpenID authentication cancelled.'},\n\n            consumer.FAILURE:\n            {'error': 'OpenID authentication failed.'},\n\n            consumer.SUCCESS:\n            {'url': response.getDisplayIdentifier(),\n             'sreg_response': sreg_response and sreg_response.iteritems(),\n             'ax_response': ax_items.items(),\n             'pape': pape_response}\n        }\n\n        result = results[response.status]\n\n        print result\n        if not result.has_key(\"error\"):\n            data_array = [it[1][0] for it in result[\"ax_response\"]]\n            data = {\n                \"login\": None,\n                \"openid\": result[\"url\"],\n                \"first_name\": data_array[0],\n                \"last_name\": data_array[1],\n                \"email\": data_array[2],\n            }\n            return create_profil_from_ipenid(request, data)\n\n        if isinstance(response, consumer.FailureResponse):\n            # In a real application, this information should be\n            # written to a log for debugging/tracking OpenID\n            # authentication failures. In general, the messages are\n            # not user-friendly, but intended for developers.\n            result['failure_reason'] = response.message\n\n    return renderIndexPage(request, **result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef collect(self, file_paths):\n        for file_path in file_paths:\n            self._anchors[file_path], d = self.collect_single_file(file_path)\n            if len(d) > 0:\n                # There were duplicates found in the file\n                self._duplicate_tags[file_path] = d\n            self._reset_switches()\n        return self._anchors, self._duplicate_tags", "response": "This function returns two dictionaries that maps file_paths to the AnchorHub tags and lists that are used to generate duplicate tags."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncollect a single file from a list of lines and return a dictionary mapping AnchorHub tags to auto - generated anchors and a list of containing an entry for each duplicate tag.", "response": "def collect_single_file(self, file_path):\n        \"\"\"\n        Takes in a list of strings, usually the lines in a text file,\n        and collects the AnchorHub tags and auto-generated anchors for the\n        file according to the  Collector's converter, strategies, and switches\n\n        :param file_path: string file path of file to examine\n        :return: A dictionary mapping AnchorHub tags to auto-generated\n            anchors, and a list of containing an entry for each duplicate tag\n            found on the page.\n        \"\"\"\n        lines = FileToList.to_list(file_path)\n        file_anchors = {}\n        file_duplicates = []\n        for i in range(len(lines)):\n            # Flip any switches that are triggered by this line\n            self._try_switches(lines, i)\n            if self._no_switches_on():\n                for s in self._strategies:\n                    if s.test(lines, i):\n                        # This strategy found an anchor and knows how to parse\n                        tag, convert_me = s.get(lines, i)\n                        if tag in file_anchors:\n                            # Duplicate tag\n                            file_duplicates.append((tag, i + 1,\n                                                    file_anchors[tag]))\n                        else:\n                            anchor = self._converter(convert_me, file_anchors)\n                            file_anchors[tag] = anchor\n            self._arm_switches()\n        return file_anchors, file_duplicates"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _try_switches(self, lines, index):\n        for s in self._switches:\n            s.switch(lines, index)", "response": "Try to flip switches."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninstalling git - flow if not found", "response": "def install_gitflow():\n    \"\"\"Install git-flow if not found\"\"\"\n    if not run('which git-flow', hide=True, warn=True).ok:\n        run('wget --no-check-certificate -q -O /tmp/gitflow-installer.sh  https://raw.github.com/petervanderdoes/gitflow/develop/contrib/gitflow-installer.sh')\n        run('sudo bash /tmp/gitflow-installer.sh install stable')\n        run('rm /tmp/gitflow-installer.sh')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef next_release(major=False, minor=False, patch=True):\n\n    import semantic_version\n\n    prev = run('git describe --abbrev=0 --tags', warn=True, hide=True).stdout or '0.0.0'\n    ver = semantic_version.Version.coerce(prev.strip())\n    print('current version:', ver)\n    if major:\n        print('next major release:', ver.next_major())\n        return ver.next_major()\n    if minor:\n        print('next minor release:', ver.next_minor())\n        return ver.next_minor()\n    if patch:\n        print('next patch release:', ver.next_patch())\n        return ver.next_patch()\n    print('next release <undefined>')\n    return None", "response": "Get next release version by major minor or patch"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a oneline log iterator to a generator of strings.", "response": "def _iter_changelog(changelog):\n    \"\"\"Convert a oneline log iterator to formatted strings.\n\n    :param changelog: An iterator of one line log entries like\n        that given by _iter_log_oneline.\n    :return: An iterator over (release, formatted changelog) tuples.\n    \"\"\"\n    first_line = True\n    current_release = None\n    prev_msg = None\n\n    yield current_release, 'Changelog\\n=========\\n\\n'\n    for hash, tags, msg in changelog:\n\n        if prev_msg is None:\n            prev_msg = msg\n        else:\n            if prev_msg.lower() == msg.lower():\n                continue\n            else:\n                prev_msg = msg\n\n        if tags:\n            current_release = max(tags, key=pkg_resources.parse_version)\n            underline = len(current_release) * '-'\n            if not first_line:\n                yield current_release, '\\n'\n            yield current_release, (\n                '%(tag)s\\n%(underline)s\\n\\n' %\n                dict(tag=current_release, underline=underline))\n\n        if not msg.startswith('Merge '):\n            if msg.endswith('.'):\n                msg = msg[:-1]\n            yield current_release, '* %(msg)s\\n' % dict(msg=msg)\n        first_line = False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\niterate over the log entries.", "response": "def _iter_log_inner(debug):\n    \"\"\"Iterate over --oneline log entries.\n\n    This parses the output intro a structured form but does not apply\n    presentation logic to the output - making it suitable for different\n    uses.\n\n    :return: An iterator of (hash, tags_set, 1st_line) tuples.\n    \"\"\"\n    if debug:\n        print('Generating ChangeLog')\n\n    changelog = run('git log --oneline --decorate', hide=True).stdout.strip().decode('utf-8', 'replace')\n    for line in changelog.split('\\n'):\n        line_parts = line.split()\n        if len(line_parts) < 2:\n            continue\n        # Tags are in a list contained in ()'s. If a commit\n        # subject that is tagged happens to have ()'s in it\n        # this will fail\n        if line_parts[1].startswith('(') and ')' in line:\n            msg = line.split(')')[1].strip()\n        else:\n            msg = ' '.join(line_parts[1:])\n\n        if 'tag:' in line:\n            tags = set([\n                tag.split(',')[0]\n                for tag in line.split(')')[0].split('tag: ')[1:]])\n        else:\n            tags = set()\n\n        yield line_parts[0], tags, msg"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_changelog(debug=False):\n    changelog = _iter_log_oneline(debug)\n    if changelog:\n        changelog = _iter_changelog(changelog)\n    if not changelog:\n        return\n    if debug:\n        print('Writing ChangeLog')\n    new_changelog = os.path.join(os.path.curdir, 'ChangeLog')\n    # If there's already a ChangeLog and it's not writable, just use it\n    if (os.path.exists(new_changelog)\n            and not os.access(new_changelog, os.W_OK)):\n        return\n    with io.open(new_changelog, 'w', encoding='utf-8') as changelog_file:\n        for release, content in changelog:\n            changelog_file.write(content)", "response": "Write a changelog based on the git changelog."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npublishes packaged distributions to pypi index", "response": "def publish(idx=None):\n    \"\"\"Publish packaged distributions to pypi index\"\"\"\n    if idx is None:\n        idx = ''\n    else:\n        idx = '-r ' + idx\n    run('python setup.py register {}'.format(idx))\n    run('twine upload {} dist/*.whl dist/*.egg dist/*.tar.gz'.format(idx))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncleans up build files", "response": "def clean(all=False, docs=False, dist=False, extra=None):\n    \"\"\"Clean up build files\"\"\"\n\n    run('find . -type f -name \"*.py[co]\" -delete')\n    run('find . -type d -name \"__pycache__\" -delete')\n\n    patterns = ['build', '*.egg-info/']\n    if all or docs:\n        patterns.append('doc/build/*')\n    if all or dist:\n        patterns.append('dist')\n    if extra:\n        patterns.append(extra)\n    for pattern in patterns:\n        run('rm -rf {}'.format(pattern))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a unit to a set", "response": "def convert_to_set(unit):\n    \"\"\"\u5c06\u6587\u672c\u884c\u8f6c\u6362\u6210\u96c6\u5408\u5f62\u5f0f\n\n    Keyword arguments:\n    unit                    -- \u6587\u672c\u884c\n    Return:\n        set_unit            -- \u5207\u5206\u3001\u53bb\u505c\u8bcd\u3001\u53bb\u91cd\u540e\u7684\u6587\u672c\u884c\uff0clist\u7c7b\u578b\n    \"\"\"\n    w = WordSegmentation()\n    set_unit = set(w.segment(unit))\n    set_unit = [i for i in set_unit]\n    return set_unit"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_beta_list(queue, *args):\n    beta_list = []\n    for i in queue:\n        c = CDM(i)\n        beta_list.append(c.get_alpha(*args))\n    return beta_list", "response": "Get a list of beta from a queue"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef normalized(beta, beta_list):\n    if len(beta_list) <= 2:\n        # beta_list\u5143\u7d20\u5c0f\u4e8e\u7b49\u4e8e2\u65f6\uff0c\u6839\u636ejiaccard\u76f8\u4f3c\u5ea6\u516c\u5f0f\u8fdb\u884c\u5224\u5b9a\n        return 1\n    try:\n        result = (beta - min(beta_list)) / (max(beta_list) - min(beta_list))\n    except ZeroDivisionError:\n        result = 1\n    return result", "response": "Returns the normalized version of the beta parameter"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the margin attribute.", "response": "def margin(self, value):\n        \"\"\"\n        Setter for **self.__margin** attribute.\n\n        :param value: Attribute value.\n        :type value: int\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is int, \"'{0}' attribute: '{1}' type is not 'int'!\".format(\"margin\", value)\n            assert value > 0, \"'{0}' attribute: '{1}' need to be exactly positive!\".format(\"margin\", value)\n        self.__margin = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef background_color(self, value):\n\n        if value is not None:\n            assert type(value) is QColor, \"'{0}' attribute: '{1}' type is not 'QColor'!\".format(\n                \"background_color\", value)\n        self.__background_color = value", "response": "Sets the background color of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef separator_color(self, value):\n\n        if value is not None:\n            assert type(value) is QColor, \"'{0}' attribute: '{1}' type is not 'QColor'!\".format(\n                \"separator_color\", value)\n        self.__separator_color = value", "response": "Setter for **self. __separator_color** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndraws the current color for the entry.", "response": "def paintEvent(self, event):\n        \"\"\"\n        Reimplements the :meth:`QWidget.paintEvent` method.\n\n        :param event: Event.\n        :type event: QEvent\n        \"\"\"\n\n        def __set_bold(state):\n            \"\"\"\n            Sets the current painter font bold state.\n\n            :return: Definiton success.\n            :rtype: bool\n            \"\"\"\n\n            font = painter.font()\n            font.setBold(state)\n            painter.setFont(font)\n            return True\n\n        painter = QPainter(self)\n        painter.fillRect(event.rect(), self.__background_color)\n\n        pen = QPen(QBrush(), self.__separator_width)\n        pen.setColor(self.__separator_color)\n        painter.setPen(pen)\n        top_right_corner = event.rect().topRight()\n        bottom_right_corner = event.rect().bottomRight()\n        painter.drawLine(top_right_corner.x(), top_right_corner.y(), bottom_right_corner.x(), bottom_right_corner.y())\n        painter.setPen(self.__color)\n\n        viewport_height = self.__editor.viewport().height()\n        metrics = QFontMetrics(self.__editor.document().defaultFont())\n        current_block = self.__editor.document().findBlock(\n            self.__editor.textCursor().position())\n\n        block = self.__editor.firstVisibleBlock()\n        block_number = block.blockNumber()\n        painter.setFont(self.__editor.document().defaultFont())\n\n        while block.isValid():\n            block_number += 1\n            position = self.__editor.blockBoundingGeometry(block).topLeft() + self.__editor.contentOffset()\n            if position.y() > viewport_height:\n                break\n\n            if not block.isVisible():\n                continue\n\n            block == current_block and __set_bold(True) or __set_bold(False)\n            painter.drawText(\n                self.width() - metrics.width(foundations.strings.to_string(block_number)) - self.__margin / 3,\n                round(position.y() + metrics.ascent() + metrics.descent() -\n                      (self.__editor.blockBoundingRect(block).height() * 8.0 / 100)),\n                foundations.strings.to_string(block_number))\n            block = block.next()\n\n        painter.end()\n        QWidget.paintEvent(self, event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_width(self):\n\n        return self.__margin + \\\n               self.__editor.fontMetrics().width(foundations.strings.to_string(max(1, self.__editor.blockCount())))", "response": "Returns the Widget target width."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the given rectangle.", "response": "def update_rectangle(self, rectangle, scroll_y):\n        \"\"\"\n        Updates the given Widget rectangle.\n\n        :param rectangle: Rectangle to update.\n        :type rectangle: QRect\n        :param scroll_y: Amount of pixels the viewport was scrolled.\n        :type scroll_y: int\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if scroll_y:\n            self.scroll(0, scroll_y)\n        else:\n            self.update(0, rectangle.y(), self.width(), rectangle.height())\n\n        if rectangle.contains(self.__editor.viewport().rect()):\n            self.set_editor_viewport_margins(0)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the widget geometry.", "response": "def update_geometry(self):\n        \"\"\"\n        Updates the Widget geometry.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        self.setGeometry(self.__editor.contentsRect().left(),\n                         self.__editor.contentsRect().top(),\n                         self.get_width(),\n                         self.__editor.contentsRect().height())\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef indent_marker(self, value):\n\n        if value is not None:\n            assert type(value) is unicode, \"'{0}' attribute: '{1}' type is not 'unicode'!\".format(\n                \"indent_marker\", value)\n            assert re.search(r\"\\s\", value), \"'{0}' attribute: '{1}' is not a whitespace character!\".format(\n                \"indent_marker\", value)\n        self.__indent_marker = value", "response": "Sets the indent marker for the log entry."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef indent_width(self, value):\n\n        if value is not None:\n            assert type(value) is int, \"'{0}' attribute: '{1}' type is not 'int'!\".format(\"indent_width\", value)\n        self.__indent_width = value", "response": "Sets the indent_width attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef margin_area_LinesNumbers_widget(self, value):\n\n        if value is not None:\n            assert type(value) is LinesNumbers_QWidget, \\\n                \"'{0}' attribute: '{1}' type is not 'LinesNumbers_QWidget'!\".format(\"checked\", value)\n        self.__margin_area_LinesNumbers_widget = value", "response": "Setter for self. __margin_area_LinesNumbers_widget attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pre_input_accelerators(self, value):\n\n        if value is not None:\n            assert type(value) in (tuple, list), \"'{0}' attribute: '{1}' type is not 'tuple' or 'list'!\".format(\n                \"pre_input_accelerators\", value)\n        self.__pre_input_accelerators = value", "response": "Setter for **self. __pre_input_accelerators** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef post_input_accelerators(self, value):\n\n        if value is not None:\n            assert type(value) in (tuple, list), \"'{0}' attribute: '{1}' type is not 'tuple' or 'list'!\".format(\n                \"post_input_accelerators\", value)\n        self.__post_input_accelerators = value", "response": "Setter for **self. __post_input_accelerators** attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes the Widget ui.", "response": "def __initialize_ui(self):\n        \"\"\"\n        Initializes the Widget ui.\n        \"\"\"\n\n        self.__margin_area_LinesNumbers_widget = LinesNumbers_QWidget(self)\n\n        self.__set_extra_selections()\n\n        self.__set_language_description()\n\n        # Signals / Slots.\n        self.blockCountChanged.connect(self.__margin_area_LinesNumbers_widget.set_editor_viewport_margins)\n        self.updateRequest.connect(self.__margin_area_LinesNumbers_widget.update_rectangle)\n        self.cursorPositionChanged.connect(self.__set_extra_selections)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninserting the completion text in the current document.", "response": "def __insert_completion(self, completion):\n        \"\"\"\n        Inserts the completion text in the current document.\n\n        :param completion: Completion text.\n        :type completion: QString\n        \"\"\"\n\n        LOGGER.debug(\"> Inserting '{0}' completion.\".format(completion))\n\n        text_cursor = self.textCursor()\n        extra = (completion.length() - self.__completer.completion_prefix().length())\n        text_cursor.insertText(completion.right(extra))\n        self.setTextCursor(text_cursor)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the language description.", "response": "def __set_language_description(self):\n        \"\"\"\n        Sets the language accelerators.\n        \"\"\"\n\n        LOGGER.debug(\"> Setting language description.\")\n\n        if not self.__language:\n            return\n\n        if self.__language.highlighter:\n            self.set_highlighter(self.__language.highlighter(self.document(),\n                                                             self.__language.rules,\n                                                             self.__language.theme))\n            self.highlighter.rehighlight()\n        else:\n            self.remove_highlighter()\n\n        if self.__language.completer:\n            self.set_completer(self.__language.completer(self.parent(), self.__language.name, self.__language.tokens))\n        else:\n            self.remove_completer()\n\n        self.indent_marker = self.__language.indent_marker\n        self.comment_marker = self.__language.comment_marker\n        self.pre_input_accelerators = self.__language.pre_input_accelerators\n        self.post_input_accelerators = self.__language.post_input_accelerators\n        self.visual_accelerators = self.__language.visual_accelerators\n\n        color = \"rgb({0}, {1}, {2})\"\n        background = self.__language.theme.get(\"default\").background()\n        foreground = self.__language.theme.get(\"default\").foreground()\n        self.setStyleSheet(\n            \"QPlainTextEdit{{ background-color: {0}; color: {1}; }}\".format(color.format(background.color().red(),\n                                                                                         background.color().green(),\n                                                                                         background.color().blue()),\n                                                                            color.format(foreground.color().red(),\n                                                                                         foreground.color().green(),\n                                                                                         foreground.color().blue())))\n\n        self.__tab_width = self.fontMetrics().width(\" \" * self.indent_width)\n        self.setTabStopWidth(self.__tab_width)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the editor language.", "response": "def set_language(self, language):\n        \"\"\"\n        Sets the language.\n\n        :param language: Language to set.\n        :type language: Language\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        LOGGER.debug(\"> Setting editor language to '{0}'.\".format(language.name))\n        self.__language = language or umbra.ui.languages.PYTHON_LANGUAGE\n        self.__set_language_description()\n        self.language_changed.emit()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_highlighter(self, highlighter):\n\n        if not issubclass(highlighter.__class__, QSyntaxHighlighter):\n            raise foundations.exceptions.ProgrammingError(\"{0} | '{1}' is not a 'QSyntaxHighlighter' subclass!\".format(\n                self.__class__.__name__, highlighter))\n\n        if self.__highlighter:\n            self.remove_highlighter()\n\n        LOGGER.debug(\"> Setting '{0}' highlighter.\".format(highlighter))\n        self.__highlighter = highlighter\n\n        return True", "response": "Sets given highlighter as the current document highlighter."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_highlighter(self):\n\n        if self.__highlighter:\n            LOGGER.debug(\"> Removing '{0}' highlighter.\".format(self.__highlighter))\n            self.__highlighter.deleteLater()\n            self.__highlighter = None\n        return True", "response": "Removes current highlighter.\n\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting given completer as the current completer.", "response": "def set_completer(self, completer):\n        \"\"\"\n        Sets given completer as the current completer.\n\n        :param completer: Completer.\n        :type completer: QCompleter\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if not issubclass(completer.__class__, QCompleter):\n            raise foundations.exceptions.ProgrammingError(\"{0} | '{1}' is not a 'QCompleter' subclass!\".format(\n                self.__class__.__name__, completer))\n\n        if self.__completer:\n            self.remove_completer()\n\n        LOGGER.debug(\"> Setting '{0}' completer.\".format(completer))\n        self.__completer = completer\n        self.__completer.setWidget(self)\n\n        # Signals / Slots.\n        self.__completer.activated.connect(self.__insert_completion)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves current completer. :return: Method success. :rtype: bool", "response": "def remove_completer(self):\n        \"\"\"\n        Removes current completer.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if self.__completer:\n            LOGGER.debug(\"> Removing '{0}' completer.\".format(self.__completer))\n            # Signals / Slots.\n            self.__completer.activated.disconnect(self.__insert_completion)\n\n            self.__completer.deleteLater()\n            self.__completer = None\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the cursor for matching given symbols pairs.", "response": "def get_matching_symbols_pairs(self, cursor, opening_symbol, closing_symbol, backward=False):\n        \"\"\"\n        Returns the cursor for matching given symbols pairs.\n\n        :param cursor: Cursor to match from.\n        :type cursor: QTextCursor\n        :param opening_symbol: Opening symbol.\n        :type opening_symbol: unicode\n        :param closing_symbol: Closing symbol to match.\n        :type closing_symbol: unicode\n        :return: Matching cursor.\n        :rtype: QTextCursor\n        \"\"\"\n\n        if cursor.hasSelection():\n            start_position = cursor.selectionEnd() if backward else cursor.selectionStart()\n        else:\n            start_position = cursor.position()\n\n        flags = QTextDocument.FindFlags()\n        if backward:\n            flags = flags | QTextDocument.FindBackward\n\n        start_cursor = previous_start_cursor = cursor.document().find(opening_symbol, start_position, flags)\n        end_cursor = previous_end_cursor = cursor.document().find(closing_symbol, start_position, flags)\n        if backward:\n            while start_cursor > end_cursor:\n                start_cursor = cursor.document().find(opening_symbol, start_cursor.selectionStart(), flags)\n                if start_cursor > end_cursor:\n                    end_cursor = cursor.document().find(closing_symbol, end_cursor.selectionStart(), flags)\n        else:\n            while start_cursor < end_cursor:\n                start_cursor = cursor.document().find(opening_symbol, start_cursor.selectionEnd(), flags)\n                if start_cursor < end_cursor:\n                    end_cursor = cursor.document().find(closing_symbol, end_cursor.selectionEnd(), flags)\n\n        return end_cursor if end_cursor.position() != -1 else previous_end_cursor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nindent the document text under cursor.", "response": "def indent(self):\n        \"\"\"\n        Indents the document text under cursor.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        cursor = self.textCursor()\n        if not cursor.hasSelection():\n            cursor.insertText(self.__indent_marker)\n        else:\n            block = self.document().findBlock(cursor.selectionStart())\n            while True:\n                block_cursor = self.textCursor()\n                block_cursor.setPosition(block.position())\n                block_cursor.insertText(self.__indent_marker)\n                if block.contains(cursor.selectionEnd()):\n                    break\n                block = block.next()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntoggling comments on the document selected lines.", "response": "def toggle_comments(self):\n        \"\"\"\n        Toggles comments on the document selected lines.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if not self.__comment_marker:\n            return True\n\n        cursor = self.textCursor()\n        if not cursor.hasSelection():\n            cursor.movePosition(QTextCursor.StartOfBlock)\n            line = foundations.strings.to_string(self.document().findBlockByNumber(cursor.blockNumber()).text())\n            if line.startswith(self.__comment_marker):\n                foundations.common.repeat(cursor.deleteChar, len(self.__comment_marker))\n            else:\n                cursor.insertText(self.__comment_marker)\n        else:\n            block = self.document().findBlock(cursor.selectionStart())\n            while True:\n                block_cursor = self.textCursor()\n                block_cursor.setPosition(block.position())\n                if foundations.strings.to_string(block.text()).startswith(self.__comment_marker):\n                    foundations.common.repeat(block_cursor.deleteChar, len(self.__comment_marker))\n                else:\n                    block_cursor.insertText(self.__comment_marker)\n\n                if block.contains(cursor.selectionEnd()):\n                    break\n                block = block.next()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove trailing white spaces from the document.", "response": "def remove_trailing_white_spaces(self):\n        \"\"\"\n        Removes document trailing white spaces.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        cursor = self.textCursor()\n\n        block = self.document().findBlockByLineNumber(0)\n        while block.isValid():\n            cursor.setPosition(block.position())\n            if re.search(r\"\\s+$\", block.text()):\n                cursor.movePosition(QTextCursor.EndOfBlock)\n                cursor.movePosition(QTextCursor.StartOfBlock, QTextCursor.KeepAnchor)\n                cursor.insertText(foundations.strings.to_string(block.text()).rstrip())\n            block = block.next()\n        cursor.movePosition(QTextCursor.End, QTextCursor.MoveAnchor)\n        if not cursor.block().text().isEmpty():\n            cursor.insertText(\"\\n\")\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert document indentation to tabs.", "response": "def convert_indentation_to_tabs(self):\n        \"\"\"\n        Converts document indentation to tabs.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        cursor = self.textCursor()\n\n        block = self.document().findBlockByLineNumber(0)\n        while block.isValid():\n            cursor.setPosition(block.position())\n            search = re.match(r\"^ +\", block.text())\n            if search:\n                cursor.movePosition(QTextCursor.StartOfBlock, QTextCursor.MoveAnchor)\n                searchLength = len(search.group(0))\n                foundations.common.repeat(\n                    lambda: cursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor), searchLength)\n                cursor.insertText(self.__indent_marker * (searchLength / self.__indent_width))\n            block = block.next()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef str_to_num(self, arg):\n\n        if len(arg) == 1:\n            ten = '10'\n        else:\n            ten = ''\n        switcher = {\n            '\u4e00': '1',\n            '\u4e8c': '2',\n            '\u4e09': '3',\n            '\u56db': '4',\n            '\u4e94': '5',\n            '\u516d': '6',\n            '\u4e03': '7',\n            '\u516b': '8',\n            '\u4e5d': '9',\n            '\u5341': ten,\n            '\u3007': '0',\n            '\u25cb': '0',\n        }\n        test = ''\n        for i in arg:\n            test = test + switcher.get(i, None)\n        return int(test)", "response": "Convert a string to an integer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef special_time_extrator(self, string):\n\n        try:\n            if not self.year_check:\n                str_year = int(re.search('.*?(\\d{4})[-._]', string).group(1))\n                check_year = datetime.datetime.now().year\n                if str_year in range(1970, check_year + 1):\n                    self.year = str_year\n                    self.year_check = True\n        except:\n            pass\n        try:\n            if not self.month_check and not self.day_check:\n                str_month_day = re.search('((\\d{1,2})[-._\u00b7](\\d{1,2}))', string)\n                str_month = int(str_month_day.group(2))\n                str_day = int(str_month_day.group(3))\n                if str_month in range(1, 13) and str_day in range(1, 32):\n                    self.month = str_month\n                    self.day = str_day\n                    self.month_check = True\n                    self.day_check = True\n        except:\n            pass", "response": "This method is used to extract the special time from the ISO."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the time is in the correct format.", "response": "def check_time_extrator(self):\n        \"\"\"\u5c06\u62bd\u53d6\u5f97\u65f6\u95f4\u8f6c\u6362\u4e3adate\u6807\u51c6\u65f6\u95f4\u683c\u5f0f\n\n        Keyword arguments:\n        string                  -- \u542b\u6709\u65f6\u95f4\u7684\u6587\u672c\uff0cstr\u7c7b\u578b\n        Return:\n        release_time            -- \u65b0\u95fb\u53d1\u5e03\u65f6\u95f4\n        \"\"\"\n\n        if self.year_check and self.month_check and self.day_check:\n            time = str(self.year) + '-' + str(self.month) + '-' + str(self.day)\n            release_time = datetime.datetime.strptime(time, \"%Y-%m-%d\").date()\n            return release_time"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef modified_environ(added=None, absent=()):\n    env = os.environ\n    added = dict(added or {})\n    absent = tuple(absent)\n\n    in_env = partial(__filter, lambda i: i in env)\n    not_in_env = partial(__filter, lambda i: i not in env)\n\n    # List of environment variables being updated or removed.\n    stomped = in_env(chain(__keys(added), absent))\n    # Environment variables and values to restore on exit.\n    update_after = dict((a, env[a]) for a in stomped)\n    # Environment variables and values to remove on exit.\n    remove_after = tuple(not_in_env(__keys(added)))\n\n    def update(other):\n        return env.update(other)\n\n    def popper(item):\n        return env.pop(item, None)\n\n    def remove(items):\n        return tuple(__map(popper, items))\n\n    try:\n        update(added)\n        remove(absent)\n        yield\n    finally:\n        update(update_after)\n        remove(remove_after)", "response": "Temporarily updates the os. environ dictionary in - place. Can be used as a context manager or a decorator."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef business_date(self, business_date):\n        if business_date is not None:\n            if isinstance(business_date, type_check):\n                self._business_date = parse(business_date).date()\n            else:\n                self._business_date= business_date", "response": "Set the business date of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the rate timestamp of the FX.", "response": "def rate_timestamp(self, rate_timestamp):\n        \"\"\"\n        Force the rate_timestamp to be a datetime\n        :param rate_timestamp:\n        :return:\n        \"\"\"\n        if rate_timestamp is not None:\n            if isinstance(rate_timestamp, (str, type_check)):\n                rate_timestamp = parse(rate_timestamp).replace(tzinfo=pytz.utc)\n            if type(rate_timestamp) == date:\n                rate_timestamp = datetime.combine(rate_timestamp, datetime.min.time()).replace(tzinfo=pytz.utc)\n            if not rate_timestamp.tzinfo:\n                raise ValueError('Cannot set an FX rate timestamp without a timezone')\n            self._rate_timestamp = rate_timestamp"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an iterator over the key value pairs of a dictionary.", "response": "def iteritems(d, **kw):\n    \"\"\"Return an iterator over the (key, value) pairs of a dictionary.\"\"\"\n    if not PY2:\n        return iter(d.items(**kw))\n    return d.iteritems(**kw)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef itervalues(d, **kw):\n    if not PY2:\n        return iter(d.values(**kw))\n    return d.itervalues(**kw)", "response": "Return an iterator over the values of a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield the tokens from the given row", "response": "def __get_tokens(self, row):\n        \"\"\"Row should be a single string\"\"\"\n        row_tokenizer = RowTokenizer(row, self.config)\n\n        line = row_tokenizer.next()\n        while line:\n            # print(\"RETURN line\", line[0:100])\n            yield line\n            line = row_tokenizer.next()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cursor():\n    try:\n        cur = conn.cursor()\n        yield cur\n    except (db.Error, Exception) as e:\n        cur.close()\n        if conn:\n            conn.rollback()\n        print(e.message)\n        raise\n    else:\n        conn.commit()\n        cur.close()", "response": "Database cursor generator. Commit on context exit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resample_time_series(self):\n        with cursor() as cur:\n            cur.execute(\"SELECT max(starttime) FROM resampled_ledger\")\n            if cur.rowcount:\n                last_resample = str(cur.fetchone()[0])\n            else:\n                last_resample = 0\n            if not self.quiet:\n                print(\"Resampling time series...\")\n            for market in self.markets:\n                sys.stdout.write(market[0] + \"-\" + market[1] + \"\\r\")\n                sys.stdout.flush()\n\n                # Resample all transactions\n                if self.full or last_resample == 'None':\n                    query = (\n                        \"SELECT currency1, currency2, price1, price2, \"\n                        \"amount1, amount2, txdate FROM ripple_ledger \"\n                        \"WHERE market = '%s' \"\n                        \"ORDER BY txdate\"\n                    ) % (market[0] + market[1])\n\n                # Resample transactions from the last resampling\n                # starting timestamp or newer\n                else:\n                    query = (\n                        \"SELECT currency1, currency2, price1, price2, \"\n                        \"amount1, amount2, txdate FROM ripple_ledger \"\n                        \"WHERE market = '%s' AND txdate >= '%s' \"\n                        \"ORDER BY txdate\"\n                    ) % (market[0] + market[1], last_resample)\n                df = psql.frame_query(query, conn)\n                if not df.empty:\n                    for f in self.resampling_frequencies:\n                        rs = self.resampler(df, freq=f)\n                        self.write_resampled(rs, market, cur, freq=f)\n                    conn.commit()\n            print()\n            print(self.updates, \"resampled_ledger records updated\")\n            print()\n\n        # Index the columns: starttime, freq, currency1, currency2\n        conn.set_isolation_level(ext.ISOLATION_LEVEL_AUTOCOMMIT)\n        with cursor() as cur:\n            if not self.quiet:\n                print(\"Indexing...\")\n            idx_queries = (\n                \"DROP INDEX IF EXISTS idx_ledger_interval\",\n                (\n                    \"CREATE INDEX CONCURRENTLY idx_ledger_interval ON \"\n                    \"resampled_ledger(starttime, freq, currency1, currency2)\"\n                ),\n            )\n            for query in idx_queries:\n                cur.execute(query)", "response": "Resample all time series transactions from the last resampled timestamp."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef download(self):\n        self.housekeeping()\n        self.rippled_history()\n        if self.resampling_frequencies is not None:\n            self.find_markets()\n            self.resample_time_series()", "response": "Download all transactions from the current ledger index to the genesis ledger index and download them from rippled."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting integer to hex string representation e. g. 12 to 0C", "response": "def hexify(number):\n    \"\"\"\n    Convert integer to hex string representation, e.g. 12 to '0C'\n    \"\"\"\n    if( isinstance(number, int) == False ):\n        raise TypeError('hexify(): expected integer, not {}'.format(type(number)))\n\n    if number < 0:\n        raise ValueError('Invalid number to hexify - must be positive')\n\n    result = hex(int(number)).replace('0x', '').upper()\n    if divmod(len(result), 2)[1] == 1:\n        # Padding\n        result = '0{}'.format(result)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting DES key check value.", "response": "def key_CV(key, kcv_length=6):\n    \"\"\"\n    Get DES key check value. The key is binary hex e.g. b'DF1267EEDCBA9876'\n    \"\"\"\n    cipher = DES3.new(B2raw(key), DES3.MODE_ECB)\n    encrypted = raw2B(cipher.encrypt(B2raw(b'00000000000000000000000000000000')))\n\n    return encrypted[:kcv_length]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting the digits from the given cyphertext.", "response": "def get_digits_from_string(cyphertext, length=4):\n    \"\"\"\n    Extract PVV/CVV digits from the cyphertext (HEX-encoded string, e.g. 'EEFADCFFFBD7ADECAB9FBB')\n    \"\"\"\n    digits = ''\n   \n    \"\"\"\n    The algorigthm is used for PVV and CVV calculation.\n\n    1. The cyphertext is scanned from left to right. Decimal digits are\n    selected during the scan until the needed number of decimal digits is found. \n    Each selected digit is placed from left to right according to the order\n    of selection. If needed number of decimal digits is found (four in case of PVV, \n    three in case of CVV), those digits are the PVV or CVV.\n    \"\"\"\n    for c in cyphertext:\n        if len(digits) >= length:\n            break\n        try:\n            int(c)\n            digits += c\n        except ValueError:\n            continue\n    \n    \"\"\"\n    2. If, at the end of the first scan, less than four decimal digits\n    have been selected, a second scan is performed from left to right.\n    During the second scan, all decimal digits are skipped and only nondecimal\n    digits can be processed. Nondecimal digits are converted to decimal\n    digits by subtracting 10. The process proceeds until four digits of\n    PVV are found.\n    \"\"\"\n    if len(digits) < length:\n        for c in cyphertext:\n            if len(digits) >= length:\n                break\n    \n            if (int(c, 16) - 10) >= 0:\n                digits += str(int(c, 16) - 10)\n    \n    return digits"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_visa_pvv(account_number, key_index, pin, PVK):\n    tsp = account_number[-12:-1] + key_index + pin\n    if len(PVK) != 32:\n        raise ValueError('Incorrect key length')\n\n    left_key_cypher = DES3.new(PVK[:16], DES3.MODE_ECB)\n    right_key_cypher = DES3.new(PVK[16:], DES3.MODE_ECB)\n\n    encrypted_tsp = left_key_cypher.encrypt(right_key_cypher.decrypt((left_key_cypher.encrypt(B2raw(tsp)))))\n    return bytes(get_digits_from_string(raw2str(encrypted_tsp)), 'utf-8')", "response": "This function generates a VISA PVR value for a given TSP and PIN."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the clear PIN from provided PIN block and account_number.", "response": "def get_clear_pin(pinblock, account_number):\n    \"\"\"\n    Calculate the clear PIN from provided PIN block and account_number, which is the 12 right-most digits of card account number, excluding check digit\n    \"\"\"\n    raw_pinblock = bytes.fromhex(pinblock.decode('utf-8'))\n    raw_acct_num = bytes.fromhex((b'0000' + account_number).decode('utf-8'))\n        \n    pin_str = xor(raw2B(raw_pinblock), raw2B(raw_acct_num)).decode('utf-8')\n    pin_length = int(pin_str[:2], 16)\n    \n    if pin_length >= 4 and pin_length < 9:\n        pin = pin_str[2:2+pin_length]            \n        try:\n            int(pin)\n        except ValueError:\n            raise ValueError('PIN contains non-numeric characters')\n        return bytes(pin, 'utf-8')\n    else:\n        raise ValueError('Incorrect PIN length: {}'.format(pin_length))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parityOf(int_type):\n    parity = 0\n    while (int_type):\n        parity = ~parity\n        int_type = int_type & (int_type - 1)\n    return(parity)", "response": "Calculates the parity of an integer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef modify_key_parity(key):\n    validated_key = b''\n    for byte in key:\n        if parityOf(int(byte)) == -1:\n            byte_candidate = int(byte) + 1 \n            while parityOf(byte_candidate) == -1:\n                byte_candidate = divmod(byte_candidate + 1, 256)[1]\n            validated_key += bytes([byte_candidate])\n\n        else:\n            validated_key += bytes([byte])\n    return validated_key", "response": "Modify the parity of a key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef color(self, value):\n\n        if value is not None:\n            assert type(value) is QColor, \"'{0}' attribute: '{1}' type is not 'QColor'!\".format(\"color\", value)\n        self.__color = value\n        self.__set_style_sheet()", "response": "Sets the color of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef border_color(self, value):\n\n        if value is not None:\n            assert type(value) is QColor, \"'{0}' attribute: '{1}' type is not 'QColor'!\".format(\"border_color\", value)\n        self.__border_color = value\n        self.__set_style_sheet()", "response": "Sets the border color of the object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef anchor(self, value):\n\n        if value is not None:\n            assert type(value) is int, \"'{0}' attribute: '{1}' type is not 'int'!\".format(\"anchor\", value)\n            assert value in range(\n                0, 9), \"'{0}' attribute: '{1}' need to be in '0' to '8' range!\".format(\"anchor\", value)\n        self.__anchor = value", "response": "Sets the anchor of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef horizontal_padding(self, value):\n\n        if value is not None:\n            assert type(value) is int, \"'{0}' attribute: '{1}' type is not 'int'!\".format(\"horizontal_padding\", value)\n            assert value >= 0, \"'{0}' attribute: '{1}' need to be positive!\".format(\"horizontal_padding\", value)\n        self.__horizontal_padding = value", "response": "Sets the value for the horizontal_padding attribute."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the value of the vertical_padding attribute.", "response": "def vertical_padding(self, value):\n        \"\"\"\n        Setter for **self.__vertical_padding** attribute.\n\n        :param value: Attribute value.\n        :type value: int\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is int, \"'{0}' attribute: '{1}' type is not 'int'!\".format(\"vertical_padding\", value)\n            assert value > 0, \"'{0}' attribute: '{1}' need to be positive!\".format(\"vertical_padding\", value)\n        self.__vertical_padding = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef horizontal_offset(self, value):\n\n        if value is not None:\n            assert type(value) is int, \"'{0}' attribute: '{1}' type is not 'int'!\".format(\"horizontal_offset\", value)\n        self.__horizontal_offset = value", "response": "Sets the value of the\n       ."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the value of the attribute.", "response": "def vertical_offset(self, value):\n        \"\"\"\n        Setter for **self.__vertical_offset** attribute.\n\n        :param value: Attribute value.\n        :type value: int\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is int, \"'{0}' attribute: '{1}' type is not 'int'!\".format(\"vertical_offset\", value)\n        self.__vertical_offset = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fade_speed(self, value):\n\n        if value is not None:\n            assert type(value) is float, \"'{0}' attribute: '{1}' type is not 'float'!\".format(\"fade_speed\", value)\n            assert value >= 0, \"'{0}' attribute: '{1}' need to be exactly positive!\".format(\"fade_speed\", value)\n        self.__fade_speed = value", "response": "Sets the value of the fade_speed attribute."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the target opacity of the object.", "response": "def target_opacity(self, value):\n        \"\"\"\n        Setter for **self.__target_opacity** attribute.\n\n        :param value: Attribute value.\n        :type value: float\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is float, \"'{0}' attribute: '{1}' type is not 'float'!\".format(\"target_opacity\", value)\n            assert value >= 0, \"'{0}' attribute: '{1}' need to be positive!\".format(\"target_opacity\", value)\n            assert value <= 1, \"'{0}' attribute: '{1}' need to be less or equal than '1'!\".format(\n                \"target_opacity\", value)\n        self.__target_opacity = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef duration(self, value):\n\n        if value is not None:\n            assert type(value) is int, \"'{0}' attribute: '{1}' type is not 'int'!\".format(\"duration\", value)\n            assert value >= 0, \"'{0}' attribute: '{1}' need to be exactly positive!\".format(\"duration\", value)\n        self.__duration = value", "response": "Sets the duration of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef opacity(self, value):\n\n        if value is not None:\n            assert type(value) in (int, float), \"'{0}' attribute: '{1}' type is not 'int' or 'float'!\".format(\"opacity\",\n                                                                                                              value)\n        if value > 1:\n            value = 1\n        elif value < 0:\n            value = 0\n\n        self.__opacity = float(value)\n        self.__set_style_sheet()", "response": "Sets the opacity of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __raise(self, *args):\n\n        children = self.parent().children().remove(self)\n        if children:\n            self.stackUnder(children[-1])\n        else:\n            self.lower()\n        self.raise_()", "response": "Raise the Widget if it is on top of the parent stack."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __set_position(self):\n\n        rectangle = hasattr(self.parent(), \"viewport\") and self.parent().viewport().rect() or self.parent().rect()\n        if not rectangle:\n            return\n\n        self.adjustSize()\n\n        if self.__anchor == 0:\n            point_x = rectangle.width() / 2 - self.width() / 2\n            point_y = self.__vertical_padding\n        elif self.__anchor == 1:\n            point_x = rectangle.width() - self.width() - self.__horizontal_padding\n            point_y = self.__vertical_padding\n        elif self.__anchor == 2:\n            point_x = rectangle.width() - self.width() - self.__horizontal_padding\n            point_y = rectangle.height() / 2 - self.height() / 2\n        elif self.__anchor == 3:\n            point_x = rectangle.width() - self.width() - self.__horizontal_padding\n            point_y = rectangle.height() - self.height() - self.__vertical_padding\n        elif self.__anchor == 4:\n            point_x = rectangle.width() / 2 - self.width() / 2\n            point_y = rectangle.height() - self.height() - self.__vertical_padding\n        elif self.__anchor == 5:\n            point_x = self.__horizontal_padding\n            point_y = rectangle.height() - self.height() - self.__vertical_padding\n        elif self.__anchor == 6:\n            point_x = self.__horizontal_padding\n            point_y = rectangle.height() / 2 - self.height() / 2\n        elif self.__anchor == 7:\n            point_x = self.__horizontal_padding\n            point_y = self.__vertical_padding\n        elif self.__anchor == 8:\n            point_x = rectangle.width() / 2 - self.width() / 2\n            point_y = rectangle.height() / 2 - self.height() / 2\n\n        self.setGeometry(point_x + self.__horizontal_offset, point_y +\n                                                             self.__vertical_offset, self.width(), self.height())", "response": "Sets the position relatively to its parent."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts the Widget fade in.", "response": "def __fade_in(self):\n        \"\"\"\n        Starts the Widget fade in.\n        \"\"\"\n\n        self.__timer.stop()\n        self.__vector = self.__fade_speed\n        self.__timer.start()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __fade_out(self):\n\n        self.__timer.stop()\n        self.__vector = -self.__fade_speed\n        self.__timer.start()", "response": "Starts the Widget fade out."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __set_opacity(self):\n\n        if self.__vector > 0:\n            if self.isHidden():\n                self.show()\n            if self.opacity <= self.__target_opacity:\n                self.opacity += self.__vector\n            else:\n                self.__timer.stop()\n                self.faded_in.emit()\n                self.__duration and QTimer.singleShot(self.__duration, self.__fade_out)\n        elif self.__vector < 0:\n            if self.opacity > 0:\n                self.opacity += self.__vector\n            else:\n                self.__timer.stop()\n                self.faded_out.emit()\n                self.hide()", "response": "Sets the Widget opacity."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the Widget stylesheet.", "response": "def __set_style_sheet(self):\n        \"\"\"\n        Sets the Widget stylesheet.\n        \"\"\"\n\n        colors = map(\n            lambda x: \"rgb({0}, {1}, {2}, {3})\".format(x.red(), x.green(), x.blue(), int(self.__opacity * 255)),\n            (self.__color, self.__background_color, self.__border_color))\n        self.setStyleSheet(self.__style.format(*colors))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nshow given message. :param message: Message. :type message: unicode :param duration: Notification duration in milliseconds. :type duration: int :return: Method success. :rtype: bool", "response": "def show_message(self, message, duration=2500):\n        \"\"\"\n        Shows given message.\n\n        :param message: Message.\n        :type message: unicode\n        :param duration: Notification duration in milliseconds.\n        :type duration: int\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        self.setText(message)\n        self.__duration = duration\n\n        self.__set_position()\n\n        if message:\n            self.__fade_in()\n        else:\n            self.__fade_out()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef execute_git_command(command, repo_dir=None):\n    try:\n        output = shell.execute(command, cwd=repo_dir)\n    except exceptions.SimplCalledProcessError as err:\n        raise exceptions.SimplGitCommandError(err.returncode, err.cmd,\n                                              output=err.output)\n    except OSError as err:\n        # OSError's errno *is not* the returncode\n        raise exceptions.SimplGitCommandError(\n            127, command, output=repr(err), oserror=err)\n    else:\n        return output", "response": "Execute a git command and return the output."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks the installed git version against a known - stable version.", "response": "def check_git_version():\n    \"\"\"Check the installed git version against a known-stable version.\n\n    If the git version is less then ``MIN_GIT_VERSION``, a warning is raised.\n\n    If git is not installed at all on this system, we also raise a warning for\n    that.\n\n    The original reason why this check was introduced is because with older\n    versions git (< 1.9), newly init-ed git repos cannot checkout from a\n    fetched remote unless the repo has at least one commit in it. The reason\n    for this is that before creating a commit, the HEAD refers to a\n    refs/heads/master file which doesn't exist yet.\n\n    .. todo::\n\n        TODO(larsbutler): If we wanted to be defensive about this and favor\n        compatibility over elegance, we could just automatically add a\n        `git commit` (empty, no message) after every `git init`. I would\n        recommend doing this in the :class:`GitRepo` class, not in the\n        module-level util functions. Adding an extra commit shouldn't cause\n        any problems.\n    \"\"\"\n    try:\n        version = git_version()\n    except exceptions.SimplGitCommandError:\n        warnings.warn(\"Git does not appear to be installed!\",\n                      exceptions.GitWarning)\n        return\n\n    ver_num = version.split()[2]\n    major, minor, _ = ver_num.split('.', 2)\n    major = int(major)\n    minor = int(minor)\n    if (major, minor) < MIN_GIT_VERSION:\n        warnings.warn(\n            \"Git version %(ver)s found. %(rec)s or greater \"\n            \"is recommended for simpl/git.py\"\n            % dict(ver=ver_num,\n                   rec='.'.join((str(x) for x in MIN_GIT_VERSION))),\n            exceptions.GitWarning)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef git_clone(target_dir, repo_location, branch_or_tag=None, verbose=True):\n    target_dir = pipes.quote(target_dir)\n    command = ['git', 'clone']\n    if verbose:\n        command.append('--verbose')\n    if os.path.isdir(repo_location):\n        command.append('--no-hardlinks')\n    command.extend([pipes.quote(repo_location), target_dir])\n    if branch_or_tag:\n        command.extend(['--branch', branch_or_tag])\n    return execute_git_command(command)", "response": "Clone repo at repo_location to target_dir and checkout branch_or_tag."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating an annotated tag at the current head.", "response": "def git_tag(repo_dir, tagname, message=None, force=True):\n    \"\"\"Create an annotated tag at the current head.\"\"\"\n    message = message or \"%s\" % tagname\n    command = ['git', 'tag', '--annotate', '--message', message]\n    if force:\n        command.append('--force')\n    # append the tag as the final arg\n    command.append(tagname)\n    return execute_git_command(command, repo_dir=repo_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef git_list_config(repo_dir):\n    command = ['git', 'config', '--list']\n    raw = execute_git_command(command, repo_dir=repo_dir).splitlines()\n    output = {key: val for key, val in\n              [cfg.split('=', 1) for cfg in raw]}\n    # TODO(sam): maybe turn this into more easily navigable\n    # nested dicts?\n    # e.g. {'alias': {'branches': ..., 'remotes': ...}}\n    return output", "response": "Return a list of the git configuration."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of git tags for the git repo in repo_dir.", "response": "def git_list_tags(repo_dir, with_messages=False):\n    \"\"\"Return a list of git tags for the git repo in `repo_dir`.\"\"\"\n    command = ['git', 'tag', '-l']\n    if with_messages:\n        command.append('-n1')\n    raw = execute_git_command(command, repo_dir=repo_dir).splitlines()\n    output = [l.strip() for l in raw if l.strip()]\n    if with_messages:\n        output = [tuple(j.strip() for j in line.split(None, 1))\n                  for line in output]\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef git_list_branches(repo_dir):\n    command = ['git', 'branch', '--remotes', '--all',\n               '--verbose', '--no-abbrev']\n    output = execute_git_command(command, repo_dir=repo_dir).splitlines()\n    # remove nullish lines\n    lines = [l.strip() for l in output if l.strip()]\n    # find the * current branch\n    try:\n        current_branch = [l for l in lines if l.startswith('* ')][0]\n    except IndexError:\n        current_branch = None\n    item = None\n    if current_branch:\n        lines.remove(current_branch)\n        current_branch = current_branch.replace('* ', '', 1)\n        if re.match('\\(.*detached.+\\)', current_branch):\n            branch, rest = current_branch.split(')', 1)\n            branch = \"%s)\" % branch\n            sha, msg = rest.split(None, 1)\n            item = {'branch': branch, 'commit': sha, 'message': msg}\n        else:\n            lines.insert(0, current_branch)\n    # <branch> <hash> <commit_message>\n    # make a list of lists with clean elements of equal length\n    breakout = [k.split(None, 2) for k in lines]\n    # remove any strange hashless outliers\n    breakout = [k for k in breakout if len(k[1]) == 40]\n    headers = ['branch', 'commit', 'message']\n    # use izip_longest so we fill in None if message was empty\n    result = [dict(zip_longest(headers, vals))\n              for vals in breakout]\n    if item:\n        result.append(item)\n    return result", "response": "Return a list of git branches for the git repo in repo_dir."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a listing of configured remotes.", "response": "def git_list_remotes(repo_dir):\n    \"\"\"Return a listing of configured remotes.\"\"\"\n    command = ['git', 'remote', '--verbose', 'show']\n    raw = execute_git_command(command, repo_dir=repo_dir).splitlines()\n    output = [l.strip() for l in raw if l.strip()]\n    # <name> <location> (<cmd>)\n    # make a list of lists with clean elements of equal length\n    headers = ['name', 'location', 'cmd']\n    breakout = [k.split(None, len(headers)) for k in output]\n    # use izip_longest so we fill in None if message was empty\n    return [dict(zip_longest(headers, vals))\n            for vals in breakout]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting all local refs in the local repo with commit ids.", "response": "def git_list_refs(repo_dir):\n    \"\"\"List references available in the local repo with commit ids.\n\n    This is similar to ls-remote, but shows the *local* refs.\n\n    Return format:\n\n    .. code-block:: python\n\n        {<ref1>: <commit_hash1>,\n         <ref2>: <commit_hash2>,\n         ...,\n         <refN>: <commit_hashN>,\n        }\n    \"\"\"\n    command = ['git', 'show-ref', '--dereference', '--head']\n    raw = execute_git_command(command, repo_dir=repo_dir).splitlines()\n    output = [l.strip() for l in raw if l.strip()]\n    return {ref: commit_hash for commit_hash, ref in\n            [l.split(None, 1) for l in output]}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef git_ls_remote(repo_dir, remote='origin', refs=None):\n    command = ['git', 'ls-remote', pipes.quote(remote)]\n    if refs:\n        if isinstance(refs, list):\n            command.extend(refs)\n        else:\n            command.append(refs)\n    raw = execute_git_command(command, repo_dir=repo_dir).splitlines()\n    output = [l.strip() for l in raw if l.strip()\n              and not l.strip().lower().startswith('from ')]\n    return {ref: commit_hash for commit_hash, ref in\n            [l.split(None, 1) for l in output]}", "response": "Run git ls - remote."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new branch like git branch <branch_name > <start_point >.", "response": "def git_branch(repo_dir, branch_name, start_point='HEAD',\n               force=True, verbose=True, checkout=False):\n    \"\"\"Create a new branch like `git branch <branch_name> <start_point>`.\"\"\"\n    command = ['git', 'branch']\n    if verbose:\n        command.append('--verbose')\n    if force:\n        command.append('--force')\n    command.extend([branch_name, start_point])\n    branch_output = execute_git_command(command, repo_dir=repo_dir)\n    if checkout:\n        return git_checkout(repo_dir, branch_name)\n    else:\n        return branch_output"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef git_checkout(repo_dir, ref, branch=None):\n    command = ['git', 'checkout', '--force']\n    if branch:\n        command.extend(['-B', '{}'.format(branch)])\n    command.append(ref)\n    return execute_git_command(command, repo_dir=repo_dir)", "response": "Do a git checkout of ref in repo_dir."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndo a git fetch of refspec in repo_dir.", "response": "def git_fetch(repo_dir, remote=None, refspec=None, verbose=False, tags=True):\n    \"\"\"Do a git fetch of `refspec` in `repo_dir`.\n\n    If 'remote' is None, all remotes will be fetched.\n    \"\"\"\n    command = ['git', 'fetch']\n    if not remote:\n        command.append('--all')\n    else:\n        remote = pipes.quote(remote)\n    command.extend(['--update-head-ok'])\n    if tags:\n        command.append('--tags')\n    if verbose:\n        command.append('--verbose')\n    if remote:\n        command.append(remote)\n    if refspec:\n        command.append(refspec)\n    return execute_git_command(command, repo_dir=repo_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndo a git pull of ref from remote.", "response": "def git_pull(repo_dir, remote=\"origin\", ref=None, update_head_ok=False):\n    \"\"\"Do a git pull of `ref` from `remote`.\"\"\"\n    command = ['git', 'pull']\n    if update_head_ok:\n        command.append('--update-head-ok')\n    command.append(pipes.quote(remote))\n    if ref:\n        command.append(ref)\n    return execute_git_command(command, repo_dir=repo_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncommitting any changes optionally staging all changes beforehand.", "response": "def git_commit(repo_dir, message=None, amend=False, stage=True):\n    \"\"\"Commit any changes, optionally staging all changes beforehand.\"\"\"\n    if stage:\n        git_add_all(repo_dir)\n    command = ['git', 'commit', '--allow-empty']\n    if amend:\n        command.append('--amend')\n        if not message:\n            command.append('--no-edit')\n    if message:\n        command.extend(['--message', pipes.quote(message)])\n    elif not amend:\n        # if not amending and no message, allow an empty message\n        command.extend(['--message=', '--allow-empty-message'])\n    return execute_git_command(command, repo_dir=repo_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef git_ls_tree(repo_dir, treeish='HEAD'):\n    command = ['git', 'ls-tree', '-r', '--full-tree', treeish]\n    raw = execute_git_command(command, repo_dir=repo_dir).splitlines()\n    output = [l.strip() for l in raw if l.strip()]\n    # <mode> <type> <object> <file>\n    # make a list of lists with clean elements of equal length\n    breakout = [k.split(None, 3) for k in output]\n    headers = ['mode', 'type', 'object', 'file']\n    return [dict(zip(headers, vals)) for vals in breakout]", "response": "Run git ls - tree."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_git_repo(repo_dir):\n    command = ['git', 'rev-parse']\n    try:\n        execute_git_command(command, repo_dir=repo_dir)\n    except exceptions.SimplGitCommandError:\n        return False\n    else:\n        return True", "response": "Return True if the directory is inside a git repo."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef git_remote_resolve_reference(repo_dir, ref, remote='origin'):\n    ls_refs = git_ls_remote(repo_dir, remote=remote, refs='%s*' % ref)\n\n    if ref == 'HEAD':\n        return ls_refs['HEAD']\n    else:\n        matching_refs = [\n            'refs/tags/%s^{}' % ref,\n            'refs/heads/%s^{}' % ref,\n            '%s^{}' % ref,\n            'refs/tags/%s' % ref,\n            'refs/heads/%s' % ref,\n            ref,\n        ]\n        for _ref in matching_refs:\n            if _ref in ls_refs:\n                return ls_refs[_ref]", "response": "Try to find a revision for the ref at remote repo."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncleans up temp directory ignoring ENOENT errors.", "response": "def _cleanup_tempdir(tempdir):\n    \"\"\"Clean up temp directory ignoring ENOENT errors.\"\"\"\n    try:\n        shutil.rmtree(tempdir)\n    except OSError as err:\n        if err.errno != errno.ENOENT:\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a tempdir and return the path.", "response": "def create_tempdir(suffix='', prefix='tmp', directory=None, delete=True):\n    \"\"\"Create a tempdir and return the path.\n\n    This function registers the new temporary directory\n    for deletion with the atexit module.\n    \"\"\"\n    tempd = tempfile.mkdtemp(suffix=suffix, prefix=prefix, dir=directory)\n    if delete:\n        atexit.register(_cleanup_tempdir, tempd)\n    return tempd"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclone repo at repo_location into repo_dir and checkout branch_or_tag.", "response": "def clone(cls, repo_location, repo_dir=None,\n              branch_or_tag=None, temp=False):\n        \"\"\"Clone repo at repo_location into repo_dir and checkout branch_or_tag.\n\n        Defaults into current working directory if repo_dir is not supplied.\n\n        If 'temp' is True, a temporary directory will be created for you\n        and the repository will be cloned into it. The tempdir is scheduled\n        for deletion (when the process exits) through an exit function\n        registered with the atexit module. If 'temp' is True, repo_dir\n        is ignored.\n\n        If branch_or_tag is not specified, the HEAD of the primary\n        branch of the cloned repo is checked out.\n        \"\"\"\n        if temp:\n            reponame = repo_location.rsplit('/', 1)[-1]\n            suffix = '%s.temp_simpl_GitRepo' % '_'.join(\n                [str(x) for x in (reponame, branch_or_tag) if x])\n            repo_dir = create_tempdir(suffix=suffix, delete=True)\n        else:\n            repo_dir = repo_dir or os.getcwd()\n        git_clone(repo_dir, repo_location, branch_or_tag=branch_or_tag)\n        # assuming no errors\n        return cls(repo_dir)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new instance of the class with the given repo_dir.", "response": "def init(cls, repo_dir=None, temp=False, initial_commit=False):\n        \"\"\"Run `git init` in the repo_dir.\n\n        Defaults to current working directory if repo_dir is not supplied.\n\n        If 'temp' is True, a temporary directory will be created for you\n        and the repository will be initialized. The tempdir is scheduled\n        for deletion (when the process exits) through an exit function\n        registered with the atexit module. If 'temp' is True, repo_dir is\n        ignored.\n        \"\"\"\n        if temp:\n            suffix = '.temp_simpl_GitRepo'\n            repo_dir = create_tempdir(suffix=suffix, delete=True)\n        else:\n            repo_dir = repo_dir or os.getcwd()\n        git_init(repo_dir)\n        instance = cls(repo_dir)\n\n        # NOTE(larsbutler): If we wanted to be defensive about this and favor\n        # compatibility over elegance, we could just automatically add a\n        # `git commit` (empty, no message) after every `git init`. I would\n        # recommend doing this in the :class:`GitRepo` class, not in the\n        # module-level util functions. Adding an extra commit shouldn't cause\n        # any problems.\n        if initial_commit:\n            # unknown revision, needs a commit to run most commands\n            instance.commit(\n                message='Initial commit', amend=False, stage=False)\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nshow where the origin remote ref points exist.", "response": "def origin(self):\n        \"\"\"Show where the 'origin' remote ref points.\n\n        Returns None if the 'origin' remote ref does not exist.\n\n        If 'origin' has different locations for different commands,\n        the result is ambiguous and None is returned.\n\n        Notes:\n            A repo does not necessarily have any remotes configured.\n            A repo with remotes configured does not necessarily have\n            an 'origin' remote ref.\n\n            This property is for common convenience.\n        \"\"\"\n        remotes = self.list_remotes()\n        candidates = set()\n        for remote_ref in remotes:\n            if remote_ref['name'] == 'origin':\n                candidates.add(remote_ref['location'])\n        if len(candidates) == 1:\n            return candidates.pop()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tag(self, tagname, message=None, force=True):\n        return git_tag(self.repo_dir, tagname, message=message, force=force)", "response": "Create an annotated tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ls(self):\n        tree = self.ls_tree()\n        return [t.get('file') for t in tree if t.get('file')]", "response": "Return a list of all files & dirs in the repo."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ls_remote(self, remote='origin', refs=None):\n        return git_ls_remote(\n            self.repo_dir, remote=remote, refs=refs)", "response": "Return a mapping of refs to commit ids for the given remote."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef branch(self, branch_name, start_point='HEAD', force=True,\n               checkout=False):\n        \"\"\"Create branch as in `git branch <branch_name> <start_point>`.\n\n        If 'checkout' is True, checkout the branch after creation.\n        \"\"\"\n        return git_branch(\n            self.repo_dir, branch_name, start_point, force=force,\n            checkout=checkout)", "response": "Create a branch in the current repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndoing a git checkout of ref.", "response": "def checkout(self, ref, branch=None):\n        \"\"\"Do a git checkout of `ref`.\"\"\"\n        return git_checkout(self.repo_dir, ref, branch=branch)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fetch(self, remote=None, refspec=None, verbose=False, tags=True):\n        return git_fetch(self.repo_dir, remote=remote,\n                         refspec=refspec, verbose=verbose, tags=tags)", "response": "Do a git fetch of refspec."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndoing a git pull of ref from remote.", "response": "def pull(self, remote=\"origin\", ref=None):\n        \"\"\"Do a git pull of `ref` from `remote`.\"\"\"\n        return git_pull(self.repo_dir, remote=remote, ref=ref)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncommitting any changes optionally staging all changes beforehand.", "response": "def commit(self, message=None, amend=False, stage=True):\n        \"\"\"Commit any changes, optionally staging all changes beforehand.\"\"\"\n        return git_commit(self.repo_dir, message=message,\n                          amend=amend, stage=stage)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remote_resolve_reference(self, ref, remote='origin'):\n        return git_remote_resolve_reference(self.repo_dir, ref, remote=remote)", "response": "Resolve a reference to a remote revision."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_config():\n    '''\n    Get user docker configuration\n\n    Return: dict\n    '''\n    cfg = os.path.expanduser('~/.dockercfg')\n    try:\n        fic = open(cfg)\n        try:\n            config = json.loads(fic.read())\n        finally:\n            fic.close()\n    except Exception:\n        config = {'rootPath': '/dev/null'}\n    if not 'Configs' in config:\n        config['Configs'] = {}\n    return config", "response": "Get user docker configuration"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a docker client", "response": "def _get_client(config, url=None, version=None, timeout=None):\n    '''\n    Get a connection to a docker API (socket or URL)\n\n    By default it will use the base docker-py defaults which\n    at the time of writing are using the local socket and\n    the 1.4 API\n\n    Set those keys in your configuration tree somehow:\n\n        - docker.url: URL to the docker service\n        - docker.version: API version to use\n\n    Return: docker client\n    '''\n    if config.get(\"docker_sock\"):\n        url=config[\"docker_sock\"]\n    client = docker.Client(base_url=url)\n    # force 1..5 API for registry login\n    if not version:\n        if client._version == '1.4':\n            client._version = '1.5'\n    if getattr(client, '_cfg', None) is None:\n        client._cfg = {\n            'Configs': {},\n            'rootPath': '/dev/null'\n        }\n    client._cfg.update(_get_config())\n    return client"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the ID of the current object.", "response": "def _set_id(infos):\n    '''\n    ID compatibility hack\n\n    return: dict\n    '''\n    if infos:\n        cid = None\n        if infos.get(\"Id\"): cid = infos[\"Id\"]\n        elif infos.get(\"ID\"): cid = infos[\"ID\"]\n        elif infos.get(\"id\"): cid = infos[\"id\"]\n        if \"Id\" not in infos:\n            infos[\"Id\"] = cid\n        infos.pop(\"id\",None)\n        infos.pop(\"ID\",None)\n    return infos"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the image info from the client", "response": "def _get_image_infos(config,image):\n    '''\n    Verify that the image exists\n    We will try to resolve either by:\n        - name\n        - image_id\n        - tag\n\n    image\n        Image Name / Image Id / Image Tag\n\n    Returns dict\n    '''\n    client = _get_client(config)\n    infos = None\n    try:\n        infos = _set_id(client.inspect_image(image))\n    except Exception as e:\n        pass\n    return infos"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets container infos container Image Id / grain name return: dict", "response": "def _get_container_infos(config, container):\n    '''\n    Get container infos\n\n    container\n        Image Id / grain name\n\n    return: dict\n    '''\n    client = _get_client(config)\n    infos = None\n    try:\n        infos = _set_id(client.inspect_container(container))\n    except Exception:\n        pass\n    return infos"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_running(config, container, *args, **kwargs):\n    '''\n    Is this container running\n\n    container\n        Container id\n\n    Return container\n    '''\n    try:\n        infos = _get_container_infos(config, container)\n        return (infos if infos.get('State', {}).get('Running') else None)\n    except Exception:\n        return None", "response": "Check if a container is running"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_image_multilogs_string(config, ret, repo):\n    '''\n    Parse image log strings into grokable data\n    '''\n    image_logs, infos = [], None\n    if ret and ret.strip().startswith('{') and ret.strip().endswith('}'):\n        pushd = 0\n        buf = ''\n        for char in ret:\n            buf += char\n            if char == '{':\n                pushd += 1\n            if char == '}':\n                pushd -= 1\n            if pushd == 0:\n                try:\n                    buf = json.loads(buf)\n                except Exception:\n                    pass\n                image_logs.append(buf)\n                buf = ''\n        image_logs.reverse()\n        # search last layer grabbed\n        for l in image_logs:\n            if isinstance(l, dict):\n                if l.get('status') == 'Download complete' and l.get('id'):\n                    infos = _get_image_infos(config, repo)\n                    break\n    return image_logs, infos", "response": "Parse image log strings into grokable data structures."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nassemble the error status of the image pulling the repository and return a string that can be used to display the error message.", "response": "def _pull_assemble_error_status(logs):\n    '''\n    Given input in this form::\n\n        u'{\"status\":\"Pulling repository foo/ubuntubox\"}:\n        \"image (latest) from foo/  ...\n         rogress\":\"complete\",\"id\":\"2c80228370c9\"}'\n\n    construct something like that (load JSON data is possible)::\n\n        [u'{\"status\":\"Pulling repository foo/ubuntubox\"',\n         {\"status\":\"Download\",\"progress\":\"complete\",\"id\":\"2c80228370c9\"}]\n    '''\n    comment = 'An error occurred pulling your image'\n    try:\n        for err_log in logs:\n            if isinstance(err_log, dict):\n                if 'errorDetail' in err_log:\n                    if 'code' in err_log['errorDetail']:\n                        msg = '\\n{0}\\n{1}: {2}'.format(\n                            err_log['error'],\n                            err_log['errorDetail']['code'],\n                            err_log['errorDetail']['message']\n                        )\n                    else:\n                        msg = '\\n{0}\\n{1}'.format(\n                            err_log['error'],\n                            err_log['errorDetail']['message'],\n                        )\n                    comment += msg\n    except Exception as e:\n        comment += \"%s\"%e\n    return comment"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_container(config,\n                     image,\n                     command=None,\n                     hostname=None,\n                     user=None,\n                     detach=True,\n                     entrypoint=None,\n                     stdin_open=False,\n                     tty=False,\n                     mem_limit=0,\n                     cpu_shares=None,\n                     ports=None,\n                     environment=None,\n                     dns=None,\n                     volumes=None,\n                     volumes_from=None,\n                     name=None,\n                     *args, **kwargs):\n    '''\n    Create a new container\n\n    image\n        image to create the container from\n    command\n        command to execute while starting\n    hostname\n        hostname of the container\n    user\n        user to run docker as\n    detach\n        daemon mode\n    entrypoint\n        entrypoint to the container\n    stdin_open\n        let stdin open\n    tty\n        attach ttys\n    mem_limit:\n        memory size limit\n    cpu_shares:\n        cpu shares authorized\n    ports\n        ports redirections ({'222': {}})\n    environment\n        environment variable mapping ({'foo':'BAR'})\n    dns\n        list of DNS servers\n    volumes\n        list of volumes mapping::\n\n            (['/mountpoint/in/container:/guest/foo',\n              '/same/path/mounted/point'])\n    volumes_from\n        container to get volumes definition from\n    name\n        name given to container\n\n    Returns: created container / None\n    '''\n\n    err = \"Unknown\"\n    client = _get_client(config)\n    try:\n        img_infos = _get_image_infos(config, image)\n        mountpoints = {}\n        binds = {}\n        # create empty mountpoints for them to be\n        # editable\n        # either we have a list of guest or host:guest\n        if isinstance(volumes, list):\n            for mountpoint in volumes:\n                mounted = mountpoint\n                if ':' in mountpoint:\n                    parts = mountpoint.split(':')\n                    mountpoint = parts[1]\n                    mounted = parts[0]\n                mountpoints[mountpoint] = {}\n                binds[mounted] = mountpoint\n        info = _set_id(client.create_container(\n            image=image,\n            command=command,\n            hostname=hostname,\n            user=user,\n            entrypoint=entrypoint,\n            detach=detach,\n            stdin_open=stdin_open,\n            tty=tty,\n            mem_limit=mem_limit,\n            ports=ports,\n            environment=environment,\n            dns=dns,\n            volumes=mountpoints,\n            volumes_from=volumes_from,\n            name=name,\n            cpu_shares=cpu_shares\n        ))\n        print \"Container '%s' created.\"%info['Id']\n        return info\n    except Exception as e:\n        err = e\n    utils.error(\"Unable to create your container: %s\"%err)\n    return None", "response": "Create a new container from a container image command hostname user daemon mode stdin open tty and environment variable mapping for the container name given to the container"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstops a running container", "response": "def stop(config, container, timeout=10, *args, **kwargs):\n    '''\n    Stop a running container\n\n    :type container: string\n    :param container: The container id to stop\n\n    :type timeout: int\n    :param timeout: Wait for a timeout to let the container exit gracefully\n        before killing it\n\n    :rtype: dict\n    :returns: boolean\n    '''\n    err = \"Unknown\"\n    client = _get_client(config)\n    try:\n        dcontainer = _get_container_infos(config, container)['Id']\n        if is_running(config, dcontainer):\n            client.stop(dcontainer, timeout=timeout)\n            if not is_running(config, dcontainer):\n                print \"Container stopped.\"\n                return True\n            else:\n                i = 0\n                while is_running(config, dcontainer):\n                    time.sleep(0.1)\n                    if i > 100:\n                        return kill(config,container)\n                    i += 1\n                return True\n        else:\n            return True\n    except Exception as e:\n        err = e\n    utils.warning(\"Container not existing\")\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef kill(config, container, *args, **kwargs):\n    '''\n    Kill a running container\n\n    :type container: string\n    :param container: The container id to kill\n\n    :rtype: dict\n    :returns: boolean\n    '''\n    err = \"Unknown\"\n    client = _get_client(config)\n    try:\n        dcontainer = _get_container_infos(config, container)['Id']\n        if is_running(config, dcontainer):\n            client.kill(dcontainer)\n            if not is_running(config, dcontainer):\n                print \"Container killed.\"\n                return True\n        else:\n            print \"Container not running.\"\n            return True\n    except Exception as e:\n        err = e\n    utils.error(\"Unable to kill the container: %s\"%err)\n    return False", "response": "Kill a running container"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_container(config, container=None, force=True, v=False, *args, **kwargs):\n    '''\n    Removes a container from a docker installation\n\n    container\n        Container id to remove\n    force\n        By default, remove a running container, set this\n        to notremove it unconditionally\n    v\n        verbose mode\n\n    Return boolean\n    '''\n    err = \"Unknown\"\n    client = _get_client(config)\n    dcontainer = None\n    try:\n        try:\n            dcontainer = _get_container_infos(config, container)['Id']\n        except Exception:\n#            print \"Container not existing.\"\n            return True\n        else:\n            if not dcontainer:\n                return True\n            if is_running(config, dcontainer):\n                if not force:\n                    utils.error(\"Container running, won't remove it.\")\n                    return False\n                else:\n                    kill(config, dcontainer)\n            client.remove_container(dcontainer, v=v)\n            try:\n                infos = _get_container_infos(config, dcontainer)\n                if not infos:\n                    return True\n            except Exception:\n#                print \"Container has been successfully removed.\"\n                return True\n    except Exception as e:\n        err = e\n    utils.error(\"Unable to remove container: %s\"%err)\n    return False", "response": "Remove a container from a docker installation"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef restart(config, container, timeout=10, *args, **kwargs):\n    '''\n    Restart a running container\n\n    :type container: string\n    :param container: The container id to restart\n\n    :type timout: int\n    :param timeout: Wait for a timeout to let the container exit gracefully\n        before killing it\n\n    :rtype: dict\n    :returns: boolean\n    '''\n    err = \"Unknown\"\n    client = _get_client(config)\n    try:\n        dcontainer = _get_container_infos(config, container)['Id']\n        client.restart(dcontainer, timeout=timeout)\n        if is_running(config, dcontainer):\n            print \"Container restarted.\"\n            return True\n    except Exception as e:\n        err = e\n    if stop(config, container, timeout):\n        ret = start(config, container)\n        if ret: return True\n    utils.error(\"Unable to restart the container: %s\"%err)\n    return False", "response": "Restart a running container"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstarting the specified container container Container id Returns boolean", "response": "def start(config, container, binds=None, ports=None, port_bindings=None,\n          lxc_conf=None, publish_all_ports=None, links=None,\n          privileged=False,\n          *args, **kwargs):\n    '''\n    Start the specified container\n\n    container\n        Container id\n    Returns boolean\n    '''\n    if not binds:\n        binds = {}\n    if not ports:\n        ports = {}\n    err = \"Unknown\"\n    client = _get_client(config)\n    try:\n        dcontainer = _get_container_infos(config, container)['Id']\n        if not is_running(config, container):\n            bindings = None\n            if port_bindings is not None:\n                print \"Binding container ports ...\"\n                bindings = {}\n                for k, v in port_bindings.iteritems():\n                    bindings[k] = (v.get('HostIp', ''), v['HostPort'])\n            client.start(dcontainer, binds=binds, port_bindings=bindings,\n                         lxc_conf=lxc_conf,\n                         publish_all_ports=publish_all_ports, links=links,\n                         privileged=privileged)\n            if is_running(config, dcontainer):\n                print \"Container has been started.\"\n                return _get_container_infos(config, container)\n        else:\n            print \"Container is already started.\"\n            return _get_container_infos(config, container)\n    except Exception as e:\n        err = e\n    utils.error(\"Unable to start your container: %s\"%err)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists docker images in a repository", "response": "def get_images(config, name=None, quiet=False, all=True, *args, **kwargs):\n    '''\n    List docker images\n\n    :type name: string\n    :param name: A repository name to filter on\n\n    :type quiet: boolean\n    :param quiet: Only show image ids\n\n    :type all: boolean\n    :param all: Show all images\n\n    :rtype: dict\n    :returns: the images\n    '''\n    err = \"Unknown\"\n    client = _get_client(config)\n    try:\n        infos = client.images(name=name, quiet=quiet, all=all)\n        for i in range(len(infos)):\n            inf = _set_id(infos[i])\n            try:\n                inf['Human_Size'] = _sizeof_fmt(int(inf['Size']))\n            except ValueError:\n                pass\n            try:\n                ts = int(inf['Created'])\n                dts = datetime.datetime.fromtimestamp(ts)\n                inf['Human_IsoCreated'] = dts.isoformat()\n                inf['Human_Created'] = dts.strftime(\n                    '%Y-%m-%d %H:%M:%S')\n            except Exception:\n                pass\n            try:\n                inf['Human_VirtualSize'] = (\n                    _sizeof_fmt(int(inf['VirtualSize'])))\n            except ValueError:\n                pass\n        return infos\n    except Exception as e:\n        err = e\n    utils.error(\"Unable to list Docker images: %s\"%err)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_containers(config,\n                   all=True,\n                   trunc=False,\n                   since=None,\n                   before=None,\n                   limit=-1,\n                   *args,\n                   **kwargs):\n    '''\n    Get a list of mappings representing all containers\n\n    all\n        Return all containers\n\n    trunc\n        Set it to True to have the short ID\n\n    Returns a mapping of containers\n    '''\n    err = \"Unknown\"\n    client = _get_client(config)\n    try:\n        ret = client.containers(all=all,\n                                trunc=trunc,\n                                since=since,\n                                before=before,\n                                limit=limit)\n        return ret\n    except Exception as e:\n        err = e\n    utils.error(\"Unable to list Docker containers: %s\"%err)\n    return None", "response": "Get a list of containers in a given order"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef login(config, username=None, password=None, email=None, url=None, client=None, *args, **kwargs):\n    '''\n    Wrapper to the docker.py login method\n    '''\n    try:\n        c = (_get_client(config) if not client else client)\n        lg = c.login(username, password, email, url)\n        print \"%s logged to %s\"%(username,(url if url else \"default hub\"))\n    except Exception as e:\n        utils.error(\"%s can't login to repo %s: %s\"%(username,(url if url else \"default repo\"),e))\n        return False\n    return True", "response": "Wrapper to the docker. py login method"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a new container with the given name image entrypoint command hostname and environment variables.", "response": "def installed(config,\n              name,\n              image,\n              entrypoint=None,\n              command=None,\n              hostname=None,\n              user=None,\n              detach=True,\n              stdin_open=False,\n              tty=False,\n              mem_limit=0,\n              cpu_shares=None,\n              ports=None,\n              environment=None,\n              dns=None,\n              volumes=None,\n              volumes_from=None,\n              force=True,\n              *args, **kwargs):\n    '''\n    Ensure that a container with the given name exists;\n    if not, build a new container from the specified image.\n    (`docker run`)\n\n    name\n        Name for the container\n    image\n        Image from which to build this container\n    entrypoint\n        Entrypoint of the container\n    command\n        command to execute while starting\n    hostname\n        hostname of the container\n    user\n        user to run docker as\n    detach\n        daemon mode\n    entrypoint\n        entrypoint to the container\n    stdin_open\n        let stdin open\n    tty\n        attach ttys\n    mem_limit:\n        memory size limit\n    cpu_shares:\n        cpu shares authorized\n    ports\n        ports redirections ({'222': {}})\n    environment\n        environment variable mapping ({'foo':'BAR'})\n    dns\n        list of DNS servers\n    ports\n        List of ports definitions, either:\n            - a port to map\n            - a mapping of mapping portInHost : PortInContainer\n    volumes\n        List of volumes\n    volumes_from\n\n    Returns\n        container\n\n    .. note::\n        This command does not verify that the named container\n        is running the specified image.\n    '''\n    iinfos = _get_image_infos(config, image)\n    if not iinfos:\n        utils.error(\"Image not found.\")\n        return None\n    cinfos = _get_container_infos(config, name)\n    force = (config[\"force\"] if config.get(\"force\") != None else force)\n    if cinfos and force:\n        remove_container(config, container=name,force=True)\n        print \"Old container removed.\"\n    elif cinfos and (not force):\n        print \"Container found: %s.\"%cinfos.get(\"Id\")\n        return cinfos\n\n    dports, dvolumes, denvironment, de = {}, [], {}, {}\n    if not ports:\n        ports = []\n    if not volumes:\n        volumes = []\n    if isinstance(environment, dict):\n        print \"Setting environment ...\"\n        for k in environment:\n            denvironment[u'%s' % k] = u'%s' % environment[k]\n    if isinstance(environment, list):\n        print \"Setting environment ...\"\n        for p in environment:\n            if isinstance(p, dict):\n                for k in p:\n                    denvironment[u'%s' % k] = u'%s' % p[k]\n    if ports:\n        print \"Setting ports mapping ...\"\n        for p in ports:\n            if not isinstance(p, dict):\n                dports[str(p)] = {}\n            else:\n                for k in p:\n                    dports[str(p)] = {}\n    if volumes:\n        print \"Setting volumes ...\"\n        for p in volumes:\n            vals = []\n            if not isinstance(p, dict):\n                vals.append('%s' % p)\n            else:\n                for k in p:\n                    vals.append('{0}:{1}'.format(k, p[k]))\n            dvolumes.extend(vals)\n    container = create_container(\n        config,\n        image=image,\n        command=command,\n        entrypoint=entrypoint,\n        hostname=hostname,\n        user=user,\n        detach=detach,\n        stdin_open=stdin_open,\n        tty=tty,\n        mem_limit=mem_limit,\n        ports=dports,\n        environment=denvironment,\n        dns=dns,\n        volumes=dvolumes,\n        volumes_from=volumes_from,\n        name=name)\n\n    if container:\n        print \"Container created, id: %s\"%(container.get(\"Id\"))\n    else:\n        utils.error(\"Couldn't create container.\")\n    return container"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of containers that are running.", "response": "def running(config,\n            containers,\n            image,\n            tag=None,\n            entrypoint=None,\n            command=None,\n            environment=None,\n            ports=None,\n            volumes=None,\n            mem_limit=0,\n            cpu_shares=None,\n            binds=None,\n            publish_all_ports=False,\n            links=None,\n            port_bindings=None,\n            force=True,\n            hostname=None,\n            *args, **kwargs):\n    '''\n    Ensure that a container is running. (`docker inspect`)\n\n    containers\n        name of the containers to start\n    image\n        name of the image to start the container from\n    entrypoint\n        Entrypoint of the container\n    command\n        command to execute while starting\n    environment\n        environment variable mapping ({'foo':'BAR'})\n    ports\n        List of ports definitions, either:\n            - a port to map\n            - a mapping of mapping portInHost : PortInContainer\n    volumes\n        List of volumes\n    mem_limit:\n        memory size limit\n    cpu_shares:\n        cpu shares authorized\n    binds\n        like -v of docker run command\n    publish_all_ports\n    links\n        Link several container together\n    port_bindings\n        List of ports to expose on host system\n            - a mapping port's guest, hostname's host and port's host.\n\n    Returns\n        Container Id\n    '''\n    if not containers:\n        utils.warning(\"No container specified\")\n        return [], True\n\n    if ports and port_bindings:\n        (ports,port_bindings) = _gen_ports(ports,port_bindings,len(containers))\n        if not ports or not port_bindings:\n            utils.error(\"Unable to generate port bindings (is there enough space between each allocation required?)\")\n            return [], True\n\n    containers_out = []\n    failure = False\n\n    if tag:\n        image = \"%s:%s\"%(image,tag)\n\n    for container in containers:\n        port = (ports.pop() if ports else None)\n        port_binding = (port_bindings.pop() if port_bindings else None)\n        ret = installed(config,\n                        container,image,entrypoint=entrypoint,command=command,environment=environment,ports=port,\n                        volumes=volumes,mem_limit=mem_limit,cpu_shares=cpu_shares,force=force,hostname=hostname)\n        if ret:\n            started = start(config,\n                container, binds=binds, port_bindings=port_binding,\n                publish_all_ports=publish_all_ports, links=links)\n            if is_running(config, container) and started:\n                print \"Container started, id: %s\"%started.get(\"Id\")\n                containers_out.append(started)\n            else:\n                failure = True\n                utils.error(\"Unable to run container: %s - can't start\"%container)\n        else:\n            failure = True\n            utils.error(\"Unable to run container: %s - can't install\"%container)\n\n    return containers_out, failure"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npulls an image from any registry.", "response": "def pull(config, repo, tag=None, username=None, password=None, email=None, *args, **kwargs):\n    '''\n    Pulls an repo from any registry. See above documentation for\n    how to configure authenticated access.\n\n    :type repo: string\n    :param repo: The repository to pull. \\\n        [registryurl://]REPOSITORY_NAME\n        eg::\n\n            index.docker.io:MyRepo\n            superaddress.cdn:MyRepo\n            MyRepo\n\n    :type tag: string\n    :param tag: The specific tag  to pull\n\n    :rtype: dict\n    :returns: the repo details\n    '''\n    err = \"Unknown\"\n    client = _get_client(config)\n    try:\n        if username:\n            url = repo.split(\":\")\n            url = (url[0] if len(url) > 1 else None)\n            if not login(config,username,password,email,url):\n                raise Exception(\"Can't login\")\n        print \"Pulling repository %s ... (This may take a while)\"%repo\n        ret = client.pull(repo, tag=tag)\n        if ret:\n            logs, infos = _parse_image_multilogs_string(config, ret, repo)\n            if infos and infos.get('Id', None):\n                repotag = repo\n                if tag:\n                    repotag = '{0}:{1}'.format(repo, tag)\n                print 'Repo {0} was pulled ({1})'.format(repotag, infos['Id'])\n                return infos, False\n            else:\n                err = _pull_assemble_error_status(logs)\n    except Exception as e:\n        err = e\n    utils.error(\"An error has occured pulling repo %s: %s\"%(repo,err))\n    return None, True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_hosts(config, app):\n    '''\n    app: {\n        \"container id\": continer details\n        ...\n    }\n    '''\n#    hosts = {app[container][\"NetworkSettings\"][\"IPAddress\"]:app[container][\"Name\"].replace('/','') for container in app}\n    hosts = {}\n    for container in app:\n        hosts[app[container][\"NetworkSettings\"][\"IPAddress\"]] = [app[container][\"Name\"].replace('/','')]\n    for container in app:\n        path = (app[container][\"HostsPath\"]\n                if boot2docker.has() is not True\n                else os.path.join(config[\"config_path\"],\"docker\",\"containers\",app[container][\"Id\"],\"hosts\"))\n        try:\n            with open(path, 'r+') as f:\n                for host in hosts:\n                    f.write(\"%s\\t%s\\n\"%(host,\" \".join(hosts[host])))\n        except Exception as e:\n            utils.error(e)", "response": "app: {\n        \"container id\": continer details\n        ...\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeactivates the Component. :return: Method success. :rtype: bool", "response": "def deactivate(self):\n        \"\"\"\n        Deactivates the Component.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        LOGGER.debug(\"> Deactivating '{0}' Component.\".format(self.__class__.__name__))\n\n        self.__engine = None\n        self.__settings = None\n        self.__settings_section = None\n\n        self.__script_editor = None\n\n        self.activated = False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the Component ui.", "response": "def initialize_ui(self):\n        \"\"\"\n        Initializes the Component ui.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        LOGGER.debug(\"> Initializing '{0}' Component ui.\".format(self.__class__.__name__))\n        self.__model = ProjectsProxyModel(self)\n        self.__model.setSourceModel(self.__script_editor.model)\n        self.__delegate = RichText_QStyledItemDelegate(self, self.__style)\n\n        self.Projects_Explorer_treeView.setParent(None)\n        self.Projects_Explorer_treeView = Projects_QTreeView(self, self.__model)\n        self.Projects_Explorer_treeView.setItemDelegate(self.__delegate)\n        self.Projects_Explorer_treeView.setObjectName(\"Projects_Explorer_treeView\")\n        self.Projects_Explorer_treeView.setContextMenuPolicy(Qt.ActionsContextMenu)\n        self.Projects_Explorer_dockWidgetContents_gridLayout.addWidget(self.Projects_Explorer_treeView, 0, 0)\n        self.__view = self.Projects_Explorer_treeView\n        self.__view_add_actions()\n\n        self.__add_actions()\n\n        # Signals / Slots.\n        self.__view.expanded.connect(self.__view__expanded)\n        self.__view.doubleClicked.connect(self.__view__doubleClicked)\n        self.__view.selectionModel().selectionChanged.connect(self.__view_selectionModel__selectionChanged)\n        self.__script_editor.Script_Editor_tabWidget.currentChanged.connect(\n            self.__script_editor_Script_Editor_tabWidget__currentChanged)\n        self.__script_editor.model.project_registered.connect(self.__script_editor_model__project_registered)\n\n        self.initialized_ui = True\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef uninitialize_ui(self):\n\n        LOGGER.debug(\"> Uninitializing '{0}' Component ui.\".format(self.__class__.__name__))\n\n        self.__remove_actions()\n\n        # Signals / Slots.\n        self.__view.expanded.disconnect(self.__view__expanded)\n        self.__view.doubleClicked.disconnect(self.__view__doubleClicked)\n        self.__view.selectionModel().selectionChanged.disconnect(self.__view_selectionModel__selectionChanged)\n        self.__script_editor.Script_Editor_tabWidget.currentChanged.disconnect(\n            self.__script_editor_Script_Editor_tabWidget__currentChanged)\n        self.__script_editor.model.project_registered.disconnect(self.__script_editor_model__project_registered)\n\n        self.__view_remove_actions()\n\n        self.__model = None\n        self.__delegate = None\n        self.__view = None\n\n        self.initialized_ui = False\n        return True", "response": "Uninitializes the Component ui."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __add_actions(self):\n\n        LOGGER.debug(\"> Adding '{0}' Component actions.\".format(self.__class__.__name__))\n\n        add_project_action = self.__engine.actions_manager.get_action(\n            \"Actions|Umbra|Components|factory.script_editor|&File|Add Project ...\")\n        remove_project_action = self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|factory.script_editor|&File|Remove Project\",\n            slot=self.__view_remove_project_action__triggered)\n        self.__script_editor.file_menu.insertAction(add_project_action, remove_project_action)\n        self.__script_editor.file_menu.removeAction(add_project_action)\n        self.__script_editor.file_menu.insertAction(remove_project_action, add_project_action)", "response": "Adds the actions to the file menu."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding the view actions.", "response": "def __view_add_actions(self):\n        \"\"\"\n        Sets the View actions.\n        \"\"\"\n\n        self.__view.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|addons.projects_explorer|Add Project ...\",\n            slot=self.__view_add_project_action__triggered))\n        self.__view.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|addons.projects_explorer|Remove Project\",\n            slot=self.__view_remove_project_action__triggered))\n\n        separator_action = QAction(self.__view)\n        separator_action.setSeparator(True)\n        self.__view.addAction(separator_action)\n\n        self.__view.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|addons.projects_explorer|Add New File ...\",\n            slot=self.__view_add_new_file_action__triggered))\n        self.__view.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|addons.projects_explorer|Add New Directory ...\",\n            slot=self.__view_add_new_directory_action__triggered))\n\n        separator_action = QAction(self.__view)\n        separator_action.setSeparator(True)\n        self.__view.addAction(separator_action)\n\n        self.__view.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|addons.projects_explorer|Rename ...\",\n            slot=self.__view_rename_action__triggered))\n        # self.__view.addAction(self.__engine.actions_manager.register_action(\n        # \"Actions|Umbra|Components|addons.projects_explorer|Copy ...\",\n        # slot=self.__view_copy_action__triggered))\n        # self.__view.addAction(self.__engine.actions_manager.register_action(\n        # \"Actions|Umbra|Components|addons.projects_explorer|Move ...\",\n        # slot=self.__view_move_action__triggered))\n\n        separator_action = QAction(self.__view)\n        separator_action.setSeparator(True)\n        self.__view.addAction(separator_action)\n\n        self.__view.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|addons.projects_explorer|Delete ...\",\n            slot=self.__view_delete_action__triggered))\n\n        separator_action = QAction(self.__view)\n        separator_action.setSeparator(True)\n        self.__view.addAction(separator_action)\n\n        self.__view.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|addons.projects_explorer|Find In Files ...\",\n            slot=self.__view_find_in_files_action__triggered))\n\n        separator_action = QAction(self.__view)\n        separator_action.setSeparator(True)\n        self.__view.addAction(separator_action)\n\n        self.__view.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|addons.projects_explorer|Output Selected Path\",\n            slot=self.__view_output_selected_path_action__triggered))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __view_remove_actions(self):\n\n        add_project_action = \"Actions|Umbra|Components|addons.projects_explorer|Add Project ...\"\n        remove_project_action = \"Actions|Umbra|Components|addons.projects_explorer|Remove Project\"\n        add_new_file_action = \"Actions|Umbra|Components|addons.projects_explorer|Add New File ...\"\n        add_new_directory_action = \"Actions|Umbra|Components|addons.projects_explorer|Add New Directory ...\"\n        rename_action = \"Actions|Umbra|Components|addons.projects_explorer|Rename ...\"\n        # copy_action = \"Actions|Umbra|Components|addons.projects_explorer|Copy ...\"\n        # move_action = \"Actions|Umbra|Components|addons.projects_explorer|Move ...\"\n        delete_action = \"Actions|Umbra|Components|addons.projects_explorer|Delete ...\"\n        find_in_files_action = \"Actions|Umbra|Components|addons.projects_explorer|Find In Files ...\"\n        output_selected_path_action = \"Actions|Umbra|Components|addons.projects_explorer|Output Selected Path\"\n\n        for action in (add_project_action,\n                       remove_project_action,\n                       add_new_file_action,\n                       add_new_directory_action,\n                       rename_action,\n                       # copy_action,\n                       # move_action,\n                       delete_action,\n                       output_selected_path_action):\n            self.__view.removeAction(self.__engine.actions_manager.get_action(action))\n            self.__engine.actions_manager.unregister_action(action)", "response": "Removes the View actions."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nraises a common fileSystem exception.", "response": "def __raise_file_system_exception(self, item, directory):\n        \"\"\"\n        Raises a common fileSystem exception.\n\n        :param item: Name of the item generating the exception.\n        :type item: unicode\n        :param directory: Name of the target directory.\n        :type directory: unicode\n        \"\"\"\n\n        path = os.path.join(directory, item)\n        if os.path.isfile(path):\n            raise foundations.exceptions.FileExistsError(\n                \"{0} | A file with '{1}' name already exists in '{2}' directory!\".format(self.__class__.__name__,\n                                                                                         item,\n                                                                                         directory))\n        else:\n            raise foundations.exceptions.DirectoryExistsError(\n                \"{0} | A directory with '{1}' name already exists in '{2}' directory!\".format(self.__class__.__name__,\n                                                                                              item,\n                                                                                              directory))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets given editor authoring nodes.", "response": "def __set_authoring_nodes(self, source, target):\n        \"\"\"\n        Sets given editor authoring nodes.\n\n        :param source: Source file.\n        :type source: unicode\n        :param target: Target file.\n        :type target: unicode\n        \"\"\"\n\n        editor = self.__script_editor.get_editor(source)\n        editor.set_file(target)\n        self.__script_editor.model.update_authoring_nodes(editor)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrename given source with given target name.", "response": "def __rename_path(self, source, target):\n        \"\"\"\n        Renames given source with given target name.\n\n        :param source: Source file.\n        :type source: unicode\n        :param target: Target file.\n        :type target: unicode\n        \"\"\"\n\n        if not foundations.common.path_exists(source):\n            return\n\n        parent_directory = os.path.dirname(source)\n        is_path_registered = self.__engine.file_system_events_manager.is_path_registered(parent_directory)\n        is_path_registered and self.__engine.file_system_events_manager.unregister_path(parent_directory)\n        os.rename(source, target)\n        is_path_registered and self.__engine.file_system_events_manager.register_path(parent_directory)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete given path. :param path: Path to delete. :type path: unicode", "response": "def __delete_path(self, path):\n        \"\"\"\n        Deletes given path.\n\n        :param path: Path to delete.\n        :type path: unicode\n        \"\"\"\n\n        if not foundations.common.path_exists(path):\n            return\n\n        parent_directory = os.path.dirname(path)\n        is_path_registered = self.__engine.file_system_events_manager.is_path_registered(parent_directory)\n        is_path_registered and self.__engine.file_system_events_manager.unregister_path(parent_directory)\n        foundations.io.remove(path)\n        is_path_registered and self.__engine.file_system_events_manager.register_path(parent_directory)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrenaming a file using given source and target names.", "response": "def __rename_file(self, source, target):\n        \"\"\"\n        Renames a file using given source and target names.\n\n        :param source: Source file.\n        :type source: unicode\n        :param target: Target file.\n        :type target: unicode\n        \"\"\"\n\n        for file_node in self.__script_editor.model.get_file_nodes(source, self.__script_editor.model.root_node):\n            self.__script_editor.unregister_node_path(file_node)\n            self.__rename_path(source, target)\n            self.__script_editor.register_node_path(file_node)\n            if self.__script_editor.model.is_authoring_node(file_node):\n                self.__set_authoring_nodes(source, target)\n            else:\n                self.__script_editor.model.update_project_nodes(file_node.parent)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrenaming a directory using given source and target names.", "response": "def __rename_directory(self, source, target):\n        \"\"\"\n        Renames a directory using given source and target names.\n\n        :param source: Source file.\n        :type source: unicode\n        :param target: Target file.\n        :type target: unicode\n        \"\"\"\n\n        for node in itertools.chain(self.__script_editor.model.get_project_nodes(source),\n                                    self.__script_editor.model.get_directory_nodes(source)):\n            self.__script_editor.model.unregister_project_nodes(node)\n            self.__script_editor.unregister_node_path(node)\n            self.__rename_path(source, target)\n            node.name = os.path.basename(target)\n            node.path = target\n            self.__script_editor.model.node_changed(node)\n            self.__script_editor.register_node_path(node)\n            self.__script_editor.model.set_project_nodes(node)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes given file. :param file: File to delete. :type file: unicode", "response": "def __delete_file(self, file):\n        \"\"\"\n        Deletes given file.\n\n        :param file: File to delete.\n        :type file: unicode\n        \"\"\"\n\n        for file_node in self.__script_editor.model.get_file_nodes(file, self.__script_editor.model.root_node):\n            self.__script_editor.unregister_node_path(file_node)\n            self.__delete_path(file)\n            if self.__script_editor.model.is_authoring_node(file_node):\n                self.__script_editor.get_editor(file).set_modified(True)\n            else:\n                self.__script_editor.model.unregister_file(file_node)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting given directory. :param directory: Directory to delete. :type directory: unicode", "response": "def __delete_directory(self, directory):\n        \"\"\"\n        Deletes given directory.\n\n        :param directory: Directory to delete.\n        :type directory: unicode\n        \"\"\"\n\n        for node in itertools.chain(self.__script_editor.model.get_project_nodes(directory),\n                                    self.__script_editor.model.get_directory_nodes(directory)):\n            self.__script_editor.model.unregister_project_nodes(node)\n            if node.family == \"Directory\":\n                self.__script_editor.model.unregister_project_nodes(node)\n                self.__script_editor.model.unregister_directory(node)\n            elif node.family == \"Project\":\n                self.__script_editor.remove_project(directory)\n            self.__delete_path(directory)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove the project associated with given node.", "response": "def remove_project(self, node):\n        \"\"\"\n        Removes the project associated with given node.\n\n        :param node: Node.\n        :type node: ProjectNode or DirectoryNode or FileNode\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if node.family == \"Project\":\n            self.__script_editor.remove_project(node.path)\n            return True\n\n        for node in foundations.walkers.nodes_walker(node, ascendants=True):\n            if node.family == \"Project\" and not node is self.__script_editor.model.default_project_node:\n                self.__script_editor.remove_project(node.path)\n                return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new file next to given Node associated path.", "response": "def add_new_file(self, node):\n        \"\"\"\n        Adds a new file next to given Node associated path.\n\n        :param node: Node.\n        :type node: ProjectNode or DirectoryNode or FileNode\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if self.__script_editor.model.is_authoring_node(node):\n            return self.__script_editor.new_file()\n\n        file, state = QInputDialog.getText(self, \"Add File\", \"Enter your new file name:\")\n        if not state:\n            return False\n\n        if node.family in (\"Project\", \"Directory\"):\n            directory = node.path\n        elif node.family == \"File\":\n            directory = os.path.dirname(node.path)\n\n        # file = foundations.strings.to_string(file)\n        if not file in os.listdir(directory):\n            file = os.path.join(directory, file)\n            LOGGER.info(\"{0} | Adding '{1}' file!\".format(self.__class__.__name__, file))\n            open(file, \"w\").close()\n        else:\n            self.__raise_file_system_exception(file, directory)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a new directory next to given Node associated path.", "response": "def add_new_directory(self, node):\n        \"\"\"\n        Adds a new directory next to given Node associated path.\n\n        :param node: Node.\n        :type node: ProjectNode or DirectoryNode or FileNode\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if self.__script_editor.model.is_authoring_node(node):\n            return False\n\n        directory, state = QInputDialog.getText(self, \"Add Directory\", \"Enter your new directory name:\")\n        if not state:\n            return False\n\n        if node.family in (\"Project\", \"Directory\"):\n            parent_directory = node.path\n        elif node.family == \"File\":\n            parent_directory = os.path.dirname(node.path)\n\n        directory = foundations.strings.to_string(directory)\n        if not directory in os.listdir(parent_directory):\n            directory = os.path.join(parent_directory, directory)\n            LOGGER.info(\"{0} | Adding '{1}' directory!\".format(self.__class__.__name__, directory))\n            os.makedirs(directory)\n        else:\n            self.__raise_file_system_exception(file, parent_directory)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rename(self, node):\n\n        source = node.path\n        base_name, state = QInputDialog.getText(self, \"Rename\", \"Enter your new name:\", text=os.path.basename(source))\n        if not state:\n            return False\n\n        base_name = foundations.strings.to_string(base_name)\n        if base_name == os.path.basename(source):\n            return False\n\n        parent_directory = os.path.dirname(source)\n        target = os.path.join(parent_directory, base_name)\n\n        if self.__script_editor.model.is_authoring_node(node):\n            if not foundations.common.path_exists(source):\n                LOGGER.info(\"{0} | Renaming '{1}' untitled file to '{2}'!\".format(\n                    self.__class__.__name__, source, target))\n                self.__set_authoring_nodes(source, target)\n                return True\n\n        if not base_name in os.listdir(parent_directory):\n            if node.family == \"File\":\n                LOGGER.info(\"{0} | Renaming '{1}' file to '{2}'!\".format(self.__class__.__name__, source, target))\n                self.__rename_file(source, target)\n            elif node.family == \"Directory\":\n                LOGGER.info(\"{0} | Renaming '{1}' directory to '{2}'!\".format(self.__class__.__name__, source, target))\n                self.__rename_directory(source, target)\n            elif node.family == \"Project\":\n                LOGGER.info(\"{0} | Renaming '{1}' project to '{2}'!\".format(self.__class__.__name__, source, target))\n                self.__rename_project(source, target)\n        else:\n            self.__raise_file_system_exception(base_name, parent_directory)\n\n        return True", "response": "Renames given Node associated path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete(self, node):\n\n        path = node.path\n        if self.__script_editor.model.is_authoring_node(node):\n            if not foundations.common.path_exists(path):\n                return False\n\n        if message_box.message_box(\"Question\", \"Question\",\n                                   \"Are you sure you want to delete '{0}' {1}?\".format(\n                                           path, \"file\" if os.path.isfile(path) else \"directory\"),\n                                   buttons=QMessageBox.Yes | QMessageBox.No) == QMessageBox.Yes:\n            if os.path.isfile(path):\n                LOGGER.info(\"{0} | Deleting '{1}' file!\".format(self.__class__.__name__, path))\n                self.__delete_file(path)\n            else:\n                LOGGER.info(\"{0} | Deleting '{1}' directory!\".format(self.__class__.__name__, path))\n                self.__delete_directory(path)\n        return True", "response": "Deletes given Node associated path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding object by GlobalID and return appropriate model instance.", "response": "def get_object_by_global_id(global_id):\n        \"\"\"\n        Find object by GlobalID and return appropriate model instance.\n        \"\"\"\n        app_name, tail = global_id.split('/', 1)\n        model_name, object_id = tail.split('#', 1)\n        path_to_controller = \"{}/controllers/{}\".format(app_name, model_name.lower())\n        model = import_module(path_to_controller)\n        return model.get_object_by_id(object_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _to_dict(self):\n        physical_prop_names = find_PhysicalProperty(self)\n        physical_prop_vals = [getattr(self, prop) for prop in physical_prop_names]\n\n        return dict(zip(physical_prop_names, physical_prop_vals))", "response": "Return a dictionary representation of the current object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the power density of the system.", "response": "def calc_power_density(self):\n        \"\"\"\n        Solar cell power density\n\n        The output power density is calculated according to a slight modification of Shockley & Queisser's :cite:`10.1063/1.1736034` Eq. 2.4. This method returns values of type :class:`astropy.units.Quantity` with units of [W m^-2].\n        \"\"\"\n        if self.bandgap == 0:\n            solar_flux = units.Quantity(0., \"1/(m2*s)\")\n        else:\n            solar_flux = uibei(2, self.bandgap, self.temp_sun, 0)\n        power_density = self.bandgap * solar_flux\n\n        return power_density.to(\"W/m^2\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the current cell efficiency based on the power density of the solar cell and the blackbody radiant power density of the blackbody.", "response": "def calc_efficiency(self):\n        \"\"\"\n        Solar cell efficiency\n\n        The efficiency is calculated according to Shockley & Queisser's :cite:`10.1063/1.1736034` Eq. 2.8. This method returns a :class:`float`.\n        \"\"\"\n        cell_power = self.calc_power_density()\n        solar_power = self.calc_blackbody_radiant_power_density()\n        efficiency = cell_power/solar_power\n\n        return efficiency.decompose().value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting up the list of advices and evens for the current locale.", "response": "def setup(self, *args):\n        \"\"\"\n        Set up the list of responses, with weights. If the weight of a response\n        is 'eq', it will be assigned a value that splits what is left after\n        everything that has a number is assigned. If it's weight is some\n        fraction of 'eq' (ie: 'eq/2' or 'eq/3'), then it will be assigned\n        1/2, 1/3, etc of the 'eq' weight. All probabilities will add up to\n        1.0 (plus or minus any rounding errors).\n        \"\"\"\n\n        responses = [\n            ('Yes.', 'eq'),\n            ('How should I know?', 'eq'),\n            ('Try asking a human', 'eq'),\n            ('Eww.', 'eq'),\n            ('You\\'d just do the opposite of whatever I tell you', 'eq'),\n            ('No.', 'eq'),\n            ('Nope.', 'eq'),\n            ('Maybe.', 'eq'),\n            ('Possibly.', 'eq'),\n            ('It could be.', 'eq'),\n            (\"No. No, I don't think so.\", 'eq/2'),\n            ('Without a doubt.', 'eq/2'),\n            ('I think... Yes.', 'eq/2'),\n            ('Heck yes!', 'eq/2'),\n            ('Maybe. Possibly. It could be.', 'eq/2'),\n            ('Ask again later.', 'eq/3'),\n            (\"I don't know.\", 'eq/3'),\n            (\"I'm sorry, I was thinking of bananas\", 'eq/100'),\n        ]\n\n        self.advices = [(x, 1) for x in obliques]\n        total_prob = 0\n        real_resp = []\n        evens = []\n        for resp, prob in responses:\n            if isinstance(prob, str):\n                if prob.startswith('eq'):\n                    sp = prob.split('/')\n                    if len(sp) == 1:\n                        evens.append((resp, 1))\n                    else:\n                        div = int(sp[1])\n                        evens.append((resp, 1.0 / div))\n\n            else:\n                real_resp.append((resp, prob))\n                total_prob += prob\n\n        # Share is the probability of a \"eq\" probability. Share/2 would be the\n        # probability of a \"eq/2\" probability.\n        share = (1 - total_prob) / sum(div for _, div in evens)\n        for resp, divisor in evens:\n            real_resp.append((resp, share * divisor))\n\n        self.responses = real_resp\n        self.is_question = re.compile('.*\\?(\\?|!)*$')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef nodes():\n    '''\n    List running nodes on all enabled cloud providers. Automatically flushes caches\n    '''\n    for name, provider in env.providers.items():\n        print name\n        provider.nodes()\n        print", "response": "List running nodes on all enabled cloud providers. Automatically flushes caches\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(provider, count=1, name=None, **kwargs):\n    r'''\n    Create one or more cloud servers\n\n    Args:\n        * provider (str): Cloud provider, e.g. ec2, digitalocean\n        * count (int) =1: Number of instances\n        * name (str) =None: Name of server(s)\n        * \\**kwargs: Provider-specific flags\n    '''\n    count = int(count)\n    provider = provider_by_name(provider)\n    options = provider.create_server_defaults\n    options.update(kwargs)\n    names = [name] * count\n    provider.validate_create_options(**options)\n    return provider.create_servers(count, names, **options)", "response": "r Create one or more cloud servers in a Cloud provider."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ssh(cmd=''):\n    '''\n    SSH into the server(s) (sequentially if more than one)\n\n    Args:\n        cmd (str) ='': Command to run on the server\n    '''\n    with settings(warn_only=True):\n        local('ssh -A -o StrictHostKeyChecking=no -i \"%s\" %s@%s \"%s\"' % (\n            env.key_filename, env.user, env.host, cmd))", "response": "SSH into the server ( s )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pricing(sort='cost', **kwargs):\n    '''\n    Print pricing tables for all enabled providers\n    '''\n    for name, provider in env.providers.items():\n        print name\n        provider.pricing(sort, **kwargs)\n        print", "response": "Print pricing tables for all enabled providers."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main(args, stop=False):\n    daemon = AMQPDaemon(\n        con_param=getConParams(\n            settings.RABBITMQ_LTP_VIRTUALHOST\n        ),\n        queue=settings.RABBITMQ_LTP_INPUT_QUEUE,\n        out_exch=settings.RABBITMQ_LTP_EXCHANGE,\n        out_key=settings.RABBITMQ_LTP_OUTPUT_KEY,\n        react_fn=reactToAMQPMessage,\n        glob=globals()                # used in deserializer\n    )\n\n    if not stop and args.foreground:  # run at foreground\n        daemon.run()\n    else:\n        daemon.run_daemon()", "response": "Main entry point for the daemon."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getConParams(virtualhost):\n    return pika.ConnectionParameters(\n        host=settings.RABBITMQ_HOST,\n        port=int(settings.RABBITMQ_PORT),\n        virtual_host=virtualhost,\n        credentials=pika.PlainCredentials(\n            settings.RABBITMQ_USER_NAME,\n            settings.RABBITMQ_USER_PASSWORD\n        )\n    )", "response": "Returns a Connection object builder."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef onMessageReceived(self, method_frame, properties, body):\n        # if UUID is not in headers, just ack the message and ignore it\n        if \"UUID\" not in properties.headers:\n            self.process_exception(\n                e=ValueError(\"No UUID provided, message ignored.\"),\n                uuid=\"\",\n                routing_key=self.parseKey(method_frame),\n                body=body\n            )\n            return True  # ack message\n\n        key = self.parseKey(method_frame)\n        uuid = properties.headers[\"UUID\"]\n        try:\n            result = self.react_fn(\n                serializers.deserialize(body, self.globals),\n                self.get_sendback(uuid, key)\n            )\n\n            print \"sending response\", key\n\n            self.sendResponse(\n                serializers.serialize(result),\n                uuid,\n                key\n            )\n        except Exception, e:\n            self.process_exception(\n                e=e,\n                uuid=uuid,\n                routing_key=key,\n                body=str(e),\n                tb=traceback.format_exc().strip()\n            )\n\n        return True", "response": "React to received message - deserialize it add it to users reaction\n            function stored in self. react_fn and send back result."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a function which returns a function which takes only one data argument and returns a reference to the function which takes only one data argument.", "response": "def get_sendback(self, uuid, key):\n        \"\"\"\n        Return function for sending progress messages back to original caller.\n\n        Args:\n            uuid (str): UUID of the received message.\n            key (str): Routing key.\n\n        Returns:\n            fn reference: Reference to function which takes only one data \\\n                          argument.\n        \"\"\"\n        def send_back_callback(data):\n            self.sendResponse(\n                serializers.serialize(data),\n                uuid,\n                key\n            )\n\n        return send_back_callback"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_exception(self, e, uuid, routing_key, body, tb=None):\n        # get informations about message\n        msg = e.message if hasattr(e, \"message\") else str(e)\n        exception_type = str(e.__class__)\n        exception_name = str(e.__class__.__name__)\n\n        print \"Sending exception %s: %s for UUID %s.\" % (\n            exception_name,\n            msg,\n            uuid\n        )\n\n        self.sendMessage(\n            self.output_exchange,\n            routing_key,\n            str(body),\n            properties=pika.BasicProperties(\n                content_type=\"application/text\",\n                delivery_mode=2,\n                headers={\n                    \"exception\": msg,\n                    \"exception_type\": exception_type,\n                    \"exception_name\": exception_name,\n                    \"traceback\": tb,\n                    \"UUID\": uuid\n                }\n            )\n        )", "response": "This method serializes the exception and sends it over the output exchange."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setType(self, polygonID, polygonType):\n        self._connection._beginMessage(\n            tc.CMD_SET_POLYGON_VARIABLE, tc.VAR_TYPE, polygonID, 1 + 4 + len(polygonType))\n        self._connection._packString(polygonType)\n        self._connection._sendExact()", "response": "Sets the type of the polygon."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setShape(self, polygonID, shape):\n        self._connection._beginMessage(tc.CMD_SET_POLYGON_VARIABLE,\n                                       tc.VAR_SHAPE, polygonID, 1 + 1 + len(shape) * (8 + 8))\n        self._connection._string += struct.pack(\"!BB\",\n                                                tc.TYPE_POLYGON, len(shape))\n        for p in shape:\n            self._connection._string += struct.pack(\"!dd\", p)\n        self._connection._sendExact()", "response": "setShape - Sets the shape of the specified polygon."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setColor(self, polygonID, color):\n        self._connection._beginMessage(\n            tc.CMD_SET_POLYGON_VARIABLE, tc.VAR_COLOR, polygonID, 1 + 1 + 1 + 1 + 1)\n        self._connection._string += struct.pack(\"!BBBBB\", tc.TYPE_COLOR, int(\n            color[0]), int(color[1]), int(color[2]), int(color[3]))\n        self._connection._sendExact()", "response": "Sets the rgba color of the specified polygon."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the filled flag of the specified polygon.", "response": "def setFilled(self, polygonID, filled):\n        \"\"\"setFilled(string) -> bool\n        Returns whether the polygon is filled\n        \"\"\"\n        self._connection._sendUByteCmd(\n            tc.CMD_SET_POLYGON_VARIABLE, tc.VAR_FILL, polygonID, (1 if filled else 0))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef p_AccessObj(p):\n    '''\n    AccessObj : Expression DOT INDENTIFIER\n              | Expression LBRACKET Expression RBRACKET\n              | Expression LBRACKET RBRACKET\n    '''\n    if len(p) <= 4:\n        if p[2] == '.':\n            p[0] = AccessObj(p[1], p[3], None)\n        else:\n            p[0] = AccessObj(p[1], None, None)\n    else:\n        p[0] = AccessObj(p[1], None, p[3])", "response": "AccessObj is a syntax tree for the tree structure."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef p_Varible(p):\n    '''\n    Varible : NsContentName\n            | NsContentName SCOPEOP INDENTIFIER\n            | NsContentName SCOPEOP CLASS\n            | STATIC SCOPEOP INDENTIFIER\n    '''\n    if len(p) < 3:\n        p[0] = Varible(None, p[1])\n    else:\n        p[0] = Varible(p[1], p[3])", "response": "Varible is a wrapper for the two types of tokens that are not part of the tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef p_Arg(p):\n    '''\n    Arg : Expression ThreeDotModifier\n    '''\n    if len(p) <= 2:\n        p[0] = Arg(p[1], None)\n    else:\n        p[0] = Arg(p[1], p[2])", "response": "Arg is an Expression ThreeDotModifier\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef p_Callable(p):\n    '''\n    Callable : NsContentName LPARENT\n             | NsContentName SCOPEOP INDENTIFIER LPARENT\n             | Expression LPARENT\n             | STATIC SCOPEOP INDENTIFIER LPARENT\n    '''\n    if len(p) <= 3:\n        p[0] = Callable(p[1], None)\n    else:\n        p[0] = Callable(p[1], p[3])", "response": "\\ x1b [ 1mNAME \\ x1b [ 0m Callable - A function to be used in the tree tree."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef p_NsContentNameAsId(p):\n    '''\n    NsContentNameAsId : DefOrConstModifier NsContentName\n                      | DefOrConstModifier NsContentName AS INDENTIFIER\n    '''\n    if len(p) <= 3:\n        p[0] = NsContentNameAsId(p[1], p[2], None)\n    else:\n        p[0] = NsContentNameAsId(p[1], p[2], p[4])", "response": "\\ x1b [ 1mNAME \\ x1b [ 0m NsContentNameAsId - Gets the name of the object in the form of a 2 - tuple."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef p_NsContentNameAsIdList(p):\n    '''\n    NsContentNameAsIdList : NsContentNameAsId\n                          | NsContentNameAsIdList COMMA NsContentNameAsId\n    '''\n    if len(p) == 2:\n        p[0] = NsContentNameAsIdList(None, p[1])\n    else:\n        p[0] = NsContentNameAsIdList(p[1], p[3])", "response": "NsContentNameAsIdList | NsContentNameAsIdList COMMA NsContentNameAsIdList"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef p_If(p):\n    '''\n    If : IfBlock\n       | IfBlock ELSE COLON Terminator Block\n    '''\n    if len(p) == 2:\n        p[0] = If(p[1], None, None)\n    else:\n        p[0] = If(p[1], p[5], p[4])", "response": "If : IfBlock\n       | IfBlock ELSE COLON Terminator Block"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the IfBlock expression.", "response": "def p_IfBlock(p):\n    '''\n    IfBlock : IF Expression COLON Terminator Block\n            | IfBlock ELIF Expression COLON Terminator Block\n    '''\n    if isinstance(p[1], str):\n        p[0] = IfBlock(None, p[2], p[4], p[5])\n    else:\n        p[0] = IfBlock(p[1], p[3], p[5], p[6])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncasing arglist COLON Terminator Block | DEFAULT COLON Terminator Block Case", "response": "def p_Case(p):\n    '''\n    Case : CASE ArgList COLON Terminator Block\n         | DEFAULT COLON Terminator Block\n    '''\n    if p[1] == 'case':\n        p[0] = Case(p[1], p[2], p[4], p[5])\n    else:\n        p[0] = Case(p[1], None, p[3], p[4])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef p_For(p):\n    '''\n    For : FOR Expression IN Expression COLON Terminator Block\n        | FOR Expression COMMA Expression IN Expression COLON Terminator Block\n    '''\n    if len(p) <= 8:\n        p[0] = For(p[2], None, p[4], p[6], p[7])\n    else:\n        p[0] = For(p[2], p[4], p[6], p[8], p[9])", "response": "P X FOR expression IN Expression COLON Terminator Block\n "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef p_Try(p):\n    '''\n    Try : TRY COLON Terminator Block Catch\n        | TRY COLON Terminator Block Catch FINALLY COLON Terminator Block\n    '''\n    if len(p) <= 6:\n        p[0] = Try(p[3], p[4], p[5], None, None)\n    else:\n        p[0] = Try(p[3], p[4], p[5], p[8], p[9])", "response": "P = Try Section 9. 1. 3. 1. 2. 1. 2. 1. 2. 1. 2. 1. 2. 1. 2. 1. 2. 1. 2. 1. 2. 1. 2. 1. 2. 1. 2. 1. 2. 1. 2. 1. 2. 1. 2. 1. 2. 2."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef p_Catch(p):\n    '''\n    Catch : \n          | Catch CATCH LPARENT Varible COLON NsContentName RPARENT COLON Terminator Block\n    '''\n    if len(p) <= 1:\n        p[0] = Catch(None, None, None, None, None)\n    else:\n        p[0] = Catch(p[1], p[4], p[6], p[9], p[10])", "response": "Catch : \n          | Catch CATCH LPARENT Varible COLON NsContentName RPARENT COLON Terminator Block"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclasses : AbstractModifier FinalModifier CLASS INDENTIFIER ExtendsModifier ImplementsModifier COLON Terminator ClassContent", "response": "def p_Class(p):\n    '''\n    Class : AbstractModifier FinalModifier CLASS INDENTIFIER ExtendsModifier ImplementsModifier COLON Terminator ClassContent\n    '''\n    p[0] = Class(p[1], p[2], p[4], p[5], p[6], p[8], p[9])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the UseTrait command.", "response": "def p_UseTrait(p):\n    '''\n    UseTrait : UseNamespace Terminator\n             | UseNamespace COLON Terminator UseTraitContent\n    '''\n    if len(p) <= 3:\n        p[0] = UseTrait(p[1], p[2], None)\n    else:\n        p[0] = UseTrait(p[1], p[3], p[4])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the INUSETRAILER_DEF command.", "response": "def p_InUseTraitDef(p):\n    '''\n    InUseTraitDef : Varible INSTEADOF NsContentName Terminator\n                  | Varible AS AccessModifier Terminator\n                  | Varible AS AccessModifier NsContentName Terminator\n    '''\n    if p[2] == 'insteadof':\n        p[0] = InUseTraitDef(p[1], p[2], None, p[3], p[4])\n    elif len(p) <= 5:\n        p[0] = InUseTraitDef(p[1], p[2], p[3], None, p[4])\n    else:\n        p[0] = InUseTraitDef(p[1], p[2], p[3], p[4], p[5])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef p_InterfaceDefList(p):\n    '''\n    InterfaceDefList : InterfaceDef\n                     | InterfaceDefList InterfaceDef\n    '''\n    if len(p) < 3:\n        p[0] = InterfaceDefList(None, p[1])\n    else:\n        p[0] = InterfaceDefList(p[1], p[2])", "response": "InterfaceDefList : InterfaceDef\n                     | InterfaceDefList InterfaceDef"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef p_MemberFuncDecWithoutTerminator(p):\n    '''\n    MemberFuncDecWithoutTerminator : FinalModifier AccessModifier StaticModifier RefModifier INDENTIFIER LPARENT ParamList RPARENT\n    '''\n    p[0] = MemberFuncDecWithoutTerminator(p[1], p[2], p[3], p[4], p[5], p[7])", "response": "MemberFuncDecWithoutTerminator = > MemberFuncDec"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nyield a tree node.", "response": "def p_Yield(p):\n    '''\n    Yield : YIELD\n          | YIELD Expression\n          | YIELD Expression COMMA Expression\n    '''\n    if len(p) == 2:\n        p[0] = Yield(None, None)\n    elif len(p) == 3:\n        p[0] = Yield(p[2], None)\n    else:\n        p[0] = Yield(p[2], p[4])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef p_GlobalVaribleList(p):\n    '''\n    GlobalVaribleList : Varible \n                      | GlobalVaribleList COMMA Varible\n    '''\n    if len(p) > 2:\n        p[0] = GlobalVaribleList(p[1], p[3])\n    else:\n        p[0] = GlobalVaribleList(None, p[1])", "response": "P GlobalVaribleList | Varible \n                      | Varible\n    COMMA Varible\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef p_NewOrClone(p):\n    '''\n    NewOrClone : NEW NsContentName LPARENT ArgList RPARENT\n               | NEW STATIC LPARENT ArgList RPARENT\n               | NEW Varible\n               | CLONE Varible\n               | NEW STRING\n               | CLONE STRING\n    '''\n    if len(p) > 3:\n        p[0] = NewOrClone(p[1], p[2], p[4], None)\n    else:\n        p[0] = NewOrClone(p[1], None, None, p[2])", "response": "NewOrClone is a wrapper for the NewOrClone function."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pvalues(self):\n        self.compute_statistics()\n\n        lml_alts = self.alt_lmls()\n        lml_null = self.null_lml()\n\n        lrs = -2 * lml_null + 2 * asarray(lml_alts)\n\n        from scipy.stats import chi2\n        chi2 = chi2(df=1)\n\n        return chi2.sf(lrs)", "response": "Association p - value for candidate markers."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef eventFilter(self, object, event):\n\n        if event.type() == QEvent.KeyPress:\n            if event.key() in (Qt.Key_Enter, Qt.Key_Return):\n                object.search()\n            elif event.key() in (Qt.Key_Escape,):\n                object.close()\n            return True\n        else:\n            return QObject.eventFilter(self, object, event)", "response": "Reimplement the QObject. eventFilter method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __initialize_ui(self):\n\n        umbra.ui.common.set_window_default_icon(self)\n\n        for model, settings_key, combo_box in \\\n                ((\"_SearchAndReplace__search_patterns_model\", \"recent_search_patterns\", self.Search_comboBox),\n                 (\"_SearchAndReplace__replace_with_patterns_model\", \"recent_replace_with_patterns\",\n                  self.Replace_With_comboBox)):\n            self.__dict__[model] = PatternsModel()\n            patterns = foundations.common.ordered_uniqify([foundations.strings.to_string(pattern) for pattern in\n                                                           self.__container.settings.get_key(\n                                                               self.__container.settings_section,\n                                                               settings_key).toStringList()])\n            [PatternNode(parent=self.__dict__[model].root_node, name=pattern)\n             for pattern in patterns[:self.__maximum_stored_patterns]]\n            combo_box.setInsertPolicy(QComboBox.InsertAtTop)\n            combo_box.setModel(self.__dict__[model])\n\n            combo_box.completer().setCaseSensitivity(Qt.CaseSensitive)\n\n            # Signals / Slots.\n            self.__dict__[model].pattern_inserted.connect(\n                functools.partial(self.__patterns_model__pattern_inserted, settings_key, combo_box))\n\n        self.Wrap_Around_checkBox.setChecked(True)\n\n        self.installEventFilter(ValidationFilter(self))\n\n        # Signals / Slots.\n        self.Search_pushButton.clicked.connect(self.__Search_pushButton__clicked)\n        self.Replace_pushButton.clicked.connect(self.__Replace_pushButton__clicked)\n        self.Replace_All_pushButton.clicked.connect(self.__Replace_All_pushButton__clicked)\n        self.Close_pushButton.clicked.connect(self.__Close_pushButton__clicked)", "response": "Initializes the Widget ui."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __get_settings(self):\n\n        return {\"case_sensitive\": self.Case_Sensitive_checkBox.isChecked(),\n                \"whole_word\": self.Whole_Word_checkBox.isChecked(),\n                \"regular_expressions\": self.Regular_Expressions_checkBox.isChecked(),\n                \"backward_search\": self.Backward_Search_checkBox.isChecked(),\n                \"wrap_around\": self.Wrap_Around_checkBox.isChecked()}", "response": "Returns the current search and replace settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insert_pattern(pattern, model, index=0):\n\n        if not pattern:\n            return False\n\n        pattern = pattern.replace(QChar(QChar.ParagraphSeparator), QString(\"\\n\"))\n        pattern = foundations.common.get_first_item(foundations.strings.to_string(pattern).split(\"\\n\"))\n\n        model.insert_pattern(foundations.strings.to_string(pattern), index)\n\n        return True", "response": "Inserts given pattern into given Model."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches current editor Widget for search pattern.", "response": "def search(self):\n        \"\"\"\n        Searchs current editor Widget for search pattern.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        editor = self.__container.get_current_editor()\n        search_pattern = self.Search_comboBox.currentText()\n        replacement_pattern = self.Replace_With_comboBox.currentText()\n\n        if not editor or not search_pattern:\n            return False\n\n        self.insert_pattern(search_pattern, self.__search_patterns_model)\n        self.insert_pattern(replacement_pattern, self.__replace_with_patterns_model)\n\n        settings = self.__get_settings()\n\n        LOGGER.debug(\"> 'Search' on '{0}' search pattern with '{1}' settings.\".format(search_pattern, settings))\n\n        return editor.search(search_pattern, **settings)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef root_namespace(self, value):\n\n        if value is not None:\n            assert type(value) is unicode, \"'{0}' attribute: '{1}' type is not 'unicode'!\".format(\n                \"root_namespace\", value)\n        self.__root_namespace = value", "response": "Setter for **self. __root_namespace** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the categories of the orphan in the database.", "response": "def categories(self, value):\n        \"\"\"\n        Setter for **self.__categories** attribute.\n\n        :param value: Attribute value.\n        :type value: dict\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is dict, \"'{0}' attribute: '{1}' type is not 'dict'!\".format(\"categories\", value)\n            for key, element in value.iteritems():\n                assert type(key) is dict, \"'{0}' attribute: '{1}' type is not 'dict'!\".format(\"categories\", key)\n                assert type(element) is list, \"'{0}' attribute: '{1}' type is not 'list'!\".format(\n                    \"categories\", element)\n        self.__categories = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nnormalizes given action name.", "response": "def __normalize_name(self, name):\n        \"\"\"\n        Normalizes given action name.\n\n        :param name: Action name.\n        :type name: unicode\n        :return: Normalized name.\n        :rtype: bool\n        \"\"\"\n\n        if not name.startswith(self.__root_namespace):\n            name = foundations.namespace.set_namespace(self.__root_namespace,\n                                                       foundations.namespace.set_namespace(self.__default_namespace,\n                                                                                           name))\n            LOGGER.debug(\"> Normalized name: '{0}'.\".format(name))\n            return name\n        else:\n            LOGGER.debug(\"> Name '{0}' is already normalized!\".format(name))\n            return name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __get_category(self, category, name, vivify=False):\n\n        namespace = foundations.namespace.get_namespace(name, root_only=True)\n        name = foundations.namespace.remove_namespace(name, root_only=True)\n        if namespace:\n            if vivify and namespace not in category:\n                category[namespace] = {}\n            return self.__get_category(category[namespace], name, vivify)\n        else:\n            if vivify and name not in category:\n                category[name] = {}\n            return category[name]", "response": "Gets recusively requested category alternately if vivify is set to True."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, action, default=None):\n\n        try:\n            return self.__getitem__(action)\n        except KeyError as error:\n            return default", "response": "Returns given action value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_actions(self):\n\n        actions = []\n        for path, actionName, action in self:\n            actions.append(self.__namespace_splitter.join(itertools.chain(path, (actionName,))))\n        return sorted(actions)", "response": "Returns the registered actions."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns requested category. :param name: Category to retrieve. :type name: unicode :param vivify: Vivify missing parents in the chain to the requested category. :type vivify: bool :return: Category. :rtype: dict", "response": "def get_category(self, name, vivify=False):\n        \"\"\"\n        Returns requested category.\n\n        :param name: Category to retrieve.\n        :type name: unicode\n        :param vivify: Vivify missing parents in the chain to the requested category.\n        :type vivify: bool\n        :return: Category.\n        :rtype: dict\n        \"\"\"\n\n        category = self.__get_category(self.__categories, name, vivify)\n        if isinstance(category, dict):\n            LOGGER.debug(\"> Category '{0}': '{1}'.\".format(name, category))\n            return category\n        else:\n            raise umbra.exceptions.CategoryExistsError(\"{0} | '{1}' category doesn't exists!\".format\n                                                       (self.__class__.__name__, name))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding given action to given category.", "response": "def add_to_category(self, category, name, action):\n        \"\"\"\n        Adds given action to given category.\n\n        :param category: Category to store the action.\n        :type category: unicode\n        :param name: Action name.\n        :type name: unicode\n        :param action: Action object.\n        :type action: QAction\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        category = self.get_category(category, vivify=True)\n        if not isinstance(category, dict):\n            return False\n\n        category[name] = action\n        LOGGER.debug(\"> Added '{0}' action to '{1}' category!\".format(category, name))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_from_category(self, category, name):\n\n        category = self.get_category(category)\n        if not isinstance(category, dict):\n            return False\n\n        del (category[name])\n        LOGGER.debug(\"> Removed '{0}' action from '{1}' category!\".format(category, name))\n        return True", "response": "Removes given action from given category."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register_action(self, name, **kwargs):\n\n        settings = foundations.data_structures.Structure(**{\"parent\": None,\n                                                            \"text\": None,\n                                                            \"icon\": None,\n                                                            \"icon_text\": None,\n                                                            \"checkable\": None,\n                                                            \"checked\": None,\n                                                            \"status_tip\": None,\n                                                            \"whats_this\": None,\n                                                            \"tool_tip\": None,\n                                                            \"shortcut\": None,\n                                                            \"shortcut_context\": None,\n                                                            \"slot\": None})\n        settings.update(kwargs)\n\n        name = self.__normalize_name(name)\n        category = foundations.namespace.get_namespace(name)\n        name = foundations.namespace.remove_namespace(name)\n\n        action = QAction(name, settings.parent or self)\n        self.add_to_category(category, name, action)\n\n        settings.text and action.setText(settings.text)\n        settings.icon and action.setIcon(settings.icon)\n        settings.icon_text and action.setIconText(settings.icon_text)\n        settings.checkable and action.setCheckable(settings.checkable)\n        settings.checked and action.set_checked(settings.checked)\n        settings.status_tip and action.setStatusTip(settings.status_tip)\n        settings.whats_this and action.setWhatsThis(settings.whats_this)\n        settings.tool_tip and action.setToolTip(settings.tool_tip)\n        settings.shortcut and action.setShortcut(QKeySequence(settings.shortcut))\n        settings.shortcut_context and action.setShortcutContext(settings.shortcut_context)\n        if settings.slot:\n            self.__actions_signals_slots[action] = settings.slot\n            action.triggered.connect(settings.slot)\n        return action", "response": "Registers given action with given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unregister_action(self, name):\n\n        name = self.__normalize_name(name)\n        action = self.get_action(name)\n        if not action:\n            return False\n\n        action.triggered.disconnect(self.__actions_signals_slots.pop(action))\n\n        category = foundations.namespace.get_namespace(name)\n        name = foundations.namespace.remove_namespace(name)\n        self.remove_from_category(category, name)\n        return True", "response": "Unregisters given action name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_shortcut_in_use(self, shortcut):\n\n        for path, actionName, action in foundations.walkers.dictionaries_walker(self.__categories):\n            if action.shortcut() == QKeySequence(shortcut):\n                return True\n        return False", "response": "Returns if given action shortcut is in use."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn given action shortcut.", "response": "def get_shortcut(self, name):\n        \"\"\"\n        Returns given action shortcut.\n\n        :param name: Action to retrieve the shortcut.\n        :type name: unicode\n        :return: Action shortcut.\n        :rtype: unicode\n        \"\"\"\n\n        name = self.__normalize_name(name)\n        action = self.get_action(name)\n        if not action:\n            return \"\"\n\n        return action.shortcut().toString()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset given action shortcut.", "response": "def set_shortcut(self, name, shortcut):\n        \"\"\"\n        Sets given action shortcut.\n\n        :param name: Action to set the shortcut.\n        :type name: unicode\n        :param shortcut: Shortcut to set.\n        :type shortcut: unicode\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        name = self.__normalize_name(name)\n        action = self.get_action(name)\n        if not action:\n            return\n\n        action.setShortcut(QKeySequence(shortcut))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a workspace object from a directory name.", "response": "def workspace_from_dir(directory, recurse=True):\n    \"\"\"\n    Construct a workspace object from a directory name.  If recurse=True, this\n    function will search down the directory tree and return the first workspace\n    it finds.  If recurse=False, an exception will be raised if the given\n    directory is not a workspace.  Workspace identification requires a file\n    called 'workspace.pkl' to be present in each workspace directory, which can\n    unfortunately be a little fragile.\n    \"\"\"\n    directory = os.path.abspath(directory)\n    pickle_path = os.path.join(directory, 'workspace.pkl')\n\n    # Make sure the given directory contains a 'workspace' file.  This file is\n    # needed to instantiate the right kind of workspace.\n\n    if not os.path.exists(pickle_path):\n        if recurse:\n            parent_dir = os.path.dirname(directory)\n\n            # Keep looking for a workspace as long as we haven't hit the root\n            # of the file system.  If an exception is raised, that means no\n            # workspace was found.  Catch and re-raise the exception so that\n            # the name of the directory reported in the exception is meaningful\n            # to the user.\n\n            try:\n                return workspace_from_dir(parent_dir, parent_dir != '/')\n            except WorkspaceNotFound:\n                raise WorkspaceNotFound(directory)\n        else:\n            raise WorkspaceNotFound(directory)\n\n    # Load the 'workspace' file and create a workspace.\n\n    with open(pickle_path) as file:\n        workspace_class = pickle.load(file)\n\n    return workspace_class.from_directory(directory)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef root_from_dir(directory, recurse=True):\n\n    directory = os.path.abspath(directory)\n    pickle_path = os.path.join(directory, 'workspace.pkl')\n\n    # Make sure the given directory contains a 'workspace' file.  This file is\n    # needed to instantiate the right kind of workspace.\n\n    if not os.path.exists(pickle_path):\n        if recurse:\n            parent_dir = os.path.dirname(directory)\n\n            # Keep looking for a workspace as long as we haven't hit the root\n            # of the file system.  If an exception is raised, that means no\n            # workspace was found.  Catch and re-raise the exception so that\n            # the name of the directory reported in the exception is meaningful\n            # to the user.\n\n            try:\n                return root_from_dir(parent_dir, parent_dir != '/')\n            except WorkspaceNotFound:\n                raise WorkspaceNotFound(directory)\n        else:\n            raise WorkspaceNotFound(directory)\n\n    # Return the directory in which the pkl file was found.\n\n    return pickle_path[:-len('workspace.pkl')]", "response": "This function returns the root directory of a workspace object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_loops(directory, loops_path=None):\n\n    if loops_path is None:\n        workspace = workspace_from_dir(directory)\n        loops_path = workspace.loops_path\n\n    from klab.rosetta.input_files import LoopsFile\n    loops_parser = LoopsFile.from_filepath(loops_path)\n\n    # We have to account for some weird indexing behavior in the loops file\n    # parser that I don't really understand.  It seems to shrink the loop by\n    # one residue on each side.  At first I thought it might be trying to\n    # convert the indices to python indexing, but on second thought I have no\n    # idea what it's trying to do.\n\n    return [(x-1, y+1) for x, y in loops_parser.get_distinct_segments()]", "response": "Load the loops from a directory and return a list of tuples indicating the start and end points of the loops that were sampled in the given directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_resfile(directory, resfile_path=None):\n\n    if resfile_path is None:\n        workspace = workspace_from_dir(directory)\n        resfile_path = workspace.resfile_path\n\n    from klab.rosetta.input_files import Resfile\n    return Resfile(resfile_path)", "response": "Load a Resfile from a directory."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the boundaries for the largest loop segment.", "response": "def largest_loop(self):\n        \"\"\"\n        Return the boundaries for the largest loop segment.\n        \n        This is just meant to be a reasonable default for various selectors and \n        filters to work with, in the case that more than one loop is being \n        modeled.  If you want to be more precise, you'll have to override the \n        selectors and filters in question.\n        \"\"\"\n        from collections import namedtuple\n        Loop = namedtuple('Loop', 'start end')\n        largest_segment = sorted(\n                self.loop_segments,\n                key=lambda x: abs(x[1] - x[0]),\n        )[-1]\n        return Loop(*largest_segment)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind the path to a file in the input directories that contains the given name.", "response": "def find_path(self, basename, install_dir=None):\n        \"\"\"\n        Look in a few places for a file with the given name.  If a custom\n        version of the file is found in the directory being managed by\n        this workspace, return it.  Otherwise look in the custom and default \n        input directories in the root directory, and then finally in the root \n        directory itself.\n\n        This function makes it easy to provide custom parameters to any stage\n        to the design pipeline.  Just place the file with the custom parameters\n        in a directory associated with that stage.\n        \"\"\"\n\n        # Look for the file we were asked for.\n        for dir in self.find_path_dirs:\n            path = os.path.join(dir, basename)\n            if os.path.exists(path):\n                return path\n\n        # If we didn't find the file, return the path to where we'd like it to \n        # be installed.\n        return os.path.join(install_dir or self.preferred_install_dir, basename)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchanging the current working directory and update all the paths in the base directory.", "response": "def cd(self, *subpaths):\n        \"\"\"\n        Change the current working directory and update all the paths in the\n        workspace.  This is useful for commands that have to be run from a\n        certain directory.\n        \"\"\"\n        target = os.path.join(*subpaths)\n        os.chdir(target)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses an HTTP header from a string and return an HttpHeader object.", "response": "def parse_http_header(header_line):\n    \"\"\"Parse an HTTP header from a string, and return an ``HttpHeader``.\n\n    ``header_line`` should only contain one line.\n    ``BadHttpHeaderError`` is raised if the string is an invalid header line.\n    \"\"\"\n\n    header_line = header_line.decode().strip()\n    col_idx = header_line.find(':')\n\n    if col_idx < 1:\n        raise BadHttpHeaderError('Bad header: {}'.format(repr(header_line)))\n\n    key = header_line[0:col_idx].strip()\n    value = header_line[(col_idx+1):].strip()\n    return HttpHeader(key=key, value=value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread data from reader and parse multipart form - data fields.", "response": "def parse_multipart_formdata(reader, boundary, cb):\n    \"\"\"Read data from ``reader`` and parse multipart/form-data fields.\n\n    ``boundary`` is the multipart/form-data boundary.\n    ``cb`` is a callable that will be called as ``cb(headers, reader)`` to\n    handle the parsed field.\n    \"\"\"\n\n    breader = BoundaryReader(reader, boundary)\n    # The BoundaryReader expects a new line before the boundary string,\n    # We make sure the new line exists\n    breader.put(b'\\r\\n')\n    # Clean up garbage before the first boundary\n    _dummy_data = yield from breader.read()\n    logger('parse_multipart_formdata').debug('_dummy_data = %r', _dummy_data)\n    del _dummy_data\n\n    breader = BoundaryReader(reader, boundary)\n    line = yield from breader.readline()\n    while line:\n        headers = []\n        while line.strip():\n            header = parse_http_header(line)\n            headers.append(header)\n            line = yield from breader.readline()\n\n        yield from cb(headers, breader)\n\n        yield from breader.read()\n        breader = BoundaryReader(reader, boundary)\n        line = yield from breader.readline()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconstruct headers in string form and return a list containing each line of header strings.", "response": "def write_headers(self):\n        \"\"\"Construct headers in string form, and return a list containing each\n        line of header strings.\n        \"\"\"\n        hlist = []\n        for h in self.headers:\n            hlist.append(\"{}: {}\".format(h.key, h.value))\n        return hlist"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef respond(self, code):\n\n        # TODO: respect encodings etc. in the request\n        resp = HttpResponse(code, self.connection)\n        resp.request = self\n        if hasattr(self, 'version'):\n            resp.version = self.version\n        return resp", "response": "Starts a response.\n\n        ``code`` is an integer standing for standard HTTP status code.\n\n        This method will automatically adjust the response to adapt to request\n        parameters, such as \"Accept-Encoding\" and \"TE\"."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading a request from the HTTP connection conn.", "response": "def parse(cls, conn):\n        \"\"\"Read a request from the HTTP connection ``conn``.\n\n        May raise ``BadHttpRequestError``.\n        \"\"\"\n\n        req = cls(conn)\n        req_line = yield from conn.reader.readline()\n        logger('HttpRequest').debug('req_line = %r', req_line)\n        req._parse_req_line(req_line)\n\n        header_line = yield from conn.reader.readline()\n        while len(header_line) > 0 and header_line != b'\\r\\n':\n            try:\n                req._parse_header(header_line)\n            except BadHttpHeaderError as e:\n                # Tolerating 'minor' mistakes\n                logger('HttpRequest').debug(traceback.format_exc())\n            header_line = yield from conn.reader.readline()\n        return req"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconstructs the response header.", "response": "def write(self):\n        \"\"\"Construct the response header.\n\n        The return value is a list containing the whole response header, with\n        each line as a list element.\n        \"\"\"\n\n        slist = []\n        slist.append('{}/{}.{} {} {}'.format(\n                        self.protocol,\n                        self.version[0],\n                        self.version[1],\n                        self.code,\n                        status_messages[self.code]))\n        slist.extend(self.write_headers())\n        slist.append('\\r\\n')\n        return slist"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send(self):\n\n        if hasattr(self, 'request'):\n            self.request.responded = True\n        self.connection.writer.write(str(self).encode())\n        yield from self.connection.writer.drain()", "response": "Send the response header including the status line and all the\n        HTTP headers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend the response body.", "response": "def send_body(self, data):\n        \"\"\"Send the response body.\n\n        ``data`` should be a bytes-like object or a string.\n        \"\"\"\n\n        if type(data) is str:\n            data = data.encode()\n        self.connection.writer.write(data)\n        yield from self.connection.writer.drain()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lineOffsetWithMinimumDistanceToPoint(point, line_start, line_end, perpendicular=False):\n    p = point\n    p1 = line_start\n    p2 = line_end\n    l = distance(p1, p2)\n    u = ((p[0] - p1[0]) * (p2[0] - p1[0])) + ((p[1] - p1[1]) * (p2[1] - p1[1]))\n    if l == 0 or u < 0.0 or u > l * l:\n        if perpendicular:\n            return INVALID_DISTANCE\n        if u < 0:\n            return 0\n        return l\n    return u / l", "response": "Return the offset from line line_start line_end where the distance to point is minimal"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the offset and the distancefrom the polygon start where the distance to point is minimal", "response": "def polygonOffsetAndDistanceToPoint(point, polygon, perpendicular=False):\n    \"\"\"Return the offset and the distancefrom the polygon start where the distance to point is minimal\"\"\"\n    p = point\n    s = polygon\n    seen = 0\n    minDist = 1e400\n    minOffset = INVALID_DISTANCE\n    for i in range(len(s) - 1):\n        pos = lineOffsetWithMinimumDistanceToPoint(\n            p, s[i], s[i + 1], perpendicular)\n        dist = minDist if pos == INVALID_DISTANCE else distance(\n            p, positionAtOffset(s[i], s[i + 1], pos))\n        if dist < minDist:\n            minDist = dist\n            minOffset = pos + seen\n        if perpendicular and i != 0 and pos == INVALID_DISTANCE:\n            # even if perpendicular is set we still need to check the distance\n            # to the inner points\n            cornerDist = distance(p, s[i])\n            if cornerDist < minDist:\n                pos1 = lineOffsetWithMinimumDistanceToPoint(\n                    p, s[i - 1], s[i], False)\n                pos2 = lineOffsetWithMinimumDistanceToPoint(\n                    p, s[i], s[i + 1], False)\n                if pos1 == distance(s[i - 1], s[i]) and pos2 == 0.:\n                    minOffset = seen\n                    minDist = cornerDist\n        seen += distance(s[i], s[i + 1])\n    return minOffset, minDist"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the minimum distance between point and the line line_start line_end.", "response": "def distancePointToLine(point, line_start, line_end, perpendicular=False):\n    \"\"\"Return the minimum distance between point and the line (line_start, line_end)\"\"\"\n    p1 = line_start\n    p2 = line_end\n    offset = lineOffsetWithMinimumDistanceToPoint(\n        point, line_start, line_end, perpendicular)\n    if offset == INVALID_DISTANCE:\n        return INVALID_DISTANCE\n    if offset == 0:\n        return distance(point, p1)\n    u = offset / distance(line_start, line_end)\n    intersection = (p1[0] + u * (p2[0] - p1[0]), p1[1] + u * (p2[1] - p1[1]))\n    return distance(point, intersection)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef distancePointToPolygon(point, polygon, perpendicular=False):\n    p = point\n    s = polygon\n    minDist = None\n    for i in range(0, len(s) - 1):\n        dist = distancePointToLine(p, s[i], s[i + 1], perpendicular)\n        if dist == INVALID_DISTANCE and perpendicular and i != 0:\n            # distance to inner corner\n            dist = distance(point, s[i])\n        if dist != INVALID_DISTANCE:\n            if minDist is None or dist < minDist:\n                minDist = dist\n    if minDist is not None:\n        return minDist\n    else:\n        return INVALID_DISTANCE", "response": "Return the minimum distance between point and polygon"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a callback and errback to the callback chain.", "response": "def add_callbacks(self, callback, errback=None, callback_args=None,\n                      callback_kwargs=None, errback_args=None,\n                      errback_kwargs=None):\n        \"\"\"Add a callback and errback to the callback chain.\n\n        If the previous callback succeeds the return value is passed as the\n        first argument to the next callback in the chain.\n\n        If the previous callback raises an exception the exception is passed as\n        the first argument to the next errback in the chain.\n        \n        \"\"\"\n        self._callbacks.appendleft((callback, errback, callback_args,\n                               callback_kwargs, errback_args,\n                               errback_kwargs))\n\n        if self.called:\n            self._do_callbacks()\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a callback without an associated errback.", "response": "def add_callback(self, callback, *callback_args, **callback_kwargs):\n        \"\"\"Add a callback without an associated errback.\"\"\"\n        return self.add_callbacks(callback, callback_args=callback_args,\n                           callback_kwargs=callback_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_errback(self, errback, *errback_args, **errback_kwargs):\n        return self.add_callbacks(None, errback=errback, errback_args=errback_args,\n                           errback_kwargs=errback_kwargs)", "response": "Add a errback to the log."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef errback(self, result):\n\n        assert(isinstance(result, BaseException))\n        self._start_callbacks(result, True)", "response": "Begin the callback chain with the first errback."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the last result of the callback chain or raise the last exception thrown and not caught by an errback.", "response": "def result(self, timeout=None):\n        \"\"\"Return the last result of the callback chain or raise the last\n        exception thrown and not caught by an errback.\n\n        This will block until the result is available.\n        \n        If a timeout is given and the call times out raise a TimeoutError\n\n        If SIGINT is caught while waiting raises CancelledError.\n\n        If cancelled while waiting raises CancelledError\n\n        This acts much like a pythonfutures.Future.result() call\n        except the entire callback processing chain is performed first.\n\n        \"\"\"\n\n        self._do_wait(timeout)\n\n        if self._exception:\n            self._last_exception.exception = None\n            self._last_exception.tb_info = None\n            raise self._result\n        else:\n            return self._result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _do_wait(self, timeout):\n\n        if self._cancelled:\n            raise CancelledError()\n\n        if not self._done:\n            self._wait = True\n            \n            self._sigint = pyev.Signal(signal.SIGINT, self.loop, lambda watcher, events: self._cancel(), None)\n            self._sigint.start()\n\n            if timeout and timeout > 0.0:\n                self._timer = pyev.Timer(timeout, 0.0, self.loop,\n                                         self._clear_wait, None)\n                self._timer.start()\n\n            while self._wait and not self._done and not self._cancelled:\n                self.loop.start(pyev.EVRUN_ONCE)\n\n        if self._cancelled:\n            raise CancelledError()\n        elif not self._done:\n            raise TimeoutError()", "response": "Wait for the deferred to be completed for a period of time."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _start_callbacks(self, result, exception):\n        if self._cancelled:\n            raise CancelledError()\n        if self.called:\n            raise AlreadyCalledError()\n\n        self._result = result\n        self._exception = exception\n        if self._exception:\n            self._tb_info = ''.join(traceback.format_tb(sys.exc_info()[2])) \n        self.called = True\n        self._do_callbacks()", "response": "Perform the callback chain going back and forth between the callback\n        and errback as needed."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clean(self, value):\n        if isinstance(value, FileStorage):\n            return self.storage.save(value)\n        return value", "response": "Takes a Werkzeug FileStorage returns the relative path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the frequencies to be used with FFT analysis", "response": "def get_kx(N,dx):\r\n    \"\"\"\r\n    GET_KX\r\n    :summary: Returns the frequencies to be used with FFT analysis\r\n    \r\n    :parameter N: number of samples in data\r\n    :parameter dx: sampling step\r\n    \r\n    :return: Returns\r\n      * k: frequency\r\n      * L: length\r\n      * imx: index of maximum frequency (for separating positive and negative frequencies)\r\n    \r\n    :author: Renaud DUSSURGET (RD) - LER/PAC, Ifremer\r\n    :change: Created by RD, July 2012\r\n    \"\"\"\r\n    \r\n    # to work with dimensional axes\r\n    L = N*dx\r\n    \r\n    #Odd or even\r\n    odd = N&1 and True or False\r\n    \r\n    #Get frequency & wavenumber\r\n    k=ft.fftfreq(N,d=dx)\r\n#    k=f*N\r\n    \r\n    imx = (N-1)/2 if odd else N/2 #Maximum frequency\r\n    \r\n    #Convert into frequencies\r\n#    k/=L\r\n    \r\n    return k, L, imx"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_spec(dx,Vin,verbose=False,gain=1.0,integration=True):\r\n    V=Vin.copy()\r\n    N=V.size\r\n\r\n    # part 1 - estimate of the wavenumbers\r\n    ######################################\r\n    [k,L,imx] = get_kx(N,dx)\r\n#    print \"dx = %s\" %(dx)\r\n#    print \"kx = \",k[0:3]\r\n#    print \"shape\",k.shape\r\n\r\n    # part 2 - estimate of the spectrum\r\n    # fast fourier transform\r\n    ##########################\r\n    fft=ft.fft(V)/(gain)\r\n    if verbose : print 'Check parseval theorem 1: SUM|Y(f)|\u00b2={0}, SUM|y(t)|\u00b2={1}'.format(((np.abs(fft)**2)/N).sum(),(V**2).sum()) \r\n\r\n#        Compute magnitude\r\n#        CF.Wilks, 2006. Statistical Methods in the Atmopsheric Sciences. 2nd Edition. International Geophysics Series vol.96. Elsevier.\r\n#        => Ck = [Ak^2 + Bk^2]^(1/2), where e^(iwt) = cos(wt) + i.sin(wt)\r\n    a = fft.real\r\n    b = fft.imag\r\n    c = np.sqrt(a**2.0 + b**2.0) #This is the magnitude\r\n    d = np.arctan(b/a)\r\n    \r\n    if verbose : print 'Check parseval theorem 2: SUM|Y(f)|\u00b2={0}, SUM|y(t)|\u00b2={1}'.format(((c**2)/N).sum(),(V**2).sum()) \r\n    \r\n    #Normalise data\r\n    c /= np.float32(N)\r\n    #~ d /= np.float32(N)\r\n    \r\n    if verbose : print 'Check parseval theorem 3: SUM|Y(f)|\u00b2={0}, SUM|y(t)|\u00b2={1}'.format(((c**2)*N).sum(),(V**2).sum()) \r\n    \r\n#    mean=fft.real[0]/N #Get average\r\n    \r\n    #Remove negative frequencies\r\n#    phase=np.angle(2*fft[1:imx]) #Get phase (not used yet)\r\n    c = 2*c[1:imx-1] #Multiply by 2 (because of negative frequencies removal) - loses a bit of energy\r\n    d = 2*d[1:imx-1]\r\n    \r\n    if verbose : print 'Check parseval theorem 4: SUM|Y(f)|\u00b2={0}, SUM|y(t)|\u00b2={1}'.format(((c**2)*(N/2.0)).sum(),((V-V.mean())**2).sum()) \r\n    \r\n#    if not(N&1 and True or False) : print (np.sum(fft[1:N/2+1])-np.sum(fft[N/2+1:])), fft[N/2] #This is equal to fft[n/2] \r\n#    cbis=np.absolute(2*fft[0:imx-1]) #Slightly differing from previous one    \r\n#    cbis /= np.float32(N)\r\n   \r\n    # integration of the spectrum\r\n    # shift to have values centered on the intervals\r\n    dk = k[1] - k[0]\r\n    dk_half = dk/2  # half of the interval\r\n        \r\n    k = k[1:imx-1]  \r\n    k_= k[:-1] + dk_half  #Shift wavelengths by half the unit\r\n    \r\n#    cesd = c**2 *(N/2) #Energy (ESD)\r\n    csquared = c ** 2 #Energy (ESD)\r\n    \r\n    if verbose : print 'Check parseval theorem 5: SUM|Y(f)|\u00b2={0}, SUM|y(t)|\u00b2={1}'.format((csquared*(N/2)).sum(),((V-V.mean())**2).sum())\r\n    \r\n    #Spectral integration\r\n    if integration :\r\n        esd = k_*0.0\r\n        psd = k_*0.0\r\n        for i in np.arange(len(k_)):\r\n            esd[i] = np.sum((csquared * (N/2.0))[(k > (k_[i]-dk)) & (k < (k_[i]+dk))]) / 2.0\r\n            psd[i] = np.sum(csquared[(k > (k_[i]-dk)) & (k < (k_[i]+dk))]) / (2.0**2) #This is variance units integration\r\n        fq=k_\r\n    else :\r\n        esd = csquared\r\n        psd = esd.copy()  /2.\r\n        fq=k.copy()\r\n        \r\n    psd = psd / dk\r\n#    psd = psd/ (N**2.0) / dk    # Normalisation (Danioux 2011) \r\n\r\n    if verbose : print 'Check parseval theorem 6: SUM|Y(f)|\u00b2={0}, SUM|y(t)|\u00b2={1}'.format(esd.sum(),((V-V.mean())**2).sum())\r\n\r\n    #Get frequencies and period  \r\n    p=1/fq\r\n    \r\n    return {'psd':psd,'esd':esd,'fq':fq,'p':p,'gain':gain, 'phase':d}", "response": "Returns the spectrum of a regularly sampled dataset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef spectral_analysis(dx,Ain,tapering=None,overlap=None,wsize=None,alpha=3.0,detrend=False,normalise=False,integration=True,average=True,ARspec=None):\r\n    \r\n    A=Ain.copy()\r\n\r\n    #Check dimensions\r\n    sh = A.shape\r\n    ndims = len(sh)\r\n    N = sh[0] #Time series are found along the last dimension\r\n    \r\n    #If vector, add one dimension\r\n    if ndims == 1 :\r\n        A = A.reshape((N,1))\r\n        sh = A.shape\r\n        ndims = len(sh)\r\n    \r\n    nr = sh[1] #Number of repeats  \r\n    nt = nr\r\n    \r\n#    gain=1.0 #Scaling gain... (used for tapering issues)\r\n    \r\n#    #Get the overall energy\r\n#    spec=get_spec(dx, A[:,0])\r\n#    F=spec['fq']   \r\n#    Eref = ((A[:,0]-A[:,0].mean())**2).sum() #Get the reference energy level\r\n#    ESDref=spec['esd']\r\n#    SFactor=Eref/spec['esd'].sum()\r\n#    ESDref*=SFactor\r\n#    PSDref=spec['psd']*SFactor\r\n#    print 'Check parseval theorem : SUM|Y(f)|\u00b2={0}, SUM|y(t)|\u00b2={1}'.format(spec['esd'].sum(),((A[:,0]-A[:,0].mean())**2).sum())\r\n    \r\n    #Apply tapering if asked\r\n    ########################\r\n    if tapering is not None:\r\n        \r\n        #Set tapering defaults\r\n        overlap=0 if overlap is None else overlap\r\n        wsize=N if wsize is None else wsize\r\n\r\n        #Get time splitting (tapering) parameters\r\n        #########################################\r\n        a = np.float32(wsize)\r\n        b = np.float32(overlap) \r\n        c = np.float32(N) \r\n        nn=np.floor((c - (a * b))/(a - (a * b))) #This is the number of segments\r\n        print 'Number of windows :{0}\\nTotal windowed points : {1} ({2} missing)\\nTotal points : {3}'.format(nn,nn*wsize,N - nn*wsize*overlap,N)\r\n        \r\n        ix = np.arange(nn) * ((1.0 - b) * a) #These are the starting points of each segments\r\n\r\n        #Moving window\r\n        ##############\r\n        dum = np.zeros((wsize, nn, nr),dtype=np.float64)\r\n        for j in np.arange(nr):\r\n            for i in np.arange(nn): #looping through time to get splitted time series \r\n                dum[:,i,j] = detrend_fun(np.arange(wsize),A[ix[i] : ix[i] + wsize,j]) if detrend else A[ix[i] : ix[i] + wsize,j]\r\n        \r\n        #Set up tapering window\r\n        #######################\r\n        beta=np.pi*alpha\r\n        hamm = np.hamming(wsize)\r\n        hann = np.hanning(wsize)\r\n        kbess = np.kaiser(wsize,beta)\r\n        blackman = np.blackman(wsize)\r\n        notaper = np.ones(wsize) #overpass tapering option\r\n        gain=1.0\r\n        \r\n        \r\n        if isinstance(tapering,bool) : which='hamm'\r\n        elif isinstance(tapering,str) :\r\n            if tapering.upper() == 'HAMMING' :\r\n                which='hamm'\r\n                gain=np.sum(hamm)/wsize #0.530416666667\r\n            elif tapering.upper() == 'HANNING' :\r\n                which='hann'\r\n                gain=np.sum(hann)/wsize #0.489583333333\r\n            elif tapering.upper() == 'KAISER' :\r\n                which='kbess'\r\n                gain=np.sum(kbess)/wsize #0.394170357504\r\n            elif tapering.upper() == 'NONE' :\r\n                which='notaper'\r\n                gain=1.0\r\n            elif tapering.upper() == 'BLACKMAN' :\r\n                which='blackman'\r\n                gain=np.sum(blackman)/wsize\r\n            else : raise Exception('Unknown taper {0}'.format(tapering))\r\n        elif isinstance(tapering,np.ndarray) :\r\n            which='tapering'\r\n            gain=np.sum(tapering)/wsize\r\n        else :\r\n            raise Exception('Bad value for tapering keyword')\r\n        exec('window='+which)\r\n        window = np.repeat(window,nn*nr).reshape((wsize,nn,nr))\r\n    \r\n        #Apply tapering on segmented data\r\n        A=dum.copy()*window\r\n        A=A.reshape(wsize,nr*nn) #Reshapa matrix\r\n        nr=nn*nr\r\n    else :\r\n        if detrend :\r\n            for i in np.arange(nr): A[:,i] = detrend_fun(np.arange(N),A[:,i]) if detrend else A[:,i]\r\n        gain=1.0\r\n    \r\n    #Run transform\r\n    ###############\r\n    for i in np.arange(nr):\r\n        if ARspec is not None : spec=yule_walker_regression(dx, A[:,i], ARspec)\r\n        else : spec=get_spec(dx, A[:,i],integration=integration,gain=gain)\r\n        if i == 0:\r\n            esd = spec['esd']\r\n            psd = spec['psd']\r\n            fq = spec['fq']\r\n            phase = spec['phase']\r\n            if ARspec: model =spec['psd'].model\r\n        else : \r\n            esd = np.append(esd,spec['esd'])\r\n            psd = np.append(psd,spec['psd'])\r\n            phase = spec['phase']\r\n            if ARspec: model =np.append(model,spec['psd'].model)\r\n    \r\n#    factor=((A[:,0]-A[:,0].mean())**2).sum()/spec['esd'].sum()\r\n    #Average spectrum\r\n    #################\r\n    nf=len(fq)\r\n    p=1./fq\r\n    esd=esd.reshape(nr,nf)\r\n    psd=psd.reshape(nr,nf)\r\n    \r\n    if average :\r\n        esd=(np.sum(esd,axis=0)/nr)#/gain\r\n        psd=(np.sum(psd,axis=0)/nr)#/gain\r\n    \r\n    psd = psd * (gain**0.5)\r\n#    print gain, np.sqrt(gain), gain **2, gain*0.5, gain/2.\r\n#    esd=(np.sum(esd,axis=0))#/gain\r\n#    psd=(np.sum(psd,axis=0))#/gain\r\n\r\n    if ARspec:\r\n        mparam,msig=zip(*tuple([ (el['parameters'],el['sig']) for el in model]))\r\n        deg=ARspec\r\n        mparam=np.concatenate(mparam).reshape((len(model),deg))\r\n        msig=np.array(msig)\r\n        \r\n        if average :\r\n            mparam=mparam.mean(axis=0)\r\n            msig=np.nansum(msig)/msig.size\r\n            \r\n        mstr={'parameters':mparam,'sig':msig,'n':N,'deg':ARspec}\r\n        setattr(esd,'model',mstr)\r\n        setattr(psd,'model',mstr)\r\n        \r\n        \r\n    #Normalise by energy content    \r\n    Scaling_Factor=len(fq)/esd.sum()\r\n    if normalise :\r\n        esd*=Scaling_Factor\r\n        psd*=Scaling_Factor\r\n    \r\n    if tapering is not None : return {'params':{'tapering':tapering is not None,'which':which,'wsize':int(wsize),'nwind':int(nn),'overlap':int(100.*overlap),'gain':gain},'psd':psd,'esd':esd,'fq':fq,'p':p,'phase':phase}\r\n    else : return {'params':{'tapering':tapering is not None},'psd':psd,'esd':esd,'fq':fq,'p':p,'phase':phase}", "response": "This function performs a spatial spectral analysis on a time series of SLA profiles."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_segment(sla,N,last=True,mid=None,first=None,remove_edges=True,truncate_if_continents=True):\r\n    '''\r\n    Intelligent segmentation of data.\r\n    \r\n    :keyword remove_edges: discard data at track edges.\r\n    :keyword truncate_if_continents: Force truncating data if a continent is found within a segment of data.\r\n    \r\n    :keyword last: Get segments of data sticked to the last point in track\r\n    :keyword first: Get segments of data sticked to the first point in track\r\n    :keyword mid: Get segments of data sticked to the middle point in track\r\n\r\n    '''\r\n    #Set defaults\r\n    if first is not None :\r\n        last=None\r\n        mid=None\r\n    elif mid is not None :\r\n        last=None\r\n        first=None\r\n    \r\n    dumsla=sla.copy()\r\n    nx=sla.shape[1]\r\n    nt=sla.shape[0]\r\n    \r\n    #Save input mask\r\n    dumsla.data[dumsla.mask]=dumsla.fill_value\r\n    \r\n    if len(dumsla.mask.shape) > 0:\r\n        mask=np.ma.array(dumsla.mask.copy(),mask=np.zeros(sla.shape,dtype=bool))\r\n    else:\r\n        mask=np.array([dumsla.mask]*sla.size).reshape(sla.shape)\r\n        mask=np.ma.array(mask,mask=np.zeros(sla.shape,dtype=bool))\r\n        dumsla.mask=mask#np.array([dumsla.mask]*sla.size).reshape(sla.shape)\r\n    \r\n    #~ dumsla.mask[:]=False\r\n    \r\n    #Get edges\r\n    if remove_edges : xid=np.ma.array(np.repeat(np.arange(nx),nt).reshape(nx,nt).transpose(),mask=mask.data)\r\n    else : xid=np.ma.array(np.repeat(np.arange(nx),nt).reshape(nx,nt).transpose(),mask=np.zeros(sla.shape,dtype=bool))\r\n    left=xid.min(axis=1)\r\n    right=xid.max(axis=1)\r\n    \r\n    #Shift towards end\r\n    if last :\r\n        st=(right-N).astype(int) +1\r\n        en=(right).astype(int) + 1\r\n    elif mid :\r\n        midpt=nx/2\r\n        rlag=right-midpt\r\n        llag=midpt-left\r\n        odd = np.int(N)&1 and True or False\r\n        if not odd : nr=nl=np.int(N)/2\r\n        else :\r\n            nr=np.int(N)/2 + 1\r\n            nl=np.int(N)/2\r\n#         for i,jk in enumerate(zip(*(llag,rlag))):\r\n#             j,k=jk\r\n#             st=0\r\n        st=np.repeat(midpt-nl,nt)\r\n        en=np.repeat(midpt+nr,nt)\r\n    elif first :\r\n        st=(left).astype(int)\r\n        en=(left+N).astype(int)\r\n    \r\n    if not remove_edges :\r\n        st[st < 0] = 0\r\n        en[en > nx] = nx\r\n    \r\n    for i in np.arange(nt) :\r\n        dumsla.mask[i,:st[i]]=True\r\n        dumsla.mask[i,en[i]:]=True\r\n        mask.mask[i,:st[i]]=True\r\n        mask.mask[i,en[i]:]=True\r\n    \r\n    #Update nt\r\n    cycempty=dumsla.mask.sum(axis=1) == N\r\n    ind=np.arange(nt)[~cycempty]\r\n    nt=(~cycempty).sum()\r\n    \r\n    #Reform stuff\r\n    dumsla=dumsla.compressed().reshape(nt,N)\r\n    mask=mask.compressed().reshape(nt,N)\r\n    \r\n    if truncate_if_continents :\r\n        empty=mask.sum(axis=0) == nt\r\n        if empty.sum() > 0 :\r\n            dumsla=dumsla[:,~empty]\r\n            mask=mask[:,~empty]\r\n            print '[WARNING] Points over land mass - removed {} pts'.format(empty.sum())\r\n    \r\n    return np.ma.array(dumsla,mask=mask), ind", "response": "Get the next N segments of a segment of data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef yule_walker(acf, orden):\r\n    \r\n    if len(acf) + 1 <= orden : raise Exception('ACF too short for the solicited order!')\r\n    \r\n    bb = acf[1:orden+1]\r\n    aa = np.zeros((orden, orden))\r\n    \r\n    for ii in np.arange(0, orden):\r\n        for jj in np.arange(0, orden):\r\n            aa[ii, jj] = acf[ np.int(np.abs(ii - jj)) ]\r\n    \r\n    aa_1 = np.linalg.inv(aa)\r\n    \r\n    parameters = np.ma.dot(bb,aa_1) #Compliant with IDL aa_1#bb\r\n    \r\n    import warnings\r\n    warnings.filterwarnings('error')\r\n    try:\r\n        s = acf[0] - np.sum(parameters * bb)\r\n        sigma_e = np.sqrt(s)\r\n    except RuntimeWarning:\r\n        print \"Warning : bad parameters - spectrum not computed\"\r\n        sigma_e = np.nan\r\n        \r\n    \r\n    return parameters, sigma_e", "response": "A helper function to solve the Yule - Walker equations for AutoRegressive Models"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the optimal order AR spectrum by minimizing the BIC.", "response": "def optimal_AR_spectrum(dx, Y, ndegrees=None,return_min=True):\r\n    '''\r\n    Get the optimal order AR spectrum by minimizing the BIC.\r\n    '''\r\n    \r\n    if ndegrees is None : ndegrees=len(Y)-ndegrees\r\n    \r\n    aicc=np.arange(ndegrees)\r\n    aic=aicc.copy()\r\n    bic=aicc.copy()\r\n    tmpStr=[]\r\n    for i in np.arange(1, ndegrees):\r\n        dum=yule_walker_regression(dx,Y, i)\r\n        tmpStr.append(dum)\r\n        aicc[i-1]=(tmpStr[i-1])['esd'].model['aicc']\r\n        aic[i-1]=(tmpStr[i-1])['esd'].model['aic']\r\n        bic[i-1]=(tmpStr[i-1])['esd'].model['bic']\r\n    \r\n    if return_min : return np.argmin(bic)+1\r\n    else : return {'aicc':aicc,'aic':aic,'bic':bic}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef server(port):\n    args = ['python', 'manage.py', 'runserver']\n    if port:\n        args.append(port)\n    run.main(args)", "response": "Start the Django dev server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef log_level(conf):\n    if conf.debug is True:\n        return logging.DEBUG\n    elif conf.verbose is True:\n        return logging.DEBUG\n    elif conf.quiet is True:\n        return logging.WARNING\n    else:\n        return logging.INFO", "response": "Get debug settings from arguments."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef configure(conf, default_config=None):\n    if conf.logconfig and os.path.isfile(conf.logconfig):\n        logging.config.fileConfig(conf.logconfig,\n                                  disable_existing_loggers=False)\n    elif default_config and os.path.isfile(default_config):\n        logging.config.fileConfig(default_config,\n                                  disable_existing_loggers=False)\n    else:\n        init_console_logging(conf)", "response": "Configure logging based on log config file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_debug_formatter(conf):\n    if conf.debug is True:\n        return DebugFormatter('%(pathname)s:%(lineno)d: %(levelname)-8s '\n                              '%(message)s')\n    elif conf.verbose is True:\n        return logging.Formatter(\n            '%(name)-30s: %(levelname)-8s %(message)s')\n    elif conf.quiet is True:\n        return logging.Formatter('%(message)s')\n    else:\n        return logging.Formatter(logging.BASIC_FORMAT)", "response": "Get debug formatter based on configuration."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a stream handler if it exists.", "response": "def find_console_handler(logger):\n    \"\"\"Return a stream handler, if it exists.\"\"\"\n    for handler in logger.handlers:\n        if (isinstance(handler, logging.StreamHandler) and\n                handler.stream == sys.stderr):\n            return handler"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef format(self, record):\n        if hasattr(record, 'data'):\n            return \"%s. DEBUG DATA=%s\" % (\n                logging.Formatter.format(self, record),\n                record.__dict__['data'])\n        return logging.Formatter.format(self, record)", "response": "Print out any extra data provided in logs."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nturns a path with opt. globbing into a list of objects.", "response": "def _path_to_objs(path, include=['*', '.*'], exclude=['.*', '_*']):\n    \"\"\"Turn path with opt. globbing into valid list of files respecting\n    include and exclude patterns.\n    \n    Parameters\n    ----------\n    path : str\n        Path to process. Can be location of a file, folder or glob.\n        Can be in uri-notation, can be relative or absolute or start with ~.\n    include : list, optional\n        Globbing patterns to require in result, defaults to ['*', '.*'].\n    exclude : list, optional\n        Globbing patterns to exclude from result, defaults to ['.*', '_*'].\n    \n    Returns\n    -------\n    objs : list\n        List of valid files\n    \n    Notes\n    -----\n    - Doesn't show hidden files starting with '.' by default. To enable hidden files, make sure '.*' is in `include` and '.*' is not in `exclude`.\n    - Doesn't show files starting with '_' by default. To enable these files, make sure '_*' is not in `exclude`.\n    \"\"\"\n    \n    if '://' in path:\n        # don't modify when path is in uri-notation, except for local files\n        if path.startswith('file://'):\n            path = path[7:]\n        else:\n            return [path]\n    \n    path = os.path.abspath(os.path.expanduser(path))\n    \n    if os.path.isfile(path):\n        if not path.lower().endswith(('.xlsx', '.xls')) and zipfile.is_zipfile(path):\n            # zipfile misidentifies xlsx as archive of xml files\n            with zipfile.ZipFile(path) as myzip:\n                zipped = []\n                for z in myzip.namelist():\n                    z_fn = os.path.basename(z)\n                    if z_fn != '' and any([fnmatch(z_fn, i) for i in include]) and \\\n                        not any([fnmatch(z_fn, e) for e in exclude]):\n                        zipped.append(z)\n                return [myzip.open(z) for z in zipped]\n        else:\n            return [path]\n    elif os.path.isdir(path):\n        cands = [os.path.abspath(os.path.join(path, p)) for p in os.listdir(path)]\n        dirname = path\n    else:\n        cands = []\n        dirname = os.path.dirname(path)\n    \n    include = list(chain.from_iterable(glob(os.path.join(dirname, i)) for i in include))\n    exclude = list(chain.from_iterable(glob(os.path.join(dirname, e)) for e in exclude))\n    \n    objs = []\n    if cands == []:\n        cands = glob(path)\n    for p in cands:\n        if os.path.isfile(p) and p in include and not p in exclude:\n            objs.append(p)\n    \n    zipped = [zipfile.is_zipfile(o) and not o.lower().endswith(('.xlsx', '.xls')) \\\n        for o in objs]\n    toappend = []\n    todelete = []\n    \n    for ix, o in enumerate(objs):\n        # if zipfile in objs replace zipfile with its contents\n        if zipped[ix]:\n            for new_o in _path_to_objs(o):\n                toappend.append(new_o)\n            todelete.append(ix)\n    \n    shiftindex = 0\n    for d in todelete:\n        del objs[d - shiftindex]\n        shiftindex += 1\n    \n    for new_o in toappend:\n        objs.append(new_o)\n    \n    return objs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_df(obj, cfg={}, raise_on_error=True, silent=False, verbose=False):\n    \n    if type(obj) == str:\n        name = obj\n    else:\n        name = obj.name\n    name = name[name.rfind('/') + 1:]\n    \n    if not raise_on_error:\n        try:\n            return to_df(obj=obj, cfg=cfg, raise_on_error=True)\n        except (pd.parser.CParserError, AttributeError, ValueError, TypeError, IOError) as e:\n            if not silent:\n                print('WARNING in {}: {} {}'.format(name, e.__class__, e))\n            return None\n        except:\n            if not silent:\n                print('WARNING in {}: {}'.format(name, sys.exc_info()[0]))\n            return None\n\n    params = {}\n    if 'default' in cfg:\n        params = deepcopy(cfg['default'])\n    if name in cfg:\n        for e in cfg[name]:\n            params[e] = deepcopy(cfg[name][e])\n    if 'custom_date_parser' in params:\n        params['date_parser'] = DtParser(params['custom_date_parser']).parse\n        del params['custom_date_parser']\n\n    if verbose:\n        print(name, params)\n    \n    if name.lower().startswith('s3:'):\n        if not find_spec('boto'):\n            raise ImportError('reading from aws-s3 requires the boto package to be installed')\n    \n    if '.csv' in name.lower():\n        # name can be .csv.gz or .csv.bz2\n        return pd.read_csv(obj, **params)\n        \n    elif '.tsv' in name.lower() or '.txt' in name.lower():\n        # name can be .tsv.gz or .txt.bz2\n        return pd.read_table(obj, **params)\n    \n    elif name.lower().endswith(('.htm', '.html')):\n        if not find_spec('lxml'):\n            params['flavor'] = 'bs4'\n            if not find_spec('bs4') and not find_spec('html5lib'):\n                raise ImportError('reading html requires the lxml or bs4 + html5lib packages to be installed')\n\n        if 'nrows' in params:\n            del params['nrows']\n        \n        if type(obj) == zipfile.ZipExtFile:\n            obj = obj.read()\n        data = pd.read_html(obj, **params)\n        data = {str(i): data[i] for i in range(len(data))}\n        return data\n    \n    elif name.lower().endswith('.xml'):\n        if 'nrows' in params:\n            del params['nrows']\n        \n        from icy.utils import xml_to_json\n        \n        with open(obj) as f:\n            json = xml_to_json(str(f.read()))\n        \n        return pd.read_json(json, **params)\n        \n    elif name.lower().endswith('.json'):\n        if 'nrows' in params:\n            del params['nrows']\n        \n        return pd.read_json(obj, **params)\n    \n    elif name.lower().endswith(('.xls', '.xlsx')):\n        if not find_spec('xlrd'):\n            raise ImportError('reading excel files requires the xlrd package to be installed')\n        \n        if 'nrows' in params:\n            del params['nrows']\n        \n        data = {}\n        xls = pd.ExcelFile(obj)\n        for key in xls.sheet_names:\n            data[key] = xls.parse(key, **params)\n        return data\n    \n    elif name.lower().endswith(('.h5', '.hdf5')):\n        if not find_spec('tables'):\n            raise ImportError('reading hdf5 files requires the pytables package to be installed')\n        \n        if 'nrows' in params:\n            del params['nrows']\n            # params['chunksize'] = params.pop('nrows') # returns iterator\n        \n        with pd.HDFStore(obj) as store:\n            data = {}\n            for key in store.keys():\n                data[key[1:]] = store[key]\n        return data\n    \n    elif name.lower().endswith(('.sqlite', '.sql', '.db')):\n        import sqlite3\n        if type(obj) != str:\n            raise IOError('sqlite-database must be decompressed before import')\n        \n        if 'nrows' in params:\n            del params['nrows']\n            # params['chunksize'] = params.pop('nrows') # returns iterator\n        \n        with sqlite3.connect(obj) as con:\n            data = {}\n            cursor = con.cursor()\n            cursor.execute('SELECT name FROM sqlite_master WHERE type=\"table\"')\n            tables = [t[0] for t in cursor.fetchall()]\n            for t in tables:\n                sql = 'SELECT * FROM ' + t\n                data[t] = pd.read_sql_query(sql, con, **params)\n        return data\n    \n    else:\n        try:\n            data = {name: odo(obj, pd.DataFrame)}\n            if type(data[name]) == pd.DataFrame:\n                return data\n        except NotImplementedError:\n            pass\n        raise NotImplementedError('Error creating DataFrame from object', obj)", "response": "Convert obj to pandas. DataFrame"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping pandas. IO & odo to create a dictionary of pandas. DataFrames from multiple sources.", "response": "def read(path, cfg={}, raise_on_error=False, silent=False, verbose=False, return_errors=False):\n    \"\"\"Wraps pandas.IO & odo to create a dictionary of pandas.DataFrames from multiple different sources\n    \n    Parameters\n    ----------\n    path : str\n        Location of file, folder or zip-file to be parsed. Can include globbing (e.g. `*.csv`).\n        Can be remote with URI-notation beginning with e.g. http://, https://, file://, ftp://, s3:// and ssh://.\n        Can be odo-supported database (SQL, MongoDB, Hadoop, Spark) if dependencies are available.\n        Parser will be selected based on file extension.\n    cfg : dict or str, optional\n        Dictionary of kwargs to be provided to the pandas parser (http://pandas.pydata.org/pandas-docs/stable/api.html#input-output)\n        or str with path to YAML, that will be parsed.\n        \n        Special keys:\n        \n        **filters** : str or list of strings, optional. For a file to be processed, it must contain one of the Strings (e.g. ['.csv', '.tsv'])\n        \n        **default** : kwargs to be used for every file\n        \n        **custom_date_parser** : strptime-format string (https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior), generates a parser that used as the *date_parser* argument\n        \n        If filename in keys, use kwargs from that key in addition to or overwriting *default* kwargs.\n    silent : boolean, optional\n        If True, doesn't print to stdout.\n    verbose : boolean, optional\n        If True, prints parsing arguments for each file processed to stdout.\n    raise_on_error : boolean, optional\n        Raise exception or only display warning, if a file cannot be parsed successfully.\n    return_errors : boolean, optional\n        If True, read() returns (data, errors) tuple instead of only data, with errors as a list of all files that could not be parsed.\n        \n    Returns\n    -------\n    data : dict\n        Dictionary of parsed pandas.DataFrames, with file names as keys.\n    \n    Notes\n    -----\n    - Start with basic cfg and tune until the desired parsing result is achieved.\n    - File extensions are critical to determine the parser, make sure they are *common*.\n    - Avoid files named 'default' or 'filters'.\n    - Avoid duplicate file names.\n    - Subfolders and file names beginning with '.' or '_' are ignored.\n    - If an https:// URI isn't correctly processed, try http:// instead.\n    - To connect to a database or s3-bucket, make sure the required dependencies like sqlalchemy, pymongo, pyspark or boto are available in the active environment.\n    \"\"\"\n    \n    if type(cfg) == str:\n        cfg = os.path.abspath(os.path.expanduser(cfg))\n        yml = _read_yaml(cfg)\n        if yml == None:\n            if not silent:\n                print('creating read.yml config file draft ...')\n            cfg = {'filters': ['.csv'], 'default': {'sep': ',', 'parse_dates': []}}\n            with open('local/read.yml', 'xt') as f:\n                yaml.dump(cfg, f)\n            yml = _read_yaml('local/read.yml')\n        if 'filters' in yml:\n            filters = yml['filters']\n            if type(filters) == str:\n                filters = [filters]\n            del yml['filters']\n        else:\n            filters = []\n        cfg = yml\n    data = {}\n    errors = []\n    \n    if not silent:\n        print('processing', path, '...')\n    \n    for f in _path_to_objs(path):\n        if type(f) == str:\n            fname = os.path.basename(f)\n        elif type(f) == zipfile.ZipExtFile:\n            fname = f.name\n        else:\n            raise RuntimeError('_path_to_objs() returned unknown type', f)\n        \n        data, errors = _read_append(data=data, errors=errors, path=f, fname=fname, \\\n            cfg=cfg, raise_on_error=raise_on_error, silent=silent, verbose=verbose)\n        \n    if raise_on_error and data == {}:\n        raise IOError('path is invalid or empty')\n    \n    if not silent:\n        print('imported {} DataFrames'.format(len(data)))\n        if len(data) > 0:\n            print('total memory usage: {}'.format(mem(data)))\n        if len(errors) > 0:\n            print('import errors in files: {}'.format(', '.join(errors)))\n\n    if return_errors:\n        return data, errors\n    else:\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the total memory used by data", "response": "def mem(data):\n    \"\"\"Total memory used by data\n    \n    Parameters\n    ----------\n    data : dict of pandas.DataFrames or pandas.DataFrame\n    \n    Returns\n    -------\n    str : str\n        Human readable amount of memory used with unit (like KB, MB, GB etc.).\n    \"\"\"\n    \n    if type(data) == dict:\n        num = sum([data[k].memory_usage(index=True).sum() for k in data])\n    else:\n        num = data.memory_usage(index=True).sum()\n    for x in ['bytes', 'KB', 'MB', 'GB', 'TB']:\n        if num < 1024.0:\n            return \"%3.1f %s\" % (num, x)\n        num /= 1024.0\n    return \"%3.1f %s\" % (num, 'PB')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwork IN PROGRESS Concat, merge, join, drop keys in dictionary of pandas.DataFrames into one pandas.DataFrame (data) and a pandas.Series (labels). Parameters ---------- data : dict of pandas.DataFrames Result of icy.read() cfg : dict or str, optional Dictionary of actions to perform on data or str with path to YAML, that will be parsed. Returns ------- data : pandas.DataFrame The aggregated dataset labels : pandas.Series The target variable for analysis of the dataset, can have fewer samples than the aggregated dataset Notes -----", "response": "def merge(data, cfg=None):\n    \"\"\" WORK IN PROGRESS\n    \n    Concat, merge, join, drop keys in dictionary of pandas.DataFrames\n    into one pandas.DataFrame (data) and a pandas.Series (labels).\n    \n    Parameters\n    ----------\n    data : dict of pandas.DataFrames\n        Result of icy.read()\n    cfg : dict or str, optional\n        Dictionary of actions to perform on data\n        or str with path to YAML, that will be parsed.\n    \n    Returns\n    -------\n    data : pandas.DataFrame\n        The aggregated dataset\n    labels : pandas.Series\n        The target variable for analysis of the dataset,\n        can have fewer samples than the aggregated dataset\n    \n    Notes\n    -----\n    \n    \"\"\"\n    \n    # go from a dict of dataframes (data) to one dataframe (data) and one series (labels)\n    # pd.concat([df1, df2], join, join_axes, ignore_index) and pd.merge(left, right, how, on, suffixes)\n    # should be easy to iterate from normalized tables to a fully joined set of dataframes\n    \n    if type(cfg) == str:\n        cfg = _read_yaml(cfg)\n    if cfg == None:\n        cfg = _read_yaml('local/merge.yml')\n        if cfg == None:\n            print('creating merge.yml config file draft ...')\n            cfg = {}\n            # find all tables with identical column names\n            # if no common key-col\n            # concat along rows, add col (src)\n            # e.g. chimps\n            \n            # find all tables with same length\n            # if no duplicate column names\n            # concat along columns\n            \n            # find master table (by length?)\n            # from smalles to biggest table\n            # find possible key-cols by uniques == len\n            # find bigger tables with common column names -> cands\n            # check for highest overlap-ratio of uniques -> cand (prefer smaller table if equal ratio)\n            # join table on best cand\n            # if ratio below treshold put table on unidentified list\n\n            for key in data:\n                cfg[key] = list(data[key].columns)\n            with open('local/merge.yml', 'xt') as f:\n                yaml.dump(cfg, f)\n            cfg = _read_yaml('local/merge.yml')\n    \n    # if cfg == None:\n    #     if not os.path.exists(default_cfg):\n    #         create default_cfg draft\n    #     else:\n    #         join on default_cfg\n    #         report join_result\n    # else:\n    #     join on cfg\n    #     report join_result\n    \n    labels = None\n    return data, labels"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _find_key_cols(df):\n    \n    keys = []\n    for col in df:\n        if len(df[col].unique()) == len(df[col]):\n            keys.append(col)\n    return keys", "response": "Identify columns in a DataFrame that could be a unique key"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun read on a number of examples supress output generate summary.", "response": "def run_examples(examples):\n    \"\"\"Run read() on a number of examples, supress output, generate summary.\n    \n    Parameters\n    ----------\n    examples : list of tuples of three str elements\n        Tuples contain the path and cfg argument to the read function,\n        as well as the cfg argument to the merge function (*TODO*)\n        e.g. [(path, read_cfg, merge_cfg), (...)]\n    \n    Returns\n    -------\n    None\n        Prints all results to stdout.\n    \"\"\"\n    \n    import inspect\n\n    PATH_TEST_DATA = os.path.join(os.path.dirname(os.path.abspath( \\\n        inspect.getfile(inspect.currentframe()))), '../local/test_data')\n    \n    print('running examples ...')\n    t0 = datetime.now()\n    results = [0, 0, 0]\n    for ex in sorted(examples):\n        t1 = datetime.now()\n        src, cfg, _ = examples[ex]\n        src = os.path.abspath(os.path.join(PATH_TEST_DATA, src))\n        if not os.path.isfile(src) and not os.path.isdir(src):\n            print('{} not a file'.format(src))\n            break\n        if type(cfg) == str:\n            cfg = os.path.abspath(os.path.join(PATH_TEST_DATA, cfg))\n            if not os.path.isfile(cfg):\n                print('{} not a file'.format(cfg))\n                break\n        try:\n            data = read(src, cfg=cfg, silent=True)\n            n_keys = len(data.keys())\n            if n_keys > 0:\n                print('data {:<15} [SUCCESS]   {:.1f}s, {} dfs, {}'.format(\n                    ex, (datetime.now()-t1).total_seconds(), n_keys, mem(data)))\n                results[0] += 1\n            else:\n                print('data {:<15} [NO IMPORT] {:.1f}s'.format(ex, (datetime.now()-t1).total_seconds()))\n                results[1] += 1\n        except:\n            print('data {:<15} [EXCEPTION] {:.1f}s'.format(ex, (datetime.now()-t1).total_seconds()))\n            results[2] += 1\n    print()\n    print('ran {} tests in {:.1f} seconds'.format(len(examples),\n        (datetime.now()-t0).total_seconds()))\n    print('{} success / {} no import / {} exception'.format(\n        str(results[0]), str(results[1]), str(results[2])))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add(self, key, value):\n        if key.endswith('_'):\n            key = key[:-1]\n        if key in self.attributes:\n            self.attributes[key] = self.attributes[key] + ' ' + value\n        else:\n            self.attributes[key] = value", "response": "Adds a value to the attribute list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _cleankeys(self, dict):\n        for key, val in dict.items():\n            if key.endswith('_'):\n                del dict[key]\n                dict[key[:-1]] = val", "response": "Clean keys in a dictionary so that they can be sent directly to the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of all the files under the given module_name", "response": "def get_dirtree(module_name, dirlist=[]):\n    '''\n    module_name-->str: must be name of a dir under current working dir\n    dirlist-->list of str: must all be names of dirs under module_name\n    '''\n    ret = []\n    curdir = os.getcwd()\n    if not os.path.isdir(module_name):\n        return ret\n    os.chdir(module_name)\n    try:\n        for dirname in dirlist:\n            if not os.path.isdir(dirname):\n                continue\n            for (d, ds, fs) in os.walk(dirname):\n                for f in fs:\n                    ret += [os.path.join(d, f)]\n        return ret\n    except:\n        return ret\n    finally:\n        os.chdir(curdir)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_in_order(l, show_output=True, show_err=True, ignore_err=False,\n                 args=(), **kwargs):\n    '''\n    Processes each element of l in order:\n        if it is a string: execute it as a shell command\n        elif it is a callable, call it with *args, **kwargs\n\n    l-->list: Each elem is either a string (shell command) or callable\n              Any other type is ignored\n    show_output-->boolean: Show stdout of shell commands\n                           Does not affect callables\n    show_err-->Boolean: Show stderr of shell commands\n                        Does not affect callables\n    ignore_err-->boolean: Continue after exception or shell command\n                          wth return code != 0\n    Returns-->Nothing\n\n    if ignore_err == False, exceptions are re-raised, hence shown\n\n    ------------------------------------------------------------------\n    show_output show_err ignore_err   stdout stderr exception continue\n                                                    trace\n    ------------------------------------------------------------------\n    True        True     False        SHOW   SHOW   SHOW      NO\n    True        False    False        SHOW   HIDE   SHOW      NO\n    False       True     False        HIDE   SHOW   SHOW      NO\n    False       False    False        HIDE   HIDE   SHOW      NO\n\n    True        True     True         SHOW   SHOW   SHOW      YES\n    True        False    True         SHOW   HIDE   HIDE      YES\n    False       True     True         HIDE   SHOW   SHOW      YES\n    False       False    True         HIDE   HIDE   HIDE      YES\n    ------------------------------------------------------------------\n    ----------- DEFAULT -----------   SHOW   SHOW   SHOW      NO\n    ------------------------------------------------------------------\n    '''\n    # Set defaults\n    if show_output is None:\n        show_output = True\n    if show_err is None:\n        show_err = True\n    if ignore_err is None:\n        ignore_err = False\n    if args is None:\n        args = ()\n\n    for c in l:\n        try:\n            if isinstance(c, str):\n                devnull = open(os.devnull, 'w')\n                if not show_err:\n                    stderr = devnull\n                else:\n                    stderr = None\n                if not show_output:\n                    stdout = devnull\n                else:\n                    stdout = None\n                retcode = subprocess.call(\n                    c, shell=True, stdout=stdout, stderr=stderr)\n                if not ignore_err and retcode != 0:\n                    break\n            elif hasattr(c, '__call__'):\n                c(*args, **kwargs)\n        except:\n            if not ignore_err:\n                raise\n            if show_err:\n                sys.stderr.write(traceback.format_exc())", "response": "Runs each element of a list in order."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_triggers(step, pre_post, args=(), **kwargs):\n    '''\n    step, pre_post-->str: Looked up in CONFIG_VAR\n                          step must be key in CONFIG_VAR\n                          pre_post must be key in CONFIG_VAR[step]\n    args-->tuple: Passed to run_in_order()\n    '''\n    if not isinstance(step, str) or not isinstance(pre_post, str):\n        return\n    if trace_triggers:\n        msg = 'Trigger for %s: %s' % (step, pre_post)\n        sys.stderr.write(msg.center(80, '-') + '\\n')\n    if args is None:\n        args = ()\n    if not isinstance(args, tuple):\n        return\n    cfg = __get_config()\n    if cfg is None:\n        return\n    if step not in cfg:\n        return\n    if not isinstance(cfg[step], dict):\n        return\n    if pre_post not in cfg[step]:\n        return\n    d = cfg[step][pre_post]\n    l = d.get('cmdlist', [])\n    if not l:\n        return\n\n    show_output = d.get('show_output', None)\n    show_err = d.get('show_err', None)\n    ignore_err = d.get('ignore_err', None)\n\n    run_in_order(\n        l,\n        show_output=show_output,\n        show_err=show_err,\n        ignore_err=ignore_err,\n        args=args,\n        pre_post=pre_post,\n        kwargs=kwargs\n    )", "response": "Run the triggers for the given step."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef short_key():\n    firstlast = list(ascii_letters + digits)\n    middle = firstlast + list('-_')\n    return ''.join((\n        choice(firstlast), choice(middle), choice(middle),\n        choice(middle), choice(firstlast),\n    ))", "response": "Generate a short key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_datastore(config):\n    if 'datastore' in config:\n        # the datastore has already been initialized, just use it.\n        return config['datastore']\n    factory = config.pop('factory')\n    if isinstance(factory, str):\n        \"\"\"\n        factory should be a string defined in the pkg_resources.EntryPoint\n        format.\n        \"\"\"\n        factory = pkg_resources.EntryPoint.parse('x=' + factory).resolve()\n    return factory(**config)", "response": "Take the config definition and initialize the datastore.\n\n    The config must contain either a 'datastore' parameter, which\n    will be simply returned, or\n    must contain a 'factory' which is a callable or entry\n    point definition. The callable should take the remainder of\n    the params in config as kwargs and return a DataStore instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstore code or a file. Returns a tuple containing the uid and shortid.", "response": "def store(\n            self, type, nick, time, fmt=None, code=None, filename=None,\n            mime=None, data=None, makeshort=True):\n        \"\"\"\n        Store code or a file. Returns a tuple containing the uid and shortid\n        \"\"\"\n        uid = str(uuid.uuid4())\n        shortid = short_key() if makeshort else None\n\n        paste = assign_params(self.build_paste, locals())()\n        self._store(uid, paste, data)\n        if nick:\n            self._storeLog(nick, time, uid)\n        return uid, shortid"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild a paste object", "response": "def build_paste(uid, shortid, type, nick, time, fmt, code, filename, mime):\n        \"Build a 'paste' object\"\n        return locals()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef migrate(dest_datastore, source_datastore):\n        for uid in source_datastore.list():\n            try:\n                paste = source_datastore._retrieve(uid)\n            except Exception as exc:\n                print(\n                    \"{exc.__class__.__name__} occurred retrieving {uid}: {exc}\"\n                    .format(exc=exc, uid=uid),\n                    file=sys.stderr)\n                continue\n            data = paste.pop('data', None)\n            try:\n                dest_datastore._store(uid, paste, data)\n            except Exception as exc:\n                print(\n                    \"{exc.__class__.__name__} occurred storing {uid}: {exc}\"\n                    .format(exc=exc, uid=uid),\n                    file=sys.stderr)\n                continue", "response": "Copy all records from source_datastore to dest_datastore"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npersisting the given curves to the Asset Manager.", "response": "def persist_curves(self, asset_manager_id, business_date, curves, update_existing_curves=True):\n        \"\"\"\n        :param asset_manager_id:\n        :param business_date:\n        :param curves:\n        :param update_existing_rates:\n        :return:\n        \"\"\"\n        self.logger.info('Persist curves - Asset Manager: %s - Business Date: %s', asset_manager_id, business_date)\n        url = '%s/curves/%s/%s' % (self.endpoint, asset_manager_id, business_date.isoformat())\n        params = {'update_existing_curves': update_existing_curves}\n        curves_json = [curve.to_interface() for curve in curves]\n        response = self.session.post(url, params = params, json=curves_json)\n        if response.ok:\n            curves = [json_to_curve(curve) for curve in response.json()]\n            return curves\n        else:\n            self.logger.error(response.text)\n            response.raise_for_status()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear(self, asset_manager_id):\n        self.logger.info('Clear Market Data - Asset Manager: %s', asset_manager_id)\n        url = '%s/clear/%s' % (self.endpoint, asset_manager_id)\n        response = self.session.delete(url)\n        if response.ok:\n            eod_price_count = response.json().get('eod_price_count', 'Unknown')\n            self.logger.info('Deleted %s EOD Prices.', eod_price_count)\n            fx_rate_count = response.json().get('fx_rate_count', 'Unknown')\n            self.logger.info('Deleted %s FX Rates.', fx_rate_count)\n            return response.json()\n        else:\n            self.logger.error(response.text)\n            response.raise_for_status()", "response": "This method deletes all the data for an asset_manager_id."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_brokendate_fx_forward_rate(self, asset_manager_id,  asset_id, price_date, value_date):\n        self.logger.info('Calculate broken date FX Forward - Asset Manager: %s - Asset (currency): %s - Price Date: %s - Value Date: %s', asset_manager_id, asset_id, price_date, value_date)\n        url = '%s/brokendateforward/%s' % (self.endpoint, asset_manager_id)\n        params = {'value_date': value_date, 'asset_id':asset_id, 'price_date': price_date}\n        response = self.session.get(url=url, params = params)\n        if response.ok:\n            forward_rate = response.json()\n            self.logger.info('Retrieved broken date FX forward rate %s - %s: %s', asset_id, price_date, value_date)\n            return forward_rate\n        else:\n            self.logger.error(response.text)\n            response.raise_for_status()", "response": "This method calculates the broken date forward FX rate based on the passed in parameters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the last available business date for the assets so we know the starting date for new data which needs to be downloaded from data providers.", "response": "def last_available_business_date(self, asset_manager_id, asset_ids, page_no=None, page_size=None):\n        \"\"\"\n        Returns the last available business date for the assets so we know the \n        starting date for new data which needs to be downloaded from data providers.\n        \n        This method can only be invoked by system user\n        \"\"\"\n        self.logger.info('Retrieving last available business dates for assets')\n        url = '%s/last-available-business-date' % self.endpoint\n        params = {'asset_manager_ids': [asset_manager_id],\n                  'asset_ids': ','.join(asset_ids)}\n        if page_no:\n            params['page_no'] = page_no\n        if page_size:\n            params['page_size'] = page_size\n        response = self.session.get(url, params=params)\n        if response.ok:\n            self.logger.info(\"Received %s assets' last available business date\", len(response.json()))\n            return response.json()\n        else:\n            self.logger.error(response.text)\n            response.raise_for_status()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef readddl(db):\n    '''Walks down database objects and generates\n    JDOC objects for table descriptions'''\n    jdoc = []\n    for schema in db.contents:\n        j = JDOC(None,\n                 schema.object_name,\n                 schema.comment,\n                 schema.object_type)\n        jdoc.append(j)\n        for table in schema.contents:\n            j = JDOC(table.schema_name,\n                     table.object_name,\n                     table.comment,\n                     table.object_type)\n            for c in table.contents:\n                j.params.append(c)\n            jdoc.append(j)\n    return jdoc", "response": "Walks down database objects and generates\n    JDOC objects for table descriptions"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove(addon, dev):\n    application = get_current_application()\n    application.remove(addon, dev=dev)", "response": "Remove a dependency.\n\n    Examples:\n\n    $ django remove dynamic-rest\n\n    - dynamic-rest == 1.5.0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_tree(self, has_tree=False, force_update=False):\n        if has_tree:\n            self.has_tree = self.clear_tree()\n\n        if force_update:\n            self.data_refresh_flag = True\n\n        try:\n            if self.data_refresh_flag:\n                fn = self.open_filename\n                if self.get_filetype(fn).lower() == 'json':\n                    data_dict = self.read_json(fn)\n                elif self.get_filetype(fn).lower() == 'lte':\n                    data_dict = self.read_lte(fn)\n            else:\n                data_dict = self.data['dict']\n\n            tree_name = self.treename_tc.GetValue()\n            tree_root = self.mainview_tree.AddRoot(tree_name)\n            self.add_items(data_dict,\n                           root=tree_root,\n                           target=self.mainview_tree)\n            self.expand_tree(self.expand_all_flag)\n            self.update_stat('list tree', 'Listing tree succeed', 'OK')\n            self.tree_refresh_flag = False\n            self.set_title()\n            self.all_children = self.get_children(tree_root,\n                                                  self.mainview_tree)\n            self.found_items_clear = True  # set clear flag of found items\n            self.lattice_model = None  # reset model when open new file\n            return True\n        except:\n            self.update_stat('list tree', 'Listing tree failed', 'ERR')\n            return self.has_tree", "response": "show tree list\n\n        :param has_tree: tree exist or not, False by default, if True, tree should be cleared first\n        :param force_update: force update flag, if True, update neglect other flags.\n        :return: has_tree, True successful, not change when exception"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding items for tree item", "response": "def add_items(self, data_dict, root=None, target=None):\n        \"\"\" add items for tree\n            :param data_dict: dict of tree data\n            :param root: treeitemid of tree root\n            :param target: treectrl obj\n        \"\"\"\n        if root is None:\n            print(\"Warning: TreeCtrl root must be given.\")\n            return\n        if target is None:\n            print(\"Warning: TreeCtrl target must be given.\")\n            return\n        for k in sorted(data_dict):\n            if isinstance(data_dict[k], dict):\n                k_item_root = target.AppendItem(root, k)\n                self.add_items(data_dict[k], k_item_root, target)\n            else:\n                item_val = ' : '.join((k, str(data_dict[k])))\n                target.AppendItem(root, item_val)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_data(self, item):\n        child, cookie = self.mainview_tree.GetFirstChild(item)\n        child_list = []\n        while child.IsOk():\n            child_list.append(child)\n            child, cookie = self.mainview_tree.GetNextChild(item, cookie)\n\n        lc = self.nodeview_lc\n        lc.DeleteAllItems()\n        for i, child in enumerate(child_list):\n            text = self.mainview_tree.GetItemText(child)\n            try:\n                k, v = [s.strip() for s in text.split(':')]\n            except ValueError:\n                k, v = text, '...'\n            idx = lc.InsertItem(MAXNROW, v)\n            lc.SetItem(idx, 1, k)", "response": "show data key - value in ListCtrl for tree item\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_lte(self, filename):\n        lpins = lattice.LteParser(filename)\n        return json.loads(lpins.file2json())", "response": "parse lte file first then return dict as read_json"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef json2lte(self, filename):\n        data_json = open(filename, 'r').read().strip()\n        latins = lattice.Lattice(data_json)\n\n        self.lattice_instance = latins\n        self.all_beamlines = latins.getAllBl()\n        if self.use_beamline is None:\n            self.use_beamline = 'BL' if 'BL' in self.all_beamlines else self.all_beamlines[\n                0]\n        bl_ele_list = [latins.getFullBeamline(k, True)\n                       for k in self.all_beamlines]\n        self.beamlines_dict = dict(zip(self.all_beamlines, bl_ele_list))\n\n        data_lte = latins.generateLatticeFile(self.use_beamline, 'sio')\n        return data_json, data_lte", "response": "convert json to lte file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef lte2json(self, filename):\n        lpins = lattice.LteParser(filename)\n        data_json = lpins.file2json()\n\n        latins = lattice.Lattice(lpins.file2json())\n        self.lattice_instance = latins\n        self.all_beamlines = latins.getAllBl()\n        if self.use_beamline is None:\n            self.use_beamline = 'BL' if 'BL' in self.all_beamlines else self.all_beamlines[\n                0]\n        bl_ele_list = [latins.getFullBeamline(k, True)\n                       for k in self.all_beamlines]\n        self.beamlines_dict = dict(zip(self.all_beamlines, bl_ele_list))\n\n        data_lte = open(filename, 'r').read()\n        return data_json, data_lte", "response": "convert lte to json"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_stat(self, mode='open', infostr='', stat=''):\n        self._update_stat[mode](mode, infostr, stat)", "response": "write operation stats to log\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate stat regarding to tree generating process", "response": "def _tree_stat(self, mode, infostr, stat):\n        \"\"\" update stat regarding to tree generating process,\n            e.g. show_tree()\n        \"\"\"\n        action_str = mode.upper()\n        info_str = infostr\n        if stat == 'OK':\n            self.action_st_panel.SetBackgroundColour('#00FF00')\n        else:  # ERR\n            self.action_st_panel.SetBackgroundColour('#FF0000')\n        self.action_st.SetLabel(action_str)\n        if info_str is None:\n            pass\n        if stat == 'OK':\n            child_cnt_0 = self.mainview_tree.GetChildrenCount(\n                self.mainview_tree.GetRootItem(),\n                recursively=False)\n            child_cnt_1 = self.mainview_tree.GetChildrenCount(\n                self.mainview_tree.GetRootItem(),\n                recursively=True)\n            self.info_st.SetLabel(\"{0} ({1} elements.)\".format(info_str, child_cnt_0))\n            self.log.append({'stat': stat,\n                             'logstr':\n                                 \"[{ts}] {acts:<10s} : {infs} ({cnt1}|{cnt2})\".format(\n                                     ts=time.strftime(\"%Y/%m/%d-%H:%M:%S\",\n                                                      time.localtime()),\n                                     acts=action_str,\n                                     infs=info_str,\n                                     cnt1=child_cnt_0,\n                                     cnt2=child_cnt_1), })\n        else:\n            self.info_st.SetLabel(\"{0} (0 elements.)\".format(info_str))\n            self.log.append({'stat': stat,\n                             'logstr':\n                                 \"[{ts}] {acts:<10s} : {infs} ({cnt1}|{cnt2})\".format(\n                                     ts=time.strftime(\"%Y/%m/%d-%H:%M:%S\",\n                                                      time.localtime()),\n                                     acts=action_str,\n                                     infs=info_str,\n                                     cnt1=0,\n                                     cnt2=0), })\n\n        if self.info_st.IsEllipsized():\n            self.info_st.SetToolTip(wx.ToolTip(info_str))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate stat regarding to file operation", "response": "def _file_stat(self, mode, infostr, stat):\n        \"\"\" update stat regarding to file operation,\n            e.g. open, save, saveas, etc.\n        \"\"\"\n        action_str = mode.upper()\n        info_str = infostr\n\n        if stat == 'OK':\n            self.action_st_panel.SetBackgroundColour('#00FF00')\n        else:  # ERR\n            self.action_st_panel.SetBackgroundColour('#FF0000')\n        self.action_st.SetLabel(action_str)\n        if info_str is None:\n            info_str = 'Undefined File'\n        self.info_st.SetLabel(info_str)\n        if self.info_st.IsEllipsized():\n            self.info_st.SetToolTip(wx.ToolTip(info_str))\n\n        self.log.append({'stat': stat,\n                         'logstr':\n                             \"[{ts}] {acts:<10s} : {infs}\".format(ts=time.strftime(\n                                 \"%Y/%m/%d-%H:%M:%S\", time.localtime()),\n                                 acts=action_str,\n                                 infs=info_str)})"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_refresh_flag(self, filename):\n        if filename is not None and filename != self.open_filename:\n            self.open_filename = filename\n            self.tree_refresh_flag = True\n            self.data_refresh_flag = True\n            return True\n        else:\n            return False", "response": "set refresh data flag return True or False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_children(self, root=None, target=None):\n        if root is None:\n            print(\"Warning: TreeCtrl root/child must be given.\")\n            return None\n        if target is None:\n            print(\"Warning: TreeCtrl target must be given.\")\n            return None\n        child, cookie = target.GetFirstChild(root)\n        child_list = []\n        while child.IsOk():\n            if target.ItemHasChildren(child):\n                child_list.extend(self.get_children(child, target))\n            child_list.append(child)\n            child, cookie = target.GetNextChild(root, cookie)\n        return child_list", "response": "returns list of all the children of given treeitem"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npacks up found items for search ctrl", "response": "def pack_found_items(self, s_text, target):\n        \"\"\" pack up found items for search ctrl\n            :param target: treectrl obj\n            :param s_text: text to search, lower case\n            return list of found items\n        \"\"\"\n        all_children = self.all_children\n        all_text = [target.GetItemText(i).lower() for i in all_children]\n\n        found_items = [child for i, child in enumerate(all_children)\n                       if s_text in all_text[i]]\n\n        return found_items"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_online_model(self, lattice_instance, use_bl, mode='simu'):\n        new_model = models.Models(name=use_bl, mode=mode)\n        ele_name_list = lattice_instance.getElementList(use_bl)\n        ele_eobj_list = []\n        for ele in ele_name_list:\n            ele_eobj_list.append(lattice_instance.makeElement(ele))\n        new_model.addElement(*ele_eobj_list)\n\n        return new_model", "response": "create online model according to the lattice. Lattice instance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_opts(conf):\n    conf.register_cli_opts(CLI_OPTS)\n    conf.register_opts(EPISODE_OPTS)\n    conf.register_opts(FORMAT_OPTS)\n    conf.register_opts(CACHE_OPTS, 'cache')", "response": "Configure options within configuration library."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of oslo_config options available in the library.", "response": "def list_opts():\n    \"\"\"Returns a list of oslo_config options available in the library.\n\n    The returned list includes all oslo_config options which may be registered\n    at runtime by the library.\n    Each element of the list is a tuple. The first element is the name of the\n    group under which the list of elements in the second element will be\n    registered. A group name of None corresponds to the [DEFAULT] group in\n    config files.\n    The purpose of this is to allow tools like the Oslo sample config file\n    generator to discover the options exposed to users by this library.\n\n    :returns: a list of (group_name, opts) tuples\n    \"\"\"\n    from tvrenamer.common import tools\n    all_opts = []\n    all_opts.extend(tools.make_opt_list([CLI_OPTS,\n                                         EPISODE_OPTS,\n                                         FORMAT_OPTS], None))\n    all_opts.extend(tools.make_opt_list([CACHE_OPTS], 'cache'))\n    return all_opts"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_sign(api_secret, msg):\n    if \"sign\" not in msg:\n        return False\n    sign = msg['sign']\n    params = [utils.safestr(msg[k]) for k in msg if k != 'sign' and msg[k] is not None]\n    local_sign = make_sign(api_secret, params)\n    result = (sign == local_sign)\n    if not result:\n        logger.error(\"check_sign failure, sign:%s != local_sign:%s\" %(sign,local_sign))\n    return result", "response": "Check if the sign is correct"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_message(api_secret, enc_func=False, **params):\n    if 'nonce' not in params:\n        params['nonce' ] = str(int(time.time()))\n    params['sign'] = make_sign(api_secret, params.values())\n    msg = json.dumps(params, ensure_ascii=False)\n    if callable(enc_func):\n        return enc_func(msg)\n    else:\n        return msg", "response": "Make a message from the given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_form_request(api_secret, request):\n    if not check_sign(api_secret, request):\n        raise SignError(u\"message sign error\")\n\n    return Storage(request)", "response": "parse a form request and return a new Storage object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pick_inputs(workspace):\n    frags_present = set()\n    frags_absent = set()\n\n    for path in workspace.input_paths:\n        if workspace.fragments_missing(path):\n            frags_absent.add(path)\n        else:\n            frags_present.add(path)\n\n    # If no fragments have been generated yet, just return the directory to \n    # make the resulting 'klab_generate_fragments' command a little simpler.\n    if not frags_present:\n        return [workspace.input_dir]\n\n    print '{0} of {1} inputs are missing fragments.'.format(\n        len(frags_absent), len(workspace.input_paths))\n\n    return sorted(frags_absent)", "response": "Return a list of input files that are missing fragments."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a list of files within a directory with given extensions.", "response": "def get_files(dir, exts, exclude=None, recursive=False):\n    \"\"\"\n    Get a list of files within a directory with given extensions.\n    Exclude/black list directories from the list if specified. By default,\n    the search is recursive, looking in all subdirectories of 'dir'\n\n    :param dir: String root directory to search under. All subdirectories are\n        also searched by default\n    :param exts: List of string file extensions. Files inside of dir with\n        names ending with this string will be included in the list. Note: the\n        string does not strictly need to be a file extension (beginging with\n        a '.' dot), it could be the entire name of the file, or a common\n        suffix to files.\n    :param exclude: List of strings specifying directories that should not be\n        included in the output list\n    :param recursive: When True, search in all subdirectories, otherwise just\n        look in the current directory\n    :return: List of string directories\n    \"\"\"\n    file_paths =[]\n    if recursive:\n        for root, _, _ in os.walk(dir):\n            # os.walk() does not add path separator by default to end of path\n            root = add_suffix(root, get_path_separator())\n            if exclude is not None and is_dir_inside(root, exclude):\n                # Skip directories that are in the exclude list\n                continue\n            file_paths.extend(get_files_in_dir(root, *exts))\n    else:\n        file_paths.extend(get_files_in_dir(dir, *exts))\n    return file_paths"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_files_in_dir(dir, *exts):\n    file_paths = []\n    if exts is None:\n        exts = ['']\n    for ext in exts:\n        file_paths.extend(glob.glob(dir + '*' + ext))\n    return file_paths", "response": "Returns a list of files in a directory that have the provided extensions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_dir_inside(dir, check_dirs):\n    for check_dir in check_dirs:\n        if os.path.commonprefix([dir, check_dir]) == check_dir:\n            return True\n    return False", "response": "Check to see if a directory is a subdirectory of or matches any of the check_dirs. Return True if the directory is a child of or matches any of the check_dirs. Return False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef OnSelChanged(self, event):\n        # Get the selected item object\n        item = event.GetItem()\n        obj = self.leftPanel.model.ItemToObject(item)\n        if isinstance(obj, compass.Survey):\n            l = [\n                'Survey Name: %s' % obj.name,\n                'Survey Date: %s' % obj.date,\n                'Comment: %s' % obj.comment,\n                'Team: %s' % ', '.join(obj.team),\n                'Surveyed Footage: %0.1f' % obj.length,\n                '',\n                ]\n            l.extend(['  '.join(['%s: %s' % (k,v) for (k,v) in shot.items()]) for shot in obj.shots])\n            self.display.SetLabel(str('\\n'.join(l)))\n        else:\n            self.display.SetLabel('')", "response": "Method called when selected item is changed"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize by creating the split window with the tree", "response": "def OnInit(self):\n        \"\"\"Initialize by creating the split window with the tree\"\"\"\n        project = compass.CompassProjectParser(sys.argv[1]).parse()\n        frame = MyFrame(None, -1, 'wxCompass', project)\n        frame.Show(True)\n        self.SetTopWindow(frame)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks to see if an object has each of the specified attributes.", "response": "def hasattrs(object, *names):\n    \"\"\"\n    Takes in an object and a variable length amount of named attributes,\n    and checks to see if the object has each property. If any of the\n    attributes are missing, this returns false.\n\n    :param object: an object that may or may not contain the listed attributes\n    :param names: a variable amount of attribute names to check for\n    :return: True if the object contains each named attribute, false otherwise\n    \"\"\"\n    for name in names:\n        if not hasattr(object, name):\n            return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nperforming a synchronous remote call where the returned value is given immediately.", "response": "def call(self, method, *args):\n        \"\"\"Perform a synchronous remote call where the returned value is given immediately.\n\n        This may block for sometime in certain situations. If it takes more than the Proxies\n        set timeout then a TimeoutError is raised.\n\n        Any exceptions the remote call raised that can be sent over the wire are raised.\n\n        Internally this calls begin_call(method, *args).result(timeout=self.timeout)\n\n        \"\"\"\n        return self.begin_call(method, *args).result(self.timeout)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef response(self, msgid, error, result):\n        if error:\n            self.requests[msgid].errback(Exception(str(error)))\n        else:\n            self.requests[msgid].callback(result)\n        del self.requests[msgid]", "response": "Handle a response message given to the proxy by the protocol object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef init(name, runtime):\n    runtime = click.unstyle(runtime)\n\n    stdout.write(\n        style.format_command(\n            'Initializing',\n            '%s %s %s' % (name, style.gray('@'), style.green(runtime))\n        )\n    )\n\n    config = Config(os.getcwd())\n    config.set('runtime', runtime)\n    config.save()\n\n    generate.main(['init', name], standalone_mode=False)\n    run.main(['python', 'manage.py', 'migrate'])", "response": "Create a new Django app."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if the coverage is 100%.", "response": "def check_coverage():\n    \"\"\"Checks if the coverage is 100%.\"\"\"\n    with lcd(settings.LOCAL_COVERAGE_PATH):\n        total_line = local('grep -n Total index.html', capture=True)\n        match = re.search(r'^(\\d+):', total_line)\n        total_line_number = int(match.groups()[0])\n        percentage_line_number = total_line_number + 5\n        percentage_line = local(\n            'awk NR=={0} index.html'.format(percentage_line_number),\n            capture=True)\n        match = re.search(r'(\\d.+)%', percentage_line)\n        try:\n            percentage = float(match.groups()[0])\n        except ValueError:\n            # If there's no dotting try another search\n            match = re.search(r'(\\d+)%', percentage_line)\n            percentage = float(match.groups()[0])\n    if percentage < 100:\n        abort(red('Coverage is {0}%'.format(percentage)))\n    print(green('Coverage is {0}%'.format(percentage)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates the local database.", "response": "def create_db(with_postgis=False):\n    \"\"\"\n    Creates the local database.\n\n    :param with_postgis: If ``True``, the postgis extension will be installed.\n\n    \"\"\"\n    local_machine()\n    local('psql {0} -c \"CREATE USER {1} WITH PASSWORD \\'{2}\\'\"'.format(\n        USER_AND_HOST, env.db_role, DB_PASSWORD))\n    local('psql {0} -c \"CREATE DATABASE {1} ENCODING \\'UTF8\\'\"'.format(\n        USER_AND_HOST, env.db_name))\n    if with_postgis:\n        local('psql {0} {1} -c \"CREATE EXTENSION postgis\"'.format(\n            USER_AND_HOST, env.db_name))\n    local('psql {0} -c \"GRANT ALL PRIVILEGES ON DATABASE {1}'\n          ' to {2}\"'.format(USER_AND_HOST, env.db_name, env.db_role))\n    local('psql {0} -c \"GRANT ALL PRIVILEGES ON ALL TABLES'\n          ' IN SCHEMA public TO {1}\"'.format(\n              USER_AND_HOST, env.db_role))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef export_db(filename=None, remote=False):\n    local_machine()\n    if not filename:\n        filename = settings.DB_DUMP_FILENAME\n    if remote:\n        backup_dir = settings.FAB_SETTING('SERVER_DB_BACKUP_DIR')\n    else:\n        backup_dir = ''\n\n    local('pg_dump -c -Fc -O -U {0}{1} {2} -f {3}{4}'.format(\n        env.db_role, HOST, env.db_name, backup_dir, filename))", "response": "Exports the database.\n\n    Make sure that you have this in your ``~/.pgpass`` file:\n\n    localhost:5433:*:<db_role>:<password>\n\n    Also make sure that the file has ``chmod 0600 .pgpass``.\n\n    Usage::\n\n        fab export_db\n        fab export_db:filename=foobar.dump"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndropping the local database.", "response": "def drop_db():\n    \"\"\"Drops the local database.\"\"\"\n    local_machine()\n    with fab_settings(warn_only=True):\n        local('psql {0} -c \"DROP DATABASE {1}\"'.format(\n            USER_AND_HOST, env.db_name))\n        local('psql {0} -c \"DROP USER {1}\"'.format(\n            USER_AND_HOST, env.db_role))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef jshint():\n    with fab_settings(warn_only=True):\n        needs_to_abort = False\n        # because jshint fails with exit code 2, we need to allow this as\n        # a successful exit code in our env\n        if 2 not in env.ok_ret_codes:\n            env.ok_ret_codes.append(2)\n        output = local(\n            'find -name \"{}\" -print'.format('*.js'),\n            capture=True,\n        )\n        files = output.split()\n        jshint_installed = local('command -v jshint', capture=True)\n        if not jshint_installed.succeeded:\n            warn(red(\n                \"To enable an extended check of your js files, please\"\n                \" install jshint by entering:\\n\\n    npm install -g jshint\"\n            ))\n        else:\n            for file in files:\n                if hasattr(settings, 'JSHINT_CHECK_EXCLUDES'):\n                    excludes = settings.JSHINT_CHECK_EXCLUDES\n                else:\n                    excludes = settings.SYNTAX_CHECK_EXCLUDES\n                if any(s in file for s in excludes):\n                    continue\n                jshint_result = local(\n                    'jshint {0}'.format(file),\n                    capture=True\n                )\n                if jshint_result:\n                    warn(red('JS errors detected in file {0}'.format(\n                        file\n                    )))\n                    puts(jshint_result)\n                    needs_to_abort = True\n        if needs_to_abort:\n            abort(red('There have been errors. Please fix them and run'\n                      ' the check again.'))\n        else:\n            puts(green('jshint found no errors. Very good!'))", "response": "Runs jshint checks on the given node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef syntax_check():\n    with fab_settings(warn_only=True):\n        for file_type in settings.SYNTAX_CHECK:\n            needs_to_abort = False\n            # because egrep fails with exit code 1, we need to allow this as\n            # a successful exit code in our env\n            if 1 not in env.ok_ret_codes:\n                env.ok_ret_codes.append(1)\n            output = local(\n                'find -name \"{}\" -print'.format(file_type),\n                capture=True,\n            )\n            files = output.split()\n            for file in files:\n                if any(s in file for s in settings.SYNTAX_CHECK_EXCLUDES):\n                    continue\n                result = local('egrep -i -n \"{0}\" {1}'.format(\n                    settings.SYNTAX_CHECK[file_type], file), capture=True)\n                if result:\n                    warn(red(\"Syntax check found in '{0}': {1}\".format(\n                        file, result)))\n                    needs_to_abort = True\n            if needs_to_abort:\n                abort(red('There have been errors. Please fix them and run'\n                          ' the check again.'))\n            else:\n                puts(green('Syntax check found no errors. Very good!'))", "response": "Runs flake8 against the codebase."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef import_db(filename=None):\n    local_machine()\n    if not filename:\n        filename = settings.DB_DUMP_FILENAME\n    with fab_settings(warn_only=True):\n        local('pg_restore -O -c -U {0}{1} -d {2} {3}'.format(\n            env.db_role, HOST, env.db_name, filename))", "response": "Imports the database.\n\n    Make sure that you have this in your ``~/.pgpass`` file:\n\n    localhost:5433:*:publishizer_publishizer:publishizer\n\n    Also make sure that the file has ``chmod 0600 .pgpass``.\n\n    Usage::\n\n        fab import_db\n        fab import_db:filename=foobar.dump"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nimports a backup of a media dump into your local media root.", "response": "def import_media(filename=None):\n    \"\"\"\n    Extracts media dump into your local media root.\n\n    Please note that this might overwrite existing local files.\n\n    Usage::\n\n        fab import_media\n        fab import_media:filename=foobar.tar.gz\n\n    \"\"\"\n    if not filename:\n        filename = settings.MEDIA_DUMP_FILENAME\n\n    project_root = os.getcwd()\n\n    with fab_settings(hide('everything'), warn_only=True):\n        is_backup_missing = local('test -e \"$(echo %s)\"' % os.path.join(\n            project_root, filename)).failed\n    if is_backup_missing:\n        abort(red('ERROR: There is no media backup that could be imported in'\n                  ' {0}. We need a file called {1} in that folder.'.format(\n                      project_root, filename)))\n\n    # copy the dump into the media root folder\n    with lcd(project_root):\n        local('cp {0} {1}'.format(filename, settings.MEDIA_ROOT))\n\n    # extract and remove media dump\n    with lcd(settings.MEDIA_ROOT):\n        local('tar -xvf {0}'.format(filename))\n        local('rm -rf {0}'.format(filename))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lessc(responsive=False):\n    local('lessc {0}/static/css/bootstrap.less'\n          ' {0}/static/css/bootstrap.css'.format(settings.PROJECT_NAME))\n    if responsive:\n        local('lessc {0}/static/css/responsive.less'\n              ' {0}/static/css/bootstrap-responsive.css'.format(\n                  settings.PROJECT_NAME))", "response": "Returns a new lessc file"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rebuild():\n    drop_db()\n    create_db()\n    if StrictVersion(django.get_version()) < StrictVersion('1.7'):\n        local('python{} manage.py syncdb --all --noinput'.format(\n            PYTHON_VERSION))\n        local('python{} manage.py migrate --fake'.format(PYTHON_VERSION))\n    else:\n        local('python{} manage.py migrate'.format(PYTHON_VERSION))", "response": "Rebuilds the database for the current version of the SeCraft."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef checkBinary(name, bindir=None):\n    if name == \"sumo-gui\":\n        envName = \"GUISIM_BINARY\"\n    else:\n        envName = name.upper() + \"_BINARY\"\n    env = os.environ\n    join = os.path.join\n    if envName in env and exeExists(env.get(envName)):\n        return env.get(envName)\n    if bindir is not None:\n        binary = join(bindir, name)\n        if exeExists(binary):\n            return binary\n    if \"SUMO_HOME\" in env:\n        binary = join(env.get(\"SUMO_HOME\"), \"bin\", name)\n        if exeExists(binary):\n            return binary\n    binary = os.path.abspath(\n        join(os.path.dirname(__file__), '..', '..', 'bin', name))\n    if exeExists(binary):\n        return binary\n    return name", "response": "Checks for the given binary in the given location."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the running number for the given id.", "response": "def g(self, id):\n        \"\"\"\n        If the given id is known, the numerical representation is returned,\n        otherwise a new running number is assigned to the id and returned\"\"\"\n        if id not in self._m:\n            if self.orig_ids:\n                self._m[id] = id\n                if self.warn:\n                    try:\n                        int(id)\n                    except:\n                        sys.stderr.write(\n                            'Warning: ID \"%s\" is not an integer.\\n' % id)\n                        self.warn = False\n            else:\n                self._m[id] = self.index\n                self.index += 1\n        return self._m[id]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef flush(self):\n        for fp in self.files:\n            fp.flush()\n            if isinstance(fp, int) or hasattr(fp, \"fileno\"):\n                try:\n                    os.fsync(fp)\n                except OSError:\n                    pass", "response": "flushes all file contents to disc"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfunction create user in linux for group and set homedir. Function return uid gid", "response": "def creatauth(name, homedir):\n    \"\"\" Function create user in linux for group and set homedir. Function return gid and uid.\"\"\"\n\n    uid, gid = [None, None]\n    # get information about user\n    command = \"id %s\" % (name)\n    data = commands.getstatusoutput(command)\n\n    if data[0] > 0:\n        # create new system user\n        command = \"useradd -g %s %s\" % (sett.APACHEIIS_GROUP, name)\n        #command = \"useradd -g %s %s\" % (\"www-data\",name)\n        data = commands.getstatusoutput(command)\n        if data[0] != 0:\n            msg = \"Error: Can't create user.\"\n            sys.stderr.write(msg)\n\n    # set homedir for user\n    command = \"usermod -d %s %s\" % (homedir, name)\n    data = commands.getstatusoutput(command)\n\n    command = \"chown %s:%s %s -R\" % (name, sett.APACHEIIS_GROUP, homedir)\n    data = commands.getstatusoutput(command)\n\n    # get information about user\n    command = \"id %s\" % (name)\n    data = commands.getstatusoutput(command)\n\n    # check new user and get uid, gid\n    if data[0] > 0:\n        msg = \"Error: User not create.\"\n        sys.stderr.write(msg)\n    else:\n        for it in data[1].split(\" \"):\n            m = re.search('uid=([0-9]*)', it)\n            try:\n                uid = m.group(1)\n            except:\n                pass\n\n            m = re.search('gid=([0-9]*)', it)\n            try:\n                gid = m.group(1)\n            except:\n                pass\n\n        return {\"uid\": uid, \"gid\": gid}\n    return {}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndownload an archive to a specific location", "response": "def fetch_archive(savedir, url, fname, checksum, force=False):\n    \"\"\"download an archive to a specific location\"\"\"\n    dest = pjoin(savedir, fname)\n    scheme, digest_ref = checksum.split(':')\n\n    if os.path.exists(dest) and not force:\n        info(\"already have %s\" % dest)\n        digest = checksum_file(scheme, fname)\n        if digest == digest_ref:\n            return dest\n        else:\n            warn(\"but checksum %s != %s, redownloading.\" % (digest, digest_ref))\n            os.remove(fname)\n    \n    info(\"fetching %s into %s\" % (url, savedir))\n    if not os.path.exists(savedir):\n        os.makedirs(savedir)\n    req = urlopen(url)\n    with open(dest, 'wb') as f:\n        f.write(req.read())\n    digest = checksum_file(scheme, dest)\n    if digest != digest_ref:\n        fatal(\"%s %s mismatch:\\nExpected: %s\\nActual  : %s\" % (\n            dest, scheme, digest_ref, digest))\n    return dest"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndownload and extract libzmq", "response": "def fetch_libzmq(savedir):\n    \"\"\"download and extract libzmq\"\"\"\n    dest = pjoin(savedir, 'zeromq')\n    if os.path.exists(dest):\n        info(\"already have %s\" % dest)\n        return\n    path = fetch_archive(savedir, libzmq_url, fname=libzmq, checksum=libzmq_checksum)\n    tf = tarfile.open(path)\n    with_version = pjoin(savedir, tf.firstmember.path)\n    tf.extractall(savedir)\n    tf.close()\n\n    # remove version suffix:\n    shutil.move(with_version, dest)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy_and_patch_libzmq(ZMQ, libzmq):\n\n    if sys.platform.startswith('win'):\n        return\n\n    # copy libzmq into zmq for bdist\n    local = localpath('zmq',libzmq)\n    if not ZMQ and not os.path.exists(local):\n        fatal(\"Please specify zmq prefix via `setup.py configure --zmq=/path/to/zmq` \"\n              \"or copy libzmq into zmq/ manually prior to running bdist.\")\n\n    try:\n        # resolve real file through symlinks\n        lib = os.path.realpath(pjoin(ZMQ, 'lib', libzmq))\n        print (\"copying %s -> %s\"%(lib, local))\n        shutil.copy(lib, local)\n    except Exception:\n        if not os.path.exists(local):\n            fatal(\"Could not copy libzmq into zmq/, which is necessary for bdist. \"\n                  \"Please specify zmq prefix via `setup.py configure --zmq=/path/to/zmq` \"\n                  \"or copy libzmq into zmq/ manually.\")\n    \n    if sys.platform == 'darwin':\n        # chmod u+w on the lib,\n        # which can be user-read-only for some reason\n        mode = os.stat(local).st_mode\n        os.chmod(local, mode | stat.S_IWUSR)\n\n        # patch install_name on darwin, instead of using rpath\n        cmd = ['install_name_tool', '-id', '@loader_path/../%s' % libzmq, local]\n\n        try:\n            p = Popen(cmd, stdout=PIPE, stderr=PIPE)\n        except OSError:\n            fatal(\"install_name_tool not found, cannot patch libzmq for bundling.\")\n\n        out, err = p.communicate()\n\n        if p.returncode:\n            fatal(\"Could not patch bundled libzmq install_name: %s\"%err, p.returncode)", "response": "copy libzmq into source dir and patch it if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new object with LOESS filters applied at a given cutoff frequency CUT.", "response": "def loess(h,x,cut):\r\n    \"\"\"\r\n    #===========================================================================\r\n    # ;+\r\n    # ; LOESS : Filter a signal H along X with a cutoff frequency CUT<br /><br />\r\n    # ; \r\n    # ; Reference : Schlax, M. G., et D. B. Chelton (1992), Frequency Domain Diagnostics<br />\r\n    # ;   for Linear Smoothers, Journal of the American Statistical Association, <br />\r\n    # ;   87(420), 1070-1081. \r\n    # ; \r\n    # ; @param h {in}{required}{type:NUMERIC} Array of height anomalies\r\n    # ; @param x {in}{required}{type:NUMERIC} Array of corresponding distances\r\n    # ; @param cut {in}{required}{type:NUMERIC} Cutoff distance in units of X.\r\n    # ; @param nan {in}{optional}{type:LOGICAL}{default:FALSE} Use NaNs<br />\r\n    # ;          \r\n    # ; @returns Hfilt (H filtered at cutoff CUT)\r\n    # ; \r\n    # ; \r\n    # ; @uses exist\r\n    # ; \r\n    # ; @author Renaud DUSSURGET, LEGOS/CTOH\r\n    # ; @history Created Jan. 2010 by R.DUSSURGET from loess.c develloped by Mog2d team<br />\r\n    # ;          May 2010 : Take NaNs into account for computation<br />\r\n    # ;                     Checked the filters formulation (Schlax and Chelton, 1992) <br /><br />\r\n    # ;\r\n    # ;  LEGACY :<br />\r\n    # ;  void dloess1d_irregular(int n, double l_c, double *h, double *x, double mask,double *lf,int *rstatus)<br /><br /> \r\n    # ;  \r\n    # ;  ./varReduction.cpp:          dloess1d_irregular(n,cut,h,t,(double) satData.mask,lf,&status);<br />\r\n    # ;  ./functions.extraction.cpp:  dloess1d_irregular(n,cut,h2,x,mask,lf,&status);<br /><br />\r\n    # ;  \r\n    # ;  rq: n-> nb points dans s\ufffdrie<br />\r\n    # ;  l_c -> cut<br />\r\n    # ;  *h -> sla<br />\r\n    # ;  *x -> dimensional array<br />\r\n    # ;  mask -> valeur du masque<br />\r\n    # ;  *lf -> partie basse freq<br />\r\n    # ;  *status -> retour<br />\r\n    # ;-\r\n    #===========================================================================\r\n    \"\"\"\r\n          \r\n    n=np.size(h)\r\n\r\n    #If masked_array --> Get data and replace masked values by NaNs\r\n    if isinstance(h,np.ma.masked_array): h=mask2NaN(h)\r\n    else : h=np.ma.masked_array(h,mask=np.zeros(n,dtype=bool))\r\n\r\n    #Start filtering if there are more than 1 point\r\n    if n == 1 : lf = h[0]\r\n    else : pass\r\n    \r\n    #Get the half-width of filter window\r\n    l_c=cut/2.0          \r\n    \r\n    #Initiate weights and outputs\r\n    w=np.zeros(n)\r\n    lf = np.repeat(np.NaN,n)\r\n    \r\n    #Get valid points in serie\r\n    flag = ~np.isnan(h)\r\n    fcnt = flag.sum()\r\n    fnt = np.arange(n).compress(flag)\r\n    \r\n    x = np.ma.masked_array(x,mask=(np.isnan(h) + h.mask) )\r\n#        WHERE(FINITE(h),fcnt)\r\n\r\n    #Vectorized form\r\n    q = np.reshape(np.repeat(x,n),(n,n))\r\n    q = (np.abs(q - q.transpose())/l_c).reshape(n*n)\r\n    \r\n    s = (1.0 - q*q*q)\r\n    \r\n#    outOfFilter_flag = q > 1.0\r\n    outOfFilter_flag = np.greater(q,1)\r\n    outCnt = np.nansum(outOfFilter_flag)\r\n    outOfFilter = np.arange(n*n).compress(outOfFilter_flag)\r\n    if (outCnt > 0) :\r\n        s[outOfFilter]=0.0\r\n        s.mask[outOfFilter]=True\r\n    \r\n    w=(s*s*s).reshape((n,n))  \r\n    sumvar=np.nansum(w,1)\r\n\r\n    #Compute current height (heights times weigths, divided by sum of weights)\r\n    try :\r\n        lf=np.nansum(w*np.repeat(h,n).reshape((n,n)),0)/sumvar\r\n    except (ValueError):\r\n        lf=np.nansum(w*np.repeat(h,n).reshape((n,n)),0)/sumvar #Retry\r\n\r\n    return lf"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loess_inline(h,x,cut,nan=True):\r\n    \r\n    n=np.size(h)\r\n\r\n    #Start filtering if there are more than 1 point\r\n    if n == 1 : lf = h[0]\r\n    else : pass\r\n    \r\n    #Get the half-width of filter window\r\n    l_c=cut/2.0          \r\n    \r\n    #Initiate weights and outputs\r\n    w=np.zeros(n)\r\n    lf = np.repeat(np.NaN,n)\r\n    \r\n    #Get valid points in serie\r\n    flag = ~np.isnan(h)\r\n    fcnt = flag.sum()\r\n    fnt = np.arange(n).compress(flag)\r\n#        WHERE(FINITE(h),fcnt)\r\n\r\n    #Loop from 1st to last valid point\r\n    for i in fnt :\r\n\r\n        icur=i\r\n      \r\n        #Get Q (distance from central point divided by half-window width)\r\n        q=(np.abs((x-x[icur])/l_c))\r\n            \r\n        #Compute S from Q\ufffd\r\n        s = (1.0 - q*q*q)\r\n        \r\n     \r\n        #Set all values out of filter window to 0\r\n        outOfFilter_flag = q > 1.0\r\n        outCnt = outOfFilter_flag.sum() \r\n        outOfFilter = np.arange(n).compress(outOfFilter_flag)\r\n        if (outCnt > 0) : s[outOfFilter]=0.0\r\n      \r\n        #Compute weights (S\ufffd - Tricube)\r\n        w=s*s*s  \r\n        sumvar=np.nansum(w)\r\n\r\n        #Compute current height (heights times weigths, divided by sum of weights)\r\n        lf[icur]=np.nansum(w*h)/sumvar\r\n\r\n    return lf", "response": "This is a raw inline version of the loess filter function."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_size_all(self):\n        result = self.rpc_srv.get_all_account(self.token)\n        print \"debug: %s\" % result\n        for it in result:\n            size = getFolderSize(it[\"path\"])\n            result = self.rpc_srv.set_account_size(self.token, it[\"id\"], size)", "response": "Check size of all user in the server and update data on the server"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses the results from episode processing.", "response": "def process(self, data):\n        \"\"\"Process the results from episode processing.\n\n        :param list data: result instances\n        \"\"\"\n        for res in data:\n            try:\n                cache.dbapi().save(res)\n            except Exception:\n                LOG.exception('failed to cache result: %s', res.status)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread in a Tarquin txt results file and returns a dict of the information", "response": "def read_output(filename):\n    \"\"\"\n    Reads in a Tarquin txt results file and returns a dict of the information\n\n    :param filename: The filename to read from\n    :return:\n    \"\"\"\n    with open(filename) as fin:\n        data = fin.read()\n\n        metabolite_fits = {}\n\n        sections = data.split(\"\\n\\n\")\n\n        # first section is the metabolite concentrations\n        metabolite_lines = sections[0].splitlines()[2:]\n        for line in metabolite_lines:\n            name, concentration, pc_sd, sd = line.split()\n            metabolite_fits[name] = {\n                \"concentration\": concentration,\n                \"sd\": pc_sd,\n            }\n\n        return {\n            \"metabolite_fits\": metabolite_fits\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstoring the given dict of content at uid. Nothing returned.", "response": "def _store(self, uid, content, data=None):\n        \"\"\"Store the given dict of content at uid. Nothing returned.\"\"\"\n        doc = dict(uid=uid)\n        if data:\n            gfs = gridfs.GridFS(self.db)\n            id = gfs.put(data, encoding='utf-8')\n            doc.update(data_id=id)\n        doc.update(content)\n        self.db.pastes.insert_one(doc)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd the nick & uid to the log for a given time and order. No return.", "response": "def _storeLog(self, nick, time, uid):\n        \"\"\"Adds the nick & uid to the log for a given time/order. No return.\"\"\"\n        query = dict(uid=uid)\n        update = {'$set': dict(nick=nick, time=time)}\n        self.db.pastes.update(query, update)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving the contents of the paste including the raw data.", "response": "def _retrieve(self, uid):\n        \"\"\"Return a dict with the contents of the paste, including the raw\n        data, if any, as the key 'data'. Must pass in uid, not shortid.\"\"\"\n        query = dict(uid=uid)\n        doc = self.db.pastes.find_one(query)\n        if 'data_id' in doc:\n            data_id = doc.pop('data_id')\n            gfs = gridfs.GridFS(self.db)\n            doc.update(data=gfs.get(data_id).read())\n        return doc"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lookup(self, nick):\n        query = dict(nick=nick)\n        order = [('time', pymongo.DESCENDING)]\n        recs = self.db.pastes.find(query).sort(order).limit(1)\n        try:\n            return next(recs)['uid']\n        except StopIteration:\n            pass", "response": "Looks for the most recent paste by a given nick. Returns the uid or None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getLinks(self, laneID, extended=False):\n        complete_data = self._getUniversal(tc.LANE_LINKS, laneID)\n        if extended:\n            return complete_data\n        else:\n            # for downward compatibility\n            return [tuple(d[:4]) for d in complete_data]", "response": "getLinks - Returns a list of tuples containing id of successor lane together with priority open and foe for each link."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setAllowed(self, laneID, allowedClasses):\n        if isinstance(allowedClasses, str):\n            allowedClasses = [allowedClasses]\n        self._connection._beginMessage(tc.CMD_SET_LANE_VARIABLE, tc.LANE_ALLOWED, laneID,\n                                       1 + 4 + sum(map(len, allowedClasses)) + 4 * len(allowedClasses))\n        self._connection._packStringList(allowedClasses)\n        self._connection._sendExact()", "response": "Sets the list of allowed vehicle classes for the specified lane."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the list of disallowed vehicle classes.", "response": "def setDisallowed(self, laneID, disallowedClasses):\n        \"\"\"setDisallowed(string, list) -> None\n\n        Sets a list of disallowed vehicle classes.\n        \"\"\"\n        if isinstance(disallowedClasses, str):\n            disallowedClasses = [disallowedClasses]\n        self._connection._beginMessage(tc.CMD_SET_LANE_VARIABLE, tc.LANE_DISALLOWED, laneID,\n                                       1 + 4 + sum(map(len, disallowedClasses)) + 4 * len(disallowedClasses))\n        self._connection._packStringList(disallowedClasses)\n        self._connection._sendExact()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setMaxSpeed(self, laneID, speed):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_LANE_VARIABLE, tc.VAR_MAXSPEED, laneID, speed)", "response": "Sets the maximum allowed speed on the specified lane in m / s."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setLength(self, laneID, length):\n        self._connection._sendDoubleCmd(\n            tc.CMD_SET_LANE_VARIABLE, tc.VAR_LENGTH, laneID, length)", "response": "Sets the length of the specified lane in the current resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the state of the object.", "response": "def state(self, value):\n        \"\"\"\n        Setter for **self.__state** attribute.\n\n        :param value: Attribute value.\n        :type value: bool\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is bool, \"'{0}' attribute: '{1}' type is not 'bool'!\".format(\"state\", value)\n        self.__state = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the colors attribute.", "response": "def colors(self, value):\n        \"\"\"\n        Setter for **self.__colors** attribute.\n\n        :param value: Attribute value.\n        :type value: tuple\n        \"\"\"\n        if value is not None:\n            assert type(value) is tuple, \"'{0}' attribute: '{1}' type is not 'tuple'!\".format(\"colors\", value)\n            assert len(value) == 2, \"'{0}' attribute: '{1}' length should be '2'!\".format(\"colors\", value)\n            for index in range(len(value)):\n                assert type(\n                    value[index]) is QColor, \"'{0}' attribute element '{1}': '{2}' type is not 'QColor'!\".format(\n                    \"colors\", index, value)\n        self.__colors = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the labels of the object.", "response": "def labels(self, value):\n        \"\"\"\n        Setter for **self.__labels** attribute.\n\n        :param value: Attribute value.\n        :type value: tuple\n        \"\"\"\n        if value is not None:\n            assert type(value) is tuple, \"'{0}' attribute: '{1}' type is not 'tuple'!\".format(\"labels\", value)\n            assert len(value) == 2, \"'{0}' attribute: '{1}' length should be '2'!\".format(\"labels\", value)\n            for index in range(len(value)):\n                assert type(value[index]) is unicode, \\\n                    \"'{0}' attribute element '{1}': '{2}' type is not 'unicode'!\".format(\"labels\", index, value)\n        self.__labels = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the variable button true state.", "response": "def __set_true_state(self):\n        \"\"\"\n        Sets the variable button true state.\n        \"\"\"\n\n        LOGGER.debug(\"> Setting variable QPushButton() to 'True' state.\")\n        self.__state = True\n\n        palette = QPalette()\n        palette.setColor(QPalette.Button, foundations.common.get_first_item(self.__colors))\n        self.setPalette(palette)\n\n        self.setChecked(True)\n        self.setText(foundations.common.get_first_item(self.__labels))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __set_false_state(self):\n\n        LOGGER.debug(\"> Setting variable QPushButton() to 'False' state.\")\n\n        self.__state = False\n\n        palette = QPalette()\n        palette.setColor(QPalette.Button, self.__colors[1])\n        self.setPalette(palette)\n\n        self.setChecked(False)\n        self.setText(self.__labels[1])", "response": "Sets the variable QPushButton true state."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a decimal number to a money formatted string.", "response": "def moneyfmt(value, places=2, curr='', sep=',', dp='.',\n             pos='', neg='-', trailneg=''):\n    \"\"\"Convert Decimal to a money formatted string.\n\n    places:  required number of places after the decimal point\n    curr:    optional currency symbol before the sign (may be blank)\n    sep:     optional grouping separator (comma, period, space, or blank)\n    dp:      decimal point indicator (comma or period)\n             only specify as blank when places is zero\n    pos:     optional sign for positive numbers: '+', space or blank\n    neg:     optional sign for negative numbers: '-', '(', space or blank\n    trailneg:optional trailing minus indicator:  '-', ')', space or blank\n\n    >>> d = Decimal('-1234567.8901')\n    >>> moneyfmt(d, curr='$')\n    '-$1,234,567.89'\n    >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')\n    '1.234.568-'\n    >>> moneyfmt(d, curr='$', neg='(', trailneg=')')\n    '($1,234,567.89)'\n    >>> moneyfmt(Decimal(123456789), sep=' ')\n    '123 456 789.00'\n    >>> moneyfmt(Decimal('-0.02'), neg='<', trailneg='>')\n    '<0.02>'\n\n    \"\"\"\n    if not isinstance(value, Decimal):\n        if isinstance(value, float):\n            value = str(value)\n        value = Decimal(value)\n    q = Decimal(10) ** -places      # 2 places --> '0.01'\n    sign, digits, exp = value.quantize(q).as_tuple()\n    result = []\n    digits = list(map(str, digits))\n    build, next = result.append, digits.pop\n    if sign:\n        build(trailneg)\n    for i in range(places):\n        build(next() if digits else '0')\n    if places > 0:\n        build(dp)\n    if not digits:\n        build('0')\n    i = 0\n    while digits:\n        build(next())\n        i += 1\n        if i == 3 and digits:\n            i = 0\n            build(sep)\n    build(curr)\n    build(neg if sign else pos)\n    return ''.join(reversed(result))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_symbols_pair_complete(editor, symbol):\n\n    symbols_pairs = get_editor_capability(editor, \"symbols_pairs\")\n    if not symbols_pairs:\n        return\n\n    cursor = editor.textCursor()\n    cursor.movePosition(QTextCursor.StartOfLine, QTextCursor.MoveAnchor)\n    cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)\n    selected_text = foundations.strings.to_string(cursor.selectedText())\n    if symbol == symbols_pairs[symbol]:\n        return selected_text.count(symbol) % 2 == 0\n    else:\n        return selected_text.count(symbol) == selected_text.count(symbols_pairs[symbol])", "response": "Returns if the symbols pair is complete on current editor line."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming the completion on given editor.", "response": "def perform_completion(editor):\n    \"\"\"\n    Performs the completion on given editor.\n\n    :param editor: Document editor.\n    :type editor: QWidget\n    :return: Method success.\n    :rtype: bool\n    \"\"\"\n\n    completion_prefix = editor.get_partial_word_under_cursor()\n    if not completion_prefix:\n        return\n\n    words = editor.get_words()\n    completion_prefix in words and words.remove(completion_prefix)\n    editor.completer.update_model(words)\n    editor.completer.setCompletionPrefix(completion_prefix)\n    if editor.completer.completionCount() == 1:\n        completion = editor.completer.completionModel().data(\n            editor.completer.completionModel().index(0, 0)).toString()\n        cursor = editor.textCursor()\n        cursor.insertText(completion[len(completion_prefix):])\n        editor.setTextCursor(cursor)\n    else:\n        popup = editor.completer.popup()\n        popup.setCurrentIndex(editor.completer.completionModel().index(0, 0))\n\n        completer_rectangle = editor.cursorRect()\n        hasattr(editor, \"margin_area_LinesNumbers_widget\") and completer_rectangle.moveTo(\n            completer_rectangle.topLeft().x() + editor.margin_area_LinesNumbers_widget.get_width(),\n            completer_rectangle.topLeft().y())\n        completer_rectangle.setWidth(editor.completer.popup().sizeHintForColumn(0) +\n                                     editor.completer.popup().verticalScrollBar().sizeHint().width())\n        editor.completer.complete(completer_rectangle)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nimplements indentation pre event input accelerators.", "response": "def indentation_pre_event_input_accelerators(editor, event):\n    \"\"\"\n    Implements indentation pre event input accelerators.\n\n    :param editor: Document editor.\n    :type editor: QWidget\n    :param event: Event being handled.\n    :type event: QEvent\n    :return: Process event.\n    :rtype: bool\n    \"\"\"\n\n    process_event = True\n    if not hasattr(editor, \"indent\"):\n        return process_event\n\n    if event.key() == Qt.Key_Tab:\n        process_event = editor.indent() and False\n    elif event.key() == Qt.Key_Backtab:\n        process_event = editor.unindent() and False\n    return process_event"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef indentation_post_event_input_accelerators(editor, event):\n\n    if event.key() in (Qt.Key_Enter, Qt.Key_Return):\n        cursor = editor.textCursor()\n        block = cursor.block().previous()\n        if block.isValid():\n            indent = match = re.match(r\"(\\s*)\", foundations.strings.to_string(block.text())).group(1)\n            cursor.insertText(indent)\n\n            indentation_symbols = get_editor_capability(editor, \"indentation_symbols\")\n            if not indentation_symbols:\n                return True\n\n            if not block.text():\n                return True\n\n            if not foundations.strings.to_string(block.text())[-1] in indentation_symbols:\n                return True\n\n            symbols_pairs = get_editor_capability(editor, \"symbols_pairs\")\n            if not symbols_pairs:\n                return True\n\n            cursor.insertText(editor.indent_marker)\n\n            position = cursor.position()\n            cursor.movePosition(QTextCursor.PreviousBlock, QTextCursor.MoveAnchor)\n            cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.MoveAnchor)\n            cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.KeepAnchor)\n            previous_character = foundations.strings.to_string(cursor.selectedText())\n            cursor.setPosition(position)\n            next_character = editor.get_next_character()\n            if previous_character in symbols_pairs:\n                if next_character in symbols_pairs.values():\n                    cursor.insertBlock()\n                    cursor.insertText(match)\n                    cursor.movePosition(QTextCursor.PreviousBlock, QTextCursor.MoveAnchor)\n                    cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.MoveAnchor)\n                    editor.setTextCursor(cursor)\n    return True", "response": "Implements indentation post event input accelerators."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef completion_pre_event_input_accelerators(editor, event):\n\n    process_event = True\n\n    if editor.completer:\n        # TODO: Investigate the slowdown on popup visibility test.\n        if editor.completer.popup().isVisible():\n            if event.key() in (Qt.Key_Enter, Qt.Key_Return, Qt.Key_Escape, Qt.Key_Tab, Qt.Key_Backtab):\n                event.ignore()\n                process_event = False\n                return process_event\n\n    if event.modifiers() in (Qt.ControlModifier, Qt.MetaModifier) and event.key() == Qt.Key_Space:\n        process_event = False\n        if not editor.completer:\n            return process_event\n\n        perform_completion(editor)\n\n    return process_event", "response": "Implements completion pre event input accelerators."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nimplementing completion post event input accelerators.", "response": "def completion_post_event_input_accelerators(editor, event):\n    \"\"\"\n    Implements completion post event input accelerators.\n\n    :param editor: Document editor.\n    :type editor: QWidget\n    :param event: Event being handled.\n    :type event: QEvent\n    :return: Process event.\n    :rtype: bool\n    \"\"\"\n\n    if editor.completer:\n        if editor.completer.popup().isVisible():\n            perform_completion(editor)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nimplement symbols expanding pre event input accelerators.", "response": "def symbols_expanding_pre_event_input_accelerators(editor, event):\n    \"\"\"\n    Implements symbols expanding pre event input accelerators.\n\n    :param editor: Document editor.\n    :type editor: QWidget\n    :param event: Event being handled.\n    :type event: QEvent\n    :return: Process event.\n    :rtype: bool\n    \"\"\"\n\n    process_event = True\n\n    symbols_pairs = get_editor_capability(editor, \"symbols_pairs\")\n    if not symbols_pairs:\n        return process_event\n\n    text = foundations.strings.to_string(event.text())\n    if text in symbols_pairs:\n        cursor = editor.textCursor()\n        if not is_symbols_pair_complete(editor, text):\n            cursor.insertText(event.text())\n        else:\n            if not cursor.hasSelection():\n                cursor.insertText(event.text())\n                # TODO: Provide an efficient code alternative.\n                # position = cursor.position()\n                # cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)\n                # selected_text = foundations.strings.to_string(cursor.selectedText())\n                # cursor.setPosition(position)\n                # if not selected_text.strip():\n                cursor.insertText(symbols_pairs[text])\n                cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor)\n            else:\n                selected_text = cursor.selectedText()\n                cursor.insertText(event.text())\n                cursor.insertText(selected_text)\n                cursor.insertText(symbols_pairs[text])\n        editor.setTextCursor(cursor)\n        process_event = False\n\n    if event.key() in (Qt.Key_Backspace,):\n        cursor = editor.textCursor()\n        cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor)\n        left_text = cursor.selectedText()\n        foundations.common.repeat(lambda: cursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor), 2)\n        right_text = cursor.selectedText()\n\n        if symbols_pairs.get(foundations.strings.to_string(left_text)) == foundations.strings.to_string(right_text):\n            cursor.deleteChar()\n    return process_event"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef switch(self, val=None):\n        if self._armed:\n            if val is None:\n                val = not self._switched\n            self._switched = val\n            self._armed = False\n            return True\n        else:\n            return False", "response": "Sets the state of the switch."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_dir(input_dir,input_ext,func):\n    '''reads all files with extension input_ext\n       in a directory input_dir and apply function func\n       to their contents'''\n    import os\n    for dirpath, dnames, fnames in os.walk(input_dir):\n        for fname in fnames:\n            if not dirpath.endswith(os.sep):\n                dirpath = dirpath + os.sep\n            if fname.endswith(input_ext):\n                func(read_file(dirpath + fname))", "response": "reads all files with extension input_ext in a directory input_dir and applies function functo their contents"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse key value string into dict", "response": "def parse(self, kv):\n        \"\"\"\n        Parses key value string into dict\n\n        Examples:\n            >> parser.parse('test1.test2=value')\n            {'test1': {'test2': 'value'}}\n\n            >> parser.parse('test=value')\n            {'test': 'value'}\n        \"\"\"\n        key, val = kv.split(self.kv_sep, 1)\n        keys = key.split(self.keys_sep)\n        for k in reversed(keys):\n            val = {k: val}\n        return val"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the timestamps of a node.", "response": "def update_timestampable_model(sender, instance, *args, **kwargs):\n    '''\n    Using signals guarantees that timestamps are set no matter what:\n    loading fixtures, bulk inserts, bulk updates, etc.\n    Indeed, the `save()` method is *not* called when using fixtures.\n    '''\n    if not isinstance(instance, TimestampableModel):\n        return\n    if not instance.pk:\n        instance.created_at = now()\n    instance.updated_at = now()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setModel(self, model):\n\n        if not model:\n            return\n\n        LOGGER.debug(\"> Setting '{0}' model.\".format(model))\n\n        umbra.ui.views.Abstract_QTreeView.setModel(self, model)\n\n        # Signals / Slots.\n        self.model().modelAboutToBeReset.connect(self.__model__modelAboutToBeReset)\n        self.model().modelReset.connect(self.__model__modelReset)", "response": "Sets the model of the tree view."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the Widget ui.", "response": "def __initialize_ui(self):\n        \"\"\"\n        Initializes the Widget ui.\n        \"\"\"\n\n        self.setAutoScroll(False)\n        self.setDragDropMode(QAbstractItemView.NoDragDrop)\n        self.setEditTriggers(QAbstractItemView.NoEditTriggers)\n        self.setIndentation(self.__tree_view_indentation)\n        self.setSelectionMode(QAbstractItemView.ExtendedSelection)\n\n        self.setSortingEnabled(True)\n        self.sortByColumn(0, Qt.AscendingOrder)\n\n        self.__set_default_ui_state()\n\n        # Signals / Slots.\n        self.model().modelReset.connect(self.__set_default_ui_state)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the path to the file that should be used for uploading a new file.", "response": "def auto_cleaned_path(instance, filename: str) -> str:\n    \"\"\"\n    Gets upload path in this format: {MODEL_NAME}/{SAFE_UPLOADED_FILENAME}{SUFFIX}.\n\n    :param instance: Instance of model or model class.\n    :param filename: Uploaded file name.\n    :return: Target upload path.\n    \"\"\"\n    stem, suffix = parse_filename(filename)\n    base_dir = get_base_dir_from_object(instance)\n    target_filename = get_safe_path_name(stem)\n\n    return os.path.join(base_dir, \"{target_filename}{suffix}\".format(target_filename=target_filename,\n                                                                     suffix=suffix))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef auto_cleaned_path_uuid4(instance, filename: str) -> str:\n    stem, suffix = parse_filename(filename)\n    base_dir = get_base_dir_from_object(instance)\n    target_filename = get_safe_path_name(stem)\n    rand_uuid = uuid.uuid4()\n\n    return os.path.join(base_dir, \"{target_filename}{SEPARATOR}{rand_uuid}{suffix}\".format(target_filename=target_filename,\n                                                                                           SEPARATOR=SEPARATOR,\n                                                                                           rand_uuid=rand_uuid,\n                                                                                           suffix=suffix))", "response": "Generates a path to upload a file with uuid4."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef auto_cleaned_path_stripped_uuid4(instance, filename: str) -> str:\n    _, suffix = parse_filename(filename)\n    base_dir = get_base_dir_from_object(instance)\n    rand_uuid = uuid.uuid4()\n\n    return os.path.join(base_dir, \"{rand_uuid}{suffix}\".format(rand_uuid=rand_uuid,\n                                                               suffix=suffix))", "response": "Returns the path to the file with UUID4 suffix stripped."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ssh(container, cmd='', user='root', password='root'):\n    '''\n    SSH into a running container, using the host as a jump host. This requires\n    the container to have a running sshd process.\n\n    Args:\n        * container: Container name or ID\n        * cmd='': Command to run in the container\n        * user='root': SSH username\n        * password='root': SSH password\n    '''\n    ip = get_ip(container)\n    ssh_cmd = 'sshpass -p \\'%s\\' ssh -A -t -o StrictHostKeyChecking=no \\'%s\\'@%s' % (password, user, ip)\n    local('ssh -A -t -o StrictHostKeyChecking=no -i \"%s\" %s@%s %s %s' % (\n        env.key_filename, env.user, env.host, ssh_cmd, cmd))", "response": "SSH into a running container using the specified command."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints a table of all running containers on a host", "response": "def ps():\n    '''\n    Print a table of all running containers on a host\n    '''\n    containers = get_containers()\n    containers = [pretty_container(c) for c in containers]\n    print_table(containers, ['name', 'ip', 'ports', 'created', 'image'], sort='name')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprepare a vanilla server by installing docker curl and sshpass.", "response": "def setup(docker_mount=None, force=False):\n    '''\n    Prepare a vanilla server by installing docker, curl, and sshpass. If a file called ``dot_dockercfg``\n    exists in the current working directory, it is uploaded as ``~/.dockercfg``.\n\n    Args:\n        * docker_mount=None: Partition that will be mounted as /var/lib/docker\n    '''\n\n    if not is_ubuntu() and not is_boot2docker():\n        raise Exception('Head In The Clouds Docker is only supported on Ubuntu')\n\n    # a bit hacky\n    if os.path.exists('dot_dockercfg') and not fabric.contrib.files.exists('~/.dockercfg'):\n        put('dot_dockercfg', '~/.dockercfg')\n\n    if not fabric.contrib.files.exists('~/.ssh/id_rsa'):\n        fab.run('ssh-keygen -t rsa -N \"\" -f ~/.ssh/id_rsa')\n\n    if docker_is_installed() and not force:\n        return\n\n    for attempt in range(3):\n        sudo('wget -qO- https://get.docker.io/gpg | apt-key add -')\n        sudo('sh -c \"echo deb http://get.docker.io/ubuntu docker main > /etc/apt/sources.list.d/docker.list\"')\n        with settings(warn_only=True):\n            sudo('apt-get update')\n            failed = sudo('apt-get install -y lxc-docker sshpass curl').failed\n            if not failed:\n                break\n\n    if docker_mount:\n        create_docker_mount(docker_mount)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun a docker container.", "response": "def run(image, name=None, command=None, environment=None, ports=None, volumes=None):\n    '''\n    Run a docker container.\n\n    Args:\n        * image: Docker image to run, e.g. orchardup/redis, quay.io/hello/world\n        * name=None: Container name\n        * command=None: Command to execute\n        * environment: Comma separated environment variables in the format NAME=VALUE\n        * ports=None: Comma separated port specs in the format CONTAINER_PORT[:EXPOSED_PORT][/PROTOCOL]\n        * volumes=None: Comma separated volumes in the format HOST_DIR:CONTAINER_DIR\n\n    Examples:\n        * fab docker.run:orchardup/redis,name=redis,ports=6379\n        * fab docker.run:quay.io/hello/world,name=hello,ports=\"80:8080,1000/udp\",volumes=\"/docker/hello/log:/var/log\"\n        * fab docker.run:andreasjansson/redis,environment=\"MAX_MEMORY=4G,FOO=bar\",ports=6379\n    '''\n\n    if ports and not name:\n        abort('The ports flag currently only works if you specify a container name')\n\n    if ports:\n        ports = [parse_port_spec(p) for p in ports.split(',')]\n    else:\n        ports = None\n    if environment:\n        environment = dict([x.split('=') for x in environment.split(',')])\n    else:\n        environment = None\n    if volumes:\n        volumes = dict([x.split(':') for x in volumes.split(',')])\n    else:\n        volumes = None\n\n    run_container(\n        image=image,\n        name=name,\n        command=command,\n        ports=ports,\n        environment=environment,\n        volumes=volumes,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef kill(container, rm=True):\n    '''\n    Kill a container\n\n    Args:\n        * container: Container name or ID\n        * rm=True: Remove the container or not\n    '''\n    container = get_container(container)\n    if not container:\n        raise Exception('No such container: %s' % container)\n    unbind_all(container['ip']) # legacy, only here for backwards compatibility\n\n    sudo('docker kill %s' % container['name'])\n    if rm:\n        sudo('docker rm %s' % container['name'])", "response": "Kill a container\n\n    Args:\n        * container: Container name or ID\n        * rm=True: Remove the container or not"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tunnel(container, local_port, remote_port=None, gateway_port=None):\n    '''\n    Set up an SSH tunnel into the container, using the host as a gateway host.\n\n    Args:\n        * container: Container name or ID\n        * local_port: Local port\n        * remote_port=None: Port on the Docker container (defaults to local_port)\n        * gateway_port=None: Port on the gateway host (defaults to remote_port)\n    '''\n    if remote_port is None:\n        remote_port = local_port\n    if gateway_port is None:\n        gateway_port = remote_port\n\n    remote_host = get_ip(container)\n\n    command = '''\n        ssh -v\n            -o StrictHostKeyChecking=no\n            -i \"%(key_filename)s\"\n            -L %(local_port)s:localhost:%(gateway_port)s\n            %(gateway_user)s@%(gateway_host)s\n                sshpass -p root\n                    ssh -o StrictHostKeyChecking=no\n                        -L %(gateway_port)s:localhost:%(remote_port)s\n                            root@%(remote_host)s\n    ''' % {\n        'key_filename': env.key_filename,\n        'local_port': local_port,\n        'gateway_port': gateway_port,\n        'gateway_user': env.user,\n        'gateway_host': env.host,\n        'remote_port': remote_port,\n        'remote_host': remote_host,\n    }\n\n    command = command.replace('\\n', '')\n\n    local(command)", "response": "Tunnels a container into a remote host."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef py_scanstring(s, end, encoding=None, strict=True,\n        _b=BACKSLASH, _m=STRINGCHUNK.match):\n    r\"\"\"Scan the string s for a DSON string. End is the index of the\n    character in s after the quote that started the DSON string.\n    Unescapes all valid DSON string escape sequences and raises ValueError\n    on attempt to decode an invalid string. If strict is False then literal\n    control characters are allowed in the string.\n\n    Returns a tuple of the decoded string and the index of the character in s\n    after the end quote.\"\"\"\n    if encoding is None:\n        encoding = DEFAULT_ENCODING\n    chunks = []\n    _append = chunks.append\n    begin = end - 1\n    while 1:\n        chunk = _m(s, end)\n        if chunk is None:\n            raise ValueError(\n                errmsg(\"Unterminated string starting at\", s, begin))\n        end = chunk.end()\n        content, terminator = chunk.groups()\n        # Content is contains zero or more unescaped string characters\n        if content:\n            if not isinstance(content, unicode):\n                content = unicode(content, encoding)\n            _append(content)\n        # Terminator is the end of string, a literal control character,\n        # or a backslash denoting that an escape sequence follows\n        if terminator == '\"':\n            break\n        elif terminator != '\\\\':\n            if strict:\n                #msg = \"Invalid control character %r at\" % (terminator,)\n                msg = \"Invalid control character {0!r} at\".format(terminator)\n                raise ValueError(errmsg(msg, s, end))\n            else:\n                _append(terminator)\n                continue\n        try:\n            esc = s[end]\n        except IndexError:\n            raise ValueError(\n                errmsg(\"Unterminated string starting at\", s, begin))\n        # If not a unicode escape sequence, must be in the lookup table\n        if esc != 'u':\n            try:\n                char = _b[esc]\n            except KeyError:\n                msg = \"Invalid \\\\escape: \" + repr(esc)\n                raise ValueError(errmsg(msg, s, end))\n            end += 1\n        else:\n            # Unicode escape sequence\n            esc = s[end + 1:end + 5]\n            next_end = end + 5\n            if len(esc) != 4:\n                msg = \"Invalid unicode escape\"\n                raise ValueError(errmsg(msg, s, end))\n            uni = int(esc, 16)\n            # Check for surrogate pair on UCS-4 systems\n            if 0xd800 <= uni <= 0xdbff and sys.maxunicode > 65535:\n                msg = \"Invalid unicode surrogate pair\"\n                if not s[end + 5:end + 7] == '\\\\u':\n                    raise ValueError(errmsg(msg, s, end))\n                esc2 = s[end + 7:end + 11]\n                if len(esc2) != 4:\n                    raise ValueError(errmsg(msg, s, end))\n                uni2 = int(esc2, 16)\n                uni = 0x10000 + (((uni - 0xd800) << 10) | (uni2 - 0xdc00))\n                next_end += 6\n            char = unichr(uni)\n            end = next_end\n        # Append the unescaped character\n        _append(char)\n    return u''.join(chunks), end", "response": "r Scans a string s for a DSON string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(self, host, port=25, with_ssl=False):\n        try:\n            dns_rec = self._lookup(host, port)\n            self._connect(dns_rec)\n            if with_ssl:\n                self._wrap_ssl()\n            banner = self._get_banner()\n            self._check_banner(banner)\n        except Exception:\n            exc_type, exc_value, exc_tb = sys.exc_info()\n            self.results['Exception-Type'] = str(exc_type.__name__)\n            self.results['Exception-Value'] = str(exc_value)\n            self.results['Exception-Traceback'] = repr(traceback.format_exc())\n        finally:\n            self._close(with_ssl)", "response": "Executes a single health check against a remote host and port."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\noutputs the results of the run method to the given stream.", "response": "def output(self, stream):\n        \"\"\"Outputs the results of :meth:`.run` to the given stream. The results\n        are presented similarly to HTTP headers, where each line has a key and\n        value, separated by ``: ``. The ``Status`` key will always be available\n        in the output.\n\n        :param stream: The output file to write to.\n        :returns: A return code that would be appropriate to return to the\n                  operating system, e.g. zero means success, non-zero means\n                  failure.\n        :rtype: int\n\n        \"\"\"\n        for key, val in self.results.items():\n            if isinstance(val, basestring):\n                print >> stream, '{0}: {1!s}'.format(key, val)\n            elif isinstance(val, float):\n                print >> stream, '{0}: {1:.5f}'.format(key, val)\n            elif val is None:\n                print >> stream, '{0}: '.format(key)\n            else:\n                print >> stream, '{0}: {1!s}'.format(key, val)\n        if self.results['Status'] == 'OK':\n            return 0\n        else:\n            return 1"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert xml shape string into list of 3d float - tuples.", "response": "def convertShape(shapeString):\n    \"\"\" Convert xml shape string into float tuples.\n\n    This method converts the 2d or 3d shape string from SUMO's xml file\n    into a list containing 3d float-tuples. Non existant z coordinates default\n    to zero. If shapeString is empty, an empty list will be returned.\n    \"\"\"\n\n    cshape = []\n    for pointString in shapeString.split():\n        p = [float(e) for e in pointString.split(\",\")]\n        if len(p) == 2:\n            cshape.append((p[0], p[1], 0.))\n        elif len(p) == 3:\n            cshape.append(tuple(p))\n        else:\n            raise ValueError(\n                'Invalid shape point \"%s\", should be either 2d or 3d' % pointString)\n    return cshape"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_html(self, jdoc, schema, schemas):\n        '''Generates html for a subset of jdoc records\n        describing objects of specific schema'''\n\n        params = {'functions': sorted([j for j in jdoc \\\n                   if (j.schema_name == schema.object_name and j.object_type \\\n                       in ['function', 'procedure', 'trigger'])], \\\n                                      key=lambda x: x.object_name),\n                   'tables': sorted([j for j in jdoc \\\n                   if (j.schema_name == schema.object_name and j.object_type \\\n                       in ['table', 'view', 'materialized view', 'foreign table'])], \\\n                                    key=lambda x: x.object_name),\n                   'schema_name': schema.object_name,\n                   'schemas': sorted(schemas, key=lambda x: x.object_name),\n                   'project': self.project_name,\n                   'title': '{}: schema {}'.format(self.project_name,\n                                                   schema.object_name)}\n        template = self.lookup.get_template('schema.mako')\n        html = template.render_unicode(**params)\n\n        return html", "response": "Generates html for a subset of jdoc records\n        describing objects of specific schema"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate html for an index file", "response": "def generate_index(self, schemas):\n        '''Generates html for an index file'''\n        params = {'schemas': sorted(schemas, key=lambda x: x.object_name),\n                  'project': self.project_name,\n                  'title': '{}: Database schema documentation'\\\n                  .format(self.project_name)}\n        template = self.lookup.get_template('index.mako')\n        html = template.render_unicode(**params)\n        return html"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_files(self, jdoc, output_dir):\n        '''Writes all jdoc records into files.\n        One file per schema plus index file.'''\n\n        #get all distinct schema names from jdoc:\n        schemas = [j for j in jdoc if j.object_type == 'schema']\n        schemas = [j for j in schemas if len([x for x in jdoc if x.object_type != 'schema' and x.schema_name == j.object_name]) > 0]\n        if not os.path.exists(output_dir):\n            os.makedirs(output_dir)\n        try:\n            shutil.copytree(self.template_dir + os.sep + 'styles',\n                            output_dir + os.sep + 'styles')\n        except FileExistsError:\n            None\n        for schema in schemas:\n            with open(output_dir + os.sep + schema.object_name + '.html', 'w') as f:\n                f.write(self.generate_html(jdoc, schema, schemas))\n        with open(output_dir + os.sep + 'index.html', 'w') as f:\n            f.write(self.generate_index(schemas))", "response": "Writes all jdoc records into files."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loose_search(self, asset_manager_id, query='', **kwargs):\n        self.logger.info('Asset Search - Asset Manager: %s', asset_manager_id)\n        url = '{endpoint}/assets/search/{asset_manager_id}'.format(\n            asset_manager_id=asset_manager_id,\n            endpoint=self.endpoint,\n        )\n        params = {'query': query}\n        for k, v in kwargs.items():\n            if not isinstance(v, str) and isinstance(v, Iterable):\n                v = ','.join(str(i) for i in v)\n\n            params[k] = v\n\n        response = self.session.get(url, params=params)\n        if response.ok:\n            data = response.json()\n            assets = [json_to_asset(json_asset) for json_asset in data.get('hits', [])]\n            self.logger.info('Returned %s Assets.', len(assets))\n            return assets\n        else:\n            self.logger.error(response.text)\n            response.raise_for_status()", "response": "Loose search for assets."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear(self, asset_manager_id):\n        self.logger.info('Clear Assets - Asset Manager: %s', asset_manager_id)\n        url = '%s/clear/%s' % (self.endpoint, asset_manager_id)\n        response = self.session.delete(url)\n        if response.ok:\n            count = response.json().get('count', 'Unknown')\n            self.logger.info('Deleted %s Assets.', count)\n            return count\n        else:\n            self.logger.error(response.text)\n            response.raise_for_status()", "response": "This method deletes all the data for an asset_manager_id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsegmenting a text into a list of words.", "response": "def segment(self, text, lower=True, use_stop_words=True, use_speech_tags_filter=False):\n        \"\"\"\u5bf9\u4e00\u6bb5\u6587\u672c\u8fdb\u884c\u5206\u8bcd\uff0c\u8fd4\u56delist\u7c7b\u578b\u7684\u5206\u8bcd\u7ed3\u679c\n\n        Keyword arguments:\n        lower                  -- \u662f\u5426\u5c06\u5355\u8bcd\u5c0f\u5199\uff08\u9488\u5bf9\u82f1\u6587\uff09\n        use_stop_words         -- \u82e5\u4e3aTrue\uff0c\u5219\u5229\u7528\u505c\u6b62\u8bcd\u96c6\u5408\u6765\u8fc7\u6ee4\uff08\u53bb\u6389\u505c\u6b62\u8bcd\uff09\n        use_speech_tags_filter -- \u662f\u5426\u57fa\u4e8e\u8bcd\u6027\u8fdb\u884c\u8fc7\u6ee4\u3002\u82e5\u4e3aTrue\uff0c\u5219\u4f7f\u7528self.default_speech_tag_filter\u8fc7\u6ee4\u3002\u5426\u5219\uff0c\u4e0d\u8fc7\u6ee4\u3002\n        \"\"\"\n        jieba_result = cut_for_search(text)\n        jieba_result = [w for w in jieba_result]\n\n        # \u53bb\u9664\u7279\u6b8a\u7b26\u53f7\n        word_list = [w.strip() for w in jieba_result]\n        word_list = [word for word in word_list if len(word) > 0]\n\n        if use_speech_tags_filter == False:\n            jieba_result = [w for w in jieba_result]\n\n        if lower:\n            word_list = [word.lower() for word in word_list]\n\n        if use_stop_words:\n            word_list = [word.strip() for word in word_list if word.strip() not in self.stop_words]\n\n        return word_list"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsegment a list of sentences into a list of base classes", "response": "def segment_sentences(self, sentences, lower=True, use_stop_words=True, use_speech_tags_filter=False):\n        \"\"\"\u5c06\u5217\u8868sequences\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20/\u53e5\u5b50\u8f6c\u6362\u4e3a\u7531\u5355\u8bcd\u6784\u6210\u7684\u5217\u8868\u3002\n        use_speech_tags_filter\n        sequences -- \u5217\u8868\uff0c\u6bcf\u4e2a\u5143\u7d20\u662f\u4e00\u4e2a\u53e5\u5b50\uff08\u5b57\u7b26\u4e32\u7c7b\u578b\uff09\n        \"\"\"\n\n        res = []\n        for sentence in sentences:\n            res.append(self.segment(text=sentence,\n                                    lower=lower,\n                                    use_stop_words=use_stop_words,\n                                    use_speech_tags_filter=use_speech_tags_filter))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef positions_by_asset(self):\n        positions = None\n        for book in self.books():\n            book_positions = book.positions_by_asset()\n            # unique positions\n            positions.update({position.asset_id: position for position in book_positions\n                              if position.asset_id not in positions.keys()})\n            # Existing positions\n            keys = [position.asset_id for position in book_positions if position.asset_id in positions.key()]\n            for key in keys:\n                positions.get(key).quantity += book_positions.get(key).quantity\n        return positions", "response": "A dictionary of Position objects keyed by asset_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndrops fields from a dictionary where value is None.", "response": "def _drop_none_values(dictionary: Dict) -> Dict:\n    \"\"\"Drops fields from a dictionary where value is None.\n\n    >>> _drop_none_values({'greeting': 'hello', 'name': None})\n    {'greeting': 'hello'}\n    \"\"\"\n    return {key: value for key, value in dictionary.items() if value is not None}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload configuration from one or more YAML files.", "response": "def load(*files):\n    \"\"\"\n    Loads configuration from one or more files by merging right to left.\n\n    :Parameters:\n        *files : `file-like`\n            A YAML file to read.\n\n    :Returns:\n        `dict` : the configuration document\n    \"\"\"\n    if len(files) == 0:\n        raise errors.ConfigError(\"No config files provided.\")\n    doc = merge(*(yaml.safe_load(f) for f in files))\n    return propagate_defaults(doc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts an Element into an internal dictionary ( not JSON!).", "response": "def elem_to_internal(elem, strip_ns=1, strip=1):\n    \"\"\"Convert an Element into an internal dictionary (not JSON!).\"\"\"\n\n    d = {}\n    elem_tag = elem.tag\n    if strip_ns:\n        elem_tag = strip_tag(elem.tag)\n    else:\n        for key, value in list(elem.attrib.items()):\n            d['@' + key] = value\n\n    # loop over subelements to merge them\n    for subelem in elem:\n        v = elem_to_internal(subelem, strip_ns=strip_ns, strip=strip)\n\n        tag = subelem.tag\n        if strip_ns:\n            tag = strip_tag(subelem.tag)\n\n        value = v[tag]\n\n        try:\n            # add to existing list for this tag\n            d[tag].append(value)\n        except AttributeError:\n            # turn existing entry into a list\n            d[tag] = [d[tag], value]\n        except KeyError:\n            # add a new non-list entry\n            d[tag] = value\n    text = elem.text\n    tail = elem.tail\n    if strip:\n        # ignore leading and trailing whitespace\n        if text:\n            text = text.strip()\n        if tail:\n            tail = tail.strip()\n\n    if tail:\n        d['#tail'] = tail\n\n    if d:\n        # use #text element if other attributes exist\n        if text:\n            d[\"#text\"] = text\n    else:\n        # text is the value if no attributes\n        d = text or None\n    return {elem_tag: d}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert an internal dictionary into an Element.", "response": "def internal_to_elem(pfsh, factory=ET.Element):\n\n    \"\"\"Convert an internal dictionary (not JSON!) into an Element.\n\n    Whatever Element implementation we could import will be\n    used by default; if you want to use something else, pass the\n    Element class as the factory parameter.\n    \"\"\"\n\n    attribs = {}\n    text = None\n    tail = None\n    sublist = []\n    tag = list(pfsh.keys())\n    if len(tag) != 1:\n        raise ValueError(\"Illegal structure with multiple tags: %s\" % tag)\n    tag = tag[0]\n    value = pfsh[tag]\n    if isinstance(value, dict):\n        for k, v in list(value.items()):\n            if k[:1] == \"@\":\n                attribs[k[1:]] = v\n            elif k == \"#text\":\n                text = v\n            elif k == \"#tail\":\n                tail = v\n            elif isinstance(v, list):\n                for v2 in v:\n                    sublist.append(internal_to_elem({k: v2}, factory=factory))\n            else:\n                sublist.append(internal_to_elem({k: v}, factory=factory))\n    else:\n        text = value\n    e = factory(tag, attribs)\n    for sub in sublist:\n        e.append(sub)\n    e.text = text\n    e.tail = tail\n    return e"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert an ElementTree or Element into a JSON string.", "response": "def elem2json(elem, options, strip_ns=1, strip=1):\n\n    \"\"\"Convert an ElementTree or Element into a JSON string.\"\"\"\n\n    if hasattr(elem, 'getroot'):\n        elem = elem.getroot()\n\n    if options.pretty:\n        return json.dumps(elem_to_internal(elem, strip_ns=strip_ns, strip=strip), sort_keys=True, indent=4, separators=(',', ': '))\n    else:\n        return json.dumps(elem_to_internal(elem, strip_ns=strip_ns, strip=strip))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a JSON string into an Element.", "response": "def json2elem(json_data, factory=ET.Element):\n\n    \"\"\"Convert a JSON string into an Element.\n\n    Whatever Element implementation we could import will be used by\n    default; if you want to use something else, pass the Element class\n    as the factory parameter.\n    \"\"\"\n\n    return internal_to_elem(json.loads(json_data), factory)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef xml2json(xmlstring, options, strip_ns=1, strip=1):\n\n    \"\"\"Convert an XML string into a JSON string.\"\"\"\n\n    elem = ET.fromstring(xmlstring)\n    return elem2json(elem, options, strip_ns=strip_ns, strip=strip)", "response": "Convert an XML string into a JSON string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef json2xml(json_data, factory=ET.Element):\n\n    \"\"\"Convert a JSON string into an XML string.\n\n    Whatever Element implementation we could import will be used by\n    default; if you want to use something else, pass the Element class\n    as the factory parameter.\n    \"\"\"\n    if not isinstance(json_data, dict):\n        json_data = json.loads(json_data)\n\n    elem = internal_to_elem(json_data, factory)\n    return ET.tostring(elem)", "response": "Convert a JSON string into an XML string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadvances to the specified checkpoint.", "response": "def advance_to_checkpoint(self, checkpoint):\n        \"\"\"\n        Advance to the specified checkpoint, passing all preceding checkpoints including the specified checkpoint.\n        \"\"\"\n        if checkpoint in self._checkpoints:\n            for cp in self._checkpoints:\n                self.insert(cp)\n                if cp == checkpoint:\n                    return cp\n        else:\n            raise InvalidCheckpointError(checkpoint)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the proof type of the cisco key.", "response": "def proof_type(self, proof_type):\n        \"\"\"\n        :param proof_type:\n        :return:\n        \"\"\"\n        if proof_type in CRYPTOCURRENCY_PROOF_TYPES:\n            self._proof_type = proof_type\n        else:\n            raise ValueError(\"Invalid input for proof type: %s\" % proof_type)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _process(self, name):\n        if self.token.nature == name:\n            self.token = self.lexer.next_token()\n        else:\n            self._error()", "response": "Process the current token."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a sequence of INDRA statements.", "response": "def program(self):\n        \"\"\"\n        program: (statement)*\n        \"\"\"\n        root = Program()\n\n        while self.token.nature != Nature.EOF:\n            root.children.append(self.statement())\n\n        return root"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the next statement in the tree.", "response": "def statement(self):\n        \"\"\"\n        statement: function_declaration\n                 | variable_declaration\n                 | expression_statement\n                 | if_statement\n                 | while_statement\n                 | jump_statement\n        \"\"\"\n        if self.token.nature == Nature.DEF:\n            node = self.function_declaration()\n        elif self.token.nature == Nature.LET:\n            node = self.variable_declaration()\n        elif self.token.nature in (Nature.MUT, Nature.ID):\n            node = self.expression_statement()\n        elif self.token.nature == Nature.IF:\n            node = self.if_statement()\n        elif self.token.nature == Nature.WHILE:\n            node = self.while_statement()\n        elif self.token.nature == Nature.RETURN:\n            node = self.jump_statement()\n        else:\n            node = self._error()\n\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef function_declaration(self):\n        self._process(Nature.DEF)\n\n        identifier = Identifier(self.token.value)\n        self._process(Nature.ID)\n\n        parameters = self.parameters()\n        return FunctionDeclaration(\n            identifier=identifier, parameters=parameters, body=self.function_body()\n        )", "response": "get the next token as a function declaration"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the function body.", "response": "def function_body(self):\n        \"\"\"\n        function_body: '{' (statement)* '}'\n        \"\"\"\n        root = FunctionBody()\n        self._process(Nature.LBRACKET)\n\n        while self.token.nature != Nature.RBRACKET:\n            root.children.append(self.statement())\n\n        self._process(Nature.RBRACKET)\n        return root"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the variable declaration", "response": "def variable_declaration(self):\n        \"\"\"\n        variable_declaration: 'let' assignment ';'\n        \"\"\"\n        self._process(Nature.LET)\n        node = VariableDeclaration(assignment=self.assignment())\n        self._process(Nature.SEMI)\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing an expression statement", "response": "def expression_statement(self):\n        \"\"\"\n        expression_statement: assignment ';'\n        \"\"\"\n        node = self.assignment()\n        self._process(Nature.SEMI)\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef assignment(self):\n        node = self.logical_or_expr()\n        if self.token.nature == Nature.ASSIGN:\n            token = self.token\n            self._process(Nature.ASSIGN)\n            right = self.logical_or_expr()\n            return Assignment(left=node, op=token, right=right)\n        else:\n            return node", "response": "assignment: logical_or_expr ['=' logical_or_expr]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef if_statement(self):\n        self._process(Nature.IF)\n        if_condition = self.logical_or_expr()\n        if_body = self.compound()\n\n        else_compound = None\n        else_if_compounds = []\n        while self.token.nature == Nature.ELSE:\n            self._process(Nature.ELSE)\n\n            if self.token.nature == Nature.IF:\n                self._process(Nature.IF)\n                else_if_compounds.append((self.logical_or_expr(), self.compound()))\n            else:\n                else_compound = (None, self.compound())\n\n        return IfStatement(\n            if_compound=(if_condition, if_body),\n            else_if_compounds=else_if_compounds,\n            else_compound=else_compound,\n        )", "response": "Parse an if statement."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef while_statement(self):\n        self._process(Nature.WHILE)\n        condition = self.logical_or_expr()\n        compound = self.compound()\n        return WhileStatement(condition=condition, compound=compound)", "response": "Return a while statement."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compound(self):\n        root = Compound()\n        self._process(Nature.LBRACKET)\n\n        while self.token.nature != Nature.RBRACKET:\n            root.children.append(self.statement())\n\n        self._process(Nature.RBRACKET)\n        return root", "response": "Parse a compound XML element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn statement for the current tag", "response": "def jump_statement(self):\n        \"\"\"\n        jump_statement: 'return' expression_statement\n        \"\"\"\n        self._process(Nature.RETURN)\n        return ReturnStatement(expression=self.expression_statement())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing an or expression", "response": "def logical_or_expr(self):\n        \"\"\"\n        logical_or_expr: logical_and_expr ('or' logical_and_expr)*\n        \"\"\"\n        node = self.logical_and_expr()\n\n        while self.token.nature == Nature.OR:\n            token = self.token\n            self._process(Nature.OR)\n\n            node = BinaryOperation(left=node, op=token, right=self.logical_and_expr())\n\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef logical_and_expr(self):\n        node = self.logical_not_expr()\n\n        while self.token.nature == Nature.AND:\n            token = self.token\n            self._process(Nature.AND)\n\n            node = BinaryOperation(left=node, op=token, right=self.logical_not_expr())\n\n        return node", "response": "parse an and expression"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef logical_not_expr(self):\n        if self.token.nature == Nature.NOT:\n            token = self.token\n            self._process(Nature.NOT)\n            return UnaryOperation(op=token, right=self.logical_not_expr())\n        else:\n            return self.comparison()", "response": "logical_not_expr: 'not' logical_not_expr\n                        | comparison"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef comparison(self):\n        node = self.expr()\n\n        while self.token.nature in (\n            Nature.EQ,\n            Nature.NE,\n            Nature.LE,\n            Nature.GE,\n            Nature.LT,\n            Nature.GT,\n        ):\n            token = self.token\n            if token.nature == Nature.EQ:\n                self._process(Nature.EQ)\n            elif token.nature == Nature.NE:\n                self._process(Nature.NE)\n            elif token.nature == Nature.LE:\n                self._process(Nature.LE)\n            elif token.nature == Nature.GE:\n                self._process(Nature.GE)\n            elif token.nature == Nature.LT:\n                self._process(Nature.LT)\n            elif token.nature == Nature.GT:\n                self._process(Nature.GT)\n            else:\n                self.error()\n\n            node = BinaryOperation(left=node, op=token, right=self.expr())\n\n        return node", "response": "Return a comparison expression for the ISO - 8601 related tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef expr(self):\n        node = self.term()\n\n        while self.token.nature in (Nature.PLUS, Nature.MINUS):\n            token = self.token\n            if token.nature == Nature.PLUS:\n                self._process(Nature.PLUS)\n            elif token.nature == Nature.MINUS:\n                self._process(Nature.MINUS)\n            else:\n                self._error()\n\n            node = BinaryOperation(left=node, op=token, right=self.term())\n\n        return node", "response": "expr - returns a term that represents the term in the tree."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a term in the tree.", "response": "def term(self):\n        \"\"\"\n        term: atom (('*' | '/' | '//') atom)*\n        \"\"\"\n        node = self.atom()\n\n        while self.token.nature in (Nature.MUL, Nature.DIV, Nature.INT_DIV):\n            token = self.token\n            if token.nature == Nature.MUL:\n                self._process(Nature.MUL)\n            elif token.nature == Nature.DIV:\n                self._process(Nature.DIV)\n            elif token.nature == Nature.INT_DIV:\n                self._process(Nature.INT_DIV)\n            else:\n                self._error()\n\n            node = BinaryOperation(left=node, op=token, right=self.atom())\n\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef call(self):\n        is_mutable = False\n        if self.token.nature == Nature.MUT:\n            is_mutable = True\n            self._process(Nature.MUT)\n\n        identifier = Identifier(name=self.token.value)\n        self._process(Nature.ID)\n\n        if self.token.nature == Nature.LPAREN:\n            return FunctionCall(identifier=identifier, parameters=self.parameters())\n        else:\n            return Variable(identifier=identifier, is_mutable=is_mutable)", "response": "Process the resource set entry point."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse(self):\n        node = self.program()\n        if self.token.nature != Nature.EOF:\n            self._error()\n\n        return node", "response": "Generic entrypoint of the Parser class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a list of records for a specific domain.", "response": "def list(self, domain_id, sub_domain=None):\n        '''Get a list of records, for a specific domain\n\n        :param str domain_id: Domain ID\n        :param str sub_domain: Optional. Subdomain of domain\n        :return: list of records\n        '''\n        optional_args = {}\n        if sub_domain != None:\n            optional_args['sub_domain'] = sub_domain\n        r = self._api.do_post('Record.List', domain_id=domain_id,\n                              **optional_args)\n        record_list = []\n        for record in r['records']:\n            record['domain_id'] = domain_id\n            record_list.append(Record(record))\n        return record_list"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ddns(self, domain_id, record_id, sub_domain, record_line, value):\n        '''Update record's value dynamically\n\n        If the ``value`` is different from the record's current value, then\n        perform a dynamic record update. Otherwise, nothing will be done.\n\n        :param str domain_id: Domain ID\n        :param str record_id: Record ID\n        :param str sub_domain: Sub domain of domain (e.g., **www** of **www.google.com**)\n        :param str record_line: Line of the record\n        :param str value: The record's value, an IP address\n        '''\n        record = self.info(domain_id, record_id)\n        # If everything stay the same, no need to update\n        if record.sub_domain == sub_domain and \\\n           record.record_line == record_line and \\\n           record.value == value:\n            return\n        self._api.do_post('Record.Ddns', domain_id=domain_id,\n                          record_id=record_id, sub_domain=sub_domain,\n                          record_line=record_line, value=value)", "response": "Update record s value dynamically"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets information for a specific record", "response": "def info(self, domain_id, record_id):\n        '''Get information for a specific record\n\n        :param str domain_id: Domain ID\n        :param str record_id: Record ID\n        :return: object\n        '''\n        r = self._api.do_post('Record.Info', domain_id=domain_id,\n                              record_id=record_id)\n        return Record(r['record'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_shot(self, shot):\n        shot.declination = self.declination\n        if shot.is_splay:\n            self.splays[shot['FROM']].append(shot)\n        self.shots.append(shot)", "response": "Add a Shot to the list of splays and songs."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntotal surveyed cave length not including splays.", "response": "def length(self):\n        \"\"\"Total surveyed cave length, not including splays.\"\"\"\n        return sum([shot.length for shot in self.shots if not shot.is_splay])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_shot(self, shot):\n        if not self.shots or not shot.get('TO', None) or not self.shots[-1].get('TO', None):\n            return super(MergingSurvey, self).add_shot(shot)\n\n        from_, to = shot['FROM'], shot['TO']\n        prev_shot = self.shots[-1]\n        prev_from, prev_to = prev_shot['FROM'], prev_shot['TO']\n\n        if from_ == prev_from and to == prev_to:\n            # dupe shot! calculate iterative \"running\" mean and merge into the previous shot\n            total_count = prev_shot.dupe_count + 1\n\n            log.debug('Merging %d shots \"%s\" <- \"%s\"', total_count, prev_shot, shot)\n            if abs(shot['AZM'] - prev_shot['AZM']) > 2.0:\n                log.warning('Merged forward AZM disagreement of %0.1f for \"%s\" <- \"%s\"', abs(shot['AZM'] - prev_shot['AZM']), prev_shot, shot)\n            if abs(shot['INC'] - prev_shot['INC']) > 2.0:\n                log.warning('Merged forward INC disagreement of %0.1f for \"%s\" <- \"%s\"', abs(shot['INC'] - prev_shot['INC']), prev_shot, shot)\n            if abs(shot['LENGTH'] - prev_shot['LENGTH']) > 1.0:\n                log.warning('Merged forward LENGTH disagreement of %0.1f for \"%s\" <- \"%s\"', abs(shot['LENGTH'] - prev_shot['LENGTH']), prev_shot, shot)\n\n            avg_length = (prev_shot['LENGTH'] * prev_shot.dupe_count + shot['LENGTH']) / total_count\n            avg_azm = (prev_shot['AZM'] * prev_shot.dupe_count + shot['AZM']) / total_count\n            avg_inc = (prev_shot['INC'] * prev_shot.dupe_count + shot['INC']) / total_count\n            merged_comments = ('%s %s' % (prev_shot.get('COMMENT', '') or '', shot.get('COMMENT', '') or '')).strip() or None\n\n            prev_shot['LENGTH'], prev_shot['AZM'], prev_shot['INC'], prev_shot['COMMENT'] = avg_length, avg_azm, avg_inc, merged_comments\n            prev_shot.dupe_count += 1\n\n        elif from_ == prev_to and to == prev_from:\n            # backsight! we do the same iterative \"running\" mean rather than assuming a single forward and single back\n            total_count = prev_shot.dupe_count + 1\n            inv_azm, inv_inc = self._inverse_azm(shot['AZM']), self._inverse_inc(shot['INC'])\n\n            log.debug('Merging %d backsights \"%s\" <- \"%s\"', total_count, prev_shot, shot)\n            if abs(inv_azm - prev_shot['AZM']) > 2.0:\n                log.warning('Backsight AZM disagreement of %0.1f for \"%s\" <- \"%s\"', abs(inv_azm - prev_shot['AZM']), prev_shot, shot)\n            if abs(inv_inc - prev_shot['INC']) > 2.0:\n                log.warning('Backsight INC disagreement of %0.1f for \"%s\" <- \"%s\"', abs(inv_inc - prev_shot['INC']), prev_shot, shot)\n            if abs(shot['LENGTH'] - prev_shot['LENGTH']) > 1.0:\n                log.warning('Backsight LENGTH disagreement of %0.1f for \"%s\" <- \"%s\"', abs(shot['LENGTH'] - prev_shot['LENGTH']), prev_shot, shot)\n\n            avg_length = (prev_shot['LENGTH'] * prev_shot.dupe_count + shot['LENGTH']) / total_count\n            avg_azm = (prev_shot['AZM'] * prev_shot.dupe_count + inv_azm) / total_count\n            avg_inc = (prev_shot['INC'] * prev_shot.dupe_count + inv_inc) / total_count\n            merged_comments = ('%s %s' % (prev_shot.get('COMMENT', '') or '', shot.get('COMMENT', '') or '')).strip() or None\n\n            prev_shot['LENGTH'], prev_shot['AZM'], prev_shot['INC'], prev_shot['COMMENT'] = avg_length, avg_azm, avg_inc, merged_comments\n            prev_shot.dupe_count += 1\n\n        else:\n            # a new, different shot; no merge\n            return super(MergingSurvey, self).add_shot(shot)", "response": "Adds a shot dictionary to the species and averaging it if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a : class : Survey to the list of surveys.", "response": "def add_survey(self, survey):\n        \"\"\"Add a :class:`Survey` to :attr:`surveys`.\"\"\"\n        survey.length_units = self.length_units\n        survey.angle_units = self.angle_units\n        self.surveys.append(survey)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read(fname, merge_duplicate_shots=False, encoding='windows-1252'):\n        return PocketTopoTxtParser(fname, merge_duplicate_shots, encoding).parse()", "response": "Read a PocketTopo. TXT file and produce a TTxtFile object which represents it"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the PocketTopo. TXT file and return a TxtFile object.", "response": "def parse(self):\n        \"\"\"Produce a `TxtFile` object from the .TXT file\"\"\"\n        log.debug('Parsing PocketTopo .TXT file %s ...', self.txtfilename)\n        SurveyClass = MergingSurvey if self.merge_duplicate_shots else Survey\n        txtobj = None\n\n        with codecs.open(self.txtfilename, 'rb', self.encoding) as txtfile:\n            lines = txtfile.read().splitlines()\n\n            # first line is cave name and units\n            first_line_re = re.compile(r'^([\\w\\s]*)\\(([\\w\\s]*),([\\w\\s]*)')\n            first_line = lines.pop(0)\n            cave_name, length_units, angle_units = first_line_re.search(first_line).groups()\n            cave_name, angle_units = cave_name.strip(), int(angle_units)\n            txtobj = TxtFile(cave_name, length_units, angle_units)\n\n            while not lines[0]:\n                lines.pop(0)  # skip blanks\n\n            # next block identifies surveys (trip) metadata\n            while lines[0].startswith('['):\n                toks = lines.pop(0).split(None, 3)\n                id, date, declination = toks[:3]\n                id = id.strip('[]:')\n                date = datetime.strptime(date, '%Y/%m/%d').date()\n                declination = float(declination)\n                comment = toks[3].strip('\"') if len(toks) == 4 else ''\n                survey = SurveyClass(id, date, comment, declination, cave_name)\n                txtobj.add_survey(survey)\n\n            while not lines[0]:\n                lines.pop(0)  # skip blanks\n\n            # finally actual survey data\n            while lines:\n                line = lines.pop(0).strip()\n                if not line:\n                    continue\n\n                if '\"' in line:\n                    line, comment = line.split('\"', 1)\n                    comment = comment.rstrip('\"')\n                else:\n                    comment = None\n\n                if '[' not in line:\n                    # this is either a Reference Point or a zero-length fake shot\n                    toks = line.split()\n                    if len(toks) != 4:  # ??\n                        log.debug('Skipping unrecognized shot:  %s %s', line, '\"%s\"' % comment if comment else '')\n                        continue\n                    station, vals = toks[0], list(map(float, toks[1:]))\n                    if vals[0] == 0.0:  # fake shot\n                        log.debug('Skipping zero-length shot:  %s %s', line, '\"%s\"' % comment if comment else '')\n                    else:  # reference point\n                        easting, northing, altitude = vals\n                        reference_point = UTMLocation(easting, northing, altitude, comment)\n                        log.debug('Reference point:  %s', reference_point)\n                        txtobj.add_reference_point(station, reference_point)\n                    continue\n\n                line, survey_id = line.split('[')\n                survey_id = survey_id.rstrip().rstrip(']')\n                toks = line.split()\n                from_to, (length, azm, inc) = toks[:-3], (float(tok) for tok in toks[-3:])\n\n                if len(from_to) == 2:\n                    from_, to = tuple(from_to)  # shot\n                elif len(from_to) == 1:\n                    from_, to = from_to[0], None  # splay\n                elif not from_to and length == 0.0:\n                    continue  # skip junk zero-length placeholder shots\n                else:\n                    raise Exception()\n\n                shot = Shot([('FROM',from_), ('TO',to), ('LENGTH',length), ('AZM',azm), ('INC',inc), ('COMMENT',comment)])\n                txtobj[survey_id].add_shot(shot)\n\n        return txtobj"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts the given value into its hexadecimal representation", "response": "def toHex(val):\n    \"\"\"Converts the given value (0-255) into its hexadecimal representation\"\"\"\n    hex = \"0123456789abcdef\"\n    return hex[int(val / 16)] + hex[int(val - int(val / 16) * 16)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef toFloat(val):\n    hex = \"0123456789abcdef\"\n    return float(hex.find(val[0]) * 16 + hex.find(val[1]))", "response": "Converts the given value into its hexadecimal representation"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef toColor(val, colormap):\n    for i in range(0, len(colormap) - 1):\n        if colormap[i + 1][0] > val:\n            scale = (val - colormap[i][0]) / \\\n                (colormap[i + 1][0] - colormap[i][0])\n            r = colormap[i][1][0] + \\\n                (colormap[i + 1][1][0] - colormap[i][1][0]) * scale\n            g = colormap[i][1][1] + \\\n                (colormap[i + 1][1][1] - colormap[i][1][1]) * scale\n            b = colormap[i][1][2] + \\\n                (colormap[i + 1][1][2] - colormap[i][1][2]) * scale\n            return \"#\" + toHex(r) + toHex(g) + toHex(b)\n    return \"#\" + toHex(colormap[-1][1][0]) + toHex(colormap[-1][1][1]) + toHex(colormap[-1][1][2])", "response": "Converts the given value into a color definition parseable by matplotlib"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cpt2seg(file_name, sym=False, discrete=False):\r\n   \r\n   \r\n    dic = {}\r\n#    io\r\n#    f = scipy.io.open(file_name, 'r')\r\n#    rgb = f.read_array(f)\r\n    \r\n    #Check flags:\r\n#    with open(file_name) as f:\r\n#        content = f.readlines()\r\n#        header=np.where(np.array([c.startswith('#') for c in content]))[0][-1]\r\n#        footer=np.where(np.array([c[0].isalpha() for c in content]))[0][0]\r\n    \r\n    rgb = np.genfromtxt(file_name,comments='#',invalid_raise=False)\r\n#    rgb = np.genfromtxt(file_name)\r\n    rgb = rgb/255.\r\n    s = shape(rgb)\r\n    colors = ['red', 'green', 'blue']\r\n    for c in colors:\r\n        i = colors.index(c)\r\n        x = rgb[:, i+1]\r\n\r\n        if discrete:\r\n            if sym:\r\n                dic[c] = zeros((2*s[0]+1, 3), dtype=Float)\r\n                dic[c][:,0] = linspace(0,1,2*s[0]+1)\r\n                vec = concatenate((x ,x[::-1]))\r\n            else:\r\n                dic[c] = zeros((s[0]+1, 3), dtype=Float)\r\n                dic[c][:,0] = linspace(0,1,s[0]+1)\r\n                vec = x\r\n            dic[c][1:, 1] = vec\r\n            dic[c][:-1,2] = vec\r\n               \r\n        else:\r\n            if sym:\r\n                dic[c] = zeros((2*s[0], 3), dtype=Float)\r\n                dic[c][:,0] = linspace(0,1,2*s[0])\r\n                vec = concatenate((x ,x[::-1]))\r\n            else:\r\n                dic[c] = zeros((s[0], 3), dtype=Float)\r\n                dic[c][:,0] = linspace(0,1,s[0])\r\n                vec = x\r\n            dic[c][:, 1] = vec\r\n            dic[c][:, 2] = vec\r\n   \r\n    return dic", "response": "Reads a. cpt palette and returns a segmented colormap."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wrap_object(func, before, after):\n    '''\n    before/after call will encapsulate callable object\n    '''\n    def _wrapper(*args, **kwargs):\n        before()\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            raise e\n        finally:\n            after()\n    return _wrapper", "response": "Wrap a function to be used in a sequence of functions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _to_timezone(self, dt):\n        tz = self._get_tz()\n        utc_dt = pytz.utc.localize(dt)\n        return utc_dt.astimezone(tz)", "response": "Takes a naive timezone with an utc value and return it formatted as a\n        local timezone."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake a naive timezone with an localized value and return it formatted as utc.", "response": "def _to_utc(self, dt):\n        \"\"\"Takes a naive timezone with an localized value and return it formatted\n        as utc.\"\"\"\n        tz = self._get_tz()\n        loc_dt = tz.localize(dt)\n        return loc_dt.astimezone(pytz.utc)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _str_to_datetime(self, str_value):\n        try:\n            ldt = [int(f) for f in str_value.split('-')]\n            dt = datetime.datetime(*ldt)\n        except (ValueError, TypeError):\n            return None\n        return dt", "response": "Parses a YYYY - MM - DD string into a datetime object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _str_to_time(self, str_value):\n        match = self.rx_time.match(str_value.upper())\n        if not match:\n            return None\n        try:\n            gd = match.groupdict()\n            hour = int(gd['hour'])\n            minute = int(gd['minute'])\n            second = int(gd['second'] or 0)\n            if gd['tt'] == 'PM':\n                hour += 12\n            return datetime.time(hour, minute, second)\n        except (ValueError, TypeError):\n            return None", "response": "Parses a string representing a time object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting all available column names from sddsfile", "response": "def getAllCols(self, sddsfile=None):\n        \"\"\" get all available column names from sddsfile\n\n        :param sddsfile: sdds file name, if not given, rollback to the one that from ``__init__()``\n        :return: all sdds data column names\n        :rtype: list\n\n        :Example:\n\n        >>> dh = DataExtracter('test.out')\n        >>> print(dh.getAllCols())\n        ['x', 'xp', 'y', 'yp', 't', 'p', 'particleID']\n        >>> print(dh.getAllCols('test.twi'))\n        ['s', 'betax', 'alphax', 'psix', 'etax', 'etaxp', 'xAperture', 'betay', 'alphay', 'psiy', 'etay', 'etayp',\n         'yAperture', 'pCentral0', 'ElementName', 'ElementOccurence', 'ElementType']\n        \"\"\"\n        if SDDS_:\n            if sddsfile is not None:\n                sddsobj = sdds.SDDS(2)\n                sddsobj.load(sddsfile)\n            else:\n                sddsobj = self.sddsobj\n            return sddsobj.columnName\n        else:\n            if sddsfile is None:\n                sddsfile = self.sddsfile\n            return subprocess.check_output(['sddsquery', '-col', sddsfile]).split()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getAllPars(self, sddsfile=None):\n        if SDDS_:\n            if sddsfile is not None:\n                sddsobj = sdds.SDDS(2)\n                sddsobj.load(sddsfile)\n            else:\n                sddsobj = self.sddsobj\n            return sddsobj.parameterName\n        else:\n            if sddsfile is None:\n                sddsfile = self.sddsfile\n            return subprocess.check_output(['sddsquery', '-par', sddsfile]).split()", "response": "get all available parameter names from sddsfile"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extractData(self):\n        if SDDS_:\n            columns = self.sddsobj.columnName\n            parameters = self.sddsobj.parameterName\n            data = [self.sddsobj.columnData[columns.index(col)][0]\n                    for col in self.kwslist if col in columns]\n            data.append([self.sddsobj.parameterData[parameters.index(par)][0]\n                        for par in self.kwslist if par in parameters])\n            self.h5data = np.array(filter(None, data)).T\n        else:\n            for k in self.kwslist:\n                self.dcmdline += ' -col={kw},format={p}'.format(kw=k, p=self.precision)\n            cmdlist = ['bash', self.dscript, self.dpath, self.dcmdline]\n            retlist = []\n            proc = subprocess.Popen(cmdlist, stdout=subprocess.PIPE)\n            for line in proc.stdout:\n                retlist.append([float(i) for i in line.split()])\n            self.h5data = np.array(retlist)\n        return self", "response": "return self with extracted data as numpy array"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndump extracted data into a single hdf5 file", "response": "def dump(self):\n        \"\"\" dump extracted data into a single hdf5file,\n\n        :return: None\n        :Example:\n\n\n        >>> # dump data into an hdf5 formated file\n        >>> datafields = ['s', 'Sx', 'Sy', 'enx', 'eny']\n        >>> datascript = 'sddsprintdata.sh'\n        >>> datapath   = './tests/tracking'\n        >>> hdf5file   = './tests/tracking/test.h5'\n        >>> A = DataExtracter('test.sig', *datafields)\n        >>> A.setDataScript(datascript)\n        >>> A.setDataPath  (datapath)\n        >>> A.setH5file    (hdf5file)\n        >>> A.extractData().dump()\n        >>>\n        >>> # read dumped file\n        >>> fd = h5py.File(hdf5file, 'r')\n        >>> d_s  = fd['s'][:]\n        >>> d_sx = fd['Sx'][:]\n        >>>\n        >>> # plot dumped data\n        >>> import matplotlib.pyplot as plt\n        >>> plt.figure(1)\n        >>> plt.plot(d_s, d_sx, 'r-')\n        >>> plt.xlabel('$s$')\n        >>> plt.ylabel('$\\sigma_x$')\n        >>> plt.show()\n\n        Just like the following figure shows:\n\n        .. image:: ../../images/test_DataExtracter.png\n            :width: 400px\n\n        \"\"\"\n        f = h5py.File(self.h5file, 'w')\n        for i, k in enumerate(self.kwslist):\n            v = self.h5data[:, i]\n            dset = f.create_dataset(k, shape=v.shape, dtype=v.dtype)\n            dset[...] = v\n        f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(icon=None):\n    app = wx.App()\n    frame = myappframe.MyAppFrame(None,\n                                  u'Lattice Viewer \\u2014 Accelerator Online Modeling Tool')\n    frame.SetSize((1024, 768))\n    frame.Show()\n    if icon is not None:\n        frame.SetIcon(icon)\n    app.MainLoop()", "response": "Main loop for the AIKIF module."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef includeme(config):\n    log.info('Loading htmlmin pyramid plugin')\n    for key, val in config.registry.settings.items():\n        if key.startswith('htmlmin.'):\n            log.debug('Setup %s = %s' % (key, val))\n            htmlmin_opts[key[8:]] = asbool(val)\n        if key.startswith('pyramid_htmlmin.'):\n            log.debug('Setup %s = %s' % (key, val))\n            opts[key[16:]] = asbool(val)\n\n    config.add_tween('pyramid_htmlmin.htmlmin_tween_factory', under=INGRESS)", "response": "Add htmlmin tween factory to include list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef natural_sort(item):\n    if item is None:\n        return 0\n\n    def try_int(s):\n        try:\n            return int(s)\n        except ValueError:\n            return s\n    return tuple(map(try_int, re.findall(r'(\\d+|\\D+)', item)))", "response": "Sort a string that contains numbers correctly."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads a list of symbols from a GDX file or a list of GDX files.", "response": "def gload(smatch, gpaths=None, glabels=None, filt=None, reducel=False,\n          remove_underscore=True, clear=True, single=True, reshape=RESHAPE_DEFAULT,\n          idxlower=True, returnfirst=False, lowercase=True, lamb=None, verbose=True,\n          idval=None):\n      \"\"\"\n      Loads into global namespace the symbols listed in {slist}\n      from the GDX listed in {gpaths}.\n      If {reducel}==True, filter the dataset on 'l' entries only.\n      If {remove_underscore}==True, symbols are loaded into the global\n      namespace with their names without underscores.\n      \"\"\"\n      # Normalize the match string for symbols\n      if smatch[0] == '@':\n          returnfirst = True\n          smatch = smatch[1:]\n      smatch = expandmatch(smatch)\n      # Build gdxobj list and\n      if isinstance(gpaths,list) and isinstance(gpaths[0],GdxFile):\n          gpaths = [g.internal_filename for g in gpaths]\n          gdxobjs = gpaths\n      elif not gpaths is None:\n          gpaths = expandlist(gpaths)\n          gdxobjs = [GdxFile(g) for g in gpaths]\n      else:\n          gpaths = gload.last_gpaths\n          gdxobjs = [GdxFile(g) for g in gpaths]\n          glabels = gload.last_glabels\n      # Normalize the list of labels for gdxs\n      gload.last_gpaths = gpaths\n      gload.last_glabels = glabels\n      glabels = expandlist(glabels,gpaths)\n      all_symbols = set()\n      for g in gdxobjs:\n          all_symbols |= set([x.name for x in g.get_symbols_list()])\n      ng = len(gpaths)\n      nax = 0\n      if verbose: print(smatch)\n      svar2ret = []\n      for s in all_symbols:\n            m = re.match(smatch,s, re.M|re.I)\n            if not m:\n                continue\n            if verbose: print('\\n<<< %s >>>' % s)\n            sdata = {}\n            svar = None\n            validgdxs = []\n            for ig,g in enumerate(gpaths):\n                fname, fext = os.path.splitext(g)\n                if glabels == None:\n                    gid = fname\n                else:\n                    if isinstance(glabels,int):\n                        gid = 'g%d' % (ig+glabels)\n                    else:\n                        gid = glabels[ig]\n                try:\n                    sdata_curr = gdxobjs[ig].query(s,filt=filt,reshape=reshape,idval=idval,idxlower=idxlower)\n                    sdata[gid] = sdata_curr\n                except Exception as e:\n                    #traceback.print_exc()\n                    if verbose:\n                        print_traceback(e)\n                        print('WARNING: Missing \"%s\" from \"%s\"' % (s,gid))\n                    continue\n                validgdxs.append(gid)\n            nvg = len(validgdxs)\n            if nvg>1:\n                if isinstance(sdata_curr, pd.Index):\n                    df = pd.concat({gid: pd.Series(1, x) for gid, x in sdata.items()}, keys=validgdxs).index\n                elif (reshape==RESHAPE_PANEL):\n                    raise NotImplementedError('Panels are obsolete')\n                else:\n                    if isinstance(sdata_curr, float):\n                        df = pd.Series(sdata)[validgdxs]\n                    else:\n                        df = pd.concat(sdata, keys=validgdxs)\n                    if reshape==RESHAPE_NONE:\n                        df.reset_index(inplace=True)\n                        col2drop = df.columns[1]\n                        df.drop(col2drop, axis=1, inplace=True)\n                        ncols = len(df.columns)\n                        df.columns = ['s{}'.format(x) for x in range(ncols-1)] + ['val',]\n                    elif reshape>=RESHAPE_SERIES:\n                        for i in range(len(df.index.levels)):\n                            df.index.levels[i].name = 's{}'.format(i)\n                        if reshape>=RESHAPE_FRAME:\n                            try:\n                                df.columns.name = 's{}'.format(i+1)\n                                df = df.stack().unstack(0)\n                            except:\n                                df = df.unstack(0)\n            else:\n                df = sdata_curr\n            try:\n                df.name = s\n            except:\n                pass\n            svar = df\n            if remove_underscore:\n                  s = s.replace('','')\n            if lowercase:\n                s = s.lower()\n            if not lamb is None:\n                svar = lamb(svar)\n            if not returnfirst:\n                if not clear:\n                    try:\n                        sold = __builtins__[s]\n                        if len(sold.shape) == len(svar.shape):\n                            if verbose: print('Augmenting',s)\n                            for c in svar.axes[0]:\n                                sold[c] = svar[c]\n                            svar = sold\n                    except:\n                        pass\n                else:\n                    __builtins__[s] = svar\n\n\n            logprint = logger.info if verbose else logger.debug\n            if isinstance(svar, pd.DataFrame):\n                logprint('Rows   : {} ... {}'.format(str(svar.index[0]), str(svar.index[-1])))\n                colwidth = np.max([len(str(svar.columns[i])) for i in range(len(svar.columns))])\n                logprint('Columns: {}'.format('\\n         '.join([('{:<%d} = {} ... {}'%colwidth).format(\n                    str(svar.columns[i]), svar.iloc[0,i], svar.iloc[-1,i]) for i in range(len(svar.columns))])))\n            elif isinstance(svar, pd.Series):\n                logprint('Index  : {} ... {}'.format(str(svar.index[0]), str(svar.index[-1])))\n            else:\n                logprint(svar)\n            if returnfirst:\n                svar2ret.append(svar)\n      if returnfirst:\n          if len(svar2ret) == 1:\n              svar2ret = svar2ret[0]\n          return svar2ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncloses Gdx file and free up resources.", "response": "def close(self):\n        '''Close Gdx file and free up resources.'''\n        h = self.gdx_handle\n        gdxcc.gdxClose(h)\n        gdxcc.gdxFree(h)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_sid_info(self,j):\n        '''Return a dict of metadata for symbol with ID j.'''\n        h = self.gdx_handle\n        r, name, dims, stype = gdxcc.gdxSymbolInfo(h, j)\n        assert r, '%d is not a valid symbol number' % j\n        r, records, userinfo, description = gdxcc.gdxSymbolInfoX(h, j)\n        assert r, '%d is not a valid symbol number' % j\n        return {'name':name, 'stype':stype, 'desc':description, 'dim':dims}", "response": "Return a dict of metadata for symbol with ID j."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_symbols_list(self):\n        '''Return a list of GdxSymb found in the GdxFile.'''\n        slist = []\n        rc, nSymb, nElem = gdxcc.gdxSystemInfo(self.gdx_handle)\n        assert rc, 'Unable to retrieve \"%s\" info' % self.filename\n        self.number_symbols = nSymb\n        self.number_elements = nElem\n        slist = [None]*(nSymb+1)\n        for j in range(0,nSymb+1):\n            sinfo = self.get_sid_info(j)\n            if j==0:\n                sinfo['name'] = 'universal_set'\n            slist[j] = GdxSymb(self,sinfo)\n        return slist", "response": "Return a list of GdxSymb found in the GdxFile."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef query(self, name, reshape=RESHAPE_DEFAULT, filt=None, idval=None, idxlower=True):\n        '''\n        Query attribute `idval` from symbol `name`, and return a data structure shaped according to `reshape`.\n        '''\n        gdx_handle = self.gdx_handle\n        ret, symNr = gdxcc.gdxFindSymbol(gdx_handle, name)\n        assert ret, \"Symbol '%s' not found in GDX '%s'\" % (name, self.internal_filename)\n        sinfo = self.get_sid_info(symNr)\n        dim = sinfo['dim']\n        symType = sinfo['stype']\n        ret, nrRecs = gdxcc.gdxDataReadStrStart(gdx_handle, symNr)\n        assert ret, get_last_error('gdxDataReadStrStart', gdx_handle)\n        if idval is None:\n            if symType == gdxcc.GMS_DT_EQU:\n                idval = gdxcc.GMS_VAL_MARGINAL\n            else:\n                idval = gdxcc.GMS_VAL_LEVEL\n        ifilt = None\n        vtable = [None]*(nrRecs)\n        rcounter = 0\n        rowtype = None\n        if filt != None:\n            if isinstance(filt,list):\n                filt = '^({0})$'.format('|'.join([re.escape(x) for x in filt]))\n            if isinstance(filt, str):\n                filt_func = re.compile(filt, re.IGNORECASE).match\n            else:\n                filt_func = filt\n        for i in range(nrRecs):\n            vrow = [None]*(dim+1)\n            ret, elements, values, afdim = gdxcc.gdxDataReadStr(gdx_handle)\n            assert ret, get_last_error('gdxDataReadStr', gdx_handle)\n            if (filt != None):\n                match_filt = False\n                for e in elements:\n                    m = filt_func(e)\n                    if m != None:\n                        match_filt = True\n                        break\n                if not match_filt:\n                    continue\n            d = -1\n            for d in range(dim):\n                try:\n                    vrow[d] = int(elements[d])\n                except:\n                    vrow[d] = elements[d].lower() if idxlower else elements[d]\n            vrow[d+1] = values[idval]\n            vtable[rcounter] = vrow\n            rcounter += 1\n        gdxcc.gdxDataReadDone(gdx_handle)\n        cols = ['s%d' % x for x in range(dim)]+['val',]\n        df = pd.DataFrame(vtable[:rcounter],columns=cols)\n        logger.debug(\"%d / %d records read from <%s>\" % (rcounter, nrRecs, self.internal_filename))\n        if symType == gdxcc.GMS_DT_SET:\n            reshape = RESHAPE_SERIES\n        df = dfreshape(df, reshape)\n        if symType == gdxcc.GMS_DT_SET:\n            df = df.index\n        self.data = df\n        return df", "response": "Query a data structure from a symbol name and return a data structure shaped according to reshape."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninserts tag into root. If not present insert it into root.", "response": "def insert_tag(tag, before, root):\n    \"\"\"\n    Insert `tag` before `before` tag if present. If not, insert it into `root`.\n\n    Args:\n        tag (obj): HTMLElement instance.\n        before (obj): HTMLElement instance.\n        root (obj): HTMLElement instance.\n    \"\"\"\n    if not before:\n        root.childs.append(tag)\n        tag.parent = root\n        return\n\n    if type(before) in [tuple, list]:\n        before = first(before)\n\n    # check that `before` is double linked\n    if not hasattr(before, \"parent\"):\n        raise ValueError(\"Input must be double-linked!\")\n\n    # put it before first existing identifier\n    parent = before.parent\n    parent.childs.insert(\n        parent.childs.index(before),\n        tag\n    )\n    tag.parent = parent"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntransforms content in all tags using content_transformer function.", "response": "def transform_content(tags, content_transformer):\n    \"\"\"\n    Transform content in all `tags` using result of `content_transformer(tag)`\n    call.\n\n    Args:\n        tags (obj/list): HTMLElement instance, or list of HTMLElement\n                         instances.\n        content_transformer (function): Function which is called as\n                                        ``content_transformer(tag)``.\n    \"\"\"\n    if type(tags) not in [tuple, list]:\n        tags = [tags]\n\n    for tag in tags:\n        new_child = dhtmlparser.HTMLElement(content_transformer(tag))\n\n        # don't forget to add parent if the list is double-linked\n        if hasattr(tag, \"parent\"):\n            new_child.parent = tag\n\n        tag.childs = [new_child]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef double_linked_dom(str_or_dom):\n    dom = str_or_dom\n    if not isinstance(str_or_dom, dhtmlparser.HTMLElement):\n        dom = dhtmlparser.parseString(str_or_dom)\n\n    dhtmlparser.makeDoubleLinked(dom)\n\n    return dom", "response": "Create double linked DOM from input."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndrop a link to your latest paste", "response": "def paste(client, event, channel, nick, rest):\n\t\"Drop a link to your latest paste\"\n\tpath = '/last/{nick}'.format(**locals())\n\tpaste_root = pmxbot.config.get('librarypaste', 'http://paste.jaraco.com')\n\turl = urllib.parse.urljoin(paste_root, path)\n\tauth = pmxbot.config.get('librarypaste auth')\n\tresp = requests.head(url, auth=_request_friendly(auth))\n\tif not resp.ok:\n\t\treturn \"I couldn't resolve a recent paste of yours. Maybe try \" + url\n\treturn resp.headers['location']"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add(addon, dev, interactive):\n    application = get_current_application()\n    application.add(\n        addon,\n        dev=dev,\n        interactive=interactive\n    )", "response": "Add a dependency.\n\n    Examples:\n\n    $ django add dynamic-rest==1.5.0\n\n    + dynamic-rest == 1.5.0"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef propagate_defaults(config_doc):\n    for group_name, group_doc in config_doc.items():\n        if isinstance(group_doc, dict):\n            defaults = group_doc.get('defaults', {})\n\n            for item_name, item_doc in group_doc.items():\n                if item_name == 'defaults':\n                    continue\n                if isinstance(item_doc, dict):\n\n                    group_doc[item_name] = \\\n                        dict_merge_pair(copy.deepcopy(defaults), item_doc)\n\n    return config_doc", "response": "Propagate default values to sections of the doc."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef split_by_proportions(total, proportions, mininum_values):\n    assert(len(proportions) == len(mininum_values))\n    assert(total >= sum(mininum_values))\n    assert(min(proportions) > 0)\n    num = len(proportions)\n    sumProportions = float(sum(proportions))\n    fractions = [p / sumProportions for p in proportions]\n    result = [max(m, int(round(total * f)))\n              for f, m in zip(fractions, mininum_values)]\n    delta = sum(result) - total\n    correct = -1 if delta > 0 else 1\n    i = 0\n    while delta != 0:\n        if result[i] + correct >= mininum_values[i]:\n            result[i] += correct\n            delta += correct\n        i = (i + 1) % num\n\n    assert(sum(result) == total)\n    return result", "response": "splits the given total by the given proportions but ensures that each value in\n    has at least the given minimum value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef api_config(self, stage=None):\n        if stage in self.known_api_configurations:\n            return self.known_api_configurations[stage]\n\n        if not stage:\n            section = 'stages.live'\n            api_url = 'https://api.amaas.com/'\n        else:\n            section = 'stages.{}'.format(stage)\n            try:\n                api_url = self.lookup(section, 'api_url')\n            except ConfigurationError:\n                api_url = 'https://api-{}.dev.amaas.com/'.format(stage)\n\n        return APIConfig(api_url)", "response": "Create api config based on stage."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef auth_config(self, stage=None):\n        if stage:\n            section = 'stages.{}'.format(stage)\n        else:\n            section = 'stages.live'\n\n        try:\n            username = self.lookup(section, 'username')\n            password = self.lookup(section, 'password')\n        except MissingConfigurationError:\n            username = self.lookup('auth', 'username')\n            password = self.lookup('auth', 'password')\n\n        if stage in self.known_auth_configurations:\n            return AuthConfig(\n                username, password,\n                **self.known_auth_configurations[stage]\n            )\n\n        try:\n            cognito_pool_id = self.lookup(section, 'cognito_pool_id')\n            cognito_region = self.lookup(section, 'cognito_region')\n        except MissingConfigurationError:\n            m = arn_re.match(self.lookup(section, 'cognito_pool'))\n            if not m:\n                raise ConfigurationError('Cognito Pool value must be an ARN')\n\n            cognito_pool_id = m.group('resource')\n            cognito_region = m.group('region')\n\n        cognito_client_id = self.lookup(section, 'cognito_client_id')\n        return AuthConfig(\n            username, password,\n            cognito_pool_id, cognito_region, cognito_client_id,\n        )", "response": "Create auth config based on stage."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef append_table(self, name, **kwargs):\n        self.stack.append(Table(name, **kwargs))", "response": "Create a new table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_builtins(self):\n        for raw_name in dir(builtins):\n            if not raw_name.startswith('__'):\n\n                if raw_name.startswith('_'):\n                    function_name = raw_name[1:]\n                else:\n                    function_name = raw_name\n\n                builtin_function = FunctionSymbol(\n                    Function(function_name, getattr(builtins, raw_name))\n                )\n                self.table[function_name] = builtin_function", "response": "Load the built - in functions into the scope."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the functions into the scope.", "response": "def load_functions(self, tree):\n        \"\"\"Load the functions into the scope.\"\"\"\n        for child in tree.children:\n            if isinstance(child, FunctionDeclaration):\n                if self.table[child.identifier.name] is not None:\n                    raise SementicError(\n                        f\"Function `{child.identifier.name}` already declared.\"\n                    )\n                self.table[child.identifier.name] = FunctionSymbol(child)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef visit_Program(self, node):\n        for child in node.children:\n            if not isinstance(child, FunctionDeclaration):\n                self.visit(child)", "response": "Vsitor for Program AST node."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef visit_FunctionCall(self, node):\n        function_name = node.identifier.name\n        call = self.table[function_name]\n        if call is None:\n            raise SementicError(f\"Function `{function_name}` not declared.\")\n        else:\n            call = call._node\n\n        if isinstance(call, AST):\n            if len(call.parameters) != len(node.parameters):\n                raise SementicError(\n                    \"Mismatch between call and function parameters number.\"\n                )\n\n            current_table = self.table.stack.current\n            functions_in_table = {\n                key: current_table[key]\n                for key in current_table\n                if isinstance(current_table[key], FunctionSymbol)\n            }\n\n            if self.table.name == function_name:\n                # End the visit in case of recursion\n                return\n\n            self.table.append_table(function_name, **functions_in_table)\n            self.visit(call)\n            self.table.pop_table()", "response": "Visitor for FunctionCall AST node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef visit_Variable(self, node):\n        var_name = node.identifier.name\n        var_symbol = self.table[var_name]\n\n        if var_symbol is None:\n            raise SementicError(f\"Variable `{var_name}` is not declared.\")", "response": "Visitor for Variable AST node."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef visit_BinaryOperation(self, node):\n        self.visit(node.left)\n        self.visit(node.right)", "response": "Visitor for BinaryOperation AST node."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nencodes ISBN number in ISBN10 format Raises exception if Bookland number different from 978", "response": "def isbn10(self):\n        '''\n        Encode ISBN number in ISBN10 format\n        Raises exception if Bookland number different from 978\n        @rtype:  string\n        @return: ISBN formated as ISBN10\n        '''\n        if self._id[0:3] != '978':\n            raise ISBNError(\"Invalid Bookland code: {}\".format(self._id[0:3]))\n        digit10 = _digit10(self._id[3:12])\n        if digit10 == 10:\n            return self._id[3:12] + 'X'\n        else:\n            return self._id[3:12] + str(digit10)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns ISBN number with segment hypenation Data obtained from https://www. isbn - internationalational. org / export_rangemessage. xml . xml", "response": "def doi(self):\n        '''\n        Returns ISBN number with segment hypenation\n        Data obtained from https://www.isbn-international.org/\n        https://www.isbn-international.org/export_rangemessage.xml\n        @return: ISBN formated as ISBN13 with hyphens\n        '''\n        if not ISBN.hyphenRange:\n            ISBN.hyphenRange = hyphen.ISBNRange()\n\n        seg = ISBN.hyphenRange.hyphensegments(self._id)\n        return '10.' + self._id[0:3] + '.' + \\\n            self._id[3:-(1 + seg[3])] + '/' + self._id[-(1 + seg[3]):]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if the given address is a valid IPv4 address.", "response": "def validipaddr(address):\n    \"\"\"\n    Returns True if `address` is a valid IPv4 address.\n    \n        >>> validipaddr('192.168.1.1')\n        True\n        >>> validipaddr('192.168.1.800')\n        False\n        >>> validipaddr('192.168.1')\n        False\n    \"\"\"\n    try:\n        octets = address.split('.')\n        if len(octets) != 4:\n            return False\n        for x in octets:\n            if not (0 <= int(x) <= 255):\n                return False\n    except ValueError:\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the ip_address and ip_port from string ip_addr_port", "response": "def validip(ip, defaultaddr=\"0.0.0.0\", defaultport=8080):\n    \"\"\"Returns `(ip_address, port)` from string `ip_addr_port`\"\"\"\n    addr = defaultaddr\n    port = defaultport\n    \n    ip = ip.split(\":\", 1)\n    if len(ip) == 1:\n        if not ip[0]:\n            pass\n        elif validipaddr(ip[0]):\n            addr = ip[0]\n        elif validipport(ip[0]):\n            port = int(ip[0])\n        else:\n            raise ValueError, ':'.join(ip) + ' is not a valid IP address/port'\n    elif len(ip) == 2:\n        addr, port = ip\n        if not validipaddr(addr) and validipport(port):\n            raise ValueError, ':'.join(ip) + ' is not a valid IP address/port'\n        port = int(port)\n    else:\n        raise ValueError, ':'.join(ip) + ' is not a valid IP address/port'\n    return (addr, port)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef urlquote(val):\n    if val is None: return ''\n    if not isinstance(val, unicode): val = str(val)\n    else: val = val.encode('utf-8')\n    return urllib.quote(val)", "response": "Quotes a string for use in a URL."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing an HTTP date into a datetime object.", "response": "def parsehttpdate(string_):\n    \"\"\"\n    Parses an HTTP date into a datetime object.\n\n        >>> parsehttpdate('Thu, 01 Jan 1970 01:01:01 GMT')\n        datetime.datetime(1970, 1, 1, 1, 1, 1)\n    \"\"\"\n    try:\n        t = time.strptime(string_, \"%a, %d %b %Y %H:%M:%S %Z\")\n    except ValueError:\n        return None\n    return datetime.datetime(*t[:6])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef htmlquote(text):\n    text = text.replace(u\"&\", u\"&amp;\") # Must be done first!\n    text = text.replace(u\"<\", u\"&lt;\")\n    text = text.replace(u\">\", u\"&gt;\")\n    text = text.replace(u\"'\", u\"&#39;\")\n    text = text.replace(u'\"', u\"&quot;\")\n    return text", "response": "r Encodes text for raw use in HTML.\n    \n        u&lt ; &gt ; &quot ; >>> htmlquote ( u\"&lt ; &gt ; &quot ; >>> htmlquote ( u\"&quot ; &lt ; &gt ; >>> htmlquote ( u\"&lt ; &lt ; &gt ; >>> htmlquote ( u\"&quot ; &gt ; >>> htmlquote ( u\"&lt ; &gt ; &quot ; >>> htmlquote ("}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef websafe(val):\n    if val is None:\n        return u''\n    elif isinstance(val, str):\n        val = val.decode('utf-8')\n    elif not isinstance(val, unicode):\n        val = unicode(val)\n        \n    return htmlquote(val)", "response": "r Converts val so that it is safe for use in Unicode HTML."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nimport a file in the Siemens. IMA format.", "response": "def load_siemens_dicom(filename):\n    \"\"\"\n    Imports a file in the Siemens .IMA format.\n    :param filename: The filename of the file to import\n    \"\"\"\n    # the .IMA format is a DICOM standard, unfortunately most of the information is contained inside a private and very\n    # complicated header with its own data storage format, we have to get that information out along with the data\n    # start by reading in the DICOM file completely\n    dataset = pydicom.dicomio.read_file(filename)\n    # now look through the tags (0029, 00xx) to work out which xx refers to the csa header\n    # xx seems to start at 10 for Siemens\n    xx = 0x0010\n    header_index = 0\n    while (0x0029, xx) in dataset:\n        if dataset[0x0029, xx].value == \"SIEMENS CSA HEADER\":\n            header_index = xx\n        xx += 1\n    # check that we have found the header\n    if header_index == 0:\n        raise KeyError(\"Could not find header index\")\n    # now we know which tag contains the CSA image header info: (0029, xx10)\n    csa_header_bytes = dataset[0x0029, 0x0100 * header_index + 0x0010].value\n    csa_header = read_csa_header(csa_header_bytes)\n    #for key, value in csa_header.items():\n    #    print(\"%s : %s\" % (str(key), str(value)))\n    # we can also get the series header info: (0029, xx20), but this seems to be mostly pretty boring\n\n    # now we can work out the shape of the data (slices, rows, columns, fid_points)\n    data_shape = (csa_header[\"SpectroscopyAcquisitionOut-of-planePhaseSteps\"],\n                  csa_header[\"Rows\"],\n                  csa_header[\"Columns\"],\n                  csa_header[\"DataPointColumns\"],\n                  )\n\n    # now look through the tags (0029, 00xx) to work out which xx refers to the csa header\n    # xx seems to start at 10 for Siemens\n    xx = 0x0010\n    data_index = 0\n    while (0x7fe1, xx) in dataset:\n        if dataset[0x7fe1, xx].value == \"SIEMENS CSA NON-IMAGE\":\n            data_index = xx\n        xx += 1\n    # check that we have found the data\n    if data_index == 0:\n        raise KeyError(\"Could not find data index\")\n    # extract the actual data bytes\n    csa_data_bytes = dataset[0x7fe1, 0x0100 * data_index + 0x0010].value\n    # the data is stored as a list of 4 byte floats in (real, imaginary) pairs\n    data_floats = struct.unpack(\"<%df\" % (len(csa_data_bytes) / 4), csa_data_bytes)\n    # form an iterator which will provide the numbers one at a time, then an iterator which calls that iterator twice\n    # each cycle to give a complex pair\n    data_iter = iter(data_floats)\n    complex_iter = (complex(r, i) for r, i in zip(data_iter, data_iter))\n    # give this iterator to numpy to build the data array\n    complex_data = numpy.fromiter(complex_iter, \"complex128\", int(len(csa_data_bytes) / 8))\n    # reshape the array to structure of rows, columns and slices\n    complex_data = numpy.reshape(complex_data, data_shape).squeeze()\n\n    return MRSData(complex_data,\n                   csa_header[\"RealDwellTime\"] * 1e-9,\n                   csa_header[\"ImagingFrequency\"],\n                   te=csa_header[\"EchoTime\"])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef strip_non_ascii(string):\n    ''' Returns the string without non ASCII characters'''\n    if type(string) == datetime:\n        return str(string)\n    stripped = (c for c in string if 0 < ord(c) < 127)\n    return ''.join(stripped)", "response": "Returns the string without non ASCII characters"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_dotted(self, key, value):\n        parts = key.split('.')\n        cobj = self\n        if len(parts) > 1:\n            key = parts.pop()\n            for name in parts:\n                cobj = getattr(cobj, name)\n        setattr(cobj, key, value)", "response": "Set the value of a dotted key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a single object from a dotted key", "response": "def get_dotted(self, key):\n        \"\"\"\n                obj = qs.get_dotted('foo.bar.baz')\n\n            is equivelent to:\n\n                obj = qs.foo.bar.baz\n        \"\"\"\n        parts = key.split('.')\n        cobj = self\n        for attr in parts:\n            cobj = getattr(cobj, attr)\n        return cobj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the values of the object that are not already defined on the main object.", "response": "def setdefaults(self, from_qs):\n        \"\"\"\n            sets values from a QuickSettings object, only keeping values that\n            are not already defined on the main object\n        \"\"\"\n        for k in from_qs.keys():\n            from_value = from_qs[k]\n            fv_is_qs = isinstance(from_value, QuickSettings)\n            self_value = self.get(k, None)\n            sv_is_qs = isinstance(self_value, QuickSettings)\n            if self_value is None:\n                # we don't have a value, so just take the value of the from\n                # object\n                self[k] = from_value\n            elif sv_is_qs and fv_is_qs:\n                self_value.setdefaults(from_value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef creation_date(self, value):\n        self._creation_date = parse(value).date() if isinstance(value, type_check) else value", "response": "Set the _creation_date attribute of the nagios object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the arguments for the certificatae", "response": "def getArguments():\n    \"\"\"Get the arguments\n    \"\"\"\n    parser = ArgumentParser(description = 'CA utility')\n    parser.add_argument('--base', dest = 'basePath', default = '.', help = 'The base working directory')\n    subParsers = parser.add_subparsers(dest = 'action')\n    # The init parser\n    initParser = subParsers.add_parser('init', help = 'Initialize the database')\n    # Vertify certificatae\n    verifyParser = subParsers.add_parser('verify', help = 'Verify certificate')\n    verifyParser.add_argument('--name', dest = 'name', required = True, help = 'The certificate name')\n    # Create root certificate parser\n    createRootCertParser = subParsers.add_parser('createRootCert', help = 'Create root certificate')\n    createRootCertParser.add_argument('--nopass', dest = 'noPass', default = False, action = 'store_true', help = 'Generate root key without a password (Not recommended), false by default.')\n    createRootCertParser.add_argument('--keylen', dest = 'keyLength', default = '4096', choices = [ '2048', '4096' ], help = 'The root key length, 4096 by default')\n    # Create server certificate parser\n    createServerCertParser = subParsers.add_parser('createServerCert', help = 'Create server cert')\n    createServerCertParser.add_argument('--name', dest = 'name', required = True, help = 'The certificate name')\n    createServerCertParser.add_argument('--usepass', dest = 'usePass', default = False, action = 'store_true', help = 'Generate key with a password, false by default.')\n    createServerCertParser.add_argument('--keylen', dest = 'keyLength', default = '2048', choices = [ '2048', '4096' ], help = 'The key length, 2048 by default')\n    createServerCertParser.add_argument('--days', dest = 'days', type = int, default = 3650, help = 'The certificate days parameter')\n    # Create client certificate parser\n    createClientCertParser = subParsers.add_parser('createClientCert', help = 'Create server cert')\n    createClientCertParser.add_argument('--name', dest = 'name', required = True, help = 'The certificate name')\n    createClientCertParser.add_argument('--usepass', dest = 'usePass', default = False, action = 'store_true', help = 'Generate key with a password, false by default.')\n    createClientCertParser.add_argument('--keylen', dest = 'keyLength', default = '2048', choices = [ '2048', '4096' ], help = 'The key length, 2048 by default')\n    createClientCertParser.add_argument('--days', dest = 'days', type = int, default = 3650, help = 'The certificate days parameter')\n    # Done\n    return parser.parse_args()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main():\n    args = getArguments()\n    try:\n        if args.action == 'init':\n            # Ask for init\n            while True:\n                print 'Initialize the path [%s] will cause any files or dirs be removed, continue?[y/n]' % args.basePath,\n                text = raw_input()\n                if text.lower() == 'n':\n                    print 'Will not initialize the path, exit'\n                    return 1\n                elif text.lower() == 'y':\n                    # Initialize\n                    manager = CertificateManager(args.basePath)\n                    manager.init()\n                    return 0\n                else:\n                    print 'Invalid input'\n        elif args.action == 'verify':\n            # Verify the certificate\n            manager = CertificateManager(args.basePath)\n            manager.verifyCertificate(args.name)\n            return 0\n        elif args.action == 'createRootCert':\n            # Create the root cert\n            manager = CertificateManager(args.basePath)\n            manager.createRootCertificate(args.noPass, int(args.keyLength))\n            return 0\n        elif args.action == 'createServerCert':\n            # Create the server cert\n            manager = CertificateManager(args.basePath)\n            manager.createServerCertificate(args.name, not args.usePass, args.keyLength, args.days)\n            return 0\n        elif args.action == 'createClientCert':\n            # Create the client cert\n            manager = CertificateManager(args.basePath)\n            manager.createClientCertificate(args.name, not args.usePass, args.keyLength, args.days)\n            return 0\n        else:\n            logger.error('Unknown argument action [%s]', args.action)\n            return 1\n    except ValueError as error:\n        logger.error(error.message)\n        return 1\n    except KeyboardInterrupt:\n        logger.error('User interrupted')\n        return 1\n    except:\n        logger.exception('Unhandled exception occurred')\n        return 1", "response": "The main entry point for the main entry of the sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms an asynchronous remote call where the return value is not known yet.", "response": "def begin_call(self, method, *args):\n        \"\"\"Perform an asynchronous remote call where the return value is not known yet.\n\n        This returns immediately with a Deferred object. The Deferred object may then be\n        used to attach a callback, force waiting for the call, or check for exceptions.\n\n        \"\"\"\n        d = Deferred(self.loop)\n        d.request = self.request_num\n        self.requests[self.request_num] = d\n        self.protocol.send_request(d.request, method, args)\n        self.request_num += 1\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles an incoming response.", "response": "def response(self, msgtype, msgid, error, result):\n        \"\"\"Handle an incoming response.\"\"\"\n        self._proxy.response(msgid, error, result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles an incoming notify request.", "response": "def notify(self, msgtype, method, params):\n        \"\"\"Handle an incoming notify request.\"\"\"\n        self.dispatch.call(method, params)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef request(self, msgtype, msgid, method, params=[]):\n        result = None\n        error = None\n        exception = None\n\n        try:\n            result = self.dispatch.call(method, params)\n        except Exception as e:\n            error = (e.__class__.__name__, str(e))\n            exception = e\n\n        if isinstance(result, Deferred):\n            result.add_callback(self._result, msgid)\n            result.add_errback(self._error, msgid)\n        else:\n            self.send_response(msgid, error, result)", "response": "Handle an incoming call request."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef data(self, data):\n        self.unpacker.feed(data)\n        for msg in self.unpacker:\n            self.handlers[msg[0]](*msg)", "response": "Use msgpack s streaming feed feature to build up a set of lists."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a Deferred that will result in a proxy object in the future.", "response": "def proxy(self):\n        \"\"\"Return a Deferred that will result in a proxy object in the future.\"\"\"\n        d = Deferred(self.loop)\n        self._proxy_deferreds.append(d)\n\n        if self._proxy:\n            d.callback(self._proxy)\n\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndefine a new PlayerRecord setting and save to disk file", "response": "def addPlayer(settings):\n    \"\"\"define a new PlayerRecord setting and save to disk file\"\"\"\n    _validate(settings)\n    player = PlayerRecord(settings)\n    player.save()\n    getKnownPlayers()[player.name] = player\n    return player"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef updatePlayer(name, settings):\n    player = delPlayer(name) # remove the existing record\n    _validate(settings)\n    player.update(settings)\n    player.save()\n    getKnownPlayers()[player.name] = player\n    return player", "response": "update an existing PlayerRecord setting and save to disk file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nobtaining a specific PlayerRecord settings file", "response": "def getPlayer(name):\n    \"\"\"obtain a specific PlayerRecord settings file\"\"\"\n    if isinstance(name, PlayerRecord): return name\n    try:    return getKnownPlayers()[name.lower()]\n    except KeyError:\n        raise ValueError(\"given player name '%s' is not a known player definition\"%(name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delPlayer(name):\n    player = getPlayer(name)\n    try:    os.remove(player.filename) # delete from disk\n    except IOError: pass # shouldn't happen, but don't crash if the disk data doesn't exist\n    try:    del getKnownPlayers()[player.name] # forget object from cache\n    except: pass\n    return player", "response": "forget about a previously defined PlayerRecord setting by deleting its disk file"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nidentifies all of the currently defined players", "response": "def getKnownPlayers(reset=False):\n    \"\"\"identify all of the currently defined players\"\"\"\n    global playerCache\n    if not playerCache or reset:\n        jsonFiles = os.path.join(c.PLAYERS_FOLDER, \"*.json\")\n        for playerFilepath in glob.glob(jsonFiles):\n            filename = os.path.basename(playerFilepath)\n            name = re.sub(\"^player_\", \"\", filename)\n            name = re.sub(\"\\.json$\",  \"\", name)\n            player = PlayerRecord(name)\n            playerCache[player.name] = player\n    return playerCache"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getBlizzBotPlayers():\n    ret = {}\n    for pName,p in iteritems(getKnownPlayers()):\n        if p.isComputer:\n            ret[pName] = p\n    return ret", "response": "identify all of Blizzard s built - in bots"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating HTML attributes from keyword arguments.", "response": "def get_html_attrs(kwargs=None):\n    \"\"\"Generate HTML attributes from the provided keyword arguments.\n\n    The output value is sorted by the passed keys, to provide consistent\n    output.  Because of the frequent use of the normally reserved keyword\n    `class`, `classes` is used instead. Also, all underscores are translated\n    to regular dashes.\n\n    Set any property with a `True` value.\n\n    >>> _get_html_attrs({'id': 'text1', 'classes': 'myclass',\n        'data_id': 1, 'checked': True})\n    u'class=\"myclass\" data-id=\"1\" id=\"text1\" checked'\n\n    \"\"\"\n    kwargs = kwargs or {}\n    attrs = []\n    props = []\n\n    classes = kwargs.get('classes', '').strip()\n    if classes:\n        classes = ' '.join(re.split(r'\\s+', classes))\n        classes = to_unicode(quoteattr(classes))\n        attrs.append('class=%s' % classes)\n    try:\n        del kwargs['classes']\n    except KeyError:\n        pass\n\n    for key, value in iteritems(kwargs):\n        key = key.replace('_', '-')\n        key = to_unicode(key)\n        if isinstance(value, bool):\n            if value is True:\n                props.append(key)\n        else:\n            value = quoteattr(Markup(value))\n            attrs.append(u'%s=%s' % (key, value))\n\n    attrs.sort()\n    props.sort()\n    attrs.extend(props)\n    return u' '.join(attrs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the type of the poi.", "response": "def setType(self, poiID, poiType):\n        \"\"\"setType(string, string) -> None\n\n        Sets the (abstract) type of the poi.\n        \"\"\"\n        self._connection._beginMessage(\n            tc.CMD_SET_POI_VARIABLE, tc.VAR_TYPE, poiID, 1 + 4 + len(poiType))\n        self._connection._packString(poiType)\n        self._connection._sendExact()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setPosition(self, poiID, x, y):\n        self._connection._beginMessage(\n            tc.CMD_SET_POI_VARIABLE, tc.VAR_POSITION, poiID, 1 + 8 + 8)\n        self._connection._string += struct.pack(\"!Bdd\", tc.POSITION_2D, x, y)\n        self._connection._sendExact()", "response": "Sets the position coordinates of the poi."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the rgba color of the poi.", "response": "def setColor(self, poiID, color):\n        \"\"\"setColor(string, (integer, integer, integer, integer)) -> None\n\n        Sets the rgba color of the poi.\n        \"\"\"\n        self._connection._beginMessage(\n            tc.CMD_SET_POI_VARIABLE, tc.VAR_COLOR, poiID, 1 + 1 + 1 + 1 + 1)\n        self._connection._string += struct.pack(\"!BBBBB\", tc.TYPE_COLOR, int(\n            color[0]), int(color[1]), int(color[2]), int(color[3]))\n        self._connection._sendExact()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef notify(self, method, *args, **kwargs):\n        self.protocol.send_notification(method, args, kwargs)", "response": "Perform a synchronous remote call where value no return value is desired."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef response(self, msgid, response):\n        self.requests[msgid].callback(response)\n        del self.requests[msgid]", "response": "Handle a response message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle an error message.", "response": "def error(self, msgid, error):\n        \"\"\"Handle a error message.\"\"\"\n        self.requests[msgid].errback(error)\n        del self.requests[msgid]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef connection_made(self, address):\n        self._proxy = PickleProxy(self.loop, self)\n        for d in self._proxy_deferreds:\n            d.callback(self._proxy)", "response": "Called when a connection is made."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a pickled version of the data to the internal buffer.", "response": "def data(self, data):\n        \"\"\"Use a length prefixed protocol to give the length of a pickled\n        message.\n\n        \"\"\"\n        self._buffer = self._buffer + data\n\n        while self._data_handler():\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_request(self, msgid, method, args, kwargs):\n        msg = dumps([0, msgid, method, args, kwargs])\n        self.send(msg)", "response": "Send a request to the master."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_error(self, msgid, error):\n        msg = dumps([3, msgid, error])\n        self.send(msg)", "response": "Send an error message."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle(self):\n\n        all_data = []\n        while True:\n            data = self.request.recv(1024)\n            if not data:\n                break\n\n            if self.codes.server_shutdown in data:\n                return self.__server_shutdown()\n\n            if self.codes.request_end in data:\n                all_data.append(data[:data.find(self.codes.request_end)])\n                break\n\n            all_data.append(data)\n            if len(all_data) >= 2:\n                tail = all_data[-2] + all_data[-1]\n\n                if self.codes.server_shutdown in tail:\n                    return self.__server_shutdown()\n\n                if self.codes.request_end in tail:\n                    all_data[-2] = tail[:tail.find(self.codes.request_end)]\n                    all_data.pop()\n                    break\n\n        RuntimeGlobals.requests_stack.append(\"\".join(all_data))\n        return True", "response": "Reimplement the SocketServer. BaseRequestHandler. handle method."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef activate(self, engine):\n\n        LOGGER.debug(\"> Activating '{0}' Component.\".format(self.__class__.__name__))\n\n        self.__engine = engine\n        self.__settings = self.__engine.settings\n        self.__settings_section = self.name\n\n        self.__preferences_manager = self.__engine.components_manager[\"factory.preferences_manager\"]\n\n        self.__tcp_server = TCPServer(self.__address, self.__port, RequestsStackDataHandler)\n\n        self.activated = True\n        return True", "response": "Activates the Component.\n\n        :param engine: Engine to attach the Component to.\n        :type engine: QObject\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the Component ui.", "response": "def initialize_ui(self):\n        \"\"\"\n        Initializes the Component ui.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        LOGGER.debug(\"> Initializing '{0}' Component ui.\".format(self.__class__.__name__))\n\n        self.__Port_spinBox_set_ui()\n        self.__Autostart_TCP_Server_checkBox_set_ui()\n\n        # Signals / Slots.\n        self.Port_spinBox.valueChanged.connect(self.__Port_spinBox__valueChanged)\n        self.Autostart_TCP_Server_checkBox.stateChanged.connect(\n            self.__Autostart_TCP_Server_checkBox__stateChanged)\n        self.Start_TCP_Server_pushButton.clicked.connect(self.__Start_TCP_Server_pushButton__clicked)\n        self.Stop_TCP_Server_pushButton.clicked.connect(self.__Stop_TCP_Server_pushButton__clicked)\n\n        self.initialized_ui = True\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling by the framework when the framework is started.", "response": "def on_startup(self):\n        \"\"\"\n        Defines the slot triggered on Framework startup.\n        \"\"\"\n\n        LOGGER.debug(\"> Calling '{0}' Component Framework 'on_startup' method.\".format(self.__class__.__name__))\n\n        if self.Autostart_TCP_Server_checkBox.isChecked():\n            if not self.__tcp_server.online:\n                self.__tcp_server.port = self.Port_spinBox.value()\n                self.__tcp_server.start()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the Port spinBox Widget.", "response": "def __Port_spinBox_set_ui(self):\n        \"\"\"\n        Sets the **Port_spinBox** Widget.\n        \"\"\"\n\n        # Adding settings key if it doesn't exists.\n        self.__settings.get_key(self.__settings_section, \"port\").isNull() and \\\n        self.__settings.set_key(self.__settings_section, \"port\", self.__port)\n\n        port = foundations.common.get_first_item(self.__settings.get_key(self.__settings_section, \"port\").toInt())\n        LOGGER.debug(\"> Setting '{0}' with value '{1}'.\".format(\"Port_spinBox\",\n                                                                port))\n        self.Port_spinBox.setValue(port)\n        self.__port = port"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __Autostart_TCP_Server_checkBox_set_ui(self):\n\n        # Adding settings key if it doesn't exists.\n        self.__settings.get_key(self.__settings_section, \"autostart_tcp_server\").isNull() and \\\n        self.__settings.set_key(self.__settings_section, \"autostart_tcp_server\", Qt.Checked)\n\n        autostart_tcp_server = foundations.common.get_first_item(\n            self.__settings.get_key(self.__settings_section, \"autostart_tcp_server\").toInt())\n        LOGGER.debug(\"> Setting '{0}' with value '{1}'.\".format(\"Autostart_TCP_Server_checkBox\",\n                                                                autostart_tcp_server))\n        self.Autostart_TCP_Server_checkBox.setCheckState(autostart_tcp_server)", "response": "Sets the Autostart TCP Server CheckBox Widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start_tcp_server(self, port):\n\n        self.__tcp_server.port = port\n        if not self.__tcp_server.online:\n            if self.__tcp_server.start():\n                self.__engine.notifications_manager.notify(\n                    \"{0} | TCP Server has started with '{1}' address on '{2}' port!\".format(\n                        self.__class__.__name__,\n                        self.__address,\n                        self.__port))\n                return True\n        else:\n            self.__engine.notifications_manager.warnify(\n                \"{0} | TCP Server is already online!\".format(self.__class__.__name__))\n            return False", "response": "Starts the TCP server using given port."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstop the TCP server.", "response": "def stop_tcp_server(self):\n        \"\"\"\n        Stops the TCP server.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if self.__tcp_server.online:\n            if self.__tcp_server.stop():\n                self.__engine.notifications_manager.notify(\n                    \"{0} | TCP Server has stopped!\".format(self.__class__.__name__))\n                return True\n        else:\n            self.__engine.notifications_manager.warnify(\n                \"{0} | TCP Server is not online!\".format(self.__class__.__name__))\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef address(self, value):\n\n        if value is not None:\n            assert type(value) is unicode, \"'{0}' attribute: '{1}' type is not 'unicode'!\".format(\n                \"address\", value)\n            self.Address_lineEdit.setText(value)\n        self.__address = value", "response": "Sets the value of the address attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the value of the port attribute.", "response": "def port(self, value):\n        \"\"\"\n        Setter for **self.__port** attribute.\n\n        :param value: Attribute value.\n        :type value: int\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is int, \"'{0}' attribute: '{1}' type is not 'int'!\".format(\n                \"port\", value)\n            assert type(value) >= 0 and type(value) >= 65535, \\\n                \"'{0}' attribute: '{1}' value must be in 0-65535 range!\".format(\"port\", value)\n            self.Port_spinBox.setValue(value)\n        self.__port = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connection_end(self, value):\n\n        if value is not None:\n            assert type(value) is unicode, \"'{0}' attribute: '{1}' type is not 'unicode'!\".format(\n                \"connection_end\", value)\n        self.__connection_end = value", "response": "Setter for **self. __connection_end** attribute."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the Component ui.", "response": "def initialize_ui(self):\n        \"\"\"\n        Initializes the Component ui.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        LOGGER.debug(\"> Initializing '{0}' Component ui.\".format(self.__class__.__name__))\n\n        self.__Port_spinBox_set_ui()\n        self.__Address_lineEdit_set_ui()\n        self.__File_Command_lineEdit_set_ui()\n        self.__Connection_End_lineEdit_set_ui()\n\n        self.__add_actions()\n\n        # Signals / Slots.\n        self.Port_spinBox.valueChanged.connect(self.__Port_spinBox__valueChanged)\n        self.Address_lineEdit.editingFinished.connect(self.__Address_lineEdit__editFinished)\n        self.File_Command_lineEdit.editingFinished.connect(self.__File_Command_lineEdit__editFinished)\n        self.Connection_End_lineEdit.editingFinished.connect(self.__Connection_End_lineEdit__editFinished)\n\n        self.initialized_ui = True\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef uninitialize_ui(self):\n\n        LOGGER.debug(\"> Uninitializing '{0}' Component ui.\".format(self.__class__.__name__))\n\n        self.__remove_actions()\n\n        # Signals / Slots.\n        self.Port_spinBox.valueChanged.disconnect(self.__Port_spinBox__valueChanged)\n        self.Address_lineEdit.editingFinished.disconnect(self.__Address_lineEdit__editFinished)\n        self.File_Command_lineEdit.editingFinished.disconnect(self.__File_Command_lineEdit__editFinished)\n        self.Connection_End_lineEdit.editingFinished.disconnect(self.__Connection_End_lineEdit__editFinished)\n\n        self.initialized_ui = False\n        return True", "response": "Uninitializes the Component ui."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_widget(self):\n\n        LOGGER.debug(\"> Adding '{0}' Component Widget.\".format(self.__class__.__name__))\n\n        self.__preferences_manager.Others_Preferences_gridLayout.addWidget(self.TCP_Client_Ui_groupBox)\n\n        return True", "response": "Adds the Component Widget to the engine."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove the Component Widget from the engine.", "response": "def remove_widget(self):\n        \"\"\"\n        Removes the Component Widget from the engine.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        LOGGER.debug(\"> Removing '{0}' Component Widget.\".format(self.__class__.__name__))\n\n        self.__preferences_manager.findChild(QGridLayout, \"Others_Preferences_gridLayout\").removeWidget(self)\n        self.TCP_Client_Ui_groupBox.setParent(None)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __add_actions(self):\n\n        LOGGER.debug(\"> Adding '{0}' Component actions.\".format(self.__class__.__name__))\n\n        self.__script_editor.command_menu.addSeparator()\n        self.__script_editor.command_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|addons.tcp_serverUi|&Command|Send Selection To Server\",\n            shortcut=Qt.ControlModifier + Qt.AltModifier + Qt.Key_Return,\n            slot=self.__send_selection_to_server_action__triggered))\n        self.__script_editor.command_menu.addAction(self.__engine.actions_manager.register_action(\n            \"Actions|Umbra|Components|addons.tcp_serverUi|&Command|&Send Current File To Server\",\n            shortcut=Qt.SHIFT + Qt.AltModifier + Qt.CTRL + Qt.Key_Return,\n            slot=self.__send_file_to_server_action__triggered))", "response": "Adds the actions to the command menu."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the address field in the Address_lineEdit widget.", "response": "def __Address_lineEdit_set_ui(self):\n        \"\"\"\n        Fills **Address_lineEdit** Widget.\n        \"\"\"\n\n        # Adding settings key if it doesn't exists.\n        self.__settings.get_key(self.__settings_section, \"address\").isNull() and \\\n        self.__settings.set_key(self.__settings_section, \"address\", self.__address)\n\n        address = self.__settings.get_key(self.__settings_section, \"address\").toString()\n        LOGGER.debug(\"> Setting '{0}' with value '{1}'.\".format(\"Address_lineEdit\",\n                                                                address))\n        self.__address = address\n        self.Address_lineEdit.setText(address)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __File_Command_lineEdit_set_ui(self):\n\n        # Adding settings key if it doesn't exists.\n        self.__settings.get_key(self.__settings_section, \"file_command\").isNull() and \\\n        self.__settings.set_key(self.__settings_section, \"file_command\", self.__file_command)\n\n        file_command = self.__settings.get_key(self.__settings_section, \"file_command\").toString()\n        LOGGER.debug(\"> Setting '{0}' with value '{1}'.\".format(\"File_Command_lineEdit\",\n                                                                file_command))\n        self.__file_command = file_command\n        self.File_Command_lineEdit.setText(file_command)", "response": "Sets the ui for the File_Command_lineEdit widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __Connection_End_lineEdit_set_ui(self):\n\n        # Adding settings key if it doesn't exists.\n        self.__settings.get_key(self.__settings_section, \"connection_end\").isNull() and \\\n        self.__settings.set_key(self.__settings_section, \"connection_end\", self.__connection_end)\n\n        connection_end = self.__settings.get_key(self.__settings_section, \"connection_end\").toString()\n        LOGGER.debug(\"> Setting '{0}' with value '{1}'.\".format(\"Connection_End_lineEdit\",\n                                                                connection_end))\n        self.__connection_end = connection_end\n        self.Connection_End_lineEdit.setText(connection_end)", "response": "Sets the ui for the Connection End Line edit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_data_to_server(self, data, time_out=5):\n\n        if not data.endswith(self.__connection_end):\n            data = \"{0}{1}\".format(data, foundations.strings.to_string(self.__connection_end).decode(\"string_escape\"))\n\n        connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        connection.settimeout(time_out)\n        connection.connect((foundations.strings.to_string(self.__address), int(self.__port)))\n        connection.send(data)\n        self.__engine.notifications_manager.notify(\n            \"{0} | Socket connection command dispatched!\".format(self.__class__.__name__))\n        connection.close()\n        return True", "response": "Sends given data to the Server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of all the entries in lst sorted by the given function.", "response": "def head_sorted(lst, func=cmp, reversed=False):\n    \"\"\"\n    >>> l = [2,3,1,0,6,4,7,8,5,9]\n    >>> head_sorted(l)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    >>> head_sorted(l, func=lambda a, b: cmp(b, a))\n    [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n    >>> head_sorted(l, reversed=True)\n    [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n    >>> head_sorted(l, func=lambda a, b: cmp(b, a), reversed=True)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    \"\"\"\n    def make_maxhead(lst, start, end):\n        root = start\n        while True:\n            left = root * 2 + 1\n            right = root * 2 + 2\n            if left > end:\n                break\n            child = left\n            if right <= end and func(lst[left], lst[right]) < 0:\n                child = right\n            if func(lst[root], lst[child]) < 0:\n                lst[root], lst[child] = lst[child], lst[root]\n                root = child\n            else:\n                break\n    n = len(lst)\n    for i in range(n, -1, -1):\n        make_maxhead(lst, i, n-1)\n    for end in range(n-1, -1, -1):\n        lst[0], lst[end] = lst[end], lst[0]\n        make_maxhead(lst, 0, end-1)\n    return lst[::-1] if reversed else lst"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmerge the list of items in lst sorted by func.", "response": "def merge_sorted(lst,  func=cmp, reversed=False):\n    \"\"\"\n    >>> l = [2,3,1,0,6,4,7,8,5,9]\n    >>> merge_sorted(l)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    >>> merge_sorted(l, func=lambda a, b: cmp(b, a))\n    [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n    >>> merge_sorted(l, reversed=True)\n    [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n    >>> merge_sorted(l, func=lambda a, b: cmp(b, a), reversed=True)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    \"\"\"\n    assert isinstance(lst, list)\n    if len(lst) <= 1:\n        return lst\n\n    def merge(a, b):\n        mlst = []\n        while a and b:\n            mlst.append(a.pop(0) if func(a[0], b[0]) < 0 else b.pop(0))\n        return mlst + a + b\n    m = int(len(lst) / 2)\n    a = merge_sorted(lst[:m], func=func)\n    b = merge_sorted(lst[m:], func=func)\n    l = merge(a, b)\n    return l[::-1] if reversed else l"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_url(self, environ):\n        if self.override_url:\n            url = self.override_url\n        else:\n            # PEP333: wsgi.url_scheme, HTTP_HOST, SERVER_NAME, and SERVER_PORT\n            # can be used to reconstruct a request's complete URL\n\n            # Much of the following is copied from bottle.py\n            http = (environ.get('HTTP_X_FORWARDED_PROTO') or\n                    environ.get('wsgi.url_scheme', 'http'))\n            host = (environ.get('HTTP_X_FORWARDED_HOST') or\n                    environ.get('HTTP_HOST'))\n            if not host:\n                # HTTP 1.1 requires a Host-header. This is for HTTP/1.0\n                # clients.\n                host = environ.get('SERVER_NAME', '127.0.0.1')\n                port = environ.get('SERVER_PORT')\n                if port and port != ('80' if http == 'http' else '443'):\n                    host += ':' + port\n            url = \"%s://%s\" % (http, host)\n        return url", "response": "Return the base URL for the current session."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef populate_context(self, context, environ):\n        url = self.get_url(environ)\n        context['base_url'] = url\n        transaction_id = uuid.uuid4().hex\n        context['transaction_id'] = transaction_id\n        LOG.debug(\"Context created: base_url=%s, tid=%s\", url, transaction_id)", "response": "Set initial context values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start_response_callback(start_response, transaction_id):\n        def callback(status, headers, exc_info=None):\n            \"\"\"Add our headers to response using a closure.\"\"\"\n            headers.append(('X-Transaction-Id', transaction_id))\n            # Call upstream start_response\n            start_response(status, headers, exc_info)\n        return callback", "response": "Create a callback that adds our headers to the response."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef vd(inc, sd):\n    return abs(sd * math.sin(math.radians(inc)))", "response": "Calculate vertical distance.\n\n    :param inc: (float) inclination angle in degrees\n    :param sd:  (float) slope distance in any units"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the cartesian coordinate offset.", "response": "def cartesian_offset(azm, inc, sd, origin=(0, 0)):\n    \"\"\"\n    Calculate the (X, Y) cartesian coordinate offset.\n\n    :param azm:    (float) azimuth angle in degrees\n    :param inc:    (float) inclination angle in degrees\n    :param sd:     (float) slope distance in any units\n    :param origin: (tuple(float, float)) optional origin coordinate\n    \"\"\"\n    hd = sd * math.cos(math.radians(inc))\n    x = hd * math.sin(math.radians(azm))\n    y = hd * math.cos(math.radians(azm))\n    return (x, y) if not origin else (x+origin[0], y+origin[1])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nassembling a request and return the ID of the request.", "response": "def call(self, method, *args, **kw):\n        \"\"\"\n        In context of a batch we return the request's ID\n        else we return the actual json\n        \"\"\"\n        if args and kw:\n            raise ValueError(\"JSON-RPC method calls allow only either named or positional arguments.\")\n        if not method:\n            raise ValueError(\"JSON-RPC method call requires a method name.\")\n\n        request = self._data_serializer.assemble_request(\n            method, args or kw or None\n        )\n\n        if self._in_batch_mode:\n            self._requests.append(request)\n            return request.get('id')\n        else:\n            return request"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all amqp settings in dict in following format ::", "response": "def get_amqp_settings():\n    \"\"\"\n    Return all settings in dict in following format::\n\n        {\n            \"submodule_name\": {\n                \"vhost\": VIRTUALHOST,\n                \"exchange\": EXCHANGE,\n                \"queues\": {\n                    QUEUE_NAME: ROUTING_KEY,\n                    QUEUE_NAME: ROUTING_KEY\n                },\n                \"in_key\": INPUT_KEY,\n                \"out_key\": OUTPUT_KEY\n            },\n            ...\n        }\n    \"\"\"\n    amqp_settings = {}\n    for vhost in filter(lambda x: x.endswith(\"VIRTUALHOST\"), globals().keys()):\n        vhost = \"RABBITMQ_\" + vhost.split(\"_\")[1]\n\n        queues = {\n            globals()[vhost + \"_INPUT_QUEUE\"]: globals()[vhost + \"_INPUT_KEY\"],\n            globals()[vhost + \"_OUTPUT_QUEUE\"]: globals()[vhost + \"_OUTPUT_KEY\"]\n        }\n\n        amqp_settings[vhost.split(\"_\")[-1].lower()] = {\n            \"vhost\": globals()[vhost + \"_VIRTUALHOST\"],\n            \"exchange\": globals()[vhost + \"_EXCHANGE\"],\n            \"queues\": queues,\n            \"in_key\": globals()[vhost + \"_INPUT_KEY\"],\n            \"out_key\": globals()[vhost + \"_OUTPUT_KEY\"]\n        }\n\n    return amqp_settings"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef substitute_globals(config_dict):\n    constants = get_all_constants()\n\n    if type(config_dict) != dict:\n        return\n\n    for key in config_dict.keys():\n        if key in constants and type(config_dict[key]) in _ALLOWED:\n            globals()[key] = config_dict[key]", "response": "Substitute all the global variables defined in config_dict with values defined in globals."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef status(self):\n        if all(os.path.exists(p.path) for p in self.parts): return 'splitted'\n        return False", "response": "Returns whether the split has been done already?"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clear(self):\n        db = sqlite3.connect(self.path)\n        c = db.cursor()\n        c.execute(\"DELETE FROM dirhashcache\")\n        db.commit()\n        db.close()", "response": "Remove all cache entries."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes the hash of a directory.", "response": "def dirhash(self, path, **dirhash_opts):\n        \"\"\"\n        Compute the hash of a directory.\n\n        Arguments:\n           path: Directory.\n           **dirhash_opts: Additional options to checksumdir.dirhash().\n\n        Returns:\n            str: Checksum of directory.\n        \"\"\"\n        path = fs.path(path)\n        last_modified = time.ctime(max(\n            max(os.path.getmtime(os.path.join(root, file)) for file in files)\n            for root,_,files in os.walk(path)))\n\n        db = sqlite3.connect(self.path)\n        c = db.cursor()\n        c.execute(\"SELECT date, hash FROM dirhashcache WHERE path=?\", (path,))\n        cached = c.fetchone()\n\n        if cached:\n            cached_date, cached_hash = cached\n            if cached_date == last_modified:\n                # cache hit\n                dirhash = cached_hash\n            else:\n                # out of date cache\n                dirhash = checksumdir.dirhash(path, self.hash, **dirhash_opts)\n                c.execute(\"UPDATE dirhashcache SET date=?, hash=? WHERE path=?\",\n                          (last_modified, dirhash, path))\n                db.commit()\n        else:\n            # new entry\n            dirhash = checksumdir.dirhash(path, self.hash, **dirhash_opts)\n            c.execute(\"INSERT INTO dirhashcache VALUES (?,?,?)\",\n                      (path, last_modified, dirhash))\n            db.commit()\n\n        db.close()\n        return dirhash"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading the contents of the named class from the database.", "response": "def read_contents(self, schema, name, conn):\n        '''Read table columns'''\n        sql = '''\nwith schemas as\n(select n.oid,\n        n.nspname as name\n  from pg_catalog.pg_namespace n),\ntables as\n(select c.oid,\n        c.relnamespace as schema_oid,\n        c.relname as name\n from pg_catalog.pg_class c\n where c.relkind in ('r','v','m','f'))\nselect a.attname,\n       ty.typname,\n       d.description\n from\n    schemas s\n    join tables t on (s.oid = t.schema_oid)\n    join pg_catalog.pg_attribute a on (a.attrelid = t.oid)\n    join pg_catalog.pg_type ty on (ty.oid = a.atttypid)\n    left join pg_catalog.pg_description d on\n    (d.objoid = a.attrelid and d.objsubid = coalesce(a.attnum,d.objsubid))\nwhere s.name = %s and\n      t.name = %s and\n      coalesce(a.attnum,1) > 0\norder by s.name,t.name,a.attnum'''\n        log = get_logger()\n        cur = conn.cursor()\n        cur.execute(sql, [schema, name])\n        columns = cur.fetchall()\n        for column in columns:\n            column_dict = {'name': column[0],\n                           'type': column[1],\n                           'comment': column[2]}\n            log.debug('{} {}: {}'.format(column[0], column[1], column[2]))\n            self.contents.append(copy.deepcopy(column_dict))\n        cur.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sendCommand(self, command):\n    data = { 'rapi' : command }\n    full_url = self.url + urllib.parse.urlencode(data)\n    data = urllib.request.urlopen(full_url)\n    response = re.search('\\<p>&gt;\\$(.+)\\<script', data.read().decode('utf-8'))\n    if response == None:#If we are using version 1 - https://github.com/OpenEVSE/ESP8266_WiFi_v1.x/blob/master/OpenEVSE_RAPI_WiFi_ESP8266.ino#L357\n      response = re.search('\\>\\>\\$(.+)\\<p>', data.read().decode('utf-8'))\n    return response.group(1).split()", "response": "Sends a command through the web interface of the charger and parses the response"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getStatus(self):\n    command = '$GS'\n    status = self.sendCommand(command)\n    return states[int(status[1])]", "response": "Returns the charger s charge status as a string"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getChargeTimeElapsed(self):\n    command = '$GS'\n    status = self.sendCommand(command)\n    if int(status[1]) == 3:\n      return int(status[2])\n    else:\n      return 0", "response": "Returns the charge time elapsed in seconds"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getServiceLevel(self):\n    command = '$GE'\n    settings = self.sendCommand(command)\n    flags = int(settings[2], 16)\n    return (flags & 0x0001) + 1", "response": "Returns the service level of the current node"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if Diode Check is enabled False if disabled", "response": "def getDiodeCheckEnabled(self):\n    \"\"\"Returns True if enabled, False if disabled\"\"\"\n    command = '$GE'\n    settings = self.sendCommand(command)\n    flags = int(settings[2], 16)\n    return not (flags & 0x0002)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getVentRequiredEnabled(self):\n    command = '$GE'\n    settings = self.sendCommand(command)\n    flags = int(settings[2], 16)\n    return not (flags & 0x0004)", "response": "Returns True if the vent required is enabled False if disabled"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if ground check is enabled False if disabled", "response": "def getGroundCheckEnabled(self):\n    \"\"\"Returns True if enabled, False if disabled\"\"\"\n    command = '$GE'\n    settings = self.sendCommand(command)\n    flags = int(settings[2], 16)\n    return not (flags & 0x0008)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getStuckRelayCheckEnabled(self):\n    command = '$GE'\n    settings = self.sendCommand(command)\n    flags = int(settings[2], 16)\n    return not (flags & 0x0010)", "response": "Returns True if stuck relay check is enabled False if disabled"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if auto service level is enabled False if disabled", "response": "def getAutoServiceLevelEnabled(self):\n    \"\"\"Returns True if enabled, False if disabled\"\"\"\n    command = '$GE'\n    settings = self.sendCommand(command)\n    flags = int(settings[2], 16)\n    return not (flags & 0x0020)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getAutoStartEnabled(self):\n    command = '$GE'\n    settings = self.sendCommand(command)\n    flags = int(settings[2], 16)\n    return not (flags & 0x0040)", "response": "Returns True if auto start is enabled False if disabled"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getSerialDebugEnabled(self):\n    command = '$GE'\n    settings = self.sendCommand(command)\n    flags = int(settings[2], 16)\n    return not (flags & 0x0080)", "response": "Returns True if serial debug is enabled False if disabled"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns LCD type as a string either monochrome or rgb", "response": "def getLCDType(self):\n    \"\"\"Returns LCD type as a string, either monochrome or rgb\"\"\"\n    command = '$GE'\n    settings = self.sendCommand(command)\n    flags = int(settings[2], 16)\n    if flags & 0x0100:\n      lcdtype = 'monochrome'\n    else:\n      lcdtype = 'rgb'\n    return lcdtype"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the charging current in amps or 0. 0 of not charging", "response": "def getChargingCurrent(self):\n    \"\"\"Returns the charging current, in amps, or 0.0 of not charging\"\"\"\n    command = '$GG'\n    currentAndVoltage = self.sendCommand(command)\n    amps = float(currentAndVoltage[1])/1000\n    return amps"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getChargingVoltage(self):\n    command = '$GG'\n    currentAndVoltage = self.sendCommand(command)\n    volts = float(currentAndVoltage[2])/1000\n    return volts", "response": "Returns the charging voltage in volts or 0. 0 of not charging"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getAmbientThreshold(self):\n    command = '$GO'\n    threshold = self.sendCommand(command)\n    if threshold[0] == 'NK':\n      return 0\n    else:\n      return float(threshold[1])/10", "response": "Returns the ambient temperature threshold in degrees Celcius or 0 if no Threshold is set"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the IR temperature threshold in degrees Celcius or 0 if no Threshold is set", "response": "def getIRThreshold(self):\n    \"\"\"Returns the IR temperature threshold in degrees Celcius, or 0 if no Threshold is set\"\"\"\n    command = '$GO'\n    threshold = self.sendCommand(command)\n    if threshold[0] == 'NK':\n      return 0\n    else:\n      return float(threshold[2])/10"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a datetime object or NULL if the clock is not set", "response": "def getTime(self):\n    \"\"\"Get the RTC time.  Returns a datetime object, or NULL if the clock is not set\"\"\"\n    command = '$GT'\n    time = self.sendCommand(command)\n    if time == ['OK','165', '165', '165', '165', '165', '85']:\n      return NULL\n    else:\n      return datetime.datetime(year = int(time[1])+2000,\n                               month = int(time[2]),\n                               day = int(time[3]),\n                               hour = int(time[4]),\n                               minute = int(time[5]),\n                               second = int(time[6]))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef closed(self, reason):\n        self.client.remove_connection(self)\n        self.protocol.connection_lost(reason)\n        if not isinstance(reason, ConnectionClosed):\n            logger.warn(\"connection closed, reason {}\".format(reason))\n        else:\n            logger.info(\"connection closed\")", "response": "Callback performed when the transport is closed."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts the connector state machine.", "response": "def start(self):\n        \"\"\"Start the connector state machine.\"\"\"\n        if self.started:\n            raise ConnectorStartedError()\n\n        self.started = True\n\n        try:\n            self.connect_watcher.start()\n            self.timeout_watcher.start()\n            self.sock.connect(self.addr)\n        except IOError as e:\n            self.errored = True\n            self._finish()\n            self.deferred.errback(e)\n\n        return self.deferred"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncancel a connector from completing.", "response": "def cancel(self):\n        \"\"\"Cancel a connector from completing.\"\"\"\n        if self.started and not self.connected and not self.timedout:\n            self.connect_watcher.stop()\n            self.timeout_watcher.stop()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _connected(self, watcher, events):\n        self.connected = True\n        self._finish()\n        self.deferred.callback(self.sock)", "response": "Called when the socket is connected."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts watching the socket for it to be writtable.", "response": "def _connect(self, sock, addr, timeout):\n        \"\"\"Start watching the socket for it to be writtable.\"\"\"\n        if self.connection:\n            raise SocketClientConnectedError()\n\n        if self.connector:\n            raise SocketClientConnectingError()\n\n        self.connect_deferred = Deferred(self.loop)\n        self.sock = sock\n        self.addr = addr\n        self.connector = Connector(self.loop, sock, addr, timeout)\n        self.connector.deferred.add_callback(self._connected)\n        self.connector.deferred.add_errback(self._connect_failed)\n        self.connector.start()\n\n        return self.connect_deferred"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling when the socket is ready to be used.", "response": "def _connected(self, sock):\n        \"\"\"When the socket is writtable, the socket is ready to be used.\"\"\"\n        logger.debug('socket connected, building protocol')\n        self.protocol = self.factory.build(self.loop)\n        self.connection = Connection(self.loop, self.sock, self.addr,\n            self.protocol, self) \n        self.connector = None\n        self.connect_deferred.callback(self.protocol)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_vcenter_vm_uuid_by_name(host, user, password, vm_name):\n    vc = VcenterInterface(host, user, password)\n    vmi = VmInterface(vc, vm_name)\n    return vmi.get_instance_uuid()", "response": "Get a uuid from vCenter API by name"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget location from sina.", "response": "def get_location_from_sina(ip):\n    \"\"\"\n        {\n            \"ret\":1,\n            \"start\":\"58.18.0.0\",\n            \"end\":\"58.18.15.255\",\n            \"country\":\"\u4e2d\u56fd\",\n            \"province\":\"\u5185\u8499\u53e4\",\n            \"city\":\"\u5174\u5b89\",\n            \"district\":\"\",\n            \"isp\":\"\u8054\u901a\",\n            \"type\":\"\",\n            \"desc\":\"\"\n        }\n    \"\"\"\n    global sina\n    response = requests.get(sina % ip)\n    if not response.status_code == 200:\n        return\n    l = json.loads(response.content)\n    if not l['ret'] == 1:\n        return\n    return (\"%s,%s,%s,%s\" % (l['country'], l['province'], l['city'], l['isp'])).encode('utf8')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_location_from_taobao(ip):\n    global taobao\n    response = requests.get(taobao % ip)\n    if not response.status_code == 200:\n        return\n    l = json.loads(response.content)\n    if not l['code'] == 0:\n        return\n    l = l['data']\n    return (\"%s,%s,%s,%s,%s\" % (l['country'], l['area'], l['region'], l['city'], l['isp'])).encode('utf8')", "response": "Get location from taobao."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_week_start_end_day():\n    t = date.today()\n    wd = t.weekday()\n    return (t - timedelta(wd), t + timedelta(6 - wd))", "response": "Get the week start date and end date"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_month_start_end_day():\n    t = date.today()\n    n = mdays[t.month]\n    return (date(t.year, t.month, 1), date(t.year, t.month, n))", "response": "Get the month start date a nd end date"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef transformation_matrix(x_vector, y_vector, translation, spacing):\n    matrix = numpy.zeros((4, 4), dtype=numpy.float)\n    matrix[:3, 0] = x_vector\n    matrix[:3, 1] = y_vector\n    z_vector = numpy.cross(x_vector, y_vector)\n    matrix[:3, 2] = z_vector\n    matrix[:3, 3] = numpy.array(translation)\n    matrix[3, 3] = 1.0\n\n    # make sure that we can append to spacing\n    spacing = list(spacing)\n    while len(spacing) < 4:\n        spacing.append(1.0)\n    for i in range(4):\n        for j in range(4):\n            matrix[i, j] *= spacing[j]\n    return matrix", "response": "Creates a transformation matrix which will convert from a specified\n    coordinate system to the scanner frame of reference."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef always(func: Callable[[], Generator]) -> AlwaysFixture:\n    global user_always\n\n    if user_always is not None:\n        raise RuntimeError('Multiple definitions of @always fixture.')\n\n    as_context_manager = contextmanager(func)\n    user_always = as_context_manager\n    return as_context_manager", "response": "Decorator that registers an always fixture which is always run before all provider\n    state fixtures and faasport call."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_args(args=None):\n\n    parser = argparse.ArgumentParser(description=ds.ARGPARSER['description'])\n    parser.add_argument('input',\n                        help=ds.ARGPARSE_INPUT['help'])\n    parser.add_argument('output',\n                        nargs='?',\n                        help=ds.ARGPARSE_OUTPUT['help'],\n                        default=ds.ARGPARSE_OUTPUT['default'])\n    parser.add_argument('-X', '--overwrite',\n                        help=ds.ARGPARSE_OVERWRITE['help'],\n                        action='store_true')\n    parser.add_argument('-e', '--extensions',\n                        nargs='+',\n                        default=ds.ARGPARSE_EXTENSION['default'],\n                        help=ds.ARGPARSE_EXTENSION['help'])\n    parser.add_argument('-w', '--wrapper',\n                        help=ds.ARGPARSE_WRAPPER['help'],\n                        default=ds.ARGPARSE_WRAPPER['default'], )\n    parser.add_argument('-v', '--verbose',\n                        help=ds.ARGPARSE_VERBOSE['help'],\n                        action='store_true')\n    parser.add_argument('-r', '-R',\n                        help=ds.ARGPARSE_RECURSIVE['help'],\n                        action='store_true',\n                        dest='recursive')\n    parser.add_argument('--version',\n                        action='version',\n                        version=ah.__version__)\n\n    if args is not None:\n        return parser.parse_args(args)\n    else:\n        return parser.parse_args()", "response": "Parse command - line arguments and return a namespace containing the arguments matching the arguments. If args is None parse all arguments and return a namespace containing arguments matching the arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(self,*fields,**kw):\r\n        mode = kw.get(\"mode\",None)\r\n        if self._table_exists():\r\n            if mode == \"override\":\r\n                self.cursor.execute(\"DROP TABLE %s\" %self.name)\r\n            elif mode == \"open\":\r\n                return self.open()\r\n            else:\r\n                raise IOError,\"Base %s already exists\" %self.name\r\n        self.fields = [ f[0] for f in fields ]\r\n        self.all_fields = [\"__id__\",\"__version__\"]+self.fields\r\n        _types = [\"INTEGER PRIMARY KEY %s\" %self.auto_increment,\"INTEGER\"] + \\\r\n            [f[1] for f in fields]\r\n        f_string = [ \"%s %s\" %(f,t) for (f,t) in zip(self.all_fields,_types)]\r\n        self.types = dict([ (f[0],self.conv_func[f[1].upper()]) \r\n            for f in fields if f[1].upper() in self.conv_func ])\r\n        sql = \"CREATE TABLE %s (%s)\" %(self.name,\",\".join(f_string))\r\n        self.cursor.execute(sql)\r\n        return self", "response": "Create a new base with the specified field names."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nopening an existing database", "response": "def open(self):\r\n        \"\"\"Open an existing database\"\"\"\r\n        if self._table_exists():\r\n            self.mode = \"open\"\r\n            # get table info\r\n            self._get_table_info()\r\n            self.types = dict([ (f[0],self.conv_func[f[1].upper()]) \r\n                for f in self.fields if f[1].upper() in self.conv_func ])\r\n            return self\r\n        else:\r\n            # table not found\r\n            raise IOError,\"Table %s doesn't exist\" %self.name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete(self,removed):\r\n        if isinstance(removed,dict):\r\n            # remove a single record\r\n            removed = [removed]\r\n        else:\r\n            # convert iterable into a list (to be able to sort it)\r\n            removed = [ r for r in removed ]\r\n        if not removed:\r\n            return 0\r\n        _ids = [ r['__id__'] for r in removed ]\r\n        _ids.sort()\r\n        sql = \"DELETE FROM %s WHERE __id__ IN (%s)\" %(self.name,\r\n            \",\".join([str(_id) for _id in _ids]))\r\n        self.cursor.execute(sql)\r\n        return len(removed)", "response": "Remove a single record or an iterable of records from the base table"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake a list of strings to pass to an SQL statement from the dictionary kw with Python types", "response": "def _make_sql_params(self,kw):\r\n        \"\"\"Make a list of strings to pass to an SQL statement\r\n        from the dictionary kw with Python types\"\"\"\r\n        vals = []\r\n        for k,v in kw.iteritems():\r\n            vals.append('%s=%s' %(k,self._conv(v)))\r\n        return vals"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert Python values to MySQL values", "response": "def _conv(self,v):\r\n        \"\"\"Convert Python values to MySQL values\"\"\"\r\n        if isinstance(v,str):\r\n            return '\"%s\"' %v.replace(\"'\",\"''\")\r\n        elif isinstance(v,datetime.datetime):\r\n            if v.tzinfo is not None:\r\n                raise ValueError,\\\r\n                    \"datetime instances with tzinfo not supported\"\r\n            return '\"%s\"' %self.db_module.Timestamp(v.year,v.month,v.day,\r\n                v.hour,v.minute,v.second)\r\n        elif isinstance(v,datetime.date):\r\n            return '\"%s\"' %self.db_module.Date(v.year,v.month,v.day)\r\n        else:\r\n            return v"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _make_record(self,row):\r\n        res = dict(zip(self.all_fields,row))\r\n        for k in self.types:\r\n            res[k] = self.types[k](res[k])\r\n        return res", "response": "Make a record dictionary from the result of a fetch_"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef objects_from_queryset(queryset, using='default'):\n    # Now collate the objects to be serialized.\n    objects = []\n\n    if using:\n        queryset = queryset.using(using)\n\n    results = list(queryset)\n    if not results:\n        return []\n\n    objs_to_check = [results[:]]\n    while objs_to_check:\n        i_objs = objs_to_check.pop(0)\n        i_model = i_objs[0].__class__\n\n        # Handle O2M dependencies\n        for field in (f for f in i_model._meta.fields if isinstance(f, ForeignKey)):\n            qs = field.rel.to._default_manager\n            if using:\n                qs = qs.using(using)\n            i_res = [o for o\n                     in qs.filter(pk__in=[getattr(r, field.column) for r in i_objs])\n                     if o not in results]\n            if i_res:\n                objs_to_check.append(i_res)\n                results.extend(i_res)\n\n        # Handle M2M dependencies\n        # TODO: this could be a lot more efficient on the SQL query\n        for field in i_model._meta.many_to_many:\n            i_res = [o for o\n                     in itertools.chain(*[getattr(r, field.name).all() for r in i_objs])\n                     if o not in results]\n            if i_res:\n                objs_to_check.append(i_res)\n                results.extend(i_res)\n\n    for obj in results:\n        if obj not in objects:\n            objects.append(obj)\n\n    return objects", "response": "Serializes objects from the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sort_dependencies(objects):\n    from django.db.models import get_model\n    # Process the list of models, and get the list of dependencies\n    model_dependencies = []\n    models = set()\n    model_list = set()\n    objs_by_model = defaultdict(list)\n    for o in objects:\n        model = o.__class__\n        objs_by_model[model].append(o)\n        model_list.add(model)\n\n    for model in model_list:\n        models.add(model)\n        # Add any explicitly defined dependencies\n        if hasattr(model, 'natural_key'):\n            deps = getattr(model.natural_key, 'dependencies', [])\n            if deps:\n                deps = [get_model(*d.split('.')) for d in deps]\n        else:\n            deps = []\n\n        # Now add a dependency for any FK or M2M relation with\n        # a model that defines a natural key\n        for field in itertools.chain(model._meta.fields, model._meta.many_to_many):\n            if hasattr(field.rel, 'to') and field.rel.to != model:\n                deps.append(field.rel.to)\n        model_dependencies.append((model, deps))\n\n    model_dependencies.reverse()\n    # Now sort the models to ensure that dependencies are met. This\n    # is done by repeatedly iterating over the input list of models.\n    # If all the dependencies of a given model are in the final list,\n    # that model is promoted to the end of the final list. This process\n    # continues until the input list is empty, or we do a full iteration\n    # over the input models without promoting a model to the final list.\n    # If we do a full iteration without a promotion, that means there are\n    # circular dependencies in the list.\n    model_list = []\n    while model_dependencies:\n        skipped = []\n        changed = False\n        while model_dependencies:\n            model, deps = model_dependencies.pop()\n\n            # If all of the models in the dependency list are either already\n            # on the final model list, or not on the original serialization list,\n            # then we've found another model with all it's dependencies satisfied.\n            found = True\n            for candidate in ((d not in models or d in model_list) for d in deps):\n                if not candidate:\n                    found = False\n            if found:\n                model_list.append(model)\n                changed = True\n            else:\n                skipped.append((model, deps))\n        if not changed:\n            raise CommandError(\"Can't resolve dependencies for %s in serialized app list.\" %\n                ', '.join('%s.%s' % (model._meta.app_label, model._meta.object_name)\n                for model, deps in sorted(skipped, key=lambda obj: obj[0].__name__))\n            )\n        model_dependencies = skipped\n\n    sorted_results = []\n    for model in model_list:\n        sorted_results.extend(objs_by_model[model])\n\n    return sorted_results", "response": "Sort a list of objects by their model dependancy graph."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle(self, *app_labels, **options):\n        # TODO: excluded_apps doesnt correctly handle foo.bar if you're not using app_labels\n        format = options.get('format', 'json')\n        indent = options.get('indent', None)\n        limit = options.get('limit', None)\n        sort = options.get('sort', None)\n        using = options.get('database', None)\n        exclude = options.get('exclude', [])\n        show_traceback = options.get('traceback', True)\n        use_natural_keys = options.get('use_natural_keys', False)\n\n        model_list = self._get_model_list(app_labels, exclude)\n\n        # Check that the serialization format exists; this is a shortcut to\n        # avoid collating all the objects and _then_ failing.\n        try:\n            serializers.get_serializer(format)\n        except KeyError:\n            raise CommandError(\"Unknown serialization format: %s\" % format)\n\n        # Now collate the objects to be serialized.\n        objects = []\n        for model in model_list:\n            if not self._can_dump_model(model, using):\n                continue\n\n            queryset = self._get_query_set(model, sort, using)[:limit]\n\n            objects.extend(objects_from_queryset(queryset, using=using))\n\n        objects = sort_dependencies(objects)\n\n        try:\n            return serializers.serialize(format, objects, indent=indent,\n                        use_natural_keys=use_natural_keys)\n        except Exception, e:\n            if show_traceback:\n                raise\n            raise CommandError(\"Unable to serialize database: %s\" % e)", "response": "Serializes objects from the database.\n\n        Works much like Django's ``manage.py dumpdata``, except that it allows you to\n        limit and sort the apps that you're pulling in, as well as automatically follow\n        the dependency graph to pull in related objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef default_project(self, value):\n\n        if value is not None:\n            assert type(value) is unicode, \\\n                \"'{0}' attribute: '{1}' type is not 'unicode'!\".format(\"default_project\", value)\n        self.__default_project = value", "response": "Sets the default project of the object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_project_nodes(self, ignore_default_project_node=True):\n\n        project_nodes = self.find_family(\"Project\")\n        return filter(lambda x: x != self.__default_project_node, project_nodes) \\\n            if ignore_default_project_node else project_nodes", "response": "Returns the list of ProjectNode objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_editors(self, node=None):\n\n        return [editor_node.editor for editor_node in self.list_editor_nodes(node) if editor_node.editor]", "response": "Returns the list of Model editors."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_files(self, node=None):\n\n        return [file_node.path for file_node in self.list_file_nodes(node) if file_node.path]", "response": "Returns the list of files in the Model."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_projects(self, ignore_default_project_node=True):\n\n        return [project_node.path for project_node in self.list_project_nodes(ignore_default_project_node) if\n                project_node.path]", "response": "Returns the list of Model projects."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the list of EditorNode class Nodes with given editor.", "response": "def get_editor_nodes(self, editor, node=None):\n        \"\"\"\n        Returns the :class:`umbra.components.factory.script_editor.nodes.EditorNode` class Nodes with given editor.\n\n        :param node: Node to start walking from.\n        :type node: AbstractNode or AbstractCompositeNode or Object\n        :param editor: Editor.\n        :type editor: Editor\n        :return: EditorNode nodes.\n        :rtype: list\n        \"\"\"\n\n        return [editor_node for editor_node in self.list_editor_nodes(node) if editor_node.editor == editor]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_file_nodes(self, path, node=None):\n\n        return [file_node for file_node in self.list_file_nodes(node) if file_node.path == path]", "response": "Returns the list of FileNode class Nodes with given path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the list of DirectoryNode class Nodes with given path.", "response": "def get_directory_nodes(self, path):\n        \"\"\"\n        Returns the :class:`umbra.components.factory.script_editor.nodes.DirectoryNode` class Nodes with given path.\n\n        :param path: Directory path.\n        :type path: unicode\n        :return: DirectoryNode nodes.\n        :rtype: list\n        \"\"\"\n\n        return [directory_node for directory_node in self.list_directory_nodes() if directory_node.path == path]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_project_nodes(self, path):\n\n        return [project_node for project_node in self.list_project_nodes() if project_node.path == path]", "response": "Returns the list of nodes with given path."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmoves given parent child to given index.", "response": "def move_node(self, parent, from_index, to_index):\n        \"\"\"\n        Moves given parent child to given index.\n\n        :param to_index: Index to.\n        :type to_index: int\n        :param from_index: Index from.\n        :type from_index: int\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        # TODO: Should be refactored once this ticket is fixed:\n        # https://bugreports.qt-project.org/browse/PYSIDE-78\n        if not from_index >= 0 or \\\n                not from_index < parent.children_count() or \\\n                not to_index >= 0 or \\\n                not to_index < parent.children_count():\n            return False\n\n        parent_index = self.get_node_index(parent)\n        self.beginRemoveRows(parent_index, from_index, from_index)\n        child = parent.remove_child(from_index)\n        self.endRemoveRows()\n\n        start_index = parent.children_count() - 1\n        end_index = to_index - 1\n\n        tail = []\n        for i in range(start_index, end_index, -1):\n            self.beginRemoveRows(parent_index, i, i)\n            tail.append(parent.remove_child(i))\n            self.endRemoveRows()\n        tail = list(reversed(tail))\n        tail.insert(0, child)\n\n        for node in tail:\n            row = parent.children_count()\n            self.beginInsertRows(parent_index, row, row)\n            parent.add_child(node)\n            self.endInsertRows()\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nregistering given file in the Model.", "response": "def register_file(self, file, parent, ensure_uniqueness=False):\n        \"\"\"\n        Registers given file in the Model.\n\n        :param file: File to register.\n        :type file: unicode\n        :param parent: FileNode parent.\n        :type parent: GraphModelNode\n        :param ensure_uniqueness: Ensure registrar uniqueness.\n        :type ensure_uniqueness: bool\n        :return: FileNode.\n        :rtype: FileNode\n        \"\"\"\n\n        if ensure_uniqueness:\n            if self.get_file_nodes(file):\n                raise foundations.exceptions.ProgrammingError(\"{0} | '{1}' file is already registered!\".format(\n                    self.__class__.__name__, file))\n\n        LOGGER.debug(\"> Registering '{0}' file.\".format(file))\n\n        row = parent.children_count()\n        self.beginInsertRows(self.get_node_index(parent), row, row)\n        file_node = FileNode(name=os.path.basename(file),\n                             path=file,\n                             parent=parent)\n        self.endInsertRows()\n\n        self.file_registered.emit(file_node)\n\n        return file_node"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unregister_file(self, file_node, raise_exception=False):\n\n        if raise_exception:\n            if not file_node in self.list_file_nodes():\n                raise foundations.exceptions.ProgrammingError(\"{0} | '{1}' file 'FileNode' isn't registered!\".format(\n                    self.__class__.__name__, file_node))\n\n        LOGGER.debug(\"> Unregistering '{0}' file 'FileNode'.\".format(file_node))\n\n        parent = file_node.parent\n        row = file_node.row()\n        self.beginRemoveRows(self.get_node_index(parent), row, row)\n        parent.remove_child(row)\n        self.endRemoveRows()\n\n        self.file_unregistered.emit(file_node)\n\n        return file_node", "response": "Unregisters given FileNode from the Model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_directory(self, directory, parent, ensure_uniqueness=False):\n\n        if ensure_uniqueness:\n            if self.get_directory_nodes(directory):\n                raise foundations.exceptions.ProgrammingError(\"{0} | '{1}' directory is already registered!\".format(\n                    self.__class__.__name__, directory))\n\n        LOGGER.debug(\"> Registering '{0}' directory.\".format(directory))\n\n        row = parent.children_count()\n        self.beginInsertRows(self.get_node_index(parent), row, row)\n        directory_node = DirectoryNode(name=os.path.basename(directory),\n                                       path=directory,\n                                       parent=parent)\n        self.endInsertRows()\n\n        self.directory_registered.emit(directory_node)\n\n        return directory_node", "response": "Registers given directory in the Model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering given editor in the Model.", "response": "def register_editor(self, editor, parent, ensure_uniqueness=False):\n        \"\"\"\n        Registers given :class:`umbra.components.factory.script_editor.editor.Editor` class editor in the Model.\n\n        :param editor: Editor to register.\n        :type editor: Editor\n        :param parent: EditorNode parent.\n        :type parent: GraphModelNode\n        :param ensure_uniqueness: Ensure registrar uniqueness.\n        :type ensure_uniqueness: bool\n        :return: EditorNode.\n        :rtype: EditorNode\n        \"\"\"\n\n        if ensure_uniqueness:\n            if self.get_editor_nodes(editor):\n                raise foundations.exceptions.ProgrammingError(\"{0} | '{1}' editor is already registered!\".format(\n                    self.__class__.__name__, editor))\n\n        LOGGER.debug(\"> Registering '{0}' editor.\".format(editor))\n\n        row = parent.children_count()\n        self.beginInsertRows(self.get_node_index(parent), row, row)\n        editor_node = EditorNode(editor=editor,\n                                 parent=parent)\n        self.endInsertRows()\n\n        self.editor_registered.emit(editor_node)\n\n        return editor_node"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unregister_editor(self, editor_node, raise_exception=False):\n\n        if raise_exception:\n            if not editor_node in self.list_editor_nodes():\n                raise foundations.exceptions.ProgrammingError(\n                    \"{0} | '{1}' editor 'EditorNode' isn't registered!\".format(\n                        self.__class__.__name__, editor_node))\n\n        LOGGER.debug(\"> Unregistering '{0}' editor 'EditorNode'.\".format(editor_node))\n\n        parent = editor_node.parent\n        row = editor_node.row()\n        self.beginRemoveRows(self.get_node_index(parent), row, row)\n        parent.remove_child(row)\n        self.endRemoveRows()\n\n        self.editor_unregistered.emit(editor_node)\n\n        return editor_node", "response": "Unregisters given EditorNode from the Model."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_project(self, path, ensure_uniqueness=False):\n\n        if ensure_uniqueness:\n            if self.get_project_nodes(path):\n                raise foundations.exceptions.ProgrammingError(\"{0} | '{1}' project is already registered!\".format(\n                    self.__class__.__name__, path))\n\n        LOGGER.debug(\"> Registering '{0}' project.\".format(path))\n\n        row = self.root_node.children_count()\n        self.beginInsertRows(self.get_node_index(self.root_node, ), row, row)\n        project_node = ProjectNode(name=os.path.basename(path),\n                                   path=path,\n                                   parent=self.root_node)\n        self.endInsertRows()\n\n        self.project_registered.emit(project_node)\n\n        return project_node", "response": "Registers given path in the Model as a project."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_authoring_node(self, node):\n\n        for parent_node in foundations.walkers.nodes_walker(node, ascendants=True):\n            if parent_node is self.__default_project_node:\n                return True\n        return False", "response": "Returns if given Node is an authoring node."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the Model authoring Nodes using given editor.", "response": "def set_authoring_nodes(self, editor):\n        \"\"\"\n        Sets the Model authoring Nodes using given editor.\n\n        :param editor: Editor to set.\n        :type editor: Editor\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        project_node = self.default_project_node\n        file_node = self.register_file(editor.file, project_node)\n        editor_node = self.register_editor(editor, file_node)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete the Model authoring Nodes associated with given editor.", "response": "def delete_authoring_nodes(self, editor):\n        \"\"\"\n        Deletes the Model authoring Nodes associated with given editor.\n\n        :param editor: Editor.\n        :type editor: Editor\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        editor_node = foundations.common.get_first_item(self.get_editor_nodes(editor))\n        file_node = editor_node.parent\n        self.unregister_editor(editor_node)\n        self.unregister_file(file_node, raise_exception=False)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_authoring_nodes(self, editor):\n\n        editor_node = foundations.common.get_first_item(self.get_editor_nodes(editor))\n        file_node = editor_node.parent\n        file = editor.file\n        file_node.name = editor_node.name = os.path.basename(file)\n        file_node.path = editor_node.path = file\n\n        self.node_changed(file_node)\n        return True", "response": "Updates given editor Model authoring nodes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_project_nodes(self, root_node, maximum_depth=1):\n\n        root_directory = root_node.path\n        for parent_directory, directories, files in foundations.walkers.depth_walker(root_directory, maximum_depth):\n            if parent_directory == root_directory:\n                parent_node = root_node\n            else:\n                parent_node = foundations.common.get_first_item(\n                    [node for node in foundations.walkers.nodes_walker(root_node)\n                     if node.family == \"Directory\" and node.path == parent_directory])\n\n            if not parent_node:\n                continue\n\n            paths = [node.path for node in parent_node.children]\n            for directory in sorted(directories):\n                if directory.startswith(\".\"):\n                    continue\n\n                path = os.path.join(parent_directory, directory)\n                if path in paths:\n                    continue\n\n                directory_node = self.register_directory(path, parent_node)\n\n            for file in sorted(files):\n                if file.startswith(\".\"):\n                    continue\n\n                path = os.path.join(parent_directory, file)\n                if path in paths:\n                    continue\n\n                if foundations.io.is_readable(path):\n                    if foundations.io.is_binary_file(path):\n                        continue\n\n                file_node = self.register_file(path, parent_node)", "response": "Sets the project Model children Nodes using given root node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the value of the languages attribute.", "response": "def languages(self, value):\n        \"\"\"\n        Setter for **self.__languages** attribute.\n\n        :param value: Attribute value.\n        :type value: list\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is list, \"'{0}' attribute: '{1}' type is not 'list'!\".format(\"languages\", value)\n            for element in value:\n                assert type(element) is Language, \"'{0}' attribute: '{1}' type is not 'Language'!\".format(\n                    \"languages\", element)\n        self.beginResetModel()\n        self.__languages = value\n        self.endResetModel()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef data(self, index, role=Qt.DisplayRole):\n\n        if not index.isValid():\n            return QVariant()\n\n        if role == Qt.DisplayRole:\n            return QVariant(self.__languages[index.row()].name)\n        return QVariant()", "response": "Reimplement the QAbstractListModel. data method."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sort_languages(self, order=Qt.AscendingOrder):\n\n        self.beginResetModel()\n        self.__languages = sorted(self.__languages, key=lambda x: (x.name), reverse=order)\n        self.endResetModel()", "response": "Sorts the Model languages."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_language(self, language):\n\n        if self.get_language(language):\n            raise foundations.exceptions.ProgrammingError(\"{0} | '{1}' language is already registered!\".format(\n                self.__class__.__name__, language.name))\n\n        LOGGER.debug(\"> Registering '{0}' language.\".format(language.name))\n\n        self.__languages.append(language)\n        self.sort_languages()\n        return True", "response": "Registers given language in the LanguageModel. languages property."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the language with given name.", "response": "def get_language(self, name):\n        \"\"\"\n        Returns the language with given name.\n\n        :param name: Language name.\n        :type name: unicode\n        :return: File language.\n        :rtype: Language\n        \"\"\"\n\n        for language in self.__languages:\n            if language.name == name:\n                LOGGER.debug(\"> Language '{0}': '{1}'.\".format(name, language))\n                return language"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_file_language(self, file):\n\n        for language in self.__languages:\n            if re.search(language.extensions, file):\n                LOGGER.debug(\"> '{0}' file detected language: '{1}'.\".format(file, language.name))\n                return language", "response": "Returns the language of given file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef insert_pattern(self, pattern, index):\n\n        LOGGER.debug(\"> Inserting '{0}' at '{1}' index.\".format(pattern, index))\n\n        self.remove_pattern(pattern)\n\n        self.beginInsertRows(self.get_node_index(self.root_node), index, index)\n        pattern_node = PatternNode(name=pattern)\n        self.root_node.insert_child(pattern_node, index)\n        self.endInsertRows()\n        self.pattern_inserted.emit(pattern_node)\n        return True", "response": "Inserts given pattern into the Model."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves given pattern from the Model.", "response": "def remove_pattern(self, pattern):\n        \"\"\"\n        Removes given pattern from the Model.\n\n        :param pattern: Pattern.\n        :type pattern: unicode\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        for index, node in enumerate(self.root_node.children):\n            if node.name != pattern:\n                continue\n\n            LOGGER.debug(\"> Removing '{0}' at '{1}' index.\".format(pattern, index))\n\n            self.beginRemoveRows(self.get_node_index(self.root_node), index, index)\n            pattern_node = self.root_node.child(index)\n            self.root_node.remove_child(index)\n            self.endRemoveRows()\n            self.pattern_removed.emit(pattern_node)\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_metrics(self):\n\n        search_file_nodes_count = search_occurence_nodesCount = 0\n\n        for node in foundations.walkers.nodes_walker(self.root_node):\n            if node.family == \"SearchFile\":\n                search_file_nodes_count += 1\n            elif node.family == \"SearchOccurence\":\n                search_occurence_nodesCount += 1\n\n        return {\"SearchFile\": search_file_nodes_count, \"SearchOccurence\": search_occurence_nodesCount}", "response": "Returns the Model metrics."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_fields(self):\n        fields = {}\n        forms = {}\n        sets = {}\n\n        for name in dir(self):\n            if name.startswith('_'):\n                continue\n            field = getattr(self, name)\n            is_field = isinstance(field, Field)\n            is_form = isinstance(field, Form) or (\n                inspect.isclass(field) and issubclass(field, Form))\n            is_set = isinstance(field, FormSet)\n\n            if is_field:\n                field = copy(field)\n                field.name = self._prefix + name\n                field.form = self\n                if field.prepare is None:\n                    field.prepare = getattr(self, 'prepare_' + name, None)\n                if field.clean is None:\n                    field.clean = getattr(self, 'clean_' + name, None)\n                fields[name] = field\n                setattr(self, name, field)\n            elif is_form:\n                forms[name] = field\n            elif is_set:\n                field._name = self._prefix + name  # REALLY IMPORTANT\n                sets[name] = field\n\n        self._fields = fields\n        self._forms = forms\n        self._sets = sets", "response": "Creates the _fields _forms and _sets dicts."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize the data into the form.", "response": "def _init_data(self, data, obj, files):\n        \"\"\"Load the data into the form.\n        \"\"\"\n        data = self.prepare(data)\n\n        # Initialize sub-forms\n        for name, subform in self._forms.items():\n            obj_value = get_obj_value(obj, name)\n            if inspect.isclass(subform):\n                fclass = subform\n            else:\n                fclass = subform.__class__\n            subform_prefix = '{prefix}{name}.'.format(\n                prefix=self._prefix,\n                name=name.lower()\n            )\n            subform = fclass(\n                data,\n                obj_value,\n                files=files,\n                locale=self._locale,\n                tz=self._tz,\n                prefix=subform_prefix,\n                backref=getattr(subform, '_backref', None)\n            )\n\n            self._forms[name] = subform\n            setattr(self, name, subform)\n            self._input_data = self._input_data or subform._input_data\n\n        # Initialize form-sets\n        for name, formset in self._sets.items():\n            sclass = formset.__class__\n            objs = formset._objs or get_obj_value(obj, name)\n            formset_name = '{prefix}{name}'.format(\n                prefix=self._prefix,\n                name=name.lower()\n            )\n            formset = sclass(\n                form_class=formset._form_class,\n                name=formset_name,\n                data=data,\n                objs=objs,\n                files=files,\n                locale=self._locale,\n                tz=self._tz,\n                create_new=formset._create_new,\n                backref=formset._backref\n            )\n            self._sets[name] = formset\n            setattr(self, name, formset)\n            for _form in formset._forms:\n                self._input_data = self._input_data or _form._input_data\n\n        # Initialize fields\n        for name, field in self._fields.items():\n            subdata = data.getlist(self._prefix + name)\n            subfiles = files.getlist(self._prefix + name)\n            self._input_data = self._input_data or subdata or subfiles\n            obj_value = get_obj_value(obj, name)\n            was_deleted = self._prefix + name + '__deleted' in data\n            if was_deleted:\n                subdata = obj_value = subfiles = None\n            field.load_data(subdata, obj_value, file_data=subfiles,\n                            locale=self._locale, tz=self._tz)\n            # delete field data\n            if was_deleted:\n                field._deleted = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns whether the current values of the form fields are all valid.", "response": "def is_valid(self):\n        \"\"\"Return whether the current values of the form fields are all valid.\n        \"\"\"\n        self.cleaned_data = {}\n        self.changed_fields = []\n        self.validated = False\n        self._errors = {}\n        self._named_errors = {}\n        cleaned_data = {}\n        changed_fields = []\n        errors = {}\n        named_errors = {}\n\n        # Validate sub forms\n        for name, subform in self._forms.items():\n            if not subform.is_valid():\n                errors[name] = subform._errors\n                named_errors.update(subform._named_errors)\n                continue\n            if subform.has_changed:\n                changed_fields.append(name)\n\n        # Validate sub sets\n        for name, formset in self._sets.items():\n            if not formset.is_valid():\n                errors[name] = formset._errors\n                named_errors.update(formset._named_errors)\n                continue\n            if formset.has_changed:\n                changed_fields.append(name)\n\n        # Validate each field\n        for name, field in self._fields.items():\n            field.error = None\n            py_value = field.validate(self)\n            if field.error:\n                errors[name] = field.error\n                named_errors[field.name] = field.error\n                continue\n            cleaned_data[name] = py_value\n            if hasattr(field, '_deleted'):\n                cleaned_data[name] = None\n                field.has_changed = True\n            if field.has_changed:\n                changed_fields.append(name)\n\n        # Validate relation between fields\n        for name, field in self._fields.items():\n            field.validate(self, cleaned_data)\n            if field.error:\n                errors[name] = field.error\n                named_errors[field.name] = field.error\n                continue\n\n        if errors:\n            self._errors = errors\n            self._named_errors = named_errors\n            return False\n\n        self.changed_fields = changed_fields\n        self.cleaned_data = self.clean(cleaned_data)\n        self.validated = True\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save(self, backref_obj=None):\n        if not self.validated:\n            assert self.is_valid()\n\n        if self._model and not self._obj:\n            obj = self._save_new_object(backref_obj)\n        else:\n            obj = self.save_to(self._obj)\n\n        for key, subform in self._forms.items():\n            data = subform.save(obj)\n            if self._model and not data:\n                continue\n            set_obj_value(obj, key, data)\n\n        for key, formset in self._sets.items():\n            data = formset.save(obj)\n            if self._model and not data:\n                continue\n            set_obj_value(obj, key, data)\n        return obj", "response": "Save the cleaned data to the initial object or creating a new one."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave the cleaned data to an object.", "response": "def save_to(self, obj):\n        \"\"\"Save the cleaned data to an object.\n        \"\"\"\n        if isinstance(obj, dict):\n            obj = dict(obj)\n\n        for key in self.changed_fields:\n            if key in self.cleaned_data:\n                val = self.cleaned_data.get(key)\n                set_obj_value(obj, key, val)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking code coverage quickly with the default Python", "response": "def coverage():\n    \"\"\"check code coverage quickly with the default Python\"\"\"\n    run(\"coverage run --source {PROJECT_NAME} -m py.test\".format(PROJECT_NAME=PROJECT_NAME))\n    run(\"coverage report -m\")\n    run(\"coverage html\")\n\n    webbrowser.open('file://' + os.path.realpath(\"htmlcov/index.html\"), new=2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the version from the release version line.", "response": "def _parse_version(self, line):\n        \"\"\"\n        There's a magic suffix to the release version, currently it's -03, but\n        it increments seemingly randomly.\n        \"\"\"\n        version_string = line.split(' ')[1]\n        version_list = version_string.split('.')\n        major_version = ''.join([version_list[0], version_list[1]])\n        release_num = ''.join([version_list[2].rstrip(), \"-03\"])\n        return (major_version, release_num)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn url for cdn. urtanterror. info to pass to _not_wget", "response": "def _get_url(self, filename):\n        \"\"\"\n        Returns url for cdn.urbanterror.info to pass to _not_wget().\n\n        http://cdn.urbanterror.info/urt/<major_ver_without_.>/<release_num>-<magic_number>/q3ut4/<filename>\n        \"\"\"\n        return self.cdn_url.format(self.mver, self.relnum, filename)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_manifest(self):\n        with open(self.manifest_file, 'r') as f:\n            for line in f:\n                if line.startswith(\"Version\"):\n                    self.mver, self.relnum = self._parse_version(line)\n                lineitems = line.split('  ')\n                if len(lineitems) == 2:\n                    asset_url = self._get_url(lineitems[1][:-1])\n                    yield grequests.get(asset_url, stream=True)", "response": "Read the defined file parse and set Version line and return generator of filenames."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving a subparser build and return the server parser.", "response": "def attach_parser(subparser):\n    \"\"\"Given a subparser, build and return the server parser.\"\"\"\n    return subparser.add_parser(\n        'server',\n        help='Run a bottle based server',\n        parents=[\n            CONFIG.build_parser(\n                add_help=False,\n                # might need conflict_handler\n            ),\n        ],\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nformatting and sort a list of pairs usually for printing.", "response": "def fmt_pairs(obj, indent=4, sort_key=None):\n    \"\"\"Format and sort a list of pairs, usually for printing.\n\n    If sort_key is provided, the value will be passed as the\n    'key' keyword argument of the sorted() function when\n    sorting the items. This allows for the input such as\n    [('A', 3), ('B', 5), ('Z', 1)] to be sorted by the ints\n    but formatted like so:\n\n        l = [('A', 3), ('B', 5), ('Z', 1)]\n        print(fmt_pairs(l, sort_key=lambda x: x[1]))\n\n            Z 1\n            A 3\n            B 5\n        where the default behavior would be:\n\n        print(fmt_pairs(l))\n\n            A 3\n            B 5\n            Z 1\n    \"\"\"\n    lengths = [len(x[0]) for x in obj]\n    if not lengths:\n        return ''\n    longest = max(lengths)\n    obj = sorted(obj, key=sort_key)\n    formatter = '%s{: <%d} {}' % (' ' * indent, longest)\n    string = '\\n'.join([formatter.format(k, v) for k, v in obj])\n    return string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a pretty formatted string of the list of routes.", "response": "def fmt_routes(bottle_app):\n    \"\"\"Return a pretty formatted string of the list of routes.\"\"\"\n    routes = [(r.method, r.rule) for r in bottle_app.routes]\n    if not routes:\n        return\n    string = 'Routes:\\n'\n    string += fmt_pairs(routes, sort_key=operator.itemgetter(1))\n    return string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_application(conf):\n    if isinstance(conf.adapter_options, list):\n        conf['adapter_options'] = {key: val for _dict in conf.adapter_options\n                                   for key, val in _dict.items()}\n    elif conf.adapter_options is None:\n        conf['adapter_options'] = {}\n    else:\n        conf['adapter_options'] = copy.copy(conf.adapter_options)\n\n    # get wsgi app the same way bottle does if it receives a string.\n    conf['app'] = conf.app or bottle.default_app()\n    if isinstance(conf.app, six.string_types):\n        conf['app'] = bottle.load_app(conf.app)\n\n    def _find_bottle_app(_app):\n        \"\"\"Lookup the underlying Bottle() instance.\"\"\"\n        while hasattr(_app, 'app'):\n            if isinstance(_app, bottle.Bottle):\n                break\n            _app = _app.app\n        assert isinstance(_app, bottle.Bottle), 'Could not find Bottle app.'\n        return _app\n\n    bottle_app = _find_bottle_app(conf.app)\n    bottle_app.route(\n        path='/_simpl', method='GET', callback=_version_callback)\n\n    def _show_routes():\n        \"\"\"Conditionally print the app's routes.\"\"\"\n        if conf.app and not conf.quiet:\n            if conf.reloader and os.getenv('BOTTLE_CHILD'):\n                LOG.info(\"Running bottle server with reloader.\")\n            elif not conf.reloader:\n                pass\n            else:\n                return\n            routes = fmt_routes(bottle_app)\n            if routes:\n                    print('\\n{}'.format(routes), end='\\n\\n')\n    _show_routes()\n    return conf.app", "response": "Do some setup and return the wsgi app."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(conf, build_app=True):\n    if build_app:\n        # The following sets conf.app\n        build_application(conf)\n    # waiting for https://github.com/bottlepy/bottle/pull/783\n    if conf.app and (os.getcwd() not in sys.path):\n        sys.path.append(os.getcwd())\n    return bottle.run(\n        app=conf.app,\n        server=conf.server,\n        host=conf.host,\n        port=conf.port,\n        interval=conf.interval,\n        reloader=conf.reloader,\n        quiet=conf.quiet,\n        debug=conf.debug,\n        **conf.adapter_options\n    )", "response": "Run bottle server based on this configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write(self, text):\n        if text:\n            if text[0] in '(w':\n                # write thread and wsgi messages to debug only\n                self.log.debug(text[:-1])\n                return\n            if self.access_log:\n                self.access_log.write(text)\n            self.log.info(text[:-1])", "response": "Write to appropriate target."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating listener socket based on bottle server parameters.", "response": "def get_socket(self):\n        \"\"\"Create listener socket based on bottle server parameters.\"\"\"\n        import eventlet\n\n        # Separate out socket.listen arguments\n        socket_args = {}\n        for arg in ('backlog', 'family'):\n            try:\n                socket_args[arg] = self.options.pop(arg)\n            except KeyError:\n                pass\n        # Separate out wrap_ssl arguments\n        ssl_args = {}\n        for arg in ('keyfile', 'certfile', 'server_side', 'cert_reqs',\n                    'ssl_version', 'ca_certs', 'do_handshake_on_connect',\n                    'suppress_ragged_eofs', 'ciphers'):\n            try:\n                ssl_args[arg] = self.options.pop(arg)\n            except KeyError:\n                pass\n        address = (self.host, self.port)\n        try:\n            sock = eventlet.listen(address, **socket_args)\n        except TypeError:\n            # Fallback, if we have old version of eventlet\n            sock = eventlet.listen(address)\n        if ssl_args:\n            sock = eventlet.wrap_ssl(sock, **ssl_args)\n        return sock"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _dummify_expr(expr, basename, symbs):\n    dummies = sympy.symbols(basename+':'+str(len(symbs)))\n    for i, s in enumerate(symbs):\n        expr = expr.subs({s: dummies[i]})\n    return expr", "response": "Used to robustify the expression"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_PCEExtension_for_prebuilding_Code(\n        name, Code, prebuild_sources, srcdir,\n        downloads=None, **kwargs):\n    \"\"\"\n    If subclass of codeexport.Generic_Code needs to have some of it\n    sources compiled to objects and cached in a `prebuilt/` directory\n    at invocation of `setup.py build_ext` this convenience function\n    makes setting up a PCEExtension easier. Use together with\n    cmdclass = {'build_ext': pce_build_ext}.\n\n    files called \".metadata*\" will be added to dist_files\n    \"\"\"\n\n    import glob\n    from .dist import PCEExtension\n\n    build_files = []\n    dist_files = [(os.path.join(srcdir, x[0]), x[1]) for\n                  x in getattr(Code, 'dist_files', [])]\n    for attr in ('build_files', 'templates'):\n        for cf in getattr(Code, attr, []) or []:\n            if not cf.startswith('prebuilt'):\n                build_files.append(os.path.join(srcdir, cf))\n                dist_files.append((os.path.join(srcdir, cf), None))\n\n    def prebuilder(build_temp, ext_fullpath, ext,\n                   src_paths, **prebuilder_kwargs):\n        build_temp = os.path.abspath(build_temp)\n        if not os.path.isdir(build_temp):\n            make_dirs(build_temp)\n\n        if downloads:\n            websrc, src_md5 = downloads\n            download_dir = os.path.join(build_temp, srcdir)\n            if not os.path.isdir(download_dir):\n                make_dirs(download_dir)\n            download_files(websrc, src_md5.keys(), src_md5,\n                           cwd=download_dir, logger=ext.logger)\n\n        for p in src_paths:\n            if p not in build_files:\n                copy(os.path.join(srcdir, p),\n                     os.path.join(build_temp, srcdir),\n                     dest_is_dir=True, create_dest_dirs=True,\n                     only_update=ext.only_update,\n                     logger=ext.logger)\n        dst = os.path.abspath(os.path.join(\n            os.path.dirname(ext_fullpath), 'prebuilt/'))\n        make_dirs(dst, logger=ext.logger)\n        objs = compile_sources(\n            [os.path.join(srcdir, x) for x in src_paths], destdir=dst,\n            cwd=build_temp, metadir=dst, only_update=True,\n            logger=ext.logger, **prebuilder_kwargs)\n        glb = os.path.join(ext_fullpath, '.metadata*')\n        dist_files.extend(glob.glob(glb))\n        for obj in objs:\n            # Copy prebuilt objects into lib for distriubtion\n            copy(os.path.join(build_temp, obj),\n                 dst, dest_is_dir=True, create_dest_dirs=True,\n                 only_update=ext.only_update,\n                 logger=ext.logger)\n        return objs\n\n    compile_kwargs = Code.compile_kwargs.copy()\n    logger = kwargs.pop('logger', True)\n    compile_kwargs.update(kwargs)\n    return PCEExtension(\n        name,\n        [],\n        build_files=build_files,\n        dist_files=dist_files,\n        build_callbacks=[\n            (\n                prebuilder,\n                (prebuild_sources,), compile_kwargs\n            ),\n        ],\n        logger=logger,\n        link_ext=False\n    )", "response": "This function creates a PCEExtension for the given code."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_cse_code(self, exprs, basename=None,\n                     dummy_groups=(), arrayify_groups=()):\n        \"\"\" Get arrayified code for common subexpression.\n\n        Parameters\n        ----------\n        exprs : list of sympy expressions\n        basename : str\n            Stem of variable names (default: cse).\n        dummy_groups : tuples\n\n        \"\"\"\n        if basename is None:\n            basename = 'cse'\n        cse_defs, cse_exprs = sympy.cse(\n            exprs, symbols=sympy.numbered_symbols(basename))\n\n        # Let's convert the new expressions into (arrayified) code\n        cse_defs_code = [\n            (vname, self.as_arrayified_code(\n                vexpr, dummy_groups, arrayify_groups))\n            for vname, vexpr in cse_defs\n        ]\n        cse_exprs_code = [self.as_arrayified_code(\n            x, dummy_groups, arrayify_groups) for x in cse_exprs]\n        return cse_defs_code, cse_exprs_code", "response": "Get arrayified code for common subexpression."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncache compiled binary of the Generic_Code class.", "response": "def mod(self):\n        \"\"\" Cached compiled binary of the Generic_Code class.\n\n        To clear cache invoke :meth:`clear_mod_cache`.\n        \"\"\"\n        if self._mod is None:\n            self._mod = self.compile_and_import_binary()\n        return self._mod"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clean(self):\n        if not self._save_temp:\n            if hasattr(self, '_written_files'):\n                map(os.unlink, self._written_files)\n            if getattr(self, '_remove_tempdir_on_clean', False):\n                shutil.rmtree(self._tempdir)", "response": "Delete temp dir if not save_temp set at __init__"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a new route with the given id consisting of the given list of edge IDs.", "response": "def add(self, routeID, edges):\n        \"\"\"add(string, list(string)) -> None\n\n        Adds a new route with the given id consisting of the given list of edge IDs.\n        \"\"\"\n        self._connection._beginMessage(tc.CMD_SET_ROUTE_VARIABLE, tc.ADD, routeID,\n                                       1 + 4 + sum(map(len, edges)) + 4 * len(edges))\n        self._connection._packStringList(edges)\n        self._connection._sendExact()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_files(self):\n        files = {}\n        for filename in os.listdir(self.source):\n            path = os.path.join(self.source, filename)\n            files[filename] = frontmatter.load(path, \n                filename=filename, \n                slug=os.path.splitext(filename)[0])\n\n        return files", "response": "Read and parse files from a directory and return a dictionary of path => post\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(self):\n        \"Run each middleware function on files\"\n        # load files from source directory\n        files = self.get_files()\n\n        # loop through each middleware\n        for func in self.middleware:\n\n            # call each one, ignoring return value\n            func(files, self)\n\n        # store and return the result\n        self.files.update(files)\n        return files", "response": "Run each middleware function on files"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\niterate over all processed files in natural order.", "response": "def iter(self, reset=False, reverse=False):\n        \"\"\"\n        Yield processed files one at a time, in natural order.\n        \"\"\"\n        files = os.listdir(self.source)\n        files.sort(reverse=reverse)\n\n        for filename in files:\n            try:\n                yield self.get(filename, reset)\n            except PostNotFound:\n                continue"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a single processed file. Uses a cached version if reset is True.", "response": "def get(self, filename, reset=False):\n        \"\"\"\n        Get a single processed file. Uses a cached version\n        if `run` has already been called, unless `reset` is True.\n        \"\"\"\n        if filename in self.files and not reset:\n            return self.files[filename]\n\n        # load a single file, and process\n        files = {}\n        path = os.path.join(self.source, filename)\n        files[filename] = frontmatter.load(path, \n            filename=filename,\n            slug=os.path.splitext(filename)[0])\n\n        # call middleware\n        for func in self.middleware:\n            func(files, self)\n\n        # cache the processed post\n        self.files.update(files)\n\n        # return just the post\n        try:\n            return files[filename]\n        except KeyError:\n            raise PostNotFound('{0} not found'.format(filename))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build(self, dest=None):\n        \"Build out results to dest directory (creating if needed)\"\n        # dest can be set here or on init\n        if not dest:\n            dest = self.dest\n\n        # raise an error if dest is None\n        if dest is None:\n            raise ValueError('destination directory must not be None')\n\n        # store build dir for later\n        self.dest = dest\n\n        # ensure a build dir\n        if not os.path.isdir(self.dest):\n            os.makedirs(self.dest)\n\n        # make sure we have files\n        if not self.files:\n            self.run()\n\n        # write the content of each post to dest, using keys as filenames\n        for filename, post in self.files.items():\n\n            # join filename to dest dir\n            path = os.path.join(self.dest, filename)\n            with open(path, 'wb') as f:\n                f.write(post.content.encode('utf-8'))", "response": "Build out results to dest directory ( creating if needed )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef serialize(self, as_dict=False, sort=None):\n        files = getattr(self, 'files', self.run())\n\n        if as_dict:\n            return dict((fn, p.to_dict()) for fn, p in files.items())\n\n        # generate a list\n        data = (p.to_dict() for p in files.values())\n\n        if callable(sort):\n            return sorted(data, key=sort)\n\n        elif sort is True:\n            return sorted(data)\n\n        return list(data)", "response": "Dump built files as a list or dictionary for JSON or other serialization."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a function to the middleware stack.", "response": "def use(self, func):\n        \"\"\"\n        Add function (or other callable) to the middleware stack.\n        Takes a single function as an argument and returns it,\n        so this can be used as a decorator.\n\n        func should take two arguments: files and stack\n\n        @stack.use\n        def count_files(files, stack):\n            stack.metadata['count'] = len(files)\n\n        \"\"\"\n        if not callable(func):\n            raise TypeError('Stack.use requires a callable')\n\n        self.middleware.append(func)\n        return func"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nserializes obj as a DSON formatted stream to fp.", "response": "def dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True,\n        allow_nan=True, cls=None, indent=None, separators=None,\n        encoding='utf-8', default=None, sort_keys=False, **kw):\n    \"\"\"Serialize ``obj`` as a DSON formatted stream to ``fp`` (a\n    ``.write()``-supporting file-like object).\n\n    If ``skipkeys`` is true then ``dict`` keys that are not basic types\n    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)\n    will be skipped instead of raising a ``TypeError``.\n\n    If ``ensure_ascii`` is true (the default), all non-ASCII characters in the\n    output are escaped with ``\\\\uXXXX`` sequences, and the result is a ``str``\n    instance consisting of ASCII characters only.  If ``ensure_ascii`` is\n    ``False``, some chunks written to ``fp`` may be ``unicode`` instances.\n    This usually happens because the input contains unicode strings or the\n    ``encoding`` parameter is used. Unless ``fp.write()`` explicitly\n    understands ``unicode`` (as in ``codecs.getwriter``) this is likely to\n    cause an error.\n\n    If ``check_circular`` is false, then the circular reference check\n    for container types will be skipped and a circular reference will\n    result in an ``OverflowError`` (or worse).\n\n    If ``allow_nan`` is false, then it will be a ``ValueError`` to\n    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)\n    in strict compliance of the DSON specification, instead of using the\n    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\n    If ``indent`` is a non-negative integer, then DSON array elements and\n    object members will be pretty-printed with that indent level. An indent\n    level of 0 will only insert newlines. ``None`` is the most compact\n    representation.  Since the default item separator is ``', '``,  the\n    output might include trailing whitespace when ``indent`` is specified.\n    You can use ``separators=(',', ': ')`` to avoid this.\n\n    If ``separators`` is an ``(item_separator, dict_separator)`` tuple\n    then it will be used instead of the default ``('and ', 'is ')`` separators.\n    ``('and', 'is')`` is the most compact DSON representation.\n\n    ``encoding`` is the character encoding for str instances, default is UTF-8.\n\n    ``default(obj)`` is a function that should return a serializable version\n    of obj or raise TypeError. The default simply raises TypeError.\n\n    If *sort_keys* is ``True`` (default: ``False``), then the output of\n    dictionaries will be sorted by key.\n\n    To use a custom ``DSONEncoder`` subclass (e.g. one that overrides the\n    ``.default()`` method to serialize additional types), specify it with\n    the ``cls`` kwarg; otherwise ``DSONEncoder`` is used.\n\n    \"\"\"\n    # cached encoder\n    if (not skipkeys and ensure_ascii and\n        check_circular and allow_nan and\n        cls is None and indent is None and separators is None and\n        encoding == 'utf-8' and default is None and not sort_keys and not kw):\n        iterable = _default_encoder.iterencode(obj)\n    else:\n        if cls is None:\n            cls = DSONEncoder\n        iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii,\n            check_circular=check_circular, allow_nan=allow_nan, indent=indent,\n            separators=separators, encoding=encoding,\n            default=default, sort_keys=sort_keys, **kw).iterencode(obj)\n    # could accelerate with writelines in some versions of Python, at\n    # a debuggability cost\n    for chunk in iterable:\n        fp.write(chunk)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _process_attachments(self, attachments):\n        for a in attachments:\n            if not isinstance(a, dict):\n                if isinstance(a, string_types):\n                    a = open(a, 'rb')\n                filename = basename(getattr(a, 'name', 'untitled'))\n                a = {\n                    \"filename\": filename,\n                    \"content_type\": guess_type(filename)[0] or 'application/octet-stream',\n                    \"content\": a.read(),\n                }\n            if isinstance(a['content'], binary_type):\n                a['content'] = b64encode(a['content']).decode()\n                a['encoded'] = True\n            yield a", "response": "Yields a list of dicts describing the attachments."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef raw(self, from_, to, body):\n        if isinstance(to, string_types):\n            raise TypeError('\"to\" parameter must be enumerable')\n        return self._session.post('{}/raw'.format(self._url), json={\n            'from': from_,\n            'to': to,\n            'body': body,\n        }).json()", "response": "Send a raw MIME message."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _append(self, target, value):\n        return self.__p(target) + '[] = ' + self.__p(value) + ';'", "response": "Append a value to the end of the list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _static(self, target, value):\n        return 'static ' + self.__p(ast.Assign(targets=[target],value=value))", "response": "PHP s static method"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _pad(input_signal, length, average=10):\n    padded_input_signal = numpy.zeros(length, input_signal.dtype)\n    start_offset = int((len(padded_input_signal) - len(input_signal)) / 2)\n    padded_input_signal[:start_offset] = numpy.average(input_signal[0:average])\n    padded_input_signal[start_offset:(start_offset + len(input_signal))] = input_signal[:]\n    padded_input_signal[(start_offset + len(input_signal)):] = numpy.average(input_signal[-average:])\n    return padded_input_signal", "response": "Helper function which increases the length of an input signal to the length of the original signal."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getContext(self):\n        ctx = ClientContextFactory.getContext(self)\n        ctx.set_options(OP_NO_SSLv3)\n        return ctx", "response": "Get the parent context but disable SSLv3."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef complex_to_real(complex_fid):\n    np = complex_fid.shape[0]\n    real_fid = numpy.zeros(np * 2)\n    real_fid[:np] = complex_fid.real\n    real_fid[np:] = complex_fid.imag[::-1]\n    return real_fid", "response": "This function converts a complex FID to a real FID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef real_to_complex(real_fid):\n    np = int(real_fid.shape[0] / 2)\n    complex_fid = numpy.zeros(np, 'complex')\n    complex_fid[:] = real_fid[:np]\n\n    # the imaginary part of the FID has been reversed, have to flip it back\n    imag_fid = real_fid[np:]\n    complex_fid += 1j * imag_fid[::-1]\n    return complex_fid", "response": "This function converts a real FID to a true complex FID."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fit(fid, model, baseline_points=16):\n\n    # Get list of metabolite names.\n    def get_metabolites(model_input):\n        metabolites = []\n        for fid_property_name, fid_property_value in model_input.items():\n            if type(fid_property_value) is dict:\n                metabolites.append(fid_property_name)\n        return metabolites\n\n    # Get standard errors from lmfit MinimizerResult object.\n    def get_errors(result):\n        errors = {}\n        for name, param in result.params.items():\n            errors[name] = param.stderr\n        return errors\n\n    def phase_fid(fid_in, phase0, phase1):\n        \"\"\"\n        This function performs a Fourier Transform on the FID to shift it into phase.\n\n        :param fid_in: FID to be fitted.\n        :param phase1: phase1 value.\n        :param phase0: phase0 value.\n        :return: FID that has been shifted into phase by FFT\n        \"\"\"\n        spectrum = numpy.fft.fftshift(numpy.fft.fft(fid_in))\n        np = fid_in.np\n        phase_shift = phase0 + phase1 * numpy.linspace(-np / 2, np / 2, np, endpoint=False)\n        phased_spectrum = spectrum * numpy.exp(1j * phase_shift)\n        return fid_in.inherit(numpy.fft.ifft(numpy.fft.ifftshift(phased_spectrum)))\n\n    def make_basis(params, time_axis):\n        \"\"\"\n        This function generates a basis set.\n\n        :param params: lmfit Parameters object containing fitting parameters.\n        :param time_axis: the time axis.\n        :return: a matrix containing the generated basis set.\n        \"\"\"\n\n        basis_matrix = numpy.matrix(numpy.zeros((len(metabolite_name_list), len(time_axis) * 2)))\n        for i, metabolite_name in enumerate(metabolite_name_list):\n            gaussian = suspect.basis.gaussian(time_axis,\n                                              params[\"{}_frequency\".format(metabolite_name)],\n                                              params[\"{}_phase\".format(metabolite_name)].value,\n                                              params[\"{}_fwhm\".format(metabolite_name)])\n            real_gaussian = complex_to_real(gaussian)\n            basis_matrix[i, :] = real_gaussian\n        return basis_matrix\n\n    def unphase(data, params):\n\n        unphased_data = phase_fid(data, -params['phase0'], -params['phase1'])\n        real_unphased_data = complex_to_real(unphased_data)\n\n        return real_unphased_data\n\n    def do_fit(params, time_axis, real_unphased_data):\n        \"\"\"\n        This function performs the fitting.\n\n        :param params: lmfit Parameters object containing fitting parameters.\n        :param time_axis: the time axis.\n        :param real_unphased_data:\n        :return: List of fitted data points and amplitudes of each singlet.\n        \"\"\"\n        basis = make_basis(params, time_axis)\n\n        weights = scipy.optimize.nnls(basis[:, baseline_points:-baseline_points].T,\n                                      real_unphased_data[baseline_points:-baseline_points])[0]\n\n        fitted_data = numpy.array(numpy.dot(weights, basis)).squeeze()\n        return fitted_data, weights\n\n    def residual(params, time_axis, data):\n        \"\"\"\n        This function calculates the residual to be minimized by the least squares means method.\n\n        :param params: lmfit Parameters object containing fitting parameters.\n        :param time_axis: the time axis.\n        :param data: FID to be fitted.\n        :return: residual values of baseline points.\n        \"\"\"\n\n        real_unphased_data = unphase(data, params)\n        fitted_data, weights = do_fit(params, time_axis, real_unphased_data)\n        res = fitted_data - real_unphased_data\n\n        return res[baseline_points:-baseline_points]\n\n    def fit_data(data, initial_params):\n        \"\"\"\n        This function takes an FID and a set of parameters contained in an lmfit Parameters object,\n        and fits the data using the least squares means method.\n\n        :param data: FID to be fitted.\n        :param initial_params: lmfit Parameters object containing fitting parameters.\n        :return: tuple of weights as a list, data as a list, and result as an lmift MinimizerResult object.\n        \"\"\"\n        fitting_result = lmfit.minimize(residual,\n                                        initial_params,\n                                        args=(data.time_axis(), data),\n                                        xtol=5e-3)\n\n        real_fitted_data, fitting_weights = do_fit(fitting_result.params, data.time_axis(), unphase(data, fitting_result.params))\n        fitted_data = real_to_complex(real_fitted_data)\n\n        return fitting_weights, fitted_data, fitting_result\n\n    # Convert lmfit parameters to model format\n    def parameters_to_model(parameters_obj, param_weights):\n        new_model = {}\n        for param_name, param in parameters_obj.items():\n            name = param_name.split(\"_\")\n            name1 = name[0]\n            if len(name) == 1:  # i.e. phase\n                new_model[name1] = param.value\n            else:\n                name2 = name[1]\n                if name1 not in new_model:\n                    new_model[name1] = {name2: param.value}\n                else:\n                    new_model[name1][name2] = param.value\n\n        for i, metabolite_name in enumerate(metabolite_name_list):\n            new_model[metabolite_name][\"amplitude\"] = param_weights[i]\n\n        return new_model\n\n    # Convert initial model to lmfit parameters.\n    def model_to_parameters(model_dict):\n        lmfit_parameters = lmfit.Parameters()\n        params = []\n        ordered_params = []\n        # Calculate dependencies/references for each parameter.\n        depend_dict = calculate_dependencies(model_dict)\n\n        model_dict_copy = copy.deepcopy(model_dict)\n        params.append((\"phase0\", model_dict_copy.pop(\"phase0\")))\n        params.append((\"phase1\", model_dict_copy.pop(\"phase1\")))\n\n        # Construct lmfit Parameter input for each parameter.\n        for peak_name, peak_properties in model_dict_copy.items():\n                # Fix phase value to 0 by default.\n                if \"phase\" not in peak_properties:\n                    params.append((\"{0}_{1}\".format(peak_name, \"phase\"), None, None, None, None, \"0\"))\n                for property_name, property_value in peak_properties.items():\n                    # Initialize lmfit parameter arguments.\n                    name = \"{0}_{1}\".format(peak_name, property_name)\n                    value = None\n                    vary = True\n                    lmfit_min = None\n                    lmfit_max = None\n                    expr = None\n                    if isinstance(property_value, numbers.Number):\n                        value = property_value\n                    elif isinstance(property_value, str):\n                        expr = property_value\n                    elif isinstance(property_value, dict):\n                        if \"value\" in property_value:\n                            value = property_value[\"value\"]\n                        if \"min\" in property_value:\n                            lmfit_min = property_value[\"min\"]\n                        if \"max\" in property_value:\n                            lmfit_max = property_value[\"max\"]\n                    # Add parameter object with defined parameters.\n                    params.append((name, value, vary, lmfit_min, lmfit_max, expr))  # (lmfit Parameter input format)\n\n        # Order parameters based on dependencies.\n        in_oparams = []\n        while len(params) > 0:\n            front = params.pop(0)\n            name = front[0]\n            # If no dependencies, add parameter to list and mark parameter as added.\n            if name not in depend_dict or depend_dict[name] is None:\n                ordered_params.append(front)\n                in_oparams.append(name)\n            else:\n                dependencies_present = True\n                for dependency in depend_dict[name]:\n                    # If dependency not yet added, mark parameter to move to back of queue.\n                    if dependency not in in_oparams:\n                        dependencies_present = False\n                # If all dependencies present, add parameter to list and mark parameter as added.\n                if dependencies_present:\n                    ordered_params.append(front)\n                    in_oparams.append(name)\n                # If dependencies missing, move parameter to back of queue.\n                else:\n                    params.append(front)\n\n        # Convert all parameters to lmfit Parameter objects.\n        lmfit_parameters.add_many(*ordered_params)\n\n        return lmfit_parameters\n\n    # Check if all model input types are correct.\n    def check_errors(check_model):\n        # Allowed keys in the model.\n        allowed_keys = [\"min\", \"max\", \"value\", \"phase\", \"amplitude\"]\n\n        # Scan model.\n        for model_property, model_values in check_model.items():\n            if not isinstance(model_values, (numbers.Number, dict)):\n                raise TypeError(\"Value of {0} must be a number (for phases), or a dictionary.\".format(model_property))\n            elif type(model_values) is dict:  # i.e. type(value) is not int\n                for peak_property, peak_value in model_values.items():\n                    if not isinstance(peak_value,(numbers.Number,dict,str)):\n                        raise TypeError(\"Value of {0}_{1} must be a value, an expression, or a dictionary.\"\n                                        .format(model_property, peak_property))\n                    if type(peak_value) is dict:\n                        for width_param in peak_value:\n                            # Dictionary must have 'value' key.\n                            if \"value\" not in peak_value:\n                                raise KeyError(\"Dictionary {0}_{1} is missing 'value' key.\"\n                                               .format(model_property, peak_property))\n                            # Dictionary can only have 'min,' 'max,' and 'value'.\n                            if width_param not in allowed_keys:\n                                raise KeyError(\"In {0}_{1}, '{2}' is not an allowed key.\"\n                                               .format(model_property, peak_property, width_param))\n\n    # Calculate references to determine order for Parameters.\n    def calculate_dependencies(unordered_model):\n        dependencies = {}  # (name, [dependencies])\n\n        # Compile dictionary of effective names.\n        for model_property, model_values in unordered_model.items():\n            if type(model_values) is dict:  # i.e. pcr, not phase\n                for peak_property in model_values:\n                    dependencies[\"{0}_{1}\".format(model_property, peak_property)] = None\n\n        # Find dependencies for each effective name.\n        for model_property, model_values in unordered_model.items():\n            if type(model_values) is dict:  # i.e. not phase\n                for peak_property, peak_value in model_values.items():\n                    if type(peak_value) is str:\n                        lmfit_name = \"{0}_{1}\".format(model_property, peak_property)\n                        dependencies[lmfit_name] = []\n                        for depend in dependencies:\n                            if depend in peak_value:\n                                dependencies[lmfit_name].append(depend)\n\n        # Check for circular dependencies.\n        for name, dependents in dependencies.items():\n            if type(dependents) is list:\n                for dependent in dependents:\n                    if dependencies[dependent] is not None and name in dependencies[dependent]:\n                        raise ReferenceError(\"{0} and {1} reference each other, creating a circular reference.\"\n                                             .format(name, dependent))\n        return dependencies\n\n    # Do singlet fitting\n    # Minimize and fit 31P data.\n\n    check_errors(model)  # Check for errors in model formatting.\n\n    metabolite_name_list = get_metabolites(model)  # Set list of metabolite names.\n\n    parameters = model_to_parameters(model)  # Convert model to lmfit Parameters object.\n\n    fitted_weights, fitted_data, fitted_results = fit_data(fid, parameters)  # Fit data.\n\n    final_model = parameters_to_model(fitted_results.params, fitted_weights)  # Convert fit parameters to model format.\n\n    stderr = get_errors(fitted_results)  # Get stderr values for each parameter.\n\n    return_dict = {\"model\": final_model, \"fit\": fitted_data, \"errors\": stderr}  # Compile output into a dictionary.\n    return return_dict", "response": "Fit a single FID with a model."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef transform_q(q, query):\n    for i, child in enumerate(q.children):\n        if isinstance(child, Q):\n            transform_q(child, query)\n        else:\n            # child is (lookup, value) tuple\n            where_node = query.build_filter(child)\n            q.children[i] = where_node", "response": "Transform a Q object into a where node object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_q(q, qn, connection):\n    joinstr = u' {} '.format(q.connector)\n    conditions = []\n    params = []\n\n    if DJANGO_MAJOR == 1 and DJANGO_MINOR == 7:\n        # in Django 1.7 WhereNode.as_sql expects `qn` to have a `compile`\n        # method (i.e not really expecting a quote names function any more\n        # they are expecting a django.db.models.sql.compiler.SQLCompiler)\n        try:\n            qn = qn.__self__\n        except AttributeError:\n            pass\n\n    for child in q.children:\n        if isinstance(child, Q):\n            # recurse\n            condition, child_params = render_q(child, qn, connection)\n            conditions.append(u'({})'.format(condition))\n            params.extend(child_params)\n        else:\n            try:\n                # Django 1.7\n                child, joins_used = child\n            except TypeError:\n                # Django 1.6\n                pass\n            # we expect child to be a WhereNode (see transform_q)\n            condition, child_params = child.as_sql(qn, connection)\n            params.extend(child_params)\n            conditions.append(condition)\n    rendered = u'({})'.format(joinstr.join(conditions))\n    if q.negated:\n        rendered = u'NOT {}'.format(rendered)\n    return rendered, params", "response": "Renders the Q object into SQL for the WHEN clause."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate the file on the file system.", "response": "def create(self):\n        \"\"\"Create the file on the file system.\"\"\"\n        self.buffer = []\n        self.buf_count = 0\n        if not self.directory.exists: self.directory.create()\n        self.open('w')\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_seq(self, seq):\n        self.buffer.append(seq)\n        self.buf_count += 1\n        if self.buf_count % self.buffer_size == 0: self.flush()", "response": "Use this method to add a SeqRecord object to this fasta file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_str(self, seq, name=None, description=\"\"):\n        self.add_seq(SeqRecord(Seq(seq), id=name, description=description))", "response": "Use this method to add a sequence as a string to this fasta file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef flush(self):\n        for seq in self.buffer:\n            SeqIO.write(seq, self.handle, self.format)\n        self.buffer = []", "response": "Flush the buffer to the file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ids(self):\n        as_list = [seq.description.split()[0] for seq in self]\n        as_set = frozenset(as_list)\n        assert len(as_set) == len(as_list)\n        return as_set", "response": "A frozen set of all unique IDs in the file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sql(self):\n        from fasta.indexed import DatabaseFASTA, fasta_to_sql\n        db = DatabaseFASTA(self.prefix_path + \".db\")\n        if not db.exists: fasta_to_sql(self.path, db.path)\n        return db", "response": "Build an SQLite database from the fasta file"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef length_by_id(self):\n        hashmap = dict((seq.id, len(seq)) for seq in self)\n        tmp = hashmap.copy()\n        hashmap.update(tmp)\n        return hashmap", "response": "Returns a dictionary mapping sequence IDs to length of each sequence in the sequence store."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef subsample(self, down_to=1, new_path=None):\n        # Auto path #\n        if new_path is None: subsampled = self.__class__(new_temp_path())\n        elif isinstance(new_path, FASTA): subsampled = new_path\n        else:                subsampled = self.__class__(new_path)\n        # Check size #\n        if down_to > len(self):\n            message = \"Can't subsample %s down to %i. Only down to %i.\"\n            print Color.ylw + message % (self, down_to, len(self)) + Color.end\n            self.copy(new_path)\n            return\n        # Do it #\n        subsampled.create()\n        for seq in isubsample(self, down_to): subsampled.add_seq(seq)\n        subsampled.close()\n        # Did it work #\n        assert len(subsampled) == down_to\n        return subsampled", "response": "Pick a number of sequences from the file pseudo - randomly."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rename_with_num(self, prefix=\"\", new_path=None, remove_desc=True):\n        # Temporary path #\n        if new_path is None: numbered = self.__class__(new_temp_path())\n        else:                numbered = self.__class__(new_path)\n        # Generator #\n        def numbered_iterator():\n            for i,read in enumerate(self):\n                read.id  = prefix + str(i)\n                read.seq = read.seq.upper()\n                if remove_desc: read.description = \"\"\n                yield read\n        # Do it #\n        numbered.write(numbered_iterator())\n        numbered.close()\n        # Replace it #\n        if new_path is None:\n            os.remove(self.path)\n            shutil.move(numbered, self.path)\n        return numbered", "response": "Rename every sequence based on a prefix and a number."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrename every sequence based on a prefix.", "response": "def rename_with_prefix(self, prefix=\"\", new_path=None, in_place=True, remove_desc=True):\n        \"\"\"Rename every sequence based on a prefix.\"\"\"\n        # Temporary path #\n        if new_path is None: prefixed = self.__class__(new_temp_path())\n        else:                prefixed = self.__class__(new_path)\n        # Generator #\n        def prefixed_iterator():\n            for i,read in enumerate(self):\n                read.id = prefix + read.id\n                if remove_desc: read.description = \"\"\n                yield read\n        # Do it #\n        prefixed.write(prefixed_iterator())\n        prefixed.close()\n        # Replace it #\n        if in_place:\n            os.remove(self.path)\n            shutil.move(prefixed, self.path)\n        return prefixed"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts a certain length fraction and place them in a new file.", "response": "def extract_length(self, lower_bound=None, upper_bound=None, new_path=None):\n        \"\"\"Extract a certain length fraction and place them in a new file.\"\"\"\n        # Temporary path #\n        if new_path is None: fraction = self.__class__(new_temp_path())\n        elif isinstance(new_path, FASTA): fraction = new_path\n        else:                fraction = self.__class__(new_path)\n        # Generator #\n        if lower_bound is None: lower_bound = 0\n        if upper_bound is None: upper_bound = sys.maxint\n        def fraction_iterator():\n            for read in self:\n                if lower_bound <= len(read) <= upper_bound:\n                    yield read\n        # Do it #\n        fraction.write(fraction_iterator())\n        fraction.close()\n        return fraction"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extract_sequences(self, ids, new_path=None):\n        # Temporary path #\n        if new_path is None: new_fasta = self.__class__(new_temp_path())\n        elif isinstance(new_path, FASTA): new_fasta = new_path\n        else:                new_fasta = self.__class__(new_path)\n        # Do it #\n        new_fasta.create()\n        for seq in self:\n            if seq.id in ids: new_fasta.add_seq(seq)\n        new_fasta.close()\n        return new_fasta", "response": "Will take all the sequences from the current file who s id appears in\n        the ids given and place them in the new file path given."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_trailing_stars(self, new_path=None, in_place=True, check=False):\n        # Optional check #\n        if check and int(sh.grep('-c', '\\*', self.path, _ok_code=[0,1])) == 0: return self\n        # Faster with bash utilities #\n        if in_place is True:\n            sh.sed('-i', 's/\\*$//g', self.path)\n            return self\n        # Standard way #\n        if new_path is None: new_fasta = self.__class__(new_temp_path())\n        else:                new_fasta = self.__class__(new_path)\n        new_fasta.create()\n        for seq in self: new_fasta.add_str(str(seq.seq).rstrip('*'), seq.id)\n        new_fasta.close()\n        return new_fasta", "response": "Remove the bad character that can be inserted by some programs at the\n        end of sequences."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef align(self, out_path=None):\n        if out_path is None: out_path = self.prefix_path + '.aln'\n        sh.muscle38(\"-in\", self.path, \"-out\", out_path)\n        return AlignedFASTA(out_path)", "response": "We align the sequences in the fasta file with muscle."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef template_align(self, ref_path):\n        # Run it #\n        sh.mothur(\"#align.seqs(candidate=%s, template=%s, search=blast, flip=false, processors=8);\" % (self.path, ref_path))\n        # Move things #\n        shutil.move(self.path[:-6] + '.align',        self.p.aligned)\n        shutil.move(self.path[:-6] + '.align.report', self.p.report)\n        shutil.move(self.path[:-6] + '.flip.accnos',  self.p.accnos)\n        # Clean up #\n        if os.path.exists('formatdb.log'): os.remove('formatdb.log')\n        if os.path.exists('error.log') and os.path.getsize('error.log') == 0: os.remove('error.log')\n        for p in sh.glob('mothur.*.logfile'): os.remove(p)", "response": "We align the sequences in the fasta file with mothur and a template."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef index_bowtie(self):\n        # It returns exit code 1 if the fasta is empty #\n        assert self\n        # Call the bowtie executable #\n        sh.bowtie2_build(self.path, self.path)\n        return FilePath(self.path + '.1.bt2')", "response": "Create an index on the fasta file compatible with bowtie2."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef graphs(self):\n        result = Dummy()\n        for graph in graphs.__all__:\n            cls = getattr(graphs, graph)\n            setattr(result, cls.short_name, cls(self))\n        return result", "response": "Returns a Dummy object whose attributes\n        are all the graphs found in graphs. py initialized with this instance as\n        only argument."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a new object with the same attributes as the given operator.", "response": "def from_operator(operation=debug):\r\n    \"\"\"# python-category-equations\r\n\r\nWith the tools provided here you can create category like equations for the given operator.\r\nOn the equations the underlaying '+' and '-' operations are basic set operations\r\ncalled union and discard  and the multiplication operator '*' connects sources to sinks.\r\nThe equation system also has a Identity 'I' term and zerO -like termination term 'O'.\r\nFor futher details go https://en.wikipedia.org/wiki/Category_(mathematics)#Definition\r\n\r\n## Usage\r\n\r\n\r\nHere our connector operation is print function called 'debug' which\r\nprints an arrow between two objects:\r\n\r\n    >>> debug('a', 'b')\r\n    a -> b\r\n\r\n    >>> debug('b', 'a')\r\n    b -> a\r\n\r\n    >>> debug('a', 'a')\r\n    a -> a\r\n\r\nGet I and O singletons and class C, which use previously defined debug -function.\r\n\r\n    >>> I, O, C = from_operator(debug)\r\n    >>> I == I\r\n    True\r\n    >>> O == I\r\n    False\r\n    >>> C(1)\r\n    C(1)\r\n\r\nThe items do have differing sinks and sources:\r\n\r\n    >>> I.sinks\r\n    {I}\r\n    >>> I.sources\r\n    {I}\r\n\r\n    >>> O.sinks\r\n    set()\r\n    >>> O.sources\r\n    set()\r\n\r\n    >>> C(1).sinks\r\n    {1}\r\n    >>> C(1).sources\r\n    {1}\r\n\r\n\r\nYou can write additions also with this notation\r\n\r\n    >>> C(1,2) == C(1) + C(2)\r\n    True\r\n\r\n\r\nThe multiplication connects sources to sinks like this:\r\n\r\n    >>> (C(1,2) * C(3,4)).evaluate()\r\n    1 -> 3\r\n    1 -> 4\r\n    2 -> 3\r\n    2 -> 4\r\n\r\n    >>> (C(3,4) * C(1,2)).sinks\r\n    {3, 4}\r\n\r\n    >>> (C(3,4) * C(1,2)).sources\r\n    {1, 2}\r\n\r\n\r\nBy combining the two previous examples:\r\n\r\n    >>> C(1,2) * C(3,4) == (C(1) + C(2)) * (C(3) + C(4))\r\n    True\r\n\r\nThe order inside C(...) does not matter:\r\n\r\n    >>> (C(1,2) * C(3,4)) == (C(2,1) * C(4,3))\r\n    True\r\n\r\nOn the other hand you can not swap the terms like:\r\n\r\n    >>> (C(1,2) * C(3,4)) == (C(3,4) * C(1,2))\r\n    False\r\n\r\nBecause:\r\n\r\n    >>> (C(3,4) * C(1,2)).evaluate()\r\n    3 -> 1\r\n    3 -> 2\r\n    4 -> 1\r\n    4 -> 2\r\n\r\nThe discard operation works like this:\r\n\r\n    >>> (C(3,4) * C(1,2) - C(4) * C(1)).evaluate()\r\n    3 -> 1\r\n    3 -> 2\r\n    4 -> 2\r\n\r\nBut\r\n\r\n    >>> (C(3,4) * C(1,2) - C(4) * C(1)) == C(3) * C(1,2) + C(4) * C(2)\r\n    False\r\n\r\nBecause sinks and sources differ:\r\n\r\n    >>> (C(3,4) * C(1,2) - C(4) * C(1)).sinks\r\n    {3}\r\n    >>> (C(3) * C(1,2) + C(4) * C(2)).sinks\r\n    {3, 4}\r\n\r\nThe right form would have been:\r\n\r\n    >>> (C(3,4) * C(1,2) - C(4) * C(1)) == C(3) * C(1,2) + C(4) * C(2) - C(4) * O - O * C(1)\r\n    True\r\n\r\n\r\nThe identity I and zero O work together like usual:\r\n\r\n    >>> I * I == I\r\n    True\r\n    >>> O * I * O == O\r\n    True\r\n\r\n\r\nIdentity 'I' works as a tool for equation simplifying.\r\nFor example:\r\n\r\n    >>> C(1,2) * C(3,4) * C(5) + C(1,2) * C(5) == C(1,2) * ( C(3,4) + I ) * C(5)\r\n    True\r\n\r\nBecause:\r\n\r\n    >>> (C(1,2) * C(3,4) * C(5) + C(1,2) * C(5)).evaluate()\r\n    1 -> 3\r\n    1 -> 4\r\n    1 -> 5\r\n    2 -> 3\r\n    2 -> 4\r\n    2 -> 5\r\n    3 -> 5\r\n    4 -> 5\r\n\r\nand\r\n\r\n    >>> (C(1,2) * ( C(3,4) + I ) * C(5)).evaluate()\r\n    1 -> 3\r\n    1 -> 4\r\n    1 -> 5\r\n    2 -> 3\r\n    2 -> 4\r\n    2 -> 5\r\n    3 -> 5\r\n    4 -> 5\r\n\r\nIf two terms have the same middle part you can simplify equations\r\nvia terminating loose sinks or sources with O:\r\nFor example:\r\n\r\n    >>> (C(1) * C(2) * C(4) + C(3) * C(4)).evaluate()\r\n    1 -> 2\r\n    2 -> 4\r\n    3 -> 4\r\n\r\n    >>> (C(1) * C(2) * C(4) + O * C(3) * C(4)).evaluate()\r\n    1 -> 2\r\n    2 -> 4\r\n    3 -> 4\r\n\r\n    >>> (C(1) * ( C(2) + O * C(3) ) * C(4)).evaluate()\r\n    1 -> 2\r\n    2 -> 4\r\n    3 -> 4\r\n\r\n    >>> C(1) * C(2) * C(4) + O * C(3) * C(4) == C(1) * ( C(2) + O * C(3) ) * C(4)\r\n    True\r\n\r\n\r\nNote that the comparison wont work without the O -term because the sinks differ:\r\n\r\n    >>> C(1) * C(2) * C(4) +  C(3) * C(4) == C(1) * ( C(2) + O * C(3) ) * C(4)\r\n    False\r\n\r\n\r\n    \"\"\"\r\n\r\n    _I, _O = get_I_and_O(operation)\r\n\r\n\r\n    def _C(*things):\r\n        return Adder(operator=operation, items=set(things))\r\n\r\n    return _I, _O, _C"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting the node with the given key_chain.", "response": "def delete_node(self, key_chain):\n        \"\"\"\n        key_chain is an array of keys giving the path to the node that should be deleted.\n        \"\"\"\n        node = self._data\n        for key in key_chain[:-1]:\n            node = node[key]\n\n        del node[key_chain[-1]]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef timethis(label, receiver_fn=None):\n\n    start = time.time()\n    try:\n        yield\n    finally:\n        end = time.time()\n        if receiver_fn:\n            receiver_fn(label, start, end)\n        else:\n            print('{}: {} to {} -> {} seconds'.format(label, start, end, end-start))", "response": "Times a block of code\nVATs"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nraising the given exception if the statement is false.", "response": "def assert_or_raise(stmt: bool, exception: Exception,\n                    *exception_args, **exception_kwargs) -> None:\n  \"\"\"\n  If the statement is false, raise the given exception.\n  \"\"\"\n  if not stmt:\n    raise exception(*exception_args, **exception_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_socket():\n    '''Creates a socket suitable for SSDP searches.\n\n    The socket will have a default timeout of 0.2 seconds (this works well for\n    the :py:func:search function which interleaves sending requests and reading\n    responses.\n    '''\n    mreq = struct.pack(\"4sl\", socket.inet_aton(MCAST_IP), socket.INADDR_ANY)\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.bind(('', MCAST_PORT))\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)\n    sock.settimeout(0.2)\n    return sock", "response": "Creates a socket suitable for SSDP searches."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef encode_request(request_line, **headers):\n    '''Creates the data for a SSDP request.\n\n    Args:\n        request_line (string): The request line for the request (e.g.\n            ``\"M-SEARCH * HTTP/1.1\"``).\n        headers (dict of string -> string): Dictionary of header name - header\n            value pairs to present in the request.\n\n    Returns:\n        bytes: The encoded request.\n    '''\n    lines = [request_line]\n    lines.extend(['%s: %s' % kv for kv in headers.items()])\n    return ('\\r\\n'.join(lines) + '\\r\\n\\r\\n').encode('utf-8')", "response": "Encodes the request line into a byte string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode_response(data):\n    '''Decodes the data from a SSDP response.\n\n    Args:\n        data (bytes): The encoded response.\n\n    Returns:\n        dict of string -> string: Case-insensitive dictionary of header name to\n        header value pairs extracted from the response.\n    '''\n    res = CaseInsensitiveDict()\n    for dataline in data.decode('utf-8').splitlines()[1:]:\n        dataline = dataline.strip()\n        if not dataline:\n            continue\n        line_parts = dataline.split(':', 1)\n        # This is to deal with headers with no value.\n        if len(line_parts) < 2:\n            line_parts = (line_parts[0], '')\n        res[line_parts[0].strip()] = line_parts[1].strip()\n    return res", "response": "Decodes the data from an SSDP response."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends an SSDP search request via the provided socket.", "response": "def request_via_socket(sock, search_target):\n    '''Send an SSDP search request via the provided socket.\n\n    Args:\n        sock: A socket suitable for use to send a broadcast message - preferably\n            one created by :py:func:`make_socket`.\n        search_target (string): A :term:`resource type` target to search for.\n    '''\n    msgparts = dict(HOST=MCAST_IP_PORT, MAN='\"ssdp:discover\"', MX='3', ST=search_target)\n    msg = encode_request('M-SEARCH * HTTP/1.1', **msgparts)\n    sock.sendto(msg, (MCAST_IP, MCAST_PORT))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nyields SSDP search responses and advertisements from the provided socket.", "response": "def responses_from_socket(sock, timeout=10):\n    '''Yield SSDP search responses and advertisements from the provided socket.\n\n    Args:\n        sock: A socket suitable for use to send a broadcast message - preferably\n            one created by :py:func:`make_socket`.\n        timeout (int / float): Overall time in seconds for how long to wait for\n            before no longer listening for responses.\n\n    Yields:\n        dict of string -> string: Case-insensitive dictionary of header name to\n        header value pairs extracted from the response.\n    '''\n    now = time.time()\n    give_up_by = now + timeout\n\n    while now < give_up_by:\n        try:\n            data = sock.recv(1024)\n        except socket.timeout:\n            now = time.time()\n            continue\n\n        # We handle either search responses or announcements.\n        for data_prefix in [\n            b'HTTP/1.1 200 OK',\n            b'NOTIFY * HTTP/1.1',\n        ]:\n            if data[:len(data_prefix)] == data_prefix:\n                break\n        else:\n            now = time.time()\n            continue\n\n        yield decode_response(data)\n\n        now = time.time()\n        continue"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef search(target_types=None, timeout=12, tries=3):\n    '''\n    Performs a search via SSDP to discover resources.\n\n    Args:\n        target_types (sequence of strings): A sequence of :term:`resource types`\n            to search for. For convenience, this can also be a single string. If\n            provided, then this function will make individual requests searching\n            for specific targets - this is sometimes required as some devices\n            will not respond unless they are specifically requested by the search. \n            \n            If not given, then a search won't be broadcast, but we will still\n            listen for SSDP notification responses.\n\n        timeout (int / float): Overall time in seconds for how long to wait for\n            before no longer listening for responses.\n\n        tries (int): How many times to send out a search request - this will be\n            spread out over the timeout period.\n\n    Yields:\n        :py:class:`Discovery` instances describing each result found - any\n        duplicate results will be filtered out by this function.\n    '''\n    if isinstance(target_types, six.string_types):\n        target_types = [target_types]\n\n    seen = set()\n    timeout = float(timeout) / tries\n    type_filter = set(target_types) if target_types else None\n    with contextlib.closing(make_socket()) as sock:\n        for i in range(tries):\n            if target_types:\n                for target_type in target_types:\n                    request_via_socket(sock, target_type)\n            for response in responses_from_socket(sock, timeout):\n                discovery = Discovery(response)\n                if discovery in seen:\n                    continue\n                seen.add(discovery)\n                if type_filter and discovery.type not in target_types:\n                    continue\n                yield discovery", "response": "Searches for the specified target types and returns a list of discovery instances for each found resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart watching the socket.", "response": "def start(self):\n        \"\"\"Start watching the socket.\"\"\"\n        if self.closed:\n            raise ConnectionClosed()\n\n        self.read_watcher.start()\n        if self.write == self.buffered_write:\n            self.write_watcher.start()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stop(self):\n        if self.closed:\n            raise ConnectionClosed()\n\n        if self.read_watcher.active:\n            self.read_watcher.stop()\n        if self.write_watcher.active:\n            self.write_watcher.stop()", "response": "Stop watching the socket."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unbuffered_write(self, buf):\n        if self.closed:\n            raise ConnectionClosed()\n\n        result = 0\n        try:\n            result = self.sock.send(buf)\n        except EnvironmentError as e:\n            # if the socket is simply backed up ignore the error \n            if e.errno != errno.EAGAIN: \n                self._close(e)\n                return\n\n        # when the socket buffers are full/backed up then we need to poll to see\n        # when we can write again\n        if result != len(buf):\n            self.write = self.buffered_write\n            self.write_watcher.start()\n            self.write(buf[result:])", "response": "Performs an unbuffered write on the specified buffer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef buffered_write(self, buf):\n        if self.closed:\n            raise ConnectionClosed()\n\n        if len(buf) + len(self.write_buffer) > self.max_size:\n            raise BufferOverflowError()\n        else:\n            self.write_buffer.extend(buf)", "response": "Appends a bytes like object to the transport write buffer. Raises ConnectionClosed Raises BufferOverflowError Raises BufferOverflowError Raises BufferOverflowError Raises BufferOverflowError Raises BufferOverflowError"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling by the pyev watcher when the socket is writtable.", "response": "def _writtable(self, watcher, events):\n        \"\"\"Called by the pyev watcher (self.write_watcher) whenever the socket\n        is writtable.\n\n        Calls send using the userspace buffer (self.write_buffer) and checks\n        for errors. If there are no errors then continue on as before.\n        Otherwise closes the socket and calls close_cb with the error.\n\n        \"\"\"\n        try:\n            sent = self.sock.send(bytes(self.write_buffer))\n            self.write_buffer = self.write_buffer[sent:]\n            if len(self.write_buffer) == 0:\n                self.write_watcher.stop()\n                self.write = self.unbuffered_write\n        except EnvironmentError as e:\n            self._close(e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _readable(self, watcher, events):\n        try:\n            data = self.sock.recv(4096)\n            if len(data) == 0:\n                self._close(ConnectionClosed())\n            else:\n                self.read_cb(data)\n        except IOError as e:\n            self._close(e)", "response": "Called by the pyev watcher when the socket is readable."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_context(name, doc):\n    name = inflection.underscore(name)\n    return {\n        'name': name,\n        'doc': doc or name\n    }", "response": "Generate a command with given name and doc."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mount(name,volumes):\n    '''\n    volumes: [{\n        \"volume\": \"root\",\n        \"hostpath\": \"/\"\n    },\n    ...\n    ]\n    '''\n    for vol in volumes:\n        try:\n            out, err = subprocess.Popen([\"VBoxManage\",\"sharedfolder\",\"add\",name,\"--name\",vol[\"volume\"],\"--hostpath\",vol[\"hostpath\"]],\n                                        stdout=PIPE,stderr=PIPE).communicate()\n        except Exception as e:\n            utils.error(e)\n            return False\n    return True", "response": "Mount a set of volumes to the local machine."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef install_optimal_reactor(verbose=False):\n    import sys\n    from twisted.python import reflect\n\n    ## determine currently installed reactor, if any\n    ##\n    if 'twisted.internet.reactor' in sys.modules:\n        current_reactor = reflect.qual(sys.modules['twisted.internet.reactor'].__class__).split('.')[-1]\n    else:\n        current_reactor = None\n\n    ## depending on platform, install optimal reactor\n    ##\n    if 'bsd' in sys.platform or sys.platform.startswith('darwin'):\n\n        ## *BSD and MacOSX\n        ##\n        if current_reactor != 'KQueueReactor':\n            try:\n                v = sys.version_info\n                if v[0] == 1 or (v[0] == 2 and v[1] < 6) or (v[0] == 2 and v[1] == 6 and v[2] < 5):\n                    raise Exception(\"Python version too old ({0}) to use kqueue reactor\".format(sys.version))\n                from twisted.internet import kqreactor\n                kqreactor.install()\n            except Exception as e:\n                print(\n                \"WARNING: Running on *BSD or MacOSX, but cannot install kqueue Twisted reactor ({0}).\".format(e))\n            else:\n                if verbose:\n                    print(\"Running on *BSD or MacOSX and optimal reactor (kqueue) was installed.\")\n        else:\n            if verbose:\n                print(\"Running on *BSD or MacOSX and optimal reactor (kqueue) already installed.\")\n\n    elif sys.platform in ['win32']:\n\n        ## Windows\n        ##\n        if current_reactor != 'IOCPReactor':\n            try:\n                from twisted.internet.iocpreactor import reactor as iocpreactor\n                iocpreactor.install()\n            except Exception as e:\n                print(\"WARNING: Running on Windows, but cannot install IOCP Twisted reactor ({0}).\".format(e))\n            else:\n                if verbose:\n                    print(\"Running on Windows and optimal reactor (ICOP) was installed.\")\n        else:\n            if verbose:\n                print(\"Running on Windows and optimal reactor (ICOP) already installed.\")\n\n    elif sys.platform.startswith('linux'):\n\n        ## Linux\n        ##\n        if current_reactor != 'EPollReactor':\n            try:\n                from twisted.internet import epollreactor\n                epollreactor.install()\n            except Exception as e:\n                print(\"WARNING: Running on Linux, but cannot install Epoll Twisted reactor ({0}).\".format(e))\n            else:\n                if verbose:\n                    print(\"Running on Linux and optimal reactor (epoll) was installed.\")\n        else:\n            if verbose:\n                print(\"Running on Linux and optimal reactor (epoll) already installed.\")\n\n    else:\n        try:\n            from twisted.internet import default as defaultreactor\n            defaultreactor.install()\n        except Exception as e:\n            print(\"WARNING: Could not install default Twisted reactor for this platform ({0}).\".format(e))", "response": "Try to install the optimal Twisted reactor for platform."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninstalling Twisted reactor. :param explicitReactor: If provided, install this reactor. Else, install optimal reactor. :type explicitReactor: obj :param verbose: If ``True``, print what happens. :type verbose: bool", "response": "def install_reactor(explicitReactor=None, verbose=False):\n    \"\"\"\n    Install Twisted reactor.\n\n    :param explicitReactor: If provided, install this reactor. Else, install optimal reactor.\n    :type explicitReactor: obj\n    :param verbose: If ``True``, print what happens.\n    :type verbose: bool\n    \"\"\"\n    import sys\n\n    if explicitReactor:\n        ## install explicitly given reactor\n        ##\n        from twisted.application.reactors import installReactor\n        print(\"Trying to install explicitly specified Twisted reactor '%s'\" % explicitReactor)\n        try:\n            installReactor(explicitReactor)\n        except Exception as e:\n            print(\"Could not install Twisted reactor %s%s\" % (explicitReactor, ' [\"%s\"]' % e if verbose else ''))\n            sys.exit(1)\n    else:\n        ## automatically choose optimal reactor\n        ##\n        if verbose:\n            print(\"Automatically choosing optimal Twisted reactor\")\n        install_optimal_reactor(verbose)\n\n    ## now the reactor is installed, import it\n    from twisted.internet import reactor\n\n    if verbose:\n        from twisted.python.reflect import qual\n        print(\"Running Twisted reactor %s\" % qual(reactor.__class__))\n\n    return reactor"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a callback that adds our headers to the response.", "response": "def start_response_callback(start_response, origin):\n        \"\"\"Intercept upstream start_response and adds our headers.\"\"\"\n        def callback(status, headers, exc_info=None):\n            \"\"\"Add our headers to response using a closure.\"\"\"\n            headers.append(('Access-Control-Allow-Origin', origin))\n            # Call upstream start_response\n            start_response(status, headers, exc_info)\n        return callback"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clean_cache(self, section=None):\n        self.remove_all_locks()\n        if section is not None and \"/\" in section:\n            raise ValueError(\"invalid section '{0}'\".format(section))\n        if section is not None:\n            path = os.path.join(self._full_base, section)\n        else:\n            path = self._full_base\n        if not os.path.exists(path):\n            return\n        shutil.rmtree(path)", "response": "Cleans the cache of this object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_file(self, cache_id_obj, section=None):\n        section = \"default\" if section is None else section\n        if \"/\" in section:\n            raise ValueError(\"invalid section '{0}'\".format(section))\n        cache_id = \"{:08x}\".format(\n            zlib.crc32(b\"&\".join(sorted([\n                str(k).encode('utf8') + b\"=\" + str(v).encode('utf8')\n                for k, v in cache_id_obj.items()\n            ]))) & 0xffffffff)\n        return os.path.join(self._full_base,\n                            os.path.join(section,\n                                         os.path.join(\n                                             \"{0}\".format(cache_id[:2]),\n                                             \"{0}.tmp\".format(cache_id[2:]))))", "response": "Returns the file path for the given cache object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove all locks and ensures their content is written to disk.", "response": "def remove_all_locks(self):\n        \"\"\"Removes all locks and ensures their content is written to disk.\"\"\"\n        locks = list(self._locks.items())\n        locks.sort(key=lambda l: l[1].get_last_access())\n        for l in locks:\n            self._remove_lock(l[0])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_hnd(self, cache_id_obj, section=None, method=None):\n        cache_file = self.get_file(cache_id_obj, section)\n        if cache_file not in self._locks:\n            try:\n                while not self._own.acquire(True):\n                    pass\n                if cache_file not in self._locks:\n                    if method is None:\n                        m = self._method\n                    else:\n                        m = methods.get(method, None)\n                    if m is None:\n                        raise ValueError(\n                            \"unknown method: '{0}'\".format(method))\n                    res = _CacheLock(cache_file, cache_id_obj, self._full_base,\n                                     self._quota, self._ram_quota,\n                                     self._warnings, self.verbose, m)\n                    self._locks[cache_file] = res\n                else:\n                    res = None\n            finally:\n                self._own.release()\n        else:\n            res = None\n        if res is None:\n            res = self._locks[cache_file]\n            res.ensure_cache_id(cache_id_obj)\n        self.enforce_ram_quota()\n        return res", "response": "Gets a handle for the given cache id object with exclusive access."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ensure_cache_id(self, cache_id_obj):\n        cache_id = self._get_canonical_id(cache_id_obj)\n        if cache_id != self._cache_id_obj:\n            raise ValueError(\n                \"cache mismatch {0} != {1}\".format(\n                    cache_id, self._cache_id_obj))", "response": "Ensure the integrity of the cache id object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has(self):\n        self._done = os.path.exists(self._cache_file)\n        return self._done or self._out is not None", "response": "Whether the cache file exists in the file system."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading the cache file as pickle file.", "response": "def read(self):\n        \"\"\"Reads the cache file as pickle file.\"\"\"\n\n        def warn(msg, elapsed_time, current_time):\n            desc = self._cache_id_desc()\n            self._warnings(\n                \"{0} {1}: {2}s < {3}s\", msg, desc, elapsed_time, current_time)\n\n        file_time = get_time()\n        out = self._out\n        if out is None:\n            if self.verbose:\n                self._warnings(\"reading {0} from disk\", self._cache_id_desc())\n            with open(self._cache_file, 'rb') as f_in:\n                out = None\n                while True:\n                    t_out = f_in.read(CHUNK_SIZE)\n                    if not len(t_out):\n                        break\n                    if out is not None:\n                        out += t_out\n                    else:\n                        out = t_out\n                self._out = out\n        (cache_id_obj, elapsed_time, res) = self._read(out)\n        self.ensure_cache_id(cache_id_obj)\n        real_time = get_time() - file_time\n        if elapsed_time is not None and real_time > elapsed_time:\n            warn(\"reading cache from disk takes longer than computing!\",\n                 elapsed_time, real_time)\n        elif self._start_time is not None and elapsed_time is not None:\n            current_time = get_time() - self._start_time\n            if elapsed_time < current_time:\n                warn(\"reading cache takes longer than computing!\",\n                     elapsed_time, current_time)\n        self._last_access = get_time()\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite the given object to the cache file as pickle.", "response": "def write(self, obj):\n        \"\"\"Writes the given object to the cache file as pickle. The cache file with\n           its path is created if needed.\n        \"\"\"\n        if self.verbose:\n            self._warnings(\"cache miss for {0}\", self._cache_id_desc())\n        if self._start_time is not None:\n            elapsed = get_time() - self._start_time\n        else:\n            elapsed = None\n        out = self._write(self._cache_id_obj, elapsed, obj)\n        self._out = out\n        self.force_to_disk(self.get_size() > self._ram_quota)\n        self._last_access = get_time()\n        return self._read(out)[2]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds missing xml attributes to the mods tag.", "response": "def add_missing_xml_attributes(dom, volume_counter=0):\n    \"\"\"\n    Add `xmlns` and `ID` attributes to ``<mods:mods>`` tag.\n\n    Args:\n        dom (HTMLElement): DOM containing whole document.\n        volume_counter (int, default 0): ID of volume.\n    \"\"\"\n    mods_tag = get_mods_tag(dom)\n\n    if mods_tag:\n        params = mods_tag.params\n\n        # add missing attributes\n        params[\"ID\"] = \"MODS_VOLUME_%04d\" % (volume_counter + 1)\n        params[\"xmlns:mods\"] = \"http://www.loc.gov/mods/v3\"\n        params[\"xmlns:xlink\"] = \"http://www.w3.org/1999/xlink\"\n        params[\"xmlns:xsi\"] = \"http://www.w3.org/2001/XMLSchema-instance\"\n        params[\"xsi:schemaLocation\"] = \" \".join((\n            \"http://www.w3.org/2001/XMLSchema-instance\",\n            \"http://www.w3.org/2001/XMLSchema.xsd\",\n            \"http://www.loc.gov/mods/v3\",\n            \"http://www.loc.gov/standards/mods/v3/mods-3-4.xsd\",\n            \"http://www.w3.org/1999/xlink http://www.w3.org/1999/xlink.xsd\",\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_uuid(dom, uuid):\n    mods_tag = get_mods_tag(dom)\n\n    uuid_tag = dhtmlparser.HTMLElement(\n        \"mods:identifier\",\n        {\"type\": \"uuid\"},\n        [dhtmlparser.HTMLElement(uuid)]\n    )\n\n    insert_tag(uuid_tag, dom.find(\"mods:identifier\"), mods_tag)", "response": "Add uuid to mods tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds marccountry tag to the list of modules.", "response": "def add_marccountry_tag(dom):\n    \"\"\"\n    Add ``<mods:placeTerm>`` tag with proper content.\n    \"\"\"\n    marccountry = dom.find(\"mods:placeTerm\", {\"authority\": \"marccountry\"})\n\n    # don't add again if already defined\n    if marccountry:\n        return\n\n    marccountry_tag = dhtmlparser.HTMLElement(\n        \"mods:place\",\n        [\n            dhtmlparser.HTMLElement(\n                \"mods:placeTerm\",\n                {\"type\": \"code\", \"authority\": \"marccountry\"},\n                [dhtmlparser.HTMLElement(\"xr-\")]\n            )\n        ]\n    )\n    insert_tag(\n        marccountry_tag,\n        dom.match(\"mods:mods\", \"mods:originInfo\", \"mods:place\"),\n        first(dom.find(\"mods:originInfo\"))\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_genre(dom):\n    mods_tag = get_mods_tag(dom)\n\n    matched_genres = [\n        \"electronic title\",\n        \"electronic volume\",\n    ]\n    genre = dom.find(\n        \"mods:genre\",\n        fn=lambda x: x.getContent().lower().strip() in matched_genres\n    )\n\n    if not genre:\n        genre_tag = dhtmlparser.HTMLElement(\n            \"mods:genre\",\n            [dhtmlparser.HTMLElement(\"electronic volume\")]\n        )\n        insert_tag(genre_tag, dom.find(\"mods:originInfo\"), mods_tag)", "response": "Add genre to dom if not present."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_hairs_from_tags(dom):\n    transform_content(\n        dom.match(\"mods:mods\", \"mods:titleInfo\", \"mods:title\"),\n        lambda x: remove_hairs(x.getContent())\n    )\n    transform_content(\n        dom.match(\n            \"mods:originInfo\",\n            \"mods:place\",\n            [\"mods:placeTerm\", {\"type\": \"text\"}]\n        ),\n        lambda x: remove_hairs(x.getContent())\n    )", "response": "Remove hairs from the dom."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfixing the location tag in the xml.", "response": "def fix_location_tag(dom):\n    \"\"\"\n    Repair the <mods:location> tag (the XSLT template returns things related to\n    paper books, not electronic documents).\n    \"\"\"\n    location = dom.match(\n        \"mods:mods\",\n        \"mods:location\",\n    )\n\n    # if no location tag found, there is nothing to be fixed\n    if not location:\n        return\n    location = first(location)\n\n    # fix only <mods:location> containing <mods:physicalLocation> tags\n    if not location.find(\"mods:physicalLocation\"):\n        return\n\n    url = location.find(\"mods:url\", {\"usage\": \"primary display\"})\n\n    # parse URL\n    if url:\n        url = first(url).getContent()\n    else:\n        urls = filter(\n            lambda x: x.getContent(),\n            location.find(\"mods:url\")\n        )\n\n        if not urls:\n            return\n\n        url_tag = max(urls, key=lambda x: len(x.getContent()))\n        url = url_tag.getContent()\n\n    # replace the code with new tag\n    replacer = dhtmlparser.parseString(\"\"\"\n  <mods:location>\n    <mods:holdingSimple>\n      <mods:copyInformation>\n        <mods:electronicLocator>\"\"\" + url + \"\"\"</mods:electronicLocator>\n      </mods:copyInformation>\n    </mods:holdingSimple>\n  </mods:location>\n    \"\"\")\n\n    location.replaceWith(\n        first(replacer.find(\"mods:location\"))\n    )\n\n    dhtmlparser.makeDoubleLinked(dom)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fix_related_item_tag(dom):\n    location = dom.match(\n        \"mods:mods\",\n        \"mods:relatedItem\",\n        \"mods:location\"\n    )\n\n    if not location:\n        return\n    location = first(location)\n\n    location.replaceWith(\n        dhtmlparser.HTMLElement()\n    )\n\n    # remove whole <mods:relatedItem> tag, if there is nothing else left in it\n    related_item = dom.match(\n        \"mods:mods\",\n        \"mods:relatedItem\"\n    )\n    related_item = first(related_item)\n\n    if not related_item.getContent().strip():\n        related_item.replaceWith(dhtmlparser.HTMLElement())", "response": "Fix relatedItem tag in the mod s tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfix missing electronic locator tag in MODS.", "response": "def fix_missing_electronic_locator_tag(dom, url):\n    \"\"\"\n    In case that MODS contains no URL and the location is wrong (physical), add\n    url from `url` parameter.\n    \"\"\"\n    electronic_locator = dom.match(\n        \"mods:mods\",\n        \"mods:location\",\n        \"mods:holdingSimple\",\n        \"mods:copyInformation\",\n        \"mods:electronicLocator\",\n    )\n    # do not try to fix correct records\n    if electronic_locator:\n        return\n\n    # if no location tag found, add it\n    location = dom.match(\"mods:mods\", \"mods:location\")\n    if location:\n        location = first(location)\n    else:\n        location_tag = dhtmlparser.parseString(\n            \"<mods:location></mods:location>\"\n        )\n\n        insert_tag(\n            location_tag,\n            dom.find(\"mods:recordInfo\"),\n            get_mods_tag(dom)\n        )\n\n        location = first(dom.match(\"mods:mods\", \"mods:location\"))\n\n    replacer = dhtmlparser.parseString(\"\"\"\n  <mods:location>\n    <mods:holdingSimple>\n      <mods:copyInformation>\n        <mods:electronicLocator>\"\"\" + url + \"\"\"</mods:electronicLocator>\n      </mods:copyInformation>\n    </mods:holdingSimple>\n  </mods:location>\n    \"\"\")\n\n    location.replaceWith(\n        first(replacer.find(\"mods:location\"))\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fix_missing_lang_tags(marc_xml, dom):\n    def get_lang_tag(lang):\n        lang_str = '\\n  <mods:language>\\n'\n        lang_str += '    <mods:languageTerm authority=\"iso639-2b\" type=\"code\">'\n        lang_str += lang\n        lang_str += '</mods:languageTerm>\\n'\n        lang_str += '  </mods:language>\\n\\n'\n\n        lang_dom = dhtmlparser.parseString(lang_str)\n\n        return first(lang_dom.find(\"mods:language\"))\n\n    for lang in reversed(marc_xml[\"041a0 \"]):\n        lang_tag = dom.find(\n            \"mods:languageTerm\",\n            fn=lambda x: x.getContent().strip().lower() == lang.lower()\n        )\n        if not lang_tag:\n            insert_tag(\n                get_lang_tag(lang),\n                dom.find(\"mods:language\"),\n                get_mods_tag(dom)\n            )", "response": "Fix missing lang tags in MODS."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef postprocess_monograph(marc_xml, mods, uuid, counter, url):\n    dom = double_linked_dom(mods)\n\n    if not isinstance(marc_xml, MARCXMLRecord):\n        marc_xml = MARCXMLRecord(marc_xml)\n\n    add_missing_xml_attributes(dom, counter)\n    fix_invalid_type_parameter(dom)\n\n    if uuid:\n        add_uuid(dom, uuid)\n\n    add_marccountry_tag(dom)\n\n    # add <genre> tag if not found\n    add_genre(dom)\n\n    # remove hairs from some tags\n    remove_hairs_from_tags(dom)\n\n    fix_issuance(dom)\n    fix_location_tag(dom)\n    fix_related_item_tag(dom)\n\n    fix_missing_electronic_locator_tag(dom, url)\n    fix_missing_lang_tags(marc_xml, dom)\n\n    return dom.prettify()", "response": "Postprocess the marc_xml string generated by XSLT template."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a suffix to a string.", "response": "def add_suffix(string, suffix):\n    \"\"\"\n    Adds a suffix to a string, if the string does not already have that suffix.\n\n    :param string: the string that should have a suffix added to it\n    :param suffix: the suffix to be added to the string\n    :return: the string with the suffix added, if it does not already end in\n        the suffix. Otherwise, it returns the original string.\n    \"\"\"\n    if string[-len(suffix):] != suffix:\n        return string + suffix\n    else:\n        return string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef upload(csvpath, asset_manager_id=None, client_id=None):\n        interface = interface_direct_csvpath(csvpath)\n        logging.config.dictConfig(DEFAULT_LOGGING)\n        logger = logging.getLogger(__name__)\n        if asset_manager_id is None:\n            params = dict()\n        elif client_id is None:\n            params = {'asset_manager_id': asset_manager_id}\n        else:\n            params = {'asset_manager_id': asset_manager_id, 'client_id': client_id}\n        with open(csvpath) as csvfile:\n            objs = csv_stream_to_objects(stream=csvfile, json_handler=Uploader.json_handler, params=params)\n        for obj in objs:\n            interface.new(obj)\n            logger.info('Creating this object and upload to database successfully')", "response": "convert csv file rows to objects and insert"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving the objs mainly for test purposes", "response": "def download(csvpath, asset_manager_id, data_id_type, data_id_list):\n        \"\"\"retrieve the objs mainly for test purposes\"\"\"\n        interface = interface_direct_csvpath(csvpath)\n        logging.config.dictConfig(DEFAULT_LOGGING)\n        logger = logging.getLogger(__name__)\n        objs = []\n        for data_id in data_id_list:\n            Dict = dict()\n            Dict[data_id_type] = data_id\n            objs.append(interface.retrieve(asset_manager_id=asset_manager_id, **Dict))\n        return objs"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert args to a tuple unless there s one arg and it s a function then acts a decorator.", "response": "def tuplify(*args):\n    \"\"\"\n    Convert args to a tuple, unless there's one arg and it's a\n    function, then acts a decorator.\n    \"\"\"\n    if (len(args) == 1) and callable(args[0]):\n        func = args[0]\n\n        @wraps(func)\n        def _inner(*args, **kwargs):\n            return tuple(func(*args, **kwargs))\n        return _inner\n    else:\n        return tuple(args)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef listify(*args):\n    if (len(args) == 1) and callable(args[0]):\n        func = args[0]\n\n        @wraps(func)\n        def _inner(*args, **kwargs):\n            return list(func(*args, **kwargs))\n        return _inner\n    else:\n        return list(args)", "response": "Convert args to a list unless there s one arg and it s a\n    function then acts a decorator."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef stringify(*args):\n    if (len(args) == 1) and callable(args[0]):\n        func = args[0]\n\n        @wraps(func)\n        def _inner(*args, **kwargs):\n            return \"\".join([str(i) for i in func(*args, **kwargs)])\n        return _inner\n    else:\n        return \"\".join([str(i) for i in args])", "response": "Joins args to build a string unless there s one arg and it s a\n    function then acts a decorator."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a generator that yields the url template with the regex named groups", "response": "def add_path_part(url, regex=PATH_PART):\n    \"\"\"\n    replace the variables in a url template with regex named groups\n    :param url: string of a url template\n    :param regex: regex of the named group\n    :returns: regex\n    \"\"\"\n    formatter = string.Formatter()\n    url_var_template = \"(?P<{var_name}>{regex})\"\n\n    for part in formatter.parse(url):\n        string_part, var_name, _, _ = part\n        if string_part:\n            yield string_part\n        if var_name:\n            yield url_var_template.format(var_name=var_name, regex=regex)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_endpoints(version, name, endpoints, kwargs=None):\n    if kwargs is None:\n        kwargs = {}\n\n    version_url_prefix = '/v{}/{}'.format(version.split('.')[0], name)\n    yield (r\"/\", RedirectHandler, {\"url\": r\"{}\".format(version_url_prefix)})\n    for endpoint in add_prefix(endpoints, version_url_prefix, kwargs):\n        yield endpoint", "response": "Generates a list of endpoints that are added to the given list of endpoints."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sanitise_capabilities(capabilities):\n    for c in REQUIRED_CAPABILITIES:\n        capabilities[c] = options[c]\n\n    for c in PROTECTED_CAPABILITIES:\n        if c in capabilities:\n            del capabilities['client_secret']\n\n    return capabilities", "response": "Sanitize the capabilities dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef message_box(type, title, message, icon=None, buttons=QMessageBox.Ok, custom_buttons=None):\n\n    LOGGER.debug(\"> Launching messagebox().\")\n    LOGGER.debug(\"> Message type: '{0}'.\".format(type))\n    LOGGER.debug(\"> Title: '{0}'.\".format(title))\n    LOGGER.debug(\"> Message: '{0}'.\".format(message))\n\n    message_box = QMessageBox()\n    message_box.setWindowTitle(\"{0} | {1}\".format(Constants.application_name, title))\n    message_box.setText(message)\n\n    for button, role in custom_buttons or ():\n        message_box.addButton(button, role)\n    umbra.ui.common.set_children_padding(message_box, (QPushButton,), width=12)\n\n    message = message.split(\"\\n\")\n    if type == \"Critical\":\n        if icon:\n            message_box.setIcon(icon)\n        else:\n            message_box.setIcon(QMessageBox.Critical)\n        for line in message:\n            LOGGER.critical(\"!> {0}\".format(line))\n    elif type == \"Error\":\n        if icon:\n            message_box.setIcon(icon)\n        else:\n            message_box.setIcon(QMessageBox.Critical)\n        for line in message:\n            LOGGER.error(\"!> {0}\".format(line))\n    elif type == \"Detailed Error\":\n        if icon:\n            message_box.setIcon(icon)\n        else:\n            message_box.setIcon(QMessageBox.Critical)\n        RuntimeGlobals.logging_session_handler_stream and \\\n        message_box.setDetailedText(\"\".join(RuntimeGlobals.logging_session_handler_stream.stream))\n        text_edit = message_box.findChild(QTextEdit)\n        if text_edit:\n            text_edit.setCurrentFont(QFont(\"Courier\"))\n            text_edit.setLineWrapMode(QTextEdit.NoWrap)\n            text_edit.moveCursor(QTextCursor.End)\n            text_edit.ensureCursorVisible()\n        for line in message:\n            LOGGER.error(\"!> {0}\".format(line))\n    elif type == \"Warning\":\n        if icon:\n            message_box.setIcon(icon)\n        else:\n            message_box.setIcon(QMessageBox.Warning)\n        for line in message:\n            LOGGER.warning(\"{0}\".format(line))\n    elif type == \"Information\":\n        if icon:\n            message_box.setIcon(icon)\n        else:\n            message_box.setIcon(QMessageBox.Information)\n        for line in message:\n            LOGGER.info(\"{0}\".format(line))\n    elif type == \"Question\":\n        if icon:\n            message_box.setIcon(icon)\n        else:\n            message_box.setIcon(QMessageBox.Question)\n        for line in message:\n            LOGGER.info(\"{0}\".format(line))\n\n    message_box.setStandardButtons(buttons)\n    message_box.setWindowFlags(Qt.WindowStaysOnTopHint)\n    message_box.show()\n    foundations.ui.common.center_widget_on_screen(message_box)\n    return message_box.exec_()", "response": "Launches a fast GUI message box."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsplits a string by sep and yield chunks of strings", "response": "def itersplit(s, sep=None):\n    \"\"\"\n    Split a string by ``sep`` and yield chunks\n\n    Args:\n        s (str-type): string to split\n        sep (str-type): delimiter to split by\n\n    Yields:\n        generator of strings: chunks of string s\n    \"\"\"\n    if not s:\n        yield s\n        return\n    exp = re.compile(r'\\s+' if sep is None else re.escape(sep))\n    pos = 0\n    while True:\n        m = exp.search(s, pos)\n        if not m:\n            if pos < len(s) or sep is not None:\n                yield s[pos:]\n            break\n        if pos < m.start() or sep is not None:\n            yield s[pos:m.start()]\n        pos = m.end()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sh(cmd, ignore_error=False, cwd=None, shell=False, **kwargs):\n    kwargs.update({\n        'shell': shell,\n        'cwd': cwd,\n        'stderr': subprocess.STDOUT,\n        'stdout': subprocess.PIPE,})\n    log.debug((('cmd', cmd), ('kwargs', kwargs)))\n    p = subprocess.Popen(cmd, universal_newlines=True, **kwargs)\n    p_stdout = p.communicate()[0]\n    if p.returncode and not ignore_error:\n        raise subprocess.CalledProcessError(p.returncode, cmd, p_stdout)\n    return p_stdout", "response": "Execute a command with subprocess. Popen and block until output is available"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch for repositories with a stack and ``os.listdir`` Args: where (str): path to search from Yields: Repository subclass instance", "response": "def listdir_find_repos(where):\n    \"\"\"\n    Search for repositories with a stack and ``os.listdir``\n\n    Args:\n        where (str): path to search from\n\n    Yields:\n        Repository subclass instance\n    \"\"\"\n    stack = deque([(convert_path(where), '')])\n    while stack:\n        where, prefix = stack.pop()\n        try:\n            for name in sorted(os.listdir(where), reverse=True):\n                fn = os.path.join(where, name)\n                if name in REPO_PREFIXES:\n                    if 1:  # os.path.exists(fn):\n                        # yield name[1:], fn.rstrip(name)[:-1] # abspath\n                        repo = REPO_PREFIXES[name](fn.rstrip(name)[:-1])\n                        yield repo\n                    stack.append((fn, prefix + name + '/'))\n        except OSError as e:\n            if e.errno == errno.EACCES:\n                log.error(\"Skipping: %s\", e)\n            else:\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_find_repos(where, ignore_error=True):\n    log.debug(('REPO_REGEX', REPO_REGEX))\n    FIND_REPO_REGEXCMD = (\"-regex\", '.*(%s)$' % REPO_REGEX)\n    if os.uname()[0] == 'Darwin':\n        cmd = (\"find\",\n               '-E',\n               '-L',  # dereference symlinks\n               where,\n               FIND_REPO_REGEXCMD[0],\n               FIND_REPO_REGEXCMD[1])\n    else:\n        cmd = (\"find\",\n               '-O3',\n               '-L',  # dereference symlinks\n               where,  # \" .\",\n               \"-regextype\",\"posix-egrep\",\n               FIND_REPO_REGEXCMD[0],\n               FIND_REPO_REGEXCMD[1])\n    _cmd = ' '.join(cmd)\n    log.debug(\"find_find_repos(%r) = %s\" % (where, _cmd))\n    kwargs = {\n        #'shell': True,\n        'cwd': where,\n        'stderr': sys.stderr,\n        'stdout': subprocess.PIPE,}\n    p = subprocess.Popen(cmd, universal_newlines=True, **kwargs)\n    if p.returncode and not ignore_error:\n        p_stdout = p.communicate()[0]\n        raise Exception(\"Subprocess return code: %d\\n%r\\n%r\" % (\n            p.returncode, cmd, p_stdout))\n\n    for l in iter(p.stdout.readline, ''):\n        path = l.rstrip()\n        _path, _prefix = os.path.dirname(path), os.path.basename(path)\n        repo = REPO_PREFIXES.get(_prefix)\n        if repo is None:\n            log.error(\"repo for path %r and prefix %r is None\" %\n                      (path, _prefix))\n        if repo:\n            yield repo(_path)", "response": "Find all repositories in a directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding unique repositories and deduplicate based on repo. fpath", "response": "def find_unique_repos(where):\n    \"\"\"\n    Search for repositories and deduplicate based on ``repo.fpath``\n\n    Args:\n        where (str): path to search from\n\n    Yields:\n        Repository subclass\n    \"\"\"\n    repos = Dict()\n    path_uuids = Dict()\n    log.debug(\"find_unique_repos(%r)\" % where)\n    for repo in find_find_repos(where):\n        # log.debug(repo)\n        repo2 = (hasattr(repo, 'search_upwards')\n                 and repo.search_upwards(upwards=path_uuids))\n        if repo2:\n            if repo2 == repo:\n                continue\n            else:\n                repo = repo2\n\n        if (repo.fpath not in repos):\n            log.debug(\"%s | %s | %s\" %\n                      (repo.prefix, repo.fpath, repo.unique_id))\n            repos[repo.fpath] = repo\n            yield repo"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_repo_report(repos, report='full', output=sys.stdout, *args, **kwargs):\n    for i, repo in enumerate(repos):\n        log.debug(str((i, next(repo.origin_report()))))\n        try:\n            if repo is not None:\n                reportfunc = REPORT_TYPES.get(report)\n                if reportfunc is None:\n                    raise Exception(\"Unrecognized report type: %r (%s)\" %\n                                    (report, ', '.join(REPORT_TYPES.keys())))\n                for l in reportfunc(repo, *args, **kwargs):\n                    print(l, file=output)\n        except Exception as e:\n            log.error(repo)\n            log.error(report)\n            log.error(e)\n            raise\n\n        yield repo", "response": "Do a repository report"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a thg - reporegistry. xml file from a list of repos and print it to output", "response": "def do_tortoisehg_report(repos, output):\n    \"\"\"\n    Generate a thg-reporegistry.xml file from a list of repos and print\n    to output\n\n    Args:\n        repos (iterable): iterable of Repository subclass instances\n        output (writeable): output stream to which THG XML will be printed\n    \"\"\"\n    import operator\n    import xml.etree.ElementTree as ET\n\n    root = ET.Element('reporegistry')\n    item = ET.SubElement(root, 'treeitem')\n\n    group = ET.SubElement(item, 'group', attrib=Dict(name='groupname'))\n\n    def fullname_to_shortname(fullname):\n        \"\"\"\n        Return a TortoiseHG-friendly path to a repository\n\n        Args:\n            fullname (str): path to repository\n\n        Returns:\n            str: path with $HOME replaced with ``~`` and leading ``./``\n                stripped\n        \"\"\"\n        shortname = fullname.replace(os.environ['HOME'], '~')\n        shortname = shortname.lstrip('./')\n        return shortname\n\n    for repo in sorted(repos, key=operator.attrgetter('fpath')):\n        fullname = os.path.join(\n            os.path.dirname(repo.fpath),\n            os.path.basename(repo.fpath))\n        shortname = fullname_to_shortname(fullname)\n        if repo.prefix != '.hg':\n            shortname = \"%s%s\" % (shortname, repo.prefix)\n        _ = ET.SubElement(group, 'repo',\n                          attrib=Dict(\n                              root=repo.fpath,\n                              shortname=shortname,\n                              basenode='0'*40))\n        _\n    print('<?xml version=\"1.0\" encoding=\"UTF-8\"?>', file=output)\n    print(\"<!-- autogenerated: %s -->\" % \"TODO\", file=output)\n    print(ET.dump(root), file=output)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_option_parser():\n    import optparse\n\n    prs = optparse.OptionParser(\n        usage=(\n            \"$0 pyrpo [-h] [-v] [-q] [-s .] \"\n            \"[-r <report>] [--thg]\"))\n\n    prs.add_option('-s', '--scan',\n                   dest='scan',\n                   action='append',\n                   default=[],\n                   help='Path(s) to scan for repositories')\n\n    prs.add_option('-r', '--report',\n                   dest='reports',\n                   action='append',\n                   default=[],\n                   help=(\"\"\"origin, status, full, gitmodule, json, sh, \"\"\"\n                         \"\"\"str, pip, hgsub\"\"\"))\n    prs.add_option('--thg',\n                   dest='thg_report',\n                   action='store_true',\n                   help='Write a thg-reporegistry.xml file to stdout')\n\n    prs.add_option('--template',\n                   dest='report_template',\n                   action='store',\n                   help='Report template')\n\n    prs.add_option('-v', '--verbose',\n                   dest='verbose',\n                   action='store_true',)\n    prs.add_option('-q', '--quiet',\n                   dest='quiet',\n                   action='store_true',)\n\n    return prs", "response": "Build an optparse. OptionParser for pyrpo commandline use\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main(argv=None):\n\n    import logging\n\n    if argv is None:\n        argv = sys.argv\n\n    prs = get_option_parser()\n    (opts, args) = prs.parse_args(args=argv)\n\n    if not opts.quiet:\n        _format = None\n        _format = \"%(levelname)s\\t%(message)s\"\n        # _format = \"%(message)s\"\n        logging.basicConfig(format=_format)\n\n    log = logging.getLogger('repos')\n\n    if opts.verbose:\n        log.setLevel(logging.DEBUG)\n    elif opts.quiet:\n        log.setLevel(logging.ERROR)\n    else:\n        log.setLevel(logging.INFO)\n    if not opts.scan:\n        opts.scan = ['.']\n\n    if opts.scan:\n        # if not opts.reports:\n        #     opts.reports = ['pip']\n        if opts.reports or opts.thg_report:\n            opts.reports = [s.strip().lower() for s in opts.reports]\n            if 'thg' in opts.reports:\n                opts.thg_report = True\n                opts.reports.remove('thg')\n            # repos = []\n            # for _path in opts.scan:\n            #     repos.extend(find_unique_repos(_path))\n            log.debug(\"SCANNING PATHS: %s\" % opts.scan)\n            repos = chain(*imap(find_unique_repos, opts.scan))\n\n            if opts.reports and opts.thg_report:\n                repos = list(repos)\n                # TODO: tee\n\n            if opts.reports:\n                for report in opts.reports:\n                    list(do_repo_report(repos, report=report))\n            if opts.thg_report:\n                do_tortoisehg_report(repos, output=sys.stdout)\n\n        else:\n            opts.scan = '.'\n            list(do_repo_report(\n                find_unique_repos(opts.scan),\n                report='sh'))\n    return 0", "response": "This function is called by the command line interface to get the available items from the command line."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef relpath(self):\n        here = os.path.abspath(os.path.curdir)\n        relpath = os.path.relpath(self.fpath, here)\n        return relpath", "response": "Determine the relative path to this repository\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsplits ( or parse ) repository log output into fields tuple", "response": "def itersplit_to_fields(self, _str):\n        \"\"\"\n        Split (or parse) repository log output into fields\n\n        Returns:\n            tuple: self._tuple(*values)\n        \"\"\"\n        if self.preparse:\n            _str = self.preparse(_str)\n\n        _fields = itersplit(_str, self.fsep)\n\n        try:\n            values = (\n                t[1] for t in izip_longest(self._tuple._fields, _fields))\n            return self._tuple(*values)\n        except Exception as e:\n            log.error(self._tuple)\n            log.error(_fields)\n            log.exception(e)\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef log_iter(self, maxentries=None, template=None, **kwargs):\n        # op = self.sh((\n        #   \"hg log %s --template\"\n        #   % (maxentries and ('-l%d' % maxentries) or '')),\n        #   ignore_error=True\n        # )\n        template = str(template or self.template)\n        op = self.log(n=maxentries, template=template, **kwargs)\n        if not op:\n            return\n        print(op)\n        for l in itersplit(op, self.lsep):\n            l = l.strip()\n            if not l:\n                continue\n            try:\n                yield self._parselog(l,)\n            except Exception:\n                log.error(\"%s %r\" % (str(self), l))\n                raise\n        return", "response": "Run the repository log command parse and yield log tuples"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef full_report(self):\n        yield ''\n        yield \"# %s\" % next(self.origin_report())\n        yield \"%s [%s]\" % (self.last_commit, self)\n        if self.status:\n            for l in self.status.split('\\n'):\n                yield l\n            yield ''\n\n        if hasattr(self, 'log_iter'):\n            for r in self.log_iter():\n                yield r\n        return", "response": "Generate a full report of the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sh_report(self, full=True, latest=False):\n\n        def pathvar_repr(var):\n            _var = var.replace('\"', '\\\"')\n            return '\"%s\"' % _var\n\n        output = []\n        if not self.remote_url:\n            output.append('#')\n        output = output + (\n            [self.label]\n            + self.clone_cmd\n            + [pathvar_repr(self.remote_url)]  # TODO: shell quote?\n            + [pathvar_repr(self.relpath)]\n        )\n        yield ''\n        yield \"## %s\" % pathvar_repr(self.relpath)\n        yield ' '.join(output)\n\n        if full:\n            checkout_rev = self.current_id\n            # if latest: checkout_rev = self.branch\n\n            relpath = pathvar_repr(self.relpath) if self.relpath else None\n            relpath = relpath if relpath else ''\n            checkout_branch_cmd = (\n                [self.label]\n                + self.checkout_branch_cmd + [self.branch]\n                + self.repo_abspath_cmd\n                + [relpath])\n            checkout_rev_cmd = (\n                [self.label]\n                + self.checkout_rev_cmd + [checkout_rev]\n                + self.repo_abspath_cmd\n                + [relpath])\n\n            if latest:\n                checkout_cmd = checkout_branch_cmd\n                comment = checkout_rev_cmd\n            else:\n                checkout_cmd = checkout_rev_cmd\n                comment = checkout_branch_cmd\n\n            yield ' '.join(c for c in checkout_cmd if c is not None)\n            yield '### %s' % ' '.join(c for c in comment if c is not None)\n            # output.extend([checkout_cmd, ';', ' ###', comment])\n\n            for x in self.recreate_remotes_shellcmd():\n                yield x", "response": "Generate the shell command necessary to clone this repository and print it out."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield a. hgsubs line for this repository", "response": "def hgsub_report(self):\n        \"\"\"\n        Yields:\n            str: .hgsubs line for this repository\n        \"\"\"\n        if self.relpath == '.':\n            return\n        yield \"%s = [%s]%s\" % (\n            self.fpath.lstrip('./'),\n            self.label,\n            self.remote_url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nyields the gitmodules configuration lines for this repository", "response": "def gitmodule_report(self):\n        \"\"\"\n        Yields:\n            str: .gitmodules configuration lines for this repository\n        \"\"\"\n        fpath = self.relpath\n        if fpath == '.':\n            return\n        yield '[submodule \"%s\"]' % fpath.replace(os.path.sep, '_')\n        yield \"    path = %s\" % fpath\n        yield \"    url = %s\" % self.remote_url\n        yield \"\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mtime(self, fpath=None):\n        return dtformat(\n            datetime.datetime.utcfromtimestamp(\n                os.path.getmtime(fpath or self.fpath)))", "response": "Returns strftime - formatted mtime of fpath"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn strftime - formatted ctime of fpath", "response": "def ctime(self, fpath=None):\n        \"\"\"\n        Returns:\n            str: strftime-formatted ctime (creation time) of fpath\n        \"\"\"\n        return dtformat(\n            datetime.datetime.utcfromtimestamp(\n                os.path.getctime(fpath or self.fpath)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nshows count most recent modified files by mtime", "response": "def lately(self, count=15):\n        \"\"\"\n        Show ``count`` most-recently modified files by mtime\n\n        Yields:\n            tuple: (strftime-formatted mtime, self.fpath-relative file path)\n        \"\"\"\n        excludes = '|'.join(('*.pyc', '*.swp', '*.bak', '*~'))\n        cmd = ('''find . -printf \"%%T@ %%p\\\\n\" '''\n               '''| egrep -v '%s' '''\n               '''| sort -n '''\n               '''| tail -n %d''') % (excludes, count)\n        op = self.sh(cmd, shell=True)\n        for l in op.split('\\n'):\n            l = l.strip()\n            if not l:\n                continue\n            mtime, fname = l.split(' ', 1)\n            mtime = datetime.datetime.fromtimestamp(float(mtime))\n            mtimestr = dtformat(mtime)\n            yield mtimestr, fname"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sh(self, cmd, ignore_error=False, cwd=None, shell=False, **kwargs):\n        kwargs.update({\n            'shell': shell,\n            'cwd': cwd or self.fpath,\n            'stderr': subprocess.STDOUT,\n            'stdout': subprocess.PIPE,\n            'ignore_error': ignore_error})\n        log.debug((('cmd', cmd), ('kwargs', kwargs)))\n        return sh(cmd, **kwargs)", "response": "Wrapper for subprocess. Popen."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef current_id(self):\n        cmd = ['hg', '-q', 'id', '-i']\n        return self.sh(cmd, shell=False).rstrip().rstrip('+')", "response": "Returns the current revision identifier for the working directory\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef log(self, n=None, **kwargs):\n        cmd = ['hg', 'log']\n        if n:\n            cmd.extend('-l%d' % n)\n        cmd.extend(\n            (('--%s=%s' % (k, v)) for (k, v)\n                in iteritems(kwargs))\n        )\n        return self.sh(cmd, shell=False)", "response": "Run the repository log command"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets mercurial schemes and convert them to regexes", "response": "def _get_url_scheme_regexes():\n        \"\"\"\n        Get configured mercurial schemes and convert them to regexes\n\n        Returns:\n            tuple: (scheme_name, scheme_value, compiled scheme_regex)\n        \"\"\"\n        output = sh(\"hg showconfig | grep '^schemes.'\", shell=True).split('\\n')\n        log.debug(output)\n        schemes = (\n            l.split('.', 1)[1].split('=') for l in output if '=' in l)\n        regexes = sorted(\n            ((k, v, re.compile(v.replace('{1}', '(.*)')+'(.*)'))\n                for k, v in schemes),\n            key=lambda x: (len(x[0]), x),\n            reverse=True)\n        return regexes"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_hg_scheme_url(cls, url):\n        regexes = cls._get_url_scheme_regexes()\n        for scheme_key, pattern, regex in regexes:\n            match = regex.match(url)\n            if match is not None:\n                groups = match.groups()\n                if len(groups) == 2:\n                    return u''.join(\n                        scheme_key,\n                        '://',\n                        pattern.replace('{1}', groups[0]),\n                        groups[1])\n                elif len(groups) == 1:\n                    return u''.join(\n                        scheme_key,\n                        '://',\n                        pattern,\n                        groups[0])", "response": "Convert a URL to a local mercurial URL."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a URL from local mercurial URL schemes to normal URLS example", "response": "def to_normal_url(cls, url):\n        \"\"\"\n        convert a URL from local mercurial URL schemes to \"normal\" URLS\n\n        example::\n\n            # schemes.gh = git://github.com/\n            # remote_url = \"gh://westurner/dotfiles\"\n            >> to_normal_url(remote_url)\n            << 'git://github.com/westurner/dotfiles'\n\n        \"\"\"\n        regexes = cls._get_url_scheme_regexes()\n        _url = url[:]\n        for scheme_key, pattern, regex in regexes:\n            if _url.startswith(scheme_key):\n                if '{1}' in pattern:\n                    _url = pattern.replace('{1}', _url.lstrip(scheme_key))\n                else:\n                    _url = (pattern + _url.lstrip(scheme_key).lstrip('://'))\n        return _url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetermine the primary remote url for this Repository", "response": "def remote_url(self, remotename='origin'):\n        \"\"\"\n        Determine the primary remote url for this Repository\n\n        Returns:\n            str: primary remote url for this Repository\n                (``git config remote.origin.url``)\n        \"\"\"\n        cmd = ['git', 'config', 'remote.%s.url' % remotename]\n        return self.sh(cmd, shell=False,\n                       ignore_error=True).strip()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget all configured remote urls for this Repository", "response": "def remote_urls(self):\n        \"\"\"\n        Get all configured remote urls for this Repository\n\n        Returns:\n            str: primary remote url for this Repository\n                (``git config -l | grep \"url\"``)\n        \"\"\"\n        cmd = 'git config -l | grep \"url\"'\n        return self.sh(cmd,\n                       shell=True,\n                       ignore_error=True).strip()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the current revision identifier for the working directory", "response": "def current_id(self):\n        \"\"\"\n        Determine the current revision identifier for the working directory\n        of this Repository\n\n        Returns:\n            str: git HEAD revision identifier\n                (``git rev-parse --short HEAD``)\n        \"\"\"\n        try:\n            cmd = ['git', 'rev-parse', '--short', 'HEAD']\n            return self.sh(cmd,\n                        shell=False,\n                        ignore_error=True).rstrip()\n        except subprocess.CalledProcessError as e:\n            log.exception(e)\n            #if e.returncode == 128  # bare repo\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef branch(self):\n        # return self.sh(['git, 'branch'], shell=False)  # parse for '*'\n        cmd = ['git', 'symbolic-ref', '--short', 'HEAD']\n        try:\n            output = self.sh(cmd, shell=False, ignore_error=True).rstrip()\n        except subprocess.CalledProcessError as e:\n            log.exception(e)\n            return  \"#err# %s\" % output\n            #if e.returncode == 128  # bare repo\n        if output.startswith('fatal: ref HEAD is not a symbolic ref'):\n            output = '# %s' % output\n        return output", "response": "Determine the branch name of the working directory of this Repository\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef log(self, n=None, **kwargs):\n        kwargs['format'] = kwargs.pop('template', self.template)\n        cmd = ['git', 'log']\n        if n:\n            cmd.append('-n%d' % n)\n        cmd.extend(\n            (('--%s=%s' % (k, v))\n             for (k, v) in iteritems(kwargs)))\n        try:\n            output = self.sh(cmd, shell=False)\n            if \"fatal: bad default revision 'HEAD'\" in output:\n                return output\n            return output\n        except Exception as e:\n            e\n            return", "response": "Run the repository log command"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cfg_file(self):\n        default_path = os.path.join(self.relpath, '.git', 'config')\n        if os.path.exists(default_path):\n            return default_path\n\n        dotgitpath = os.path.join(self.relpath, '.git')\n        cfg_path = None\n        # with git submodules, .git is a file containing \"gitdir: .../../path\"\n        if os.path.isfile(dotgitpath):\n            with codecs.open(dotgitpath, 'r', encoding='utf8') as f:\n                for _line in f:\n                    l = _line.strip()\n                    if l.startswith('gitdir:'):\n                        # gitdir: ../.git/modules/modname\n                        cfg_path_relative = l.split('gitdir:', 1)[-1].strip()\n                        cfg_path_absolute = os.path.abspath(\n                            os.path.join(\n                                os.path.dirname(dotgitpath),\n                                cfg_path_relative,\n                                'config'))\n                        cfg_path = cfg_path_absolute\n                        log.debug(('cfg_path_absolute', cfg_path_absolute))\n                        #raise Exception(cfg_path_absolute) #_absolute)\n                        break\n        return cfg_path", "response": "Return the configuration file for the given repo path"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef log(self, n=None, template=None):\n        cmd = ['bzr', 'log']\n        if n:\n            cmd.append('-l%d' % n)\n        return self.sh(cmd, shell=False)", "response": "Run the repository log command"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _logmessage_transform(cls, s, by=2):\n        if len(s) >= by:\n            return s[by:].strip('\\n')\n        return s.strip('\\n')", "response": "Preprocess a bzr log message before parsing\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a Bazaar log file format and return a generator of tuples.", "response": "def _parselog(self, r):\n        \"\"\"\n        Parse bazaar log file format\n\n        Args:\n            r (str): bzr revision identifier\n\n        Yields:\n            dict: dict of (attr, value) pairs\n\n        ::\n\n            $ bzr log -l1\n            ------------------------------------------------------------\n            revno: 1\n            committer: ubuntu <ubuntu@ubuntu-desktop>\n            branch nick: ubuntu-desktop /etc repository\n            timestamp: Wed 2011-10-12 01:16:55 -0500\n            message:\n              Initial commit\n\n        \"\"\"\n        def __parselog(entry):\n            \"\"\"\n            Parse bazaar log file format\n\n            Args:\n                entry (str): log message string\n\n            Yields:\n                tuple: (attrname, value)\n            \"\"\"\n            bufname = None\n            buf = deque()\n            print(entry)\n            if entry == ['']:\n                return\n            for l in itersplit(entry, '\\n'):\n                if not l:\n                    continue\n                mobj = self.logrgx.match(l)\n                if not mobj:\n                    # \"  - Log message\"\n                    buf.append(self._logmessage_transform(l))\n                if mobj:\n                    mobjlen = len(mobj.groups())\n                    if mobjlen == 2:\n                        # \"attr: value\"\n                        attr, value = mobj.groups()\n                        if attr == 'message':\n                            bufname = 'desc'\n                        else:\n                            attr = self.field_trans.get(attr, attr)\n                            yield (self.field_trans.get(attr, attr), value)\n                    else:\n                        raise Exception()\n            if bufname is not None:\n                if len(buf):\n                    buf.pop()\n                    len(buf) > 1 and buf.popleft()\n                yield (bufname, '\\n'.join(buf))\n            return\n\n        kwargs = dict(__parselog(r))  # FIXME\n        if kwargs:\n            if 'tags' not in kwargs:\n                kwargs['tags'] = tuple()\n            else:\n                kwargs['tags'].split(' ')  # TODO\n            if 'branchnick' not in kwargs:\n                kwargs['branchnick'] = None\n            try:\n                yield kwargs  # TODO\n                # return self._tuple(**kwargs)\n            except:\n                log.error(r)\n                log.error(kwargs)\n                raise\n        else:\n            log.error(\"failed to parse: %r\" % r)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unique_id(self):\n        cmd = 'svn info | grep \"^Repository UUID\"'\n        cmdo = self.sh(cmd,\n                       shell=True,\n                       ignore_error=True)\n        if cmdo:\n            return cmdo.split(': ', 1)[1].rstrip()\n        return None", "response": "Determine a unique id for this repository"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remote_url(self):\n        cmd = 'svn info | grep \"^Repository Root:\"'\n        return (\n            self.sh(cmd, shell=True).split(': ', 1)[1]).strip()", "response": "Determine the primary remote url for this Repository\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns the repository log command", "response": "def log(self, n=None, template=None, **kwargs):\n        \"\"\"\n        Run the repository log command\n\n        Returns:\n            str: output of log command (``svn log -l <n> <--kwarg=value>``)\n        \"\"\"\n        cmd = ['svn', 'log']\n        if n:\n            cmd.append('-l%d' % n)\n        cmd.extend(\n            (('--%s=%s' % (k, v)) for (k, v) in kwargs.items())\n        )\n        return self.sh(cmd, shell=False)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _last_commit(self):\n        cmd = ['svn', 'log' '-l1']\n        op = self.sh(cmd, shell=False)\n        data, rest = op.split('\\n', 2)[1:]\n        revno, user, datestr, lc = data.split(' | ', 3)\n        desc = '\\n'.join(rest.split('\\n')[1:-2])\n        revno = revno[1:]\n        # lc = long(lc.rstrip(' line'))\n        return datestr, (revno, user, None,  desc)", "response": "Retrieve the most recent commit message."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves the most recent commit message", "response": "def __last_commit(self):\n        \"\"\"\n        Retrieve the most recent commit message (with ``svn info``)\n\n        Returns:\n            tuple: (datestr, (revno, user, None, desc))\n\n        $ svn info\n        Path: .\n        URL: http://python-dlp.googlecode.com/svn/trunk/layercake-python\n        Repository Root: http://python-dlp.googlecode.com/svn\n        Repository UUID: d0ad5f6e-b329-0410-b51c-492c9c4f233d\n        Revision: 378\n        Node Kind: directory\n        Schedule: normal\n        Last Changed Author: chimezie\n        Last Changed Rev: 378\n        Last Changed Date: 2011-05-01 01:31:38 -0500 (Sun, 01 May 2011)\n        \"\"\"\n        cmd = ['svn', 'info']\n        op = self.sh(cmd, shell=False)\n        if not op:\n            return None\n        author, rev, datestr = op.split('\\n')[7:10]\n        author = author.split(': ', 1)[1].strip()\n        rev = rev.split(': ', 1)[1].strip()\n        datestr = datestr.split(': ', 1)[1].split('(', 1)[0].strip()\n        return datestr, (rev, author, None, None)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntraverse filesystem upwards and return a dict of unique ID to the file path that matches the given path.", "response": "def search_upwards(self, fpath=None, repodirname='.svn', upwards={}):\n        \"\"\"\n        Traverse filesystem upwards, searching for .svn directories\n        with matching UUIDs (Recursive)\n\n        Args:\n            fpath (str): file path to search upwards from\n            repodirname (str): directory name to search for (``.svn``)\n            upwards (dict): dict of already-searched directories\n\n        example::\n\n            repo/.svn\n            repo/dir1/.svn\n            repo/dir1/dir2/.svn\n\n            >> search_upwards('repo/')\n            << 'repo/'\n            >> search_upwards('repo/dir1')\n            << 'repo/'\n            >> search_upwards('repo/dir1/dir2')\n            << 'repo/'\n\n            repo/.svn\n            repo/dirA/\n            repo/dirA/dirB/.svn\n\n            >> search_upwards('repo/dirA')\n            << 'repo/'\n            >> search_upwards('repo/dirA/dirB')\n            >> 'repo/dirB')\n\n        \"\"\"\n        fpath = fpath or self.fpath\n        uuid = self.unique_id\n        last_path = self\n\n        path_comp = fpath.split(os.path.sep)\n        # [0:-1], [0:-2], [0:-1*len(path_comp)]\n        for n in xrange(1, len(path_comp)-1):\n            checkpath = os.path.join(*path_comp[0:-1 * n])\n            repodir = os.path.join(checkpath, repodirname)\n            upw_uuid = upwards.get(repodir)\n            if upw_uuid:\n                if upw_uuid == uuid:\n                    last_path = SvnRepository(checkpath)\n                    continue\n                else:\n                    break\n            elif os.path.exists(repodir):\n                repo = SvnRepository(checkpath)\n                upw_uuid = repo.unique_id\n                upwards[repodir] = upw_uuid\n                # TODO: match on REVISION too\n                if upw_uuid == uuid:\n                    last_path = repo\n                    continue\n                else:\n                    break\n\n        return last_path"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef split_obj (obj, prefix = None):\n    '''\n    Split the object, returning a 3-tuple with the flat object, optionally\n    followed by the key for the subobjects and a list of those subobjects.\n    '''\n    # copy the object, optionally add the prefix before each key\n\n    new = obj.copy() if prefix is None else { '{}_{}'.format(prefix, k): v for k, v in obj.items() }\n\n    # try to find the key holding the subobject or a list of subobjects\n    for k, v in new.items():\n        # list of subobjects\n        if isinstance(v, list):\n            # this is a list of strings or ints, which is a one-to-many\n            # can't deal with that here, but leave the data in case it's \n            # useful downstream\n            if not isinstance(v[0], dict):\n                new[k] = ','.join(v)\n                return new, None, None\n            del new[k]\n            return new, k, v\n        # or just one subobject\n        elif isinstance(v, dict):\n            del new[k]\n            return new, k, [v]\n    return new, None, None", "response": "Split the object returning a 3 - tuple with the flat object followed by the key for the subobjects and a list of those subobjects."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nflattens the data optionally with each key prefixed.", "response": "def flatten_json(data, prefix = None):\n    '''\n    Flatten the data, optionally with each key prefixed.\n    '''\n    # iterate all items\n    for item in data:\n        # split the object\n        flat, key, subs = split_obj(item, prefix)\n\n        # just return fully flat objects\n        if key is None:\n            yield flat\n            continue\n\n        # otherwise recursively flatten the subobjects\n        for sub in flatten_json(subs, key):\n            sub.update(flat)\n            yield sub"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_filename(filename):\n\n    _patterns = patterns.get_expressions()\n    result = {}\n\n    for cmatcher in _patterns:\n        match = cmatcher.match(filename)\n        if match:\n            namedgroups = match.groupdict().keys()\n\n            result['pattern'] = cmatcher.pattern\n            result['series_name'] = match.group('seriesname')\n            result['season_number'] = _get_season_no(match, namedgroups)\n            result['episode_numbers'] = _get_episodes(match, namedgroups)\n            break\n    else:\n        result = None\n\n    return result", "response": "Parse the media filename for metadata."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nimports module by path string like netshowlib. linux. provider_discovery", "response": "def import_module(mod_str):\n    \"\"\"\n    inspired by post on stackoverflow\n    :param name: import path string like 'netshowlib.linux.provider_discovery'\n    :return: module matching the import statement\n\n    \"\"\"\n\n    _module = __import__(mod_str)\n    _mod_parts = mod_str.split('.')\n    for _mod_part in _mod_parts[1:]:\n        _module = getattr(_module, _mod_part)\n    return _module"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the OS appropriate Cache module", "response": "def feature_cache():\n    \"\"\"\n    Performs OS discovery and returns the OS appropriate Cache() module\n    \"\"\"\n    providername = provider_check()\n    if providername:\n        cache_path = \"netshowlib.%s.cache\" % providername\n        cache_module = import_module(cache_path)\n        return cache_module.Cache()\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning Iface object that best matches interface characteristics", "response": "def iface(name, providername=None, cache=None):\n    \"\"\"\n    | **Interface Discovery **\n    calls into ``netshowlib.[provider].iface.iface()`` to get the correct\n    interface type\n\n    :return:  Iface object that best matches interface characteristics\n    \"\"\"\n    _providername = providername\n    if not _providername:\n        _providername = provider_check()\n\n    import_str = 'netshowlib.%s.iface' % _providername\n    return import_module(import_str).iface(name, cache=cache)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef system_summary(providername=None):\n    _providername = providername\n    if not _providername:\n        _providername = provider_check()\n\n    import_str = 'netshowlib.%s.system_summary' % _providername\n    return import_module(import_str).SystemSummary()", "response": "returns SystemSummary class from mentioned provider\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef portname_list(providername=None):\n    _providername = providername\n    if not _providername:\n        _providername = provider_check()\n\n    import_str = 'netshowlib.%s.iface' % _providername\n    return import_module(import_str).portname_list()", "response": "Returns list of ports found by the provider"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef put(self, item):\n        uid = str(uuid.uuid4())\n\n        if self.serializer is not None:\n            item = self.serializer.dumps(item)\n\n        self._redis.pipeline()\\\n                .hset(self.ITEMS_KEY, uid, item)\\\n                .lpush(self.QUEUE_KEY, uid)\\\n                .execute()\n        return uid", "response": "Adds an item to the queue and returns the uid"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets next item from queue.", "response": "def get(self, timeout=0):\n        \"\"\"Return next item from queue. Blocking by default.\n\n        Blocks if queue is empty, see `timeout` parameter.\n\n        Internally this also pops uid from queue and writes it to\n        ackbuffer.\n\n        :param timeout: blocking timeout in seconds\n                        - 0: block forever (default)\n                        - negative: disable blocking\n\n        \"\"\"\n        self._autoclean()\n        if timeout < 0:\n            uid = self._redis.rpoplpush(self.QUEUE_KEY, self.ACKBUF_KEY)\n        else:\n            uid = self._redis.brpoplpush(self.QUEUE_KEY, self.ACKBUF_KEY, timeout)\n        item = self._redis.hget(self.ITEMS_KEY, uid)\n\n        # Deserialize only if the item exists: it is equal to None if it times out\n        if self.serializer is not None and item is not None:\n            item = self.serializer.loads(item)\n\n        return uid, item"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nacknowledges the item with the given uid.", "response": "def ack(self, uid):\n        \"\"\"Acknowledge item as successfully consumed.\n\n        Removes uid from ackbuffer and deletes the corresponding item.\n        \"\"\"\n        self._redis.pipeline()\\\n                   .lrem(self.ACKBUF_KEY, 0, uid)\\\n                   .lrem(self.BACKUP, 0, uid)\\\n                   .hdel(self.ITEMS_KEY, uid)\\\n                   .execute()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreporting item as not successfully consumed.", "response": "def fail(self, uid):\n        \"\"\"Report item as not successfully consumed.\n\n        Removes uid from ackbuffer and re-enqueues it.\n        \"\"\"\n        self._redis.pipeline()\\\n                   .lrem(self.ACKBUF_KEY, 0, uid)\\\n                   .lrem(self.BACKUP, 0, uid)\\\n                   .lpush(self.QUEUE_KEY, uid)\\\n                   .execute()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nestimating the reaction time and duration of the saccade by fitting a saccade model to the data. The model consists of three phases: 1) source phase, gaze is fixated onto a point 2) saccade phase, gaze moves steadily from the source point onto the target point 3) target phase, gaze becomes fixated onto a point. The estimation is done in Expectation-Maximation manner: 1) Initial locations are given for the source and target points. 2) Expectation: given the source and target points, saccade start and end times are calculated and the gazepoints are divided into three classes: source, saccade, and target gazepoints. In EM terminology, the classes are the latent variables. 3) Maximization: the means of the new source and target gazepoints become the new values of the source and target points. 4) Repeat steps 2) and 3) until the source and target points stay the same. Input arguments pointlist, list of [x, y] points. 'None' values are not allowed. Output arguments source_points saccade_points target_points mean_squared_error Here we use two different concepts, times and indices: Time t 0 1 2 3 4 5 | | | | | | Vector [ 2 3 1 2 1 ] | | | | | Index i 0 1 2 3 4", "response": "def saccade_model_em(pointlist):\n    '''\n    Estimates the reaction time and duration of the saccade by\n    fitting a saccade model to the data.\n\n    The model consists of three phases:\n      1) source phase, gaze is fixated onto a point\n      2) saccade phase, gaze moves steadily from the source point\n         onto the target point\n      3) target phase, gaze becomes fixated onto a point.\n\n    The estimation is done in Expectation-Maximation manner:\n      1) Initial locations are given for the source and target points.\n      2) Expectation: given the source and target points, saccade start\n         and end times are calculated and the gazepoints are divided\n         into three classes: source, saccade, and target gazepoints.\n         In EM terminology, the classes are the latent variables.\n      3) Maximization: the means of the new source and target gazepoints\n         become the new values of the source and target points.\n      4) Repeat steps 2) and 3) until the source and target points stay\n         the same.\n\n    Input arguments\n      pointlist, list of [x, y] points. 'None' values are not allowed.\n\n    Output arguments\n      source_points\n      saccade_points\n      target_points\n      mean_squared_error\n\n    Here we use two different concepts, times and indices:\n      Time t  0 1 2 3 4 5\n              | | | | | |\n      Vector [ 2 3 1 2 1 ]\n               | | | | |\n      Index i  0 1 2 3 4\n    '''\n\n    # Aliases\n    g = pointlist\n\n    # Max\n    max_t = len(g)\n    max_i = max_t - 1\n\n    # Initialize\n    mu_s = g[0]   # First\n    mu_t = g[-1]  # Last\n    t_start = min(max_t, 60) # Average SRT is about 200 ms\n    t_end = min(max_t, 70) # Average SD is about 30 ms\n\n    # To detect nonconvergent situations, memorize the visited t_start and\n    # t_end pairs and their model error.\n    t_history = TimePairValueHistory()\n\n    # Limit iterations in case there is a bug\n    max_iters = 50\n    em_iters = 0\n    for _ in range(max_iters):\n        t_start_hat, t_end_hat, mse, src_sse, sacc_sse, tgt_sse = saccade_model_mle(g, mu_s, mu_t, t_start, t_end)\n\n        if t_end_hat < t_start_hat:\n            raise Exception('t_end_hat < t_start_hat: ' + str(t_end_hat) + ',' + str(t_start_hat))\n\n        # Determine new centroids.\n        # Limit times so that there is at least one gazepoint.\n        t_start_c = min(max(t_start_hat, 1), max_t - 1)\n        t_end_c   = min(max(t_end_hat  , 1), max_t - 1)\n        # Compute means based on windows of 100 ms before and after saccade\n        g_source = select_points_time_to_time(g, 0, t_start_c)\n        g_target = select_points_time_to_time(g, t_end_c, max_t)\n        g_source30 = select_last_points(g_source, 30)\n        g_target30 = select_first_points(g_target, 30)\n        mu_s_hat = mean_point(g_source30)\n        mu_t_hat = mean_point(g_target30)\n\n        mu_s = mu_s_hat\n        mu_t = mu_t_hat\n        t_start = t_start_hat\n        t_end = t_end_hat\n\n        # Compute until we have arrived to same state again.\n        if not t_history.is_visited(t_start_hat, t_end_hat):\n            t_history.visit(t_start, t_end, mse, {\n                'src_sse': src_sse,\n                'sacc_sse': sacc_sse,\n                'tgt_sse': tgt_sse,\n            })\n            # The next round either is minimal again or goes here.\n            em_iters += 1\n\n            #print('t_start: ' + str(t_start))\n            #print('t_end: ' + str(t_end))\n            #print('mse: ' + str(mse))\n        else:\n            # Select the parameters that gave minimum error\n            t_start, t_end, mse, d = t_history.get_minimum()\n            src_sse = d['src_sse']\n            sacc_sse = d['sacc_sse']\n            tgt_sse = d['tgt_sse']\n            break\n\n    if em_iters == max_iters:\n        did_converge = False\n    else:\n        did_converge = True\n\n    source_points = select_points_time_to_time(g, 0, t_start)\n    saccade_points = select_points_time_to_time(g, t_start, t_end)\n    target_points = select_points_time_to_time(g, t_end, None)\n    mean_squared_error = mse\n\n    return source_points, saccade_points, target_points, mean_squared_error"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the absolute paths to template_name when appended to each directory in template_dirs.", "response": "def get_template_sources(self, template_name, template_dirs=None):\n        \"\"\"\n        Returns the absolute paths to \"template_name\", when appended to each\n        directory in \"template_dirs\". Any paths that don't lie inside one of the\n        template dirs are excluded from the result set, for security reasons.\n        \"\"\"\n        if not template_dirs:\n            template_dirs = self.get_dirs()\n        for template_dir in template_dirs:\n            try:\n                name = safe_join(template_dir, template_name)\n            except SuspiciousFileOperation:\n                # The joined path was located outside of this template_dir\n                # (it might be inside another one, so this isn't fatal).\n                pass\n            else:\n                if Origin:\n                    yield Origin(\n                        name=name,\n                        template_name=template_name,\n                        loader=self,\n                    )\n                else:\n                    yield name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decorator(cls, func_or_class):\n        resources = getattr(func_or_class, 'resources', [])\n        resources.append(cls)\n        func_or_class.resources = resources\n        return func_or_class", "response": "A decorator method that adds this class to a list on the \n        decorated object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_table(dbcon, name, columns):\n    try:\n        colString = \", \".join([\"{} {}\".format(colName, colType) for colName, colType in columns])\n        dbcon.execute(\"CREATE TABLE '{name}'({args})\".format(name=name, args=colString))\n        return True\n    except sqlite3.OperationalError as e:\n        return False", "response": "Create a table in the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninserting a row into a table in the database", "response": "def insert_row(dbconn, tablename, *args):\n    \"\"\"\n    Insert a row into a table\n    :param dbconn: data base connection\n    :param table_name: name of the table\n    :param args: table columns\n    \"\"\"\n    cur = dbconn.cursor()\n    cur.execute(\"INSERT INTO '{name}' VALUES{args}\".format(name=tablename, args=args))\n    dbconn.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete a row from a table in a database.", "response": "def delete_row(dbconn, table_name, field, value):\n    \"\"\"\n    Delete a row from a table in a database.\n    :param dbconn: data base connection\n    :param table_name: name of the table\n    :param field: field of the table to target\n    :param value: value of the field in the table to delete\n    \"\"\"\n    cur = dbconn.cursor()\n    cur.execute(\"DELETE FROM '{name}' WHERE {field}='{value}'\".format(name=table_name, field=field, value=value))\n    dbconn.commit()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear_table(dbconn, table_name):\n    cur = dbconn.cursor()\n    cur.execute(\"DELETE FROM '{name}'\".format(name=table_name))\n    dbconn.commit()", "response": "Delete all rows from a table"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a list of tables that exist in dbconn", "response": "def get_table_list(dbconn):\n    \"\"\"\n    Get a list of tables that exist in dbconn\n    :param dbconn: database connection\n    :return: List of table names\n    \"\"\"\n    cur = dbconn.cursor()\n    cur.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n    try:\n        return [item[0] for item in cur.fetchall()]\n    except IndexError:\n        return get_table_list(dbconn)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a list of tables that exist in dbconn", "response": "def get_uuid_list(dbconn):\n    \"\"\"\n    Get a list of tables that exist in dbconn\n    :param dbconn: master database connection\n    :return: List of uuids in the database\n    \"\"\"\n    cur = dbconn.cursor()\n    tables = get_table_list(dbconn)\n    uuids = set()\n    for table in tables:\n        cur.execute(\"SELECT (UUID) FROM '{table}'\".format(table=table))\n        uuid = set([i[0] for i in cur.fetchall()])\n        if uuid:\n            uuids.update(uuid)\n    return uuids"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_table_columns(dbconn, tablename):\n    cur = dbconn.cursor()\n    cur.execute(\"PRAGMA table_info('%s');\" % tablename)\n    info = cur.fetchall()\n    cols = [(i[1], i[2]) for i in info]\n    return cols", "response": "Return a list of tuples specifying the column name and type of the table."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the number of rows in a table", "response": "def get_number_of_rows(dbcon, tablename, uuid=None):\n    \"\"\"\n    Return the number of rows in a table\n    :param dbcon: database connection\n    :param tablename: table name\n    :return: Boolean\n    \"\"\"\n    dbcur = dbcon.cursor()\n    if check_table_exists(dbcon, tablename):\n        if uuid:\n            dbcur.execute(\"SELECT COUNT(*) FROM '{name}' WHERE UUID='{uuid}'\".format(name=tablename, uuid=uuid))\n        else:\n            dbcur.execute(\"SELECT COUNT(*) FROM '{name}'\".format(name=tablename))\n        try:\n            result = dbcur.fetchone()[0]\n        except (TypeError, IndexError) as e:\n            logger.error(e)\n            result = 0\n        dbcur.close()\n        return result if isinstance(result, (int, long, float)) else 0\n    else:\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_table_exists(dbcon, tablename):\n    dbcur = dbcon.cursor()\n    dbcur.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='%s';\" % tablename)\n    result = dbcur.fetchone()\n    dbcur.close()\n    if result is None:\n        return False\n    else:\n        try:\n            return result[0] == tablename\n        except IndexError as e:\n            return check_table_exists(dbcon, tablename)", "response": "Check if a table exists in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns all the rows in a table from dbconn", "response": "def get_rows(dbconn, tablename, uuid=None):\n    \"\"\"\n    Return all the rows in a table from dbconn\n    :param dbconn: database connection\n    :param tablename: name of the table\n    :return: List of sqlite3.Row objects\n    \"\"\"\n    cursor = dbconn.cursor()\n    if uuid:\n        cursor.execute(\"SELECT * FROM  {tablename} WHERE UUID='{uuid}'\".format(tablename=tablename, uuid=uuid))\n    else:\n        cursor.execute(\"SELECT * FROM %s\" % tablename)\n    rows = cursor.fetchall()\n    return rows"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch(dbconn, tablename, n=1, uuid=None, end=True):\n    cur = dbconn.cursor()\n    order = 'DESC' if end else 'ASC'\n    try:\n        if uuid:\n            cur.execute(\"SELECT * FROM '{}' WHERE UUID='{}' ORDER BY ROWID {} LIMIT {};\".format(tablename, uuid, order, n))\n        else:\n            cur.execute(\"SELECT * FROM '{}' ORDER BY ROWID {} LIMIT {};\".format(tablename, order, n))\n    except sqlite3.OperationalError as e:\n        if 'no such table' not in getattr(e, 'message', ''):\n            # Suppress logging of errors generated when no table exists\n            logger.error(e)\n        return []\n    rows = cur.fetchall()\n    return rows", "response": "Returns n rows from the table s start or end order"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_last_row(dbconn, tablename, n=1, uuid=None):\n    return fetch(dbconn, tablename, n, uuid, end=True)", "response": "Returns the last n rows in the table."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_first_row(dbconn, tablename, n=1, uuid=None):\n    return fetch(dbconn, tablename, n, uuid, end=False)", "response": "Returns the first n rows in the table."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef merge_databases(master, part):\n    mcur = master.cursor()\n    pcur = part.cursor()\n\n    logger.debug(\"Merging databases...\")\n    tables = get_table_list(part)\n    for table in tables:\n        cols = get_table_columns(part, table)\n        pcur.execute(\"SELECT * FROM '%s'\" % table)\n        rows = pcur.fetchall()\n        if rows:\n            try:\n                logger.debug(\"Found   {n} rows of table '{name}' in master\".format(name=table, n=rows[0][1]-1))\n            except Exception as e:\n                logging.error(e)\n            if not check_table_exists(master, table):\n                create_table(master, table, cols)\n\n            args = (\"?,\" * len(cols))[:-1]\n            query = \"INSERT INTO '{name}' VALUES ({args})\".format(name=table, args=args)\n            mcur.executemany(query, tuple(tuple(r) for r in rows))\n            logger.debug(\"Merging {m} rows of table '{name}' into master\".format(name=table, m=len(rows)))\n\n    master.commit()", "response": "Merge the partial database into the master database."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_datetime_sorted_rows(dbconn, table_name, uuid=None, column=None):\n    rows = get_rows(dbconn, table_name, uuid=uuid)\n    data = []\n    for r in rows:\n        dt = datetime.datetime.strptime(r['Time'], \"%d/%m/%Y %H:%M:%S\")\n        if column is None:\n            data.append((dt, r))\n        else:\n            data.append((dt, r[column]))\n    data.sort()\n\n    return data", "response": "Get a list of datetime sorted rows from a table in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rename_table(dbconn, original, new):\n    cur = dbconn.cursor()\n    cur.execute(\"ALTER TABLE '{original}' RENAME TO '{new}'\".format(original=original, new=new))", "response": "Rename a table in the database"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlogs-in to HQ server.", "response": "def login_hq(host, user, passwd, path='', acct='', port=21, timeout=5):\n    \"\"\"\n    Create and return a logged in FTP object.\n    :return:\n    \"\"\"\n    ftp = ftplib.FTP()\n    ftp.connect(host=host, port=port, timeout=timeout)\n    ftp.login(user=user, passwd=passwd, acct=acct)\n    ftp.cwd(path)\n    logger.debug('Login to %s successful.' % host)\n    return ftp"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ftp_download(ftp, ftp_path, local_path):\n    with open(local_path, 'wb') as _f:\n        ftp.retrbinary('RETR %s' % ftp_path, _f.write)", "response": "Download the master database and file on the ftp server"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hover_pixmap(self, value):\n\n        if value is not None:\n            assert type(value) is QPixmap, \"'{0}' attribute: '{1}' type is not 'QPixmap'!\".format(\n                \"hover_pixmap\", value)\n        self.__hover_pixmap = value", "response": "Sets the value of the HoverPixmap attribute."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the active_pixmap attribute.", "response": "def active_pixmap(self, value):\n        \"\"\"\n        Setter for **self.__active_pixmap** attribute.\n\n        :param value: Attribute value.\n        :type value: QPixmap\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is QPixmap, \"'{0}' attribute: '{1}' type is not 'QPixmap'!\".format(\n                \"active_pixmap\", value)\n        self.__active_pixmap = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef checkable(self, value):\n\n        if value is not None:\n            assert type(value) is bool, \"'{0}' attribute: '{1}' type is not 'bool'!\".format(\"checkable\", value)\n        self.__checkable = value", "response": "Sets the checkable attribute."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the value of the checked attribute.", "response": "def checked(self, value):\n        \"\"\"\n        Setter for **self.__checked** attribute.\n\n        :param value: Attribute value.\n        :type value: bool\n        \"\"\"\n\n        if value is not None:\n            assert type(value) is bool, \"'{0}' attribute: '{1}' type is not 'bool'!\".format(\"checked\", value)\n        self.set_checked(value)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_checked(self, state):\n\n        if not self.__checkable:\n            return False\n\n        if state:\n            self.__checked = True\n            self.setPixmap(self.__active_pixmap)\n        else:\n            self.__checked = False\n            self.setPixmap(self.__default_pixmap)\n        self.toggled.emit(state)\n        return True", "response": "Sets the Widget checked state."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the Widget menu.", "response": "def set_menu(self, menu):\n        \"\"\"\n        Sets the Widget menu.\n\n        :param menu: Menu.\n        :type menu: QMenu\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        self.__menu = menu\n\n        if not self.parent():\n            return False\n\n        parent = [parent for parent in umbra.ui.common.parents_walker(self)].pop()\n        for action in self.__menu.actions():\n            not action.shortcut().isEmpty() and parent.addAction(action)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate(anchors, duplicate_tags, opts):\n    try:\n        return _validate(anchors, duplicate_tags, opts)\n    except ValidationException as e:\n        if str(e) == \"Duplicate tags found\":\n            messages.print_duplicate_anchor_information(duplicate_tags)\n        else:\n            print(e)\n        sys.exit(0)", "response": "This function is a wrapper for _validate that checks if the anchors and duplicate_tags pass all validations."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, path, default=None):\n\n        try:\n            return self.__getitem__(path)\n        except KeyError as error:\n            return default", "response": "Returns given path value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __watch_file_system(self):\n\n        for path, data in self.__paths.items():\n            stored_modified_time, is_file = data\n            try:\n                if not foundations.common.path_exists(path):\n                    LOGGER.warning(\n                        \"!> {0} | '{1}' path has been invalidated and will be unregistered!\".format(\n                            self.__class__.__name__, path))\n                    del (self.__paths[path])\n                    if is_file:\n                        self.file_invalidated.emit(path)\n                    else:\n                        self.directory_invalidated.emit(path)\n                    continue\n            except KeyError:\n                LOGGER.debug(\"> {0} | '{1}' path has been unregistered while iterating!\".format(\n                    self.__class__.__name__, path))\n                continue\n\n            try:\n                modified_time = self.get_path_modified_time(path)\n            except OSError:\n                LOGGER.debug(\"> {0} | '{1}' path has been invalidated while iterating!\".format(\n                    self.__class__.__name__, path))\n                continue\n\n            if stored_modified_time != modified_time:\n                self.__paths[path] = (modified_time, os.path.isfile(path))\n                LOGGER.debug(\"> {0} | '{1}' path has been changed!\".format(self.__class__.__name__, path))\n                if is_file:\n                    self.file_changed.emit(path)\n                else:\n                    self.directory_changed.emit(path)", "response": "Watches the file system for paths that have been changed or invalidated on disk."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering given path. :param path: Path name. :type path: unicode :param modified_time: Custom modified time. :type modified_time: int or float :return: Method success. :rtype: bool", "response": "def register_path(self, path, modified_time=None):\n        \"\"\"\n        Registers given path.\n\n        :param path: Path name.\n        :type path: unicode\n        :param modified_time: Custom modified time.\n        :type modified_time: int or float\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        if not foundations.common.path_exists(path):\n            raise foundations.exceptions.PathExistsError(\"{0} | '{1}' path doesn't exists!\".format(\n                self.__class__.__name__, path))\n\n        if path in self:\n            raise umbra.exceptions.PathRegistrationError(\"{0} | '{1}' path is already registered!\".format(\n                self.__class__.__name__, path))\n\n        self.__paths[path] = (self.get_path_modified_time(\n            path) if modified_time is None else modified_time, os.path.isfile(path))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unregister_path(self, path):\n\n        if not path in self:\n            raise umbra.exceptions.PathExistsError(\"{0} | '{1}' path isn't registered!\".format(\n                self.__class__.__name__, path))\n\n        del (self.__paths[path])\n        return True", "response": "Unregisters given path.\n\n        :param path: Path name.\n        :type path: unicode\n        :return: Method success.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns given path modification time.", "response": "def get_path_modified_time(path):\n        \"\"\"\n        Returns given path modification time.\n\n        :param path: Path.\n        :type path: unicode\n        :return: Modification time.\n        :rtype: int\n        \"\"\"\n\n        return float(foundations.common.get_first_item(str(os.path.getmtime(path)).split(\".\")))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npost login to Janrain.", "response": "def _post_login_page(self):\n        \"\"\"Login to Janrain.\"\"\"\n        # Prepare post data\n        data = {\n            \"form\": \"signInForm\",\n            \"client_id\": JANRAIN_CLIENT_ID,\n            \"redirect_uri\": \"https://www.fido.ca/pages/#/\",\n            \"response_type\": \"token\",\n            \"locale\": \"en-US\",\n            \"userID\": self.username,\n            \"currentPassword\": self.password,\n        }\n        # HTTP request\n        try:\n            raw_res = yield from self._session.post(LOGIN_URL,\n                                                    headers=self._headers,\n                                                    data=data,\n                                                    timeout=self._timeout)\n        except OSError:\n            raise PyFidoError(\"Can not sign in\")\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting token from JanRain.", "response": "def _get_token(self):\n        \"\"\"Get token from JanRain.\"\"\"\n        # HTTP request\n        try:\n            raw_res = yield from self._session.get(TOKEN_URL,\n                                                   headers=self._headers,\n                                                   timeout=self._timeout)\n        except OSError:\n            raise PyFidoError(\"Can not get token\")\n        # Research for json in answer\n        content = yield from raw_res.text()\n        reg_res = re.search(r\"\\({.*}\\)\", content)\n        if reg_res is None:\n            raise PyFidoError(\"Can not finf token json\")\n        # Load data as json\n        return_data = json.loads(reg_res.group()[1:-1])\n        # Get token and uuid\n        token = return_data.get('result', {}).get('accessToken')\n        uuid = return_data.get('result', {}).get('userData', {}).get('uuid')\n        # Check values\n        if token is None or uuid is None:\n            raise PyFidoError(\"Can not get token or uuid\")\n\n        return token, uuid"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_account_number(self, token, uuid):\n        # Data\n        data = {\"accessToken\": token,\n                \"uuid\": uuid}\n        # Http request\n        try:\n            raw_res = yield from self._session.post(ACCOUNT_URL,\n                                                    data=data,\n                                                    headers=self._headers,\n                                                    timeout=self._timeout)\n        except OSError:\n            raise PyFidoError(\"Can not get account number\")\n        # Load answer as json\n        try:\n            json_content = yield from raw_res.json()\n            account_number = json_content\\\n                            .get('getCustomerAccounts', {})\\\n                            .get('accounts', [{}])[0]\\\n                            .get('accountNumber')\n        except (OSError, ValueError):\n            raise PyFidoError(\"Bad json getting account number\")\n        # Check collected data\n        if account_number is None:\n            raise PyFidoError(\"Can not get account number\")\n\n        return account_number", "response": "Get fido account number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget current balance from Fido.", "response": "def _get_balance(self, account_number):\n        \"\"\"Get current balance from Fido.\"\"\"\n        # Prepare data\n        data = {\"ctn\": self.username,\n                \"language\": \"en-US\",\n                \"accountNumber\": account_number}\n        # Http request\n        try:\n            raw_res = yield from self._session.post(BALANCE_URL,\n                                                    data=data,\n                                                    headers=self._headers,\n                                                    timeout=self._timeout)\n        except OSError:\n            raise PyFidoError(\"Can not get balance\")\n        # Get balance\n        try:\n            json_content = yield from raw_res.json()\n            balance_str = json_content\\\n                            .get(\"getAccountInfo\", {})\\\n                            .get(\"balance\")\n        except (OSError, ValueError):\n            raise PyFidoError(\"Can not get balance as json\")\n        if balance_str is None:\n            raise PyFidoError(\"Can not get balance\")\n        # Casting to float\n        try:\n            balance = float(balance_str)\n        except ValueError:\n            raise PyFidoError(\"Can not get balance as float\")\n\n        return balance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_fido_dollar(self, account_number, number):\n        # Prepare data\n        data = json.dumps({\"fidoDollarBalanceFormList\":\n                           [{\"phoneNumber\": number,\n                             \"accountNumber\": account_number}]})\n        # Prepare headers\n        headers_json = self._headers.copy()\n        headers_json[\"Content-Type\"] = \"application/json;charset=UTF-8\"\n        # Http request\n        try:\n            raw_res = yield from self._session.post(FIDO_DOLLAR_URL,\n                                                    data=data,\n                                                    headers=headers_json,\n                                                    timeout=self._timeout)\n        except OSError:\n            raise PyFidoError(\"Can not get fido dollar\")\n        # Get fido dollar\n        try:\n            json_content = yield from raw_res.json()\n            fido_dollar_str = json_content\\\n                        .get(\"fidoDollarBalanceInfoList\", [{}])[0]\\\n                        .get(\"fidoDollarBalance\")\n        except (OSError, ValueError):\n            raise PyFidoError(\"Can not get fido dollar as json\")\n        if fido_dollar_str is None:\n            raise PyFidoError(\"Can not get fido dollar\")\n        # Casting to float\n        try:\n            fido_dollar = float(fido_dollar_str)\n        except ValueError:\n            raise PyFidoError(\"Can not get fido dollar\")\n\n        return fido_dollar", "response": "Get current Fido dollar balance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_usage(self, account_number, number):\n        # Prepare data\n        data = {\"ctn\": number,\n                \"language\": \"en-US\",\n                \"accountNumber\": account_number}\n        # Http request\n        try:\n            raw_res = yield from self._session.post(USAGE_URL,\n                                                    data=data,\n                                                    headers=self._headers,\n                                                    timeout=self._timeout)\n        except OSError:\n            raise PyFidoError(\"Can not get usage\")\n        # Load answer as json\n        try:\n            output = yield from raw_res.json()\n        except (OSError, ValueError):\n            raise PyFidoError(\"Can not get usage as json\")\n        # Format data\n        ret_data = {}\n        for data_name, keys in DATA_MAP.items():\n            key, subkey = keys\n            for data in output.get(key)[0].get('wirelessUsageSummaryInfoList'):\n                if data.get('usageSummaryType') == subkey:\n                    # Prepare keys:\n                    used_key = \"{}_used\".format(data_name)\n                    remaining_key = \"{}_remaining\".format(data_name)\n                    limit_key = \"{}_limit\".format(data_name)\n                    # Get values\n                    ret_data[used_key] = data.get('used', 0.0)\n                    if data.get('remaining') >= 0:\n                        ret_data[remaining_key] = data.get('remaining')\n                    else:\n                        ret_data[remaining_key] = None\n                    if data.get('total') >= 0:\n                        ret_data[limit_key] = data.get('total')\n                    else:\n                        ret_data[limit_key] = None\n\n        return ret_data", "response": "Get Fido usage.\n\n        Get the following data\n        - talk\n        - text\n        - data\n\n        Roaming data is not supported yet"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch_data(self):\n        # Get http session\n        yield from self._get_httpsession()\n        # Post login page\n        yield from self._post_login_page()\n        # Get token\n        token_uuid = yield from self._get_token()\n        # Get account number\n        account_number = yield from self._get_account_number(*token_uuid)\n        # List phone numbers\n        self._phone_numbers = yield from self._list_phone_numbers(account_number)\n        # Get balance\n        balance = yield from self._get_balance(account_number)\n        self._data['balance'] = balance\n        # Get fido dollar\n        for number in self._phone_numbers:\n            fido_dollar = yield from self._get_fido_dollar(account_number,\n                                                           number)\n            self._data[number]= {'fido_dollar': fido_dollar}\n        # Get usage\n        for number in self._phone_numbers:\n            usage = yield from self._get_usage(account_number, number)\n            self._data[number].update(usage)", "response": "Fetch the latest data from Fido."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef execute(\n    command,\n    abort=True,\n    capture=False,\n    verbose=False,\n    echo=False,\n    stream=None,\n):\n    \"\"\"Run a command locally.\n\n    Arguments:\n        command: a command to execute.\n        abort: If True, a non-zero return code will trigger an exception.\n        capture: If True, returns the output of the command.\n            If False, returns a subprocess result.\n        echo: if True, prints the command before executing it.\n        verbose: If True, prints the output of the command.\n        stream: If set, stdout/stderr will be redirected to the given stream.\n            Ignored if `capture` is True.\n    \"\"\"\n    stream = stream or sys.stdout\n\n    if echo:\n        out = stream\n        out.write(u'$ %s' % command)\n\n    # Capture stdout and stderr in the same stream\n    command = u'%s 2>&1' % command\n\n    if verbose:\n        out = stream\n        err = stream\n    else:\n        out = subprocess.PIPE\n        err = subprocess.PIPE\n\n    process = subprocess.Popen(\n        command,\n        shell=True,\n        stdout=out,\n        stderr=err,\n    )\n    # propagate SIGTERM to all child processes within\n    # the process group. this prevents subprocesses from\n    # being orphaned when the current process is terminated\n    signal.signal(\n        signal.SIGTERM,\n        make_terminate_handler(process)\n    )\n\n    # Wait for the process to complete\n    stdout, _ = process.communicate()\n    stdout = stdout.strip() if stdout else ''\n    if not isinstance(stdout, unicode):\n        stdout = stdout.decode('utf-8')\n\n    if abort and process.returncode != 0:\n        message = (\n            u'Error #%d running \"%s\"%s' % (\n                process.returncode,\n                command,\n                ':\\n====================\\n'\n                '%s\\n'\n                '====================\\n' % (\n                    stdout\n                ) if stdout else ''\n            )\n        )\n        raise Exception(message)\n    if capture:\n        return stdout\n    else:\n        return process", "response": "Execute a command locally."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving a MailBase this will construct a MIME message that is canonicalized for the Python email API.", "response": "def to_message(base):\n    \"\"\"\n    Given a MailBase, this will construct a MIME part that is canonicalized for\n    use with the Python email API.\n    \"\"\"\n    ctype, ctparams = base.get_content_type()\n\n    if not ctype:\n        if base.parts:\n            ctype = 'multipart/mixed'\n        else:\n            ctype = 'text/plain'\n\n    maintype, subtype = ctype.split('/')\n    is_text = maintype == 'text'\n    is_multipart = maintype == 'multipart'\n\n    if base.parts and not is_multipart:\n        raise RuntimeError(\n            'Content type should be multipart, not %r' % ctype\n            )\n\n    body = base.get_body()\n    ctenc = base.get_transfer_encoding()\n    charset = ctparams.get('charset')\n\n    if is_multipart:\n        out = MIMEMultipart(subtype, **ctparams)\n    else:\n        out = MIMENonMultipart(maintype, subtype, **ctparams)\n        if ctenc:\n            out['Content-Transfer-Encoding'] = ctenc\n        if isinstance(body, text_type):\n            if not charset:\n                if is_text:\n                    charset, _ = best_charset(body)\n                else:\n                    charset = 'utf-8'\n            if PY2:\n                body = body.encode(charset)\n            else: # pragma: no cover\n                body = body.encode(charset, 'surrogateescape')\n        if body is not None:\n            if ctenc:\n                body = transfer_encode(ctenc, body)\n            if not PY2: # pragma: no cover\n                body = body.decode(charset or 'ascii', 'replace')\n        out.set_payload(body, charset) \n\n    for k in base.keys(): # returned sorted\n        value = base[k]\n        if not value:\n            continue\n        out[k] = value\n\n    cdisp, cdisp_params = base.get_content_disposition()\n\n    if cdisp:\n        out.add_header('Content-Disposition', cdisp, **cdisp_params)\n\n    # go through the children\n    for part in base.parts:\n        sub = to_message(part)\n        out.attach(sub)\n\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds the most human - readable and conventional encoding for unicode text.", "response": "def best_charset(text):\n    \"\"\"\n    Find the most human-readable and/or conventional encoding for unicode text.\n\n    Prefers `us-ascii` or `iso-8859-1` and falls back to `utf-8`.\n    \"\"\"\n    if isinstance(text, bytes):\n        text = text.decode('ascii')\n    for charset in 'us-ascii', 'iso-8859-1', 'utf-8':\n        try:\n            encoded = text.encode(charset)\n        except UnicodeError:\n            pass\n        else:\n            return charset, encoded"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_message(self):\n\n        self.validate()\n        \n        bodies = [(self.body, 'text/plain'), (self.html, 'text/html')]\n\n        for idx, (val, content_type) in enumerate(bodies):\n            if val is None:\n                bodies[idx] = None\n            elif isinstance(val, Attachment):\n                bodies[idx] = val.to_mailbase(content_type)\n            else:\n                # presumed to be a textual val\n                attachment = Attachment(\n                    data=val,\n                    content_type=content_type,\n                    transfer_encoding='quoted-printable',\n                    disposition='inline'\n                    )\n                bodies[idx] = attachment.to_mailbase(content_type)\n\n        body, html = bodies\n\n        base = MailBase([\n            ('To', ', '.join(self.recipients)),\n            ('From', self.sender),\n            ('Subject', self.subject),\n            ])\n\n        # base represents the outermost mime part; it will be one of the\n        # following types:\n        #\n        # - a multipart/mixed type if there are attachments.  this\n        #   part will contain a single multipart/alternative type if there\n        #   is both an html part and a plaintext part (the alternative part\n        #   will contain both the text and html), it will contain\n        #   a single text/plain part if there is only a plaintext part,\n        #   or it will contain a single text/html part if there is only\n        #   an html part.  it will also contain N parts representing\n        #   each attachment as children of the base mixed type.\n        #\n        # - a multipart/alternative type if there are no attachments but\n        #   both an html part and a plaintext part.  it will contain\n        #   a single text/plain part if there is only a plaintext part,\n        #   or it will contain a single text/html part if there is only\n        #   an html part.\n        #\n        # - a text/plain type if there is only a plaintext part\n        #\n        # - a text/html type if there is only an html part\n\n        if self.cc:\n            base['Cc'] = ', '.join(self.cc)\n            \n        if self.extra_headers:\n            base.update(dict(self.extra_headers))\n\n        if self.attachments:\n            base.set_content_type('multipart/mixed')\n            altpart = MailBase()\n            base.attach_part(altpart)\n        else:\n            altpart = base\n            \n        if body and html:\n            altpart.set_content_type('multipart/alternative')\n            altpart.set_body(None)\n            # Per RFC2046, HTML part comes last in multipart/alternative\n            altpart.attach_part(body)\n            altpart.attach_part(html)\n        elif body is not None:\n            altpart.merge_part(body)\n        elif html is not None:\n            altpart.merge_part(html)\n\n        for attachment in self.attachments:\n            attachment_mailbase = attachment.to_mailbase()\n            base.attach_part(attachment_mailbase)\n\n        return to_message(base)", "response": "Converts the message to a raw email. Message instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_bad_headers(self):\n\n        headers = [self.subject, self.sender]\n        headers += list(self.send_to)\n        headers += dict(self.extra_headers).values()\n\n        for val in headers:\n            for c in '\\r\\n':\n                if c in val:\n                    return True\n        return False", "response": "Checks if the message contains bad headers i. e. newlines in subject sender or recipients."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate(self):\n\n        if not (self.recipients or self.cc or self.bcc):\n            raise InvalidMessage(\"No recipients have been added\")\n\n        if not self.body and not self.html:\n            raise InvalidMessage(\"No body has been set\")\n\n        if not self.sender:\n            raise InvalidMessage(\"No sender address has been set\")\n\n        if self.is_bad_headers():\n            raise BadHeaders", "response": "Checks if message is valid and raises appropriate exception."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_settings(cls, settings, prefix='mail.'):\n        settings = settings or {}\n        top_level_directory = settings.get(prefix+'top_level_directory')\n        if top_level_directory is None:\n            raise ValueError(\"DebugMailer:  must specify \"\n                             \"'%stop_level_directory'\" % prefix)\n        return cls(top_level_directory)", "response": "Create a new instance of DebugMailer from a settings dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends a message to a file for debugging", "response": "def _send(self, message, fail_silently=False):\n        \"\"\"Save message to a file for debugging\n        \"\"\"\n        seeds = '1234567890qwertyuiopasdfghjklzxcvbnm'\n        file_part1 = datetime.now().strftime('%Y%m%d%H%M%S')\n        file_part2 = ''.join(sample(seeds, 4))\n        filename = join(self.tld, '%s_%s.msg' % (file_part1, file_part2))\n        with open(filename, 'w') as fd:\n            fd.write(str(message.to_message()))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_settings(cls, settings, prefix='mail.'):\n        settings = settings or {}\n\n        kwarg_names = [prefix + k for k in (\n                       'host', 'port', 'username',\n                       'password', 'tls', 'ssl', 'keyfile',\n                       'certfile', 'queue_path', 'debug', 'default_sender')]\n\n        size = len(prefix)\n\n        kwargs = dict(((k[size:], settings[k]) for k in settings.keys() if\n                        k in kwarg_names))\n\n        for key in ('tls', 'ssl'):\n            val = kwargs.get(key)\n            if val:\n                kwargs[key] = asbool(val)\n\n        return cls(**kwargs)", "response": "Create a new instance of Mailer from a dictionary - like object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a message immediately outside the transaction manager.", "response": "def send_immediately(self, message, fail_silently=False):\n        \"\"\"Send a message immediately, outside the transaction manager.\n\n        If there is a connection error to the mail server this will have to\n        be handled manually. However if you pass ``fail_silently`` the error\n        will be swallowed.\n\n        :versionadded: 0.3\n\n        :param message: a 'Message' instance.\n\n        :param fail_silently: silently handle connection errors.\n        \"\"\"\n        try:\n            return self.smtp_mailer.send(*self._message_args(message))\n        except smtplib.socket.error:\n            if not fail_silently:\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_to_queue(self, message):\n        if not self.queue_delivery:\n            raise RuntimeError(\"No queue_path provided\")\n\n        return self.queue_delivery.send(*self._message_args(message))", "response": "Add a message to a maildir queue."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if an object is a sequence.", "response": "def is_seq(obj):\n    \"\"\"\n    Check if an object is a sequence.\n    \"\"\"\n    return (not is_str(obj) and not is_dict(obj) and\n            (hasattr(obj, \"__getitem__\") or hasattr(obj, \"__iter__\")))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dict_values(src):\n    for v in src.values():\n        if isinstance(v, dict):\n            for v in dict_values(v):\n                yield v\n        else:\n            yield v", "response": "Recursively get values in dict.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the _curve_rates attribute of the object.", "response": "def curve_rates(self, curve_rates):\n        \"\"\"\n        :param curve_rates:\n        :return:\n        \"\"\"\n        if curve_rates is not None:\n            if isinstance(curve_rates, str):\n                self._curve_rates = curve_rates\n            else:\n                try:\n                    self._curve_rates = json.dumps(curve_rates)\n                except TypeError:\n                    raise TypeError('Passed in curve rates object are not json serializable.Please check the format')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the curve timestamp.", "response": "def curve_timestamp(self, curve_timestamp):\n        \"\"\"\n        Force the timestamp to be a datetime\n        :param curve_timestamp:\n        :return:\n        \"\"\"\n        if curve_timestamp is not None:\n            curve_timestamp = str(curve_timestamp)\n            if isinstance(curve_timestamp, str):\n                curve_timestamp = parse(curve_timestamp).replace(tzinfo=pytz.utc)\n            if type(curve_timestamp) == date:\n                curve_timestamp = datetime.combine(curve_timestamp, datetime.min.time()).replace(tzinfo=pytz.utc)\n            if not curve_timestamp.tzinfo:\n                raise ValueError('Cannot set a curve without a timezone')            \n            if curve_timestamp > datetime.utcnow().replace(tzinfo=pytz.utc):\n                raise ValueError('Cannot set a curve in the future: %s' % curve_timestamp.isoformat())\n            self._curve_timestamp = curve_timestamp"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nliking sys.addsitedir() but gives the added directory preference over system directories. The paths will be normalized for dots and slash direction before being added to the path. projdir: the path you want to add to sys.path. If its a a file, the parent directory will be added *args: additional directories relative to the projdir to add to sys.path.", "response": "def prependsitedir(projdir, *args):\n    \"\"\"\n        like sys.addsitedir() but gives the added directory preference\n        over system directories.  The paths will be normalized for dots and\n        slash direction before being added to the path.\n\n        projdir: the path you want to add to sys.path.  If its a\n            a file, the parent directory will be added\n\n        *args: additional directories relative to the projdir to add\n            to sys.path.\n    \"\"\"\n    # let the user be lazy and send a file, we will convert to parent directory\n    # of file\n    if path.isfile(projdir):\n        projdir = path.dirname(projdir)\n\n    projdir = path.abspath(projdir)\n\n    # any args are considered paths that need to be joined to the\n    # projdir to get to the correct directory.\n    libpaths = []\n    for lpath in args:\n        libpaths.append(path.join(projdir, path.normpath(lpath)))\n\n    # add the path to sys.path with preference over everything that currently\n    # exists in sys.path\n    syspath_orig = set(sys.path)\n    site.addsitedir(projdir)\n    for lpath in libpaths:\n        site.addsitedir(lpath)\n    syspath_after = set(sys.path)\n    new_paths = list(syspath_after.difference(syspath_orig))\n    sys.path = new_paths + sys.path"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_split(import_name):\n    obj = None\n    attr = None\n    if ':' in import_name:\n        module, obj = import_name.split(':', 1)\n        if '.' in obj:\n            obj, attr = obj.rsplit('.', 1)\n    elif '.' in import_name:\n        module, obj = import_name.rsplit('.', 1)\n    else:\n        module = import_name\n    return module, obj, attr", "response": "takes a dotted string path and returns the module object and attribute"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds the python version of the base package that the said path belongs to.", "response": "def find_path_package(thepath):\n    \"\"\"\n        Takes a file system path and returns the module object of the python\n        package the said path belongs to. If the said path can not be\n        determined, it returns None.\n    \"\"\"\n    pname = find_path_package_name(thepath)\n    if not pname:\n        return None\n    fromlist = b'' if six.PY2 else ''\n    return __import__(pname, globals(), locals(), [fromlist])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_path_package_name(thepath):\n    module_found = False\n    last_module_found = None\n    continue_ = True\n    while continue_:\n        module_found = is_path_python_module(thepath)\n        next_path = path.dirname(thepath)\n        if next_path == thepath:\n            continue_ = False\n        if module_found:\n            init_names = ['__init__%s' % suffix.lower() for suffix in _py_suffixes]\n            if path.basename(thepath).lower() in init_names:\n                last_module_found = path.basename(path.dirname(thepath))\n            else:\n                last_module_found = path.basename(thepath)\n        if last_module_found and not module_found:\n            continue_ = False\n        thepath = next_path\n    return last_module_found", "response": "Given a file system path and returns the name of the python package that the said path belongs to."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_path_python_module(thepath):\n    thepath = path.normpath(thepath)\n\n    if path.isfile(thepath):\n        base, ext = path.splitext(thepath)\n        if ext in _py_suffixes:\n            return True\n        return False\n\n    if path.isdir(thepath):\n        for suffix in _py_suffixes:\n            if path.isfile(path.join(thepath, '__init__%s' % suffix)):\n                return True\n    return False", "response": "Given a path find out of the path is a python module."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_string(import_name, silent=False):\n\n    try:\n        if ':' in import_name:\n            module, obj_name = import_name.split(':', 1)\n        elif '.' in import_name:\n            module, obj_name = import_name.rsplit('.', 1)\n        else:\n            return __import__(import_name)\n\n        return getattr(__import__(module, None, None, [obj_name]), obj_name)\n    except (ImportError, AttributeError):\n        if not silent:\n            raise", "response": "Imports an object based on a dotted name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_files(root, pattern):\n    results = []\n    for base, dirs, files in os.walk(root):\n        matched = fnmatch.filter(files, pattern)\n        results.extend(os.path.join(base, f) for f in matched)\n    return results", "response": "Find all files matching the glob pattern recursively\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_directories(root, pattern):\n    results = []\n    for base, dirs, files in os.walk(root):\n        matched = fnmatch.filter(dirs, pattern)\n        results.extend(os.path.join(base, d) for d in matched)\n    return results", "response": "Find all directories matching the glob pattern recursively\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef posargs_limiter(func, *args):\n    posargs = inspect.getargspec(func)[0]\n    length = len(posargs)\n    if inspect.ismethod(func):\n        length -= 1\n    if length == 0:\n        return func()\n    return func(*args[0:length])", "response": "Takes a function a positional arguments and sends only the number of positional arguments the function is expecting\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning composition on a series of functions.", "response": "def compose(*functions):\n    \"\"\"Function composition on a series of functions.\n\n    Remember that function composition runs right-to-left: `f . g . h = f(g(h(x)))`. As a unix\n    pipeline, it would be written: `h | g | f`.\n\n    From https://mathieularose.com/function-composition-in-python/.\n    \"\"\"\n    return functools.reduce(lambda f, g: lambda x: f(g(x)), functions, identity)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef first_where(pred, iterable, default=None):\n    return next(six.moves.filter(pred, iterable), default)", "response": "Returns the first element in an iterable that meets the given predicate."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef partition_iter(pred, iterable):\n    left, right = itertools.tee(iterable, 2)\n    return (\n        (x for x in left if pred(x)),\n        (y for y in right if not pred(y))\n    )", "response": "Partitions an iterable with a predicate into two iterables one with elements satisfying\n    the predicate and one with elements that do not satisfy it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npartitioning an iterable with a predicate into two lists one with elements satisfying the predicate and one with elements that do not satisfy it.", "response": "def partition_list(pred, iterable):\n    \"\"\"Partitions an iterable with a predicate into two lists, one with elements satisfying\n    the predicate and one with elements that do not satisfy it.\n\n    .. note: this just converts the results of partition_iter to a list for you so that you don't\n    have to in most cases using `partition_iter` is a better option.\n\n    :returns: a tuple (satisfiers, unsatisfiers).\n    \"\"\"\n    left, right = partition_iter(pred, iterable)\n    return list(left), list(right)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nunzips an iterable of tuples into a tuple of lists.", "response": "def unzip(iterable):\n    \"\"\"Unzip/transpose an iterable of tuples into a tuple of lists.\n\n    WARNING: When given an empty iterable, this returns an empty list instead of a tuple. If you\n    need a consistent interface then do something like this:\n\n        left, right = unzip(two_columned_list) or ([], [])\n    \"\"\"\n    return list(map(list, list(six.moves.zip(*iterable))))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a generator that spits an iterable into n - sized chunks.", "response": "def split_every(n, iterable):\n    \"\"\"Returns a generator that spits an iteratable into n-sized chunks. The last chunk may have\n    less than n elements.\n\n    See http://stackoverflow.com/a/22919323/503377.\"\"\"\n    items = iter(iterable)\n    return itertools.takewhile(bool, (list(itertools.islice(items, n)) for _ in itertools.count()))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding all the unique values in an iterable maintaining order", "response": "def unique(iterable, key=identity):\n    \"\"\"Yields all the unique values in an iterable maintaining order\"\"\"\n    seen = set()\n    for item in iterable:\n        item_key = key(item)\n        if item_key not in seen:\n            seen.add(item_key)\n            yield item"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nformatting data to get a readable output", "response": "def _format_output(selected_number, raw_data):\n    \"\"\"Format data to get a readable output\"\"\"\n    tmp_data = {}\n    data = collections.defaultdict(lambda: 0)\n    balance = raw_data.pop('balance')\n    for number in raw_data.keys():\n        tmp_data = dict([(k, int(v) if v is not None else \"No limit\")\n                         for k, v in raw_data[number].items()])\n        tmp_data['number'] = number\n        if selected_number is None or selected_number == number:\n            data[number] = tmp_data\n\n    output = (\"\"\"Account Balance\n=======\n\nBalance:      {:.2f} $\n\"\"\")\n    print(output.format(balance))\n    for number_data in data.values():\n        _print_number(number_data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-u', '--username',\n                        required=True, help='Fido username')\n    parser.add_argument('-n', '--number', default=None,\n                        required=False, help='Fido phone number')\n    parser.add_argument('-p', '--password',\n                        required=True, help='Password')\n    parser.add_argument('-l', '--list', action='store_true',\n                        default=False, help='List phone numbers')\n    parser.add_argument('-j', '--json', action='store_true',\n                        default=False, help='Json output')\n    parser.add_argument('-t', '--timeout',\n                        default=REQUESTS_TIMEOUT, help='Request timeout')\n    args = parser.parse_args()\n    client = FidoClient(args.username, args.password, args.timeout)\n    loop = asyncio.get_event_loop()\n    fut = asyncio.wait([client.fetch_data()])\n    loop.run_until_complete(fut)\n    if args.list:\n        if not client.get_phone_numbers():\n            return\n        if args.json:\n            print(json.dumps(client.get_phone_numbers()))\n        else:\n            print(\"Phone numbers: \"\n                  \"{}\".format(\", \".join(client.get_phone_numbers())))\n    else:\n        if not client.get_data():\n            return\n        if args.json:\n            print(json.dumps(client.get_data()))\n        else:\n            _format_output(args.number, client.get_data())\n    client.close_session()", "response": "Main function of the\n    command line interface"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iteritems(self):\n        sorted_data = sorted(self.data.iteritems(), self.cmp, self.key,\n                             self.reverse)\n        for k,v in sorted_data:\n            yield k,v", "response": "Iterate over the dictionary and return a generator of the keys and values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _adapt_param(self, key, val):\n        if key in self.param_adapters:\n            try:\n                return self.param_adapters[key](val)\n            except (AdaptError, AdaptErrors, TypeError, ValueError) as e:\n                if hasattr(e, 'errors'):\n                    errors = e.errors\n                else:\n                    errors = [e]\n\n                raise AnticipateParamError(\n                    message='Input value %r for parameter `%s` does not match '\n                        'anticipated type %r' % (type(val), key, self.params[key]),\n                    name=key,\n                    value=val,\n                    anticipated=self.params[key],\n                    errors=errors)\n        else:\n            return val", "response": "Adapt the value of a parameter."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef input(self, *args, **kwargs):\n        errors = []\n\n        if args and self.arg_names:\n            args = list(args)\n            # Replace args inline that have adapters\n            for i, (key, val) in enumerate(izip(self.arg_names, args)):\n                try:\n                    args[i] = self._adapt_param(key, val)\n                except AnticipateParamError as e:\n                    errors.append(e)\n            args = tuple(args)\n\n        if kwargs and self.params:\n            # Adapt all adaptable arguments\n            for key, val in kwargs.items():\n                try:\n                    kwargs[key] = self._adapt_param(key, val)\n                except AnticipateParamError as e:\n                    errors.append(e)\n\n        if errors:\n            raise AnticipateErrors(\n                message='Invalid input for %s' % self.func,\n                errors=errors)\n\n        return args, kwargs", "response": "Adapt the input and check for errors."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef output(self, result):\n        if self.returns:\n            errors = None\n            try:\n                return self._adapt_result(result)\n            except AdaptErrors as e:\n                errors = e.errors\n            except AdaptError as e:\n                errors = [e]\n\n            raise AnticipateErrors(\n                message='Return value %r does not match anticipated type %r'\n                    % (type(result), self.returns),\n                errors=errors)\n        elif self.strict:\n            if result is not None:\n                raise AnticipateErrors(\n                    message='Return value %r does not match anticipated value '\n                    'of None' % type(result),\n                    errors=None)\n            return None\n        else:\n            return result", "response": "Adapt the result of a function based on the returns definition."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npassing the value to FileField and resizes the image at the path the parent returns if needed.", "response": "def clean(self, value):\n        \"\"\"Passes the value to FileField and resizes the image at the path the parent\n        returns if needed.\n\n        \"\"\"\n        path = super(Image, self).clean(value)\n        if path and self.size:\n            self.resize_image(join(self.base_path, path))\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the dimensions of the image.", "response": "def calculate_dimensions(image_size, desired_size):\n        \"\"\"Return the Tuple with the arguments to pass to Image.crop.\n\n        If the image is smaller than than the desired_size Don't do\n        anything. Otherwise, first calculate the (truncated) center and then\n        take half the width and height (truncated again) for x and y.\n\n        x0, y0: the center coordinates\n        \"\"\"\n\n        current_x, current_y = image_size\n        target_x, target_y = desired_size\n\n        if current_x < target_x and current_y < target_y:\n            return None\n\n        if current_x > target_x:\n            new_x0 = floor(current_x / 2)\n            new_x = new_x0 - ceil(target_x / 2)\n            new_width = target_x\n        else:\n            new_x = 0\n            new_width = current_x\n\n        if current_y > target_y:\n            new_y0 = floor(current_y / 2)\n            new_y = new_y0 - ceil(target_y / 2)\n            new_height = target_y\n        else:\n            new_y = 0\n            new_height = current_y\n\n        return (int(new_x), int(new_y), new_width, new_height)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef slugify(value):\n    # TODO(Jim Zhan) whether to use jinja2???\n    value = Markup(value).striptags()\n    if type(value) == unicode:\n        value = unicode(unidecode(value))\n        value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore')\n    value = unicode(re.sub('[^\\w\\s-]', '', value).strip().lower())\n    return re.sub('[-\\s]+', '-', value)", "response": "Normalizes string converts to lowercase removes non - alpha characters removes spaces to hyphens."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rpc_handler(request):\n    global ip\n    \"\"\"\n        the actual handler:\n        if you setup your urls.py properly, all calls to the xml-rpc service\n        should be routed through here.\n        If post data is defined, it assumes it's XML-RPC and tries to process as such\n        Empty post assumes you're viewing from a browser and tells you about the service.\n        \"\"\"\n    if len(request.body):\n        ip = request.META[\"REMOTE_ADDR\"]\n        response = HttpResponse(mimetype=\"application/xml\")\n        data = dispatcher._marshaled_dispatch(request.body)\n        response.write(data)\n\n        #d = Xmlrpc(request)\n    else:\n        response = HttpResponse()\n        response.write(\"<h1>This is an XML-RPC Service.</h2>\")\n        response.write(\"<p>You need to invoke it using an XML-RPC Client!</p>\")\n        response.write(\"The following methods are available:<ul>\")\n        methods = dispatcher.system_listMethods()\n\n        for method in methods:\n            sig = dispatcher.system_methodSignature(method)\n            # this just reads your docblock, so fill it in!\n            help = dispatcher.system_methodHelp(method)\n\n            response.write(\"<li><b>%s</b>: [%s] %s\" % (method, sig, help))\n        response.write(\"</ul>\")\n\n    response['Content-length'] = str(len(response.content))\n    return response", "response": "This function is the main handler for the XML - RPC service. It is called by the HTTP server to handle the request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndefault OPTIONS response If the 'cors' option is True, will respond with an empty response and set the 'Access-Control-Allow-Headers' and 'Access-Control-Allow-Methods' headers", "response": "def options(self, *args, **kwargs):\n        \"\"\"Default OPTIONS response\n\n        If the 'cors' option is True, will respond with an empty response and\n        set the 'Access-Control-Allow-Headers' and\n        'Access-Control-Allow-Methods' headers\n        \"\"\"\n        if getattr(options, 'cors', False):\n            self.set_header('Access-Control-Allow-Headers',\n                            'Content-Type, Authorization, '\n                            'Accept, X-Requested-With')\n            self.set_header('Access-Control-Allow-Methods',\n                            'OPTIONS, TRACE, GET, HEAD, POST, '\n                            'PUT, PATCH, DELETE')\n\n        self.finish()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_error(self, status_code, **kwargs):\n        http_error = _get_http_error(kwargs)\n        if http_error:\n            self.finish(self._error_template(status_code,\n                                             http_error.errors,\n                                             http_error.source))\n        else:\n            source = kwargs.get('source', getattr(options, 'name', None))\n            # Slightly annoyed that have to rely on the internal self._reason\n            # to deal with unhandled exceptions. On the dev version of\n            # tornado self._reason is always set, while in the current version\n            # a reason kwarg is passed down from `send_error` but not set\n            # on the instance.\n            reason = kwargs.get('reason', self._reason)\n            self.finish(self._error_template(status_code, reason, source))", "response": "Override write_error in order to output JSON errors."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _error_template(cls, status_code, errors, source=None):\n        # this handles unhandled exceptions\n        if isinstance(errors, basestring):\n            errors_out = {'errors': [{'message': errors}]}\n        elif isinstance(errors, (list, tuple)):\n            errors_out = {'errors': [{'message': e} for e in errors]}\n        else:\n            errors_out = errors\n        errors_out['status'] = status_code\n\n        for error in errors_out['errors']:\n            if not error.get('source'):\n                error['source'] = source\n\n        logging.error(json.dumps(errors_out))\n        return errors_out", "response": "Construct a JSON error response from the status code and errors."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_json_body(self, required=None, validators=None):\n        content_type = self.request.headers.get('Content-Type',\n                                                'application/json')\n        if 'application/json' not in content_type.split(';'):\n            raise HTTPError(415, 'Content-Type should be application/json')\n        if not self.request.body:\n            error = 'Request body is empty'\n            logging.warning(error)\n            raise HTTPError(400, error)\n\n        try:\n            body = json.loads(self.request.body)\n        except (ValueError, TypeError):\n            error = 'Error parsing JSON'\n            logging.warning(error)\n            raise HTTPError(400, error)\n\n        if required:\n            _check_required(body, required)\n\n        if validators:\n            _validate(body, validators)\n\n        return body", "response": "Get the JSON body from the request body."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetermine the access level needed for the given HTTP verb.", "response": "def endpoint_access(self, method):\n        \"\"\"\n        Determine access level needed for endpoint\n        :param method: The request verb\n        :return: String representing access type.\n        \"\"\"\n        if method == 'OPTIONS':\n            # The CORS pre-flight checks should not require authentication\n            return self.UNAUTHENTICATED_ACCESS\n        elif method not in self.METHOD_ACCESS:\n            logging.error('Cannot determine access needed for %s method', method)\n            raise HTTPError(500, 'Internal Server Error')\n\n        return self.METHOD_ACCESS[method]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nverifying the token bearer is permitted to access the resource.", "response": "def verify_token(self, token, requested_access):\n        \"\"\"\n        Check the token bearer is permitted to access the resource\n\n        :param token: Access token\n        :param requested_access: the access level the client has requested\n        :returns: boolean\n        \"\"\"\n        client = API(options.url_auth,\n                     auth_username=options.service_id,\n                     auth_password=options.client_secret,\n                     ssl_options=ssl_server_options())\n        headers = {'Content-Type': 'application/x-www-form-urlencoded',\n                   'Accept': 'application/json'}\n        body = urllib.urlencode({'token': token, 'requested_access': requested_access})\n\n        client.auth.verify.prepare_request(headers=headers, request_timeout=180)\n\n        try:\n            result = yield client.auth.verify.post(body=body)\n        except tornado.httpclient.HTTPError as ex:\n            # Must be converted to a tornado.web.HTTPError for the server\n            # to handle it correctly\n            logging.exception(ex.message)\n            raise HTTPError(500, 'Internal Server Error')\n\n        raise Return(result['has_access'])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate provided token and access.", "response": "def prepare(self):\n        \"\"\"If OAuth verification is required, validate provided token\n\n        :raise: HTTPError if token does not have access\n        \"\"\"\n        requested_access = self.endpoint_access(self.request.method)\n        use_oauth = getattr(options, 'use_oauth', None)\n        if use_oauth and requested_access is not self.UNAUTHENTICATED_ACCESS:\n            token = self.request.headers.get('Authorization', '').split(' ')[-1]\n            if token:\n                has_access = yield self.verify_token(token, requested_access)\n                if not has_access:\n                    msg = \"'{}' access not granted.\".format(requested_access)\n                    raise HTTPError(403, msg)\n            else:\n                msg = 'OAuth token not provided'\n                raise HTTPError(401, msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compound_object(element_name, attrnames, warn=False):\n    class CompoundObject():\n        _original_fields = sorted(attrnames)\n        _fields = [_prefix_keyword(a, warn) for a in _original_fields]\n\n        def __init__(self, values, child_dict):\n            for name, val in zip(self._fields, values):\n                self.__dict__[name] = val\n            self._child_dict = child_dict\n            self.name = element_name\n\n        def getAttributes(self):\n            return [(k, getattr(self, k)) for k in self._fields]\n\n        def hasAttribute(self, name):\n            return name in self._fields\n\n        def setAttribute(self, name, value):\n            if name not in self._fields:\n                self._original_fields.append(name)\n                self._fields.append(_prefix_keyword(name, warn))\n            self.__dict__[name] = value\n\n        def hasChild(self, name):\n            return name in self._child_dict\n\n        def getChild(self, name):\n            return self._child_dict[name]\n\n        def addChild(self, name, attrs=None):\n            if attrs is None:\n                attrs = {}\n            clazz = compound_object(name, attrs.keys())\n            child = clazz([attrs.get(a) for a in sorted(attrs.keys())], _NO_CHILDREN)\n            if len(self._child_dict) == 0:\n                self._child_dict = OrderedDict()\n            self._child_dict.setdefault(name, []).append(child)\n            return child\n\n        def __getattr__(self, name):\n            if name[:2] != \"__\":\n                return self._child_dict.get(name, None)\n            raise AttributeError\n\n        def __setattr__(self, name, value):\n            if name != \"_child_dict\" and name in self._child_dict:\n                self._child_dict[name] = value\n            else:\n                self.__dict__[name] = value\n\n        def __delattr__(self, name):\n            if name in self._child_dict:\n                del self._child_dict[name]\n            else:\n                if name in self.__dict__:\n                    del self.__dict__[name]\n                self._original_fields.remove(name)\n                self._fields.remove(_prefix_keyword(name, False))\n\n        def __getitem__(self, name):\n            return self._child_dict[name]\n\n        def __str__(self):\n            return \"<%s,child_dict=%s>\" % (self.getAttributes(), dict(self._child_dict))\n\n        def toXML(self, initialIndent=\"\", indent=\"    \"):\n            fields = ['%s=\"%s\"' % (self._original_fields[i], str(getattr(self, k)))\n                      for i, k in enumerate(self._fields) if getattr(self, k) is not None \n                      # see #3454\n                      and not '{' in self._original_fields[i]]\n            if not self._child_dict:\n                return \"%s<%s %s/>\\n\" % (initialIndent, element_name, \" \".join(fields))\n            else:\n                s = \"%s<%s %s>\\n\" % (\n                    initialIndent, element_name, \" \".join(fields))\n                for l in self._child_dict.values():\n                    for c in l:\n                        s += c.toXML(initialIndent + indent)\n                return s + \"%s</%s>\\n\" % (initialIndent, element_name)\n\n        def __repr__(self):\n            return str(self)\n\n    return CompoundObject", "response": "return a class which delegates bracket access to an internal dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse(xmlfile, element_names, element_attrs={}, attr_conversions={},\n          heterogeneous=False, warn=False):\n    \"\"\"\n    Parses the given element_names from xmlfile and yield compound objects for\n    their xml subtrees (no extra objects are returned if element_names appear in\n    the subtree) The compound objects provide all element attributes of\n    the root of the subtree as attributes unless attr_names are supplied. In this\n    case attr_names maps element names to a list of attributes which are\n    supplied. If attr_conversions is not empty it must map attribute names to\n    callables which will be called upon the attribute value before storing under\n    the attribute name.\n    The compound objects gives dictionary style access to list of compound\n    objects o for any children with the given element name\n    o['child_element_name'] = [osub0, osub1, ...]\n    As a shorthand, attribute style access to the list of child elements is\n    provided unless an attribute with the same name as the child elements\n    exists (i.e. o.child_element_name = [osub0, osub1, ...])\n    @Note: All elements with the same name must have the same type regardless of\n    the subtree in which they occur (heterogeneous cases may be handled by\n    setting heterogeneous=False (with reduced parsing speed)\n    @Note: Attribute names may be modified to avoid name clashes\n    with python keywords. (set warn=True to receive renaming warnings)\n    @Note: The element_names may be either a single string or a list of strings.\n    @Example: parse('plain.edg.xml', ['edge'])\n    \"\"\"\n    if isinstance(element_names, str):\n        element_names = [element_names]\n    elementTypes = {}\n    for event, parsenode in ET.iterparse(xmlfile):\n        if parsenode.tag in element_names:\n            yield _get_compound_object(parsenode, elementTypes,\n                                       parsenode.tag, element_attrs,\n                                       attr_conversions, heterogeneous, warn)\n            parsenode.clear()", "response": "Parses the given element_names from xmlfile and yields the compound objects for each element in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the given xmlfile and yields a sequence of namedtuple elements.", "response": "def parse_fast(xmlfile, element_name, attrnames, warn=False, optional=False):\n    \"\"\"\n    Parses the given attrnames from all elements with element_name\n    @Note: The element must be on its own line and the attributes must appear in\n    the given order.\n    @Example: parse_fast('plain.edg.xml', 'edge', ['id', 'speed'])\n    \"\"\"\n    prefixedAttrnames = [_prefix_keyword(a, warn) for a in attrnames]\n    if optional:\n        pattern = ''.join(['<%s' % element_name] +\n                          ['(\\\\s+%s=\"(?P<%s>[^\"]*?)\")?' % a for a in zip(attrnames, prefixedAttrnames)])\n    else:\n        pattern = '.*'.join(['<%s' % element_name] +\n                            ['%s=\"([^\"]*)\"' % attr for attr in attrnames])\n    Record = namedtuple(element_name, prefixedAttrnames)\n    reprog = re.compile(pattern)\n    for line in open(xmlfile):\n        m = reprog.search(line)\n        if m:\n            if optional:\n                yield Record(**m.groupdict())\n            else:\n                yield Record(*m.groups())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef analyze(self, text,\n                window=2,\n                lower=False,\n                vertex_source='all_filters',\n                edge_source='no_stop_words',\n                pagerank_config={'alpha': 0.85, }):\n        \"\"\"\u5206\u6790\u6587\u672c\n\n        Keyword arguments:\n        text       --  \u6587\u672c\u5185\u5bb9\uff0c\u5b57\u7b26\u4e32\u3002\n        window     --  \u7a97\u53e3\u5927\u5c0f\uff0cint\uff0c\u7528\u6765\u6784\u9020\u5355\u8bcd\u4e4b\u95f4\u7684\u8fb9\u3002\u9ed8\u8ba4\u503c\u4e3a2\u3002\n        lower      --  \u662f\u5426\u5c06\u6587\u672c\u8f6c\u6362\u4e3a\u5c0f\u5199\u3002\u9ed8\u8ba4\u4e3aFalse\u3002\n        vertex_source   --  \u9009\u62e9\u4f7f\u7528words_no_filter, words_no_stop_words, words_all_filters\u4e2d\u7684\u54ea\u4e00\u4e2a\u6765\u6784\u9020pagerank\u5bf9\u5e94\u7684\u56fe\u4e2d\u7684\u8282\u70b9\u3002\n                            \u9ed8\u8ba4\u503c\u4e3a`'all_filters'`\uff0c\u53ef\u9009\u503c\u4e3a`'no_filter', 'no_stop_words', 'all_filters'`\u3002\u5173\u952e\u8bcd\u4e5f\u6765\u81ea`vertex_source`\u3002\n        edge_source     --  \u9009\u62e9\u4f7f\u7528words_no_filter, words_no_stop_words, words_all_filters\u4e2d\u7684\u54ea\u4e00\u4e2a\u6765\u6784\u9020pagerank\u5bf9\u5e94\u7684\u56fe\u4e2d\u7684\u8282\u70b9\u4e4b\u95f4\u7684\u8fb9\u3002\n                            \u9ed8\u8ba4\u503c\u4e3a`'no_stop_words'`\uff0c\u53ef\u9009\u503c\u4e3a`'no_filter', 'no_stop_words', 'all_filters'`\u3002\u8fb9\u7684\u6784\u9020\u8981\u7ed3\u5408`window`\u53c2\u6570\u3002\n        \"\"\"\n\n        self.text = text\n        self.word_index = {}\n        self.index_word = {}\n        self.keywords = []\n        self.graph = None\n\n        result = self.seg.segment(text=text, lower=lower)\n        self.sentences = result.sentences\n        self.words_no_filter = result.words_no_filter\n        self.words_no_stop_words = result.words_no_stop_words\n        self.words_all_filters = result.words_all_filters\n\n        options = ['no_filter', 'no_stop_words', 'all_filters']\n\n        if vertex_source in options:\n            _vertex_source = result['words_' + vertex_source]\n        else:\n            _vertex_source = result['words_all_filters']\n\n        if edge_source in options:\n            _edge_source = result['words_' + edge_source]\n        else:\n            _edge_source = result['words_no_stop_words']\n\n        self.keywords = util.sort_words(_vertex_source, _edge_source, window=window, pagerank_config=pagerank_config)", "response": "Analyze a text file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a list of keywords that are shorter than word_min_len", "response": "def wordvector(self, word_min_len=2):\n        \"\"\"\u83b7\u53d6\u6240\u6709\u5355\u8bcd\u548c\u6743\u91cd\u3002\n\n        Return:\n        result      --\u5355\u8bcd\u6743\u91cd\u96c6\u5408\n        \"\"\"\n        result = []\n        count = 0\n        for item in self.keywords:\n            if len(item.word) >= word_min_len:\n                result.append(item)\n                count += 1\n        util.log('debug','\u83b7\u53d6\u5355\u8bcd\u6743\u91cd\u96c6\u5408\u6210\u529f\uff1a\u3010{}\u3011'.format(result))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tracing(pattern=None, out=None):\n    _trace = partial(trace_line, pattern)\n\n    if out is None:\n        out = sys.stdout\n\n    with redirect_stdout(out):\n        sys.settrace(_trace)\n        try:\n            yield\n        finally:\n            sys.settrace(None)", "response": "A context manager that prints executed lines to stdout."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef trace(line):\n    args = line.split()\n    enable = args[0] in {'enable', 'on'}\n\n    if not enable:\n        sys.settrace(None)\n        sys.stdout = _ORIGINAL_STDOUT\n        return\n\n    pattern = args[1] if len(args) > 1 else None\n    sys.stdout = open(args[2], 'a') if len(args) > 2 else sys.stdout\n    sys.settrace(partial(trace_line, pattern))", "response": "Usage: %trace enable disable"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts MODIS file name to MODIS date.", "response": "def modis_filename2modisdate(modis_fname):\n    \"\"\"\n    #+\n    # MODIS_FILENAME2DATE : Convert MODIS file name to MODIS date\n    # \n    # @author: Renaud DUSSURGET (LER PAC/IFREMER)\n    # @history: Created by RD on 29/10/2012\n    #\n    #-\n    \"\"\"\n    \n    if not isinstance(modis_fname,list) : modis_fname=[modis_fname]\n    \n    return [os.path.splitext(os.path.basename(m))[0][1:12] for m in modis_fname]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\noverride some character settings in a node.", "response": "def override_params(opening_char='{', closing_char='}', separator_char='|'):\n    \"\"\"\n    Override some character settings\n\n    @type opening_char: str\n    @param opening_char: Opening character. Default: '{'\n    @type closing_char: str\n    @param closing_char: Closing character. Default: '}'\n    @type separator_char: str\n    @param separator_char: Separator char. Default: '|'\n    \"\"\"\n    global char_separator, char_opening, char_closing\n    char_separator = separator_char\n    char_opening = opening_char\n    char_closing = closing_char"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unique(text):\n\n    # check if the text is correct\n    correct, error = _is_correct(text)\n    if not correct:\n        raise Exception(error)\n\n    s = []\n    _all_unique_texts(text, s)\n    return s[0]", "response": "Return an unique text from a text written used spin syntax."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning all the possible choices from the given text.", "response": "def _choices(text, randomized=True):\n    \"\"\"\n    Return all the possible choices from the following format: {a|b|c}\n\n    @type text: str\n    @param text: Text written used spin syntax\n\n    @type randomized: bool\n    @param text: Specifies if the choices will be given in random order or not.\n\n    @return: A generator that yields all the possible choices\n    \"\"\"\n    if text:\n        # regex pattern that will be used for splitting\n        pattern = r'{0}|{1}|{2}'.format(\n            re.escape(char_opening),\n            re.escape(char_closing),\n            re.escape(char_separator)\n        )\n\n        choices = [x for x in re.split(pattern, text) if x]\n        if randomized:\n            random.shuffle(choices)\n        for x in choices:\n            yield x"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute all the possible unique texts in the given text.", "response": "def _all_unique_texts(text, final):\n    \"\"\"\n    Compute all the possible unique texts\n\n    @type text: str\n    @param text: Text written used spin syntax\n\n    @type final: list\n    @param final: An empty list where all the unique texts will be stored\n    @return: Nothing. The result will be in the 'final' list\n    \"\"\"\n    if not char_opening in text:\n        if not text in final:\n            final.append(text)\n        return\n\n    stack = []\n    indexes = []\n    for i, c in enumerate(text):\n        if c == char_closing:\n            if stack[-1] == char_opening:\n                start_index = indexes.pop()\n                substring = '' if i == start_index + 1 else text[start_index:i + 1]\n                # get some random combination\n                combination = next(_choices(substring))\n                new_text = text.replace(substring, combination)\n                _all_unique_texts(new_text, final)\n                return\n        elif c == char_opening:\n            stack.append(c)\n            indexes.append(i)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _is_correct(text):\n    error = ''\n    stack = []\n    for i, c in enumerate(text):\n        if c == char_opening:\n            stack.append(c)\n        elif c == char_closing:\n            if stack.count == 0:\n                error = 'Syntax incorrect. Found \"}\" before \"{\"'\n                break\n            last_char = stack.pop()\n            if last_char != char_opening:\n                error = 'Syntax incorrect. Found \"}\" before \"{\"'\n                break\n    if len(stack) > 0:\n        error = 'Syntax incorrect. Some \"{\" were not closed'\n    return not error, error", "response": "Checks if the specified text has a correct spin."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_format(**kwargs):\n\n    settings = foundations.data_structures.Structure(**{\"format\": QTextCharFormat(),\n                                                        \"background_color\": None,\n                                                        \"color\": None,\n                                                        \"font_weight\": None,\n                                                        \"font_point_size\": None,\n                                                        \"italic\": False})\n    settings.update(kwargs)\n\n    format = QTextCharFormat(settings.format)\n\n    settings.background_color and format.setBackground(settings.background_color)\n    settings.color and format.setForeground(settings.color)\n    settings.font_weight and format.setFontWeight(settings.font_weight)\n    settings.font_point_size and format.setFontPointSize(settings.font_point_size)\n    settings.italic and format.setFontItalic(True)\n\n    return format", "response": "Returns a QTextCharFormat instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_builtins(self):\n        for raw_name in dir(builtins):\n            if not raw_name.startswith('__'):\n\n                if raw_name.startswith('_'):\n                    function_name = raw_name[1:]\n                else:\n                    function_name = raw_name\n\n                builtin_function = Function(function_name, getattr(builtins, raw_name))\n                self.memory[function_name] = builtin_function", "response": "Load the built - in functions into the scope."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload the functions into the scope.", "response": "def load_functions(self, tree):\n        \"\"\"Load the functions into the scope.\"\"\"\n        for child in tree.children:\n            if isinstance(child, FunctionDeclaration):\n                function_name = child.identifier.name\n                self.memory[function_name] = Function(function_name, child)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef visit_FunctionDeclaration(self, node):\n        scope = self.memory.stack.current.current.copy()\n        args = [parameter.variable.identifier.name for parameter in node.parameters]\n\n        for i in islice(scope, len(args)):\n            self.memory.stack.current.current.pop(i)\n            self.memory[args[i]] = scope[i]\n\n        return self.visit(node.body)", "response": "Visitor for FunctionDeclaration AST node."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef visit_FunctionBody(self, node):\n        for child in node.children:\n            return_value = self.visit(child)\n\n            if isinstance(child, ReturnStatement):\n                return return_value\n\n            if isinstance(child, (IfStatement, WhileStatement)):\n                if return_value is not None:\n                    return return_value\n\n        return NoneType()", "response": "Visitor for FunctionBody AST node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef visit_WhileStatement(self, node):\n        while self.visit(node.condition):\n            result = self.visit(node.compound)\n            if result is not None:\n                return result", "response": "Visitor for WhileStatement AST node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef visit_Compound(self, node):\n        self.memory.append_scope()\n        for child in node.children:\n            return_value = self.visit(child)\n\n            if isinstance(child, ReturnStatement):\n                return return_value\n\n            if isinstance(child, (IfStatement, WhileStatement)):\n                if return_value is not None:\n                    return return_value\n        self.memory.pop_scope()", "response": "Visitor for Compound AST node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef visit_UnaryOperation(self, node):\n        if node.op.nature == Nature.PLUS:\n            return +self.visit(node.right)\n        elif node.op.nature == Nature.MINUS:\n            return -self.visit(node.right)\n        elif node.op.nature == Nature.NOT:\n            return Bool(not self.visit(node.right))", "response": "Visitor for UnaryOperation AST node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrender the page bar.", "response": "def render(self, form_id=None):\n        '''\n        \u52a8\u6001\u8f93\u51fahtml\u5185\u5bb9\n        '''\n        page_bar = self.page_bars.get(int(self.page / 10))\n        if page_bar is None:\n            return ''\n\n        _htmls = []\n        if form_id:\n            _htmls.append(u'''<script>\n                function goto_page(form_id,page){\n                    var form=document.getElementById(form_id);\n                    var page_input = document.createElement(\"input\");\n                    page_input.type=\"hidden\";\n                    page_input.name=\"page\";\n                    page_input.value=page;\n                    form.appendChild(page_input);\n                    form.submit();\n                }</script>''')\n        _htmls.append('<ul class=\"pagination pull-right\">')\n        _htmls.append(u'\\t<li class=\"disabled\"><a href=\"#\">\u67e5\u8be2\u8bb0\u5f55\u6570 %s</a></li>' % self.total)\n        current_start = self.page\n        if current_start == 1:\n            _htmls.append(u'\\t<li class=\"disabled\"><a href=\"#\">\u9996\u9875</a></li>')\n            _htmls.append(u'\\t<li class=\"disabled\"><a href=\"#\">&larr; \u4e0a\u4e00\u9875</a></li>')\n        else:\n            _htmls.append(u'\\t<li><a href=\"%s\">\u9996\u9875</a></li>' % self.url_func(1,form_id))\n            _htmls.append(u'\\t<li><a href=\"%s\">&larr; \u4e0a\u4e00\u9875</a></li>' % self.url_func(current_start - 1,form_id))\n\n        for page in page_bar:\n            _page_url = self.url_func(page,form_id)\n            if page == self.page:\n                _htmls.append(u'\\t<li class=\"active\"><span>%s <span class=\"sr-only\">{current}</span></span></li>' % page)\n            else:\n                _htmls.append(u'\\t<li><a href=\"%s\">%s</a></li>' % (_page_url, page))\n\n\n\n        current_end = self.page\n        if current_end == self.page_num:\n            _htmls.append(u'\\t<li class=\"disabled\"><a href=\"#\">\u4e0b\u4e00\u9875 &rarr;</a></li>')\n            _htmls.append(u'\\t<li class=\"disabled\"><a href=\"#\">\u5c3e\u9875</a></li>')\n        else:\n            _htmls.append(u'\\t<li><a href=\"%s\">\u4e0b\u4e00\u9875 &rarr;</a></li>' % self.url_func(current_end + 1,form_id))\n            _htmls.append(u'\\t<li><a href=\"%s\">\u5c3e\u9875</a></li>' % self.url_func(self.page_num,form_id))\n\n        _htmls.append('</ul>')\n\n        return '\\r\\n'.join(_htmls)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating servers and containers as required to meet the configuration of the specified base class.", "response": "def up(name, debug=False):\n    '''\n    Create servers and containers as required to meet the configuration\n    specified in _name_.\n\n    Args:\n        * name: The name of the yaml config file (you can omit the .yml extension for convenience)\n\n    Example:\n        fab ensemble.up:wordpress\n    '''\n\n    if debug:\n        env.ensemble_debug = True\n\n    filenames_to_try = [\n        name,\n        '%s.yml' % name,\n        '%s.yaml' % name,\n    ]\n\n    for filename in filenames_to_try:\n        if os.path.exists(filename):\n            with open(filename, 'r') as f:\n                config = yaml.load(f)\n            break\n    else:\n        abort('Ensemble manifest not found: %s' % name)\n\n    uncache()\n    try:\n        do_up(config)\n    except exceptions.ConfigException, e:\n        abort('Config error: ' + str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stop(name, file=sys.stderr):\n    if is_enabled():\n        elapsed = (time() - __TIMERS[name])\n        if elapsed > 60:\n            elapsed_str = '{:.1f} m'.format(elapsed / 60)\n        elif elapsed > 1:\n            elapsed_str = '{:.1f} s'.format(elapsed)\n        else:\n            elapsed_str = '{:.1f} ms'.format(elapsed * 1000)\n\n        del __TIMERS[name]\n        print(\"[prof]\", name, elapsed_str, file=file)\n    return is_enabled()", "response": "Stop a profiling timer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pdf_extract_text(path, pdfbox_path, pwd='', timeout=120):\n    \n    if not os.path.isfile(path):\n        raise IOError('path must be the location of the source pdf-file')\n    \n    if not os.path.isfile(pdfbox_path):\n        raise IOError('pdfbox_path must be the location of the pdfbox.jar')\n    \n    import subprocess\n    for p in os.environ['PATH'].split(':'):\n        if os.path.isfile(os.path.join(p, 'java')):\n            break\n    else:\n        print('java is not on the PATH')\n        return\n    try:\n        if pwd == '':\n            cmd = ['java', '-jar', pdfbox_path, 'ExtractText', path, path+'.txt']\n        else:\n            cmd = ['java', '-jar', pdfbox_path, 'ExtractText', '-password', pwd,\n                path, path+'.txt']\n        subprocess.check_call(cmd, stdin=subprocess.DEVNULL, \n            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=timeout)\n    \n    except subprocess.TimeoutExpired as e:\n        print('Timeout of {:.1f} min expired'.format(timeout/60))\n    \n    except subprocess.CalledProcessError as e:\n        print('Text could not successfully be extracted.')", "response": "Utility to use PDFBox from pdfbox. apache. org to extract text from a PDF file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef geh(m, c):\n    if m + c == 0:\n        return 0\n    else:\n        return math.sqrt(2 * (m - c) * (m - c) / (m + c))", "response": "Error function for hourly traffic flow measures after Geoffrey E. Havers"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the mean value", "response": "def avg(self):\n        \"\"\"return the mean value\"\"\"\n        # XXX rename this method\n        if len(self.values) > 0:\n            return sum(self.values) / float(len(self.values))\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef avg_abs(self):\n        # XXX rename this method\n        if len(self.values) > 0:\n            return sum(map(abs, self.values)) / float(len(self.values))\n        else:\n            return None", "response": "return the mean of absolute values"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the mean and standard deviation optionally limited to the last limit values", "response": "def meanAndStdDev(self, limit=None):\n        \"\"\"return the mean and the standard deviation optionally limited to the last limit values\"\"\"\n        if limit is None or len(self.values) < limit:\n            limit = len(self.values)\n        if limit > 0:\n            mean = sum(self.values[-limit:]) / float(limit)\n            sumSq = 0.\n            for v in self.values[-limit:]:\n                sumSq += (v - mean) * (v - mean)\n            return mean, math.sqrt(sumSq / limit)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef relStdDev(self, limit=None):\n        moments = self.meanAndStdDev(limit)\n        if moments is None:\n            return None\n        return moments[1] / moments[0]", "response": "return the relative standard deviation optionally limited to the last limit values"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the median value", "response": "def mean(self):\n        \"\"\"return the median value\"\"\"\n        # XXX rename this method\n        if len(self.values) > 0:\n            return sorted(self.values)[len(self.values) / 2]\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the median of absolute values", "response": "def mean_abs(self):\n        \"\"\"return the median of absolute values\"\"\"\n        # XXX rename this method\n        if len(self.values) > 0:\n            return sorted(map(abs, self.values))[len(self.values) / 2]\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy_resources_to_log_dir(log_dir):\n        css_path = resource_filename(Requirement.parse(\"egat\"), \"/egat/data/default.css\")\n        header_path = resource_filename(Requirement.parse(\"egat\"), \"/egat/data/egat_header.png\")\n        shutil.copyfile(css_path, log_dir + \"/style.css\")\n        shutil.copyfile(header_path, log_dir + \"/egat_header.png\")\n\n        return log_dir + os.sep + \"style.css\"", "response": "Copies the necessary static assets to the log_dir and returns the path \n        of the main css file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dump_queue(queue):\n        result = []\n\n        try:\n            while True:\n                item = queue.get_nowait()\n                result.append(item)\n        except: Empty\n\n        return result", "response": "Empties all pending items in a queue and returns them in a list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexecuting a system command with optional options.", "response": "def execute(command, cwd=os.path.curdir, **options):\n    \"\"\"\n    Run the system command with optional options.\n\n    Args:\n        * command: system command.\n        * cwd: current working directory.\n        * verbose: direct options for :func:`subprocess.Popen`.\n\n    Returns:\n        Opened process, standard output & error.\n    \"\"\"\n    process = subprocess.Popen(shlex.split(command), cwd=cwd, **options)\n    stdout, stderr = process.communicate() \n    return process, stdout, stderr"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting the struct to a dictionary.", "response": "def to_dict(self, copy=False):\n        \"\"\"Convert the struct to a dictionary.\n\n        If `copy == True`, returns a deep copy of the values.\n\n        \"\"\"\n        new_dict = {}\n        for attr, value in self:\n            if copy:\n                value = deepcopy(value)\n            new_dict[attr] = value\n\n        return new_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart the process essentially forks and calls target function.", "response": "def start(self):\n        \"\"\"Start the process, essentially forks and calls target function.\"\"\" \n        logger.info(\"starting process\")\n        process = os.fork()\n        time.sleep(0.01)\n        if process != 0:\n            logger.debug('starting child watcher')\n            self.loop.reset()\n            self.child_pid = process\n            self.watcher = pyev.Child(self.child_pid, False, self.loop, self._child)\n            self.watcher.start()\n        else:\n            self.loop.reset()\n            logger.debug('running main function')\n            self.run(*self.args, **self.kwargs) \n            logger.debug('quitting')\n            sys.exit(0)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stop(self):\n        logger.info(\"stopping process\")\n        self.watcher.stop()\n        os.kill(self.child_pid, signal.SIGTERM)", "response": "Stop the child process."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef main(args, stop=False):\n    daemon = AMQPDaemon(\n        con_param=getConParams(\n            settings.RABBITMQ_ANTIVIRUS_VIRTUALHOST\n        ),\n        queue=settings.RABBITMQ_ANTIVIRUS_INPUT_QUEUE,\n        out_exch=settings.RABBITMQ_ANTIVIRUS_EXCHANGE,\n        out_key=settings.RABBITMQ_ANTIVIRUS_OUTPUT_KEY,\n        react_fn=reactToAMQPMessage,\n        glob=globals()                # used in deserializer\n    )\n\n    if not stop and args.foreground:  # run at foreground\n        daemon.run()\n    else:\n        daemon.run_daemon()", "response": "Main entry point for the daemon."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setup(settings):\n    connector = settings.get('db_connector')\n    if connector == 'postgres':\n        from playhouse.pool import PooledPostgresqlExtDatabase\n        return PooledPostgresqlExtDatabase(settings['db_name'],\n                           user=settings['db_user'],\n                           password=settings['db_password'],\n                           host=settings['db_host'],\n                           port=settings.get('db_port'),\n                           max_connections=settings.get('db_max_conn'),\n                           stale_timeout=settings.get('db_stale_timeout'),\n                           timeout=settings.get('db_timeout'),\n                           register_hstore=False)", "response": "Setup the database connection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a model into a json using the playhouse shortcut.", "response": "def to_json(self, extras=None):\n        \"\"\"\n        Convert a model into a json using the playhouse shortcut.\n        \"\"\"\n        extras = extras or {}\n        to_dict = model_to_dict(self)\n        to_dict.update(extras)\n        return json.dumps(to_dict, cls=sel.serializers.JsonEncoder)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef default_commit_veto(request, response):\n    xtm = response.headers.get('x-tm')\n    if xtm is not None:\n        return xtm != 'commit'\n    return response.status.startswith(('4', '5'))", "response": "Default commit veto logic."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_reftrack(self, reftrack):\n        self._reftracks.add(reftrack)\n        refobj = reftrack.get_refobj()\n        if refobj:\n            self._parentsearchdict[refobj] = reftrack", "response": "Adds a reftrack object to the root."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_reftrack(self, reftrack):\n        self._reftracks.remove(reftrack)\n        refobj = reftrack.get_refobj()\n        if refobj and refobj in self._parentsearchdict:\n            del self._parentsearchdict[refobj]", "response": "Removes the reftrack from the root."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_refobj(self, old, new, reftrack):\n        if old:\n            del self._parentsearchdict[old]\n        if new:\n            self._parentsearchdict[new] = reftrack", "response": "Update the parent search dict so that the new refobj can be found\n        with the old refobj and delete the entry for the new refobj."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_scene_suggestions(self, refobjinter):\n        sugs = []\n        cur = refobjinter.get_current_element()\n        if not cur:\n            return sugs\n        for typ in refobjinter.types:\n            inter = refobjinter.get_typ_interface(typ)\n            elements = inter.get_scene_suggestions(cur)\n            for e in elements:\n                for r in self._reftracks:\n                    if not r.get_parent() and typ == r.get_typ() and e == r.get_element():\n                        break\n                else:\n                    sugs.append((typ, e))\n        return sugs", "response": "Return a list of suggested Reftracks for the current scene that are not already there."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wrap(cls, root, refobjinter, refobjects):\n        tracks = []\n        for r in refobjects:\n            track = cls(root=root, refobjinter=refobjinter, refobj=r)\n            tracks.append(track)\n\n        for t in tracks:\n            parentrefobj = refobjinter.get_parent(t._refobj)\n            if parentrefobj:\n                parentreftrack = root.get_reftrack(parentrefobj)\n            else:\n                parentreftrack = None\n            t.set_parent(parentreftrack)\n            t.fetch_new_children()\n            t.update_restrictions()\n            t.emit_data_changed()\n        return tracks", "response": "Wrap the given list of reftracks in a list of reftracks and set the right parents"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwrapping all reftracks in the scene and set the right parents", "response": "def wrap_scene(cls, root, refobjinter):\n        \"\"\"Wrap all refobjects in the scene in a :class:`Reftrack` instance\n        and set the right parents, also add suggestions for the current scene\n\n        When you want to quickly scan the scene and display the reftracks in a tool,\n        this is the easiest function.\n\n        It uses wrap on all refobjects in the scene, then adds suggestions for the\n        current scene.\n\n        :param root: the root that groups all reftracks and makes it possible to search for parents\n        :type root: :class:`ReftrackRoot`\n        :param refobjinter: a programm specific reftrack object interface\n        :type refobjinter: :class:`RefobjInterface`\n        :returns: list with the wrapped :class:`Reftrack` instances\n        :rtype: list\n        :raises: None\n        \"\"\"\n        refobjects = cls.get_unwrapped(root, refobjinter)\n        tracks = cls.wrap(root, refobjinter, refobjects)\n        sugs = root.get_scene_suggestions(refobjinter)\n        for typ, element in sugs:\n            r = cls(root=root, refobjinter=refobjinter, typ=typ, element=element)\n            tracks.append(r)\n        return tracks"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_unwrapped(self, root, refobjinter):\n        all_refobjs = set(refobjinter.get_all_refobjs())\n        wrapped = set(root._parentsearchdict.keys())\n        return all_refobjs - wrapped", "response": "Return a set with all refobjects in the scene that are not in already\n        wrapped in root."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_refobj(self, refobj, setParent=True):\n        root = self.get_root()\n        old = self._refobj\n        self._refobj = refobj\n        refobjinter = self.get_refobjinter()\n        if self._refobj:\n            self.set_typ(refobjinter.get_typ(self._refobj))\n            self.set_taskfileinfo(refobjinter.get_taskfileinfo(self._refobj))\n            self.set_element(refobjinter.get_element(self._refobj))\n            if setParent:\n                parentrefobj = refobjinter.get_parent(self._refobj)\n                parentreftrack = root.get_reftrack(parentrefobj)\n                self.set_parent(parentreftrack)\n            self.set_status(refobjinter.get_status(self._refobj))\n        else:\n            self.set_taskfileinfo(None)\n            if setParent:\n                self.set_parent(None)\n            self.set_status(None)\n        root.update_refobj(old, refobj, self)\n        self.fetch_uptodate()", "response": "Sets the reftrack object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_typ(self, typ):\n        if typ not in self._refobjinter.types:\n            raise ValueError(\"The given typ is not supported by RefobjInterface. Given %s, supported: %s\" %\n                             (typ, self._refobjinter.types.keys()))\n        self._typ = typ\n        self._typicon = self.get_refobjinter().get_typ_icon(typ)", "response": "Set the type of the entity."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_taskfileinfo(self, tfi):\n        self._taskfileinfo = tfi\n        if tfi:\n            self.set_element(tfi.task.element)", "response": "Sets the taskfileinfo for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the parent reftrack object.", "response": "def set_parent(self, parent):\n        \"\"\"Set the parent reftrack object\n\n        If a parent gets deleted, the children will be deleted too.\n\n        .. Note:: Once the parent is set, it cannot be set again!\n\n        :param parent: the parent reftrack object\n        :type parent: :class:`Reftrack` | None\n        :returns: None\n        :rtype: None\n        :raises: AssertionError\n        \"\"\"\n        assert self._parent is None or self._parent is parent,\\\n            \"Cannot change the parent. Can only set from None.\"\n        if parent and self._parent is parent:\n            return\n        self._parent = parent\n        if parent:\n            refobjinter = self.get_refobjinter()\n            refobj = self.get_refobj()\n            # set the parent of the refobj only if it is not already set\n            # and only if there is one! oO\n            if refobj and not refobjinter.get_parent(refobj):\n                refobjinter.set_parent(refobj, parent.get_refobj())\n            # add to parent\n            self._parent.add_child(self)\n        if not self.get_refobj():\n            self.set_id(self.fetch_new_id())\n\n        pitem = self._parent._treeitem if self._parent else self.get_root().get_rootitem()\n        self._treeitem.set_parent(pitem)\n        self.fetch_alien()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_id(self, identifier):\n        self._id = identifier\n        refobj = self.get_refobj()\n        if refobj:\n            self.get_refobjinter().set_id(refobj, identifier)", "response": "Set the id of the given reftrack\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fetch_new_id(self, ):\n        parent = self.get_parent()\n        if parent:\n            others = parent._children\n        else:\n            others = [r for r in self.get_root()._reftracks if r.get_parent() is None]\n        others = [r for r in others\n                  if r != self\n                  and r.get_typ() == self.get_typ()\n                  and r.get_element() == self.get_element()]\n        highest = -1\n        for r in others:\n            identifier = r.get_id()\n            if identifier > highest:\n                highest = identifier\n        return highest + 1", "response": "Returns a new id for the given reftrack to be set on the refobject\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_treeitem(self, ):\n        p = self.get_parent()\n        root = self.get_root()\n        if p:\n            pitem = p.get_treeitem()\n        else:\n            pitem = root.get_rootitem()\n        idata = root.create_itemdata(self)\n        item = TreeItem(idata, parent=pitem)\n        return item", "response": "Create a new treeitem for this reftrack instance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset and return the options for possible files to load replace etc.", "response": "def fetch_options(self, ):\n        \"\"\"Set and return the options for possible files to\n        load, replace etc. The stored element will determine the options.\n\n        The refobjinterface and typinterface are responsible for providing the options\n\n        :returns: the options\n        :rtype: :class:`jukeboxcore.gui.treemodel.TreeModel`\n        :raises: None\n        \"\"\"\n        self._options, self._taskfileinfo_options = self.get_refobjinter().fetch_options(self.get_typ(), self.get_element())\n        return self._options"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset and return whether the currently loaded entity is the newest version in the department.", "response": "def fetch_uptodate(self, ):\n        \"\"\"Set and return whether the currently loaded entity is\n        the newest version in the department.\n\n        :returns: True, if newest version. False, if there is a newer version.\n                  None, if there is nothing loaded yet.\n        :rtype: bool | None\n        :raises: None\n        \"\"\"\n        tfi = self.get_taskfileinfo()\n        if tfi:\n            self._uptodate = tfi.is_latest()\n        else:\n            self._uptodate = None\n        return self._uptodate"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch_alien(self, ):\n        parent = self.get_parent()\n        if parent:\n            parentelement = parent.get_element()\n        else:\n            parentelement = self.get_refobjinter().get_current_element()\n            if not parentelement:\n                self._alien = True\n                return self._alien\n        element = self.get_element()\n        if element == parentelement:\n            self._alien = False\n        # test if it is the element is a global shot\n        # first test if we have a shot\n        # then test if it is in a global sequence. then the shot is global too.\n        # test if the parent element is a shot, if they share the sequence, and element is global\n        elif isinstance(element, djadapter.models.Shot)\\\n            and (element.sequence.name == djadapter.GLOBAL_NAME\\\n            or (isinstance(parentelement, djadapter.models.Shot)\\\n                and parentelement.sequence == element.sequence and element.name == djadapter.GLOBAL_NAME)):\n            self._alien = False\n        else:\n            assets = parentelement.assets.all()\n            self._alien = element not in assets\n        return self._alien", "response": "Sets and return if the reftrack element is linked to the current scene."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_refobject(self, ):\n        parent = self.get_parent()\n        if parent:\n            prefobj = parent.get_refobj()\n        else:\n            prefobj = None\n        refobj = self.get_refobjinter().create(self.get_typ(), self.get_id(), prefobj)\n        return refobj", "response": "Create a reftrack object in the scene that represents the reftrack instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreferencing the entity into the scene. Only possible if the current status is None.", "response": "def reference(self, taskfileinfo):\n        \"\"\"Reference the entity into the scene. Only possible if the current status is None.\n\n        This will create a new refobject, then call :meth:`RefobjInterface.reference` and\n        afterwards set the refobj on the :class:`Reftrack` instance.\n\n        :param taskfileinfo: the taskfileinfo to reference\n        :type taskfileinfo: :class:`jukeboxcore.filesys.TaskFileInfo`\n        :returns: None\n        :rtype: None\n        :raises: :class:`ReftrackIntegrityError`\n        \"\"\"\n        assert self.status() is None,\\\n            \"Can only reference, if the entity is not already referenced/imported. Use replace instead.\"\n        refobj = self.create_refobject()\n        with self.set_parent_on_new(refobj):\n            self.get_refobjinter().reference(taskfileinfo, refobj)\n        self.set_refobj(refobj)\n        self.fetch_new_children()\n        self.update_restrictions()\n        self.emit_data_changed()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(self, ):\n        assert self.status() == self.UNLOADED,\\\n            \"Cannot load if there is no unloaded reference. Use reference instead.\"\n        self.get_refobjinter().load(self._refobj)\n        self.set_status(self.LOADED)\n        self.fetch_new_children()\n        self.update_restrictions()\n        self.emit_data_changed()", "response": "Loads the data from the reference."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unload(self, ):\n        assert self.status() == self.LOADED,\\\n            \"Cannot unload if there is no loaded reference. \\\nUse delete if you want to get rid of a reference or import.\"\n        childrentodelete = self.get_children_to_delete()\n        if childrentodelete:\n            raise ReftrackIntegrityError(\"Cannot unload because children of the reference would become orphans.\", childrentodelete)\n        self.get_refobjinter().unload(self._refobj)\n        self.set_status(self.UNLOADED)\n        self.throw_children_away()\n        self.update_restrictions()\n        self.emit_data_changed()", "response": "Unloads the current reftrack."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef import_file(self, taskfileinfo):\n        assert self.status() is None,\\\n            \"Entity is already in scene. Use replace instead.\"\n        refobjinter = self.get_refobjinter()\n        refobj = self.create_refobject()\n        with self.set_parent_on_new(refobj):\n            refobjinter.import_taskfile(refobj, taskfileinfo)\n        self.set_refobj(refobj)\n        self.set_status(self.IMPORTED)\n        self.fetch_new_children()\n        self.update_restrictions()\n        self.emit_data_changed()", "response": "Import the file for the given taskfileinfo into the current reftrack."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nimport the currently loaded reference for this entity.", "response": "def import_reference(self, ):\n        \"\"\"Import the currently loaded reference\n\n        This will also update the status to :data:`Reftrack.IMPORTED`.\n\n        :returns: None\n        :rtype: None\n        :raises: :class:`ReftrackIntegrityError`\n        \"\"\"\n        assert self.status() in (self.LOADED, self.UNLOADED),\\\n            \"There is no reference for this entity.\"\n        refobjinter = self.get_refobjinter()\n        refobjinter.import_reference(self.get_refobj())\n        self.set_status(self.IMPORTED)\n        self.update_restrictions()\n        for c in self.get_all_children():\n            c.update_restrictions()\n        self.emit_data_changed()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreplacing the current reference or imported entity with the given taskfileinfo.", "response": "def replace(self, taskfileinfo):\n        \"\"\"Replace the current reference or imported entity.\n\n        If the given refobj is not replaceable, e.g. it might be imported\n        or it is not possible to switch the data, then the entity will be deleted,\n        then referenced or imported again, depending on the current status.\n\n        A replaced entity might have other children. This introduces a problem:\n\n          A child might get deleted, e.g. an asset which itself has another child,\n          that will not get deleted, e.g. an imported shader. In this case the imported\n          shader will be left as an orphan.\n          This will check all children that will not be deleted (:meth:`Reftrack.get_children_to_delete`)\n          and checks if they are orphans after the replace. If they are, they will get deleted!\n\n        After the replace, all children will be reset. This will simply throw away all children reftracks\n        (the content will not be deleted) and wrap all new children again. See: :meth:`Reftrack.fetch_new_children`.\n\n        :param taskfileinfo: the taskfileinfo that will replace the old entity\n        :type taskfileinfo: :class:`jukeboxcore.filesys.TaskFileInfo`\n        :returns: None\n        :rtype: None\n        :raises: ReftrackIntegrityError\n        \"\"\"\n        assert self.status() is not None,\\\n            \"Can only replace entities that are already in the scene.\"\n        refobjinter = self.get_refobjinter()\n        refobj = self.get_refobj()\n        if self.status() in (self.LOADED, self.UNLOADED) and refobjinter.is_replaceable(refobj):\n            # possible orphans will not get replaced, by replace\n            # but their parent might dissapear in the process\n            possibleorphans = self.get_children_to_delete()\n            with self.set_parent_on_new(refobj):\n                refobjinter.replace(refobj, taskfileinfo)\n            self.set_taskfileinfo(taskfileinfo)\n            self.fetch_uptodate()\n            for o in possibleorphans:\n                # find if orphans were created and delete them\n                # we get the refobj of the parent\n                # if it still exists, it is no orphan\n                parent = o.get_parent()\n                refobj = parent.get_refobj()\n                if not parent.get_refobjinter().exists(refobj):\n                    # orphans will be deleted!\n                    # this is politically incorrect, i know!\n                    # the world of programming is a harsh place.\n                    o.delete()\n            # reset the children\n            # throw them away at first\n            self.throw_children_away()\n            # gather them again\n            self.fetch_new_children()\n        else:\n            status = self.status()\n            self.delete(removealien=False)\n            if status == self.IMPORTED:\n                self.import_file(taskfileinfo)\n            else:\n                self.reference(taskfileinfo)\n        self.update_restrictions()\n        self.emit_data_changed()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete(self, removealien=True):\n        if self.status() is None:\n            parent = self.get_parent()\n            if parent:\n                parent.remove_child(self)\n            self._treeitem.parent().remove_child(self._treeitem)\n            self.get_root().remove_reftrack(self)\n            return\n        todelete = self.get_children_to_delete()\n        allchildren = self.get_all_children()\n        for c in reversed(todelete):\n            c._delete()\n        for c in allchildren:\n            self.get_root().remove_reftrack(c)\n        self._delete()\n        if self.alien() and removealien:\n            self.get_root().remove_reftrack(self)\n        self.update_restrictions()\n        self.emit_data_changed()", "response": "Delete the current reftrack."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _delete(self, ):\n        refobjinter = self.get_refobjinter()\n        refobjinter.delete(self.get_refobj())\n        self.set_refobj(None, setParent=False)\n        if self.alien():\n            # it should not be in the scene\n            # so also remove it from the model\n            # so we cannot load it again\n            parent = self.get_parent()\n            if parent:\n                parent.remove_child(self)\n            self._treeitem.parent().remove_child(self._treeitem)\n        else:\n            # only remove all children from the model and set their parent to None\n            for c in self.get_all_children():\n                c._parent = None\n                self._treeitem.remove_child(c._treeitem)\n        # this should not have any children anymore\n        self._children = []\n        self.set_status(None)", "response": "Internal method to delete a reftrack."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a new reftrack instance that has the same typ element and parent.", "response": "def duplicate(self, ):\n        \"\"\"Return a new :class:`Reftrack` instance that has the same\n        typ, element and parent. The new reference will be not referenced or imported!\n\n        :returns: a new reftrack instance with same typ, element and parent\n        :rtype: :class:`Reftrack`\n        :raises: None\n        \"\"\"\n        return self.__class__(root=self.get_root(),\n                              refobjinter=self.get_refobjinter(),\n                              typ=self.get_typ(),\n                              element=self.get_element(),\n                              parent=self.get_parent())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all children including children of children", "response": "def get_all_children(self):\n        \"\"\"Get all children including children of children\n\n        :returns: all children including children of children\n        :rtype: list of :class:`Reftrack`\n        :raises: None\n        \"\"\"\n        children = self._children[:]\n        oldlen = 0\n        newlen = len(children)\n        while oldlen != newlen:\n            start = oldlen\n            oldlen = len(children)\n            for i in range(start, len(children)):\n                children.extend(children[i]._children)\n            newlen = len(children)\n        return children"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns all children that are not referenced by this reftrack.", "response": "def get_children_to_delete(self):\n        \"\"\"Return all children that are not referenced\n\n        :returns: list or :class:`Reftrack`\n        :rtype: list\n        :raises: None\n        \"\"\"\n        refobjinter = self.get_refobjinter()\n        children = self.get_all_children()\n\n        todelete = []\n        for c in children:\n            if c.status() is None:\n                # if child is not in scene we do not have to delete it\n                continue\n            rby = refobjinter.referenced_by(c.get_refobj())\n            if rby is None:\n                # child is not part of another reference.\n                # we have to delete it for sure\n                todelete.append(c)\n                continue\n            # check if child is referenced by any parent up to self\n            # if it is not referenced by any refrence of a parent, then we\n            # can assume it is referenced by a parent of a greater scope,\n            # e.g. the parent of self. because we do not delete anything above self\n            # we would have to delete the child manually\n            parent = c.get_parent()\n            while parent != self.get_parent():\n                if refobjinter.get_reference(parent.get_refobj()) == rby:\n                    # is referenced by a parent so it will get delted when the parent is deleted.\n                    break\n                parent = parent.get_parent()\n            else:\n                todelete.append(c)\n        return todelete"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch_new_children(self, ):\n        root = self.get_root()\n        refobjinter = self.get_refobjinter()\n        unwrapped = self.get_unwrapped(root, refobjinter)\n        self.wrap(self.get_root(), self.get_refobjinter(), unwrapped)\n\n        suggestions = self.get_suggestions()\n        for typ, element in suggestions:\n            for c in self._children:\n                if typ == c.get_typ() and element == c.get_element():\n                    break\n            else:\n                Reftrack(root=root, refobjinter=refobjinter, typ=typ, element=element, parent=self)", "response": "Collect all new children and add the suggestions to the children as well\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef throw_children_away(self, ):\n        for c in self._children:\n            c._parent = None\n            self._treeitem.remove_child(c._treeitem)\n        for c in self.get_all_children():\n            self.get_root().remove_reftrack(c)\n        self._children = []", "response": "Removes all children from the treeitem and all children of the treeitem."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_parent_on_new(self, parentrefobj):\n        refobjinter = self.get_refobjinter()\n        # to make sure we only get the new one\n        # we get all current unwrapped first\n        old = self.get_unwrapped(self.get_root(), refobjinter)\n        yield\n        new = self.get_unwrapped(self.get_root(), refobjinter) - old\n        for refobj in new:\n            if refobjinter.get_parent(refobj) is None:\n                refobjinter.set_parent(refobj, parentrefobj)", "response": "Contextmanager that will get all unwrapped refobjects and set the parent to the given one."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the restricted flag on the given object.", "response": "def set_restricted(self, obj, restricted):\n        \"\"\"Set the restriction on the given object.\n\n        You can use this to signal that a certain function is restricted.\n        Then you can query the restriction later with :meth:`Reftrack.is_restricted`.\n\n        :param obj: a hashable object\n        :param restricted: True, if you want to restrict the object.\n        :type restricted: :class:`bool`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if restricted:\n            self._restricted.add(obj)\n        elif obj in self._restricted:\n            self._restricted.remove(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the restricted attributes of the common : class : Reftrack actions.", "response": "def update_restrictions(self, ):\n        \"\"\"Update all restrictions for the common :class:`Reftrack` actions.\n\n        Update restrictions for:\n\n          * :meth:`Reftrack.reference`\n          * :meth:`Reftrack.load`\n          * :meth:`Reftrack.unload`\n          * :meth:`Reftrack.import_reference`\n          * :meth:`Reftrack.import_file`\n          * :meth:`Reftrack.replace`\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.set_restricted(self.reference, self.fetch_reference_restriction())\n        self.set_restricted(self.load, self.fetch_load_restriction())\n        self.set_restricted(self.unload, self.fetch_unload_restriction())\n        self.set_restricted(self.import_reference, self.fetch_import_ref_restriction())\n        self.set_restricted(self.import_file, self.fetch_import_f_restriction())\n        self.set_restricted(self.replace, self.fetch_replace_restriction())\n        self.set_restricted(self.delete, self.fetch_delete_restriction())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch_reference_restriction(self, ):\n        inter = self.get_refobjinter()\n        restricted = self.status() is not None\n        return restricted or inter.fetch_action_restriction(self, 'reference')", "response": "Fetch whether referencing is restricted by the current user."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fetch_load_restriction(self, ):\n        inter = self.get_refobjinter()\n        restricted = self.status() != self.UNLOADED\n        return restricted or inter.fetch_action_restriction(self, 'load')", "response": "Fetch whether loading is restricted by the current object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fetch_unload_restriction(self, ):\n        inter = self.get_refobjinter()\n        restricted = self.status() != self.LOADED or self.get_children_to_delete()\n        return restricted or inter.fetch_action_restriction(self, 'unload')", "response": "Fetch whether unloading is restricted"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch_import_ref_restriction(self,):\n        inter = self.get_refobjinter()\n        restricted = self.status() not in (self.LOADED, self.UNLOADED)\n        return restricted or inter.fetch_action_restriction(self, 'import_reference')", "response": "Fetch whether importing the reference is restricted by the current user."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetch_import_f_restriction(self,):\n        inter = self.get_refobjinter()\n        restricted = self.status() is not None\n        return restricted or inter.fetch_action_restriction(self, 'import_taskfile')", "response": "Fetch whether importing a file is restricted by the current user."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch_replace_restriction(self, ):\n        inter = self.get_refobjinter()\n        restricted = self.status() is None\n        return restricted or inter.fetch_action_restriction(self, 'replace')", "response": "Fetch whether unloading is restricted\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef emit_data_changed(self):\n        item = self.get_treeitem()\n        m = item.get_model()\n        if m:\n            start = m.index_of_item(item)\n            parent = start.parent()\n            end = m.index(start.row(), item.column_count()-1, parent)\n            m.dataChanged.emit(start, end)", "response": "Emits the data changed signal on the model of the treeitem."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of additional actions that can be used for the menu entry of the reftrack.", "response": "def get_additional_actions(self,):\n        \"\"\"Return a list of additional actions you want to provide for the menu\n        of the reftrack.\n\n        E.e. you want to have a menu entry, that will select the entity in your programm.\n\n        This will call :meth:`RefobjInterface.get_additional_actions`.\n\n        The base implementation returns an empty list.\n\n        :returns: A list of :class:`ReftrackAction`\n        :rtype: list\n        :raises: None\n        \"\"\"\n        if self.get_typ():\n            inter = self.get_refobjinter()\n            return inter.get_additional_actions(self)\n        else:\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new refobj with the given typ and identifier.", "response": "def create(self, typ, identifier, parent=None):\n        \"\"\"Create a new refobj with the given typ and parent\n\n        :param typ: the entity type\n        :type typ: str\n        :param identifier: the refobj id. Used to identify refobjects of the same parent, element and type in the UI\n        :type identifier: int\n        :param parent: the parent refobject\n        :type parent: refobj\n        :returns: The created refobj\n        :rtype: refobj\n        :raises: None\n        \"\"\"\n        refobj = self.create_refobj()\n        self.set_typ(refobj, typ)\n        self.set_id(refobj, identifier)\n        if parent:\n            self.set_parent(refobj, parent)\n        return refobj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting the given refobj and the contents of the entity", "response": "def delete(self, refobj):\n        \"\"\"Delete the given refobj and the contents of the entity\n\n        :param refobj: the refobj to delete\n        :type refobj: refobj\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        i = self.get_typ_interface(self.get_typ(refobj))\n        i.delete(refobj)\n        self.delete_refobj(refobj)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreference the given taskfileinfo and set the created reference on the refobj", "response": "def reference(self, taskfileinfo, refobj):\n        \"\"\"Reference the given taskfile info and\n        set the created reference on the refobj\n\n        This will call :meth:`ReftypeInterface.reference`, then :meth:`ReftypeInterface.set_reference`.\n\n        :param taskfileinfo: The taskfileinfo that holds the information for what to reference\n        :type taskfileinfo: :class:`jukeboxcore.filesys.TaskFileInfo`\n        :param refobj: the refobj that should represent the new reference\n        :type refobj: refobj\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        inter = self.get_typ_interface(self.get_typ(refobj))\n        ref = inter.reference(refobj, taskfileinfo)\n        self.set_reference(refobj, ref)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(self, refobj):\n        inter = self.get_typ_interface(self.get_typ(refobj))\n        ref = self.get_reference(refobj)\n        inter.load(refobj, ref)", "response": "Load the given refobject\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unload(self, refobj):\n        inter = self.get_typ_interface(self.get_typ(refobj))\n        ref = self.get_reference(refobj)\n        inter.unload(refobj, ref)", "response": "Unloads the given refobject\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef replace(self, refobj, taskfileinfo):\n        inter = self.get_typ_interface(self.get_typ(refobj))\n        ref = self.get_reference(refobj)\n        inter.replace(refobj, ref, taskfileinfo)", "response": "Replace the given refobjs reference with the taskfileinfo that will replace the old entity\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn whether the given reference of the refobject is replaceable or not.", "response": "def is_replaceable(self, refobj):\n        \"\"\"Return whether the given reference of the refobject is replaceable or\n        if it should just get deleted and loaded again.\n\n        This will call :meth:`ReftypeInterface.is_replaceable`.\n\n        :param refobj: the refobject to query\n        :type refobj: refobj\n        :returns: True, if replaceable\n        :rtype: bool\n        :raises: None\n        \"\"\"\n        inter = self.get_typ_interface(self.get_typ(refobj))\n        return inter.is_replaceable(refobj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nimporting the reference of the given refobj into the current scene and store the result in the reference cache", "response": "def import_reference(self, refobj):\n        \"\"\"Import the reference of the given refobj\n\n        Here we assume, that the reference is already in the scene and\n        we break the encapsulation and pull the data from the reference into\n        the current scene.\n        This will call :meth:`ReftypeInterface.import_reference` and set the\n        reference on the refobj to None.\n\n        :param refobj: the refobj with a reference\n        :type refobj: refobj\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        inter = self.get_typ_interface(self.get_typ(refobj))\n        ref = self.get_reference(refobj)\n        inter.import_reference(refobj, ref)\n        self.set_reference(refobj, None)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_taskfile(self, refobj, taskfileinfo):\n        inter = self.get_typ_interface(self.get_typ(refobj))\n        inter.import_taskfile(refobj, taskfileinfo)", "response": "Import the given taskfileinfo and update the refobj\n        property"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the : class : TaskFileInfo that is loaded by the refobj", "response": "def get_taskfileinfo(self, refobj):\n        \"\"\"Return the :class:`jukeboxcore.filesys.TaskFileInfo` that is loaded\n        by the refobj\n\n        :param refobj: the refobject to query\n        :type refobj: refobj\n        :returns: the taskfileinfo that is loaded in the scene\n        :rtype: :class:`jukeboxcore.filesys.TaskFileInfo`\n        :raises: None\n        \"\"\"\n        tf = self.get_taskfile(refobj)\n        return TaskFileInfo.create_from_taskfile(tf)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_element(self, refobj):\n        tf = self.get_taskfile(refobj)\n        return tf.task.element", "response": "Return the element the reftrack represents."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fetch_options(self, typ, element):\n        inter = self.get_typ_interface(typ)\n        return inter.fetch_options(element)", "response": "Fetch the options for possible files to\n        load replace etc for the given element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch_option_taskfileinfos(self, typ, element):\n        inter = self.get_typ_interface(typ)\n        return inter.fetch_option_taskfileinfos(element)", "response": "Fetch the options for possible files to load replace etc for the given element."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_option_labels(self, typ, element):\n        inter = self.get_typ_interface(typ)\n        return inter.get_option_labels(element)", "response": "Return the labels for each level of the option model."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the column of the model to show for each level", "response": "def get_option_columns(self, typ, element):\n        \"\"\"Return the column of the model to show for each level\n\n        Because each level might be displayed in a combobox. So you might want to provide the column\n        to show.\n\n        :param typ: the typ of options. E.g. Asset, Alembic, Camera etc\n        :type typ: str\n        :param element: The element for wich the options should be fetched.\n        :type element: :class:`jukeboxcore.djadapter.models.Asset` | :class:`jukeboxcore.djadapter.models.Shot`\n        :returns: a list of columns\n        :rtype: list\n        :raises: None\n        \"\"\"\n        inter = self.get_typ_interface(typ)\n        return inter.get_option_columns(element)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of possible children for this reftrack.", "response": "def get_suggestions(self, reftrack):\n        \"\"\"Return a list with possible children for this reftrack\n\n        Each Reftrack may want different children. E.g. a Asset wants\n        to suggest a shader for itself and all assets that are linked in\n        to it in the database. Suggestions only apply for enities with status\n        other than None.\n\n        A suggestion is a tuple of typ and element. It will be used to create a newlen\n        :class:`Reftrack`. The parent will be this instance, root and interface will\n        of course be the same.\n\n        This will delegate the call to the  appropriate :class:`ReftypeInterface`.\n        So suggestions may vary for every typ and might depend on the\n        status of the reftrack.\n\n        :param reftrack: the reftrack which needs suggestions\n        :type reftrack: :class:`Reftrack`\n        :returns: list of suggestions, tuples of type and element.\n        :rtype: list\n        :raises: None\n        \"\"\"\n        inter = self.get_typ_interface(reftrack.get_typ())\n        return inter.get_suggestions(reftrack)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfetching wheter the given action is restricted for the given reftrack.", "response": "def fetch_action_restriction(self, reftrack, action):\n        \"\"\"Return wheter the given action is restricted for the given reftrack\n\n        available actions are:\n\n           ``reference``, ``load``, ``unload``, ``replace``, ``import_reference``, ``import_taskfile``, ``delete``\n\n        If action is not available, True is returned.\n\n        :param reftrack: the reftrack to query\n        :type reftrack: :class:`Reftrack`\n        :param action: the action to check.\n        :type action: str\n        :returns: True, if the action is restricted\n        :rtype: :class:`bool`\n        :raises: None\n        \"\"\"\n        inter = self.get_typ_interface(reftrack.get_typ())\n        d = {'reference': inter.is_reference_restricted, 'load': inter.is_load_restricted,\n             'unload': inter.is_unload_restricted, 'replace': inter.is_replace_restricted,\n             'import_reference': inter.is_import_ref_restricted, 'import_taskfile': inter.is_import_f_restricted,\n             'delete': inter.is_delete_restricted,}\n        f = d.get(action, None)\n        if not f:\n            return True\n        else:\n            return f(reftrack)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of additional actions that you want to provide for the menu of the reftrack.", "response": "def get_additional_actions(self, reftrack):\n        \"\"\"Return a list of additional actions you want to provide for the menu\n        of the reftrack.\n\n        E.e. you want to have a menu entry, that will select the entity in your programm.\n\n        This will call :meth:`ReftypeInterface.get_additional_actions`.\n\n        The base implementation returns an empty list.\n\n        :param reftrack: the reftrack to return the actions for\n        :type reftrack: :class:`Reftrack`\n        :returns: A list of :class:`ReftrackAction`\n        :rtype: list\n        :raises: None\n        \"\"\"\n        inter = self.get_typ_interface(reftrack.get_typ())\n        return inter.get_additional_actions(reftrack)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of types that can be used in combination with the given element.", "response": "def get_available_types_for_scene(self, element):\n        \"\"\"Return a list of types that can be used in combination with the given element\n        to add new reftracks to the scene.\n\n        This allows for example the user, to add new reftracks (aliens) to the scene.\n        So e.g. for a shader, it wouldn't make sense to make it available to be added to the scene, because\n        one would use them only as children of let's say an asset or cache.\n        Some types might only be available for shots or assets etc.\n\n        :param element: the element that could be used in conjuction with the returned types to create new reftracks.\n        :type element: :class:`jukeboxcore.djadapter.models.Asset` | :class:`jukeboxcore.djadapter.models.Shot`\n        :returns: a list of types\n        :rtype: :class:`list`\n        :raises: None\n        \"\"\"\n        available = []\n        for typ, inter in self.types.items():\n            if inter(self).is_available_for_scene(element):\n                available.append(typ)\n        return available"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch_options(self, element):\n        tfis = self.fetch_option_taskfileinfos(element)\n        return self.create_options_model(tfis), tfis", "response": "Fetch the options for possible files to load replace etc for the given element."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reinstantiate_endpoints(self, endpoint=None):\n        endpoint = endpoint or self\n        for k, v in endpoint.__class__.__dict__.items():\n            if isinstance(v, Endpoint):\n                setattr(endpoint, k, v.__class__(self))\n            elif inspect.isclass(v) and issubclass(v, Endpoint):\n                setattr(endpoint, k, v(self))", "response": "This will re - instantiate the endpoints with the connection this time\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _post_process_call(self, api_call, data, method_return_types):\n        if self.wrap_return_data:\n            data = rep(data, **method_return_types)\n            # this will make it have a nice pretty repr & str\n\n        if self.max_history:\n            api_call.save_formatted_data(data)\n        return data", "response": "This will wrap the object in thin representational object\n        and save the formatted object if necessary"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a function that can be used to create a new object.", "response": "def function(fname):\n    \"\"\"\n    Make a function to Function class\n    \"\"\"\n    def _f(func):\n        class WrapFunction(Function):\n            name = fname\n\n            def __call__(self, *args, **kwargs):\n                return func(*args, **kwargs)\n\n        return WrapFunction\n\n    return _f"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unquote_header_value(value):\n    if value and value[0] == value[-1] == '\"':\n        # this is not the real unquoting, but fixing this so that the\n        # RFC is met will result in bugs with internet explorer and\n        # probably some other browsers as well.  IE for example is\n        # uploading files with \"C:\\foo\\bar.txt\" as filename\n        value = value[1:-1].replace('\\\\\\\\', '\\\\').replace('\\\\\"', '\"')\n    return value", "response": "Unquotes a header value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_cookie(header, charset='utf-8', errors='ignore'):\n    cookie = _ExtendedCookie()\n    if header:\n        cookie.load(header)\n    result = {}\n\n    # decode to unicode and skip broken items.  Our extended morsel\n    # and extended cookie will catch CookieErrors and convert them to\n    # `None` items which we have to skip here.\n    for key, value in cookie.iteritems():\n        if value.value is not None:\n            result[key] = unquote_header_value(value.value) \\\n                .decode(charset, errors)\n\n    return result", "response": "Parse a cookie.\n\n    :param header: the header to be used to parse the cookie.\n    :param charset: the charset for the cookie values.\n    :param errors: the error behavior for the charset decoding."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisplaying the data of the given index.", "response": "def set_index(self, index):\n        \"\"\"Display the data of the given index\n\n        :param index: the index to paint\n        :type index: QtCore.QModelIndex\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        item = index.internalPointer()\n        note = item.internal_data()\n        self.content_lb.setText(note.content)\n        self.created_dte.setDateTime(dt_to_qdatetime(note.date_created))\n        self.updated_dte.setDateTime(dt_to_qdatetime(note.date_updated))\n        self.username_lb.setText(note.user.username)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef equals_as(self, value_type, other):\n        if other == None and self.value == None:\n            return True\n        if other == None or self.value == None:\n            return False\n\n        if isinstance(other, AnyValue):\n            other = other._value\n\n        if other == self.value:\n            return True\n        \n        value1 = TypeConverter.to_type(value_type, self.value)\n        value2 = TypeConverter.to_type(value_type, other)\n\n        if value1 == None or value2 == None:\n            return False\n\n        return value1 == value2", "response": "Compares this object value to specified value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding images outside the source directory copy them into the source directory and replace the paths in the source directory with the new ones.", "response": "def _collect_images(self, content: str, md_file_path: Path) -> str:\n        '''Find images outside the source directory, copy them into the source directory,\n        and replace the paths in the source.\n\n        This is necessary because MkDocs can't deal with images outside the project's doc_dir.\n\n        :param content: Markdown content\n        :param md_file_path: Path to the Markdown file with content ``content``\n\n        :returns: Markdown content with image paths pointing within the source directory\n        '''\n\n        self.logger.debug(f'Looking for images in {md_file_path}.')\n\n        def _sub(image):\n            image_caption = image.group('caption')\n            image_path = (md_file_path.parent / Path(image.group('path'))).resolve()\n\n            self.logger.debug(f'Detected image: caption=\"{image_caption}\", path={image_path}')\n\n            if self.working_dir.resolve() not in image_path.parents:\n                self.logger.debug('Image outside source directory.')\n\n                self._collected_imgs_path.mkdir(exist_ok=True)\n\n                collected_img_path = (\n                    self._collected_imgs_path/f'{image_path.stem}_{str(uuid1())}'\n                ).with_suffix(image_path.suffix)\n\n                copy(image_path, collected_img_path)\n\n                self.logger.debug(f'Image copied to {collected_img_path}')\n\n                rel_img_path = Path(relpath(collected_img_path, md_file_path.parent)).as_posix()\n\n            else:\n                self.logger.debug('Image inside source directory.')\n                rel_img_path = Path(relpath(image_path, md_file_path.parent)).as_posix()\n\n            img_ref = f'![{image_caption}]({rel_img_path})'\n\n            self.logger.debug(f'Replacing with: {img_ref}')\n\n            return img_ref\n\n        return self._image_pattern.sub(_sub, content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates all the properties that are not already set.", "response": "def __create_log_props(cls, log_props, _getdict, _setdict):  # @NoSelf\n        \"\"\"Creates all the logical property.\n\n        The list of names of properties to be created is passed\n        with frozenset log_props. The getter/setter information is\n        taken from _{get,set}dict.\n\n        This method resolves also wildcards in names, and performs\n        all checks to ensure correctness.\n\n        Returns the frozen set of the actually created properties\n        (as not log_props may be really created, e.g. when no\n        getter is provided, and a warning is issued).\n        \"\"\"\n\n        real_log_props = set()\n        resolved_getdict = {}\n        resolved_setdict = {}\n\n        for _dict_name, _dict, _resolved_dict in (\n                                      (\"getter\", _getdict, resolved_getdict),\n                                      (\"setter\", _setdict, resolved_setdict)):\n            # first resolve all wildcards\n            for pat, ai in ((pat, ai)\n                            for pat, ai in _dict.items()\n                            if frozenset(pat) & WILDCARDS):\n                matches = fnmatch.filter(log_props, pat)\n                for match in matches:\n                    if match in _resolved_dict:\n                        raise NameError(\"In class %s.%s %s property '%s' \"\n                                        \"is matched multiple times\"\n                                        \" by patterns\" % \\\n                            (cls.__module__, cls.__name__, _dict_name, match))\n                    _resolved_dict[match] = ai\n\n                if not matches:\n                    logger.warning(\"In class %s.%s %s pattern '%s' \"\n                                   \"did not match any existing \"\n                                   \"logical property\",\n                                   cls.__module__, cls.__name__, _dict_name, pat)\n\n            # now adds the exact matches (no wilcards) which override\n            # the pattern-matches\n            _resolved_dict.update((name, ai)\n                                  for name, ai in _dict.items()\n                                  if name in log_props)\n\n            # checks that all getter/setter have a corresponding logical\n            # property\n            not_found = [name for name in _resolved_dict\n                         if name not in log_props]\n\n            if not_found:\n                logger.warning(\"In class %s.%s logical %s were declared for \"\n                               \"non-existent observables: %s\",\n                               cls.__module__, cls.__name__, _dict_name,\n                               str(not_found))\n\n        # creates the properties\n        for name in log_props:\n            # finds the getter\n            ai_get = resolved_getdict.get(name, None)\n            if ai_get:\n                # decorator-based\n                _getter = type(cls).get_getter(cls, name, ai_get.func,\n                                               ai_get.has_args)\n                _deps = ai_get.deps\n            else:\n                # old style\n                _getter = type(cls).get_getter(cls, name)\n                if _getter is None:\n                    raise RuntimeError(\"In class %s.%s \"\n                                       \"logical observable '%s' \"\n                                        \"has no getter method\" % \\\n                                  (cls.__module__, cls.__name__, name))\n                _deps = type(cls)._get_old_style_getter_deps(cls, name,\n                                                             _getter)\n\n            # finds the setter\n            ai_set = resolved_setdict.get(name, None)\n            if ai_set:\n                # decorator-based\n                if ai_get:\n                    _setter = type(cls).get_setter(cls, name,\n                                                ai_set.func, ai_set.has_args,\n                                                ai_get.func, ai_get.has_args)\n                else:\n                    # the getter is old style. _getter is already\n                    # resolved wrt the name it may take, so\n                    # getter_takes_name is False\n                    _setter = type(cls).get_setter(cls, name,\n                                               ai_set.func, ai_set.has_args,\n                                               _getter, False)\n            else:\n                # old style setter\n                if ai_get:\n                    _setter = type(cls).get_setter(cls, name,\n                                                   None, None,\n                                                   ai_get.func,\n                                                   ai_get.has_args)\n                else:\n                    _setter = type(cls).get_setter(cls, name)\n\n            # creates the logical property, here _setter can be None\n            prop = PropertyMeta.LogicalOP(_getter, _setter, frozenset(_deps))\n            setattr(cls, name, prop)\n            real_log_props.add(name)\n\n        # checks that all setters have a getter\n        setters_no_getters = (set(resolved_setdict) - real_log_props) & \\\n                                log_props\n        if setters_no_getters:\n            logger.warning(\"In class %s.%s logical setters have no \"\n                           \"getters: %s\",\n                           cls.__module__, cls.__name__,\n                           \", \".join(setters_no_getters))\n\n        return frozenset(real_log_props)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_old_style_getter_deps(cls, prop_name, _getter):  # @NoSelf\n        args, _, _, defaults = inspect.getargspec(_getter)\n\n        try:\n            idx = args.index(KWARG_NAME_DEPS) - (len(args) - len(defaults))\n            # finds the corresponding value\n            if idx < 0:\n                raise ValueError(\"In class %s.%s logical OP getter '%s'\"\n                                 \"must have a default value set for \"\n                                 \"argument '%s'\" % \\\n                                 (cls.__module__, cls.__name__,\n                                  _getter.__name__, KWARG_NAME_DEPS))\n            _deps = defaults[idx]\n            # checks types\n            if not hasattr(_deps, '__iter__'):\n                raise TypeError(\"In logical OP getter %s.%s.%s \"\n                                \"default value of argument '%s' \"\n                                \"must be an iterable\" % \\\n                                (cls.__module__, cls.__name__,\n                                 _getter.__name__, KWARG_NAME_DEPS))\n\n            for dep in _deps:\n                if not isinstance(dep, str):\n                    raise TypeError(\"In logical OP getter %s.%s.%s \"\n                                    \"values of argument '%s' \"\n                                    \"must be strings\" % \\\n                                    (cls.__module__, cls.__name__,\n                                     _getter.__name__,\n                                     KWARG_NAME_DEPS))\n        except ValueError:\n            _deps = ()\n\n        return _deps", "response": "Checks if deps were given with argument deps and returns the value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef has_prop_attribute(cls, prop_name):  # @NoSelf\n        return (prop_name in cls.__dict__ and\n                not isinstance(cls.__dict__[prop_name], types.FunctionType))", "response": "This methods returns True if there exists a class attribute\n        for the given property."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_value_change(cls, old, new):  # @NoSelf\n        return (type(old) != type(new) or\n                isinstance(old, wrappers.ObsWrapperBase) and old != new)", "response": "Checks whether the value of the property changed in type\n        or instance\n        has been changed to a different instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_value(cls, prop_name, val, model=None):  # @NoSelf\n\n        if isinstance(val, tuple):\n            # this might be a class instance to be wrapped\n            # (thanks to Tobias Weber for\n            # providing a bug fix to avoid TypeError (in 1.99.1)\n            if len(val) == 3:\n                try:\n                    wrap_instance = isinstance(val[1], val[0]) and \\\n                        (isinstance(val[2], tuple) or\n                         isinstance(val[2], list))\n                except TypeError:\n                    pass  # not recognized, it must be another type of tuple\n                else:\n                    if wrap_instance:\n                        res = wrappers.ObsUserClassWrapper(val[1], val[2])\n                        if model:\n                            res.__add_model__(model, prop_name)\n                        return res\n\n        elif isinstance(val, list):\n            res = wrappers.ObsListWrapper(val)\n            if model:\n                res.__add_model__(model, prop_name)\n            return res\n\n        elif isinstance(val, set):\n            res = wrappers.ObsSetWrapper(val)\n            if model:\n                res.__add_model__(model, prop_name)\n            return res\n\n        elif isinstance(val, dict):\n            res = wrappers.ObsMapWrapper(val)\n            if model:\n                res.__add_model__(model, prop_name)\n            return res\n\n        return val", "response": "This function creates a value for a specific property in a Tobias Weber object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_getter(cls, prop_name,  # @NoSelf\n                   user_getter=None, getter_takes_name=False):\n        \"\"\"Returns a function wich is a getter for a property.\n        prop_name is the name off the property.\n\n        user_getter is an optional function doing the work. If\n        specified, that function will be called instead of getting\n        the attribute whose name is in 'prop_name'.\n\n        If user_getter is specified with a False value for\n        getter_takes_name (default), than the method is used to get\n        the value of the property. If True is specified for\n        getter_takes_name, then the user_getter is called by\n        passing the property name (i.e. it is considered a general\n        method which receive the property name whose value has to\n        be returned.)\n        \"\"\"\n        if user_getter:\n            if getter_takes_name:  # wraps the property name\n                _deps = type(cls)._get_old_style_getter_deps(cls, prop_name,\n                                                             user_getter)\n\n                def _getter(self, deps=_deps):\n                    return user_getter(self, prop_name)\n            else:\n                _getter = user_getter\n            return _getter\n\n        def _getter(self):  # @DuplicatedSignature\n            return getattr(self, PROP_NAME % {'prop_name' : prop_name})\n        return _getter", "response": "Returns a function wich is a getter for a property."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a setter function for setting the value of the given property.", "response": "def get_setter(cls, prop_name,   # @NoSelf\n                   user_setter=None, setter_takes_name=False,\n                   user_getter=None, getter_takes_name=False):\n        \"\"\"Similar to get_getter, but for setting property\n        values. If user_getter is specified, that it may be used to\n        get the old value of the property before setting it (this\n        is the case in some derived classes' implementation). if\n        getter_takes_name is True and user_getter is not None, than\n        the property name is passed to the given getter to retrieve\n        the property value.\"\"\"\n\n        if user_setter:\n            if setter_takes_name:\n                # wraps the property name\n                def _setter(self, val):\n                    return user_setter(self, prop_name, val)\n            else: _setter = user_setter\n            return _setter\n\n        def _setter(self, val):  # @DuplicatedSignature\n            setattr(self, PROP_NAME % {'prop_name' : prop_name}, val)\n            return\n        return _setter"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the setter function for the given property name.", "response": "def get_setter(cls, prop_name,  # @NoSelf\n                   user_setter=None, setter_takes_name=False,\n                   user_getter=None, getter_takes_name=False):\n        \"\"\"The setter follows the rules of the getter. First search\n          for property variable, then logical custom setter. If no setter\n          is found, None is returned (i.e. the property is read-only.)\"\"\"\n\n        has_prop_variable = cls.has_prop_attribute(prop_name)\n\n        # WARNING! These are deprecated\n        has_specific_setter = hasattr(cls, SET_PROP_NAME % \\\n                                      {'prop_name' : prop_name})\n        has_general_setter = hasattr(cls, SET_GENERIC_NAME)\n\n        if not (has_prop_variable or\n                has_specific_setter or\n                has_general_setter or\n                user_setter):\n            return None\n\n        if has_prop_variable:\n            if has_specific_setter or user_setter:\n                logger.warning(\"In class %s.%s ignoring custom logical \"\n                               \"setter for property '%s' as a \"\n                               \"corresponding attribute exists\" % \\\n                               (cls.__module__, cls.__name__, prop_name))\n\n            user_setter = user_getter = None\n            setter_takes_name = getter_takes_name = False\n        else:\n            if user_setter:\n                pass\n            else:\n                if has_specific_setter:\n                    def __setter(self, val):\n                        _setter = getattr(self, SET_PROP_NAME % \\\n                                          {'prop_name' : prop_name})\n                        _setter(val)\n                        return\n                    user_setter = __setter\n                    #user_setter = getattr(cls, SET_PROP_NAME % \\\n                    #                     {'prop_name' : prop_name})\n                    setter_takes_name = False\n                else:\n                    assert has_general_setter\n\n                    def __setter(self, name, val):\n                        _setter = getattr(self, SET_GENERIC_NAME)\n                        _setter(name, val)\n                        return\n                    user_setter = __setter\n                    #user_setter = getattr(cls, SET_GENERIC_NAME)\n                    setter_takes_name = True\n\n        # the final setter is a combination of a basic setter, and\n        # the getter (see how inner_{getter,setter} are used in\n        # _setter below)\n        _inner_setter = PropertyMeta.get_setter(cls, prop_name,\n                                        user_setter, setter_takes_name,\n                                        user_getter, getter_takes_name)\n\n        _inner_getter = type(cls).get_getter(cls, prop_name,\n                                             user_getter, getter_takes_name)\n\n        def _setter(self, val):\n            curr_frame = len(self._notify_stack)\n            if prop_name not in self._notify_stack:\n                self._notify_stack.append(prop_name)\n\n            old = _inner_getter(self)\n            new = type(self).create_value(prop_name, val, self)\n\n            # to track dependencies\n            olds = self.__before_property_value_change__(prop_name) if \\\n                self._has_observer() else ()\n            self._notify_stack.extend(\n                            map(operator.itemgetter(1), olds))\n\n            # this is the unique place where the value is set:\n            _inner_setter(self, new)\n\n            if type(self).check_value_change(old, new):\n                self._reset_property_notification(prop_name, old)\n\n            self.notify_property_value_change(prop_name, old, val)\n\n            # to notify dependencies\n            self.__after_property_value_change__(prop_name, olds)\n\n            del self._notify_stack[curr_frame:]\n        return _setter"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_setter(cls, prop_name,  # @NoSelf\n                   user_setter=None, setter_takes_name=False,\n                   user_getter=None, getter_takes_name=False):\n        \"\"\"The setter follows the rules of the getter. First search\n          for property variable, then logical custom getter/setter pair\n          methods\"\"\"\n\n        _inner_setter = ObservablePropertyMeta.get_setter(cls, prop_name,\n                                            user_setter, setter_takes_name,\n                                            user_getter, getter_takes_name)\n\n        def _setter(self, val):\n            self._prop_lock.acquire()\n            _inner_setter(self, val)\n            self._prop_lock.release()\n        return _setter", "response": "Returns a function that can be used to set the value of a property in the class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef coneSearch(self, center, radius=3*u.arcmin, magnitudelimit=25):\n        '''\n        Run a cone search of the GALEX archive\n        '''\n\n\n        self.magnitudelimit = magnitudelimit\n\n        # run the query\n        self.speak('querying GALEX, centered on {} with radius {}'.format(center, radius, magnitudelimit))\n\n        coordinatetosearch = '{0.ra.deg} {0.dec.deg}'.format(center)\n        table = astroquery.mast.Catalogs.query_region(coordinates=center, radius=radius, catalog='GALEX')\n\n\n\n        # the gaia DR2 epoch is 2015.5\n        epoch = 2005#???\n\n        # create skycoord objects\n        self.coordinates = coord.SkyCoord(  ra=table['ra'].data*u.deg,\n                                        dec=table['dec'].data*u.deg,\n                                        obstime=Time(epoch, format='decimalyear'))\n\n        self.magnitudes = dict(NUV=table['nuv_mag'].data, FUV=table['fuv_mag'].data)\n        self.magnitude = self.magnitudes['NUV']", "response": "Run a cone search of the GALEX archive containing the GALEX coordinates and the magnetic nuptuals."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns a cone search of the Gaia DR2.", "response": "def coneSearch(self, center, radius=3*u.arcmin, magnitudelimit=20):\n        '''\n        Run a cone search of the Gaia DR2.\n        '''\n\n\n        self.magnitudelimit = magnitudelimit\n\n        # define a query for cone search surrounding this center\n        conequery = \"\"\"SELECT designation, ra, dec, j_m, h_m, ks_m, j_date FROM gaiadr1.tmass_original_valid WHERE CONTAINS(POINT('ICRS',ra,dec),CIRCLE('ICRS',{},{},{}))=1 and j_m < {}\"\"\".format(center.ra.deg, center.dec.deg, radius.to(u.deg).value, magnitudelimit)\n\n\n        # run the query\n        self.speak('querying 2MASS, centered on {} with radius {}, for J<{}'.format(center, radius, magnitudelimit))\n        table = self.query(conequery)\n\n\n\n\n        # create skycoord objects\n        self.coordinates = coord.SkyCoord(  ra=table['ra'].data*u.deg,\n                                        dec=table['dec'].data*u.deg,\n                                        obstime=Time(table['j_date'].data, format='jd'))\n\n        self.magnitudes = dict(         J=table['j_m'].data,\n                                        H=table['h_m'].data,\n                                        Ks=table['ks_m'].data)\n        self.magnitude = self.magnitudes['J']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupload Nginx site configuration from a template.", "response": "def upload_nginx_site_conf(site_name, template_name=None, context=None, enable=True):\n    \"\"\"Upload Nginx site configuration from a template.\"\"\"\n    \n    template_name = template_name or [u'nginx/%s.conf' % site_name, u'nginx/site.conf']\n    site_available = u'/etc/nginx/sites-available/%s' % site_name\n    upload_template(template_name, site_available, context=context, use_sudo=True)\n    if enable:\n        enable_site(site_name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nenables an available Nginx site.", "response": "def enable_site(site_name):\n    \"\"\"Enable an available Nginx site.\"\"\"\n\n    site_available = u'/etc/nginx/sites-available/%s' % site_name\n    site_enabled = u'/etc/nginx/sites-enabled/%s' % site_name\n    if files.exists(site_available):\n        sudo(u'ln -s -f %s %s' % (site_available, site_enabled))\n        restart_service(u'nginx')\n    else:\n        abort(u'%s site configuration is not available' % site_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndisable Nginx site configuration.", "response": "def disable_site(site_name):\n    \"\"\"Disables Nginx site configuration.\"\"\"\n\n    site = u'/etc/nginx/sites-enabled/%s' % site_name\n    if files.exists(site):\n        sudo(u'rm %s' % site)\n        restart_service(u'nginx')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisabling console output during the method is run.", "response": "def suppressConsoleOut(meth):\n    \"\"\"Disable console output during the method is run.\"\"\"\n    @wraps(meth)\n    def decorate(*args, **kwargs):\n        \"\"\"Decorate\"\"\"\n        # Disable ansible console output\n        _stdout = sys.stdout\n        fptr = open(os.devnull, 'w')\n        sys.stdout = fptr\n        try:\n            return meth(*args, **kwargs)\n        except Exception as e:\n            raise e\n        finally:\n            # Enable console output\n            sys.stdout = _stdout\n    return decorate"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mount(cls, mount_point, lower_dir, upper_dir, mount_table=None):\n        ensure_directories(mount_point, lower_dir, upper_dir)\n        # Load the mount table if it isn't given\n        if not mount_table:\n            mount_table = MountTable.load()\n        # Check if the mount_point is in use\n        if mount_table.is_mounted(mount_point):\n            # Throw an error if it is\n            raise AlreadyMounted()\n        # Build mount options\n        options = \"rw,lowerdir=%s,upperdir=%s\" % (lower_dir, upper_dir)\n        # Run the actual mount\n        subwrap.run(['mount', '-t', 'overlayfs', '-o', options,\n            'olyfs%s' % random_name(), mount_point])\n        return cls(mount_point, lower_dir, upper_dir)", "response": "Execute the mount. This requires root."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a function func, and given distinct inital points ax and bx, this routine searches in the downhill direction (defined by the function as evaluated at the initial points) and returns new points at ax, bx, cx that bracket a minimum of the function. Also returned are the function values at the three points. See Press, et al. (1992) \"Numerical recipes in C\", 2nd ed., p.400.", "response": "def minimum_bracketing(fct, initial_value=0.0, natural_length=1.0 + DOUBLE_TOL):\n    '''\n    Given a function func, and given distinct inital points ax and bx, this routine searches\n    in the downhill direction (defined by the function as evaluated at the initial points)\n    and returns new points at ax, bx, cx that bracket a minimum of the function.\n    Also returned are the function values at the three points.\n    See Press, et al. (1992) \"Numerical recipes in C\", 2nd ed., p.400.\n    '''\n\n    def _minimum_bracketing(a, b, fct):\n        v = mn_brak(a, b, fct)\n        fa = v[3]\n        fb = v[4]\n        fc = v[5]\n        if not (fa > fb and fb < fc):\n            return False\n        # Return the three bracketing points.\n        return (v[0], v[1], v[2])\n\n    ta = initial_value if initial_value != None else 0.0\n    tb = ta + natural_length\n    ret = _minimum_bracketing(ta, tb, fct)\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if all components are opened.", "response": "def is_opened(components):\n        \"\"\"\n        Checks if all components are opened.\n\n        To be checked components must implement [[IOpenable]] interface.\n        If they don't the call to this method returns true.\n\n        :param components: a list of components that are to be checked.\n\n        :return: true if all components are opened and false if at least one component is closed.\n        \"\"\"\n        if components == None:\n            return True\n\n        result = True\n        for component in components:\n            result = result and Opener.is_opened_one(component)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef open(correlation_id, components):\n        if components == None:\n            return\n\n        for component in components:\n            Opener.open_one(correlation_id, component)", "response": "Opens multiple components.\n\n        To be opened components must implement [[IOpenable]] interface.\n        If they don't the call to this method has no effect.\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :param components: the list of components that are to be closed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_raw_temp(self):\n        self.i2c.write8(BMP085_CONTROL, BMP085_READTEMPCMD)\n        time.sleep(0.005)  # Wait 5ms\n        raw = self.i2c.read_U16BE(BMP085_TEMPDATA)\n        self.logger.debug('Raw temp 0x{0:X} ({1})', raw & 0xFFFF, raw)\n        return raw", "response": "Reads the raw ( uncompensated ) temperature from the sensor."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_raw_pressure(self):\n        self.i2c.write8(BMP085_CONTROL, BMP085_READPRESSURECMD + (self._mode << 6))\n        if self._mode == BMP085_ULTRALOWPOWER:\n            time.sleep(0.005)\n        elif self._mode == BMP085_HIGHRES:\n            time.sleep(0.014)\n        elif self._mode == BMP085_ULTRAHIGHRES:\n            time.sleep(0.026)\n        else:\n            time.sleep(0.008)\n        msb = self.i2c.read_U8(BMP085_PRESSUREDATA)\n        lsb = self.i2c.read_U8(BMP085_PRESSUREDATA+1)\n        xlsb = self.i2c.read_U8(BMP085_PRESSUREDATA+2)\n        raw = ((msb << 16) + (lsb << 8) + xlsb) >> (8 - self._mode)\n        self.logger.debug('Raw pressure 0x{0:04X} ({1})', raw & 0xFFFF, raw)\n        return raw", "response": "Reads the raw pressure level from the sensor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_temperature(self):\n        UT = self.read_raw_temp()\n        # Datasheet value for debugging:\n        #UT = 27898\n        # Calculations below are taken straight from section 3.5 of the datasheet.\n        X1 = ((UT - self.cal_AC6) * self.cal_AC5) >> 15\n        X2 = (self.cal_MC << 11) // (X1 + self.cal_MD)\n        B5 = X1 + X2\n        temp = ((B5 + 8) >> 4) / 10.0\n        self.logger.debug('Calibrated temperature {0} C', temp)\n        return temp", "response": "Gets the compensated temperature in degrees celsius."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the compensated pressure in Pascals.", "response": "def read_pressure(self):\n        \"\"\"Gets the compensated pressure in Pascals.\"\"\"\n        UT = self.read_raw_temp()\n        UP = self.read_raw_pressure()\n        # Datasheet values for debugging:\n        #UT = 27898\n        #UP = 23843\n        # Calculations below are taken straight from section 3.5 of the datasheet.\n        # Calculate true temperature coefficient B5.\n        X1 = ((UT - self.cal_AC6) * self.cal_AC5) >> 15\n        X2 = (self.cal_MC << 11) // (X1 + self.cal_MD)\n        B5 = X1 + X2\n        self.logger.debug('B5 = {0}', B5)\n        # Pressure Calculations\n        B6 = B5 - 4000\n        self.logger.debug('B6 = {0}', B6)\n        X1 = (self.cal_B2 * (B6 * B6) >> 12) >> 11\n        X2 = (self.cal_AC2 * B6) >> 11\n        X3 = X1 + X2\n        B3 = (((self.cal_AC1 * 4 + X3) << self._mode) + 2) // 4\n        self.logger.debug('B3 = {0}', B3)\n        X1 = (self.cal_AC3 * B6) >> 13\n        X2 = (self.cal_B1 * ((B6 * B6) >> 12)) >> 16\n        X3 = ((X1 + X2) + 2) >> 2\n        B4 = (self.cal_AC4 * (X3 + 32768)) >> 15\n        self.logger.debug('B4 = {0}', B4)\n        B7 = (UP - B3) * (50000 >> self._mode)\n        self.logger.debug('B7 = {0}', B7)\n        if B7 < 0x80000000:\n            p = (B7 * 2) // B4\n        else:\n            p = (B7 // B4) * 2\n        X1 = (p >> 8) * (p >> 8)\n        X1 = (X1 * 3038) >> 16\n        X2 = (-7357 * p) >> 16\n        p = p + ((X1 + X2 + 3791) >> 4)\n        self.logger.debug('Pressure {0} Pa', p)\n        return p/100"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_altitude(self, sealevel_pa=101325.0):\n        # Calculation taken straight from section 3.6 of the datasheet.\n        pressure = float(self.read_pressure())\n        altitude = 44330.0 * (1.0 - pow(pressure / sealevel_pa, (1.0/5.255)))\n        self.logger.debug('Altitude {0} m', altitude)\n        return altitude", "response": "Calculates the altitude in meters."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_sealevel_pressure(self, altitude_m=0.0):\n        pressure = float(self.read_pressure())\n        p0 = pressure / pow(1.0 - altitude_m/44330.0, 5.255)\n        self.logger.debug('Sealevel pressure {0} Pa', p0)\n        return p0", "response": "Calculates the pressure at sealevel when given a known altitude in\n        meters. Returns a value in Pascals."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a rendition url for a master image", "response": "def get_rendition_url(request, image_id, target_width=0, target_height=0):\n    '''\n    get a rendition url\n\n    if the rendition does nto exist it will be created in the storage\n    if dimensions do not fit master's aspect ratio\n    then image will be cropped with a centered anchor\n\n    if one dimensions is omitted (0)\n    the other one will be generated accordind to master's aspect ratio\n\n    :param request: http GET request\n        /renderer/rendition/url/<image_id>/<target_width>/<target_height>/\n    :param image_id: the master image primary key\n    :param target_width: target image width\n        if 0 renderer will use target_height\n        to generate a image with correct aspect ratio\n    :param target_height: target image height\n        if 0 renderer will use target_width\n        to generate a image height correct aspect ratio\n    :return: rendition url in a json dictionary\n    '''\n    im = get_object_or_404(MasterImage, pk=image_id)\n\n    return JsonResponse({\n        'url': im.get_rendition_url(target_width, target_height)\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_master_url(request, image_id):\n    '''\n    get image's master url\n\n    ...\n\n    :param request: http GET request /renderer/master/url/<image_id>/\n    :param image_id: the master image primary key\n    :return: master url in a json dictionary\n    '''\n    im = get_object_or_404(MasterImage, pk=image_id)\n\n    return JsonResponse({'url': im.get_master_url()})", "response": "get image's master url\n\n    ...\n\n    :param request: http GET request /renderer/master/url/<image_id>/\n    :param image_id: the master image primary key\n    :return: master url in a json dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the results from the resolve server into a list of dicts.", "response": "def __parse_results(self,results):\n        \"\"\"\n        The resolve server responds with some basic HTML formatting, where the actual\n        results are listed as an HTML list. The regular expression RE_RESULT captures\n        each entry\n        \"\"\"\n        reslist = []\n        cursor = 0\n        match  = RE_RESULTS.search(results,cursor)\n        while match:\n            doc = {}\n            doc['bibcode'] = match.group('bibcode')\n            doc['confidence'] = self.__get_confidence_level(match.group('confidence'))\n            doc['refstring'] = match.group('refstring')\n            reslist.append(doc)\n            cursor = match.end()\n            match  = RE_RESULTS.search(results,cursor)\n        return reslist"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_domain_config(self, domain):\n        domain_root = self.identify_domain_root(domain)\n\n        host = ''\n        if len(domain_root) != len(domain):\n            host = domain.replace('.' + domain_root, '')\n\n        domain_connect_api = self._identify_domain_connect_api(domain_root)\n\n        ret = self._get_domain_config_for_root(domain_root, domain_connect_api)\n        return DomainConnectConfig(domain, domain_root, host, ret)", "response": "Makes a discovery of domain name and resolves configuration of DNS provider"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_domain_connect_template_sync_url(self, domain, provider_id, service_id, redirect_uri=None, params=None,\n                                             state=None, group_ids=None):\n        \"\"\"Makes full Domain Connect discovery of a domain and returns full url to request sync consent.\n\n        :param domain: str\n        :param provider_id: str\n        :param service_id: str\n        :param redirect_uri: str\n        :param params: dict\n        :param state: str\n        :param group_ids: list(str)\n        :return: (str, str)\n            first field is an url which shall be used to redirect the browser to\n            second field is an indication of error\n        :raises: NoDomainConnectRecordException\n            when no _domainconnect record found\n        :raises: NoDomainConnectSettingsException\n            when settings are not found\n        :raises: InvalidDomainConnectSettingsException\n            when settings contain missing fields\n        \"\"\"\n        # TODO: support for signatures\n        # TODO: support for provider_name (for shared templates)\n\n        if params is None:\n            params = {}\n\n        config = self.get_domain_config(domain)\n\n        self.check_template_supported(config, provider_id, service_id)\n\n        if config.urlSyncUX is None:\n            raise InvalidDomainConnectSettingsException(\"No sync URL in config\")\n\n        sync_url_format = '{}/v2/domainTemplates/providers/{}/services/{}/' \\\n                          'apply?domain={}&host={}&{}'\n\n        if redirect_uri is not None:\n            params[\"redirect_uri\"] = redirect_uri\n        if state is not None:\n            params[\"state\"] = state\n        if group_ids is not None:\n            params[\"groupId\"] = \",\".join(group_ids)\n\n        return sync_url_format.format(config.urlSyncUX, provider_id, service_id, config.domain_root, config.host,\n                                      urllib.parse.urlencode(sorted(params.items(), key=lambda val: val[0])))", "response": "Makes full Domain Connect discovery of a domain and returns full url to request sync consent."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_domain_connect_template_async_context(self, domain, provider_id, service_id, redirect_uri, params=None,\n                                                  state=None, service_id_in_path=False):\n        \"\"\"Makes full Domain Connect discovery of a domain and returns full context to request async consent.\n\n        :param domain: str\n        :param provider_id: str\n        :param service_id: str\n        :param redirect_uri: str\n        :param params: dict\n        :param state: str\n        :param service_id_in_path: bool\n        :return: (DomainConnectAsyncContext, str)\n            asyncConsentUrl field of returned context shall be used to redirect the browser to\n            second field is an indication of error\n        :raises: NoDomainConnectRecordException\n            when no _domainconnect record found\n        :raises: NoDomainConnectSettingsException\n            when settings are not found\n        :raises: TemplateNotSupportedException\n            when template is not found\n        :raises: InvalidDomainConnectSettingsException\n            when parts of the settings are missing\n        :raises: DomainConnectException\n            on other domain connect issues\n        \"\"\"\n        if params is None:\n            params = {}\n\n        config = self.get_domain_config(domain)\n\n        self.check_template_supported(config, provider_id, service_id)\n\n        if config.urlAsyncUX is None:\n            raise InvalidDomainConnectSettingsException(\"No asynch UX URL in config\")\n\n        if service_id_in_path:\n            if type(service_id) is list:\n                raise DomainConnectException(\"Multiple services are only supported with service_id_in_path=false\")\n            async_url_format = '{0}/v2/domainTemplates/providers/{1}/services/{2}' \\\n                               '?client_id={1}&scope={2}&domain={3}&host={4}&{5}'\n        else:\n            if type(service_id) is list:\n                service_id = '+'.join(service_id)\n            async_url_format = '{0}/v2/domainTemplates/providers/{1}' \\\n                               '?client_id={1}&scope={2}&domain={3}&host={4}&{5}'\n\n        if redirect_uri is not None:\n            params[\"redirect_uri\"] = redirect_uri\n        if state is not None:\n            params[\"state\"] = state\n\n        ret = DomainConnectAsyncContext(config, provider_id, service_id, redirect_uri, params)\n        ret.asyncConsentUrl = async_url_format.format(config.urlAsyncUX, provider_id, service_id,\n                                                      config.domain_root, config.host,\n                                                      urllib.parse.urlencode(\n                                                          sorted(params.items(), key=lambda val: val[0])))\n        return ret", "response": "Makes full Domain Connect discovery of a domain and returns full context to request async consent."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget access_token in async process and returns it", "response": "def get_async_token(self, context, credentials):\n        \"\"\"Gets access_token in async process\n\n        :param context: DomainConnectAsyncContext\n        :param credentials: DomainConnectAsyncCredentials\n        :return: DomainConnectAsyncContext\n            context enriched with access_token and refresh_token if existing\n        :raises: AsyncTokenException\n        \"\"\"\n        params = {'code': context.code, 'grant_type': 'authorization_code'}\n        if getattr(context, 'iat', None) and getattr(context, 'access_token_expires_in', None) and \\\n                getattr(context, 'refresh_token', None):\n            now = int(time.time()) + 60\n            if now > context.iat + context.access_token_expires_in:\n                params = {'refresh_token': context.refresh_token, 'grant_type': 'refresh_token',\n                          'client_id': credentials.client_id, 'client_secret': credentials.client_secret\n                }\n            else:\n                logger.debug('Context has a valid access token')\n                return context\n        params['redirect_uri'] = context.return_url\n\n        url_get_access_token = '{}/v2/oauth/access_token?{}'.format(context.config.urlAPI,\n                                                                    urllib.parse.urlencode(\n                                                                        sorted(params.items(), key=lambda val: val[0])))\n        try:\n            # this has to be checked to avoid secret leakage by spoofed \"settings\" end-point\n            if credentials.api_url != context.config.urlAPI:\n                raise AsyncTokenException(\"URL API for provider does not match registered one with credentials\")\n            data, status = http_request_json(self._networkContext,\n                                             method='POST',\n                                             content_type='application/json',\n                                             body=json.dumps({\n                                                 'client_id': credentials.client_id,\n                                                 'client_secret': credentials.client_secret,\n                                             }),\n                                             url=url_get_access_token\n                                             )\n        except Exception as ex:\n            logger.debug('Cannot get async token: {}'.format(ex))\n            raise AsyncTokenException('Cannot get async token: {}'.format(ex))\n\n        if 'access_token' not in data \\\n                or 'expires_in' not in data \\\n                or 'token_type' not in data \\\n                or data['token_type'].lower() != 'bearer':\n            logger.debug('Token not complete: {}'.format(data))\n            raise AsyncTokenException('Token not complete: {}'.format(data))\n\n        context.access_token = data['access_token']\n        context.access_token_expires_in = data['expires_in']\n        context.iat = int(time.time())\n\n        if 'refresh_token' in data:\n            context.refresh_token = data['refresh_token']\n\n        return context"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef httpretty_callback(request, uri, headers):\n    method = request.method\n    response_headers = CaseInsensitiveDict()\n    response_headers.update(headers)\n    request_headers = CaseInsensitiveDict()\n    request_headers.update(request.headers)\n    request.headers = request_headers\n    return StackInABox.call_into(method,\n                                 request,\n                                 uri,\n                                 response_headers)", "response": "httpretty request handler.\n\n    converts a call intercepted by httpretty to\n    the stack-in-a-box infrastructure\n\n    :param request: request object\n    :param uri: the uri of the request\n    :param headers: headers for the response\n\n    :returns: tuple - (int, dict, string) containing:\n                      int - the http response status code\n                      dict - the headers for the http response\n                      string - http string response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef registration(uri):\n\n    # add the stack-in-a-box specific response codes to\n    # http's status information\n    status_data = {\n        595: 'StackInABoxService - Unknown Route',\n        596: 'StackInABox - Exception in Service Handler',\n        597: 'StackInABox - Unknown Service'\n    }\n    for k, v in six.iteritems(status_data):\n        if k not in httpretty.http.STATUSES:\n            httpretty.http.STATUSES[k] = v\n\n    # log the uri that is used to access the stack-in-a-box services\n    logger.debug('Registering Stack-In-A-Box at {0} under Python HTTPretty'\n                 .format(uri))\n    # tell stack-in-a-box what uri to match with\n    StackInABox.update_uri(uri)\n\n    # build the regex for the uri and register all http verbs\n    # with httpretty\n    regex = re.compile('(http)?s?(://)?{0}:?(\\d+)?/'.format(uri),\n                       re.I)\n    for method in HttpBaseClass.METHODS:\n        register_uri(method, regex, body=httpretty_callback)", "response": "httpretty handler registration.\n\n    registers a handler for a given uri with httpretty\n    so that it can be intercepted and handed to\n    stack-in-a-box.\n\n    :param uri: uri used for the base of the http requests\n\n    :returns: n/a"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrank queries and write results to file", "response": "def approximator(molecules, options, sort_order=None, frameworks=[], ensemble=[]):\n    \"\"\"\n    recursively rank queries\n    :param molecules:\n    :param options:\n    :param sort_order:\n    :param frameworks:\n    :param ensemble:\n    :return:\n    \"\"\"\n\n    # set variables\n    ensemble_size = options.ensemble_size\n\n    if not sort_order:\n        sort_order = classification.get_sort_order(molecules)\n\n    # construct ensemble\n    print(\"Performing calculations for ensemble size {s}\".format(s=(len(ensemble) + 1)))\n    ensemble = rank_queries(molecules, ensemble, sort_order, options)\n\n    # write stats & ensemble\n    output.write_ensemble(list(ensemble), options)\n\n    if len(ensemble) == ensemble_size:\n        return 1\n    else:\n        return approximator(molecules, options, sort_order, frameworks, ensemble)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nranks queries by value added to existing ensemble", "response": "def rank_queries(molecules, ensemble, sort_order, options):\n    \"\"\"\n    rank queries by value added to existing ensemble\n    :param molecules:\n    :param score_field:\n    :param ensemble:\n    :param sort_order:\n    :param options:\n    :return:\n    \"\"\"\n\n    # generate query list\n    query_list = [x for x in list(molecules[0].scores.keys()) if x not in ensemble]\n\n    results = {}\n\n    for query in query_list:\n        es = EnsembleStorage() # an ensemble storage project\n\n        # generate test_ensemble\n        test_ensemble = ensemble[0:]\n        test_ensemble.append(query)\n        test_ensemble = tuple(test_ensemble)\n        es.set_prop('ensemble', test_ensemble)\n\n        # calculate its performance\n        score_structure = classification.make_score_structure(molecules, test_ensemble)\n\n        # determine auc value\n        auc_structure = classification.make_auc_structure(score_structure)\n        auc = classification.calculate_auc(auc_structure, sort_order, 'no stats')\n        es.set_prop('auc', auc)\n\n        # if the enrichment factor was set to anything other than 1, then we're training to maximize the corresponding\n        # enrichment factor\n        for fpf in classification.make_fpfList(options, score_structure):\n            fpf = float(fpf)\n            ef_structure = classification.make_ef_structure(score_structure, fpf, sort_order)\n            if ef_structure:\n                ef = classification.calculate_ef(ef_structure, fpf)\n                es.set_prop(ef[0], ef[1], 'ef')\n\n        # append results to metric list\n        results[test_ensemble] = es\n\n    # peel away the best performing ensemble\n    best_ensemble = screener.find_best_ensemble(results, options)\n\n    return list(best_ensemble)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the value of the redirect response", "response": "def value(self):\n        \"\"\"\n        Return the value of the redirect response\n        \"\"\"\n        user = self.trigger.agentml.request_log.most_recent().user\n        groups = self.trigger.agentml.request_log.most_recent().groups\n\n        # Does the redirect statement have tags to parse?\n        if len(self._element):\n            message = ''.join(map(str, self.trigger.agentml.parse_tags(self._element, self.trigger)))\n        else:\n            message = self._element.text\n\n        # Is there a default value defined?\n        default = attribute(self._element, 'default', '')\n        response = self.trigger.agentml.get_reply(user.id, message, groups)\n\n        return response or default"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef graph_repo(repo_url, output_loc, format='graphml'):  \n  log = logging.getLogger(\"graphgit\")\n  # repo type\n  local_repo = os.path.isabs(repo_url)\n  # repo name\n  repo_name = repo_url[repo_url.rfind('/')+1:repo_url.rfind('.git')] \\\n    if not local_repo else repo_url[repo_url.rfind(os.sep)+1:]\n  log.info (\"Processing git repository: %s\" % repo_name)\n  # repo location\n  repo_loc = os.path.join(constants.REPO_DOWNLOAD_LOCATION, repo_name) \\\n    if not local_repo else repo_url\n  # initialize repo\n  repo = None\n  gitt = git.Git()\n  try:\n    # check if repo is already cloned\n    # if local repo exists, assign\n    repo = git.Repo(repo_loc, odbt=git.GitCmdObjectDB)    \n    log.info( \"Repository already cloned... Going ahead and using it...\" )\n    # TODO: check if repo is dirty and if so, update\n  except git.exc.NoSuchPathError:\n    # local repo doesn't exist. clone\n    try:\n      if local_repo:\n        raise Exception\n      log.info( \"Cloning repository... this might take some time, please wait !\" )\n      gitt.clone(repo_url, repo_loc)\n      log.info( \"Git clone completed...\" )  \n      repo = git.Repo(repo_loc, odbt=git.GitCmdObjectDB)\n    except:\n      log.error( \"Could not obtain repository: %s !\" % repo_url )\n      sys.exit(1)\n    \n  if repo is None:\n    log.error( \"Could not obtain repository: %s !\" % repo_url )\n    sys.exit(1)\n\n  # create a graph for the repo\n  G = nx.DiGraph()\n  # root node\n  G.add_node(repo_name, type=constants.NODE_TYPE_VALS['REPOSITORY'])\n  # branches & commits\n  for branch in repo.branches:\n    log.debug (\"Processing branch %s\" % branch)\n    G.add_node(branch, type=constants.NODE_TYPE_VALS['BRANCH'])\n    G.add_edge(repo_name, branch, \n      label=constants.EDGE_LABEL_VALS['REPOSITORY_BRANCH'])\n    for commit in repo.iter_commits(branch):\n      try:\n        author = safe_str(commit.author)\n        ts = commit.committed_date\n        sha = safe_str(commit)\n        log.debug (\"%s> %s --[commit]--> %s\" % (branch, author, sha))\n        G.add_node(author, type=constants.NODE_TYPE_VALS['PERSON'])\n        G.add_node(sha, ts=ts,\n          type=constants.NODE_TYPE_VALS['COMMIT'])\n        G.add_edge(author, sha, \n          label=constants.EDGE_LABEL_VALS['PERSON_COMMIT'])\n        G.add_edge(branch, sha, \n          label=constants.EDGE_LABEL_VALS['BRANCH_COMMIT'])\n      except LookupError:\n        log.warning('Could not process %s !' % commit)      \n        continue\n\n  log.info( \"Graph built ! saving...\" )\n\n  # save graph\n  output_file_name = '%s.%s' % (repo_name, format)\n  output_file_loc = os.path.join(output_loc, output_file_name)\n  if format == 'graphml':\n    nx.write_graphml(G, output_file_loc, encoding='utf-8')\n  elif format == 'gexf':\n    nx.write_gexf(G, output_file_loc, encoding='utf-8')\n  else:\n    log.error( \"Invalid output format: %s !\" % format )\n    sys.exit(1)\n\n  log.info( \"Saved to %s !\" % output_file_loc )", "response": "generates a graph for a git repository"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling when client wants to attach session.", "response": "def onHello(self, realm, details):\n        \"\"\"\n        Callback fired when client wants to attach session.\n        \"\"\"\n        log.msg(\"onHello: {} {}\".format(realm, details))\n\n        self._pending_auth = None\n\n        if details.authmethods:\n            for authmethod in details.authmethods:\n                if authmethod == u\"wampcra\":\n\n                    ## lookup user in user DB\n                    salt, key, role, uid = yield self.factory.userdb.get(details.authid)\n                    log.msg(\"salt, key, role: {} {} {} {}\".format(salt, key, role, uid))\n\n                    ## if user found ..\n                    if key:\n\n                        log.msg(\"found key\")\n\n                        ## setup pending auth\n                        self._pending_auth = PendingAuth(key, details.pending_session,\n                            details.authid, role, authmethod, u\"userdb\", uid)\n\n                        log.msg(\"setting challenge\")\n                        ## send challenge to client\n                        extra = {\n                            u'challenge': self._pending_auth.challenge\n                        }\n\n                        ## when using salted passwords, provide the client with\n                        ## the salt and then PBKDF2 parameters used\n                        if salt:\n                            extra[u'salt'] = salt\n                            extra[u'iterations'] = 1000\n                            extra[u'keylen'] = 32\n\n                        defer.returnValue(types.Challenge(u'wampcra', extra))\n\n        ## deny client\n        defer.returnValue(types.Deny())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall when a client responds to an authentication challenge.", "response": "def onAuthenticate(self, signature, extra):\n        \"\"\"\n        Callback fired when a client responds to an authentication challenge.\n        \"\"\"\n        log.msg(\"onAuthenticate: {} {}\".format(signature, extra))\n\n        ## if there is a pending auth, and the signature provided by client matches ..\n        if self._pending_auth:\n\n            if signature == self._pending_auth.signature:\n\n                ## accept the client\n                return types.Accept(authid = self._pending_auth.uid,\n                    authrole = self._pending_auth.authrole,\n                    authmethod = self._pending_auth.authmethod,\n                    authprovider = self._pending_auth.authprovider)\n            else:\n\n                ## deny client\n                return types.Deny(message = u\"signature is invalid\")\n        else:\n\n            ## deny client\n            return types.Deny(message = u\"no pending authentication\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconfigure logging to use the file logger.", "response": "def configure_file_logger(name, log_dir, log_level=logging.DEBUG):\n    \"\"\"Configures logging to use the :class:`SizeRotatingFileHandler`\"\"\"\n    from .srothandler import SizeRotatingFileHandler\n\n    root = logging.getLogger()\n    root.setLevel(log_level)\n    handler = SizeRotatingFileHandler(os.path.join(log_dir, '%s.log' % name))\n    handler.setLevel(log_level)\n    handler.setFormatter(logging.Formatter(LOG_FORMAT_STANDARD))\n\n    root.addHandler(handler)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconfigures logging to use STDOUT", "response": "def configure_stdout_logger(log_level=logging.DEBUG):\n    \"\"\"Configures logging to use STDOUT\"\"\"\n    root = logging.getLogger()\n    root.setLevel(log_level)\n\n    handler = logging.StreamHandler()\n    handler.setLevel(log_level)\n    handler.setFormatter(logging.Formatter(LOG_FORMAT_ESCAPED))\n\n    root.addHandler(handler)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef default_logging_dict(log_dir, handlers=['file'], filename='debug.log'):\n    d = {\n        'version': 1,\n        'disable_existing_loggers': True,\n        'formatters': {\n            'escaped': {\n                'format':LOG_FORMAT_ESCAPED,\n            },\n            'standard': {\n                'format':LOG_FORMAT_STANDARD,\n            },\n        },\n        'handlers': {\n            'default': {\n                'level':'DEBUG',\n                'class':'logging.StreamHandler',\n                'formatter':'escaped',\n            },\n            'file': {\n                'level':'DEBUG',\n                'class':'wrench.logtools.srothandler.SizeRotatingFileHandler',\n                'filename': os.path.abspath(os.path.join(log_dir, filename)),\n                'formatter':'standard',\n                'maxBytes':300000,\n            },\n        },\n        'loggers': {\n            '': {\n                'handlers':handlers,\n                'propagate': False,\n                'level':'DEBUG',\n            },\n        },\n    }\n\n    return d", "response": "Returns a logging configuration dictionary with reasonable defaults."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndisable logging for the duration of what is being wrapped. This is particularly useful when testing if a test method is supposed to issue an error message which is confusing that the error shows for a successful test.", "response": "def silence_logging(method):\n    \"\"\"Disables logging for the duration of what is being wrapped.  This is\n    particularly useful when testing if a test method is supposed to issue an\n    error message which is confusing that the error shows for a successful\n    test.\n    \"\"\"\n    @wraps(method)\n    def wrapper(*args, **kwargs):\n        logging.disable(logging.ERROR)\n        result = method(*args, **kwargs)\n        logging.disable(logging.NOTSET)\n        return result\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend an item to the broker and returns the response.", "response": "def send(self, item, timeout=30):\n        \"\"\"\n        Arguments:\n            item (dict): item to queue up.\n            timeout (int): if no response in this many seconds, then give up.\n\n        Returns:\n            if timed out, then returns None.\n            otherwise returns a `dict` corresponding to the response.\n        \"\"\"\n        uid = str(uuid.uuid4().int & (1<<64)-1)\n        msg = {'id': uid, 'msg': item}\n        self.db.rpush(self.send_addr, json.dumps(msg))\n        key, resp = self.db.blpop(self.recv_addr.format(id=uid), timeout=30)\n        if resp:\n            return json.loads(resp.decode())\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a tuple of a tuple of a tuple of a tuple of a dict corresponding to the dequeued item and a function with which to send back a response.", "response": "def recv(self):\n        \"\"\"\n        Returns:\n            a tuple of `(dict, function)`, corresponding to the dequeued item and a function with which to send back a response.\n        \"\"\"\n        key, incoming = self.db.blpop(self.send_addr)\n        d = json.loads(incoming.decode())\n        uid, msg = d['id'], d['msg']\n        def respond(response):\n            self.db.rpush(self.recv_addr.format(id=uid), json.dumps(response))\n        return msg, respond"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_value(self, value):\n        self._value = value\n\n        for proxy in self.get_proxies():\n            proxy.handler_block(self._changed_handlers[proxy])\n            proxy.set_value(self._value)\n            proxy.handler_unblock(self._changed_handlers[proxy])\n            pass\n\n        self.emit('changed')\n        return", "response": "Set value to action."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_datetime(datetimestring):\n    '''\n    Parses ISO 8601 date-times into datetime.datetime objects.\n    This function uses parse_date and parse_time to do the job, so it allows\n    more combinations of date and time representations, than the actual\n    ISO 8601:2004 standard allows.\n    '''\n    try:\n        datestring, timestring = re.split('T| ', datetimestring)\n    except ValueError:\n        raise isodate.ISO8601Error(\n            \"ISO 8601 time designator 'T' or ' '  missing. Unable to parse \"\n            \"datetime string %r\" % datetimestring\n        )\n    tmpdate = isodate.parse_date(datestring)\n    tmptime = isodate.parse_time(timestring)\n    return datetime.datetime.combine(tmpdate, tmptime)", "response": "Parses ISO 8601 date - times into datetime. datetime objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clean(ctx):\n    os.chdir(PROJECT_DIR)\n    patterns = ['.cache',\n                '.coverage',\n                '.eggs',\n                'build',\n                'dist']\n    ctx.run('rm -vrf {0}'.format(' '.join(patterns)))\n    ctx.run('''find . \\( -name '*,cover' -o -name '__pycache__' -o -name '*.py[co]' -o -name '_work' \\) '''\n            '''-exec rm -vrf '{}' \\; || true''')", "response": "clean generated project files"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds docker image sshd - mssh - copy - id", "response": "def build_docker_sshd(ctx):\n    \"\"\"\n    build docker image sshd-mssh-copy-id\n    \"\"\"\n    dinfo = DOCKER_SSHD_IMG\n    ctx.run('docker rmi -f {0}'.format(dinfo['name']), warn=True)\n    ctx.run('docker build -t {0} {1}'.format(dinfo['name'], dinfo['path']))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_deb(ctx, target):\n    if target not in ('ubuntu-trusty',):\n        print('Error: unknown target \"{0}\"!'.format(target), file=sys.stderr)\n        sys.exit(1)\n\n    os.chdir(PROJECT_DIR)\n    debbuild_dir = os.path.join(DIST_DIR, 'deb')\n\n    # Create directories layout\n    ctx.run('mkdir -p {0}'.format(debbuild_dir))\n\n    # Copy the sources\n    build_src(ctx, dest=debbuild_dir)\n    src_archive = glob.glob(os.path.join(debbuild_dir, 'mssh-copy-id-*.tar.gz'))[0]\n    ctx.run('tar -xvf {0} -C {1}'.format(src_archive, debbuild_dir))\n    src_dir = src_archive[:-7]  # uncompressed directory\n    ctx.run('cp -r {0} {1}'.format(os.path.join(PROJECT_DIR, 'deb/debian'), src_dir))\n\n    # Build the deb\n    ctx.run('docker run -e LOCAL_USER_ID={local_user_id} -v {local}:{cont} {img}'\n            .format(local_user_id=os.getuid(),\n                    local=debbuild_dir,\n                    cont='/deb',\n                    img=DOCKER_IMGS[target]['name']))\n\n    ctx.run('mv -f {0} {1}'.format(os.path.join(debbuild_dir, 'mssh-copy-id_*.deb'), DIST_DIR))", "response": "build a deb package"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_rpm(ctx, target):\n    if target not in ('centos6', 'centos7'):\n        print('Error: unknown target \"{0}\"!'.format(target), file=sys.stderr)\n        sys.exit(1)\n\n    os.chdir(PROJECT_DIR)\n    rpmbuild_dir = os.path.join(DIST_DIR, 'rpmbuild')\n\n    # Create directories layout\n    ctx.run('mkdir -p {0}'.format(' '.join(os.path.join(rpmbuild_dir, d)\n                                           for d in ('BUILD', 'RPMS', 'SOURCES', 'SPECS', 'SRPMS'))))\n\n    # Copy the sources & spec file\n    build_src(ctx, dest=os.path.join(rpmbuild_dir, 'SOURCES'))\n    ctx.run('cp -f {0} {1}'.format(os.path.join(PROJECT_DIR, 'rpm/centos/mssh-copy-id.spec'),\n                                   os.path.join(rpmbuild_dir, 'SPECS')))\n\n    # Build the RPM\n    ctx.run('docker run -e LOCAL_USER_ID={local_user_id} -v {local}:{cont} {img}'\n            .format(local_user_id=os.getuid(),\n                    local=rpmbuild_dir,\n                    cont='/rpmbuild',\n                    img=DOCKER_IMGS[target]['name']))\n\n    ctx.run('mv -f {0} {1}'.format(os.path.join(rpmbuild_dir, 'RPMS/noarch/mssh-copy-id-*.rpm'), DIST_DIR))", "response": "Build an RPM package"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding the RPM and deb images to run mssh - copy - id", "response": "def build_docker_run(ctx, image):\n    \"\"\"\n    build docker images to run mssh-copy-id (functional test)\n    \"\"\"\n    if image not in DOCKER_RUN_IMGS:\n        print('Error: unknown docker image \"{0}\"!'.format(image), file=sys.stderr)\n        sys.exit(1)\n\n    # Build the RPM & deb\n    if image in ('centos6', 'centos7'):\n        build_rpm(ctx, target=image)\n    elif image in ('ubuntu-trusty',):\n        # TODO: add ubuntu-trusty\n        build_deb(ctx, target=image)\n\n    dinfo = DOCKER_RUN_IMGS[image]\n    dinfo_work_dir = os.path.join(dinfo['path'], '_work')\n    ctx.run('mkdir -p {0}'.format(dinfo_work_dir))\n    ctx.run('cp {0} {1}'.format(os.path.join(DIST_DIR, 'mssh-copy-id-*.rpm'), dinfo_work_dir))\n    ctx.run('docker rmi -f {0}'.format(dinfo['name']), warn=True)\n    ctx.run('docker build -t {0} {1}'.format(dinfo['name'], dinfo['path']))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset up the argument parser and returns it.", "response": "def setup_argparse():\n    \"\"\"Sets up the argument parser and returns it\n\n    :returns: the parser\n    :rtype: :class:`argparse.ArgumentParser`\n    :raises: None\n    \"\"\"\n\n    parser = argparse.ArgumentParser(\n        description=\"Builds the documentaion. First it runs gendoc to create rst files\\\n        for the source code. Then it runs sphinx make.\\\n        WARNING: this will delete the contents of the output dirs. You can use -nod.\")\n    ipath = os.path.join(thisdir, '../src')\n    ipath = os.path.abspath(ipath)\n    idefault = [ipath]\n    parser.add_argument('-i', '--input', nargs='+', default=idefault,\n                        help='list of input directories. gendoc is called for every\\\n                        source dir.\\\n                        Default is \\'%s\\'.' % ', '.join(idefault))\n    opath = os.path.join(thisdir, 'reference')\n    opath = os.path.abspath(opath)\n    odefault = [opath]\n    parser.add_argument('-o', '--output', nargs='+', default=odefault,\n                        help='list of output directories. if you have multiple source\\\n                        directories, the corresponding output directorie is used.\\\n                        if there are less dirs than for source, the last output dir\\\n                        is used for the remaining source dirs.\\\n                        WARNING: the output directories are emptied by default. See -nod.\\\n                        Default is \\'%s\\'.' % ', '.join(odefault))\n    gadefault = ['-T', '-f', '-e', '-o']\n    parser.add_argument('-ga', '--gendocargs', nargs='*', default=gadefault,\n                        help=\"list of arguments to pass to gendoc. use -gh for info.\\\n                        Default is \\'%s\\'\" % ', '.join(gadefault))\n    parser.add_argument('-nod', '--nodelete', action='store_true',\n                        help='Do not empty the output directories first.')\n    parser.add_argument('-gh', '--gendochelp', action='store_true',\n                        help='print the help for gendoc and exit')\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prepare_dir(directory, delete=True):\n    if os.path.exists(directory):\n        if delete:\n            assert directory != thisdir, 'Trying to delete docs! Specify other output dir!'\n            print 'Deleting %s' % directory\n            shutil.rmtree(directory)\n            print 'Creating %s' % directory\n            os.mkdir(directory)\n    else:\n        print 'Creating %s' % directory\n        os.mkdir(directory)", "response": "Create apidoc dir delete contents if delete is True."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_gendoc(source, dest, args):\n    args.insert(0, 'gendoc.py')\n    args.append(dest)\n    args.append(source)\n    print 'Running gendoc.main with: %s' % args\n    gendoc.main(args)", "response": "Starts gendoc which reads source and creates rst files in dest with the given args."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main(argv=sys.argv[1:]):\n    parser = setup_argparse()\n    args = parser.parse_args(argv)\n    if args.gendochelp:\n        sys.argv[0] = 'gendoc.py'\n        genparser = gendoc.setup_parser()\n        genparser.print_help()\n        sys.exit(0)\n    print 'Preparing output directories'\n    print '='*80\n    for odir in args.output:\n        prepare_dir(odir, not args.nodelete)\n    print '\\nRunning gendoc'\n    print '='*80\n    for i, idir in enumerate(args.input):\n        if i >= len(args.output):\n            odir = args.output[-1]\n        else:\n            odir = args.output[i]\n        run_gendoc(idir, odir, args.gendocargs)", "response": "Parse commandline arguments and run the tool\n ArcGIS"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fake_print(self):\n    '''\n    This is the overridden __str__ method for Operation\n    Recursively prints out the actual query to be executed\n    '''\n    def _fake_run():\n        kwargs = self.kwargs.copy()\n        kwargs['generate'] = True\n        return _fake_handle_result(\n            getattr(self.migrator, self.method)(*self.args, **kwargs)\n        )\n\n    def _fake_handle_result(result):\n        if isinstance(result, Node):\n            sql, params = self._parse_node(result)\n            return (sql, params)\n        elif isinstance(result, Operation):\n            return str(result)\n        elif isinstance(result, (list, tuple)):\n            return '\\n'.join([str(_fake_handle_result(item)) for item in result])\n\n    return str(_fake_run())", "response": "This method is the overridden __str__ method for Operation\n    Recursively prints out the actual query to be executed\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_migrations(path):\n    '''\n    In the specified directory, get all the files which match the pattern\n    0001_migration.py\n    '''\n    pattern = re.compile(r\"\\d+_[\\w\\d]+\")\n    modules = [name for _, name, _ in pkgutil.iter_modules([path])\n                if pattern.match(name)\n            ]\n\n    return sorted(modules, key=lambda name: int(name.split(\"_\")[0]))", "response": "Get all the migrations in the specified directory."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef migrate(engine, database, module, **kwargs):\n    '''\n    Execute the migrations. Pass in kwargs\n    '''\n    validate_args(engine, database, module)\n\n    options = {\n        'direction': kwargs.get('direction', 'up'),\n        'fake': kwargs.get('fake', False),\n        'force': kwargs.get('force', False),\n        'migration': kwargs.get('migration', None),\n        'transaction': kwargs.get('transaction', True),\n    }\n\n    Migration._meta.database = database\n    migrator = DATABASE_MAP[engine](database, module, **options)\n    migrator.run()", "response": "Execute the migrations. Pass in kwargs\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generate(engine, database, models, **kwargs):\n    '''\n    Generate the migrations by introspecting the db\n    '''\n    validate_args(engine, database, models)\n    generator = Generator(engine, database, models)\n    generator.run()", "response": "Generate migrations by introspecting the db\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\napplies a particular migration to the database.", "response": "def apply_migration(self, migration, **kwargs):\n        '''\n        Apply a particular migration\n        '''\n        cprint(\"\\nAttempting to run %s\" % migration, \"cyan\")\n        # First check if the migration has already been applied\n        exists = Migration.select().where(Migration.name == migration).limit(1).first()\n        if exists and self.direction == 'up':\n            cprint(\"This migration has already been run on this server\", \"red\")\n            if not self.force or self.fake:\n                return False\n            else:\n                cprint(\"Force running this migration again\", \"yellow\")\n\n        # Load the module\n        module_name = \"%s.%s\" % (self.module_name, migration)\n        try:\n            module = importlib.import_module(module_name)\n            if not hasattr(module, self.direction):\n                raise MigrationException(\"%s doesn't have %s migration defined\" %\n                    (migration, self.direction)\n                )\n            # Actually execute the direction method\n            # Note that this doesn't actually run the migrations in the DB yet.\n            # This merely collects the steps in the migration, so that if needed\n            # we can just fake it and print out the SQL query as well.\n            getattr(module, self.direction)(self)\n            # Print out each migration and execute it\n            for op in self.operations:\n                self.execute_operation(op)\n\n            if not self.fake:\n                # If successful, create the entry in our log\n                if self.direction == 'up' and not exists:\n                    Migration.create(name=migration)\n                elif self.direction == 'down' and exists:\n                    exists.delete_instance()\n\n            cprint(\"Done\", \"green\")\n\n        except ImportError:\n            raise MigrationException(\"%s migration not found\" % migration)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_tables(self, models):\n        '''\n        Extract all peewee models from the passed in module\n        '''\n        return { obj._meta.db_table : obj for obj in\n                models.__dict__.itervalues() if\n                isinstance(obj, peewee.BaseModel) and\n                len(obj._meta.fields) > 1\n            }", "response": "Extract all peewee models from the passed in module\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_pwiz_tables(self, engine, database):\n        '''\n        Run the pwiz introspector and get the models defined\n        in the DB.\n        '''\n        introspector = pwiz.make_introspector(engine, database.database,\n            **database.connect_kwargs)\n        out_file = '/tmp/db_models.py'\n\n        with Capturing() as code:\n            pwiz.print_models(introspector)\n        code = '\\n'.join(code)\n        # Unfortunately, introspect.getsource doesn't seem to work\n        # with dynamically created classes unless it is written out\n        # to a file. So write it out to a temporary file\n        with open(out_file, 'w') as file_:\n            file_.write(code)\n        # Load up the DB models as a new module so that we can\n        # compare them with those in the model definition\n        return imp.load_source('db_models', out_file)", "response": "Run the pwiz introspector and get the models defined\n        in the DB."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\noverriding to not set the subject identifier on save.", "response": "def update_subject_identifier_on_save(self):\n        \"\"\"Overridden to not set the subject identifier on save.\n        \"\"\"\n        if not self.subject_identifier:\n            self.subject_identifier = self.subject_identifier_as_pk.hex\n        elif re.match(UUID_PATTERN, self.subject_identifier):\n            pass\n        return self.subject_identifier"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nraising an exception if the subject identifier for an existing instance is not set.", "response": "def raise_on_changed_subject_identifier(self):\n        \"\"\"Raises an exception if there is an attempt to change\n        the subject identifier for an existing instance if the subject\n        identifier is already set.\n        \"\"\"\n        if self.id and self.subject_identifier_is_set():\n            with transaction.atomic():\n                obj = self.__class__.objects.get(pk=self.id)\n                if obj.subject_identifier != self.subject_identifier_as_pk.hex:\n                    if self.subject_identifier != obj.subject_identifier:\n                        raise RegisteredSubjectError(\n                            'Subject identifier cannot be changed for '\n                            'existing registered subject. Got {} <> {}.'.format(\n                                self.subject_identifier, obj.subject_identifier))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if the subject identifier or other attribute is in use and if not raises an exception if it is not.", "response": "def raise_on_duplicate(self, attrname):\n        \"\"\"Checks if the subject identifier (or other attr) is in use,\n        for new and existing instances.\n        \"\"\"\n        if getattr(self, attrname):\n            with transaction.atomic():\n                error_msg = (\n                    'Cannot {{action}} registered subject with a duplicate '\n                    '\\'{}\\'. Got {}.'.format(attrname, getattr(self, attrname)))\n                try:\n                    obj = self.__class__.objects.exclude(\n                        **{'pk': self.pk} if self.id else {}).get(\n                            **{attrname: getattr(self, attrname)})\n                    if not self.id:\n                        raise RegisteredSubjectError(\n                            error_msg.format(action='insert'))\n                    elif self.subject_identifier_is_set() and obj.id != self.id:\n                        raise RegisteredSubjectError(\n                            error_msg.format(action='update'))\n                    else:\n                        raise RegisteredSubjectError(\n                            error_msg.format(action='update'))\n                except self.__class__.DoesNotExist:\n                    pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef resolve(config, default_name = None):\n        name = config.get_as_nullable_string(\"name\")\n        name = name if name != None else config.get_as_nullable_string(\"id\")\n\n        if name == None:\n            descriptor_str = config.get_as_nullable_string(\"descriptor\")\n            descriptor = Descriptor.from_string(descriptor_str)\n            if descriptor != None:\n                name = descriptor.get_name()\n\n        return name if name != None else default_name", "response": "Resolves a component name from the given configuration parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_or_create_environment(self, repo: str, branch: str, git_repo: Repo, repo_path: Path) -> str:\n        return sys.executable", "response": "Returns the path to the current Python executable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef apply(self, resource):\n        if not isinstance(resource, Image.Image):\n            raise ValueError('Unknown resource format')\n\n        original_width, original_height = resource.size\n\n        if self.start[0] < original_width or self.start[1] < original_height:\n            left = self.start[0]\n            upper = self.start[1]\n        else:\n            left = 0\n            upper = 0\n\n        right = self.start[0] + self.size[0]\n        lower = self.start[1] + self.size[1]\n\n        resource_format = resource.format\n        resource = resource.crop(\n            (\n                left,\n                upper,\n                right if right < original_width else original_width,\n                lower if lower < original_height else original_height\n            )\n        )\n        resource.format = resource_format\n\n        return resource", "response": "Apply filter to resource\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reverse_geocode(self, lat, lng, **params):\n        return self._get_geocoder_result(latlng=\"%s,%s\" % (lat, lng), **params)", "response": "Reverse geocode the given latitude and longitude."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a signature for the base_url and private_key.", "response": "def _generate_signature(self, base_url, private_key):\n        \"\"\"\n        http://code.google.com/apis/maps/documentation/webservices/index.html#PythonSignatureExample\n        \"\"\"\n        url = urlparse.urlparse(base_url)\n        url_to_sign = url.path + '?' + url.query\n        decoded_key = base64.urlsafe_b64decode(private_key)\n        signature = hmac.new(decoded_key, url_to_sign, hashlib.sha1)\n        return base64.urlsafe_b64encode(signature.digest())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _alignment(elist, flist, e2f, f2e):\r\n    '''\r\n    elist, flist\r\n        wordlist for each language\r\n    e2f\r\n        translatoin alignment from e to f\r\n        alignment is\r\n        [(e, f)]\r\n    f2e\r\n        translatoin alignment from f to e\r\n        alignment is\r\n        [(e, f)]\r\n    return\r\n        alignment: {(f, e)}\r\n             flist\r\n          -----------------\r\n        e |               |\r\n        l |               |\r\n        i |               |\r\n        s |               |\r\n        t |               |\r\n          -----------------\r\n\r\n    '''\r\n    neighboring = {(-1, 0), (0, -1), (1, 0), (0, 1),\r\n                   (-1, -1), (-1, 1), (1, -1), (1, 1)}\r\n    e2f = set(e2f)\r\n    f2e = set(f2e)\r\n    m = len(elist)\r\n    n = len(flist)\r\n    alignment = e2f.intersection(f2e)\r\n    # marge with neighborhood\r\n    while True:\r\n        set_len = len(alignment)\r\n        for e_word in range(1, m+1):\r\n            for f_word in range(1, n+1):\r\n                if (e_word, f_word) in alignment:\r\n                    for (e_diff, f_diff) in neighboring:\r\n                        e_new = e_word + e_diff\r\n                        f_new = f_word + f_diff\r\n                        if not alignment:\r\n                            if (e_new, f_new) in e2f.union(f2e):\r\n                                alignment.add((e_new, f_new))\r\n                        else:\r\n                            if ((e_new not in list(zip(*alignment))[0]\r\n                                    or f_new not in list(zip(*alignment))[1])\r\n                                    and (e_new, f_new) in e2f.union(f2e)):\r\n                                alignment.add((e_new, f_new))\r\n        if set_len == len(alignment):\r\n            break\r\n    # finalize\r\n    for e_word in range(1, m+1):\r\n        for f_word in range(1, n+1):\r\n            # for alignment = set([])\r\n            if not alignment:\r\n                if (e_word, f_word) in e2f.union(f2e):\r\n                    alignment.add((e_word, f_word))\r\n            else:\r\n                if ((e_word not in list(zip(*alignment))[0]\r\n                        or f_word not in list(zip(*alignment))[1])\r\n                        and (e_word, f_word) in e2f.union(f2e)):\r\n                    alignment.add((e_word, f_word))\r\n    return alignment", "response": "Returns a new list of words that are aligned with the original list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn an alignment for the given translations from es to es", "response": "def symmetrization(es, fs, f2e_train, e2f_train):\r\n    '''\r\n    forpus\r\n        for translation from fs to es\r\n    return\r\n        alignment **from fs to es**\r\n    '''\r\n    f2e = viterbi_alignment(es, fs, *f2e_train).items()\r\n    e2f = viterbi_alignment(fs, es, *e2f_train).items()\r\n    \r\n    \"\"\"\r\n    es: English words\r\n    fs: Foreign words\r\n    f2e: alignment for translation from fs to es\r\n        [(e, f)] or {(e, f)}\r\n    e2f: alignment for translation from es to fs\r\n        [(f, e)] or {(f, e)}\r\n    \"\"\"\r\n    _e2f = list(zip(*reversed(list(zip(*e2f)))))\r\n    return _alignment(es, fs, _e2f, f2e)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the number of non - sequence items in a given recursive sequence.", "response": "def count_leaves(x):\n    \"\"\"\n    Return the number of non-sequence items in a given recursive sequence.\n    \"\"\"\n    if hasattr(x, 'keys'):\n        x = list(x.values())\n    if hasattr(x, '__getitem__'):\n        return sum(map(count_leaves, x))\n\n    return 1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reprcall(name, args=(), kwargs=(), keywords='', sep=', ',\n        argfilter=repr):\n    \"\"\"Format a function call for display.\"\"\"\n    if keywords:\n        keywords = ((', ' if (args or kwargs) else '') +\n                    '**' + keywords)\n    argfilter = argfilter or repr\n    return \"{name}({args}{sep}{kwargs}{keywords})\".format(\n            name=name, args=reprargs(args, filter=argfilter),\n            sep=(args and kwargs) and sep or \"\",\n            kwargs=reprkwargs(kwargs, sep), keywords=keywords or '')", "response": "Format a function call for display."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats a function signature for display.", "response": "def reprsig(fun, name=None, method=False):\n    \"\"\"Format a methods signature for display.\"\"\"\n    args, varargs, keywords, defs, kwargs = [], [], None, [], {}\n    argspec = fun\n    if callable(fun):\n        name = fun.__name__ if name is None else name\n        argspec = getargspec(fun)\n    try:\n        args = argspec[0]\n        varargs = argspec[1]\n        keywords = argspec[2]\n        defs = argspec[3]\n    except IndexError:\n        pass\n    if defs:\n        args, kwkeys = args[:-len(defs)], args[-len(defs):]\n        kwargs = dict(zip(kwkeys, defs))\n    if varargs:\n        args.append('*' + varargs)\n    if method:\n        args.insert(0, 'self')\n    return reprcall(name, map(str, args), kwargs, keywords,\n                    argfilter=str)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_input(input_func, input_str):\n    val = input_func(\"Please enter your {0}: \".format(input_str))\n    while not val or not len(val.strip()):\n        val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))\n    return val", "response": "Get input from the user given an input function and an input string"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef working_cycletime(start, end, workday_start=datetime.timedelta(hours=0), workday_end=datetime.timedelta(hours=24)):\n    def clamp(t, start, end):\n        \"Return 't' clamped to the range ['start', 'end']\"\n        return max(start, min(end, t))\n\n    def day_part(t):\n        \"Return timedelta between midnight and 't'.\"\n        return t - t.replace(hour=0, minute=0, second=0)\n\n    if not start:\n        return None\n    if not end:\n        end = datetime.datetime.now()\n\n    zero = datetime.timedelta(0)\n    # Make sure that the work day is valid\n    assert(zero <= workday_start <= workday_end <= datetime.timedelta(1))\n    # Get the workday delta\n    workday = workday_end - workday_start\n    # Get the number of days it took\n    days = (end - start).days + 1\n    # Number of weeks\n    weeks = days // 7\n    # Get the number of days in addition to weeks\n    extra = (max(0, 5 - start.weekday()) + min(5, 1 + end.weekday())) % 5\n    # Get the number of working days\n    weekdays = weeks * 5 + extra\n    # Get the total time spent accounting for the workday\n    total = workday * weekdays\n    if start.weekday() < 5:\n        # Figuring out how much time it wasn't being worked on and subtracting\n        total -= clamp(day_part(start) - workday_start, zero, workday)\n    if end.weekday() < 5:\n        # Figuring out how much time it wasn't being worked on and subtracting\n        total -= clamp(workday_end - day_part(end), zero, workday)\n\n    cycle_time = timedelta_total_seconds(total) / timedelta_total_seconds(workday)\n    return cycle_time", "response": "Get the working cycle time between start and end."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nevaluate the given expression string with the given context.", "response": "def _evaluate(expression, defines):\n    \"\"\"Evaluate the given expression string with the given context.\n\n    .. WARNING:\n        This runs eval() on a user string. This is unsafe.\n    \"\"\"\n    #interpolated = _interpolate(s, defines)\n    try:\n        defined = {'defined': (lambda v: v in defines)}\n        return_value = eval(expression, defined, defines)\n    except Exception, ex:\n        message = str(ex)\n        if message.startswith(\"name '\") and message.endswith(\"' is not defined\"):\n            # A common error (at least this is presumed:) is to have\n            #   defined(FOO)   instead of   defined('FOO')\n            # We should give a little insight into what might be wrong.\n            # message == \"name 'FOO' is not defined\"\n            #    -->  variable_name == \"FOO\"\n            variable_name = message[len(\"name '\"):-len(\"' is not defined\")]\n            if expression.find(\"defined(%s)\" % variable_name) > -1:\n                # \"defined(FOO)\" in expr instead of \"defined('FOO')\"\n                message += ''' (perhaps you want `defined('%s')` instead of `defined(%s)`)''' % (variable_name, variable_name)\n        elif message.startswith(\"invalid syntax\"):\n            message = \"invalid syntax: `%s`\" % expression\n        raise PreprocessorError(message, defines['__FILE__'], defines['__LINE__'])\n\n    logger.debug(\"evaluate %r -> %s (defines=%r)\", expression, return_value, defines)\n    return return_value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef preprocess(input_file,\n               output_file,\n               defines=None,\n               options=None,\n               content_types_db=None,\n               _preprocessed_files=None,\n               _depth=0):\n    \"\"\"\n    Preprocesses the specified file.\n\n    :param input_filename:\n        The input path.\n    :param output_filename:\n        The output file (NOT path).\n    :param defines:\n        a dictionary of defined variables that will be\n        understood in preprocessor statements. Keys must be strings and,\n        currently, only the truth value of any key's value matters.\n    :param options:\n        A ``Namespace`` of command-line options.\n    :param content_types_db:\n        is an instance of ``ContentTypesDatabase``.\n    :param _preprocessed_files:\n        (for internal use only) is used to ensure files\n        are not recursively preprocessed.\n    :param _depth:\n        When the call reaches _depth == 0, the output file is actually\n        written. For all internal recursive calls _depth == 1.\n    :return:\n        Modified dictionary of defines or raises ``PreprocessorError`` if\n        an error occurred.\n    \"\"\"\n\n    # Options that can later be turned into function parameters.\n    include_paths = options.include_paths\n    should_keep_lines = options.should_keep_lines\n    should_substitute = options.should_substitute\n    default_content_type = options.default_content_type\n    input_filename = input_file.name\n\n    defines = defines or {}\n\n    # Ensure preprocessing isn't cyclic(?).\n    _preprocessed_files = _preprocessed_files or []\n    input_file_absolute_path = absolute_path(input_filename)\n    if input_file_absolute_path in _preprocessed_files:\n        raise PreprocessorError(\"detected recursive #include of '%s'\"\\\n                                % input_filename)\n    _preprocessed_files.append(input_file_absolute_path)\n\n    # Determine the content type and comment info for the input file.\n    comment_groups = content_types_db.get_comment_group_for_path(input_filename, default_content_type)\n    statement_regexps = get_statement_regexps(comment_groups)\n\n    # Process the input file.\n    # (Would be helpful if I knew anything about lexing and parsing\n    # simple grammars.)\n    input_lines = input_file.readlines()\n    if _depth == 0:\n        # Only at recursion depth 0 is the temporary buffer created.\n        temp_output_buffer = StringIO()\n    else:\n        # At deeper levels, the temporary buffer is the output file.\n        temp_output_buffer = output_file\n\n    defines['__FILE__'] = input_filename\n    SKIP, EMIT = range(2) # states\n    states = [(EMIT, # a state is (<emit-or-skip-lines-in-this-section>,\n               0, #             <have-emitted-in-this-if-block>,\n               0)]     #             <have-seen-'else'-in-this-if-block>)\n    line_number = 0\n    for line in input_lines:\n        line_number += 1\n        logger.debug(\"line %d: %r\", line_number, line)\n        defines['__LINE__'] = line_number\n\n        # Is this line a preprocessor stmt line?\n        #XXX Could probably speed this up by optimizing common case of\n        #    line NOT being a preprocessor stmt line.\n        for statement_regexp in statement_regexps:\n            match = statement_regexp.match(line)\n            if match:\n                break\n        else:\n            match = None\n\n        if match:\n            op = match.group(\"op\")\n            logger.debug(\"%r stmt (states: %r)\", op, states)\n            if op == \"define\":\n                if not (states and states[-1][0] == SKIP):\n                    var, val = match.group(\"var\", \"val\")\n                    if val is None:\n                        val = None\n                    else:\n                        try:\n                            val = eval(val, {}, {})\n                        except:\n                            pass\n                    defines[var] = val\n            elif op == \"undef\":\n                if not (states and states[-1][0] == SKIP):\n                    var = match.group(\"var\")\n                    try:\n                        del defines[var]\n                    except KeyError:\n                        pass\n            elif op == \"include\":\n                if not (states and states[-1][0] == SKIP):\n                    if \"var\" in match.groupdict():\n                        # This is the second include form: #include VAR\n                        var = match.group(\"var\")\n                        f = defines[var]\n                    else:\n                        # This is the first include form: #include \"path\"\n                        f = match.group(\"fname\")\n\n                    for d in [os.path.dirname(input_filename)] + include_paths:\n                        fname = os.path.normpath(os.path.join(d, f))\n                        if os.path.exists(fname):\n                            break\n                    else:\n                        raise PreprocessorError(\n                            \"could not find #include'd file \"\\\n                            \"\\\"%s\\\" on include path: %r\"\\\n                            % (f, include_paths))\n                    with open(fname, 'rb') as f:\n                        defines = preprocess(f,\n                                             temp_output_buffer,\n                                             defines=defines,\n                                             options=options,\n                                             content_types_db=content_types_db,\n                                             _preprocessed_files=_preprocessed_files,\n                                             _depth=1)\n            elif op in (\"if\", \"ifdef\", \"ifndef\"):\n                if op == \"if\":\n                    expr = match.group(\"expr\")\n                elif op == \"ifdef\":\n                    expr = \"defined('%s')\" % match.group(\"expr\")\n                elif op == \"ifndef\":\n                    expr = \"not defined('%s')\" % match.group(\"expr\")\n                try:\n                    if states and states[-1][0] == SKIP:\n                        # Were are nested in a SKIP-portion of an if-block.\n                        states.append((SKIP, 0, 0))\n                    elif _evaluate(expr, defines):\n                        states.append((EMIT, 1, 0))\n                    else:\n                        states.append((SKIP, 0, 0))\n                except KeyError:\n                    raise PreprocessorError(\"use of undefined variable in \"\\\n                                            \"#%s stmt\" % op, defines['__FILE__']\n                                            ,\n                                            defines['__LINE__'], line)\n            elif op == \"elif\":\n                expr = match.group(\"expr\")\n                try:\n                    if states[-1][2]: # already had #else in this if-block\n                        raise PreprocessorError(\"illegal #elif after #else in \"\\\n                                                \"same #if block\",\n                                                defines['__FILE__'],\n                                                defines['__LINE__'], line)\n                    elif states[-1][1]: # if have emitted in this if-block\n                        states[-1] = (SKIP, 1, 0)\n                    elif states[:-1] and states[-2][0] == SKIP:\n                        # Were are nested in a SKIP-portion of an if-block.\n                        states[-1] = (SKIP, 0, 0)\n                    elif _evaluate(expr, defines):\n                        states[-1] = (EMIT, 1, 0)\n                    else:\n                        states[-1] = (SKIP, 0, 0)\n                except IndexError:\n                    raise PreprocessorError(\"#elif stmt without leading #if \"\\\n                                            \"stmt\", defines['__FILE__'],\n                                            defines['__LINE__'], line)\n            elif op == \"else\":\n                try:\n                    if states[-1][2]: # already had #else in this if-block\n                        raise PreprocessorError(\"illegal #else after #else in \"\\\n                                                \"same #if block\",\n                                                defines['__FILE__'],\n                                                defines['__LINE__'], line)\n                    elif states[-1][1]: # if have emitted in this if-block\n                        states[-1] = (SKIP, 1, 1)\n                    elif states[:-1] and states[-2][0] == SKIP:\n                        # Were are nested in a SKIP-portion of an if-block.\n                        states[-1] = (SKIP, 0, 1)\n                    else:\n                        states[-1] = (EMIT, 1, 1)\n                except IndexError:\n                    raise PreprocessorError(\"#else stmt without leading #if \"\\\n                                            \"stmt\", defines['__FILE__'],\n                                            defines['__LINE__'], line)\n            elif op == \"endif\":\n                try:\n                    states.pop()\n                except IndexError:\n                    raise PreprocessorError(\"#endif stmt without leading #if\"\\\n                                            \"stmt\", defines['__FILE__'],\n                                            defines['__LINE__'], line)\n            elif op == \"error\":\n                if not (states and states[-1][0] == SKIP):\n                    error = match.group(\"error\")\n                    raise PreprocessorError(\"#error: \" + error,\n                                            defines['__FILE__'],\n                                            defines['__LINE__'], line)\n            logger.debug(\"states: %r\", states)\n            if should_keep_lines:\n                temp_output_buffer.write(\"\\n\")\n        else:\n            try:\n                if states[-1][0] == EMIT:\n                    logger.debug(\"emit line (%s)\" % states[-1][1])\n                    # Substitute all defines into line.\n                    # XXX Should avoid recursive substitutions. But that\n                    #     would be a pain right now.\n                    sline = line\n                    if should_substitute:\n                        for name in reversed(sorted(defines, key=len)):\n                            value = defines[name]\n                            sline = sline.replace(name, str(value))\n                    temp_output_buffer.write(sline)\n                elif should_keep_lines:\n                    logger.debug(\"keep blank line (%s)\" % states[-1][1])\n                    temp_output_buffer.write(\"\\n\")\n                else:\n                    logger.debug(\"skip line (%s)\" % states[-1][1])\n            except IndexError:\n                raise PreprocessorError(\"superfluous #endif before this line\",\n                                        defines['__FILE__'],\n                                        defines['__LINE__'])\n    if len(states) > 1:\n        raise PreprocessorError(\"unterminated #if block\", defines['__FILE__'],\n                                defines['__LINE__'])\n    elif len(states) < 1:\n        raise PreprocessorError(\"superfluous #endif on or before this line\",\n                                defines['__FILE__'], defines['__LINE__'])\n\n    #if temp_output_buffer != output_file:\n    #    temp_output_buffer.close()\n    if _depth == 0:\n        output_file.write(temp_output_buffer.getvalue())\n        temp_output_buffer.close()\n\n    return defines", "response": "Preprocesses the specified file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a string to convert it to an integer.", "response": "def parse_int_token(token):\n    \"\"\"\n    Parses a string to convert it to an integer based on the format used:\n\n    :param token:\n        The string to convert to an integer.\n    :type token:\n        ``str``\n    :return:\n        ``int`` or raises ``ValueError`` exception.\n\n    Usage::\n\n        >>> parse_int_token(\"0x40\")\n        64\n        >>> parse_int_token(\"040\")\n        32\n        >>> parse_int_token(\"40\")\n        40\n        >>> parse_int_token(\"foobar\")\n        Traceback (most recent call last):\n            ...\n        ValueError: invalid literal for int() with base 10: 'foobar'\n    \"\"\"\n    if token.startswith(\"0x\") or token.startswith(\"0X\"):\n        return int(token, 16)\n    elif token.startswith(\"0\"):\n        return int(token, 8)\n    else:\n        return int(token)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a definition expression and returns a key - value pair containing the names of the current module.", "response": "def parse_definition_expr(expr, default_value=None):\n    \"\"\"\n    Parses a definition expression and returns a key-value pair\n    as a tuple.\n\n    Each definition expression should be in one of these two formats:\n\n        * <variable>=<value>\n        * <variable>\n\n    :param expr:\n        String expression to be parsed.\n    :param default_value:\n        (Default None) When a definition is encountered that has no value, this\n        will be used as its value.\n    :return:\n        A (define, value) tuple\n\n        or raises a ``ValueError`` if an invalid\n        definition expression is provided.\n\n        or raises ``AttributeError`` if None is provided for ``expr``.\n\n    Usage:\n\n        >>> parse_definition_expr('DEBUG=1')\n        ('DEBUG', 1)\n        >>> parse_definition_expr('FOOBAR=0x40')\n        ('FOOBAR', 64)\n        >>> parse_definition_expr('FOOBAR=whatever')\n        ('FOOBAR', 'whatever')\n        >>> parse_definition_expr('FOOBAR=false')\n        ('FOOBAR', False)\n        >>> parse_definition_expr('FOOBAR=TRUE')\n        ('FOOBAR', True)\n        >>> parse_definition_expr('FOOBAR', default_value=None)\n        ('FOOBAR', None)\n        >>> parse_definition_expr('FOOBAR', default_value=1)\n        ('FOOBAR', 1)\n        >>> parse_definition_expr('FOOBAR=ah=3')\n        ('FOOBAR', 'ah=3')\n        >>> parse_definition_expr(' FOOBAR=ah=3 ')\n        ('FOOBAR', 'ah=3 ')\n        >>> parse_definition_expr(' FOOBAR =ah=3 ')\n        ('FOOBAR', 'ah=3 ')\n        >>> parse_definition_expr(' FOOBAR = ah=3 ')\n        ('FOOBAR', ' ah=3 ')\n        >>> parse_definition_expr(\" \")\n        Traceback (most recent call last):\n            ...\n        ValueError: Invalid definition symbol ` `\n        >>> parse_definition_expr(None)\n        Traceback (most recent call last):\n            ...\n        AttributeError: 'NoneType' object has no attribute 'split'\n    \"\"\"\n    try:\n        define, value = expr.split('=', 1)\n        try:\n            value = parse_number_token(value)\n        except ValueError:\n            value = parse_bool_token(value)\n    except ValueError:\n        if expr:\n            define, value = expr, default_value\n        else:\n            raise ValueError(\"Invalid definition expression `%s`\" % str(expr))\n    d = define.strip()\n    if d:\n        return d, value\n    else:\n        raise ValueError(\"Invalid definition symbol `%s`\" % str(define))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_definitions(definitions):\n    defines = {}\n    if definitions:\n        for definition in definitions:\n            define, value = parse_definition_expr(definition,\n                                                  default_value=None)\n            defines[define] = value\n    return defines", "response": "Parses a list of command line macro definitions and returns a dictionary of symbol table entries."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_command_line():\n\n    import argparse\n\n    parser = argparse.ArgumentParser(description=__doc__.split(\"\\n\")[0])\n    parser.add_argument('-v',\n                        '--version',\n                        action='version',\n                        version='%(prog)s ' + __version__,\n                        help=\"Show version number and exit.\")\n    parser.add_argument('input_filename',\n                        metavar='INPUT_FILE',\n                        type=str,\n                        help='Path of the input file to be preprocessed')\n    parser.add_argument('-q',\n                        '--quiet',\n                        dest='should_be_quiet',\n                        action='store_true',\n                        default=False,\n                        help=\"Disables verbose logging\")\n    parser.add_argument('-L',\n                        '--log-level',\n                        '--logging-level',\n                        dest='logging_level',\n                        choices=[\n                            'DEBUG',\n                            'INFO',\n                            'WARNING',\n                            'ERROR',\n                            'CRITICAL',\n                            'NONE',\n                            ],\n                        default='INFO',\n                        help=\"Logging level.\")\n    parser.add_argument('-o',\n                        '--output',\n                        metavar=\"OUTPUT_FILE\",\n                        dest='output_filename',\n                        default=None,\n                        help='Output file name (default STDOUT)')\n    parser.add_argument('-f',\n                        '--force',\n                        dest='should_force_overwrite',\n                        action='store_true',\n                        default=False,\n                        help='Force overwrite existing output file.')\n    parser.add_argument('-D',\n                        '--define',\n                        metavar=\"EXPR\",\n                        dest='definitions',\n                        action='append',\n                        help=\"\"\"\\\nDefine a variable for preprocessing. <define>\ncan simply be a variable name (in which case it\nwill be true) or it can be of the form\n<var>=<val>. An attempt will be made to convert\n<val> to an integer so -D 'FOO=0' will create a\nfalse value.\"\"\")\n    parser.add_argument('-I',\n                        '--include',\n                        metavar=\"DIR_PATH\",\n                        dest='include_paths',\n                        action='append',\n                        default=['.'],\n                        help='Add a directory to the include path for #include directives.')\n    parser.add_argument('-k',\n                        '--keep-lines',\n                        dest='should_keep_lines',\n                        action='store_true',\n                        default=False,\n                        help='''\\\nEmit empty lines for preprocessor statement\nlines and skipped output lines. This allows line\nnumbers to stay constant.''')\n    parser.add_argument('-s',\n                        '--substitute',\n                        dest='should_substitute',\n                        action='store_true',\n                        default=False,\n                        help='''\\\nSubstitute #defines into emitted lines.\n(Disabled by default to avoid polluting strings)''')\n    parser.add_argument('--default-content-type',\n                        metavar=\"CONTENT_TYPE\",\n                        dest='default_content_type',\n                        default=None,\n                        help='If the content type of the file cannot be determined this will be used. (Default: an error is raised)')\n    parser.add_argument('-c',\n                        '--content-types-path',\n                        '--content-types-config',\n                        metavar=\"PATH\",\n                        dest='content_types_config_files',\n                        default=[],\n                        action='append',\n                        help=\"\"\"\\\nSpecify a path to a content.types file to assist\nwith file type determination. Use the -p or -P flags\nto display content types as read by pepe.\"\"\")\n    parser.add_argument('-p',\n                        '--print-content-types',\n                        dest='should_print_content_types',\n                        action='store_true',\n                        default=False,\n                        help='Display content types and exit.')\n    parser.add_argument('-P',\n                        '--print-content-types-config',\n                        dest='should_print_content_types_config',\n                        action='store_true',\n                        default=False,\n                        help='Display content types configuration and exit.')\n    return parser.parse_args()", "response": "Parses the command line and returns a Namespace object containing options and their values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_up_logging(logger, level, should_be_quiet):\n    LOGGING_LEVELS = {\n        'DEBUG': logging.DEBUG,\n        'INFO': logging.INFO,\n        'WARNING': logging.WARNING,\n        'ERROR': logging.ERROR,\n        'CRITICAL': logging.CRITICAL,\n        'NONE': None,\n    }\n\n    logging_level = LOGGING_LEVELS.get(level)\n    if should_be_quiet or logging_level is None:\n        logging_handler = NullLoggingHandler()\n    else:\n        logger.setLevel(logging_level)\n        logging_handler = logging.StreamHandler()\n        logging_handler.setLevel(logging_level)\n        logging_handler.setFormatter(\n            logging.Formatter(\n                \"%(asctime)s:%(name)s:%(levelname)s: %(message)s\"\n                )\n            )\n\n    logger.addHandler(logging_handler)\n    return logging_level", "response": "Sets up logging for the current node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_max_matching(graph):\n    left = list(graph)\n    pair = defaultdict(lambda: None)\n    dist = defaultdict(lambda: None)\n    q = deque()\n\n    full_graph = graph.copy()\n    for v in left:\n        for n in graph[v]:\n            full_graph[n].add(v)\n\n    def bfs():\n        for v in left:\n            if pair[v] is None:\n                dist[v] = 0\n                q.append(v)\n            else:\n                dist[v] = None\n\n        dist[None] = None\n\n        while q:\n            v = q.popleft()\n            if v is not None:\n                for u in full_graph[v]:\n                    if dist[pair[u]] is None:\n                        dist[pair[u]] = dist[v] + 1\n                        q.append(pair[u])\n\n        return dist[None] is not None\n\n    def dfs(v):\n        if v is not None:\n            for u in full_graph[v]:\n                if dist[pair[u]] == dist[v] + 1 and dfs(pair[u]):\n                    pair[u] = v\n                    pair[v] = u\n                    return True\n\n            dist[v] = None\n            return False\n\n        return True\n\n    matching = 0\n\n    while bfs():\n        for v in left:\n            if pair[v] is None and dfs(v):\n                matching += 1\n                if matching == len(graph):\n                    break\n\n    return {v: pair[v] for v in pair if pair[v] is not None}", "response": "Returns a maximum matching of a bipartite graph."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register(self, service, provider, singleton=False):\n\n        def get_singleton(*args, **kwargs):\n            result = self._get_singleton(service)\n            if not result:\n                instantiator = self._get_instantiator(provider)\n                result = instantiator(*args, **kwargs)\n                self._set_singleton(service, result)\n            return result\n\n        # Providers are always registered in self.providers  as callable methods\n\n        if not callable(provider):\n            self._set_provider(service, lambda *args, **kwargs: provider)\n        elif singleton:\n            self._set_provider(service, get_singleton)\n        else:\n            self._set_provider(service, self._get_instantiator(provider))", "response": "Registers a service provider for a given service."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_jenks_config():\n    config_file = (get_configuration_file() or\n                   os.path.expanduser(os.path.join(\"~\", CONFIG_FILE_NAME)))\n\n    if not os.path.exists(config_file):\n        open(config_file, 'w').close()\n\n    with open(config_file, 'r') as fh:\n        return JenksData(\n            yaml.load(fh.read()),\n            write_method=generate_write_yaml_to_file(config_file)\n        )", "response": "retrieve the jenks configuration object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the placeholder text that will be displayed when the text is empty and the widget is out of focus.", "response": "def set_placeholder(self, text):\n        \"\"\"Set the placeholder text that will be displayed\n        when the text is empty and the widget is out of focus\n\n        :param text: The text for the placeholder\n        :type text: str\n        :raises: None\n        \"\"\"\n        if self._placeholder != text:\n            self._placeholder = text\n            if not self.hasFocus():\n                self.update()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef paintEvent(self, event):\n        if not self.toPlainText() and not self.hasFocus() and self._placeholder:\n            p = QtGui.QPainter(self.viewport())\n            p.setClipping(False)\n            col = self.palette().text().color()\n            col.setAlpha(128)\n            oldpen = p.pen()\n            p.setPen(col)\n            p.drawText(self.viewport().geometry(), QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop, self._placeholder)\n            p.setPen(oldpen)\n        else:\n            return super(JB_PlainTextEdit, self).paintEvent(event)", "response": "Paint the widget\n\n        :param event:\n        :type event:\n        :returns: None\n        :rtype: None\n        :raises: None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a gradient line for the specified resource.", "response": "def gen_gradient(args, resource, inflow, radius, loc, common=True):\n    \"\"\"\n    Returns a line of text to add to an environment file, initializing a\n    gradient resource with the specified\n    name (string), inflow(int), radius(int), and location (tuple of ints)\n    \"\"\"\n    return \"\".join([\"GRADIENT_RESOURCE \", str(resource), \":height=\",\n                    str(radius), \":plateau=\", str(inflow), \":spread=\",\n                    str(radius-1), \":common=\", str(int(common)),\n                    \":updatestep=1000000:peakx=\", str(loc[0]), \":peaky=\",\n                    str(loc[1]), \":plateau_inflow=\", str(inflow), \":initial=\",\n                    str(inflow) + \"\\n\"])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a line of text to add to an environment file initializing a standard resource with the specified name inflow and outflow.", "response": "def gen_res(args, resource, inflow, outflow):\n    \"\"\"\n    Returns a line of text to add to an environment file, initializing a\n    standard resource with the specified name (string), inflow(int), and\n    outflow(int)\n    \"\"\"\n    return \"\".join([\"RESOURCE \", resource, \":inflow=\", str(inflow),\n                    \":outflow=\", str(outflow), \"\\n\"])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a reaction for the given resource.", "response": "def gen_reaction(args, resource, depletable=0):\n    \"\"\"\n    Returns a line of text to add to an environment file, initializing a\n    reaction that uses the resource specified in the first\n    argument to perform the associated task (resource names are expected to\n    be of the form \"resTASK#\" where \"TASK\" corresponds\n    to the task the resource is associated with and # is an integer uniquely\n    identifying that specific gradient resource. For\n    example, the first AND resource would be named resAND0). An optional\n    second argument (int) specifies whether or not the reaction\n    should deplete the resource (by default it will not).\n    \"\"\"\n    task = resource.lower()\n    if task[:3] == \"res\":\n        task = task[3:]\n    while task[-1].isdigit():\n        task = task[:-1]\n\n    name = resource[3:]\n    return \"\".join([\"REACTION \", name, \" \", task, \" process:resource=\",\n                    resource, \":value=\", str(args.taskValDict[task]), \":type=\",\n                    args.rxnType, \":frac=\", str(args.frac), \":max=\",\n                    str(args.resMax), \":depletable=\", str(int(depletable)),\n                    \" requisite:max_count=\", str(args.maxCount), \"\\n\"])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating anchor points evenly spaced across the world.", "response": "def calcEvenAnchors(args):\n    \"\"\"\n    Calculates anchor points evenly spaced across the world, given\n    user-specified parameters.\n\n    Note: May not be exactly even if world size is not divisible by\n    patches+1.\n    Note: Eveness is based on bounded world, not toroidal.\n    \"\"\"\n    anchors = []\n    dist = int((args.worldSize)/(args.patchesPerSide+1))\n    for i in range(dist, args.worldSize, dist):\n        for j in range(dist, args.worldSize, dist):\n            anchors.append((i, j))\n    return anchors"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calcRandomAnchors(args, inworld=True):\n    anchors = []\n    rng = (args.patchRadius, args.worldSize - args.patchRadius)\n    if not inworld:\n        rng = (0, args.worldSize)\n    for i in range(args.nPatches):\n        anchors.append((random.randrange(rng[0], rng[1]),\n                        random.randrange(rng[0], rng[1])))\n\n    return anchors", "response": "Calculates a list of random anchor points such that all circles will fit in the world."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calcTightAnchors(args, d, patches):\n    centerPoint = (int(args.worldSize/2), int(args.worldSize/2))\n    anchors = []\n    if patches == 0:\n        pass\n\n    elif patches == 1:\n        anchors.append(centerPoint)\n\n    elif patches % 2 == 0:\n        dsout = int((patches-2)//2) + 1\n        add_anchors(centerPoint, d, dsout, anchors, True)\n        if d != 0:\n            anchors = list(set(anchors))\n        anchors.sort()\n        if dsout != 1:\n            return (anchors +\n                    calcTightAnchors(args, d, patches-2)\n                    )[:patches*patches]\n            # to cut off the extras in the case where d=0\n\n    else:\n        # Note - an odd number of args.patchesPerSide requires that there be\n        # a patch at the centerpoint\n        dsout = int((patches-1)//2)\n        add_anchors(centerPoint, d, dsout, anchors, False)\n        if dsout != 1:\n            return anchors + calcTightAnchors(d, patches-2)\n\n    return anchors", "response": "Calculates the number of anchor points specified in the\n    and returns them."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef genRandResources(args, resources):\n    randResources = []\n    nEach = int(args.nPatches // len(resources))\n    extras = int(args.nPatches % len(resources))\n    for i in range(nEach):\n        for res in resources:\n            randResources.append(res + str(i))\n\n    additional = random.sample(resources, extras)\n    for res in additional:\n        randResources.append(res + str(nEach))\n\n    random.shuffle(randResources)\n    return randResources", "response": "Generates a list of the appropriate length containing a roughly equal\n    number of all resources in a random order"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd personal package archive from a file list.", "response": "def add_ppas_from_file(file_name, update=True):\n    \"\"\"Add personal package archive from a file list.\"\"\"\n\n    for ppa in _read_lines_from_file(file_name):\n        add_ppa(ppa, update=False)\n    if update:\n        update_apt_sources()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds source url to apt sources. list. Optional to pass the key url.", "response": "def add_apt_source(source, key=None, update=True):\n    \"\"\"Adds source url to apt sources.list. Optional to pass the key url.\"\"\"\n\n    # Make a backup of list\n    source_list = u'/etc/apt/sources.list'\n    sudo(\"cp %s{,.bak}\" % source_list)\n    files.append(source_list, source, use_sudo=True)\n    if key:\n        # Fecth key from url and add\n        sudo(u\"wget -q %s -O - | sudo apt-key add -\" % key)\n    if update:\n        update_apt_sources()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_sources_from_file(file_name, update=True):\n\n    key_regex = re.compile(r'(?P<source>[^()]*)(\\s+\\((?P<key>.*)\\))?$')\n    for line in _read_lines_from_file(file_name):\n        kwargs = key_regex.match(line).groupdict()\n        kwargs['update'] = False\n        add_apt_source(**kwargs)\n    if update:\n        update_apt_sources()", "response": "Add source urls from a file list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a user. Adds a key file to authorized_keys if given.", "response": "def create_user(name, groups=None, key_file=None):\n    \"\"\"Create a user. Adds a key file to authorized_keys if given.\"\"\"\n\n    groups = groups or []\n    if not user_exists(name):\n        for group in groups:\n            if not group_exists(group):\n                sudo(u\"addgroup %s\" % group)\n        groups = groups and u'-G %s' % u','.join(groups) or ''\n        sudo(u\"useradd -m %s -s /bin/bash %s\" % (groups, name))\n        sudo(u\"passwd -d %s\" % name)\n    if key_file:\n        sudo(u\"mkdir -p /home/%s/.ssh\" % name)\n        put(key_file, u\"/home/%s/.ssh/authorized_keys\" % name, use_sudo=True)\n        sudo(u\"chown -R %(name)s:%(name)s /home/%(name)s/.ssh\" % {'name': name})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun an init. d command.", "response": "def service_command(name, command):\n    \"\"\"Run an init.d/upstart command.\"\"\"\n\n    service_command_template = getattr(env, 'ARGYLE_SERVICE_COMMAND_TEMPLATE',\n                                       u'/etc/init.d/%(name)s %(command)s')\n    sudo(service_command_template % {'name': name,\n                                     'command': command}, pty=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the user distinguished name", "response": "def get_user_dn(self, username):\n        \"\"\"\n        Get the user distinguished name (dn)\n        \"\"\"\n        server = ldap3.Server('ldap://' + self.ldap_server)\n        connection = ldap3.Connection(server)\n        connection.open()\n\n        connection.search(\n            search_base=self.dn,\n            search_filter='(' + self.user_attr + '=' + username + ')'\n        )\n        return connection.response[0]['dn']"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef authenticate(self, username, password):\n\n        if username is None or password is None:\n            return False\n\n        # check the username\n        if not re.match(\"^[A-Za-z0-9_-]*$\", username):\n            return False\n\n        user_dn = self.get_user_dn(username)\n\n        server = ldap3.Server(\n                self.uri,\n                use_ssl=self.use_ssl\n            )\n\n        connection = ldap3.Connection(server, user=user_dn, password=password)\n\n        return connection.bind()", "response": "Authenticate the user with a bind on the LDAP server"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pump(fin, fout):\n    while True:\n        tmp = fin.read(4096)\n        if not tmp:\n            break\n        fout.write(tmp)", "response": "Reads data from fin and writes it to fout until EOF is reached."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decorate_method(cls, func):\n        func_args = [arg for arg in function_arguments(func) if arg != 'self']\n        method_return_types = \\\n            Endpoint._parse_function_return_types_from_doc(func.__doc__)\n        name = '%s.%s' % (cls.path, func.__name__)\n\n        @wraps(func)\n        def method_decorator(self, *args, **kwargs):\n            for i in range(len(args)):\n                kwargs[func_args[i]] = args[i]\n\n            api_call = self.connection._pre_process_call(\n                name, endpoint_params=kwargs)\n            try:\n                data = func(**kwargs)\n            except RestException as e:\n                api_call.error = e\n                raise e\n\n            except Exception as e:\n                call_queue = self.connection._call_queue.get(\n                    self.connection._get_thread_id(), [])\n                if api_call in call_queue:\n                    call_queue.remove(api_call)\n                e = RestException(original_error=e,\n                                  stack=traceback.format_exc())\n                log.error('ApiCall Exception: %s' % e, exc_info=True)\n                raise e\n            return self.connection._post_process_call(\n                api_call, data, method_return_types)\n\n        method_decorator.rest_method = True\n        return method_decorator", "response": "Decorator for API methods that are now decorated"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef binary_guesser(handle, num_bytes=512):\n\n    text_chars = ''.join(map(chr, range(32, 127))) + '\\n\\r\\t\\b'\n    byte_chars = text_chars.encode()\n    handle_location = handle.tell()\n    first_block = handle.read(num_bytes)\n    if type(first_block) is str:\n        first_block = first_block.encode()\n    filtered_block = first_block.translate(None, delete=byte_chars)\n    handle.seek(handle_location)  # Return to original handle location\n    if float(len(filtered_block)) / float(len(first_block)) > 0.30:\n        pass  # File is likely binary\n    else:\n        msg = '{0} is probably not a binary file'.format(handle.name)\n        raise FormatError(message=msg)", "response": "Guesses if a file is likely binary"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compile_ui(uifile):\n    print \"Compileing: %s\" % uifile\n    outputpath = uifile.rsplit(os.path.extsep, 1)[0] + \"_ui.py\"\n    print \"Outputfile: %s\" % outputpath\n    outputfile = open(os.path.abspath(outputpath), \"w\")\n    pysideuic.compileUi(os.path.abspath(uifile), outputfile)\n    print \"Done!\"", "response": "Compile the given Qt designer file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef compile_rcc(rccfile):\n    print \"Compileing: %s\" % rccfile\n    rccfilename = os.path.basename(rccfile)\n    outname = rccfilename.rsplit(os.path.extsep, 1)[0] + \"_rc.py\"\n    # put in resoures package\n    path = os.path.dirname(jukeboxcore.gui.resources.__file__)\n    outputpath = os.path.join(path, outname)\n    print \"Outputfile: %s\" % outputpath\n    # get pyside-rcc.exe. It is in the PySide dir.\n    pysidedir = os.path.dirname(PySide.__file__)\n    pysidercc = os.path.join(pysidedir, \"pyside-rcc.exe\")\n    args=[pysidercc, \"-o\", outputpath, rccfile]\n    rc = subprocess.call(args)\n    print \"Finished with returncode %s\" % rc", "response": "Compile the given Qt resource file into a nonen\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef process_tokens(self, tokens):\n        for (tok_type, token, (start_row, _), _, _) in tokens:\n            if tok_type == tokenize.STRING:\n                self._check_string(token, start_row)", "response": "u Loop other tokens to find strings and ensure that they are prefixed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the source into an AST node with positions as positions.", "response": "def parse(code, filename='<unknown>', mode='exec', tree=None):\n    \"\"\"Parse the source into an AST node with PyPosAST.\n    Enhance nodes with positions\n\n\n    Arguments:\n    code -- code text\n\n\n    Keyword Arguments:\n    filename -- code path\n    mode -- execution mode (exec, eval, single)\n    tree -- current tree, if it was optimized\n    \"\"\"\n    visitor = Visitor(code, filename, mode, tree=tree)\n    return visitor.tree"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding all nodes of a given type in a given type.", "response": "def get_nodes(code, desired_type, path=\"__main__\", mode=\"exec\", tree=None):\n    \"\"\"Find all nodes of a given type\n\n\n    Arguments:\n    code -- code text\n    desired_type -- ast Node or tuple\n\n\n    Keyword Arguments:\n    path -- code path\n    mode -- execution mode (exec, eval, single)\n    tree -- current tree, if it was optimized\n    \"\"\"\n    return _GetVisitor(parse(code, path, mode, tree), desired_type).result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates the js for a dashboard", "response": "def generate_dashboard_js(dashboard, react_server, compiled_static_folder, compiled_static_prep, modules, dynamic_dashboard_js=True):\n    \"\"\"\n    Given a dashboard, make the bundle javascript for it\n\n    We also do some caching so we don't generate the javascript when nothing has changed\n\n    First we generate the dashboard es6 content with dashboard.make_dashboard_module()\n    we then write this to disk if not on disk or hasn't changed.\n\n    If the compiled equivalent is not on disk or the raw has a modified time greater than compiled\n    We generate compiled.\n\n    If this is not the case, we find all the static/react folders from our modules\n    and determine if anything has a modified time greater than the compiled javascript.\n\n    If nothing does, and we have our compiled javascript, we do nothing.\n\n    If we need to do something, we create a temporary folder with a copy of the raw javascript\n    and the static/react folders for each module named with the import_path of the module.\n\n    Finally we add a webpack configuration to this temporary folder and tell react_server to run webpack\n    there and generate the compiled javascript.\n\n    Easy!\n    \"\"\"\n    javascript = dashboard.make_dashboard_module(modules)\n\n    dashboard_folder = os.path.join(compiled_static_folder, \"dashboards\")\n    if not os.path.exists(dashboard_folder):\n        os.makedirs(dashboard_folder)\n\n    filename = dashboard.path.replace(\"_\", \"__\").replace(\"/\", \"_\")\n    final_location = \"{0}.js\".format(os.path.join(dashboard_folder, filename))\n\n    if not dynamic_dashboard_js:\n        return final_location\n\n    js_location = os.path.join(dashboard_folder, \"{0}.js\".format(filename))\n    raw_location = os.path.join(dashboard_folder, \"{0}.raw\".format(filename))\n\n    if os.path.exists(raw_location):\n        with open(raw_location) as fle:\n            if fle.read() != javascript:\n                with open(raw_location, 'w') as write_fle:\n                    write_fle.write(javascript)\n    else:\n        with open(raw_location, 'w') as write_fle:\n            write_fle.write(javascript)\n\n    do_change = False\n    js_mtime = -1 if not os.path.exists(js_location) else os.stat(js_location).st_mtime\n    if not os.path.exists(js_location) or os.stat(raw_location).st_mtime > js_mtime:\n        do_change = True\n\n    folders = [(\"dashmat.server\", os.path.join(here, \"static\", \"react\"))]\n    for name, module in modules.items():\n        react_folder = pkg_resources.resource_filename(module.relative_to, \"static/react\")\n        if (module.relative_to, react_folder) not in folders:\n            if os.path.exists(react_folder):\n                if not do_change:\n                    for root, dirs, files in os.walk(react_folder, followlinks=True):\n                        for fle in files:\n                            location = os.path.join(root, fle)\n                            if os.stat(location).st_mtime > js_mtime:\n                                do_change = True\n                                break\n                folders.append((module.relative_to, react_folder))\n\n    if do_change:\n        directory = None\n        try:\n            directory = tempfile.mkdtemp(dir=compiled_static_prep)\n            shutil.copy(raw_location, os.path.join(directory, \"{0}.js\".format(filename)))\n            for module_path, react_folder in folders:\n                dest = os.path.join(directory, module_path)\n                shutil.copytree(react_folder, dest)\n\n            with open(os.path.join(directory, \"webpack.config.js\"), 'w') as fle:\n                fle.write(dedent(\"\"\"\n                    var webpack = require(\"webpack\");\n\n                    module.exports = {{\n                      entry: [ \"/modules/{0}.js\" ],\n                      output: {{\n                        filename: \"/compiled/dashboards/{0}.js\",\n                        library: \"Dashboard\"\n                      }},\n                      module: {{\n                        loaders: [\n                          {{\n                            exclude: /node_modules/,\n                            loader: \"babel\",\n                            test: /\\.jsx?$/,\n                            query: {{\n                                presets: [\"react\", \"es2015\"],\n                                plugins: [\"transform-object-rest-spread\"]\n                            }}\n                          }},\n                          {{\n                            test: /\\.css$/,\n                            loader: \"style!css?modules\"\n                          }}\n                        ]\n                      }},\n                      plugins: [\n                        new webpack.NoErrorsPlugin(),\n                        new webpack.ProvidePlugin({{\n                          Promise: 'imports?this=>global!exports?global.Promise!es6-promise',\n                          fetch: 'imports?this=>global!exports?global.fetch!whatwg-fetch'\n                        }})\n                      ]\n                    }};\n                \"\"\".format(filename)))\n            react_server.build_webpack(directory)\n        finally:\n            if directory and os.path.exists(directory):\n                shutil.rmtree(directory)\n\n    return final_location"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind the best performing ensemble for the given set of results.", "response": "def find_best_ensemble(results, options):\n    \"\"\"\n    Return the best performing ensemble. If the user hasn't specified a FPF, the default behavior sorts ensembles by\n    largest enrichment factor at the smallest FPF (1 / n, where n is the total number of decoys). If the user supplied\n    a FPF, ensembles are sorted by the largest enrichment factor at the input FPF. If the user supplied a FPF = 1,\n    ensembles are sorted by AUC. Ties are broken by considering enrichment factors at the smallest FPF not already\n    considered.\n    :param results: {ensemble_storage_object1, ensemble_storage_object2, ..., ensemble_storage_objectn}\n    :param options: options object, contains user-specified arguments as attributes.\n    :return: ensemble_storage_object (classification.EnsembleStorage) that contains the best performing ensemble\n    \"\"\"\n\n    # We need the total number of decoys in the set to determine the number of decoys that correspond to the FPF values\n    # at which enrichment factors were measured. The number of decoys are keys in the ef dictionary of each\n    # ensemble object stored in the results dictionary.\n    n = sorted(list(list(results.items())[0][1].ef.keys()), reverse=True)[0]\n\n    # determine the number of decoys that correspond to the FPF used for training\n    if not options.fpf:\n        ndecoys = 1\n    else:\n        ndecoys = int(round(n * options.fpf))\n\n    # sort the results according to the user-specified training method\n    if ndecoys == n:\n        # the user specified an fpf of 1, so wants the ensemble the maximizes the AUC, so sort on auc\n        prop_key = 'auc'\n        sorted_list = sorted(results.items(), key = lambda x: x[1].get_prop(prop_key), reverse=True)\n    else:\n        # the user is interested in an ensemble that maximizes an enrichment factor at some FPF\n        prop_key = 'ef'\n        sorted_list = sorted(results.items(), key = lambda x: x[1].get_prop(ndecoys, prop_key), reverse=True)\n\n    # we only need to consider breaking a tie if there is more than one ensemble to consider\n    if len(sorted_list) > 1:\n        sorted_list = tie_break(sorted_list, results, prop_key, ndecoys)\n\n    return sorted_list[0][0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tie_break(sorted_list, results, prop_key, ndecoys):\n\n    # Generate a list of the number of decoys that correspond to the FPF\n    # values at which enrichment factors were determined, not including ndecoys, the training value\n    ndecoys_list = sorted([x for x in list(results.values())[0].ef.keys() if x != ndecoys])\n\n    # break the tie the ensemble that maximizes the enrichment factor at a given FPF (that corresponds to ndecoys)\n    if prop_key == 'ef':\n        index = 0\n        while index < len(ndecoys_list) and sorted_list[0][1].get_prop(ndecoys_list[index], prop_key) == \\\n                sorted_list[1][1].get_prop(ndecoys_list[index], prop_key):\n            sorted_list = sorted(results.items(), key=lambda r: (r[1].get_prop(ndecoys, prop_key),\n                                                                 r[1].get_prop(ndecoys_list[index], 'ef')),\n                                 reverse=True)\n            index += 1\n    # break the tie if the ensemble that maximizes the auc is desired\n    elif prop_key == 'auc':\n        index = 0\n        while sorted_list[0][1].get_prop(prop_key) == sorted_list[1][1].get_prop(prop_key) \\\n                and index < len(ndecoys_list):\n            sorted_list = sorted(results.items(), key = lambda x: (x[1].get_prop(prop_key),\n                                                                   x[1].get_prop(ndecoys_list[index])))\n            index += 1\n\n    return sorted_list", "response": "This function ties the ensemble that maximizes the FPF at a given ndecoys at a given FPF."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nusing the virtual screening scores for the receptors or queries specified in ensemble to sort the molecules in the specified order.", "response": "def screener(molecules, ensemble, sort_order):\n    \"\"\"\n    Uses the virtual screening scores for the receptors, or queries, specified in ensemble to sort the molecules in\n    molecules in the direction specified by sort_order.\n    :param molecules: a list of molecule objects (/classification/molecules.Molecules())\n    :param ensemble: a tuple with receptors, or a query, that specifies a ensemble\n    :param sort_order: 'asc' or 'dsc'. 'asc' sorts in ascending order (binding energy estimates) 'dsc' sorts in\n    descending order (similarity scores, or binding probabilities)\n    :return:\n    \"\"\"\n\n    # screen\n    modified_molecules = []\n    for index in range(len(molecules)):\n        modified_molecules.append(molecules[index])\n        scores = []     #[(score, query)]\n\n        for query in ensemble:\n            scores.append( (molecules[index].GetProp(query), query))\n\n        if sort_order == 'dsc':\n            scores.sort(key=lambda x: float(x[0]), reverse=True)\n\n        elif sort_order == 'asc':\n            scores.sort(key=lambda x: float(x[0]))\n\n        modified_molecules[index].SetProp('best_score', format(scores[0][0]))\n        modified_molecules[index].SetProp('best_query', format(scores[0][1]))\n\n    active = []\n    decoy = []\n    non_random = []\n    for mol in modified_molecules:\n        if float(mol.GetProp('best_score')) == 10000.00:\n            if mol.GetProp('status') == 1:\n                active.append(mol)\n            else:\n                decoy.append(mol)\n        else:\n            non_random.append(mol)\n\n    if sort_order == 'dsc':\n        non_random.sort(key=lambda mol: float(mol.GetProp('best_score')), reverse=True)\n        #random.shuffle(rand)\n    elif sort_order == 'asc':\n        non_random.sort(key=lambda mol: float(mol.GetProp('best_score')))\n        #random.shuffle(rand)\n    # append the compounds with scores of 10,000 in the order active, decoy, active, ...\n    rand = []\n    decoy_length = len(decoy)\n    active_length = len(active)\n    if decoy_length > active_length:\n        for a, d in zip(active, decoy[0:active_length]):\n            rand.append(a)\n            rand.append(d)\n        for d in decoy[active_length:decoy_length]:\n            rand.append(d)\n    elif decoy_length < active_length:\n        for a, d in zip(active[0:decoy_length], decoy):\n            rand.append(a)\n            rand.append(d)\n        for a in active[decoy_length:active_length]:\n            rand.append(a)\n    elif decoy_length == active_length:\n        for a, d in zip(active, decoy):\n            rand.append(a)\n            rand.append(d)\n\n    modified_molecules = non_random + rand\n\n    return modified_molecules"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprocess a. pth file similar to site. addpackage.", "response": "def _process_pth(path, base, file_name):\n    \"\"\"Process a ``.pth`` file similar to site.addpackage(...).\"\"\"\n    \n    pth_path = os.path.abspath(os.path.join(base, file_name))\n    \n    # This is for `exec` below, as some packages (e.g. virtualenvwrapper)\n    # assume that `site.addpackage` is running them.\n    sitedir = os.path.dirname(base)\n\n    # Only process this once.\n    if pth_path in _processed_pths:\n        return\n    _processed_pths.add(pth_path)    \n    \n    log.log(1, '_process_pth(..., %r, %r)', base, file_name)\n    \n    try:\n        fh = open(pth_path)\n    except IOError as e:\n        log.log(1, '_process_path IOError %s' % e)\n        return\n    \n    for line in open(pth_path):\n        line = line.strip()\n        \n        # Blanks and comments.\n        if not line or line.startswith('#'):\n            continue\n        \n        # Execs.\n        if line.startswith('import'):\n            \n            # Sorry easy-install: you break our environment.\n            if file_name == 'easy-install.pth' and 'sys.__plen' in line:\n                continue\n\n            log.log(1, '_process_pth exec %s' % line)\n            exec line\n            continue\n        \n        # Replace \"{platform_spec}\" to allow per-platform paths.\n        line = line.format(\n            platform_spec=basic_platform_spec,\n            basic_platform_spec=basic_platform_spec,\n            extended_platform_spec=extended_platform_spec,\n        )\n\n        path.add(os.path.join(base, line))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a list of pseudo site - packages to sys. path.", "response": "def add_site_list(dir_list):\n    \"\"\"Add a list of pseudo site-packages to :data:`python:sys.path`.\n\n    This centers the list on ``sys.path`` around the current environment.\n    I.e. if this environment is in the list, then directories before it in the\n    list will be prepended to ``sys.path``, and directories after it will\n    be appended to ``sys.path``.\n\n    \"\"\"\n    \n    our_site_packages = os.path.abspath(os.path.join(sys.prefix, site_package_postfix))\n    dir_list = [os.path.abspath(x) for x in dir_list]\n\n    prepend = SysPathInserter(0)\n    append = SysPathInserter()\n\n    try:\n        our_index = dir_list.index(our_site_packages)\n    except ValueError:\n        our_index = None\n\n    for i, dir_name in enumerate(dir_list):\n        if our_index is None or i < our_index:\n            add_site_dir(dir_name, _path=prepend)\n        else:\n            add_site_dir(dir_name, _path=append)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_site_dir(dir_name, before=None, _path=None):\n\n    log.log(5, 'add_site_dir(%r, before=%r)', dir_name, before)\n    \n    # Don't do anything if the folder doesn't exist.\n    if not os.path.exists(dir_name):\n        return\n    \n    path = _path or SysPathInserter(index=before)\n    path.add(dir_name)\n\n    # Process *.pth files in a manner similar to site.addsitedir(...).\n    for file_name in os.listdir(dir_name):\n    \n        # Skip dotfiles.\n        if file_name.startswith('.'):\n            continue\n    \n        # *.pth files.\n        if file_name.endswith('.pth'):\n            _process_pth(path, dir_name, file_name)\n    \n        # __site__.pth files inside packages.\n        if os.path.exists(os.path.join(dir_name, file_name, '__site__.pth')):\n            _process_pth(path, os.path.join(dir_name, file_name), '__site__.pth')", "response": "Add a directory to the list of site - packages."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add(self, path):\n        \n        # sys.path always has absolute paths.\n        path = os.path.abspath(path)\n        \n        # It must exist.\n        if not os.path.exists(path):\n            return\n        \n        # It must not already be in sys.path.\n        if path in sys.path:\n            return\n\n        if self.index is not None:\n            sys.path.insert(self.index, path)\n            self.index += 1\n        else:\n            sys.path.append(path)", "response": "Adds the given path to the decided place in sys. path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate(data, algorithms=(DEFAULT_ALOGRITHM,)):\n    return (Hash.fromresource(data, algorithm) for algorithm in algorithms)", "response": "Generates a list of subresource integrity Hash objects for the given data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a subresource integrity string for the given data & algorithms", "response": "def render(data, algorithms=(DEFAULT_ALOGRITHM,), seperator=' '):\n    \"\"\"Returns a subresource integrity string for the given data &\n    algorithms\n\n    >>> data = b\"alert('Hello, world.');\"\n    >>> render(data)\n    'sha384-H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO'\n\n    >>> print(render(data, ['sha256', 'sha384'], seperator='\\\\n'))\n    sha256-qznLcsROx4GACP2dm0UCKCzCG+HiZ1guq6ZZDob/Tng=\n    sha384-H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO\n    \"\"\"\n    return seperator.join(str(ihash) for ihash in generate(data, algorithms))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a string containing a list of subresource integrity Hash objects.", "response": "def parse(integrity):\n    \"\"\"Returns a list of subresource integrity Hash objects parsed from a str\n\n    >>> parse('  sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU= ')\n    ... # doctest: +ELLIPSIS\n    [subresource_integrity.Hash('sha256', '47DEQp...SuFU=', '')]\n\n    Hash objects are put in descending order of algorithmic strength\n\n    >>> parse('sha384-dOTZf16X8p34q2/kYyEFm0jh89uTjikhnzjeLeF0FHsEaYKb'\n    ...       '1A1cv+Lyv4Hk8vHd'\n    ...       ' '\n    ...       'sha512-Q2bFTOhEALkN8hOms2FKTDLy7eugP2zFZ1T8LCvX42Fp3WoN'\n    ...       'r3bjZSAHeOsHrbV1Fu9/A0EzCinRE7Af1ofPrw=='\n    ... )\n    ... # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE\n    [subresource_integrity.Hash('sha512', 'Q2b...zCinRE7Af1ofPrw==', ''),\n     subresource_integrity.Hash('sha384', 'dOT...Hk8vHd', '')]\n\n    Unrecognised hash algorithms are discarded\n\n    >>> parse('sha1-2jmj7l5rSw0yVb/vlWAYkK/YBwk=')\n    []\n    \"\"\"\n    matches = _INTEGRITY_PATTERN.findall(integrity)\n    matches.sort(key=lambda t: RECOGNISED_ALGORITHMS.index(t[0]))\n    return [Hash.fromhash(*match) for match in matches]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nquerying the database for the most recent time an object was created or updated returns datetime or None", "response": "def last_change(self):\n        \"\"\"\n        queries the database for the most recent time an object was either created or\n        updated\n\n        returns datetime or None if db is empty\n        \"\"\"\n        try:\n            cdt = self.latest('created')\n            udt = self.latest('updated')\n            #print cdt, udt\n            return max(cdt.created, udt.updated)\n\n        except ObjectDoesNotExist:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef since(self, timestamp=None, version=None, deleted=False):\n\n        qset = self\n\n        if timestamp is not None:\n\n            if isinstance(timestamp, numbers.Real):\n                timestamp = datetime.datetime.fromtimestamp(timestamp)\n\n            qset = qset.filter(\n                models.Q(created__gt=timestamp) |\n                models.Q(updated__gt=timestamp)\n            )\n\n        if version is not None:\n\n            qset = qset.filter(version__gt=version)\n\n        if not deleted:\n\n            qset = qset.undeleted()\n\n        return qset", "response": "Queries the database for objects modified since timestamp or version."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fastq_verifier(entries, ambiguous=False):\n\n    if ambiguous:\n        regex = r'^@.+{0}[ACGTURYKMSWBDHVNX]+{0}' \\\n                r'\\+.*{0}[!\"#$%&\\'()*+,-./0123456' \\\n                r'789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ' \\\n                r'[\\]^_`abcdefghijklmnopqrstuvwxyz' \\\n                r'{{|}}~]+{0}$'.format(os.linesep)\n    else:\n        regex = r'^@.+{0}[ACGTU]+{0}' \\\n                r'\\+.*{0}[!-~]+{0}$'.format(os.linesep)\n    delimiter = r'{0}'.format(os.linesep)\n\n    for entry in entries:\n        if len(entry.sequence) != len(entry.quality):\n            msg = 'The number of bases in {0} does not match the number ' \\\n                  'of quality scores'.format(entry.id)\n            raise FormatError(message=msg)\n        try:\n            entry_verifier([entry.write()], regex, delimiter)\n        except FormatError as error:\n            if error.part == 0:\n                msg = 'Unknown Header Error with {0}'.format(entry.id)\n                raise FormatError(message=msg)\n            elif error.part == 1 and ambiguous:\n                msg = '{0} contains a base not in ' \\\n                      '[ACGTURYKMSWBDHVNX]'.format(entry.id)\n                raise FormatError(message=msg)\n            elif error.part == 1 and not ambiguous:\n                msg = '{0} contains a base not in ' \\\n                      '[ACGTU]'.format(entry.id)\n                raise FormatError(message=msg)\n            elif error.part == 2:\n                msg = 'Unknown error with line 3 of {0}'.format(entry.id)\n                raise FormatError(message=msg)\n            elif error.part == 3:\n                msg = r'{0} contains a quality score not in ' \\\n                      r'[!-~]'.format(entry.id)\n                raise FormatError(message=msg)\n            else:\n                msg = '{0}: Unknown Error: Likely a Bug'.format(entry.id)\n                raise FormatError(message=msg)", "response": "Raises FormatError if invalid FASTQ format detected\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_configuration(self):\n        super().validate_configuration()\n\n        if self.inherit_image is not None:\n            try:\n                assert len(str(self.inherit_image).split(\":\")) == 2\n            except (ValueError, AssertionError):\n                raise ArcaMisconfigured(f\"Image '{self.inherit_image}' is not a valid value for the 'inherit_image'\"\n                                        f\"setting\")\n\n        if self.inherit_image is not None and self.get_dependencies() is not None:\n            raise ArcaMisconfigured(\"An external image is used as a base image, \"\n                                    \"therefore Arca can't install dependencies.\")\n\n        if self.use_registry_name is not None:\n            try:\n                assert 2 >= len(str(self.inherit_image).split(\"/\")) <= 3\n            except ValueError:\n                raise ArcaMisconfigured(f\"Registry '{self.use_registry_name}' is not valid value for the \"\n                                        f\"'use_registry_name' setting.\")", "response": "Validates the configuration of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_docker_access(self):\n        try:\n            if self.client is None:\n                self.client = docker.from_env()\n            self.client.ping()  # check that docker is running and user is permitted to access it\n        except ConnectionError as e:\n            logger.exception(e)\n            raise BuildError(\"Docker is not running or the current user doesn't have permissions to access docker.\")", "response": "Checks that the instance is accessible by the current user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_dependencies(self) -> Optional[List[str]]:\n\n        if not self.apt_dependencies:\n            return None\n\n        try:\n            dependencies = list([str(x).strip() for x in self.apt_dependencies])\n        except (TypeError, ValueError):\n            raise ArcaMisconfigured(\"Apk dependencies can't be converted into a list of strings\")\n\n        if not len(dependencies):\n            return None\n\n        dependencies.sort()\n\n        return dependencies", "response": "Returns the apt_dependencies setting to a standardized format."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_python_version(self) -> str:\n        if self.python_version is None:\n            python_version = platform.python_version()\n        else:\n            python_version = self.python_version\n\n        return python_version", "response": "Returns either the specified version from settings or platform. python_version"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_image_name(self,\n                       repo_path: Path,\n                       requirements_option: RequirementsOptions,\n                       dependencies: Optional[List[str]]) -> str:\n        \"\"\" Returns the name for images with installed requirements and dependencies.\n        \"\"\"\n        if self.inherit_image is None:\n            return self.get_arca_base_name()\n        else:\n            name, tag = str(self.inherit_image).split(\":\")\n\n            return f\"arca_{name}_{tag}\"", "response": "Returns the name of the image with installed requirements and dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the tag for images with the dependencies and requirements installed.", "response": "def get_image_tag(self,\n                      requirements_option: RequirementsOptions,\n                      requirements_hash: Optional[str],\n                      dependencies: Optional[List[str]]) -> str:\n        \"\"\" Returns the tag for images with the dependencies and requirements installed.\n\n        64-byte hexadecimal strings cannot be used as docker tags, so the prefixes are necessary.\n        Double hashing the dependencies and requirements hash to make the final tag shorter.\n\n        Prefixes:\n\n        * Image type:\n\n          * i \u2013 Inherited image\n          * a \u2013 Arca base image\n\n        * Requirements:\n\n          * r \u2013 Does have some kind of requirements\n          * s \u2013 Doesn't have requirements\n\n        * Dependencies:\n\n          * d \u2013 Does have dependencies\n          * e \u2013 Doesn't have dependencies\n\n        Possible outputs:\n\n        * Inherited images:\n\n          * `ise` \u2013 no requirements\n          * `ide_<hash(requirements)>` \u2013 with requirements\n\n        * From Arca base image:\n\n          * `<Arca version>_<Python version>_ase` \u2013 no requirements and no dependencies\n          * `<Arca version>_<Python version>_asd_<hash(dependencies)>` \u2013 only dependencies\n          * `<Arca version>_<Python version>_are_<hash(requirements)>` \u2013 only requirements\n          * `<Arca version>_<Python version>_ard_<hash(hash(dependencies) + hash(requirements))>`\n            \u2013 both requirements and dependencies\n\n        \"\"\"\n        prefix = \"\"\n\n        if self.inherit_image is None:\n            prefix = \"{}_{}_\".format(arca.__version__, self.get_python_version())\n\n        prefix += \"i\" if self.inherit_image is not None else \"a\"\n        prefix += \"r\" if requirements_option != RequirementsOptions.no_requirements else \"s\"\n        prefix += \"d\" if dependencies is not None else \"e\"\n\n        if self.inherit_image is not None:\n            if requirements_hash:\n                return prefix + \"_\" + requirements_hash\n            return prefix\n\n        if dependencies is None:\n            dependencies_hash = \"\"\n        else:\n            dependencies_hash = self.get_dependencies_hash(dependencies)\n\n        if requirements_hash and dependencies_hash:\n            return prefix + \"_\" + hashlib.sha256(bytes(requirements_hash + dependencies_hash, \"utf-8\")).hexdigest()\n        elif requirements_hash:\n            return f\"{prefix}_{requirements_hash}\"\n        elif dependencies_hash:\n            return f\"{prefix}_{dependencies_hash}\"\n        else:\n            return prefix"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_or_build_image(self, name: str, tag: str, dockerfile: Union[str, Callable[..., str]], *,\n                           pull=True, build_context: Optional[Path]=None):\n        \"\"\"\n        A proxy for commonly built images, returns them from the local system if they exist, tries to pull them if\n        pull isn't disabled, otherwise builds them by the definition in ``dockerfile``.\n\n        :param name: Name of the image\n        :param tag: Image tag\n        :param dockerfile: Dockerfile text or a callable (no arguments) that produces Dockerfile text\n        :param pull: If the image is not present locally, allow pulling from registry (default is ``True``)\n        :param build_context: A path to a folder. If it's provided, docker will build the image in the context\n            of this folder. (eg. if ``ADD`` is needed)\n        \"\"\"\n        if self.image_exists(name, tag):\n            logger.info(\"Image %s:%s exists\", name, tag)\n            return\n\n        elif pull:\n            logger.info(\"Trying to pull image %s:%s\", name, tag)\n\n            try:\n                self.client.images.pull(name, tag=tag)\n                logger.info(\"The image %s:%s was pulled from registry\", name, tag)\n                return\n            except docker.errors.APIError:\n                logger.info(\"The image %s:%s can't be pulled, building locally.\", name, tag)\n\n        if callable(dockerfile):\n            dockerfile = dockerfile()\n\n        try:\n            if build_context is None:\n                fileobj = BytesIO(bytes(dockerfile, \"utf-8\"))  # required by the docker library\n\n                self.client.images.build(\n                    fileobj=fileobj,\n                    tag=f\"{name}:{tag}\"\n                )\n            else:\n                dockerfile_file = build_context / \"dockerfile\"\n                dockerfile_file.write_text(dockerfile)\n\n                self.client.images.build(\n                    path=str(build_context.resolve()),\n                    dockerfile=dockerfile_file.name,\n                    tag=f\"{name}:{tag}\"\n                )\n\n                dockerfile_file.unlink()\n        except docker.errors.BuildError as e:\n            for line in e.build_log:\n                if isinstance(line, dict) and line.get(\"errorDetail\") and line[\"errorDetail\"].get(\"code\") in {124, 143}:\n                    raise BuildTimeoutError(f\"Installing of requirements timeouted after \"\n                                            f\"{self.requirements_timeout} seconds.\")\n\n            logger.exception(e)\n\n            raise BuildError(\"Building docker image failed, see extra info for details.\", extra_info={\n                \"build_log\": e.build_log\n            })", "response": "Returns the image with the given name and tag. If the image is not present locally builds it locally."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the name and tag of the base image that is available locally.", "response": "def get_arca_base(self, pull=True):\n        \"\"\"\n        Returns the name and tag of image that has the basic build dependencies installed with just pyenv installed,\n        with no python installed. (Builds or pulls the image if it doesn't exist locally.)\n        \"\"\"\n        name = self.get_arca_base_name()\n        tag = arca.__version__\n\n        pyenv_installer = \"https://raw.githubusercontent.com/pyenv/pyenv-installer/master/bin/pyenv-installer\"\n        dockerfile = f\"\"\"\n            FROM debian:stretch-slim\n            RUN apt-get update && \\\n                apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \\\n                                   libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\\n                                   xz-utils tk-dev libffi-dev git locales && \\\n                apt-get clean\n\n            RUN sed -i -e 's/# en_US.UTF-8 UTF-8/en_US.UTF-8 UTF-8/' /etc/locale.gen && locale-gen\n            ENV LANG en_US.UTF-8\n            ENV LANGUAGE en_US:en\n            ENV LC_ALL en_US.UTF-8\n\n            RUN adduser --system --disabled-password --shell /bin/bash arca\n\n            USER arca\n            WORKDIR /home/arca\n            RUN echo \"source $HOME/.bash_profile\" >> .bashrc\n\n            RUN curl -L {pyenv_installer} -o ~/pyenv-installer && \\\n                  /bin/bash ~/pyenv-installer && \\\n                  rm ~/pyenv-installer && \\\n                  echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' >> /home/arca/.bash_profile && \\\n                  echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' >> /home/arca/.bash_profile && \\\n                  echo 'eval \"$(pyenv init -)\"' >> /home/arca/.bash_profile\n\n            USER root\n\n            RUN apt-get remove -y --autoremove curl && \\\n                apt-get clean -y\n\n            RUN mkdir /srv/scripts\n\n            USER arca\n\n            SHELL [\"bash\", \"-lc\"]\n            CMD bash -i\n        \"\"\"\n\n        self.get_or_build_image(name, tag, dockerfile, pull=pull)\n        return name, tag"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the name and tag of an image with specified python_version installed locally.", "response": "def get_python_base(self, python_version, pull=True):\n        \"\"\"\n        Returns the name and tag of an image with specified ``python_version`` installed,\n        if the image doesn't exist locally, it's pulled or built (extending the image from :meth:`get_arca_base`).\n        \"\"\"\n        name = self.get_arca_base_name()\n        tag = self.get_python_base_tag(python_version)\n\n        def get_dockerfile():\n            base_arca_name, base_arca_tag = self.get_arca_base(pull)\n\n            return f\"\"\"\n                FROM {base_arca_name}:{base_arca_tag}\n                RUN pyenv update && \\\n                    pyenv install {python_version}\n                ENV PYENV_VERSION {python_version}\n                ENV PATH \"/home/arca/.pyenv/shims:$PATH\"\n                RUN pip install --upgrade pip setuptools pipenv\n                CMD bash -i\n            \"\"\"\n\n        self.get_or_build_image(name, tag, get_dockerfile, pull=pull)\n\n        return name, tag"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the inherit_image setting and pulls it if it doesn t exist locally.", "response": "def get_inherit_image(self) -> Tuple[str, str]:\n        \"\"\" Parses the ``inherit_image`` setting, checks if the image is present locally and pulls it otherwise.\n\n        :return: Returns the name and the tag of the image.\n        :raise ArcaMisconfiguration: If the image can't be pulled from registries.\n        \"\"\"\n        name, tag = str(self.inherit_image).split(\":\")\n\n        if self.image_exists(name, tag):\n            return name, tag\n        try:\n            self.client.images.pull(name, tag)\n        except docker.errors.APIError:\n            raise ArcaMisconfigured(f\"The specified image {self.inherit_image} from which Arca should inherit \"\n                                    f\"can't be pulled\")\n\n        return name, tag"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an image with installed requirements from the inherited image.", "response": "def build_image_from_inherited_image(self, image_name: str, image_tag: str,\n                                         repo_path: Path,\n                                         requirements_option: RequirementsOptions):\n        \"\"\"\n        Builds a image with installed requirements from the inherited image. (Or just tags the image\n        if there are no requirements.)\n\n        See :meth:`build_image` for parameters descriptions.\n\n        :rtype: docker.models.images.Image\n        \"\"\"\n\n        base_name, base_tag = self.get_inherit_image()\n\n        if requirements_option == RequirementsOptions.no_requirements:\n            image = self.get_image(base_name, base_tag)\n            image.tag(image_name, image_tag)  # so ``build_image`` doesn't have to be called next time\n\n            return image\n\n        dockerfile = self.get_install_requirements_dockerfile(base_name, base_tag, repo_path, requirements_option)\n\n        self.get_or_build_image(image_name, image_tag, dockerfile, build_context=repo_path.parent, pull=False)\n\n        return self.get_image(image_name, image_tag)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_image_with_installed_dependencies(self, image_name: str,\n                                              dependencies: Optional[List[str]]) -> Tuple[str, str]:\n        \"\"\"\n        Return name and tag of a image, based on the Arca python image, with installed dependencies defined\n        by ``apt_dependencies``.\n\n        :param image_name: Name of the image which will be ultimately used for the image.\n        :param dependencies: List of dependencies in the standardized format.\n        \"\"\"\n        python_version = self.get_python_version()\n\n        if dependencies is not None:\n            def install_dependencies_dockerfile():\n                python_name, python_tag = self.get_python_base(python_version,\n                                                               pull=not self.disable_pull)\n\n                return self.INSTALL_DEPENDENCIES.format(\n                    name=python_name,\n                    tag=python_tag,\n                    dependencies=\" \".join(self.get_dependencies())\n                )\n\n            image_tag = self.get_image_tag(RequirementsOptions.no_requirements, None, dependencies)\n            self.get_or_build_image(image_name, image_tag, install_dependencies_dockerfile,\n                                    pull=not self.disable_pull)\n\n            return image_name, image_tag\n        else:\n            return self.get_python_base(python_version, pull=not self.disable_pull)", "response": "Returns name and tag of an image based on the Arca python image with installed dependencies defined by apt_dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild an image for specific requirements and dependencies.", "response": "def build_image(self, image_name: str, image_tag: str,\n                    repo_path: Path,\n                    requirements_option: RequirementsOptions,\n                    dependencies: Optional[List[str]]):\n        \"\"\" Builds an image for specific requirements and dependencies, based on the settings.\n\n        :param image_name: How the image should be named\n        :param image_tag: And what tag it should have.\n        :param repo_path: Path to the cloned repository.\n        :param requirements_option: How requirements are set in the repository.\n        :param dependencies: List of dependencies (in the formalized format)\n        :return: The Image instance.\n        :rtype: docker.models.images.Image\n        \"\"\"\n        if self.inherit_image is not None:\n            return self.build_image_from_inherited_image(image_name, image_tag, repo_path, requirements_option)\n\n        if requirements_option == RequirementsOptions.no_requirements:\n\n            python_version = self.get_python_version()\n\n            # no requirements and no dependencies, just return the basic image with the correct python installed\n            if dependencies is None:\n                base_name, base_tag = self.get_python_base(python_version, pull=not self.disable_pull)\n                image = self.get_image(base_name, base_tag)\n\n                # tag the image so ``build_image`` doesn't have to be called next time\n                image.tag(image_name, image_tag)\n\n                return image\n\n            # extend the image with correct python by installing the dependencies\n            def install_dependencies_dockerfile():\n                base_name, base_tag = self.get_python_base(python_version, pull=not self.disable_pull)\n\n                return self.INSTALL_DEPENDENCIES.format(\n                    name=base_name,\n                    tag=base_tag,\n                    dependencies=\" \".join(dependencies)\n                )\n\n            self.get_or_build_image(image_name, image_tag, install_dependencies_dockerfile)\n\n            return self.get_image(image_name, image_tag)\n\n        else:  # doesn't have to be here, but the return right above was confusing\n            def install_requirements_dockerfile():\n                \"\"\" Returns a Dockerfile for installing pip requirements,\n                    based on a image with installed dependencies (or no extra dependencies)\n                \"\"\"\n                dependencies_name, dependencies_tag = self.get_image_with_installed_dependencies(image_name,\n                                                                                                 dependencies)\n\n                return self.get_install_requirements_dockerfile(\n                    name=dependencies_name,\n                    tag=dependencies_tag,\n                    repo_path=repo_path,\n                    requirements_option=requirements_option,\n                )\n\n            self.get_or_build_image(image_name, image_tag, install_requirements_dockerfile,\n                                    build_context=repo_path.parent, pull=False)\n\n            return self.get_image(image_name, image_tag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef push_to_registry(self, image, image_tag: str):\n        # already tagged, so it's already pushed\n        if f\"{self.use_registry_name}:{image_tag}\" in image.tags:\n            return\n\n        image.tag(self.use_registry_name, image_tag)\n\n        result = self.client.images.push(self.use_registry_name, image_tag)\n\n        result = result.strip()  # remove empty line at the end of output\n\n        # the last can have one of two outputs, either\n        # {\"progressDetail\":{},\"aux\":{\"Tag\":\"<tag>\",\"Digest\":\"sha256:<hash>\",\"Size\":<size>}}\n        # when the push is successful, or\n        # {\"errorDetail\": {\"message\":\"<error_msg>\"},\"error\":\"<error_msg>\"}\n        # when the push is not successful\n\n        last_line = json.loads(result.split(\"\\n\")[-1])\n\n        if \"error\" in last_line:\n            self.client.images.remove(f\"{self.use_registry_name}:{image_tag}\")\n            raise PushToRegistryError(f\"Push of the image failed because of: {last_line['error']}\", full_output=result)\n\n        logger.info(\"Pushed image to registry %s:%s\", self.use_registry_name, image_tag)\n        logger.debug(\"Info:\\n%s\", result)", "response": "Pushes a local image to a registry based on the use_registry_name setting."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef image_exists(self, image_name, image_tag):\n        try:\n            self.get_image(image_name, image_tag)\n            return True\n        except docker.errors.ImageNotFound:\n            return False", "response": "Returns if the image exists locally."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries to pull an image from the registry and returns it.", "response": "def try_pull_image_from_registry(self, image_name, image_tag):\n        \"\"\"\n        Tries to pull a image with the tag ``image_tag`` from registry set by ``use_registry_name``.\n        After the image is pulled, it's tagged with ``image_name``:``image_tag`` so lookup can\n        be made locally next time.\n\n        :return: A :class:`Image <docker.models.images.Image>` instance if the image exists, ``None`` otherwise.\n        :rtype: Optional[docker.models.images.Image]\n        \"\"\"\n        try:\n            image = self.client.images.pull(self.use_registry_name, image_tag)\n        except (docker.errors.ImageNotFound, docker.errors.NotFound):  # the image doesn't exist\n            logger.info(\"Tried to pull %s:%s from a registry, not found\", self.use_registry_name, image_tag)\n            return None\n\n        logger.info(\"Pulled %s:%s from registry, tagged %s:%s\", self.use_registry_name, image_tag,\n                    image_name, image_tag)\n\n        # the name and tag are different on the repo, let's tag it with local name so exists checks run smoothly\n        image.tag(image_name, image_tag)\n\n        return image"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef container_running(self, container_name):\n        filters = {\n            \"name\": container_name,\n            \"status\": \"running\",\n        }\n\n        for container in self.client.containers.list(filters=filters):\n            if container_name == container.name:\n                return container\n        return None", "response": "Returns the container with the given name if it is running."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tar_files(self, path: Path) -> bytes:\n        tarstream = BytesIO()\n        tar = tarfile.TarFile(fileobj=tarstream, mode='w')\n        tar.add(str(path), arcname=\"data\", recursive=True)\n        tar.close()\n        return tarstream.getvalue()", "response": "Returns a tar with the git repository."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tar_runner(self):\n        script_bytes = self.RUNNER.read_bytes()\n\n        tarstream = BytesIO()\n        tar = tarfile.TarFile(fileobj=tarstream, mode='w')\n\n        tarinfo = tarfile.TarInfo(name=\"runner.py\")\n        tarinfo.size = len(script_bytes)\n        tarinfo.mtime = int(time.time())\n\n        tar.addfile(tarinfo, BytesIO(script_bytes))\n        tar.close()\n\n        return tarstream.getvalue()", "response": "Returns a tar with the runner script."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a tar with the task definition.", "response": "def tar_task_definition(self, name: str, contents: str) -> bytes:\n        \"\"\" Returns a tar with the task definition.\n\n        :param name: Name of the file\n        :param contents: Contens of the definition, utf-8\n        \"\"\"\n        tarstream = BytesIO()\n        tar = tarfile.TarFile(fileobj=tarstream, mode='w')\n        tarinfo = tarfile.TarInfo(name=name)\n\n        script_bytes = contents.encode(\"utf-8\")\n\n        tarinfo.size = len(script_bytes)\n        tarinfo.mtime = int(time.time())\n        tar.addfile(tarinfo, BytesIO(script_bytes))\n        tar.close()\n\n        return tarstream.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start_container(self, image, container_name: str, repo_path: Path):\n        command = \"bash -i\"\n\n        if self.inherit_image:\n            command = \"sh -i\"\n\n        container = self.client.containers.run(image, command=command, detach=True, tty=True, name=container_name,\n                                               working_dir=str((Path(\"/srv/data\") / self.cwd).resolve()),\n                                               auto_remove=True)\n\n        container.exec_run([\"mkdir\", \"-p\", \"/srv/scripts\"])\n        container.put_archive(\"/srv\", self.tar_files(repo_path))\n        container.put_archive(\"/srv/scripts\", self.tar_runner())\n\n        return container", "response": "Starts a container with the image and name container_name and copies the repository into the container."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_image_for_repo(self, repo: str, branch: str, git_repo: Repo, repo_path: Path):\n        requirements_option, requirements_hash = self.get_requirements_information(repo_path)\n        dependencies = self.get_dependencies()\n\n        logger.info(\"Getting image based on %s, %s\", requirements_option, dependencies)\n\n        image_name = self.get_image_name(repo_path, requirements_option, dependencies)\n        image_tag = self.get_image_tag(requirements_option, requirements_hash, dependencies)\n\n        logger.info(\"Using image %s:%s\", image_name, image_tag)\n\n        if self.image_exists(image_name, image_tag):\n            image = self.get_image(image_name, image_tag)\n\n            # in case the push to registry was set later and the image wasn't pushed when built\n            if self.use_registry_name is not None and not self.registry_pull_only:\n                self.push_to_registry(image, image_tag)\n\n            return image\n\n        if self.use_registry_name is not None:\n            # the target image might have been built and pushed in a previous run already, let's try to pull it\n            image = self.try_pull_image_from_registry(image_name, image_tag)\n\n            if image is not None:  # image wasn't found\n                return image\n\n        image = self.build_image(image_name, image_tag, repo_path, requirements_option, dependencies)\n\n        if self.use_registry_name is not None and not self.registry_pull_only:\n            self.push_to_registry(image, image_tag)\n\n        return image", "response": "Gets an image for a specific repo."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the name of the container used for the repo.", "response": "def get_container_name(self, repo: str, branch: str, git_repo: Repo):\n        \"\"\" Returns the name of the container used for the repo.\n        \"\"\"\n        return \"arca_{}_{}_{}\".format(\n            self._arca.repo_id(repo),\n            branch,\n            self._arca.current_git_hash(repo, branch, git_repo, short=True)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun the script in the container.", "response": "def run(self, repo: str, branch: str, task: Task, git_repo: Repo, repo_path: Path) -> Result:\n        \"\"\" Gets or builds an image for the repo, gets or starts a container for the image and runs the script.\n\n        :param repo: Repository URL\n        :param branch: Branch ane\n        :param task: :class:`Task` to run.\n        :param git_repo: :class:`Repo <git.repo.base.Repo>` of the cloned repository.\n        :param repo_path: :class:`Path <pathlib.Path>` to the cloned location.\n        \"\"\"\n        self.check_docker_access()\n\n        container_name = self.get_container_name(repo, branch, git_repo)\n\n        container = self.container_running(container_name)\n        if container is None:\n            image = self.get_image_for_repo(repo, branch, git_repo, repo_path)\n\n            container = self.start_container(image, container_name, repo_path)\n\n        task_filename, task_json = self.serialized_task(task)\n\n        container.put_archive(\"/srv/scripts\", self.tar_task_definition(task_filename, task_json))\n\n        res = None\n\n        try:\n            command = [\"timeout\"]\n\n            if self.inherit_image:\n                if self.alpine_inherited or b\"Alpine\" in container.exec_run([\"cat\", \"/etc/issue\"], tty=True).output:\n                    self.alpine_inherited = True\n                    command = [\"timeout\", \"-t\"]\n\n            command += [str(task.timeout),\n                        \"python\",\n                        \"/srv/scripts/runner.py\",\n                        f\"/srv/scripts/{task_filename}\"]\n\n            logger.debug(\"Running command %s\", \" \".join(command))\n\n            res = container.exec_run(command, tty=True)\n\n            # 124 is the standard, 143 on alpine\n            if res.exit_code in {124, 143}:\n                raise BuildTimeoutError(f\"The task timeouted after {task.timeout} seconds.\")\n\n            return Result(res.output)\n        except BuildError:  # can be raised by  :meth:`Result.__init__`\n            raise\n        except Exception as e:\n            logger.exception(e)\n            if res is not None:\n                logger.warning(res.output)\n\n            raise BuildError(\"The build failed\", extra_info={\n                \"exception\": e,\n                \"output\": res if res is None else res.output\n            })\n        finally:\n            if not self.keep_container_running:\n                container.kill(signal.SIGKILL)\n            else:\n                self._containers.add(container)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstops all containers used by this instance of the backend.", "response": "def stop_containers(self):\n        \"\"\" Stops all containers used by this instance of the backend.\n        \"\"\"\n        while len(self._containers):\n            container = self._containers.pop()\n            try:\n                container.kill(signal.SIGKILL)\n            except docker.errors.APIError:  # probably doesn't exist anymore\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_install_requirements_dockerfile(self, name: str, tag: str, repo_path: Path,\n                                            requirements_option: RequirementsOptions) -> str:\n        \"\"\"\n        Returns the content of a Dockerfile that will install requirements based on the repository,\n        prioritizing Pipfile or Pipfile.lock and falling back on requirements.txt files\n        \"\"\"\n        if requirements_option == RequirementsOptions.requirements_txt:\n            target_file = \"requirements.txt\"\n            requirements_files = [repo_path / self.requirements_location]\n\n            install_cmd = \"pip\"\n            cmd_arguments = \"install -r /srv/requirements.txt\"\n\n        elif requirements_option == RequirementsOptions.pipfile:\n            target_file = \"\"\n            requirements_files = [repo_path / self.pipfile_location / \"Pipfile\",\n                                  repo_path / self.pipfile_location / \"Pipfile.lock\"]\n\n            install_cmd = \"pipenv\"\n            cmd_arguments = \"install --system --ignore-pipfile --deploy\"\n        else:\n            raise ValueError(\"Invalid requirements_option\")\n\n        dockerfile = self.INSTALL_REQUIREMENTS.format(\n            name=name,\n            tag=tag,\n            timeout=self.requirements_timeout,\n            target_file=target_file,\n            requirements_files=\" \".join(str(x.relative_to(repo_path.parent)) for x in requirements_files),\n            cmd_arguments=cmd_arguments,\n            install_cmd=install_cmd\n        )\n\n        logger.debug(\"Installing Python requirements with Dockerfile: %s\", dockerfile)\n\n        return dockerfile", "response": "Returns the content of a Dockerfile that will install Python requirements based on the repository."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef status():\n    import pdb; pdb.set_trace()\n    branch = git.branch\n    issue = jira.get_issue(branch)\n    if not issue:\n        return\n\n    # Print the title\n    title = issue.fields.summary\n    print \"(%s) %s\" % (branch, title)\n\n    # Print the status\n    status = issue.fields.status.name\n    assignee = issue.fields.assignee.name\n    in_progress = jira.get_datetime_issue_in_progress(issue)\n\n    if in_progress:\n        in_progress_string = in_progress.strftime(\"%a %x %I:%M %p\")\n        print '  Status: %s as of %s' % (status, in_progress_string)\n    else:\n        print '  Status: %s' % status\n\n    print '  Assignee: %s' % assignee\n\n    # Print the worklogs\n\n    # Get the timespent and return 0m if it does not exist\n    time_spent = '0m'\n    try:\n        time_spent = issue.fields.timetracking.timeSpent\n    except:\n        pass\n\n    worklogs = jira.get_worklog(issue)\n    print \"\\nTime logged (%s):\" % time_spent\n    if worklogs:\n        for worklog in worklogs:\n            worklog_hash = worklog.raw\n\n            author = worklog_hash['author']['name']\n\n            time_spent = worklog_hash.get('timeSpent', '0m')\n\n            created = dateutil.parser.parse(worklog_hash['started'])\n            created_pattern = '%a %x         '  # Adding extra space for formatting\n            if not created.hour == created.minute == created.second == 0:\n                created = created.astimezone(tzlocal())\n                created_pattern = '%a %x %I:%M %p'\n            comment = worklog_hash.get('comment', '<no comment>')\n\n            updated_string = created.strftime(created_pattern)\n            print \"  %s - %s (%s): %s\" % (updated_string, author, time_spent, comment)\n    else:\n        print \"  No worklogs\"\n\n    cycle_time = jira.get_cycle_time(issue)\n    if cycle_time:\n        print '\\nCycle Time: %.1f days' % cycle_time\n\n    # Print the time elapsed since the last mark\n    elapsed_time = jira.get_elapsed_time(issue)\n    if elapsed_time:\n        print '\\n\\033[0;32m%s elapsed\\033[00m (use \"jtime log .\" to log elapsed time or \"jtime log <duration> (ex. 30m, 1h etc.)\" to log a specific amount of time)' % (elapsed_time)\n    else:\n        print '\\n\\033[0;32m0m elapsed\\033[00m'", "response": "Gets the status of the current branch and returns the status of the current branch and the worklog status for the current branch"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef log(duration, message=None, use_last_commit_message=False):\n    branch = git.branch\n    issue = jira.get_issue(branch)\n    # Create the comment\n    comment = \"Working on issue %s\" % branch\n    if message:\n        comment = message\n    elif use_last_commit_message:\n        comment = git.get_last_commit_message()\n\n    if issue:\n        # If the duration is provided use it, otherwise use the elapsed time since the last mark\n        duration = jira.get_elapsed_time(issue) if duration == '.' else duration\n\n        if duration:\n            # Add the worklog\n            jira.add_worklog(issue, timeSpent=duration, adjustEstimate=None, newEstimate=None, reduceBy=None,\n                             comment=comment)\n\n            print \"Logged %s against issue %s (%s)\" % (duration, branch, comment)\n        else:\n            print \"No time logged, less than 0m elapsed.\"", "response": "Log the elapsed time against the current active issue."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mark():\n    branch = git.branch\n    issue = jira.get_issue(branch)\n    if not issue:\n        return\n    worklogs = jira.get_worklog(issue)\n\n    marked = False\n    if worklogs:\n        # If we have worklogs, change the updated time of the last log to the mark\n        marked = jira.touch_last_worklog(issue)\n        mark_time = datetime.datetime.now(dateutil.tz.tzlocal()).strftime(\"%I:%M %p\")\n        print \"Set mark at %s on %s by touching last work log\" % (mark_time, branch)\n    else:\n        # If we don't have worklogs, mark the issue as in progress if that is an available transition\n        jira.workflow_transition(issue, 'Open')\n        marked = jira.workflow_transition(issue, 'In Progress')\n        mark_time = datetime.datetime.now(dateutil.tz.tzlocal()).strftime(\"%I:%M %p\")\n        print 'Set mark at %s on %s by changing status to \"In Progress\"' % (mark_time, branch)\n\n    if not marked:\n        print \"ERROR: Issue %s is has a status of %s and has no worklogs.  You must log some time or re-open the issue to proceed.\" % \\\n            (branch, issue.fields.status.name)", "response": "Mark the start time for active work on an issue"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprints a list of the users tickets and provides filtering options", "response": "def me(show_all=False, show_inprogress=False, show_open=False, quiet=False):\n    \"\"\"\n    Prints a list of the users tickets and provides filtering options\n    \"\"\"\n    default = not [arg for arg in sys.argv[2:] if arg not in ('-q', '--quiet')]\n\n    status_exclusions = ['Backlog', 'Open', 'Closed']\n    status_inclusions = []\n\n    if show_inprogress or default:\n        status_inclusions.append('In Progress')\n    if show_open:\n        status_exclusions = []\n        status_inclusions.append('Open')\n    elif show_all:\n        status_exclusions = ['Closed']\n\n    jql = \\\n        \"\"\"\n            assignee=currentUser()\n            AND resolved is EMPTY\n        \"\"\"\n    # We are switching between showing everything and only showing in progress items\n    if not show_all and not show_open:\n        jql += ' AND status was \"In Progress\" '\n\n    inclusion_str = None\n    if len(status_inclusions):\n        inclusion_str = \"status in ({0})\".format((','.join('\"' + issue_status + '\"' for issue_status in status_inclusions)))\n    exclusion_str = None\n    if len(status_exclusions):\n        exclusion_str = \"status not in ({0})\".format((','.join('\"' + issue_status + '\"' for issue_status in status_exclusions)))\n    jql += \" AND ( {0} {1} {2} ) \".format(inclusion_str if inclusion_str else \"\",\n                                          \" OR \" if inclusion_str and exclusion_str else \"\",\n                                          exclusion_str if exclusion_str else \"\")\n\n    jql += \" ORDER BY updated DESC \"\n\n    results = jira.search_issues(jql)\n\n    for result in results:\n\n        issue = result.key\n        updated = dateutil.parser.parse(result.fields.updated).strftime(\"%a %x %I:%M %p\")\n        status = result.fields.status.name\n\n        cycletime = jira.get_cycle_time(result.key)\n        cycletime_str = \" -- %.1f days\" % cycletime if cycletime else \"\"\n        print \"%s (%s) %s%s\" % (issue, updated, status, cycletime_str)\n\n        # If verbose, add a line for the issue title\n        if not quiet:\n            title = result.fields.summary\n            title = (title[:75] + '..') if len(title) > 75 else title\n            print \"  %s\\n\" % title\n\n    # Print result count and usage hint for help\n    print \"\\033[0;32m%s issue(s) found\\033[00m (use 'jtime me -h' for filter options)\" % len(results)\n\n    print \"One week avg cycle time: %.1f days\" % jira.get_week_avg_cycletime()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset up the context and connectors", "response": "def main():\n    \"\"\"\n    Set up the context and connectors\n    \"\"\"\n    try:\n        init()\n    except custom_exceptions.NotConfigured:\n        configure()\n        init()\n    # Adding this in case users are trying to run without adding a jira url.\n    # I would like to take this out in a release or two.\n    # TODO: REMOVE\n    except (AttributeError, ConfigParser.NoOptionError):\n        logging.error('It appears that your configuration is invalid, please reconfigure the app and try again.')\n        configure()\n        init()\n\n    parser = argparse.ArgumentParser()\n\n    # Now simply auto-discovering the methods listed in this module\n    current_module = sys.modules[__name__]\n    module_methods = [getattr(current_module, a, None) for a in dir(current_module)\n                      if isinstance(getattr(current_module, a, None), types.FunctionType)\n                      and a != 'main']\n    argh.add_commands(parser, module_methods)\n\n    # Putting the error logging after the app is initialized because\n    # we want to adhere to the user's preferences\n    try:\n        argh.dispatch(parser)\n    # We don't want to report keyboard interrupts to rollbar\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except Exception as e:\n        if isinstance(e, jira.exceptions.JIRAError) and \"HTTP 400\" in e:\n            logging.warning('It appears that your authentication with {0} is invalid. Please re-configure jtime: `jtime configure` with the correct credentials'.format(configuration.load_config['jira'].get('url')))\n        elif configured.get('jira').get('error_reporting', True):\n            # Configure rollbar so that we report errors\n            import rollbar\n            from . import __version__ as version\n            root_path = os.path.dirname(os.path.realpath(__file__))\n            rollbar.init('7541b8e188044831b6728fa8475eab9f', 'v%s' % version, root=root_path)\n            logging.error('Sorry. It appears that there was an error when handling your command. '\n                          'This error has been reported to our error tracking system. To disable '\n                          'this reporting, please re-configure the app: `jtime config`.')\n            extra_data = {\n                # grab the command that we're running\n                'cmd': sys.argv[1],\n                # we really don't want to see jtime in the args\n                'args': sys.argv[2:],\n                # lets grab anything useful, python version?\n                'python': str(sys.version),\n            }\n            # We really shouldn't thit this line of code when running tests, so let's not cover it.\n            rollbar.report_exc_info(extra_data=extra_data)  # pragma: no cover\n        else:\n            logging.error('It appears that there was an error when handling your command.')\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_string(cls, contents, **kwargs):\n\t\tlines = contents.splitlines()\n\t\ttitle = None\n\t\tdescription = None\n\n\t\tline = lines.pop(0)\n\t\twhile line != '':\n\t\t\tif not title and line.startswith('#'):\n\t\t\t\ttitle = line[1:].strip()\n\t\t\telif line.startswith('title:'):\n\t\t\t\ttitle = line[6:].strip()\n\t\t\telif line.startswith('description:'):\n\t\t\t\tdescription = line[12:].strip()\n\t\t\telif line.startswith('subtitle:'):\n\t\t\t\tkwargs['subtitle'] = line[9:].strip()\n\t\t\telif line.startswith('comments:'):\n\t\t\t\ttry:\n\t\t\t\t\tkwargs['allow_comments'] = _str_to_bool(line[9:])\n\t\t\t\texcept ValueError:\n\t\t\t\t\tLOG.warning('invalid boolean value for comments', exc_info=True)\n\n\t\t\tcls.process_meta(line, kwargs)\n\n\t\t\tline = lines.pop(0)\n\n\t\t# the only lines left should be the actual contents\n\t\tbody = '\\n'.join(lines).strip()\n\t\texcerpt = _get_excerpt(body)\n\t\tif description is None:\n\t\t\tdescription = _get_description(excerpt, 160)\n\t\tif issubclass(cls, Post):\n\t\t\tkwargs['excerpt'] = render_markdown(excerpt)\n\t\tbody = render_markdown(body)\n\n\t\treturn cls(title=title, body=body, description=description, **kwargs)", "response": "Given a string create an Entry object from it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing a line of metadata found in the markdown.", "response": "def process_meta(cls, line, kwargs):\n\t\t\"\"\"\n\t\tProcess a line of metadata found in the markdown.\n\n\t\tLines are usually in the format of \"key: value\".\n\n\t\tModify the kwargs dict in order to change or add new kwargs that should\n\t\tbe passed to the class's constructor.\n\t\t\"\"\"\n\t\tif line.startswith('slug:'):\n\t\t\tkwargs['slug'] = line[5:].strip()\n\n\t\telif line.startswith('public:'):\n\t\t\ttry:\n\t\t\t\tkwargs['public'] = _str_to_bool(line[7:])\n\t\t\texcept ValueError:\n\t\t\t\tLOG.warning('invalid boolean value for public', exc_info=True)\n\n\t\telif line.startswith('private:'):\n\t\t\ttry:\n\t\t\t\tkwargs['public'] = not _str_to_bool(line[8:])\n\t\t\texcept ValueError:\n\t\t\t\tLOG.warning('invalid boolean value for private', exc_info=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives a markdown file get an Entry object.", "response": "def from_file(cls, path, **kwargs):\n\t\t\"\"\"\n\t\tGiven a markdown file, get an Entry object.\n\t\t\"\"\"\n\t\tLOG.debug('creating %s from \"%s\"', cls, path)\n\n\t\t# the filename will be the default slug - can be overridden later\n\t\tkwargs['slug'] = os.path.splitext(os.path.basename(path))[0]\n\n\t\t# TODO: ideally this should be part of the Post class.\n\t\t# if a pubdate isn't explicitly passed, get it from the file metadata\n\t\t# instead. note that it might still be overriden later on while reading\n\t\t# the file contents.\n\t\tif issubclass(cls, Post) and not kwargs.get('pubdate'):\n\t\t\t# you would think creation always comes before modification, but you\n\t\t\t# can manually modify a file's modification date to one earlier than\n\t\t\t# the creation date. this lets you set a post's pubdate by running\n\t\t\t# the command `touch`. we support this behaviour by simply finding\n\t\t\t# the chronologically earliest date of creation and modification.\n\t\t\ttimestamp = min(os.path.getctime(path), os.path.getmtime(path))\n\t\t\tkwargs['pubdate'] = datetime.fromtimestamp(timestamp)\n\n\t\twith open(path, 'r') as file:\n\t\t\tentry = cls.from_string(file.read(), **kwargs)\n\n\t\treturn entry"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking a Tag object from a tag name.", "response": "def make_tag(cls, tag_name):\n\t\t\"\"\"\n\t\tMake a Tag object from a tag name. Registers it with the content manager\n\t\tif possible.\n\t\t\"\"\"\n\t\tif cls.cm:\n\t\t\treturn cls.cm.make_tag(tag_name)\n\t\treturn Tag(tag_name.strip())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget ADS journal abbreviation for a given publication name.", "response": "def get_pub_abbreviation(pubstring, numBest=5, exact=None):\n    \"\"\"\n    Get ADS journal abbreviation (\"bibstem\") candidates for a given publication name.\n    * 'exact': if True results will only be returned if an exact match was found\n    * 'numBest': maximum number of guesses to return\n    A list of tuples will be returned, each tuple consisting of a score and a bibstem\n    \"\"\"\n    if exact:\n        # Only try to find exact matches\n        bibstems = _defaultSourcematcher.getExactMatch(string.upper(pubstring))\n    else:\n        # Allow fuzzy matching\n        bibstems = _defaultSourcematcher.getBestMatches(string.upper(pubstring), numBest)\n        if re.search(r\"L(ett(ers)?)?$\",pubstring):\n            addit = _defaultSourcematcher.getBestMatches(re.sub(r\"(?i)\\s*L(ett(ers)?)?$\", \"\", pubstring.upper()), 2)\n            if addit:\n                bibstems.extend(addit)\n                bibstems.sort()\n    # Make the list of results unique\n    try:\n        bibstems = list(set(bibstems))\n    except:\n        bibstems = []\n    # Sort the list of results from highest score to lowest score\n    bibstems.sort(key=lambda tup: tup[0], reverse=True)\n\n    return bibstems"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_item(self, path):\n        if self.source_folder:\n            item_path = '%s/%s/%s' % (\n                    current_app.static_folder,\n                    self.source_folder,\n                    path.strip('/')\n                )\n        else:\n            item_path = '%s/%s' % (\n                    current_app.static_folder,\n                    path.strip('/')\n                )\n\n        if os.path.isfile(item_path):\n            try:\n                return Image.open(item_path)\n            except IOError as err:\n                LOGGER.warning('File not found on path \"%s\" with error: %s' % (item_path, str(err)))\n                return False\n        else:\n            return False", "response": "Get resource item by path"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_cached_item(self, path, content):\n        if isinstance(content, Image.Image):\n            item_path = '%s/%s/%s' % (\n                current_app.static_folder,\n                self.cache_folder,\n                path.strip('/')\n            )\n            self.make_dirs(item_path)\n\n            content.save(item_path)\n\n            if os.path.isfile(item_path):\n                return '%s/%s/%s' % (current_app.static_url_path, self.cache_folder, path.strip('/'))\n            else:  # pragma: no cover\n                LOGGER.warning('File is not created on path: %s' % item_path)\n                return False\n        else:\n            return False", "response": "Create cached resource item"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_cached_item(self, path):\n        item_path = '%s/%s/%s' % (\n                current_app.static_folder,\n                self.cache_folder,\n                path.strip('/')\n            )\n\n        if os.path.isfile(item_path):\n            try:\n                return Image.open(item_path)\n            except IOError as err:  # pragma: no cover\n                LOGGER.warning('Cached file not found on path \"%s\" with error: %s' % (item_path, str(err)))\n                return False\n        else:\n            return False", "response": "Get cached resource item by path"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if a cached resource item exists in the cache folder.", "response": "def check_cached_item(self, path):\n        \"\"\"\n        Check for cached resource item exists\n        :param path: str\n        :return: bool\n        \"\"\"\n        item_path = '%s/%s/%s' % (\n                current_app.static_folder,\n                self.cache_folder,\n                path.strip('/')\n            )\n\n        if os.path.isfile(item_path):\n            return '%s/%s/%s' % (current_app.static_url_path, self.cache_folder, path.strip('/'))\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_cached_item(self, path):\n        item_path = '%s/%s/%s' % (\n                current_app.static_folder,\n                self.cache_folder,\n                path.strip('/')\n            )\n\n        if os.path.isfile(item_path):\n            os.remove(item_path)\n\n        return True", "response": "Remove cached item from cache folder"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating directories if not exist.", "response": "def make_dirs(path):\n        \"\"\"\n        Create directories if not exist\n        :param path: string\n        :return:\n        \"\"\"\n        try:\n            os.makedirs(os.path.dirname(path))\n        except OSError as err:\n            if err.errno != errno.EEXIST:\n                LOGGER.error('Failed to create directory %s with error: %s' % (path, str(err)))\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef luminosity_to_flux(lumErg_S, dist_Mpc):\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    import numpy as np\n    import math\n    ## LOCAL APPLICATION ##\n\n    ################ > VARIABLE SETTINGS ######\n\n    ################ >ACTION(S) ################\n    # Convert the distance to cm\n    distCm = dist_Mpc * MPC_2_CMS\n    fluxErg_cm2_S = lumErg_S / (4 * np.pi * distCm ** 2)\n\n    return fluxErg_cm2_S", "response": "Convert a luminosity in ergs to a flux in ergs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfunctioning to create argument getter factory.", "response": "def argument_getter_factory(route_spec):\n    \"\"\" \u6839\u636espec\u6765\u751f\u6210handler\u51fd\u6570\u53c2\u6570\u503c\u8bfb\u53d6\u5668 \"\"\" \n    \n    func_sig = inspect.signature(route_spec.handler_func)\n\n    param_names = list(func_sig.parameters.keys())\n    arg_getters  = build_argval_getters(route_spec)\n    n_args = len(arg_getters)\n\n    async def argument_getters(request):\n        errors = None\n        values = {}\n        for i in range(n_args):\n            try:\n                arg_name = param_names[i]\n                values[arg_name] = await arg_getters[i](request)\n            except HTTPException:\n                raise\n            except Exception as exc :\n                if errors is None: \n                    errors = []\n\n                request.app.logger.error('', exc_info=True)\n\n                exc_type = type(exc)\n\n                data = {\n                    \"name\": arg_name, \n                    \"type\": f\"{exc_type.__module__}.{exc_type.__qualname__}\",\n                    \"error\": str(exc)\n                }\n\n                errors.append(data)\n\n        if errors is not None:\n            raise RESTfulArgumentError(errors)\n\n        return values\n\n    return argument_getters"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_model(self, m):\n        self._model = m\n        self.new_root.emit(QtCore.QModelIndex())\n        self.model_changed(m)", "response": "Sets the model that the level should use for the item."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_model(self, model):\n        # do the set model in reverse!\n        # set model might trigger an update for the lower levels\n        # but the lower ones have a different model, so it will fail anyways\n        # this way the initial state after set_model is correct.\n        self.model = model\n        self._levels[0].set_model(model)", "response": "Sets the model of the items in the levels list"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the level s root of the given depth to index.", "response": "def set_root(self, depth, index):\n        \"\"\"Set the level\\'s root of the given depth to index\n\n        :param depth: the depth level\n        :type depth: int\n        :param index: the new root index\n        :type index: QtCore.QModelIndex\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if depth < len(self._levels):\n            self._levels[depth].set_root(index)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _new_level(self, depth):\n        l = self.create_level(depth)\n        h = self.create_header(depth)\n        self.add_lvl_to_ui(l, h)\n        l.new_root.connect(partial(self.set_root, depth+1))\n        self._levels.append(l)", "response": "Create a new level and header and connect signals"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the given index as the root of the combobox.", "response": "def set_root(self, index):\n        \"\"\"Set the given index as root index of the combobox\n\n        :param index: the new root index\n        :type index: QtCore.QModelIndex\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not index.isValid():\n            self.setCurrentIndex(-1)\n            return\n        if self.model() != index.model():\n            self.setModel(index.model())\n        self.setRootModelIndex(index)\n        if self.model().rowCount(index):\n            self.setCurrentIndex(0)\n        else:\n            self.setCurrentIndex(-1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the current index in a list", "response": "def selected_indexes(self, ):\n        \"\"\"Return the current index\n\n        :returns: the current index in a list\n        :rtype: list of QtCore.QModelIndex\n        :raises: None\n        \"\"\"\n        i = self.model().index(self.currentIndex(), 0, self.rootModelIndex())\n        return [i]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef current_changed(self, i):\n        m = self.model()\n        ri = self.rootModelIndex()\n        index = m.index(i, 0, ri)\n        self.new_root.emit(index)", "response": "Slot for when the current index changes."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates the layouts and set some attributes of the ui", "response": "def setup_ui(self, ):\n        \"\"\"Create the layouts and set some attributes of the ui\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        grid = QtGui.QGridLayout(self)\n        grid.setContentsMargins(0, 0, 0, 0)\n        self.setLayout(grid)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating and return a widget that will be used as a header for the given depth", "response": "def create_header(self, depth):\n        \"\"\"Create and return a widget that will be used as a header for the given depth\n\n        Override this method if you want to have header widgets.\n        The default implementation returns None.\n        You can return None if you do not want a header for the given depth\n\n        :param depth: the depth level\n        :type depth: int\n        :returns: a Widget that is used for the header or None\n        :rtype: QtGui.QWidget|None\n        :raises: None\n        \"\"\"\n        if not (depth >= 0 and depth < len(self._headertexts)):\n            return\n        txt = self._headertexts[depth]\n        if txt is None:\n            return\n        lbl = QtGui.QLabel(txt, self)\n        return lbl"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_lvl_to_ui(self, level, header):\n        lay = self.layout()\n        rc = lay.rowCount()\n        lay.addWidget(level, rc+1, 1)\n        if header is not None:\n            lay.addWidget(header, rc+1, 0)\n        lay.setColumnStretch(1,1)", "response": "Insert the level and header into the ui."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling when the model of the level instance has changed", "response": "def model_changed(self, model):\n        \"\"\"Apply the model to the combobox\n\n        When a level instance is created, the model is None. So it has to be set afterwards.\n        Then this method will be called and your level should somehow use the model\n\n        :param model: the model that the level should use\n        :type model: QtCore.QAbstractItemModel\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.setModel(model)\n        # to update all lists belwo\n        # current changed is not triggered by setModel somehow\n        if model is not None:\n            self.setCurrentIndex(self.model().index(0, 0))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_root(self, index):\n        if not index.isValid():\n            self.setModel(None) # so we will not see toplevel stuff\n            self.setCurrentIndex(QtCore.QModelIndex())\n            self.new_root.emit(QtCore.QModelIndex())\n            return\n        if self.model() != index.model():\n            self.setModel(index.model())\n        self.setRootIndex(index)\n        if self.model().hasChildren(index):\n            self.setCurrentIndex(self.model().index(0, 0, index))\n            self.new_root.emit(self.model().index(0, 0, index))\n        else:\n            self.new_root.emit(QtCore.QModelIndex())", "response": "Sets the given index as the root index of the list\n           ."}
