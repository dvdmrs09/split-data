{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, gist, content):\n        # abort if content is False\n        if content is False:\n            return False\n\n        # request\n        url = self._api_url(\"gists\", gist.get(\"id\"))\n        data = {\"files\": {self.filename: {\"content\": content}}}\n        self.output(\"Sending contents of {} to {}\".format(self.file_path, url))\n        response = self.requests.patch(url, data=dumps(data))\n\n        # error\n        if response.status_code != 200:\n            self.oops(\"Could not update \" + gist.get(\"description\"))\n            self.oops(\"PATCH request returned \" + str(response.status_code))\n            return False\n\n        # success\n        self.yeah(\"Done!\")\n        self.hey(\"The URL to this Gist is: {}\".format(gist[\"url\"]))\n        return True", "response": "Updates the contents of a gist at GitHub."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(self, content, **kwargs):\n        # abort if content is False\n        if content is False:\n            return False\n\n        # set new gist\n        public = bool(kwargs.get(\"public\", True))\n        data = {\n            \"description\": self.filename,\n            \"public\": public,\n            \"files\": {self.filename: {\"content\": content}},\n        }\n\n        # send request\n        url = self._api_url(\"gists\")\n        self.output(\"Sending contents of {} to {}\".format(self.file_path, url))\n        response = self.requests.post(url, data=dumps(data))\n\n        # error\n        if response.status_code != 201:\n            self.oops(\"Could not create \" + self.filename)\n            self.oops(\"POST request returned \" + str(response.status_code))\n            return False\n\n        # parse created gist\n        gist = self._parse_gist(response.json())\n\n        # success\n        self.yeah(\"Done!\")\n        self.hey(\"The URL to this Gist is: {}\".format(gist[\"url\"]))\n        return True", "response": "Create a new gist."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nasks user which gist to use in case of more than one gist matching the instance filename.", "response": "def _ask_which_gist(self, matches):\n        \"\"\"\n        Asks user which gist to use in case of more than one gist matching the\n        instance filename.\n        :param matches: (list) of dictioaries generated within select_gists()\n        :return: (dict) of the selected gist\n        \"\"\"\n        # ask user which gist to use\n        self.hey(\"Use {} from which gist?\".format(self.filename))\n        for count, gist in enumerate(matches, 1):\n            self.hey(\"[{}] {}\".format(count, gist.get(\"description\")))\n\n        # get the gist index\n        selected = False\n        while not selected:\n            gist_index = prompt(\"Type the number: \", type=int) - 1\n            try:\n                selected = matches[gist_index]\n            except IndexError:\n                self.oops(\"Invalid number, please try again.\")\n\n        self.output(\"Using `{}` Gist\".format(selected[\"description\"]))\n        return selected"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreceive a gist dict and parse it to GetGist", "response": "def _parse_gist(gist):\n        \"\"\"Receive a gist (dict) and parse it to GetGist\"\"\"\n\n        # parse files\n        files = list()\n        file_names = sorted(filename for filename in gist[\"files\"].keys())\n        for name in file_names:\n            files.append(\n                dict(filename=name, raw_url=gist[\"files\"][name].get(\"raw_url\"))\n            )\n\n        # parse description\n        description = gist[\"description\"]\n        if not description:\n            names = sorted(f.get(\"filename\") for f in files)\n            description = names.pop(0)\n\n        return dict(\n            description=description,\n            id=gist.get(\"id\"),\n            files=files,\n            url=gist.get(\"html_url\"),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef indent(self, message):\n        indent = self.indent_char * self.indent_size\n        return indent + message", "response": "Sets the indent for standardized output\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, url, params=None, **kwargs):\n        return requests.get(url, params=params, headers=self.add_headers(**kwargs))", "response": "Encapsulte requests. get to use this class instance header"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef patch(self, url, data=None, **kwargs):\n        return requests.patch(url, data=data, headers=self.add_headers(**kwargs))", "response": "Encapsulte requests. patch to use this class instance header"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef post(self, url, data=None, **kwargs):\n        return requests.post(url, data=data, headers=self.add_headers(**kwargs))", "response": "Encapsulte requests. post to use this class instance header"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save(self, content):\n        # backup existing file if needed\n        if os.path.exists(self.file_path) and not self.assume_yes:\n            message = \"Overwrite existing {}? (y/n) \"\n            if not confirm(message.format(self.filename)):\n                self.backup()\n\n        # write file\n        self.output(\"Saving \" + self.filename)\n        with open(self.file_path, \"wb\") as handler:\n            if not isinstance(content, bytes):\n                content = bytes(content, \"utf-8\")\n            handler.write(content)\n        self.yeah(\"Done!\")", "response": "Save any given content to the instance file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef backup(self):\n        count = 0\n        name = \"{}.bkp\".format(self.filename)\n        backup = os.path.join(self.cwd, name)\n        while os.path.exists(backup):\n            count += 1\n            name = \"{}.bkp{}\".format(self.filename, count)\n            backup = os.path.join(self.cwd, name)\n        self.hey(\"Moving existing {} to {}\".format(self.filename, name))\n        os.rename(os.path.join(self.cwd, self.filename), backup)", "response": "Backups files with the same name of the instance filename"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the contents of a file in the local file system.", "response": "def read(self, file_path=None):\n        \"\"\"\n        Read the contents of a file.\n        :param filename: (str) path to a file in the local file system\n        :return: (str) contents of the file, or (False) if not found/not file\n        \"\"\"\n        if not file_path:\n            file_path = self.file_path\n\n        # abort if the file path does not exist\n        if not os.path.exists(file_path):\n            self.oops(\"Sorry, but {} does not exist\".format(file_path))\n            return False\n\n        # abort if the file path is not a file\n        if not os.path.isfile(file_path):\n            self.oops(\"Sorry, but {} is not a file\".format(file_path))\n            return False\n\n        with open(file_path) as handler:\n            return handler.read()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef str_matcher(mode):\r\n\r\n    def f_raw(inp_str, pos):\r\n        return unique_literal_cache_pool[mode] if inp_str.startswith(mode, pos) else None\r\n\r\n    def f_collection(inp_str, pos):\r\n        for each in mode:\r\n            if inp_str.startswith(each, pos):\r\n                return unique_literal_cache_pool[each]\r\n        return None\r\n\r\n    if isinstance(mode, str):\r\n        return f_raw\r\n\r\n    if len(mode) is 1:\r\n        mode = mode[0]\r\n        return f_raw\r\n\r\n    return f_collection", "response": "Returns a function that returns a list of tokens that match the input string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef regex_matcher(regex_pat):\r\n    if isinstance(regex_pat, str):\r\n        regex_pat = re.compile(regex_pat)\r\n\r\n    def f(inp_str, pos):\r\n        m = regex_pat.match(inp_str, pos)\r\n        return m.group() if m else None\r\n\r\n    return f", "response": "generate token names cache\r\n    generate token names"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ast_for_stmts(self, stmts: T) -> None:\r\n        if not stmts:\r\n            raise ValueError('no ast found!')\r\n        head, *equals = stmts\r\n\r\n        if head.name is NameEnum.TokenDef:\r\n            self.ast_for_token_def(head)\r\n        elif head.name is NameEnum.TokenIgnore:\r\n            self.ast_for_token_ignore(head)\r\n        else:\r\n            self.ast_for_equals(head)\r\n\r\n        for each in equals:\r\n            self.ast_for_equals(each)\r\n\r\n        # if every combined parser can reach any other combined, \r\n        # just take any of them and compile it!\r\n        if not self.compile_helper.alone and self._current__combined_parser_name:\r\n            self.compile_helper.alone.add(self._current__combined_parser_name)", "response": "Add the ast for the given list of statements."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _request(self, method, resource_uri, **kwargs):\n        data = kwargs.get('data')\n        response = method(self.API_BASE_URL + resource_uri,\n                          json=data, headers=self.headers)\n        response.raise_for_status()\n        return response.json()", "response": "Perform a method on a resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a resource s nacms.", "response": "def get(self, endpoint, **kwargs):\n        \"\"\"Get a resource.\n\n        Args:\n            endpoint: resource endpoint.\n        \"\"\"\n        return self._request(requests.get, endpoint, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a resource. Args: endpoint: resource endpoint.", "response": "def post(self, endpoint, **kwargs):\n        \"\"\"Create a resource.\n\n        Args:\n            endpoint: resource endpoint.\n        \"\"\"\n        return self._request(requests.post, endpoint, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef put(self, endpoint, **kwargs):\n        return self._request(requests.put, endpoint, **kwargs)", "response": "Update a resource s nacms."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake Slack formatted text and returns HTML.", "response": "def render(txt):\n    \"\"\"\n    Accepts Slack formatted text and returns HTML.\n    \"\"\"\n\n    # Removing links to other channels\n    txt = re.sub(r'<#[^\\|]*\\|(.*)>', r'#\\g<1>', txt)\n\n    # Removing links to other users\n    txt = re.sub(r'<(@.*)>', r'\\g<1>', txt)\n\n    # handle named hyperlinks\n    txt = re.sub(r'<([^\\|]*)\\|([^\\|]*)>', r'<a href=\"\\g<1>\" target=\"blank\">\\g<2></a>', txt)\n\n    # handle unnamed hyperlinks\n    txt = re.sub(r'<([^a|/a].*)>', r'<a href=\"\\g<1>\" target=\"blank\">\\g<1></a>', txt)\n\n    # handle ordered and unordered lists\n    for delimeter in LIST_DELIMITERS:\n        slack_tag = delimeter\n        class_name = LIST_DELIMITERS[delimeter]\n\n        # Wrap any lines that start with the slack_tag in <li></li>\n        list_regex = u'(?:^|\\n){}\\s?(.*)'.format(slack_tag)\n        list_repl = r'<li class=\"list-item-{}\">\\g<1></li>'.format(class_name)\n        txt = re.sub(list_regex, list_repl, txt)\n\n    # hanlde blockquotes\n    txt = re.sub(u'(^|\\n)(?:&gt;){3}\\s?(.*)$', r'\\g<1><blockquote>\\g<2></blockquote>', txt, flags=re.DOTALL)\n    txt = re.sub(u'(?:^|\\n)&gt;\\s?(.*)\\n?', r'<blockquote>\\g<1></blockquote>', txt)\n\n    # handle code blocks\n    txt = re.sub(r'```\\n?(.*)```', r'<pre>\\g<1></pre>', txt, flags=re.DOTALL)\n    txt = re.sub(r'\\n(</pre>)', r'\\g<1>', txt)\n\n    # handle bolding, italics, and strikethrough\n    for wrapper in FORMATTERS:\n        slack_tag = wrapper\n        html_tag = FORMATTERS[wrapper]\n\n        # Grab all text in formatted characters on the same line unless escaped\n        regex = r'(?<!\\\\)\\{t}([^\\{t}|\\n]*)\\{t}'.format(t=slack_tag)\n        repl = r'<{t}>\\g<1></{t}>'.format(t=html_tag)\n        txt = re.sub(regex, repl, txt)\n\n    # convert line breaks\n    txt = txt.replace('\\n', '<br />')\n\n    # clean up bad HTML\n    parser = CustomSlackdownHTMLParser(txt)\n    txt = parser.clean()\n\n    # convert multiple spaces\n    txt = txt.replace(r'  ', ' &nbsp')\n\n    return txt"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _open_list(self, list_type):\n        if list_type in LIST_TYPES.keys():\n            tag = LIST_TYPES[list_type]\n        else:\n            raise Exception('CustomSlackdownHTMLParser:_open_list: Not a valid list type.')\n\n        html = '<{t} class=\"list-container-{c}\">'.format(\n            t=tag,\n            c=list_type\n        )\n        self.cleaned_html += html\n        self.current_parent_element['tag'] = LIST_TYPES[list_type]\n        self.current_parent_element['attrs'] = {'class': list_type}", "response": "Add an open list tag corresponding to the specification in the LIST_TYPES."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd an close list tag corresponding to the currently open list found in current_parent_element.", "response": "def _close_list(self):\n        \"\"\"\n        Add an close list tag corresponding to the currently open\n        list found in current_parent_element.\n        \"\"\"\n        list_type = self.current_parent_element['attrs']['class']\n        tag = LIST_TYPES[list_type]\n\n        html = '</{t}>'.format(\n            t=tag\n        )\n        self.cleaned_html += html\n        self.current_parent_element['tag'] = ''\n        self.current_parent_element['attrs'] = {}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling the start tag of the element.", "response": "def handle_starttag(self, tag, attrs):\n        \"\"\"\n        Called by HTMLParser.feed when a start tag is found.\n        \"\"\"\n        # Parse the tag attributes\n        attrs_dict = dict(t for t in attrs)\n\n        # If the tag is a predefined parent element\n        if tag in PARENT_ELEMENTS:\n            # If parser is parsing another parent element\n            if self.current_parent_element['tag'] != '':\n                # close the parent element\n                self.cleaned_html += '</{}>'.format(self.current_parent_element['tag'])\n\n            self.current_parent_element['tag'] = tag\n            self.current_parent_element['attrs'] = {}\n\n            self.cleaned_html += '<{}>'.format(tag)\n\n        # If the tag is a list item\n        elif tag == 'li':\n            self.parsing_li = True\n\n            # Parse the class name & subsequent type\n            class_name = attrs_dict['class']\n            list_type = class_name[10:]\n\n            # Check if parsing a list\n            if self.current_parent_element['tag'] == 'ul' or self.current_parent_element['tag'] == 'ol':\n                cur_list_type = self.current_parent_element['attrs']['class']\n                # Parsing a different list\n                if cur_list_type != list_type:\n                    # Close that list\n                    self._close_list()\n\n                    # Open new list\n                    self._open_list(list_type)\n            # Not parsing a list\n            else:\n                # if parsing some other parent\n                if self.current_parent_element['tag'] != '':\n                    self.cleaned_html += '</{}>'.format(self.current_parent_element['tag'])\n                # Open new list\n                self._open_list(list_type)\n\n            self.cleaned_html += '<{}>'.format(tag)\n\n        # If the tag is a line break\n        elif tag == 'br':\n            # If parsing a paragraph, close it\n            if self.current_parent_element['tag'] == 'p':\n                self.cleaned_html += '</p>'\n                self.current_parent_element['tag'] = ''\n                self.current_parent_element['attrs'] = {}\n            # If parsing a list, close it\n            elif self.current_parent_element['tag'] == 'ul' or self.current_parent_element['tag'] == 'ol':\n                self._close_list()\n            # If parsing any other parent element, keep it\n            elif self.current_parent_element['tag'] in PARENT_ELEMENTS:\n                self.cleaned_html += '<br />'\n            # If not in any parent element, create an empty paragraph\n            else:\n                self.cleaned_html += '<p></p>'\n\n        # If the tag is something else, like a <b> or <i> tag\n        else:\n            # If not parsing any parent element\n            if self.current_parent_element['tag'] == '':\n                self.cleaned_html += '<p>'\n                self.current_parent_element['tag'] = 'p'\n            self.cleaned_html += '<{}'.format(tag)\n\n            for attr in sorted(attrs_dict.keys()):\n                self.cleaned_html += ' {k}=\"{v}\"'.format(\n                    k=attr,\n                    v=attrs_dict[attr]\n                )\n\n            self.cleaned_html += '>'"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall by HTMLParser. feed when an end tag is found.", "response": "def handle_endtag(self, tag):\n        \"\"\"\n        Called by HTMLParser.feed when an end tag is found.\n        \"\"\"\n        if tag in PARENT_ELEMENTS:\n            self.current_parent_element['tag'] = ''\n            self.current_parent_element['attrs'] = ''\n\n        if tag == 'li':\n            self.parsing_li = True\n        if tag != 'br':\n            self.cleaned_html += '</{}>'.format(tag)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle_data(self, data):\n        if self.current_parent_element['tag'] == '':\n            self.cleaned_html += '<p>'\n            self.current_parent_element['tag'] = 'p'\n\n        self.cleaned_html += data", "response": "Called by HTMLParser. feed when text is found."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves formatting tags added to pre elements.", "response": "def _remove_pre_formatting(self):\n        \"\"\"\n        Removes formatting tags added to pre elements.\n        \"\"\"\n        preformatted_wrappers = [\n            'pre',\n            'code'\n        ]\n\n        for wrapper in preformatted_wrappers:\n            for formatter in FORMATTERS:\n                tag = FORMATTERS[formatter]\n                character = formatter\n\n                regex = r'(<{w}>.*)<{t}>(.*)</{t}>(.*</{w}>)'.format(\n                    t=tag,\n                    w=wrapper\n                )\n                repl = r'\\g<1>{c}\\g<2>{c}\\g<3>'.format(c=character)\n                self.cleaned_html = re.sub(regex, repl, self.cleaned_html)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clean(self):\n        # Calls handle_starttag, handle_endtag, and handle_data\n        self.feed()\n\n        # Clean up any parent tags left open\n        if self.current_parent_element['tag'] != '':\n            self.cleaned_html += '</{}>'.format(self.current_parent_element['tag'])\n\n        # Remove empty <p> added after lists\n        self.cleaned_html = re.sub(r'(</[u|o]l>)<p></p>', r'\\g<1>', self.cleaned_html)\n\n        self._remove_pre_formatting()\n\n        return self.cleaned_html", "response": "Cleans up any problematic HTML."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render_author(**kwargs):\n    html = '<div class=\"user\">'\n\n    author_avatar = kwargs.get('author_avatar', None)\n    if author_avatar:\n        html += '<img class=\"user-avatar\" src=\"{}\">'.format(author_avatar)\n\n    author_name = kwargs.get('author_name', None)\n    if author_name:\n        html += '<p class=\"user-name\">'\n\n        author_link = kwargs.get('author_link', None)\n        if author_link:\n            html += '<a href=\"{author_link}\">{author_name}</a>'.format(\n                author_link=author_link,\n                author_name=author_name\n            )\n        else:\n            html += author_name\n\n        html += '</p>'\n\n    author_handle = kwargs.get('author_handle', None)\n    if author_handle:\n        html += '<p class=\"user-handle\">{}</p>'.format(author_handle)\n\n    html += '</div>'", "response": "Unstrict template block for rendering authors:\n    <div class=\"author\">\n        <img class=\"author-avatar\" src=\"{author_avatar}\">\n        <p class=\"author-name\">\n            <a href=\"{author_link}\">{author_name}</a>\n        </p>\n        <p class=\"user-handle\">{author_handle}</p>\n    </div>"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef render_metadata(**kwargs):\n    html = '<div class=\"metadata\">'\n\n    service_logo = kwargs.get('service_logo', None)\n    if service_logo:\n        html += '<img class=\"metadata-logo\" src=\"{}\">'.format(service_logo)\n\n    service_name = kwargs.get('service_name', None)\n    if service_name:\n        html += '<p class=\"metadata-name\">{}</p>'.format(service_name)\n\n    timestamp = kwargs.get('timestamp', None)\n    if timestamp:\n        html += '<p class=\"user-name\">'\n\n        timestamp_link = kwargs.get('timestamp_link', None)\n        if timestamp_link:\n            html += '<a href=\"{timestamp_link}\">{timestamp}</a>'.format(\n                timestamp_link=timestamp_link,\n                timestamp=timestamp\n            )\n        else:\n            html += timestamp\n\n        html += '</p>'\n\n    html += '</div>'", "response": "Render the metadata page."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef render_image(**kwargs):\n    html = ''\n\n    url = kwargs.get('url', None)\n    if url:\n        html = '<img'\n\n        alt_text = kwargs.get('alt_text', None)\n        if alt_text:\n            html += ' alt=\"{}\"'.format(alt_text)\n\n        title = kwargs.get('title', None)\n        if title:\n            html += ' title=\"{}\"'.format(title)\n\n        html += ' src=\"{}\">'.format(url)\n\n    return html", "response": "Render an image in a non - strict template block."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrendering a twitter embed.", "response": "def render_twitter(text, **kwargs):\n    \"\"\"\n    Strict template block for rendering twitter embeds.\n    \"\"\"\n    author = render_author(**kwargs['author'])\n    metadata = render_metadata(**kwargs['metadata'])\n    image = render_image(**kwargs['image'])\n\n    html = \"\"\"\n        <div class=\"attachment attachment-twitter\">\n            {author}\n            <p class=\"twitter-content\">{text}</p>\n            {metadata}\n            {image}\n        </div>\n    \"\"\".format(\n        author=author,\n        text=text,\n        metadata=metadata,\n        image=image\n    ).strip()\n\n    return html"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the model params from the given LAB directory.", "response": "def get_model(LAB_DIR):\n    \"\"\" Cannon model params \"\"\"\n    coeffs = np.load(\"%s/coeffs.npz\" %LAB_DIR)['arr_0']\n    scatters = np.load(\"%s/scatters.npz\" %LAB_DIR)['arr_0']\n    chisqs = np.load(\"%s/chisqs.npz\" %LAB_DIR)['arr_0']\n    pivots = np.load(\"%s/pivots.npz\" %LAB_DIR)['arr_0']\n    return coeffs, scatters, chisqs, pivots"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_labels(ids_find):\n    a = pyfits.open(\"%s/lamost_catalog_full.fits\" %LAB_DIR)\n    data = a[1].data\n    a.close()\n    id_all = data['lamost_id']\n    id_all = np.array(id_all)\n    id_all = np.array([val.strip() for val in id_all])\n    snr_all = data['cannon_snrg']\n    chisq_all = data['cannon_chisq']\n    teff = data['cannon_teff']\n    logg = data['cannon_logg']\n    feh = data['cannon_m_h']\n    afe = data['cannon_alpha_m']\n    ak = data['cannon_a_k']\n    labels = np.vstack((teff,logg,feh,afe,ak))\n    choose = np.in1d(id_all, ids_find)\n    id_choose = id_all[choose]\n    label_choose = labels[:,choose]\n    snr_choose = snr_all[choose]\n    chisq_choose = chisq_all[choose]\n    inds = np.array([np.where(id_choose==val)[0][0] for val in ids_find])\n    print(id_choose[inds][100])\n    print(ids_find[100])\n    return label_choose[:,inds], snr_choose[inds], chisq_choose[inds]", "response": "Get labels for a list of ids"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the normalized spectra for the lamost model", "response": "def get_normed_spectra():\n    \"\"\" Spectra to compare with models \"\"\"\n    wl = np.load(\"%s/wl.npz\" %LAB_DIR)['arr_0']\n    filenames = np.array(\n            [SPEC_DIR + \"/Spectra\" + \"/\" + val for val in lamost_id])\n    grid, fluxes, ivars, npix, SNRs = lamost.load_spectra(\n            lamost_id, input_grid=wl)\n    ds = dataset.Dataset(\n            wl, lamost_id, fluxes, ivars, [1], \n            lamost_id[0:2], fluxes[0:2], ivars[0:2])\n    ds.continuum_normalize_gaussian_smoothing(L=50)\n    np.savez(SPEC_DIR + \"/\" + \"norm_flux.npz\", ds.tr_flux)\n    np.savez(SPEC_DIR + \"/\" + \"norm_ivar.npz\", ds.tr_ivar)\n    return ds.tr_flux, ds.tr_ivar"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wget_files():\n    for f in lamost_id:\n        short = (f.split('-')[2]).split('_')[0]\n        filename = \"%s/%s.gz\" %(short,f)\n        DIR = \"/Users/annaho/Data/Li_Giants/Spectra_APOKASC\"\n        searchfor = \"%s/%s.gz\" %(DIR,f)\n        if glob.glob(searchfor):\n            print(\"done\")\n        else:\n            #print(searchfor)\n            os.system(\n                    \"wget http://dr2.lamost.org/sas/fits/%s\" %(filename))\n            new_filename = filename.split(\"_\")[0] + \"_\" + filename.split(\"_\")[2]\n            os.system(\n                    \"wget http://dr2.lamost.org/sas/fits/%s\" %(new_filename))", "response": "Pull the files from the LAMOST archive"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_labels():\n    cannon_teff = data['cannon_teff_2']\n    cannon_logg = data['cannon_logg_2']\n    cannon_m_h = data['cannon_m_h']\n    cannon_alpha_m = data['cannon_alpha_m']\n    cannon_a_k = data['cannon_a_k']\n    labels = np.vstack(\n            (cannon_teff, cannon_logg, cannon_m_h, cannon_alpha_m, cannon_a_k))\n    cannon_chisq = data['cannon_chisq']\n    np.savez(DATA_DIR + \"chisq.npz\", labels)\n    np.savez(DATA_DIR + \"labels.npz\", labels)\n    snrg = data['cannon_snrg'] # snrg * 3\n    np.savez(\"snr.npz\", snrg)\n    return labels.T", "response": "Get the labels of the Cannon model spectra"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cannon_normalize(spec_raw):\n    spec = np.array([spec_raw])\n    wl = np.arange(0, spec.shape[1])\n    w = continuum_normalization.gaussian_weight_matrix(wl, L=50)\n    ivar = np.ones(spec.shape)*0.5\n    cont = continuum_normalization._find_cont_gaussian_smooth(\n            wl, spec, ivar, w)\n    norm_flux, norm_ivar = continuum_normalization._cont_norm(\n            spec, ivar, cont)\n    return norm_flux[0]", "response": "Normalize according to The Cannon"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resample(grid, wl, flux):\n    flux_rs = (interpolate.interp1d(wl, flux))(grid)\n    return flux_rs", "response": "Resample spectrum onto desired grid"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating the gradient spectra for a Cannon object.", "response": "def gen_cannon_grad_spec(choose, coeffs, pivots):\n    \"\"\" Generate Cannon gradient spectra\n\n    Parameters\n    ----------\n    labels: default values for [teff, logg, feh, cfe, nfe, afe, ak]\n    choose: val of cfe or nfe, whatever you're varying\n    low: lowest val of cfe or nfe, whatever you're varying\n    high: highest val of cfe or nfe, whatever you're varying\n    \"\"\"\n    base_labels = [4800, 2.5, 0.03, 0.10, -0.17, -0.17, 0, -0.16,\n            -0.13, -0.15, 0.13, 0.08, 0.17, -0.062]\n    label_names = np.array(\n            ['TEFF', 'LOGG', 'AK', 'Al', 'Ca', 'C', 'Fe', 'Mg', 'Mn',\n            'Ni', 'N', 'O', 'Si', 'Ti'])\n    label_atnum = np.array(\n            [0, 1, -1, 13, 20, 6, 26, 12, 25, 28, 7, 8, 14, 22])\n    # Generate Cannon gradient spectra\n    ind = np.where(label_atnum==choose)[0][0]\n    low_lab = copy.copy(base_labels)\n    high = base_labels[ind]\n    if choose > 0:\n        low = base_labels[ind] - 0.2\n    else: #temperature\n        if choose != 0: print(\"warning...\")\n        low = base_labels[ind] - 200\n    low_lab[ind] = low\n    lvec = (train_model._get_lvec(np.array([low_lab]), pivots))[0]\n    model_low = np.dot(coeffs, lvec)\n    lvec = (train_model._get_lvec(np.array([base_labels]), pivots))[0]\n    model_high = np.dot(coeffs, lvec)\n    grad_spec = (model_high - model_low) / (high - low)\n    return grad_spec"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget model specting from the given atomic number", "response": "def get_model_spec_ting(atomic_number):\n    \"\"\" \n    X_u_template[0:2] are teff, logg, vturb in km/s\n    X_u_template[:,3] -> onward, put atomic number \n    atomic_number is 6 for C, 7 for N\n    \"\"\"\n    DATA_DIR = \"/Users/annaho/Data/LAMOST/Mass_And_Age\"\n    temp = np.load(\"%s/X_u_template_KGh_res=1800.npz\" %DATA_DIR)\n    X_u_template = temp[\"X_u_template\"]\n    wl = temp[\"wavelength\"]\n    grad_spec = X_u_template[:,atomic_number]\n    return wl, grad_spec"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the residuals of the dataset and model object using the dataset and model object ds and model object m.", "response": "def get_residuals(ds, m):\n    \"\"\" Using the dataset and model object, calculate the residuals and return\n\n    Parameters\n    ----------\n    ds: dataset object\n    m: model object\n    Return\n    ------\n    residuals: array of residuals, spec minus model spec\n    \"\"\"\n    model_spectra = get_model_spectra(ds, m)\n    resid = ds.test_flux - model_spectra\n    return resid"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the model object for the", "response": "def load_model():\n    \"\"\" Load the model \n\n    Parameters\n    ----------\n    direc: directory with all of the model files\n    \n    Returns\n    -------\n    m: model object\n    \"\"\"\n    direc = \"/home/annaho/TheCannon/code/lamost/mass_age/cn\"\n    m = model.CannonModel(2)\n    m.coeffs = np.load(direc + \"/coeffs.npz\")['arr_0'][0:3626,:] # no cols\n    m.scatters = np.load(direc + \"/scatters.npz\")['arr_0'][0:3626] # no cols\n    m.chisqs = np.load(direc + \"/chisqs.npz\")['arr_0'][0:3626] # no cols\n    m.pivots = np.load(direc + \"/pivots.npz\")['arr_0']\n    return m"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the dataset for a single date", "response": "def load_dataset(date):\n    \"\"\" Load the dataset for a single date \n    \n    Parameters\n    ----------\n    date: the date (string) for which to load the data & dataset\n\n    Returns\n    -------\n    ds: the dataset object\n    \"\"\"\n    LAB_DIR = \"/home/annaho/TheCannon/data/lamost\"\n    WL_DIR = \"/home/annaho/TheCannon/code/lamost/mass_age/cn\"\n    SPEC_DIR = \"/home/annaho/TheCannon/code/apogee_lamost/xcalib_4labels/output\"\n    wl = np.load(WL_DIR + \"/wl_cols.npz\")['arr_0'][0:3626] # no cols\n    ds = dataset.Dataset(wl, [], [], [], [], [], [], [])\n    test_label = np.load(\"%s/%s_all_cannon_labels.npz\" %(LAB_DIR,date))['arr_0']\n    ds.test_label_vals = test_label\n    a = np.load(\"%s/%s_norm.npz\" %(SPEC_DIR,date))\n    ds.test_flux = a['arr_0']\n    ds.test_ivar = a['arr_1']\n    ds.test_ID = np.load(\"%s/%s_ids.npz\" %(SPEC_DIR,date))['arr_0']\n    return ds"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfit a Gaussian to the data", "response": "def fit_gaussian(x, y, yerr, p0):\n    \"\"\" Fit a Gaussian to the data \"\"\"\n    try:\n        popt, pcov = curve_fit(gaussian, x, y, sigma=yerr, p0=p0, absolute_sigma=True)\n    except RuntimeError:\n        return [0],[0]\n    return popt, pcov"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef select(yerrs, amps, amp_errs, widths):\n    keep_1 = np.logical_and(amps < 0, widths > 1)\n    keep_2 = np.logical_and(np.abs(amps) > 3*yerrs, amp_errs < 3*np.abs(amps))\n    keep = np.logical_and(keep_1, keep_2)\n    return keep", "response": "selects an object based on the given error and amplitudes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run_all():\n    DATA_DIR = \"/home/annaho/TheCannon/code/apogee_lamost/xcalib_4labels\"\n    dates = os.listdir(\"/home/share/LAMOST/DR2/DR2_release\")\n    dates = np.array(dates)\n    dates = np.delete(dates, np.where(dates=='.directory')[0][0])\n    dates = np.delete(dates, np.where(dates=='all_folders.list')[0][0])\n    dates = np.delete(dates, np.where(dates=='dr2.lis')[0][0])\n\n    for date in dates:\n        if glob.glob(\"*%s*.txt\" %date):\n            print(\"%s done\" %date)\n        else:\n            print(\"running %s\" %date)\n            run_one_date(date)", "response": "Load the data that we re using to search for Li - rich giants."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef gen_cannon_grad_spec(base_labels, choose, low, high, coeffs, pivots):\n    # Generate Cannon gradient spectra\n    low_lab = copy.copy(base_labels)\n    low_lab[choose] = low\n    lvec = (train_model._get_lvec(np.array([low_lab]), pivots))[0]\n    model_low = np.dot(coeffs, lvec)\n    high_lab = copy.copy(base_labels)\n    high_lab[choose] = high\n    lvec = (train_model._get_lvec(np.array([high_lab]), pivots))[0]\n    model_high = np.dot(coeffs, lvec)\n    grad_spec = (model_high - model_low) / (high - low)\n    return grad_spec", "response": "Generate the gradient of a Cannon graph based on the base_labels and coeffs."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_err(snr):\n\n    quad_terms = np.array(\n            [3.11e-3, 1.10e-5, 6.95e-6, 5.05e-6, 4.65e-6, 4.10e-6])\n    lin_terms = np.array(\n            [-0.869, -2.07e-3, -1.40e-3, -1.03e-3, -1.13e-3, -7.29e-4])\n    consts = np.array([104, 0.200, 0.117, 0.114, 0.156, 0.0624])\n    err = quad_terms[:,None] * snr**2 + lin_terms[:,None] * snr + consts[:,None]\n\n    # find the minimum of the quadratic function\n    min_snr = -lin_terms / (2*quad_terms)\n    min_err = quad_terms * min_snr**2 + lin_terms * min_snr + consts\n    mask = (snr[:,None] > min_snr).T\n    for i in range(0,len(min_err)):\n        err[i][mask[i]] = min_err[i]\n\n    return err", "response": "Get approximate scatters from SNR."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget colors from a catalog", "response": "def get_colors(catalog):\n    \"\"\" \n    Pull colors from catalog\n\n    Parameters\n    ----------\n    catalog: filename\n    \"\"\"\n    print(\"Get Colors\")\n    a = pyfits.open(catalog)\n    data = a[1].data\n    a.close()\n    all_ids = data['LAMOST_ID_1']\n    all_ids = np.array([val.strip() for val in all_ids])\n    # G magnitude\n    gmag = data['gpmag']\n    gmag_err = data['e_gpmag']\n    # R magnitude\n    rmag = data['rpmag']\n    rmag_err = data['e_rpmag']\n    # I magnitude\n    imag = data['ipmag']\n    imag_err = data['e_ipmag']\n    # W1\n    W1 = data['W1mag']\n    W1_err = data['e_W1mag']\n    # W1\n    W2 = data['W2mag']\n    W2_err = data['e_W2mag']\n    # J magnitude\n    Jmag = data['Jmag']\n    Jmag_err = data['e_Jmag']\n    # H magnitude\n    Hmag = data['Hmag']\n    Hmag_err = data['e_Hmag']\n    # K magnitude\n    Kmag = data['Kmag']\n    Kmag_err = data['e_Kmag']\n    # Stack\n    mag = np.vstack((\n        gmag, rmag, imag, Jmag, Hmag, Kmag, W2, W1)) # 8, nobj\n    mag_err = np.vstack((\n        gmag_err, rmag_err, imag_err, Jmag_err, \n        Hmag_err, Kmag_err, W2_err, W1_err))\n    # Make g-r, r-i, i-J, etc\n    col = mag[:-1] - mag[1:]\n    col_ivar = 1/(mag_err[:-1]**2 + mag_err[1:]**2)\n\n    # There's something wrong with the i-band, I think..so the second color r-i\n    #bad = col[:,1] < 0.0\n    #col_ivar[bad] = 0.0\n\n    return all_ids, col, col_ivar"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef draw_spectra(md, ds):\n    coeffs_all, covs, scatters, red_chisqs, pivots, label_vector = model.model\n    nstars = len(dataset.test_SNR)\n    cannon_flux = np.zeros(dataset.test_flux.shape)\n    cannon_ivar = np.zeros(dataset.test_ivar.shape)\n    for i in range(nstars):\n        x = label_vector[:,i,:]\n        spec_fit = np.einsum('ij, ij->i', x, coeffs_all)\n        cannon_flux[i,:] = spec_fit\n        bad = dataset.test_ivar[i,:] == SMALL**2\n        cannon_ivar[i,:][~bad] = 1. / scatters[~bad] ** 2\n    return cannon_flux, cannon_ivar", "response": "Generates the best fit spectra for all the test objects  \n\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef overlay_spectra(model, dataset):\n    best_flux, best_ivar = draw_spectra(model, dataset)\n    coeffs_all, covs, scatters, all_chisqs, pivots, label_vector = model.model\n\n    # Overplot original spectra with best-fit spectra\n    print(\"Overplotting spectra for ten random stars\")\n    res = dataset.test_flux-best_flux\n    lambdas = dataset.wl\n    npix = len(lambdas)\n    nstars = best_flux.shape[0]\n    pickstars = []\n    for i in range(10):\n        pickstars.append(random.randrange(0, nstars-1))\n    for i in pickstars:\n        print(\"Star %s\" % i)\n        ID = dataset.test_ID[i]\n        spec_orig = dataset.test_flux[i,:]\n        bad = dataset.test_flux[i,:] == 0\n        lambdas = np.ma.array(lambdas, mask=bad, dtype=float)\n        npix = len(lambdas.compressed())\n        spec_orig = np.ma.array(dataset.test_flux[i,:], mask=bad)\n        spec_fit = np.ma.array(best_flux[i,:], mask=bad)\n        ivars_orig = np.ma.array(dataset.test_ivar[i,:], mask=bad)\n        ivars_fit = np.ma.array(best_ivar[i,:], mask=bad)\n        red_chisq = np.sum(all_chisqs[:,i], axis=0) / (npix - coeffs_all.shape[1])\n        red_chisq = np.round(red_chisq, 2)\n        fig,axarr = plt.subplots(2)\n        ax1 = axarr[0]\n        im = ax1.scatter(lambdas, spec_orig, label=\"Orig Spec\",\n                         c=1 / np.sqrt(ivars_orig), s=10)\n        ax1.scatter(lambdas, spec_fit, label=\"Cannon Spec\", c='r', s=10)\n        ax1.errorbar(lambdas, spec_fit, \n                     yerr=1/np.sqrt(ivars_fit), fmt='ro', ms=1, alpha=0.7)\n        ax1.set_xlabel(r\"Wavelength $\\lambda (\\AA)$\")\n        ax1.set_ylabel(\"Normalized flux\")\n        ax1.set_title(\"Spectrum Fit: %s\" % ID)\n        ax1.set_title(\"Spectrum Fit\")\n        ax1.set_xlim(min(lambdas.compressed())-10, max(lambdas.compressed())+10)\n        ax1.legend(loc='lower center', fancybox=True, shadow=True)\n        ax2 = axarr[1]\n        ax2.scatter(spec_orig, spec_fit, c=1/np.sqrt(ivars_orig), alpha=0.7)\n        ax2.errorbar(spec_orig, spec_fit, yerr=1 / np.sqrt(ivars_fit),\n                     ecolor='k', fmt=\"none\", ms=1, alpha=0.7)\n        #fig.subplots_adjust(right=0.8)\n        #cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.7])\n        fig.colorbar()\n        #fig.colorbar(\n        #        im, cax=cbar_ax,\n        #        label=\"Uncertainties on the Fluxes from the Original Spectrum\")\n        xlims = ax2.get_xlim()\n        ylims = ax2.get_ylim()\n        lims = [np.min([xlims, ylims]), np.max([xlims, ylims])]\n        ax2.plot(lims, lims, 'k-', alpha=0.75)\n        textstr = \"Red Chi Sq: %s\" % red_chisq\n        props = dict(boxstyle='round', facecolor='palevioletred', alpha=0.5)\n        ax2.text(0.05, 0.95, textstr, transform=ax2.transAxes, fontsize=14,\n                 verticalalignment='top', bbox=props)\n        ax2.set_xlim(xlims)\n        ax2.set_ylim(ylims)\n        ax2.set_xlabel(\"Orig Fluxes\")\n        ax2.set_ylabel(\"Fitted Fluxes\")\n        plt.tight_layout()\n        filename = \"best_fit_spec_Star%s.png\" % i\n        print(\"Saved as %s\" % filename)\n        fig.savefig(filename)\n        plt.close(fig)", "response": "Overlays the original spectra with the best fit spectra."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef residuals(cannon_set, dataset):\n    print(\"Stacking spectrum fit residuals\")\n    res = dataset.test_fluxes - cannon_set.test_fluxes\n    bad = dataset.test_ivars == SMALL**2\n    err = np.zeros(len(dataset.test_ivars))\n    err = np.sqrt(1. / dataset.test_ivars + 1. / cannon_set.test_ivars)\n    res_norm = res / err\n    res_norm = np.ma.array(res_norm,\n                           mask=(np.ones_like(res_norm) *\n                                 (np.std(res_norm,axis=0) == 0)))\n    res_norm = np.ma.compress_cols(res_norm)\n\n    for i in range(len(cannon_set.get_plotting_labels())):\n        label_name = cannon_set.get_plotting_labels()[i]\n        print(\"Plotting residuals sorted by %s\" % label_name)\n        label_vals = cannon_set.tr_label_vals[:,i]\n        sorted_res = res_norm[np.argsort(label_vals)]\n        mu = np.mean(sorted_res.flatten())\n        sigma = np.std(sorted_res.flatten())\n        left, width = 0.1, 0.65\n        bottom, height = 0.1, 0.65\n        bottom_h = left_h = left+width+0.1\n        rect_scatter = [left, bottom, width, height]\n        rect_histx = [left, bottom_h, width, 0.1]\n        rect_histy = [left_h, bottom, 0.1, height]\n        plt.figure()\n        axScatter = plt.axes(rect_scatter)\n        axHistx = plt.axes(rect_histx)\n        axHisty = plt.axes(rect_histy)\n        im = axScatter.imshow(sorted_res, cmap=plt.cm.bwr_r,\n                              interpolation=\"nearest\", vmin=mu - 3. * sigma,\n                              vmax=mu + 3. * sigma, aspect='auto',\n                              origin='lower', extent=[0, len(dataset.wl),\n                                                      min(label_vals),\n                                                      max(label_vals)])\n        cax, kw = colorbar.make_axes(axScatter.axes, location='bottom')\n        plt.colorbar(im, cax=cax, orientation='horizontal')\n        axScatter.set_title(\n                r\"Spectral Residuals Sorted by ${0:s}$\".format(label_name))\n        axScatter.set_xlabel(\"Pixels\")\n        axScatter.set_ylabel(r\"$%s$\" % label_name)\n        axHisty.hist(np.std(res_norm,axis=1)[~np.isnan(np.std(res_norm, axis=1))], orientation='horizontal', range=[0,2])\n        axHisty.axhline(y=1, c='k', linewidth=3, label=\"y=1\")\n        axHisty.legend(bbox_to_anchor=(0., 0.8, 1., .102),\n                       prop={'family':'serif', 'size':'small'})\n        axHisty.text(1.0, 0.5, \"Distribution of Stdev of Star Residuals\",\n                     verticalalignment='center', transform=axHisty.transAxes,\n                     rotation=270)\n        axHisty.set_ylabel(\"Standard Deviation\")\n        start, end = axHisty.get_xlim()\n        axHisty.xaxis.set_ticks(np.linspace(start, end, 3))\n        axHisty.set_xlabel(\"Number of Stars\")\n        axHisty.xaxis.set_label_position(\"top\")\n        axHistx.hist(np.std(res_norm, axis=0)[~np.isnan(np.std(res_norm, axis=0))], range=[0.8,1.1])\n        axHistx.axvline(x=1, c='k', linewidth=3, label=\"x=1\")\n        axHistx.set_title(\"Distribution of Stdev of Pixel Residuals\")\n        axHistx.set_xlabel(\"Standard Deviation\")\n        axHistx.set_ylabel(\"Number of Pixels\")\n        start, end = axHistx.get_ylim()\n        axHistx.yaxis.set_ticks(np.linspace(start, end, 3))\n        axHistx.legend()\n        filename = \"residuals_sorted_by_label_%s.png\" % i\n        plt.savefig(filename)\n        print(\"File saved as %s\" % filename)\n        plt.close()\n\n    # Auto-correlation of mean residuals\n    print(\"Plotting Auto-Correlation of Mean Residuals\")\n    mean_res = res_norm.mean(axis=0)\n    autocorr = np.correlate(mean_res, mean_res, mode=\"full\")\n    pkwidth = int(len(autocorr)/2-np.argmin(autocorr))\n    xmin = int(len(autocorr)/2)-pkwidth\n    xmax = int(len(autocorr)/2)+pkwidth\n    zoom_x = np.linspace(xmin, xmax, len(autocorr[xmin:xmax]))\n    fig, axarr = plt.subplots(2)\n    axarr[0].plot(autocorr)\n    axarr[0].set_title(\"Autocorrelation of Mean Spectral Residual\")\n    axarr[0].set_xlabel(\"Lag (# Pixels)\")\n    axarr[0].set_ylabel(\"Autocorrelation\")\n    axarr[1].plot(zoom_x, autocorr[xmin:xmax])\n    axarr[1].set_title(\"Central Peak, Zoomed\")\n    axarr[1].set_xlabel(\"Lag (# Pixels)\")\n    axarr[1].set_ylabel(\"Autocorrelation\")\n    filename = \"residuals_autocorr.png\"\n    plt.savefig(filename)\n    print(\"saved %s\" % filename)\n    plt.close()", "response": "Stack spectrum fit residuals"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _find_contpix_given_cuts(f_cut, sig_cut, wl, fluxes, ivars):\n    f_bar = np.median(fluxes, axis=0)\n    sigma_f = np.var(fluxes, axis=0)\n    bad = np.logical_and(f_bar==0, sigma_f==0)\n    cont1 = np.abs(f_bar-1) <= f_cut\n    cont2 = sigma_f <= sig_cut\n    contmask = np.logical_and(cont1, cont2)\n    contmask[bad] = False\n    return contmask", "response": "Find and return continuum pixels given the flux and sigma cuts."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind continuum pix in the spec meeting a set target fraction.", "response": "def _find_contpix(wl, fluxes, ivars, target_frac):\n    \"\"\" Find continuum pix in spec, meeting a set target fraction\n\n    Parameters\n    ----------\n    wl: numpy ndarray\n        rest-frame wavelength vector\n\n    fluxes: numpy ndarray\n        pixel intensities\n    \n    ivars: numpy ndarray\n        inverse variances, parallel to fluxes\n\n    target_frac: float\n        the fraction of pixels in spectrum desired to be continuum\n\n    Returns\n    -------\n    contmask: boolean numpy ndarray\n        True corresponds to continuum pixels\n    \"\"\"\n    print(\"Target frac: %s\" %(target_frac))\n    bad1 = np.median(ivars, axis=0) == SMALL\n    bad2 = np.var(ivars, axis=0) == 0\n    bad = np.logical_and(bad1, bad2)\n    npixels = len(wl)-sum(bad)\n    f_cut = 0.0001\n    stepsize = 0.0001\n    sig_cut = 0.0001\n    contmask = _find_contpix_given_cuts(f_cut, sig_cut, wl, fluxes, ivars)\n    if npixels > 0:\n        frac = sum(contmask)/float(npixels)\n    else:\n        frac = 0\n    while (frac < target_frac): \n        f_cut += stepsize\n        sig_cut += stepsize\n        contmask = _find_contpix_given_cuts(f_cut, sig_cut, wl, fluxes, ivars)\n        if npixels > 0:\n            frac = sum(contmask)/float(npixels)\n        else:\n            frac = 0\n    if frac > 0.10*npixels:\n        print(\"Warning: Over 10% of pixels identified as continuum.\")\n    print(\"%s out of %s pixels identified as continuum\" %(sum(contmask), \n                                                          npixels))\n    print(\"Cuts: f_cut %s, sig_cut %s\" %(f_cut, sig_cut))\n    return contmask"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _find_contpix_regions(wl, fluxes, ivars, frac, ranges):\n    contmask = np.zeros(len(wl), dtype=bool)\n    for chunk in ranges:\n        start = chunk[0]\n        stop = chunk[1]\n        contmask[start:stop] = _find_contpix(\n                wl[start:stop], fluxes[:,start:stop], ivars[:,start:stop], frac)\n    return contmask", "response": "Find continuum pix in a spectrum split into chunks"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload the reference data and assign each object a random integer from 0 to 7. Save the IDs.", "response": "def group_data():\n    \"\"\" Load the reference data, and assign each object\n    a random integer from 0 to 7. Save the IDs. \"\"\"\n\n    tr_obj = np.load(\"%s/ref_id.npz\" %direc_ref)['arr_0']\n    groups = np.random.randint(0, 8, size=len(tr_obj))\n    np.savez(\"ref_groups.npz\", groups)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef train(ds, ii):\n    print(\"Loading model\")\n    m = model.CannonModel(2)\n    print(\"Training...\")\n    m.fit(ds)\n    np.savez(\"./ex%s_coeffs.npz\" %ii, m.coeffs)\n    np.savez(\"./ex%s_scatters.npz\" %ii, m.scatters)\n    np.savez(\"./ex%s_chisqs.npz\" %ii, m.chisqs)\n    np.savez(\"./ex%s_pivots.npz\" %ii, m.pivots)\n    fig = m.diagnostics_leading_coeffs(ds)\n    plt.savefig(\"ex%s_leading_coeffs.png\" %ii)\n    # m.diagnostics_leading_coeffs_triangle(ds)\n    # m.diagnostics_plot_chisq(ds)\n    return m", "response": "Train the Cannon model on a dataset object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef xvalidate():\n\n    print(\"Loading data\")\n    groups = np.load(\"ref_groups.npz\")['arr_0']\n    ref_label = np.load(\"%s/ref_label.npz\" %direc_ref)['arr_0']\n    ref_id = np.load(\"%s/ref_id.npz\" %direc_ref)['arr_0']\n    ref_flux = np.load(\"%s/ref_flux.npz\" %direc_ref)['arr_0']\n    ref_ivar = np.load(\"%s/ref_ivar.npz\" %direc_ref)['arr_0']\n    wl = np.load(\"%s/wl.npz\" %direc_ref)['arr_0']\n\n    num_models = 8\n\n    for ii in np.arange(num_models):\n        print(\"Leaving out group %s\" %ii)\n        train_on = groups != ii\n        test_on = groups == ii\n\n        tr_label = ref_label[train_on]\n        tr_id = ref_id[train_on]\n        tr_flux = ref_flux[train_on]\n        tr_ivar = ref_ivar[train_on]\n        print(\"Training on %s objects\" %len(tr_id))\n        test_label = ref_label[test_on]\n        test_id = ref_id[test_on]\n        test_flux = ref_flux[test_on]\n        test_ivar = ref_ivar[test_on]\n        print(\"Testing on %s objects\" %len(test_id))\n\n        print(\"Loading dataset...\")\n        ds = dataset.Dataset(\n                wl, tr_id, tr_flux, tr_ivar, tr_label, \n                test_id, test_flux, test_ivar)\n        ds.set_label_names(\n                ['T_{eff}', '\\log g', '[M/H]', '[\\\\alpha/Fe]', 'AKWISE'])\n        fig = ds.diagnostics_SNR()\n        plt.savefig(\"ex%s_SNR.png\" %ii)\n        fig = ds.diagnostics_ref_labels()\n        plt.savefig(\"ex%s_ref_label_triangle.png\" %ii)\n        np.savez(\"ex%s_tr_snr.npz\" %ii, ds.tr_SNR)\n\n        # train a model\n        m = train(ds, ii)\n\n        # test step\n        ds.tr_label = test_label # to compare the results\n        test(ds, m, ii)", "response": "Train a model on the remaining 1 / 8 of the sample."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the weighted standard deviation of a sequence of values.", "response": "def weighted_std(values, weights):\n    \"\"\" Calculate standard deviation weighted by errors \"\"\"\n    average = np.average(values, weights=weights)\n    variance = np.average((values-average)**2, weights=weights)\n    return np.sqrt(variance)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nestimate the scatter in a region of the spectrum taken to be continuum", "response": "def estimate_noise(fluxes, contmask):\n    \"\"\" Estimate the scatter in a region of the spectrum\n    taken to be continuum \"\"\"\n    nstars = fluxes.shape[0]\n    scatter = np.zeros(nstars)\n    for i,spec in enumerate(fluxes): \n        cont = spec[contmask]\n        scatter[i] = stats.funcs.mad_std(cont)\n    return scatter"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_ref_spectra():\n    data_dir = \"/Users/annaho/Data/AAOmega/ref_spectra\"\n    # Load the files & count the number of training objects\n    ff = glob.glob(\"%s/*.txt\" %data_dir)\n    nstars = len(ff)\n    print(\"We have %s training objects\" %nstars)\n    \n    # Read the first file to get the wavelength array\n    f = ff[0]\n    data = Table.read(f, format=\"ascii.fast_no_header\")\n    wl = data['col1']\n    npix = len(wl)\n    print(\"We have %s pixels\" %npix)\n\n    tr_flux = np.zeros((nstars,npix))\n    tr_ivar = np.zeros(tr_flux.shape)\n\n    for i,f in enumerate(ff):\n        data = Table.read(f, format=\"ascii.fast_no_header\")\n        flux = data['col2']\n        tr_flux[i,:] = flux\n        sigma = data['col3']\n        tr_ivar[i,:] = 1.0 / sigma**2\n\n    return np.array(ff), wl, tr_flux, tr_ivar", "response": "Load the training spectra from the first file in the directory and return the wavelength array"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads the data for the AAOmega object.", "response": "def load_data():\n    data_dir = \"/Users/annaho/Data/AAOmega\"\n    out_dir = \"%s/%s\" %(data_dir, \"Run_13_July\")\n\n    \"\"\" Use all the above functions to set data up for The Cannon \"\"\"\n    ff, wl, tr_flux, tr_ivar = load_ref_spectra()\n\n    \"\"\" pick one that doesn't have extra dead pixels \"\"\"\n    skylines = tr_ivar[4,:] # should be the same across all obj\n    np.savez(\"%s/skylines.npz\" %out_dir, skylines)\n\n    contmask = np.load(\"%s/contmask_regions.npz\" %data_dir)['arr_0']\n    scatter = estimate_noise(tr_flux, contmask)\n    ids, labels = load_labels()\n    \n    # Select the objects in the catalog corresponding to the files\n    inds = []\n    ff_short = []\n    for fname in ff:\n        val = fname.split(\"/\")[-1]\n        short = (val.split('.')[0] + '.' + val.split('.')[1])\n        ff_short.append(short)\n        if short in ids:\n            ind = np.where(ids==short)[0][0]\n            inds.append(ind)\n\n    # choose the labels\n    tr_id = ids[inds]\n    tr_label = labels[inds]\n\n    # find the corresponding spectra\n    ff_short = np.array(ff_short)\n    inds = np.array([np.where(ff_short==val)[0][0] for val in tr_id])\n    tr_flux_choose = tr_flux[inds]\n    tr_ivar_choose = tr_ivar[inds]\n    scatter_choose = scatter[inds]\n    np.savez(\"%s/wl.npz\" %out_dir, wl)\n    np.savez(\"%s/ref_id_all.npz\" %out_dir, tr_id)\n    np.savez(\"%s/ref_flux_all.npz\" %out_dir, tr_flux_choose)\n    np.savez(\"%s/ref_ivar_all.npz\" %out_dir, tr_ivar_choose)\n    np.savez(\"%s/ref_label_all.npz\" %out_dir, tr_label)\n    np.savez(\"%s/ref_spec_scat_all.npz\" %out_dir, scatter_choose)\n\n    # now, the test spectra\n    test_id, test_flux = load_test_spectra()\n    scatter = estimate_noise(test_flux, contmask) \n    np.savez(\"%s/test_id.npz\" %out_dir, test_id)\n    np.savez(\"%s/test_flux.npz\" %out_dir, test_flux)\n    np.savez(\"%s/test_spec_scat.npz\" %out_dir, scatter)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntaking the scatters and skylines and make final ivars", "response": "def make_full_ivar():\n    \"\"\" take the scatters and skylines and make final ivars \"\"\"\n\n    # skylines come as an ivar\n    # don't use them for now, because I don't really trust them...\n    # skylines = np.load(\"%s/skylines.npz\" %DATA_DIR)['arr_0']\n\n    ref_flux = np.load(\"%s/ref_flux_all.npz\" %DATA_DIR)['arr_0']\n    ref_scat = np.load(\"%s/ref_spec_scat_all.npz\" %DATA_DIR)['arr_0']\n    test_flux = np.load(\"%s/test_flux.npz\" %DATA_DIR)['arr_0']\n    test_scat = np.load(\"%s/test_spec_scat.npz\" %DATA_DIR)['arr_0']\n    ref_ivar = np.ones(ref_flux.shape) / ref_scat[:,None]**2\n    test_ivar = np.ones(test_flux.shape) / test_scat[:,None]**2\n\n    # ref_ivar = (ref_ivar_temp * skylines[None,:]) / (ref_ivar_temp + skylines)\n    # test_ivar = (test_ivar_temp * skylines[None,:]) / (test_ivar_temp + skylines)\n\n    ref_bad = np.logical_or(ref_flux <= 0, ref_flux > 1.1)\n    test_bad = np.logical_or(test_flux <= 0, test_flux > 1.1)\n    SMALL = 1.0 / 1000000000.0\n    ref_ivar[ref_bad] = SMALL\n    test_ivar[test_bad] = SMALL\n    np.savez(\"%s/ref_ivar_corr.npz\" %DATA_DIR, ref_ivar)\n    np.savez(\"%s/test_ivar_corr.npz\" %DATA_DIR, test_ivar)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _sinusoid(x, p, L, y):\n    N = int(len(p)/2)\n    n = np.linspace(0, N, N+1)\n    k = n*np.pi/L\n    func = 0\n    for n in range(0, N):\n        func += p[2*n]*np.sin(k[n]*x)+p[2*n+1]*np.cos(k[n]*x)\n    return func", "response": "Returns the sinusoid contfunc evaluated at input x for the continuum."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _weighted_median(values, weights, quantile):\n    sindx = np.argsort(values)\n    cvalues = 1. * np.cumsum(weights[sindx])\n    if cvalues[-1] == 0: # means all the values are 0\n        return values[0]\n    cvalues = cvalues / cvalues[-1] # div by largest value\n    foo = sindx[cvalues > quantile]\n    if len(foo) == 0:\n        return values[0]\n    indx = foo[0]\n    return values[indx]", "response": "Calculate a weighted median of a set of values"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _find_cont_gaussian_smooth(wl, fluxes, ivars, w):\n    print(\"Finding the continuum\")\n    bot = np.dot(ivars, w.T)\n    top = np.dot(fluxes*ivars, w.T)\n    bad = bot == 0\n    cont = np.zeros(top.shape)\n    cont[~bad] = top[~bad] / bot[~bad]\n    return cont", "response": "Finds the weighted mean block of spectra with Gaussian smoothed fluxes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _cont_norm_gaussian_smooth(dataset, L):\n    print(\"Gaussian smoothing the entire dataset...\")\n    w = gaussian_weight_matrix(dataset.wl, L)\n\n    print(\"Gaussian smoothing the training set\")\n    cont = _find_cont_gaussian_smooth(\n            dataset.wl, dataset.tr_flux, dataset.tr_ivar, w)\n    norm_tr_flux, norm_tr_ivar = _cont_norm(\n            dataset.tr_flux, dataset.tr_ivar, cont)\n    print(\"Gaussian smoothing the test set\")\n    cont = _find_cont_gaussian_smooth(\n            dataset.wl, dataset.test_flux, dataset.test_ivar, w)\n    norm_test_flux, norm_test_ivar = _cont_norm(\n            dataset.test_flux, dataset.test_ivar, cont)\n    return norm_tr_flux, norm_tr_ivar, norm_test_flux, norm_test_ivar", "response": "Continuum normalize by dividing by a Gaussian - weighted smoothed spectrum\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfits a continuum to a single segment of spectra.", "response": "def _find_cont_fitfunc(fluxes, ivars, contmask, deg, ffunc, n_proc=1):\n    \"\"\" Fit a continuum to a continuum pixels in a segment of spectra\n\n    Functional form can be either sinusoid or chebyshev, with specified degree\n\n    Parameters\n    ----------\n    fluxes: numpy ndarray of shape (nstars, npixels)\n        training set or test set pixel intensities\n\n    ivars: numpy ndarray of shape (nstars, npixels)\n        inverse variances, parallel to fluxes\n\n    contmask: numpy ndarray of length (npixels)\n        boolean pixel mask, True indicates that pixel is continuum \n\n    deg: int\n        degree of fitting function\n\n    ffunc: str\n        type of fitting function, chebyshev or sinusoid\n\n    Returns\n    -------\n    cont: numpy ndarray of shape (nstars, npixels)\n        the continuum, parallel to fluxes\n    \"\"\"\n    nstars = fluxes.shape[0]\n    npixels = fluxes.shape[1]\n    cont = np.zeros(fluxes.shape)\n\n    if n_proc == 1:\n        for jj in range(nstars):\n            flux = fluxes[jj,:]\n            ivar = ivars[jj,:]\n            pix = np.arange(0, npixels)\n            y = flux[contmask]\n            x = pix[contmask]\n            yivar = ivar[contmask]\n            yivar[yivar == 0] = SMALL**2\n            if ffunc==\"sinusoid\":\n                p0 = np.ones(deg*2) # one for cos, one for sin\n                L = max(x)-min(x)\n                pcont_func = _partial_func(_sinusoid, L=L, y=flux)\n                popt, pcov = opt.curve_fit(pcont_func, x, y, p0=p0,\n                                           sigma=1./np.sqrt(yivar))\n            elif ffunc==\"chebyshev\":\n                fit = np.polynomial.chebyshev.Chebyshev.fit(x=x,y=y,w=yivar,deg=deg)\n            for element in pix:\n                if ffunc==\"sinusoid\":\n                    cont[jj,element] = _sinusoid(element, popt, L=L, y=flux)\n                elif ffunc==\"chebyshev\":\n                    cont[jj,element] = fit(element)\n    else:\n        # start mp.Pool\n        pool = mp.Pool(processes=n_proc)\n        mp_results = []\n        for i in xrange(nstars):\n            mp_results.append(pool.apply_async(\\\n                _find_cont_fitfunc,\n                (fluxes[i, :].reshape((1, -1)),\n                 ivars[i, :].reshape((1, -1)),\n                 contmask[:]),\n                {'deg':deg, 'ffunc':ffunc}))\n        # close mp.Pool\n        pool.close()\n        pool.join()\n\n        cont = np.array([mp_results[i].get().flatten() for i in xrange(nstars)])\n\n    return cont"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the continuum in the given set of fluxes and the given mask.", "response": "def _find_cont_fitfunc_regions(fluxes, ivars, contmask, deg, ranges, ffunc,\n                               n_proc=1):\n    \"\"\" Run fit_cont, dealing with spectrum in regions or chunks\n\n    This is useful if a spectrum has gaps.\n\n    Parameters\n    ----------\n    fluxes: ndarray of shape (nstars, npixels)\n        training set or test set pixel intensities\n\n    ivars: numpy ndarray of shape (nstars, npixels)\n        inverse variances, parallel to fluxes\n\n    contmask: numpy ndarray of length (npixels)\n        boolean pixel mask, True indicates that pixel is continuum \n\n    deg: int\n        degree of fitting function\n\n    ffunc: str\n        type of fitting function, chebyshev or sinusoid\n\n    Returns\n    -------\n    cont: numpy ndarray of shape (nstars, npixels)\n        the continuum, parallel to fluxes\n    \"\"\"\n    nstars = fluxes.shape[0]\n    npixels = fluxes.shape[1]\n    cont = np.zeros(fluxes.shape)\n    for chunk in ranges:\n        start = chunk[0]\n        stop = chunk[1]\n        if ffunc==\"chebyshev\":\n            output = _find_cont_fitfunc(fluxes[:,start:stop],\n                                        ivars[:,start:stop],\n                                        contmask[start:stop],\n                                        deg=deg, ffunc=\"chebyshev\",\n                                        n_proc=n_proc)\n        elif ffunc==\"sinusoid\":\n            output = _find_cont_fitfunc(fluxes[:,start:stop],\n                                        ivars[:,start:stop],\n                                        contmask[start:stop],\n                                        deg=deg, ffunc=\"sinusoid\",\n                                        n_proc=n_proc)\n        cont[:, start:stop] = output\n\n    return cont"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _find_cont_running_quantile(wl, fluxes, ivars, q, delta_lambda,\n                                verbose=False):\n    \"\"\" Perform continuum normalization using a running quantile\n\n    Parameters\n    ----------\n    wl: numpy ndarray \n        wavelength vector\n    fluxes: numpy ndarray of shape (nstars, npixels)\n        pixel intensities\n    ivars: numpy ndarray of shape (nstars, npixels)\n        inverse variances, parallel to fluxes\n    q: float\n        the desired quantile cut\n    delta_lambda: int\n        the number of pixels over which the median is calculated\n\n    Output\n    ------\n    norm_fluxes: numpy ndarray of shape (nstars, npixels)\n        normalized pixel intensities\n    norm_ivars: numpy ndarray of shape (nstars, npixels)\n        rescaled pixel invariances\n    \"\"\"\n    cont = np.zeros(fluxes.shape)\n    nstars = fluxes.shape[0]\n    for jj in range(nstars):\n        if verbose:\n            print(\"cont_norm_q(): working on star [%s/%s]...\" % (jj+1, nstars))\n        flux = fluxes[jj,:]\n        ivar = ivars[jj,:]\n        for ll, lam in enumerate(wl):\n            indx = (np.where(abs(wl-lam) < delta_lambda))[0]\n            flux_cut = flux[indx]\n            ivar_cut = ivar[indx]\n            cont[jj, ll] = _weighted_median(flux_cut, ivar_cut, q)\n    return cont", "response": "Perform continuum normalization using a running quantile"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _cont_norm_running_quantile_mp(wl, fluxes, ivars, q, delta_lambda,\n                                   n_proc=2, verbose=False):\n    \"\"\"\n    The same as _cont_norm_running_quantile() above,\n    but using multi-processing.\n\n    Bo Zhang (NAOC)\n    \"\"\"\n    nStar = fluxes.shape[0]\n\n    # start mp.Pool\n    mp_results = []\n    pool = mp.Pool(processes=n_proc)\n    for i in xrange(nStar):\n        mp_results.append(pool.apply_async(\\\n            _find_cont_running_quantile,\n            (wl, fluxes[i, :].reshape((1, -1)), ivars[i, :].reshape((1, -1)),\n             q, delta_lambda), {'verbose': False}))\n        if verbose:\n            print('@Bo Zhang: continuum normalizing star [%d/%d] ...'\\\n                  % (i + 1, nStar))\n    # close mp.Pool\n    pool.close()\n    pool.join()\n\n    # reshape results --> cont\n    cont = np.zeros_like(fluxes)\n    for i in xrange(nStar):\n        cont[i, :] = mp_results[i].get() #.flatten()\n    norm_fluxes = np.ones(fluxes.shape)\n    norm_fluxes[cont!=0] = fluxes[cont!=0] / cont[cont!=0]\n    norm_ivars = cont**2 * ivars\n\n    print('@Bo Zhang: continuum normalization finished!')\n    return norm_fluxes, norm_ivars", "response": "This function normalizes the running quantiles in a running process."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform continuum normalization using running quantile", "response": "def _cont_norm_running_quantile_regions(wl, fluxes, ivars, q, delta_lambda,\n                                        ranges, verbose=True):\n    \"\"\" Perform continuum normalization using running quantile, for spectrum\n    that comes in chunks\n    \"\"\"\n    print(\"contnorm.py: continuum norm using running quantile\")\n    print(\"Taking spectra in %s chunks\" % len(ranges))\n    nstars = fluxes.shape[0]\n    norm_fluxes = np.zeros(fluxes.shape)\n    norm_ivars = np.zeros(ivars.shape)\n    for chunk in ranges:\n        start = chunk[0]\n        stop = chunk[1]\n        output = _cont_norm_running_quantile(\n                wl[start:stop], fluxes[:,start:stop],\n                ivars[:,start:stop], q, delta_lambda)\n        norm_fluxes[:,start:stop] = output[0]\n        norm_ivars[:,start:stop] = output[1]\n    return norm_fluxes, norm_ivars"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform continuum normalization using running quantile for spectrum", "response": "def _cont_norm_running_quantile_regions_mp(wl, fluxes, ivars, q, delta_lambda,\n                                           ranges, n_proc=2, verbose=False):\n    \"\"\"\n    Perform continuum normalization using running quantile, for spectrum\n    that comes in chunks.\n\n    The same as _cont_norm_running_quantile_regions(),\n    but using multi-processing.\n\n    Bo Zhang (NAOC)\n    \"\"\"\n    print(\"contnorm.py: continuum norm using running quantile\")\n    print(\"Taking spectra in %s chunks\" % len(ranges))\n    # nstars = fluxes.shape[0]\n    nchunks = len(ranges)\n    norm_fluxes = np.zeros(fluxes.shape)\n    norm_ivars = np.zeros(ivars.shape)\n    for i in xrange(nchunks):\n        chunk = ranges[i, :]\n        start = chunk[0]\n        stop = chunk[1]\n        if verbose:\n            print('@Bo Zhang: Going to normalize Chunk [%d/%d], pixel:[%d, %d] ...'\n                  % (i+1, nchunks, start, stop))\n        output = _cont_norm_running_quantile_mp(\n            wl[start:stop], fluxes[:, start:stop],\n            ivars[:, start:stop], q, delta_lambda,\n            n_proc=n_proc, verbose=verbose)\n        norm_fluxes[:, start:stop] = output[0]\n        norm_ivars[:, start:stop] = output[1]\n    return norm_fluxes, norm_ivars"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nperforms continuum normalization for spectra in chunks", "response": "def _cont_norm_regions(fluxes, ivars, cont, ranges):\n    \"\"\" Perform continuum normalization for spectra in chunks\n\n    Useful for spectra that have gaps\n\n    Parameters\n    ---------\n    fluxes: numpy ndarray\n        pixel intensities\n    ivars: numpy ndarray\n        inverse variances, parallel to fluxes\n    cont: numpy ndarray\n        the continuum\n    ranges: list or np ndarray\n        the chunks that the spectrum should be split into\n\n    Returns\n    -------\n    norm_fluxes: numpy ndarray\n        normalized pixel intensities\n    norm_ivars: numpy ndarray\n        rescaled inverse variances\n    \"\"\"\n    nstars = fluxes.shape[0]\n    norm_fluxes = np.zeros(fluxes.shape)\n    norm_ivars = np.zeros(ivars.shape)\n    for chunk in ranges:\n        start = chunk[0]\n        stop = chunk[1]\n        output = _cont_norm(fluxes[:,start:stop],\n                           ivars[:,start:stop],\n                           cont[:,start:stop])\n        norm_fluxes[:,start:stop] = output[0]\n        norm_ivars[:,start:stop] = output[1]\n    for jj in range(nstars):\n        bad = (norm_ivars[jj,:] == 0.)\n        norm_fluxes[jj,:][bad] = 1.\n    return norm_fluxes, norm_ivars"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntraining the spectral model on the data set.", "response": "def train(self, ds):\n        \"\"\" Run training step: solve for best-fit spectral model \"\"\"\n        if self.useErrors:\n            self.coeffs, self.scatters, self.new_tr_labels, self.chisqs, self.pivots, self.scales = _train_model_new(ds)\n        else:\n            self.coeffs, self.scatters, self.chisqs, self.pivots, self.scales = _train_model(ds)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef infer_spectra(self, ds):\n        lvec_all = _get_lvec(ds.test_label_vals, self.pivots, self.scales, derivs=False)\n        self.model_spectra = np.dot(lvec_all, self.coeffs.T)", "response": "Infer the model spectra for the object holding the test set."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_contpix(self, x, y, contpix_x, contpix_y, figname):\n        fig, axarr = plt.subplots(2, sharex=True)\n        plt.xlabel(r\"Wavelength $\\lambda (\\AA)$\")\n        plt.xlim(min(x), max(x))\n        ax = axarr[0]\n        ax.step(x, y, where='mid', c='k', linewidth=0.3,\n                label=r'$\\theta_0$' + \"= the leading fit coefficient\")\n        ax.scatter(contpix_x, contpix_y, s=1, color='r',\n                label=\"continuum pixels\")\n        ax.legend(loc='lower right', \n                prop={'family':'serif', 'size':'small'})\n        ax.set_title(\"Baseline Spectrum with Continuum Pixels\")\n        ax.set_ylabel(r'$\\theta_0$')\n        ax = axarr[1]\n        ax.step(x, y, where='mid', c='k', linewidth=0.3,\n             label=r'$\\theta_0$' + \"= the leading fit coefficient\")\n        ax.scatter(contpix_x, contpix_y, s=1, color='r',\n                label=\"continuum pixels\")\n        ax.set_title(\"Baseline Spectrum with Continuum Pixels, Zoomed\")\n        ax.legend(loc='upper right', prop={'family':'serif', \n            'size':'small'})\n        ax.set_ylabel(r'$\\theta_0$')\n        ax.set_ylim(0.95, 1.05)\n        print(\"Diagnostic plot: fitted 0th order spec w/ cont pix\")\n        print(\"Saved as %s.png\" % (figname))\n        plt.savefig(figname)\n        plt.close()", "response": "Plot baseline spec with continuum pix overlaid \n"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall plot_contpix once for each nth of the spectrum", "response": "def diagnostics_contpix(self, data, nchunks=10, fig = \"baseline_spec_with_cont_pix\"):\n        \"\"\" Call plot_contpix once for each nth of the spectrum \"\"\"\n        if data.contmask is None:\n            print(\"No contmask set\")\n        else:\n            coeffs_all = self.coeffs\n            wl = data.wl\n            baseline_spec = coeffs_all[:,0]\n            contmask = data.contmask\n            contpix_x = wl[contmask]\n            contpix_y = baseline_spec[contmask]\n            rem = len(wl)%nchunks\n            wl_split = np.array(np.split(wl[0:len(wl)-rem],nchunks))\n            baseline_spec_split = np.array(\n                    np.split(baseline_spec[0:len(wl)-rem],nchunks))\n            nchunks = wl_split.shape[0]\n            for i in range(nchunks):\n                fig_chunk = fig + \"_%s\" %str(i)\n                wl_chunk = wl_split[i,:]\n                baseline_spec_chunk = baseline_spec_split[i,:]\n                take = np.logical_and(\n                        contpix_x>wl_chunk[0], contpix_x<wl_chunk[-1])\n                self.plot_contpix(\n                        wl_chunk, baseline_spec_chunk, \n                        contpix_x[take], contpix_y[take], fig_chunk)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nproduces a set of diagnostic plots for the model", "response": "def diagnostics_plot_chisq(self, ds, figname = \"modelfit_chisqs.png\"):\n        \"\"\" Produce a set of diagnostic plots for the model \n\n        Parameters\n        ----------\n        (optional) chisq_dist_plot_name: str\n            Filename of output saved plot\n        \"\"\"\n        label_names = ds.get_plotting_labels()\n        lams = ds.wl\n        pivots = self.pivots\n        npixels = len(lams)\n        nlabels = len(pivots)\n        chisqs = self.chisqs\n        coeffs = self.coeffs\n        scatters = self.scatters\n\n        # Histogram of the chi squareds of ind. stars\n        plt.hist(np.sum(chisqs, axis=0), color='lightblue', alpha=0.7,\n                bins=int(np.sqrt(len(chisqs))))\n        dof = len(lams) - coeffs.shape[1]   # for one star\n        plt.axvline(x=dof, c='k', linewidth=2, label=\"DOF\")\n        plt.legend()\n        plt.title(\"Distribution of \" + r\"$\\chi^2$\" + \" of the Model Fit\")\n        plt.ylabel(\"Count\")\n        plt.xlabel(r\"$\\chi^2$\" + \" of Individual Star\")\n        print(\"Diagnostic plot: histogram of the red chi squareds of the fit\")\n        print(\"Saved as %s\" %figname)\n        plt.savefig(figname)\n        plt.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calc_mass(nu_max, delta_nu, teff):\n    NU_MAX = 3140.0 # microHz\n    DELTA_NU = 135.03 # microHz\n    TEFF = 5777.0\n    return (nu_max/NU_MAX)**3 * (delta_nu/DELTA_NU)**(-4) * (teff/TEFF)**1.5", "response": "Calculate the mass of a node based on the given nu_max delta_nu and teff."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calc_mass_2(mh,cm,nm,teff,logg):\n    CplusN = calc_sum(mh,cm,nm)\n    t = teff/4000.\n    return (95.8689 - 10.4042*mh - 0.7266*mh**2\n            + 41.3642*cm - 5.3242*cm*mh - 46.7792*cm**2\n            + 15.0508*nm - 0.9342*nm*mh - 30.5159*nm*cm - 1.6083*nm**2\n            - 67.6093*CplusN + 7.0486*CplusN*mh + 133.5775*CplusN*cm + 38.9439*CplusN*nm - 88.9948*CplusN**2\n            - 144.1765*t + 5.1180*t*mh - 73.7690*t*cm - 15.2927*t*nm + 101.7482*t*CplusN + 27.7690*t**2\n            - 9.4246*logg + 1.5159*logg*mh + 16.0412*logg*cm + 1.3549*logg*nm - 18.6527*logg*CplusN + 28.8015*logg*t - 4.0982*logg**2)", "response": "Calculates mass of mass 2 from mass 1 and mass 2 and mass 3."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef corner(xs, bins=20, range=None, weights=None, color=\"k\",\n           smooth=None, smooth1d=None,\n           labels=None, label_kwargs=None,\n           show_titles=False, title_fmt=\".2f\", title_kwargs=None,\n           truths=None, truth_color=\"#4682b4\",\n           scale_hist=False, quantiles=None, verbose=False, fig=None,\n           max_n_ticks=5, top_ticks=False, use_math_text=False,\n           hist_kwargs=None, **hist2d_kwargs):\n    \"\"\"\n    Make a *sick* corner plot showing the projections of a data set in a\n    multi-dimensional space. kwargs are passed to hist2d() or used for\n    `matplotlib` styling.\n\n    Parameters\n    ----------\n    xs : array_like (nsamples, ndim)\n        The samples. This should be a 1- or 2-dimensional array. For a 1-D\n        array this results in a simple histogram. For a 2-D array, the zeroth\n        axis is the list of samples and the next axis are the dimensions of\n        the space.\n\n    bins : int or array_like (ndim,) (optional)\n        The number of bins to use in histograms, either as a fixed value for\n        all dimensions, or as a list of integers for each dimension.\n\n    weights : array_like (nsamples,)\n        The weight of each sample. If `None` (default), samples are given\n        equal weight.\n\n    color : str (optional)\n        A ``matplotlib`` style color for all histograms.\n\n    smooth, smooth1d : float (optional)\n       The standard deviation for Gaussian kernel passed to\n       `scipy.ndimage.gaussian_filter` to smooth the 2-D and 1-D histograms\n       respectively. If `None` (default), no smoothing is applied.\n\n    labels : iterable (ndim,) (optional)\n        A list of names for the dimensions. If a ``xs`` is a\n        ``pandas.DataFrame``, labels will default to column names.\n\n    label_kwargs : dict (optional)\n        Any extra keyword arguments to send to the `set_xlabel` and\n        `set_ylabel` methods.\n\n    show_titles : bool (optional)\n        Displays a title above each 1-D histogram showing the 0.5 quantile\n        with the upper and lower errors supplied by the quantiles argument.\n\n    title_fmt : string (optional)\n        The format string for the quantiles given in titles. If you explicitly\n        set ``show_titles=True`` and ``title_fmt=None``, the labels will be\n        shown as the titles. (default: ``.2f``)\n\n    title_kwargs : dict (optional)\n        Any extra keyword arguments to send to the `set_title` command.\n\n    range : iterable (ndim,) (optional)\n        A list where each element is either a length 2 tuple containing\n        lower and upper bounds or a float in range (0., 1.)\n        giving the fraction of samples to include in bounds, e.g.,\n        [(0.,10.), (1.,5), 0.999, etc.].\n        If a fraction, the bounds are chosen to be equal-tailed.\n\n    truths : iterable (ndim,) (optional)\n        A list of reference values to indicate on the plots.  Individual\n        values can be omitted by using ``None``.\n\n    truth_color : str (optional)\n        A ``matplotlib`` style color for the ``truths`` makers.\n\n    scale_hist : bool (optional)\n        Should the 1-D histograms be scaled in such a way that the zero line\n        is visible?\n\n    quantiles : iterable (optional)\n        A list of fractional quantiles to show on the 1-D histograms as\n        vertical dashed lines.\n\n    verbose : bool (optional)\n        If true, print the values of the computed quantiles.\n\n    plot_contours : bool (optional)\n        Draw contours for dense regions of the plot.\n\n    use_math_text : bool (optional)\n        If true, then axis tick labels for very large or small exponents will\n        be displayed as powers of 10 rather than using `e`.\n\n    max_n_ticks: int (optional)\n        Maximum number of ticks to try to use\n\n    top_ticks : bool (optional)\n        If true, label the top ticks of each axis\n\n    fig : matplotlib.Figure (optional)\n        Overplot onto the provided figure object.\n\n    hist_kwargs : dict (optional)\n        Any extra keyword arguments to send to the 1-D histogram plots.\n\n    **hist2d_kwargs : (optional)\n        Any remaining keyword arguments are sent to `corner.hist2d` to generate\n        the 2-D histogram plots.\n    \"\"\"\n    if quantiles is None:\n        quantiles = []\n    if title_kwargs is None:\n        title_kwargs = dict()\n    if label_kwargs is None:\n        label_kwargs = dict()\n\n    # Try filling in labels from pandas.DataFrame columns.\n    if labels is None:\n        try:\n            labels = xs.columns\n        except AttributeError:\n            pass\n\n    # Deal with 1D sample lists.\n    xs = np.atleast_1d(xs)\n    if len(xs.shape) == 1:\n        xs = np.atleast_2d(xs)\n    else:\n        assert len(xs.shape) == 2, \"The input sample array must be 1- or 2-D.\"\n        xs = xs.T\n    assert xs.shape[0] <= xs.shape[1], \"I don't believe that you want more \" \\\n                                       \"dimensions than samples!\"\n\n    # Parse the weight array.\n    if weights is not None:\n        weights = np.asarray(weights)\n        if weights.ndim != 1:\n            raise ValueError(\"Weights must be 1-D\")\n        if xs.shape[1] != weights.shape[0]:\n            raise ValueError(\"Lengths of weights must match number of samples\")\n\n    # Parse the parameter ranges.\n    if range is None:\n        if \"extents\" in hist2d_kwargs:\n            logging.warn(\"Deprecated keyword argument 'extents'. \"\n                         \"Use 'range' instead.\")\n            range = hist2d_kwargs.pop(\"extents\")\n        else:\n            range = [[x.min(), x.max()] for x in xs]\n            # Check for parameters that never change.\n            m = np.array([e[0] == e[1] for e in range], dtype=bool)\n            if np.any(m):\n                raise ValueError((\"It looks like the parameter(s) in \"\n                                  \"column(s) {0} have no dynamic range. \"\n                                  \"Please provide a `range` argument.\")\n                                 .format(\", \".join(map(\n                                     \"{0}\".format, np.arange(len(m))[m]))))\n\n    else:\n        # If any of the extents are percentiles, convert them to ranges.\n        # Also make sure it's a normal list.\n        range = list(range)\n        for i, _ in enumerate(range):\n            try:\n                emin, emax = range[i]\n            except TypeError:\n                q = [0.5 - 0.5*range[i], 0.5 + 0.5*range[i]]\n                range[i] = quantile(xs[i], q, weights=weights)\n\n    if len(range) != xs.shape[0]:\n        raise ValueError(\"Dimension mismatch between samples and range\")\n\n    # Parse the bin specifications.\n    try:\n        bins = [float(bins) for _ in range]\n    except TypeError:\n        if len(bins) != len(range):\n            raise ValueError(\"Dimension mismatch between bins and range\")\n\n    # Some magic numbers for pretty axis layout.\n    K = len(xs)\n    factor = 2.0           # size of one side of one panel\n    lbdim = 0.5 * factor   # size of left/bottom margin\n    trdim = 0.2 * factor   # size of top/right margin\n    whspace = 0.05         # w/hspace size\n    plotdim = factor * K + factor * (K - 1.) * whspace\n    dim = lbdim + plotdim + trdim\n\n    # Create a new figure if one wasn't provided.\n    if fig is None:\n        fig, axes = pl.subplots(K, K, figsize=(dim, dim))\n    else:\n        try:\n            axes = np.array(fig.axes).reshape((K, K))\n        except:\n            raise ValueError(\"Provided figure has {0} axes, but data has \"\n                             \"dimensions K={1}\".format(len(fig.axes), K))\n\n    # Format the figure.\n    lb = lbdim / dim\n    tr = (lbdim + plotdim) / dim\n    fig.subplots_adjust(left=lb, bottom=lb, right=tr, top=tr,\n                        wspace=whspace, hspace=whspace)\n\n    # Set up the default histogram keywords.\n    if hist_kwargs is None:\n        hist_kwargs = dict()\n    hist_kwargs[\"color\"] = hist_kwargs.get(\"color\", color)\n    if smooth1d is None:\n        hist_kwargs[\"histtype\"] = hist_kwargs.get(\"histtype\", \"step\")\n\n    for i, x in enumerate(xs):\n        # Deal with masked arrays.\n        if hasattr(x, \"compressed\"):\n            x = x.compressed()\n\n        if np.shape(xs)[0] == 1:\n            ax = axes\n        else:\n            ax = axes[i, i]\n        # Plot the histograms.\n        if smooth1d is None:\n            n, _, _ = ax.hist(x, bins=bins[i], weights=weights,\n                              range=range[i], **hist_kwargs)\n        else:\n            if gaussian_filter is None:\n                raise ImportError(\"Please install scipy for smoothing\")\n            n, b = np.histogram(x, bins=bins[i], weights=weights,\n                                range=range[i])\n            n = gaussian_filter(n, smooth1d)\n            x0 = np.array(list(zip(b[:-1], b[1:]))).flatten()\n            y0 = np.array(list(zip(n, n))).flatten()\n            ax.plot(x0, y0, **hist_kwargs)\n\n        if truths is not None and truths[i] is not None:\n            ax.axvline(truths[i], color=truth_color)\n\n        # Plot quantiles if wanted.\n        if len(quantiles) > 0:\n            qvalues = quantile(x, quantiles, weights=weights)\n            for q in qvalues:\n                ax.axvline(q, ls=\"dashed\", color=color)\n\n            if verbose:\n                print(\"Quantiles:\")\n                print([item for item in zip(quantiles, qvalues)])\n\n        if show_titles:\n            title = None\n            if title_fmt is not None:\n                # Compute the quantiles for the title. This might redo\n                # unneeded computation but who cares.\n                q_16, q_50, q_84 = quantile(x, [0.16, 0.5, 0.84],\n                                            weights=weights)\n                q_m, q_p = q_50-q_16, q_84-q_50\n\n                # Format the quantile display.\n                fmt = \"{{0:{0}}}\".format(title_fmt).format\n                title = r\"${{{0}}}_{{-{1}}}^{{+{2}}}$\"\n                title = title.format(fmt(q_50), fmt(q_m), fmt(q_p))\n\n                # Add in the column name if it's given.\n                if labels is not None:\n                    title = \"{0} = {1}\".format(labels[i], title)\n\n            elif labels is not None:\n                title = \"{0}\".format(labels[i])\n\n            if title is not None:\n                ax.set_title(title, **title_kwargs)\n\n        # Set up the axes.\n        ax.set_xlim(range[i])\n        if scale_hist:\n            maxn = np.max(n)\n            ax.set_ylim(-0.1 * maxn, 1.1 * maxn)\n        else:\n            ax.set_ylim(0, 1.1 * np.max(n))\n        ax.set_yticklabels([])\n        ax.xaxis.set_major_locator(MaxNLocator(max_n_ticks, prune=\"lower\"))\n\n        if i < K - 1:\n            if top_ticks:\n                ax.xaxis.set_ticks_position(\"top\")\n                [l.set_rotation(45) for l in ax.get_xticklabels()]\n            else:\n                ax.set_xticklabels([])\n        else:\n            [l.set_rotation(45) for l in ax.get_xticklabels()]\n            if labels is not None:\n                ax.set_xlabel(labels[i], **label_kwargs)\n                ax.xaxis.set_label_coords(0.5, -0.3)\n\n            # use MathText for axes ticks\n            ax.xaxis.set_major_formatter(\n                ScalarFormatter(useMathText=use_math_text))\n\n        for j, y in enumerate(xs):\n            if np.shape(xs)[0] == 1:\n                ax = axes\n            else:\n                ax = axes[i, j]\n            if j > i:\n                ax.set_frame_on(False)\n                ax.set_xticks([])\n                ax.set_yticks([])\n                continue\n            elif j == i:\n                continue\n\n            # Deal with masked arrays.\n            if hasattr(y, \"compressed\"):\n                y = y.compressed()\n\n            hist2d(y, x, ax=ax, range=[range[j], range[i]], weights=weights,\n                   color=color, smooth=smooth, bins=[bins[j], bins[i]],\n                   **hist2d_kwargs)\n\n            if truths is not None:\n                if truths[i] is not None and truths[j] is not None:\n                    ax.plot(truths[j], truths[i], \"s\", color=truth_color)\n                if truths[j] is not None:\n                    ax.axvline(truths[j], color=truth_color)\n                if truths[i] is not None:\n                    ax.axhline(truths[i], color=truth_color)\n\n            ax.xaxis.set_major_locator(MaxNLocator(max_n_ticks, prune=\"lower\"))\n            ax.yaxis.set_major_locator(MaxNLocator(max_n_ticks, prune=\"lower\"))\n\n            if i < K - 1:\n                ax.set_xticklabels([])\n            else:\n                [l.set_rotation(45) for l in ax.get_xticklabels()]\n                if labels is not None:\n                    ax.set_xlabel(labels[j], **label_kwargs)\n                    ax.xaxis.set_label_coords(0.5, -0.3)\n\n                # use MathText for axes ticks\n                ax.xaxis.set_major_formatter(\n                    ScalarFormatter(useMathText=use_math_text))\n\n            if j > 0:\n                ax.set_yticklabels([])\n            else:\n                [l.set_rotation(45) for l in ax.get_yticklabels()]\n                if labels is not None:\n                    ax.set_ylabel(labels[i], **label_kwargs)\n                    ax.yaxis.set_label_coords(-0.3, 0.5)\n\n                # use MathText for axes ticks\n                ax.yaxis.set_major_formatter(\n                    ScalarFormatter(useMathText=use_math_text))\n\n    return fig", "response": "A simple corner plot showing the projections of a data set in a multi - dimensional space."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlike np. percentile but returns a list of the n - th quantile of the elements in x.", "response": "def quantile(x, q, weights=None):\n    \"\"\"\n    Like numpy.percentile, but:\n\n    * Values of q are quantiles [0., 1.] rather than percentiles [0., 100.]\n    * scalar q not supported (q must be iterable)\n    * optional weights on x\n\n    \"\"\"\n    if weights is None:\n        return np.percentile(x, [100. * qi for qi in q])\n    else:\n        idx = np.argsort(x)\n        xsorted = x[idx]\n        cdf = np.add.accumulate(weights[idx])\n        cdf /= cdf[-1]\n        return np.interp(q, cdf, xsorted).tolist()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nplotting a 2 - D histogram of samples.", "response": "def hist2d(x, y, bins=20, range=None, weights=None, levels=None, smooth=None,\n           ax=None, color=None, plot_datapoints=True, plot_density=True,\n           plot_contours=True, no_fill_contours=False, fill_contours=False,\n           contour_kwargs=None, contourf_kwargs=None, data_kwargs=None,\n           **kwargs):\n    \"\"\"\n    Plot a 2-D histogram of samples.\n\n    Parameters\n    ----------\n    x, y : array_like (nsamples,)\n       The samples.\n\n    levels : array_like\n        The contour levels to draw.\n\n    ax : matplotlib.Axes (optional)\n        A axes instance on which to add the 2-D histogram.\n\n    plot_datapoints : bool (optional)\n        Draw the individual data points.\n\n    plot_density : bool (optional)\n        Draw the density colormap.\n\n    plot_contours : bool (optional)\n        Draw the contours.\n\n    no_fill_contours : bool (optional)\n        Add no filling at all to the contours (unlike setting\n        ``fill_contours=False``, which still adds a white fill at the densest\n        points).\n\n    fill_contours : bool (optional)\n        Fill the contours.\n\n    contour_kwargs : dict (optional)\n        Any additional keyword arguments to pass to the `contour` method.\n\n    contourf_kwargs : dict (optional)\n        Any additional keyword arguments to pass to the `contourf` method.\n\n    data_kwargs : dict (optional)\n        Any additional keyword arguments to pass to the `plot` method when\n        adding the individual data points.\n    \"\"\"\n    if ax is None:\n        ax = pl.gca()\n\n    # Set the default range based on the data range if not provided.\n    if range is None:\n        if \"extent\" in kwargs:\n            logging.warn(\"Deprecated keyword argument 'extent'. \"\n                         \"Use 'range' instead.\")\n            range = kwargs[\"extent\"]\n        else:\n            range = [[x.min(), x.max()], [y.min(), y.max()]]\n\n    # Set up the default plotting arguments.\n    if color is None:\n        color = \"k\"\n\n    # Choose the default \"sigma\" contour levels.\n    if levels is None:\n        levels = 1.0 - np.exp(-0.5 * np.arange(0.5, 2.1, 0.5) ** 2)\n\n    # This is the color map for the density plot, over-plotted to indicate the\n    # density of the points near the center.\n    density_cmap = LinearSegmentedColormap.from_list(\n        \"density_cmap\", [color, (1, 1, 1, 0)])\n\n    # This color map is used to hide the points at the high density areas.\n    white_cmap = LinearSegmentedColormap.from_list(\n        \"white_cmap\", [(1, 1, 1), (1, 1, 1)], N=2)\n\n    # This \"color map\" is the list of colors for the contour levels if the\n    # contours are filled.\n    rgba_color = colorConverter.to_rgba(color)\n    contour_cmap = [list(rgba_color) for l in levels] + [rgba_color]\n    for i, l in enumerate(levels):\n        contour_cmap[i][-1] *= float(i) / (len(levels)+1)\n\n    # We'll make the 2D histogram to directly estimate the density.\n    try:\n        H, X, Y = np.histogram2d(x.flatten(), y.flatten(), bins=bins,\n                                 range=range, weights=weights)\n    except ValueError:\n        raise ValueError(\"It looks like at least one of your sample columns \"\n                         \"have no dynamic range. You could try using the \"\n                         \"'range' argument.\")\n\n    if smooth is not None:\n        if gaussian_filter is None:\n            raise ImportError(\"Please install scipy for smoothing\")\n        H = gaussian_filter(H, smooth)\n\n    # Compute the density levels.\n    Hflat = H.flatten()\n    inds = np.argsort(Hflat)[::-1]\n    Hflat = Hflat[inds]\n    sm = np.cumsum(Hflat)\n    sm /= sm[-1]\n    V = np.empty(len(levels))\n    for i, v0 in enumerate(levels):\n        try:\n            V[i] = Hflat[sm <= v0][-1]\n        except:\n            V[i] = Hflat[0]\n    V.sort()\n    m = np.diff(V) == 0\n    if np.any(m):\n        logging.warning(\"Too few points to create valid contours\")\n    while np.any(m):\n        V[np.where(m)[0][0]] *= 1.0 - 1e-4\n        m = np.diff(V) == 0\n    V.sort()\n\n    # Compute the bin centers.\n    X1, Y1 = 0.5 * (X[1:] + X[:-1]), 0.5 * (Y[1:] + Y[:-1])\n\n    # Extend the array for the sake of the contours at the plot edges.\n    H2 = H.min() + np.zeros((H.shape[0] + 4, H.shape[1] + 4))\n    H2[2:-2, 2:-2] = H\n    H2[2:-2, 1] = H[:, 0]\n    H2[2:-2, -2] = H[:, -1]\n    H2[1, 2:-2] = H[0]\n    H2[-2, 2:-2] = H[-1]\n    H2[1, 1] = H[0, 0]\n    H2[1, -2] = H[0, -1]\n    H2[-2, 1] = H[-1, 0]\n    H2[-2, -2] = H[-1, -1]\n    X2 = np.concatenate([\n        X1[0] + np.array([-2, -1]) * np.diff(X1[:2]),\n        X1,\n        X1[-1] + np.array([1, 2]) * np.diff(X1[-2:]),\n    ])\n    Y2 = np.concatenate([\n        Y1[0] + np.array([-2, -1]) * np.diff(Y1[:2]),\n        Y1,\n        Y1[-1] + np.array([1, 2]) * np.diff(Y1[-2:]),\n    ])\n\n    if plot_datapoints:\n        if data_kwargs is None:\n            data_kwargs = dict()\n        data_kwargs[\"color\"] = data_kwargs.get(\"color\", color)\n        data_kwargs[\"ms\"] = data_kwargs.get(\"ms\", 2.0)\n        data_kwargs[\"mec\"] = data_kwargs.get(\"mec\", \"none\")\n        data_kwargs[\"alpha\"] = data_kwargs.get(\"alpha\", 0.1)\n        ax.plot(x, y, \"o\", zorder=-1, rasterized=True, **data_kwargs)\n\n    # Plot the base fill to hide the densest data points.\n    if (plot_contours or plot_density) and not no_fill_contours:\n        ax.contourf(X2, Y2, H2.T, [V.min(), H.max()],\n                    cmap=white_cmap, antialiased=False)\n\n    if plot_contours and fill_contours:\n        if contourf_kwargs is None:\n            contourf_kwargs = dict()\n        contourf_kwargs[\"colors\"] = contourf_kwargs.get(\"colors\", contour_cmap)\n        contourf_kwargs[\"antialiased\"] = contourf_kwargs.get(\"antialiased\",\n                                                             False)\n        ax.contourf(X2, Y2, H2.T, np.concatenate([[0], V, [H.max()*(1+1e-4)]]),\n                    **contourf_kwargs)\n\n    # Plot the density map. This can't be plotted at the same time as the\n    # contour fills.\n    elif plot_density:\n        ax.pcolor(X, Y, H.max() - H.T, cmap=density_cmap)\n\n    # Plot the contour edge colors.\n    if plot_contours:\n        if contour_kwargs is None:\n            contour_kwargs = dict()\n        contour_kwargs[\"colors\"] = contour_kwargs.get(\"colors\", color)\n        ax.contour(X2, Y2, H2.T, V, **contour_kwargs)\n\n    ax.set_xlim(range[0])\n    ax.set_ylim(range[1])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_classifier(self, name, ids, labels):\n        if not all(np.in1d(ids, self.ids)):\n            raise ValueError(\"Hay ids de textos que no se encuentran \\\n                              almacenados.\")\n        setattr(self, name, SGDClassifier())\n        classifier = getattr(self, name)\n        indices = np.searchsorted(self.ids, ids)\n        classifier.fit(self.tfidf_mat[indices, :], labels)", "response": "Enregistro un clasificador SVM sobre los textos cargados."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef classify(self, classifier_name, examples, max_labels=None,\n                 goodness_of_fit=False):\n        \"\"\"Usar un clasificador SVM para etiquetar textos nuevos.\n\n        Args:\n            classifier_name (str): Nombre del clasidicador a usar.\n            examples (list or str): Se espera un ejemplo o una lista de\n                ejemplos a clasificar en texto plano o en ids.\n            max_labels (int, optional): Cantidad de etiquetas a devolver para\n                cada ejemplo. Si se devuelve mas de una el orden corresponde a\n                la plausibilidad de cada etiqueta. Si es None devuelve todas\n                las etiquetas posibles.\n            goodness_of_fit (bool, optional): Indica si devuelve o no una\n                medida de cuan buenas son las etiquetas.\n        Nota:\n            Usa el clasificador de `Scikit-learn <http://scikit-learn.org/>`_\n\n        Returns:\n            tuple (array, array): (labels_considerados, puntajes)\n                labels_considerados: Las etiquetas que se consideraron para\n                    clasificar.\n                puntajes: Cuanto m\u00e1s alto el puntaje, m\u00e1s probable es que la\n                    etiqueta considerada sea la adecuada.\n        \"\"\"\n        classifier = getattr(self, classifier_name)\n        texts_vectors = self._make_text_vectors(examples)\n        return classifier.classes_, classifier.decision_function(texts_vectors)", "response": "Usar un clasificador SVM para etiquetar textos nuevos."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_similar(self, example, max_similars=3, similarity_cutoff=None,\n                    term_diff_max_rank=10, filter_list=None,\n                    term_diff_cutoff=None):\n        \"\"\"Devuelve textos similares al ejemplo dentro de los textos entrenados.\n\n        Nota:\n            Usa la distancia de coseno del vector de features TF-IDF\n\n        Args:\n            example (str): Se espera un id de texto o un texto a partir del\n                cual se buscaran otros textos similares.\n            max_similars (int, optional): Cantidad de textos similares a\n                devolver.\n            similarity_cutoff (float, optional): Valor umbral de similaridad\n                para definir que dos textos son similares entre si.\n            term_diff_max_rank (int, optional): Este valor sirve para controlar\n                el umbral con el que los terminos son considerados importantes\n                a la hora de recuperar textos (no afecta el funcionamiento de\n                que textos se consideran cercanos, solo la cantidad de terminos\n                que se devuelven en best_words).\n            filter_list (list): Lista de ids de textos en la cual buscar textos\n                similares.\n            term_diff_cutoff (float): Deprecado. Se quitara en el futuro.\n\n        Returns:\n            tuple (list, list, list): (text_ids, sorted_dist, best_words)\n                text_ids (list of str): Devuelve los ids de los textos\n                    sugeridos.\n                sorted_dist (list of float): Devuelve la distancia entre las\n                    opciones sugeridas y el ejemplo dado como entrada.\n                best_words (list of list): Para cada sugerencia devuelve las\n                    palabras mas relevantes que se usaron para seleccionar esa\n                    sugerencia.\n        \"\"\"\n\n        if term_diff_cutoff:\n            warnings.warn('Deprecado. Quedo sin uso. Se quitara en el futuro.',\n                          DeprecationWarning)\n        if filter_list:\n            if max_similars > len(filter_list):\n                raise ValueError(\"No se pueden pedir mas sugerencias que la \\\n                                  cantidad de textos en `filter_list`.\")\n            else:\n                filt_idx = np.in1d(self.ids, filter_list)\n\n        elif max_similars > self.term_mat.shape[0]:\n            raise ValueError(\"No se pueden pedir mas sugerencias que la \\\n                              cantidad de textos que hay almacenados.\")\n        else:\n            filt_idx = np.ones(len(self.ids), dtype=bool)\n        # Saco los textos compuestos solo por stop_words\n        good_ids = np.array(np.sum(self.term_mat, 1) > 0).squeeze()\n        filt_idx = filt_idx & good_ids\n        filt_idx_to_general_idx = np.flatnonzero(filt_idx)\n        if example in self.ids:\n            index = self.ids == example\n            exmpl_vec = self.tfidf_mat[index, :]\n            distances = np.squeeze(pairwise_distances(self.tfidf_mat[filt_idx],\n                                                      exmpl_vec))\n            # Pongo la distancia a si mismo como inf, par que no se devuelva a\n            # si mismo como una opcion\n            if filter_list and example in filter_list:\n                distances[filter_list.index(example)] = np.inf\n            elif not filter_list:\n                idx_example = np.searchsorted(self.ids, example)\n                filt_idx_example = np.searchsorted(np.flatnonzero(filt_idx),\n                                                   idx_example)\n                distances[filt_idx_example] = np.inf\n        else:\n            exmpl_vec = self.vectorizer.transform([example])  # contar terminos\n            exmpl_vec = self.transformer.transform(exmpl_vec)  # calcular tfidf\n            distances = np.squeeze(pairwise_distances(self.tfidf_mat[filt_idx],\n                                                      exmpl_vec))\n        if np.sum(exmpl_vec) == 0:\n            return [], [], []\n        sorted_indices = np.argsort(distances)\n        closest_n = sorted_indices[:max_similars]\n        sorted_dist = distances[closest_n]\n        if similarity_cutoff:\n            closest_n = closest_n[sorted_dist < similarity_cutoff]\n            sorted_dist = sorted_dist[sorted_dist < similarity_cutoff]\n        best_words = []\n\n        # Calculo palabras relevantes para cada sugerencia\n        best_example = np.squeeze(exmpl_vec.toarray())\n        sorted_example_weights = np.flipud(np.argsort(best_example))\n        truncated_max_rank = min(term_diff_max_rank, np.sum(best_example > 0))\n        best_example_words = sorted_example_weights[:truncated_max_rank]\n        for suggested in closest_n:\n            suggested_idx = filt_idx_to_general_idx[suggested]\n            test_vec = np.squeeze(self.tfidf_mat[suggested_idx, :].toarray())\n            sorted_test_weights = np.flipud(np.argsort(test_vec))\n            truncated_max_rank = min(term_diff_max_rank,\n                                     np.sum(test_vec > 0))\n            best_test = sorted_test_weights[:truncated_max_rank]\n            best_words_ids = np.intersect1d(best_example_words, best_test)\n            best_words.append([k for k, v in\n                               self.vectorizer.vocabulary_.items()\n                               if v in best_words_ids])\n\n        # Filtro dentro de las buscadas\n        if filter_list:\n            text_ids = self.ids[filt_idx_to_general_idx[closest_n]]\n        else:\n            text_ids = self.ids[closest_n]\n        return list(text_ids), list(sorted_dist), best_words", "response": "Return a list of similares to the given texto."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reload_texts(self, texts, ids, vocabulary=None):\n        self._check_id_length(ids)\n        self.ids = np.array(sorted(ids))\n        if vocabulary:\n            self.vectorizer.vocabulary = vocabulary\n        sorted_texts = [x for (y, x) in sorted(zip(ids, texts))]\n        self.term_mat = self.vectorizer.fit_transform(sorted_texts)\n        self._update_tfidf()", "response": "Re - defines the term_mat and vocabulary of the terminos de textos."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dataset_metrics(uuid, **kwargs):\n\t'''\n\tGet details on a GBIF dataset.\n\n\t:param uuid: [str] One or more dataset UUIDs. See examples.\n\n\tReferences: http://www.gbif.org/developer/registry#datasetMetrics\n\n\tUsage::\n\n\t\t\tfrom pygbif import registry\n\t\t\tregistry.dataset_metrics(uuid='3f8a1297-3259-4700-91fc-acc4170b27ce')\n\t\t\tregistry.dataset_metrics(uuid='66dd0960-2d7d-46ee-a491-87b9adcfe7b1')\n\t\t\tregistry.dataset_metrics(uuid=['3f8a1297-3259-4700-91fc-acc4170b27ce', '66dd0960-2d7d-46ee-a491-87b9adcfe7b1'])\n\t'''\n\tdef getdata(x, **kwargs):\n\t\turl = gbif_baseurl + 'dataset/' + x + '/metrics'\n\t\treturn gbif_GET(url, {}, **kwargs)\n\n\tif len2(uuid) == 1:\n\t\treturn getdata(uuid)\n\telse:\n\t\treturn [getdata(x) for x in uuid]", "response": "Get details on a GBIF dataset."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsearches for datasets and dataset metadata.", "response": "def datasets(data = 'all', type = None, uuid = None, query = None, id = None,\n\t\t\t\t\t\t\tlimit = 100, offset = None, **kwargs):\n\t'''\n\tSearch for datasets and dataset metadata.\n\n\t:param data: [str] The type of data to get. Default: ``all``\n\t:param type: [str] Type of dataset, options include ``OCCURRENCE``, etc.\n\t:param uuid: [str] UUID of the data node provider. This must be specified if data\n\t\t is anything other than ``all``.\n\t:param query: [str] Query term(s). Only used when ``data = 'all'``\n\t:param id: [int] A metadata document id.\n\n\tReferences http://www.gbif.org/developer/registry#datasets\n\n\tUsage::\n\n\t\t\tfrom pygbif import registry\n\t\t\tregistry.datasets(limit=5)\n\t\t\tregistry.datasets(type=\"OCCURRENCE\")\n\t\t\tregistry.datasets(uuid=\"a6998220-7e3a-485d-9cd6-73076bd85657\")\n\t\t\tregistry.datasets(data='contact', uuid=\"a6998220-7e3a-485d-9cd6-73076bd85657\")\n\t\t\tregistry.datasets(data='metadata', uuid=\"a6998220-7e3a-485d-9cd6-73076bd85657\")\n\t\t\tregistry.datasets(data='metadata', uuid=\"a6998220-7e3a-485d-9cd6-73076bd85657\", id=598)\n\t\t\tregistry.datasets(data=['deleted','duplicate'])\n\t\t\tregistry.datasets(data=['deleted','duplicate'], limit=1)\n\t'''\n\targs = {'q': query, 'type': type, 'limit': limit, 'offset': offset}\n\tdata_choices = ['all', 'organization', 'contact', 'endpoint',\n\t\t\t\t\t\t\t\t\t'identifier', 'tag', 'machinetag', 'comment',\n\t\t\t\t\t\t\t\t\t'constituents', 'document', 'metadata', 'deleted',\n\t\t\t\t\t\t\t\t\t'duplicate', 'subDataset', 'withNoEndpoint']\n\tcheck_data(data, data_choices)\n\tif len2(data) ==1:\n\t\treturn datasets_fetch(data, uuid, args, **kwargs)\n\telse:\n\t\treturn [datasets_fetch(x, uuid, args, **kwargs) for x in data]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dataset_suggest(q=None, type=None, keyword=None, owningOrg=None,\n\tpublishingOrg=None, hostingOrg=None, publishingCountry=None, decade=None,\n\tlimit = 100, offset = None, **kwargs):\n\t'''\n\tSearch that returns up to 20 matching datasets. Results are ordered by relevance.\n\n\n\t:param q: [str] Query term(s) for full text search.  The value for this parameter can be a simple word or a phrase. Wildcards can be added to the simple word parameters only, e.g. ``q=*puma*``\n\t:param type: [str] Type of dataset, options include OCCURRENCE, etc.\n\t:param keyword: [str] Keyword to search by. Datasets can be tagged by keywords, which you can search on. The search is done on the merged collection of tags, the dataset keywordCollections and temporalCoverages. SEEMS TO NOT BE WORKING ANYMORE AS OF 2016-09-02.\n\t:param owningOrg: [str] Owning organization. A uuid string. See :func:`~pygbif.registry.organizations`\n\t:param publishingOrg: [str] Publishing organization. A uuid string. See :func:`~pygbif.registry.organizations`\n\t:param hostingOrg: [str] Hosting organization. A uuid string. See :func:`~pygbif.registry.organizations`\n\t:param publishingCountry: [str] Publishing country.\n\t:param decade: [str] Decade, e.g., 1980. Filters datasets by their temporal coverage broken down to decades. Decades are given as a full year, e.g. 1880, 1960, 2000, etc, and will return datasets wholly contained in the decade as well as those that cover the entire decade or more. Facet by decade to get the break down, e.g. ``/search?facet=DECADE&facet_only=true`` (see example below)\n\t:param limit: [int] Number of results to return. Default: ``300``\n\t:param offset: [int] Record to start at. Default: ``0``\n\n\t:return: A dictionary\n\n\tReferences: http://www.gbif.org/developer/registry#datasetSearch\n\n\tUsage::\n\n\t\t\tfrom pygbif import registry\n\t\t\tregistry.dataset_suggest(q=\"Amazon\", type=\"OCCURRENCE\")\n\n\t\t\t# Suggest datasets tagged with keyword \"france\".\n\t\t\tregistry.dataset_suggest(keyword=\"france\")\n\n\t\t\t# Suggest datasets owned by the organization with key\n\t\t\t# \"07f617d0-c688-11d8-bf62-b8a03c50a862\" (UK NBN).\n\t\t\tregistry.dataset_suggest(owningOrg=\"07f617d0-c688-11d8-bf62-b8a03c50a862\")\n\n\t\t\t# Fulltext search for all datasets having the word \"amsterdam\" somewhere in\n\t\t\t# its metadata (title, description, etc).\n\t\t\tregistry.dataset_suggest(q=\"amsterdam\")\n\n\t\t\t# Limited search\n\t\t\tregistry.dataset_suggest(type=\"OCCURRENCE\", limit=2)\n\t\t\tregistry.dataset_suggest(type=\"OCCURRENCE\", limit=2, offset=10)\n\n\t\t\t# Return just descriptions\n\t\t\tregistry.dataset_suggest(type=\"OCCURRENCE\", limit = 5, description=True)\n\n\t\t\t# Search by decade\n\t\t\tregistry.dataset_suggest(decade=1980, limit = 30)\n\t'''\n\turl = gbif_baseurl + 'dataset/suggest'\n\targs = {'q': q, 'type': type, 'keyword': keyword,\n\t\t\t\t'publishingOrg': publishingOrg, 'hostingOrg': hostingOrg,\n\t\t\t\t'owningOrg': owningOrg, 'decade': decade,\n\t\t\t\t'publishingCountry': publishingCountry,\n\t\t\t\t'limit': limit, 'offset': offset}\n\tout = gbif_GET(url, args, **kwargs)\n\treturn out", "response": "A simple text search that returns up to 20 matching datasets."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dataset_search(q=None, type=None, keyword=None,\n\towningOrg=None, publishingOrg=None, hostingOrg=None, decade=None,\n\tpublishingCountry = None, facet = None, facetMincount=None,\n\tfacetMultiselect = None, hl = False, limit = 100, offset = None,\n\t**kwargs):\n\t'''\n\tFull text search across all datasets. Results are ordered by relevance.\n\n\t:param q: [str] Query term(s) for full text search.  The value for this parameter\n\t\t can be a simple word or a phrase. Wildcards can be added to the simple word\n\t\t parameters only, e.g. ``q=*puma*``\n\t:param type: [str] Type of dataset, options include OCCURRENCE, etc.\n\t:param keyword: [str] Keyword to search by. Datasets can be tagged by keywords, which\n\t\t you can search on. The search is done on the merged collection of tags, the\n\t\t dataset keywordCollections and temporalCoverages. SEEMS TO NOT BE WORKING\n\t\t ANYMORE AS OF 2016-09-02.\n\t:param owningOrg: [str] Owning organization. A uuid string. See :func:`~pygbif.registry.organizations`\n\t:param publishingOrg: [str] Publishing organization. A uuid string. See :func:`~pygbif.registry.organizations`\n\t:param hostingOrg: [str] Hosting organization. A uuid string. See :func:`~pygbif.registry.organizations`\n\t:param publishingCountry: [str] Publishing country.\n\t:param decade: [str] Decade, e.g., 1980. Filters datasets by their temporal coverage\n\t\t broken down to decades. Decades are given as a full year, e.g. 1880, 1960, 2000,\n\t\t etc, and will return datasets wholly contained in the decade as well as those\n\t\t that cover the entire decade or more. Facet by decade to get the break down,\n\t\t e.g. ``/search?facet=DECADE&facet_only=true`` (see example below)\n\t:param facet: [str] A list of facet names used to retrieve the 100 most frequent values\n\t\t\tfor a field. Allowed facets are: type, keyword, publishingOrg, hostingOrg, decade,\n\t\t\tand publishingCountry. Additionally subtype and country are legal values but not\n\t\t\tyet implemented, so data will not yet be returned for them.\n\t:param facetMincount: [str] Used in combination with the facet parameter. Set\n\t\t\tfacetMincount={#} to exclude facets with a count less than {#}, e.g.\n\t\t\thttp://api.gbif.org/v1/dataset/search?facet=type&limit=0&facetMincount=10000\n\t\t\tonly shows the type value 'OCCURRENCE' because 'CHECKLIST' and 'METADATA' have\n\t\t\tcounts less than 10000.\n\t:param facetMultiselect: [bool] Used in combination with the facet parameter. Set\n\t\t\tfacetMultiselect=True to still return counts for values that are not currently\n\t\t\tfiltered, e.g.\n\t\t\thttp://api.gbif.org/v1/dataset/search?facet=type&limit=0&type=CHECKLIST&facetMultiselect=true\n\t\t\tstill shows type values 'OCCURRENCE' and 'METADATA' even though type is being\n\t\t\tfiltered by type=CHECKLIST\n\t:param hl: [bool] Set ``hl=True`` to highlight terms matching the query when in fulltext\n\t\t\tsearch fields. The highlight will be an emphasis tag of class 'gbifH1' e.g.\n\t\t\thttp://api.gbif.org/v1/dataset/search?q=plant&hl=true\n\t\t\tFulltext search fields include: title, keyword, country, publishing country,\n\t\t\tpublishing organization title, hosting organization title, and description. One\n\t\t\tadditional full text field is searched which includes information from metadata\n\t\t\tdocuments, but the text of this field is not returned in the response.\n\t:param limit: [int] Number of results to return. Default: ``300``\n\t:param offset: [int] Record to start at. Default: ``0``\n\n\t:note: Note that you can pass in additional faceting parameters on a per field basis.\n\t\t\tFor example, if you want to limit the numbef of facets returned from a field ``foo`` to\n\t\t\t3 results, pass in ``foo_facetLimit = 3``. GBIF does not allow all per field parameters,\n\t\t\tbut does allow some. See also examples.\n\n\t:return: A dictionary\n\n\tReferences: http://www.gbif.org/developer/registry#datasetSearch\n\n\tUsage::\n\n\t\t\tfrom pygbif import registry\n\t\t\t# Gets all datasets of type \"OCCURRENCE\".\n\t\t\tregistry.dataset_search(type=\"OCCURRENCE\", limit = 10)\n\n\t\t\t# Fulltext search for all datasets having the word \"amsterdam\" somewhere in\n\t\t\t# its metadata (title, description, etc).\n\t\t\tregistry.dataset_search(q=\"amsterdam\", limit = 10)\n\n\t\t\t# Limited search\n\t\t\tregistry.dataset_search(type=\"OCCURRENCE\", limit=2)\n\t\t\tregistry.dataset_search(type=\"OCCURRENCE\", limit=2, offset=10)\n\n\t\t\t# Search by decade\n\t\t\tregistry.dataset_search(decade=1980, limit = 10)\n\n\t\t\t# Faceting\n\t\t\t## just facets\n\t\t\tregistry.dataset_search(facet=\"decade\", facetMincount=10, limit=0)\n\n\t\t\t## data and facets\n\t\t\tregistry.dataset_search(facet=\"decade\", facetMincount=10, limit=2)\n\n\t\t\t## many facet variables\n\t\t\tregistry.dataset_search(facet=[\"decade\", \"type\"], facetMincount=10, limit=0)\n\n\t\t\t## facet vars\n\t\t\t### per variable paging\n\t\t\tx = registry.dataset_search(\n\t\t\t\tfacet = [\"decade\", \"type\"],\n\t\t\t\tdecade_facetLimit = 3,\n\t\t\t\ttype_facetLimit = 3,\n\t\t\t\tlimit = 0\n\t\t\t)\n\n\t\t\t## highlight\n\t\t\tx = registry.dataset_search(q=\"plant\", hl=True, limit = 10)\n\t\t\t[ z['description'] for z in x['results'] ]\n\t'''\n\turl = gbif_baseurl + 'dataset/search'\n\targs = {'q': q, 'type': type, 'keyword': keyword,\n\t\t\t\t'owningOrg': owningOrg, 'publishingOrg': publishingOrg,\n\t\t\t\t'hostingOrg': hostingOrg, 'decade': decade,\n\t\t\t\t'publishingCountry': publishingCountry, 'facet': facet,\n\t\t\t\t'facetMincount': facetMincount, 'facetMultiselect': facetMultiselect,\n\t\t\t\t'hl': hl, 'limit': limit, 'offset': offset}\n\tgbif_kwargs = {key: kwargs[key] for key in kwargs if key not in requests_argset}\n\tif gbif_kwargs is not None:\n\t\txx = dict(zip( [ re.sub('_', '.', x) for x in gbif_kwargs.keys() ], gbif_kwargs.values() ))\n\t\targs.update(xx)\n\tkwargs = {key: kwargs[key] for key in kwargs if key in requests_argset}\n\tout = gbif_GET(url, args, **kwargs)\n\treturn out", "response": "Search for datasets in the current language."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wkt_rewind(x, digits = None):\n    '''\n    reverse WKT winding order\n\n    :param x: [str] WKT string\n    :param digits: [int] number of digits after decimal to use for the return string. \n        by default, we use the mean number of digits in your string.\n\n    :return: a string\n\n    Usage::\n        \n        from pygbif import wkt_rewind\n        x = 'POLYGON((144.6 13.2, 144.6 13.6, 144.9 13.6, 144.9 13.2, 144.6 13.2))'\n        wkt_rewind(x)\n        wkt_rewind(x, digits = 0)\n        wkt_rewind(x, digits = 3)\n        wkt_rewind(x, digits = 7)\n    '''\n    z = wkt.loads(x)\n    if digits is None:\n      coords = z['coordinates']\n      nums = __flatten(coords)\n      dec_n = [ decimal.Decimal(str(w)).as_tuple().exponent for w in nums ]\n      digits = abs(statistics.mean(dec_n))\n    else:\n      if not isinstance(digits, int):\n        raise TypeError(\"'digits' must be an int\")\n    wound = rewind(z)\n    back_to_wkt = wkt.dumps(wound, decimals = digits)\n    return back_to_wkt", "response": "rewinds the WKT string x to the nearest digit"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef occ_issues_lookup(issue=None, code=None):\n    '''\n    Lookup occurrence issue definitions and short codes\n\n    :param issue: Full name of issue, e.g, CONTINENT_COUNTRY_MISMATCH\n    :param code: an issue short code, e.g. ccm\n\n    Usage\n    pygbif.occ_issues_lookup(issue = 'CONTINENT_COUNTRY_MISMATCH')\n    pygbif.occ_issues_lookup(issue = 'MULTIMEDIA_DATE_INVALID')\n    pygbif.occ_issues_lookup(issue = 'ZERO_COORDINATE')\n    pygbif.occ_issues_lookup(code = 'cdiv')\n    '''\n    if code is None:\n        bb = [trymatch(issue, x) for x in gbifissues['issue'] ]\n        tmp = filter(None, bb)\n    else:\n        bb = [trymatch(code, x) for x in gbifissues['code'] ]\n        tmp = filter(None, bb)\n    return tmp", "response": "Return a sequence of occurrence issue definitions and short codes for the given issue and short code."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsearch GBIF occurrences in a specific GBIF file.", "response": "def search(taxonKey=None, repatriated=None,\n    kingdomKey=None, phylumKey=None, classKey=None, orderKey=None,\n    familyKey=None, genusKey=None, subgenusKey=None, scientificName=None,\n    country=None, publishingCountry=None, hasCoordinate=None, typeStatus=None,\n    recordNumber=None, lastInterpreted=None, continent=None,\n    geometry=None, recordedBy=None, basisOfRecord=None, datasetKey=None,\n    eventDate=None, catalogNumber=None, year=None, month=None,\n    decimalLatitude=None, decimalLongitude=None, elevation=None,\n    depth=None, institutionCode=None, collectionCode=None,\n    hasGeospatialIssue=None, issue=None, q=None, spellCheck=None, mediatype=None,\n    limit=300, offset=0, establishmentMeans=None,\n    facet=None, facetMincount=None, facetMultiselect=None, **kwargs):\n    '''\n    Search GBIF occurrences\n\n    :param taxonKey: [int] A GBIF occurrence identifier\n    :param q: [str] Simple search parameter. The value for this parameter can be a simple word or a phrase.\n    :param spellCheck: [bool] If ``True`` ask GBIF to check your spelling of the value passed to the ``search`` parameter.\n        IMPORTANT: This only checks the input to the ``search`` parameter, and no others. Default: ``False``\n    :param repatriated: [str] Searches for records whose publishing country is different to the country where the record was recorded in\n    :param kingdomKey: [int] Kingdom classification key\n    :param phylumKey: [int] Phylum classification key\n    :param classKey: [int] Class classification key\n    :param orderKey: [int] Order classification key\n    :param familyKey: [int] Family classification key\n    :param genusKey: [int] Genus classification key\n    :param subgenusKey: [int] Subgenus classification key\n    :param scientificName: [str] A scientific name from the GBIF backbone. All included and synonym taxa are included in the search.\n    :param datasetKey: [str] The occurrence dataset key (a uuid)\n    :param catalogNumber: [str] An identifier of any form assigned by the source within a physical collection or digital dataset for the record which may not unique, but should be fairly unique in combination with the institution and collection code.\n    :param recordedBy: [str] The person who recorded the occurrence.\n    :param collectionCode: [str] An identifier of any form assigned by the source to identify the physical collection or digital dataset uniquely within the text of an institution.\n    :param institutionCode: [str] An identifier of any form assigned by the source to identify the institution the record belongs to. Not guaranteed to be que.\n    :param country: [str] The 2-letter country code (as per ISO-3166-1) of the country in which the occurrence was recorded. See here http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\n    :param basisOfRecord: [str] Basis of record, as defined in our BasisOfRecord enum here http://gbif.github.io/gbif-api/apidocs/org/gbif/api/vocabulary/BasisOfRecord.html Acceptable values are:\n\n     - ``FOSSIL_SPECIMEN`` An occurrence record describing a fossilized specimen.\n     - ``HUMAN_OBSERVATION`` An occurrence record describing an observation made by one or more people.\n     - ``LITERATURE`` An occurrence record based on literature alone.\n     - ``LIVING_SPECIMEN`` An occurrence record describing a living specimen, e.g.\n     - ``MACHINE_OBSERVATION`` An occurrence record describing an observation made by a machine.\n     - ``OBSERVATION`` An occurrence record describing an observation.\n     - ``PRESERVED_SPECIMEN`` An occurrence record describing a preserved specimen.\n     - ``UNKNOWN`` Unknown basis for the record.\n\n    :param eventDate: [date] Occurrence date in ISO 8601 format: yyyy, yyyy-MM, yyyy-MM-dd, or\n       MM-dd. Supports range queries, smaller,larger (e.g., ``1990,1991``, whereas ``1991,1990``\n       wouldn't work)\n    :param year: [int] The 4 digit year. A year of 98 will be interpreted as AD 98. Supports range queries,\n       smaller,larger (e.g., ``1990,1991``, whereas ``1991,1990`` wouldn't work)\n    :param month: [int] The month of the year, starting with 1 for January. Supports range queries,\n       smaller,larger (e.g., ``1,2``, whereas ``2,1`` wouldn't work)\n    :param q: [str] Query terms. The value for this parameter can be a simple word or a phrase.\n    :param decimalLatitude: [float] Latitude in decimals between -90 and 90 based on WGS 84.\n       Supports range queries, smaller,larger (e.g., ``25,30``, whereas ``30,25`` wouldn't work)\n    :param decimalLongitude: [float] Longitude in decimals between -180 and 180 based on WGS 84.\n       Supports range queries (e.g., ``-0.4,-0.2``, whereas ``-0.2,-0.4`` wouldn't work).\n    :param publishingCountry: [str] The 2-letter country code (as per ISO-3166-1) of the\n       country in which the occurrence was recorded.\n    :param elevation: [int/str] Elevation in meters above sea level. Supports range queries, smaller,larger\n       (e.g., ``5,30``, whereas ``30,5`` wouldn't work)\n    :param depth: [int/str] Depth in meters relative to elevation. For example 10 meters below a\n       lake surface with given elevation. Supports range queries, smaller,larger (e.g., ``5,30``,\n       whereas ``30,5`` wouldn't work)\n    :param geometry: [str] Searches for occurrences inside a polygon described in Well Known\n       Text (WKT) format. A WKT shape written as either POINT, LINESTRING, LINEARRING\n       POLYGON, or MULTIPOLYGON. Example of a polygon: ``((30.1 10.1, 20, 20 40, 40 40, 30.1 10.1))`` would be queried as http://bit.ly/1BzNwDq.\n       Polygons must have counter-clockwise ordering of points.\n    :param hasGeospatialIssue: [bool] Includes/excludes occurrence records which contain spatial\n       issues (as determined in our record interpretation), i.e. ``hasGeospatialIssue=TRUE``\n       returns only those records with spatial issues while ``hasGeospatialIssue=FALSE`` includes\n       only records without spatial issues. The absence of this parameter returns any\n       record with or without spatial issues.\n    :param issue: [str] One or more of many possible issues with each occurrence record. See\n       Details. Issues passed to this parameter filter results by the issue.\n    :param hasCoordinate: [bool] Return only occurence records with lat/long data (``true``) or\n       all records (``false``, default).\n    :param typeStatus: [str] Type status of the specimen. One of many options. See ?typestatus\n    :param recordNumber: [int] Number recorded by collector of the data, different from GBIF record\n       number. See http://rs.tdwg.org/dwc/terms/#recordNumber} for more info\n    :param lastInterpreted: [date] Date the record was last modified in GBIF, in ISO 8601 format:\n       yyyy, yyyy-MM, yyyy-MM-dd, or MM-dd.  Supports range queries, smaller,larger (e.g.,\n       ``1990,1991``, whereas ``1991,1990`` wouldn't work)\n    :param continent: [str] Continent. One of ``africa``, ``antarctica``, ``asia``, ``europe``, ``north_america``\n       (North America includes the Caribbean and reachies down and includes Panama), ``oceania``,\n       or ``south_america``\n    :param fields: [str] Default (``all``) returns all fields. ``minimal`` returns just taxon name,\n       key, latitude, and longitude. Or specify each field you want returned by name, e.g.\n       ``fields = c('name','latitude','elevation')``.\n    :param mediatype: [str] Media type. Default is ``NULL``, so no filtering on mediatype. Options:\n       ``NULL``, ``MovingImage``, ``Sound``, and ``StillImage``\n    :param limit: [int] Number of results to return. Default: ``300``\n    :param offset: [int] Record to start at. Default: ``0``\n    :param facet: [str] a character vector of length 1 or greater\n    :param establishmentMeans: [str] EstablishmentMeans, possible values include: INTRODUCED,\n        INVASIVE, MANAGED, NATIVE, NATURALISED, UNCERTAIN\n    :param facetMincount: [int] minimum number of records to be included in the faceting results\n    :param facetMultiselect: [bool] Set to ``true`` to still return counts for values that are not currently\n        filtered. See examples. Default: ``false``\n\n    :return: A dictionary\n\n    Usage::\n\n        from pygbif import occurrences\n        occurrences.search(taxonKey = 3329049)\n\n        # Return 2 results, this is the default by the way\n        occurrences.search(taxonKey=3329049, limit=2)\n\n        # Instead of getting a taxon key first, you can search for a name directly\n        # However, note that using this approach (with `scientificName=\"...\"`)\n        # you are getting synonyms too. The results for using `scientifcName` and\n        # `taxonKey` parameters are the same in this case, but I wouldn't be surprised if for some\n        # names they return different results\n        occurrences.search(scientificName = 'Ursus americanus')\n        from pygbif import species\n        key = species.name_backbone(name = 'Ursus americanus', rank='species')['usageKey']\n        occurrences.search(taxonKey = key)\n\n        # Search by dataset key\n        occurrences.search(datasetKey='7b5d6a48-f762-11e1-a439-00145eb45e9a', limit=20)\n\n        # Search by catalog number\n        occurrences.search(catalogNumber=\"49366\", limit=20)\n        # occurrences.search(catalogNumber=[\"49366\",\"Bird.27847588\"], limit=20)\n\n        # Use paging parameters (limit and offset) to page. Note the different results\n        # for the two queries below.\n        occurrences.search(datasetKey='7b5d6a48-f762-11e1-a439-00145eb45e9a', offset=10, limit=5)\n        occurrences.search(datasetKey='7b5d6a48-f762-11e1-a439-00145eb45e9a', offset=20, limit=5)\n\n        # Many dataset keys\n        # occurrences.search(datasetKey=[\"50c9509d-22c7-4a22-a47d-8c48425ef4a7\", \"7b5d6a48-f762-11e1-a439-00145eb45e9a\"], limit=20)\n\n        # Search by collector name\n        res = occurrences.search(recordedBy=\"smith\", limit=20)\n        [ x['recordedBy'] for x in res['results'] ]\n\n        # Many collector names\n        # occurrences.search(recordedBy=[\"smith\",\"BJ Stacey\"], limit=20)\n\n        # Search for many species\n        splist = ['Cyanocitta stelleri', 'Junco hyemalis', 'Aix sponsa']\n        keys = [ species.name_suggest(x)[0]['key'] for x in splist ]\n        out = [ occurrences.search(taxonKey = x, limit=1) for x in keys ]\n        [ x['results'][0]['speciesKey'] for x in out ]\n\n        # Search - q parameter\n        occurrences.search(q = \"kingfisher\", limit=20)\n        ## spell check - only works with the `search` parameter\n        ### spelled correctly - same result as above call\n        occurrences.search(q = \"kingfisher\", limit=20, spellCheck = True)\n        ### spelled incorrectly - stops with suggested spelling\n        occurrences.search(q = \"kajsdkla\", limit=20, spellCheck = True)\n        ### spelled incorrectly - stops with many suggested spellings\n        ###   and number of results for each\n        occurrences.search(q = \"helir\", limit=20, spellCheck = True)\n\n        # Search on latitidue and longitude\n        occurrences.search(decimalLatitude=50, decimalLongitude=10, limit=2)\n\n        # Search on a bounding box\n        ## in well known text format\n        occurrences.search(geometry='POLYGON((30.1 10.1, 10 20, 20 40, 40 40, 30.1 10.1))', limit=20)\n        from pygbif import species\n        key = species.name_suggest(q='Aesculus hippocastanum')[0]['key']\n        occurrences.search(taxonKey=key, geometry='POLYGON((30.1 10.1, 10 20, 20 40, 40 40, 30.1 10.1))', limit=20)\n        ## multipolygon\n        wkt = 'MULTIPOLYGON(((-123 38, -123 43, -116 43, -116 38, -123 38)),((-97 41, -97 45, -93 45, -93 41, -97 41)))'\n        occurrences.search(geometry = wkt, limit = 20)\n\n        # Search on country\n        occurrences.search(country='US', limit=20)\n        occurrences.search(country='FR', limit=20)\n        occurrences.search(country='DE', limit=20)\n\n        # Get only occurrences with lat/long data\n        occurrences.search(taxonKey=key, hasCoordinate=True, limit=20)\n\n        # Get only occurrences that were recorded as living specimens\n        occurrences.search(taxonKey=key, basisOfRecord=\"LIVING_SPECIMEN\", hasCoordinate=True, limit=20)\n\n        # Get occurrences for a particular eventDate\n        occurrences.search(taxonKey=key, eventDate=\"2013\", limit=20)\n        occurrences.search(taxonKey=key, year=\"2013\", limit=20)\n        occurrences.search(taxonKey=key, month=\"6\", limit=20)\n\n        # Get occurrences based on depth\n        key = species.name_backbone(name='Salmo salar', kingdom='animals')['usageKey']\n        occurrences.search(taxonKey=key, depth=\"5\", limit=20)\n\n        # Get occurrences based on elevation\n        key = species.name_backbone(name='Puma concolor', kingdom='animals')['usageKey']\n        occurrences.search(taxonKey=key, elevation=50, hasCoordinate=True, limit=20)\n\n        # Get occurrences based on institutionCode\n        occurrences.search(institutionCode=\"TLMF\", limit=20)\n\n        # Get occurrences based on collectionCode\n        occurrences.search(collectionCode=\"Floristic Databases MV - Higher Plants\", limit=20)\n\n        # Get only those occurrences with spatial issues\n        occurrences.search(taxonKey=key, hasGeospatialIssue=True, limit=20)\n\n        # Search using a query string\n        occurrences.search(q=\"kingfisher\", limit=20)\n\n        # Range queries\n        ## See Detail for parameters that support range queries\n        ### this is a range depth, with lower/upper limits in character string\n        occurrences.search(depth='50,100')\n\n        ## Range search with year\n        occurrences.search(year='1999,2000', limit=20)\n\n        ## Range search with latitude\n        occurrences.search(decimalLatitude='29.59,29.6')\n\n        # Search by specimen type status\n        ## Look for possible values of the typeStatus parameter looking at the typestatus dataset\n        occurrences.search(typeStatus = 'allotype')\n\n        # Search by specimen record number\n        ## This is the record number of the person/group that submitted the data, not GBIF's numbers\n        ## You can see that many different groups have record number 1, so not super helpful\n        occurrences.search(recordNumber = 1)\n\n        # Search by last time interpreted: Date the record was last modified in GBIF\n        ## The lastInterpreted parameter accepts ISO 8601 format dates, including\n        ## yyyy, yyyy-MM, yyyy-MM-dd, or MM-dd. Range queries are accepted for lastInterpreted\n        occurrences.search(lastInterpreted = '2014-04-01')\n\n        # Search by continent\n        ## One of africa, antarctica, asia, europe, north_america, oceania, or south_america\n        occurrences.search(continent = 'south_america')\n        occurrences.search(continent = 'africa')\n        occurrences.search(continent = 'oceania')\n        occurrences.search(continent = 'antarctica')\n\n        # Search for occurrences with images\n        occurrences.search(mediatype = 'StillImage')\n        occurrences.search(mediatype = 'MovingImage')\n        x = occurrences.search(mediatype = 'Sound')\n        [z['media'] for z in x['results']]\n\n        # Query based on issues\n        occurrences.search(taxonKey=1, issue='DEPTH_UNLIKELY')\n        occurrences.search(taxonKey=1, issue=['DEPTH_UNLIKELY','COORDINATE_ROUNDED'])\n        # Show all records in the Arizona State Lichen Collection that cant be matched to the GBIF\n        # backbone properly:\n        occurrences.search(datasetKey='84c0e1a0-f762-11e1-a439-00145eb45e9a', issue=['TAXON_MATCH_NONE','TAXON_MATCH_HIGHERRANK'])\n\n        # If you pass in an invalid polygon you get hopefully informative errors\n        ### the WKT string is fine, but GBIF says bad polygon\n        wkt = 'POLYGON((-178.59375 64.83258989321493,-165.9375 59.24622380205539,\n        -147.3046875 59.065977905449806,-130.78125 51.04484764446178,-125.859375 36.70806354647625,\n        -112.1484375 23.367471303759686,-105.1171875 16.093320185359257,-86.8359375 9.23767076398516,\n        -82.96875 2.9485268155066175,-82.6171875 -14.812060061226388,-74.8828125 -18.849111862023985,\n        -77.34375 -47.661687803329166,-84.375 -49.975955187343295,174.7265625 -50.649460483096114,\n        179.296875 -42.19189902447192,-176.8359375 -35.634976650677295,176.8359375 -31.835565983656227,\n        163.4765625 -6.528187613695323,152.578125 1.894796132058301,135.703125 4.702353722559447,\n        127.96875 15.077427674847987,127.96875 23.689804541429606,139.921875 32.06861069132688,\n        149.4140625 42.65416193033991,159.2578125 48.3160811030533,168.3984375 57.019804336633165,\n        178.2421875 59.95776046458139,-179.6484375 61.16708631440347,-178.59375 64.83258989321493))'\n        occurrences.search(geometry = wkt)\n\n        # Faceting\n        ## return no occurrence records with limit=0\n        x = occurrences.search(facet = \"country\", limit = 0)\n        x['facets']\n\n        ## also return occurrence records\n        x = occurrences.search(facet = \"establishmentMeans\", limit = 10)\n        x['facets']\n        x['results']\n\n        ## multiple facet variables\n        x = occurrences.search(facet = [\"country\", \"basisOfRecord\"], limit = 10)\n        x['results']\n        x['facets']\n        x['facets']['country']\n        x['facets']['basisOfRecord']\n        x['facets']['basisOfRecord']['count']\n\n        ## set a minimum facet count\n        x = occurrences.search(facet = \"country\", facetMincount = 30000000L, limit = 0)\n        x['facets']\n\n        ## paging per each faceted variable\n        ### do so by passing in variables like \"country\" + \"_facetLimit\" = \"country_facetLimit\"\n        ### or \"country\" + \"_facetOffset\" = \"country_facetOffset\"\n        x = occurrences.search(\n          facet = [\"country\", \"basisOfRecord\", \"hasCoordinate\"],\n          country_facetLimit = 3,\n          basisOfRecord_facetLimit = 6,\n          limit = 0\n        )\n        x['facets']\n\n        # requests package options\n        ## There's an acceptable set of requests options (['timeout', 'cookies', 'auth',\n        ## 'allow_redirects', 'proxies', 'verify', 'stream', 'cert']) you can pass\n        ## in via **kwargs, e.g., set a timeout\n        x = occurrences.search(timeout = 1)\n    '''\n    url = gbif_baseurl + 'occurrence/search'\n    args = {'taxonKey': taxonKey, 'repatriated': repatriated,\n        'kingdomKey': kingdomKey, 'phylumKey': phylumKey, 'classKey': classKey,\n        'orderKey': orderKey, 'familyKey': familyKey, 'genusKey': genusKey,\n        'subgenusKey': subgenusKey, 'scientificName': scientificName,\n        'country': country, 'publishingCountry': publishingCountry,\n        'hasCoordinate': hasCoordinate, 'typeStatus': typeStatus,\n        'recordNumber': recordNumber, 'lastInterpreted': lastInterpreted,\n        'continent': continent, 'geometry': geometry, 'recordedBy': recordedBy,\n        'basisOfRecord': basisOfRecord, 'datasetKey': datasetKey, 'eventDate': eventDate,\n        'catalogNumber': catalogNumber, 'year': year, 'month': month,\n        'decimalLatitude': decimalLatitude, 'decimalLongitude': decimalLongitude,\n        'elevation': elevation, 'depth': depth, 'institutionCode': institutionCode,\n        'collectionCode': collectionCode, 'hasGeospatialIssue': hasGeospatialIssue,\n        'issue': issue, 'q': q, 'spellCheck': spellCheck, 'mediatype': mediatype,\n        'limit': limit, 'offset': offset, 'establishmentMeans': establishmentMeans,\n        'facetMincount': facetMincount, 'facet': facet,\n        'facetMultiselect': facetMultiselect}\n    gbif_kwargs = {key: kwargs[key] for key in kwargs if key not in requests_argset}\n    if gbif_kwargs is not None:\n        xx = dict(zip( [ re.sub('_', '.', x) for x in gbif_kwargs.keys() ], gbif_kwargs.values() ))\n        args.update(xx)\n    kwargs = {key: kwargs[key] for key in kwargs if key in requests_argset}\n    out = gbif_GET(url, args, **kwargs)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef networks(data = 'all', uuid = None, q = None, identifier = None,\n  identifierType = None, limit = 100, offset = None, **kwargs):\n  '''\n  Networks metadata.\n\n  Note: there's only 1 network now, so there's not a lot you can do with this method.\n\n  :param data: [str] The type of data to get. Default: ``all``\n  :param uuid: [str] UUID of the data network provider. This must be specified if data\n     is anything other than ``all``.\n  :param q: [str] Query networks. Only used when ``data = 'all'``. Ignored otherwise.\n  :param identifier: [fixnum] The value for this parameter can be a simple string or integer,\n      e.g. identifier=120\n  :param identifierType: [str] Used in combination with the identifier parameter to filter\n      identifiers by identifier type: ``DOI``, ``FTP``, ``GBIF_NODE``, ``GBIF_PARTICIPANT``,\n      ``GBIF_PORTAL``, ``HANDLER``, ``LSID``, ``UNKNOWN``, ``URI``, ``URL``, ``UUID``\n  :param limit: [int] Number of results to return. Default: ``100``\n  :param offset: [int] Record to start at. Default: ``0``\n\n  :return: A dictionary\n\n  References: http://www.gbif.org/developer/registry#networks\n\n  Usage::\n\n      from pygbif import registry\n      registry.networks(limit=1)\n      registry.networks(uuid='2b7c7b4f-4d4f-40d3-94de-c28b6fa054a6')\n  '''\n  args = {'q': q, 'limit': limit, 'offset': offset, 'identifier': identifier,\n    'identifierType': identifierType}\n  data_choices = ['all', 'contact', 'endpoint', 'identifier',\n    'tag', 'machineTag', 'comment', 'constituents']\n  check_data(data, data_choices)\n\n  def getdata(x, uuid, args, **kwargs):\n    if x is not 'all' and uuid is None:\n      stop('You must specify a uuid if data does not equal \"all\"')\n\n    if uuid is None:\n      url = gbif_baseurl + 'network'\n    else:\n      if x is 'all':\n        url = gbif_baseurl + 'network/' + uuid\n      else:\n        url = gbif_baseurl + 'network/' + uuid + '/' + x\n\n    res = gbif_GET(url, args, **kwargs)\n    return {'meta': get_meta(res), 'data': parse_results(res, uuid)}\n\n  if len2(data) == 1:\n    return getdata(data, uuid, args, **kwargs)\n  else:\n    return [getdata(x, uuid, args, **kwargs) for x in data]", "response": "Get a dictionary of network metadata."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a GBIF map for the specified source.", "response": "def map(source = 'density', z = 0, x = 0, y = 0, format = '@1x.png', \n    srs='EPSG:4326', bin=None, hexPerTile=None, style='classic.point', \n    taxonKey=None, country=None,  publishingCountry=None, publisher=None,\n    datasetKey=None, year=None, basisOfRecord=None, **kwargs):\n    '''\n    GBIF maps API\n\n    :param source: [str] Either ``density`` for fast, precalculated tiles,\n        or ``adhoc`` for any search\n    :param z: [str] zoom level\n    :param x: [str] longitude\n    :param y: [str] latitude\n    :param format: [str] format of returned data. One of:\n\n      - ``.mvt`` - vector tile\n      - ``@Hx.png`` - 256px raster tile (for legacy clients)\n      - ``@1x.png`` - 512px raster tile, @2x.png for a 1024px raster tile\n      - ``@2x.png`` - 1024px raster tile\n      - ``@3x.png`` - 2048px raster tile\n      - ``@4x.png`` - 4096px raster tile\n\n    :param srs: [str] Spatial reference system. One of:\n\n      - ``EPSG:3857`` (Web Mercator)\n      - ``EPSG:4326`` (WGS84 plate caree)\n      - ``EPSG:3575`` (Arctic LAEA)\n      - ``EPSG:3031`` (Antarctic stereographic)\n\n    :param bin: [str] square or hex to aggregate occurrence counts into\n        squares or hexagons. Points by default.\n    :param hexPerTile: [str] sets the size of the hexagons (the number \n        horizontally across a tile)\n    :param squareSize: [str] sets the size of the squares. Choose a factor \n        of 4096 so they tessalate correctly: probably from 8, 16, 32, 64, \n        128, 256, 512.\n    :param style: [str] for raster tiles, choose from the available styles.\n        Defaults to classic.point.\n    :param taxonKey: [int] A GBIF occurrence identifier\n    :param datasetKey: [str] The occurrence dataset key (a uuid)\n    :param country: [str] The 2-letter country code (as per ISO-3166-1) of \n        the country in which the occurrence was recorded. See here\n        http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\n    :param basisOfRecord: [str] Basis of record, as defined in the BasisOfRecord enum \n        http://gbif.github.io/gbif-api/apidocs/org/gbif/api/vocabulary/BasisOfRecord.html\n        Acceptable values are\n\n       - ``FOSSIL_SPECIMEN`` An occurrence record describing a fossilized specimen.\n       - ``HUMAN_OBSERVATION`` An occurrence record describing an observation made by one or more people.\n       - ``LITERATURE`` An occurrence record based on literature alone.\n       - ``LIVING_SPECIMEN`` An occurrence record describing a living specimen, e.g.\n       - ``MACHINE_OBSERVATION`` An occurrence record describing an observation made by a machine.\n       - ``OBSERVATION`` An occurrence record describing an observation.\n       - ``PRESERVED_SPECIMEN`` An occurrence record describing a preserved specimen.\n       - ``UNKNOWN`` Unknown basis for the record.\n\n    :param year: [int] The 4 digit year. A year of 98 will be interpreted as \n        AD 98. Supports range queries, smaller,larger (e.g., ``1990,1991``, \n        whereas ``1991,1990`` wouldn't work)\n    :param publishingCountry: [str] The 2-letter country code (as per \n        ISO-3166-1) of the country in which the occurrence was recorded.\n\n    :return: An object of class GbifMap\n\n    For mvt format, see https://github.com/tilezen/mapbox-vector-tile to \n    decode, and example below\n\n    Usage::\n\n        from pygbif import maps\n        out = maps.map(taxonKey = 2435098)\n        out.response\n        out.path\n        out.img\n        out.plot()\n\n        out = maps.map(taxonKey = 2480498, year = range(2008, 2011+1))\n        out.response\n        out.path\n        out.img\n        out.plot()\n        \n        # srs\n        maps.map(taxonKey = 2480498, year = 2010, srs = \"EPSG:3857\")\n        # bin\n        maps.map(taxonKey = 212, year = 1998, bin = \"hex\",\n           hexPerTile = 30, style = \"classic-noborder.poly\")\n        # style\n        maps.map(taxonKey = 2480498, style = \"purpleYellow.point\").plot()\n        # basisOfRecord\n        maps.map(taxonKey = 2480498, year = 2010,\n          basisOfRecord = \"HUMAN_OBSERVATION\", bin = \"hex\", \n          hexPerTile = 500).plot()\n        maps.map(taxonKey = 2480498, year = 2010, \n          basisOfRecord = [\"HUMAN_OBSERVATION\", \"LIVING_SPECIMEN\"],\n          hexPerTile = 500, bin = \"hex\").plot()\n\n        # map vector tiles, gives back raw bytes\n        from pygbif import maps\n        x = maps.map(taxonKey = 2480498, year = 2010,\n          format = \".mvt\")\n        x.response\n        x.path\n        x.img # None\n        import mapbox_vector_tile\n        mapbox_vector_tile.decode(x.response.content)\n    '''\n    if format not in ['.mvt', '@Hx.png', '@1x.png', '@2x.png', '@3x.png', '@4x.png']:\n      raise ValueError(\"'format' not in allowed set, see docs\")\n    if source not in ['density', 'adhoc']:\n      raise ValueError(\"'source' not in allowed set, see docs\")\n    if srs not in ['EPSG:3857', 'EPSG:4326', 'EPSG:3575', 'EPSG:3031']:\n      raise ValueError(\"'srs' not in allowed set, see docs\")\n    if bin is not None:\n      if bin not in ['square', 'hex']:\n        raise ValueError(\"'bin' not in allowed set, see docs\")\n    if style is not None:\n      if style not in map_styles:\n        raise ValueError(\"'style' not in allowed set, see docs\")\n\n    maps_baseurl = 'https://api.gbif.org'\n    url = maps_baseurl + '/v2/map/occurrence/%s/%s/%s/%s%s'\n    url = url % ( source, z, x, y, format )\n    year = __handle_year(year)\n    basisOfRecord = __handle_bor(basisOfRecord)\n    args = {'srs': srs, 'bin': bin, 'hexPerTile': hexPerTile, 'style': style,\n        'taxonKey': taxonKey, 'country': country,\n        'publishingCountry': publishingCountry, 'publisher': publisher,\n        'datasetKey': datasetKey, 'year': year,\n        'basisOfRecord': basisOfRecord}\n    kw = {key: kwargs[key] for key in kwargs if key not in requests_argset}\n    if kw is not None:\n        xx = dict(zip( [ re.sub('_', '.', x) for x in kw.keys() ], kw.values() ))\n        args.update(xx)\n    kwargs = {key: kwargs[key] for key in kwargs if key in requests_argset}\n    ctype = 'image/png' if has(format, \"png\") else 'application/x-protobuf'\n    out = gbif_GET_map(url, args, ctype, **kwargs)\n    # return out\n    return GbifMap(out)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _check_environ(variable, value):\n    if is_not_none(value):\n        return value\n    else:\n        value = os.environ.get(variable)\n        if is_none(value):\n            stop(''.join([variable,\n                          \"\"\" not supplied and no entry in environmental\n                           variables\"\"\"]))\n        else:\n            return value", "response": "check if a variable is present in the environmental variables"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef download(queries, user=None, pwd=None,\n             email=None, pred_type='and'):\n    \"\"\"\n    Spin up a download request for GBIF occurrence data.\n\n    :param queries: One or more of query arguments to kick of a download job.\n        See Details.\n    :type queries: str or list\n    :param pred_type: (character) One of ``equals`` (``=``), ``and`` (``&``),\n        `or`` (``|``), ``lessThan`` (``<``), ``lessThanOrEquals`` (``<=``),\n        ``greaterThan`` (``>``), ``greaterThanOrEquals`` (``>=``),\n        ``in``, ``within``, ``not`` (``!``), ``like``\n    :param user: (character) User name within GBIF's website.\n        Required. Set in your env vars with the option ``GBIF_USER``\n    :param pwd: (character) User password within GBIF's website. Required.\n        Set in your env vars with the option ``GBIF_PWD``\n    :param email: (character) Email address to recieve download notice done\n        email. Required. Set in your env vars with the option ``GBIF_EMAIL``\n\n    Argument passed have to be passed as character (e.g., ``country = US``),\n    with a space between key (``country``), operator (``=``), and value (``US``).\n    See the ``type`` parameter for possible options for the operator.\n    This character string is parsed internally.\n\n    Acceptable arguments to ``...`` (args) are:\n\n     - taxonKey = ``TAXON_KEY``\n     - scientificName = ``SCIENTIFIC_NAME``\n     - country = ``COUNTRY``\n     - publishingCountry = ``PUBLISHING_COUNTRY``\n     - hasCoordinate = ``HAS_COORDINATE``\n     - hasGeospatialIssue = ``HAS_GEOSPATIAL_ISSUE``\n     - typeStatus = ``TYPE_STATUS``\n     - recordNumber = ``RECORD_NUMBER``\n     - lastInterpreted = ``LAST_INTERPRETED``\n     - continent = ``CONTINENT``\n     - geometry = ``GEOMETRY``\n     - basisOfRecord = ``BASIS_OF_RECORD``\n     - datasetKey = ``DATASET_KEY``\n     - eventDate = ``EVENT_DATE``\n     - catalogNumber = ``CATALOG_NUMBER``\n     - year = ``YEAR``\n     - month = ``MONTH``\n     - decimalLatitude = ``DECIMAL_LATITUDE``\n     - decimalLongitude = ``DECIMAL_LONGITUDE``\n     - elevation = ``ELEVATION``\n     - depth = ``DEPTH``\n     - institutionCode = ``INSTITUTION_CODE``\n     - collectionCode = ``COLLECTION_CODE``\n     - issue = ``ISSUE``\n     - mediatype = ``MEDIA_TYPE``\n     - recordedBy = ``RECORDED_BY``\n     - repatriated = ``REPATRIATED``\n\n    See the API docs http://www.gbif.org/developer/occurrence#download\n    for more info, and the predicates docs\n    http://www.gbif.org/developer/occurrence#predicates\n\n    GBIF has a limit of 12,000 characters for download queries - so\n    if you're download request is really, really long and complex,\n    consider breaking it up into multiple requests by one factor or\n    another.\n\n    :return: A dictionary, of results\n\n    Usage::\n\n        from pygbif import occurrences as occ\n\n        occ.download('basisOfRecord = LITERATURE')\n        occ.download('taxonKey = 3119195')\n        occ.download('decimalLatitude > 50')\n        occ.download('elevation >= 9000')\n        occ.download('decimalLatitude >= 65')\n        occ.download('country = US')\n        occ.download('institutionCode = TLMF')\n        occ.download('catalogNumber = Bird.27847588')\n\n        res = occ.download(['taxonKey = 7264332', 'hasCoordinate = TRUE'])\n\n        # pass output to download_meta for more information\n        occ.download_meta(occ.download('decimalLatitude > 75'))\n\n        # Multiple queries\n        gg = occ.download(['decimalLatitude >= 65',\n                          'decimalLatitude <= -65'], type='or')\n        gg = occ.download(['depth = 80', 'taxonKey = 2343454'],\n                          type='or')\n\n        # Repratriated data for Costa Rica\n        occ.download(['country = CR', 'repatriated = true'])\n    \"\"\"\n\n    user = _check_environ('GBIF_USER', user)\n    pwd = _check_environ('GBIF_PWD', pwd)\n    email = _check_environ('GBIF_EMAIL', email)\n\n    if isinstance(queries, str):\n        queries = [queries]\n\n    keyval = [_parse_args(z) for z in queries]\n\n    # USE GBIFDownload class to set up the predicates\n    req = GbifDownload(user, email)\n    req.main_pred_type = pred_type\n    for predicate in keyval:\n        req.add_predicate(predicate['key'],\n                          predicate['value'],\n                          predicate['type'])\n\n    out = req.post_download(user, pwd)\n    return out, req.payload", "response": "This function is used to kick up a download job for a GBIF occurrence data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef download_list(user=None, pwd=None, limit=20, offset=0):\n\n    user = _check_environ('GBIF_USER', user)\n    pwd = _check_environ('GBIF_PWD', pwd)\n\n    url = 'http://api.gbif.org/v1/occurrence/download/user/' + user\n    args = {'limit': limit, 'offset': offset}\n    res = gbif_GET(url, args, auth=(user, pwd))\n    return {'meta': {'offset': res['offset'],\n                     'limit': res['limit'],\n                     'endofrecords': res['endOfRecords'],\n                     'count': res['count']},\n            'results': res['results']}", "response": "Lists the downloads created by a user."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef download_get(key, path=\".\", **kwargs):\n    meta = pygbif.occurrences.download_meta(key)\n    if meta['status'] != 'SUCCEEDED':\n        raise Exception('download \"%s\" not of status SUCCEEDED' % key)\n    else:\n        print('Download file size: %s bytes' % meta['size'])\n        url = 'http://api.gbif.org/v1/occurrence/download/request/' + key\n        path = \"%s/%s.zip\" % (path, key)\n        gbif_GET_write(url, path, **kwargs)\n        print(\"On disk at \" + path)\n        return {'path': path, 'size': meta['size'], 'key': key}", "response": "Download a file from GBIF."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main_pred_type(self, value):\n        if value not in operators:\n            value = operator_lkup.get(value)\n        if value:\n            self._main_pred_type = value\n            self.payload['predicate']['type'] = self._main_pred_type\n        else:\n            raise Exception(\"main predicate combiner not a valid operator\")", "response": "set main predicate combination type"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds predicate to the list of predicates", "response": "def add_predicate(self, key, value, predicate_type='equals'):\n        \"\"\"\n        add key, value, type combination of a predicate\n\n        :param key: query KEY parameter\n        :param value: the value used in the predicate\n        :param predicate_type: the type of predicate (e.g. ``equals``)\n        \"\"\"\n        if predicate_type not in operators:\n            predicate_type = operator_lkup.get(predicate_type)\n        if predicate_type:\n            self.predicates.append({'type': predicate_type,\n                                    'key': key,\n                                    'value': value\n                                    })\n        else:\n            raise Exception(\"predicate type not a valid operator\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract values from either file or list of values", "response": "def _extract_values(values_list):\n        \"\"\"extract values from either file or list\n\n        :param values_list: list or file name (str) with list of values\n        \"\"\"\n        values = []\n        # check if file or list of values to iterate\n        if isinstance(values_list, str):\n            with open(values_list) as ff:\n                reading = csv.reader(ff)\n                for j in reading:\n                    values.append(j[0])\n        elif isinstance(values_list, list):\n            values = values_list\n        else:\n            raise Exception(\"input datatype not supported.\")\n        return values"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd an iterative predicate with a key and set of values_list which it can be equal to in and or function.", "response": "def add_iterative_predicate(self, key, values_list):\n        \"\"\"add an iterative predicate with a key and set of values\n        which it can be equal to in and or function.\n        The individual predicates are specified with the type ``equals`` and\n        combined with a type ``or``.\n\n        The main reason for this addition is the inability of using ``in`` as\n        predicate type wfor multiple taxon_key values\n        (cfr. http://dev.gbif.org/issues/browse/POR-2753)\n\n        :param key: API key to use for the query.\n        :param values_list: Filename or list containing the taxon keys to be s\n            searched.\n\n        \"\"\"\n        values = self._extract_values(values_list)\n\n        predicate = {'type': 'equals', 'key': key, 'value': None}\n        predicates = []\n        while values:\n            predicate['value'] = values.pop()\n            predicates.append(predicate.copy())\n        self.predicates.append({'type': 'or', 'predicates': predicates})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting details for a single interpreted occurrence", "response": "def get(key, **kwargs):\n    '''\n    Gets details for a single, interpreted occurrence\n\n    :param key: [int] A GBIF occurrence key\n\n    :return: A dictionary, of results\n\n    Usage::\n\n        from pygbif import occurrences\n        occurrences.get(key = 1258202889)\n        occurrences.get(key = 1227768771)\n        occurrences.get(key = 1227769518)\n    '''\n    url = gbif_baseurl + 'occurrence/' + str(key)\n    out = gbif_GET(url, {}, **kwargs)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a verbatim occurrence record without any interpretation", "response": "def get_verbatim(key, **kwargs):\n    '''\n    Gets a verbatim occurrence record without any interpretation\n\n    :param key: [int] A GBIF occurrence key\n\n    :return: A dictionary, of results\n\n    Usage::\n\n        from pygbif import occurrences\n        occurrences.get_verbatim(key = 1258202889)\n        occurrences.get_verbatim(key = 1227768771)\n        occurrences.get_verbatim(key = 1227769518)\n    '''\n    url = gbif_baseurl + 'occurrence/' + str(key) + '/verbatim'\n    out = gbif_GET(url, {}, **kwargs)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_fragment(key, **kwargs):\n    '''\n    Get a single occurrence fragment in its raw form (xml or json)\n\n    :param key: [int] A GBIF occurrence key\n\n    :return: A dictionary, of results\n\n    Usage::\n\n        from pygbif import occurrences\n        occurrences.get_fragment(key = 1052909293)\n        occurrences.get_fragment(key = 1227768771)\n        occurrences.get_fragment(key = 1227769518)\n    '''\n    url = gbif_baseurl + 'occurrence/' + str(key) + '/fragment'\n    out = gbif_GET(url, {}, **kwargs)\n    return out", "response": "Get a single occurrence fragment in its raw form."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing taxon names using the GBIF name parser.", "response": "def name_parser(name, **kwargs):\n  '''\n  Parse taxon names using the GBIF name parser\n\n  :param name: [str] A character vector of scientific names. (required)\n\n  reference: http://www.gbif.org/developer/species#parser\n\n  Usage::\n\n      from pygbif import species\n      species.name_parser('x Agropogon littoralis')\n      species.name_parser(['Arrhenatherum elatius var. elatius',\n        'Secale cereale subsp. cereale', 'Secale cereale ssp. cereale',\n        'Vanessa atalanta (Linnaeus, 1758)'])\n  '''\n  url = gbif_baseurl + 'parser/name'\n  if name.__class__ == str:\n    name = [name]\n  return gbif_POST(url, name, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef name_lookup(q=None, rank=None, higherTaxonKey=None, status=None, isExtinct=None,\n\thabitat=None, nameType=None, datasetKey=None, nomenclaturalStatus=None,\n\tlimit=100, offset=None, facet=False, facetMincount=None, facetMultiselect=None,\n\ttype=None, hl=False, verbose=False, **kwargs):\n\t'''\n\tLookup names in all taxonomies in GBIF.\n\n\tThis service uses fuzzy lookup so that you can put in partial names and\n\tyou should get back those things that match. See examples below.\n\n\t:param q: [str] Query term(s) for full text search (optional)\n\t:param rank: [str] ``CLASS``, ``CULTIVAR``, ``CULTIVAR_GROUP``, ``DOMAIN``, ``FAMILY``,\n\t\t ``FORM``, ``GENUS``, ``INFORMAL``, ``INFRAGENERIC_NAME``, ``INFRAORDER``, ``INFRASPECIFIC_NAME``,\n\t\t ``INFRASUBSPECIFIC_NAME``, ``KINGDOM``, ``ORDER``, ``PHYLUM``, ``SECTION``, ``SERIES``, ``SPECIES``, ``STRAIN``, ``SUBCLASS``,\n\t\t ``SUBFAMILY``, ``SUBFORM``, ``SUBGENUS``, ``SUBKINGDOM``, ``SUBORDER``, ``SUBPHYLUM``, ``SUBSECTION``, ``SUBSERIES``,\n\t\t ``SUBSPECIES``, ``SUBTRIBE``, ``SUBVARIETY``, ``SUPERCLASS``, ``SUPERFAMILY``, ``SUPERORDER``, ``SUPERPHYLUM``,\n\t\t ``SUPRAGENERIC_NAME``, ``TRIBE``, ``UNRANKED``, ``VARIETY`` (optional)\n\t:param verbose: [bool] If True show alternative matches considered which had been rejected.\n\t:param higherTaxonKey: [str] Filters by any of the higher Linnean rank keys. Note this\n\t\t\tis within the respective checklist and not searching nub keys across all checklists (optional)\n\t:param status: [str] (optional) Filters by the taxonomic status as one of:\n\n\t\t* ``ACCEPTED``\n\t\t* ``DETERMINATION_SYNONYM`` Used for unknown child taxa referred to via spec, ssp, ...\n\t\t* ``DOUBTFUL`` Treated as accepted, but doubtful whether this is correct.\n\t\t* ``HETEROTYPIC_SYNONYM`` More specific subclass of ``SYNONYM``.\n\t\t* ``HOMOTYPIC_SYNONYM`` More specific subclass of ``SYNONYM``.\n\t\t* ``INTERMEDIATE_RANK_SYNONYM`` Used in nub only.\n\t\t* ``MISAPPLIED`` More specific subclass of ``SYNONYM``.\n\t\t* ``PROPARTE_SYNONYM`` More specific subclass of ``SYNONYM``.\n\t\t* ``SYNONYM`` A general synonym, the exact type is unknown.\n\n\t:param isExtinct: [bool] Filters by extinction status (e.g. ``isExtinct=True``)\n\t:param habitat: [str] Filters by habitat. One of: ``marine``, ``freshwater``, or\n\t\t\t``terrestrial`` (optional)\n\t:param nameType: [str] (optional) Filters by the name type as one of:\n\n\t\t* ``BLACKLISTED`` surely not a scientific name.\n\t\t* ``CANDIDATUS`` Candidatus is a component of the taxonomic name for a bacterium that cannot be maintained in a Bacteriology Culture Collection.\n\t\t* ``CULTIVAR`` a cultivated plant name.\n\t\t* ``DOUBTFUL`` doubtful whether this is a scientific name at all.\n\t\t* ``HYBRID`` a hybrid formula (not a hybrid name).\n\t\t* ``INFORMAL`` a scientific name with some informal addition like \"cf.\" or indetermined like Abies spec.\n\t\t* ``SCINAME`` a scientific name which is not well formed.\n\t\t* ``VIRUS`` a virus name.\n\t\t* ``WELLFORMED`` a well formed scientific name according to present nomenclatural rules.\n\n\t:param datasetKey: [str] Filters by the dataset's key (a uuid) (optional)\n\t:param nomenclaturalStatus: [str] Not yet implemented, but will eventually allow for\n\t\t\tfiltering by a nomenclatural status enum\n\t:param limit: [fixnum] Number of records to return. Maximum: ``1000``. (optional)\n\t:param offset: [fixnum] Record number to start at. (optional)\n\t:param facet: [str] A list of facet names used to retrieve the 100 most frequent values\n\t\t\tfor a field. Allowed facets are: ``datasetKey``, ``higherTaxonKey``, ``rank``, ``status``,\n\t\t\t``isExtinct``, ``habitat``, and ``nameType``. Additionally ``threat`` and ``nomenclaturalStatus``\n\t\t\tare legal values but not yet implemented, so data will not yet be returned for them. (optional)\n\t:param facetMincount: [str] Used in combination with the facet parameter. Set\n\t\t\t``facetMincount={#}`` to exclude facets with a count less than {#}, e.g.\n\t\t\thttp://bit.ly/1bMdByP only shows the type value ``ACCEPTED`` because the other\n\t\t\tstatuses have counts less than 7,000,000 (optional)\n\t:param facetMultiselect: [bool] Used in combination with the facet parameter. Set\n\t\t\t``facetMultiselect=True`` to still return counts for values that are not currently\n\t\t\tfiltered, e.g. http://bit.ly/19YLXPO still shows all status values even though\n\t\t\tstatus is being filtered by ``status=ACCEPTED`` (optional)\n\t:param type: [str] Type of name. One of ``occurrence``, ``checklist``, or ``metadata``. (optional)\n\t:param hl: [bool] Set ``hl=True`` to highlight terms matching the query when in fulltext\n\t\t\tsearch fields. The highlight will be an emphasis tag of class ``gbifH1`` e.g.\n\t\t\t``q='plant', hl=True``. Fulltext search fields include: ``title``, ``keyword``, ``country``,\n\t\t\t``publishing country``, ``publishing organization title``, ``hosting organization title``, and\n\t\t\t``description``. One additional full text field is searched which includes information from\n\t\t\tmetadata documents, but the text of this field is not returned in the response. (optional)\n\n\t:return: A dictionary\n\n\t:references: http://www.gbif.org/developer/species#searching\n\n\tUsage::\n\n\t\t\tfrom pygbif import species\n\n\t\t\t# Look up names like mammalia\n\t\t\tspecies.name_lookup(q='mammalia')\n\n\t\t\t# Paging\n\t\t\tspecies.name_lookup(q='mammalia', limit=1)\n\t\t\tspecies.name_lookup(q='mammalia', limit=1, offset=2)\n\n\t\t\t# large requests, use offset parameter\n\t\t\tfirst = species.name_lookup(q='mammalia', limit=1000)\n\t\t\tsecond = species.name_lookup(q='mammalia', limit=1000, offset=1000)\n\n\t\t\t# Get all data and parse it, removing descriptions which can be quite long\n\t\t\tspecies.name_lookup('Helianthus annuus', rank=\"species\", verbose=True)\n\n\t\t\t# Get all data and parse it, removing descriptions field which can be quite long\n\t\t\tout = species.name_lookup('Helianthus annuus', rank=\"species\")\n\t\t\tres = out['results']\n\t\t\t[ z.pop('descriptions', None) for z in res ]\n\t\t\tres\n\n\t\t\t# Fuzzy searching\n\t\t\tspecies.name_lookup(q='Heli', rank=\"genus\")\n\n\t\t\t# Limit records to certain number\n\t\t\tspecies.name_lookup('Helianthus annuus', rank=\"species\", limit=2)\n\n\t\t\t# Query by habitat\n\t\t\tspecies.name_lookup(habitat = \"terrestrial\", limit=2)\n\t\t\tspecies.name_lookup(habitat = \"marine\", limit=2)\n\t\t\tspecies.name_lookup(habitat = \"freshwater\", limit=2)\n\n\t\t\t# Using faceting\n\t\t\tspecies.name_lookup(facet='status', limit=0, facetMincount='70000')\n\t\t\tspecies.name_lookup(facet=['status', 'higherTaxonKey'], limit=0, facetMincount='700000')\n\n\t\t\tspecies.name_lookup(facet='nameType', limit=0)\n\t\t\tspecies.name_lookup(facet='habitat', limit=0)\n\t\t\tspecies.name_lookup(facet='datasetKey', limit=0)\n\t\t\tspecies.name_lookup(facet='rank', limit=0)\n\t\t\tspecies.name_lookup(facet='isExtinct', limit=0)\n\n\t\t\t# text highlighting\n\t\t\tspecies.name_lookup(q='plant', hl=True, limit=30)\n\n\t\t\t# Lookup by datasetKey\n\t\t\tspecies.name_lookup(datasetKey='3f8a1297-3259-4700-91fc-acc4170b27ce')\n\t'''\n\targs = {'q': q, 'rank': rank, 'higherTaxonKey': higherTaxonKey,\n\t\t'status': status, 'isExtinct': isExtinct, 'habitat': habitat,\n\t\t'nameType': nameType, 'datasetKey': datasetKey,\n\t\t'nomenclaturalStatus': nomenclaturalStatus, 'limit': limit, 'offset': offset,\n\t\t'facet': bn(facet), 'facetMincount': facetMincount, 'facetMultiselect': facetMultiselect,\n\t\t'hl': bn(hl), 'verbose': bn(verbose), 'type': type}\n\tgbif_kwargs = {key: kwargs[key] for key in kwargs if key not in requests_argset}\n\tif gbif_kwargs is not None:\n\t\t\txx = dict(zip( [ re.sub('_', '.', x) for x in gbif_kwargs.keys() ], gbif_kwargs.values() ))\n\t\t\targs.update(xx)\n\tkwargs = {key: kwargs[key] for key in kwargs if key in requests_argset}\n\treturn gbif_GET(gbif_baseurl + 'species/search', args, **kwargs)", "response": "This function is used to perform a fuzzy name lookup on a set of terms."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns occurrence counts for a predefined set of dimensions of a predefined set of dimensions of a GBIF occurrence identifier.", "response": "def count(taxonKey=None, basisOfRecord=None, country=None, isGeoreferenced=None,\n    datasetKey=None, publishingCountry=None, typeStatus=None,\n    issue=None, year=None, **kwargs):\n    '''\n    Returns occurrence counts for a predefined set of dimensions\n\n    :param taxonKey: [int] A GBIF occurrence identifier\n    :param basisOfRecord: [str] A GBIF occurrence identifier\n    :param country: [str] A GBIF occurrence identifier\n    :param isGeoreferenced: [bool] A GBIF occurrence identifier\n    :param datasetKey: [str] A GBIF occurrence identifier\n    :param publishingCountry: [str] A GBIF occurrence identifier\n    :param typeStatus: [str] A GBIF occurrence identifier\n    :param issue: [str] A GBIF occurrence identifier\n    :param year: [int] A GBIF occurrence identifier\n\n    :return: dict\n\n    Usage::\n\n        from pygbif import occurrences\n        occurrences.count(taxonKey = 3329049)\n        occurrences.count(country = 'CA')\n        occurrences.count(isGeoreferenced = True)\n        occurrences.count(basisOfRecord = 'OBSERVATION')\n    '''\n    url = gbif_baseurl + 'occurrence/count'\n    out = gbif_GET(url, {'taxonKey': taxonKey, 'basisOfRecord': basisOfRecord, 'country': country,\n        'isGeoreferenced': isGeoreferenced, 'datasetKey': datasetKey,\n        'publishingCountry': publishingCountry, 'typeStatus': typeStatus,\n        'issue': issue, 'year': year}, **kwargs)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef count_year(year, **kwargs):\n    '''\n    Lists occurrence counts by year\n\n    :param year: [int] year range, e.g., ``1990,2000``. Does not support ranges like ``asterisk,2010``\n\n    :return: dict\n\n    Usage::\n\n            from pygbif import occurrences\n            occurrences.count_year(year = '1990,2000')\n    '''\n    url = gbif_baseurl + 'occurrence/counts/year'\n    out = gbif_GET(url, {'year': year}, **kwargs)\n    return out", "response": "Lists occurrence counts by year"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a dictionary of occurrence counts for datasets that cover a given taxon or country.", "response": "def count_datasets(taxonKey = None, country = None, **kwargs):\n    '''\n    Lists occurrence counts for datasets that cover a given taxon or country\n\n    :param taxonKey: [int] Taxon key\n    :param country: [str] A country, two letter code\n\n    :return: dict\n\n    Usage::\n\n            from pygbif import occurrences\n            occurrences.count_datasets(country = \"DE\")\n    '''\n    url = gbif_baseurl + 'occurrence/counts/datasets'\n    out = gbif_GET(url, {'taxonKey': taxonKey, 'country': country}, **kwargs)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dictionary containing the occurrence counts for all countries covered by the data published by the given country.", "response": "def count_countries(publishingCountry, **kwargs):\n    '''\n    Lists occurrence counts for all countries covered by the data published by the given country\n\n    :param publishingCountry: [str] A two letter country code\n\n    :return: dict\n\n    Usage::\n\n            from pygbif import occurrences\n            occurrences.count_countries(publishingCountry = \"DE\")\n    '''\n    url = gbif_baseurl + 'occurrence/counts/countries'\n    out = gbif_GET(url, {'publishingCountry': publishingCountry}, **kwargs)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef count_publishingcountries(country, **kwargs):\n    '''\n    Lists occurrence counts for all countries that publish data about the given country\n\n    :param country: [str] A country, two letter code\n\n    :return: dict\n\n    Usage::\n\n            from pygbif import occurrences\n            occurrences.count_publishingcountries(country = \"DE\")\n    '''\n    url = gbif_baseurl + 'occurrence/counts/publishingCountries'\n    out = gbif_GET(url, {\"country\": country}, **kwargs)\n    return out", "response": "Returns a dictionary of occurrence counts for all countries that publish data about the given country."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _detect_notebook() -> bool:\n    try:\n        from IPython import get_ipython\n        from ipykernel import zmqshell\n    except ImportError:\n        return False\n    kernel = get_ipython()\n    try:\n        from spyder.utils.ipython.spyder_kernel import SpyderKernel\n\n        if isinstance(kernel.kernel, SpyderKernel):\n            return False\n    except (ImportError, AttributeError):\n        pass\n    return isinstance(kernel, zmqshell.ZMQInteractiveShell)", "response": "Detect if code is running in a Jupyter Notebook."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _merge_layout(x: go.Layout, y: go.Layout) -> go.Layout:\n    xjson = x.to_plotly_json()\n    yjson = y.to_plotly_json()\n    if 'shapes' in yjson and 'shapes' in xjson:\n        xjson['shapes'] += yjson['shapes']\n    yjson.update(xjson)\n    return go.Layout(yjson)", "response": "Merge attributes from two layouts."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries to convert to pandas objects to datetimes.", "response": "def _try_pydatetime(x):\n    \"\"\"Try to convert to pandas objects to datetimes.\n\n    Plotly doesn't know how to handle them.\n    \"\"\"\n    try:\n        # for datetimeindex\n        x = [y.isoformat() for y in x.to_pydatetime()]\n    except AttributeError:\n        pass\n    try:\n        # for generic series\n        x = [y.isoformat() for y in x.dt.to_pydatetime()]\n    except AttributeError:\n        pass\n    return x"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a spark chart with the specified shape.", "response": "def spark_shape(points, shapes, fill=None, color='blue', width=5, yindex=0, heights=None):\n    \"\"\"TODO: Docstring for spark.\n\n    Parameters\n    ----------\n    points : array-like\n    shapes : array-like\n    fill : array-like, optional\n\n    Returns\n    -------\n    Chart\n\n    \"\"\"\n    assert len(points) == len(shapes) + 1\n    data = [{'marker': {'color': 'white'}, 'x': [points[0], points[-1]], 'y': [yindex, yindex]}]\n\n    if fill is None:\n        fill = [False] * len(shapes)\n\n    if heights is None:\n        heights = [0.4] * len(shapes)\n\n    lays = []\n    for i, (shape, height) in enumerate(zip(shapes, heights)):\n        if shape is None:\n            continue\n        if fill[i]:\n            fillcolor = color\n        else:\n            fillcolor = 'white'\n        lays.append(\n            dict(\n                type=shape,\n                x0=points[i],\n                x1=points[i + 1],\n                y0=yindex - height,\n                y1=yindex + height,\n                xref='x',\n                yref='y',\n                fillcolor=fillcolor,\n                line=dict(color=color, width=width),\n            )\n        )\n\n    layout = dict(shapes=lays)\n\n    return Chart(data=data, layout=layout)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndraw a vertical line from xmin xmax color dash opacity opacity", "response": "def vertical(x, ymin=0, ymax=1, color=None, width=None, dash=None, opacity=None):\n    \"\"\"Draws a vertical line from `ymin` to `ymax`.\n\n    Parameters\n    ----------\n    xmin : int, optional\n    xmax : int, optional\n    color : str, optional\n    width : number, optional\n\n    Returns\n    -------\n    Chart\n\n    \"\"\"\n    lineattr = {}\n    if color:\n        lineattr['color'] = color\n    if width:\n        lineattr['width'] = width\n    if dash:\n        lineattr['dash'] = dash\n\n    layout = dict(\n        shapes=[dict(type='line', x0=x, x1=x, y0=ymin, y1=ymax, opacity=opacity, line=lineattr)]\n    )\n    return Chart(layout=layout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndraws a horizontal line from xmin to xmax.", "response": "def horizontal(y, xmin=0, xmax=1, color=None, width=None, dash=None, opacity=None):\n    \"\"\"Draws a horizontal line from `xmin` to `xmax`.\n\n    Parameters\n    ----------\n    xmin : int, optional\n    xmax : int, optional\n    color : str, optional\n    width : number, optional\n\n    Returns\n    -------\n    Chart\n\n    \"\"\"\n    lineattr = {}\n    if color:\n        lineattr['color'] = color\n    if width:\n        lineattr['width'] = width\n    if dash:\n        lineattr['dash'] = dash\n\n    layout = dict(\n        shapes=[dict(type='line', x0=xmin, x1=xmax, y0=y, y1=y, opacity=opacity, line=lineattr)]\n    )\n    return Chart(layout=layout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef line(\n    x=None,\n    y=None,\n    label=None,\n    color=None,\n    width=None,\n    dash=None,\n    opacity=None,\n    mode='lines+markers',\n    yaxis=1,\n    fill=None,\n    text=\"\",\n    markersize=6,\n):\n    \"\"\"Draws connected dots.\n\n    Parameters\n    ----------\n    x : array-like, optional\n    y : array-like, optional\n    label : array-like, optional\n\n    Returns\n    -------\n    Chart\n\n    \"\"\"\n    assert x is not None or y is not None, \"x or y must be something\"\n    yn = 'y' + str(yaxis)\n    lineattr = {}\n    if color:\n        lineattr['color'] = color\n    if width:\n        lineattr['width'] = width\n    if dash:\n        lineattr['dash'] = dash\n    if y is None:\n        y = x\n        x = None\n    if x is None:\n        x = np.arange(len(y))\n    else:\n        x = _try_pydatetime(x)\n    x = np.atleast_1d(x)\n    y = np.atleast_1d(y)\n    assert x.shape[0] == y.shape[0]\n    if y.ndim == 2:\n        if not hasattr(label, '__iter__'):\n            if label is None:\n                label = _labels()\n            else:\n                label = _labels(label)\n        data = [\n            go.Scatter(\n                x=x,\n                y=yy,\n                name=ll,\n                line=lineattr,\n                mode=mode,\n                text=text,\n                fill=fill,\n                opacity=opacity,\n                yaxis=yn,\n                marker=dict(size=markersize, opacity=opacity),\n            )\n            for ll, yy in zip(label, y.T)\n        ]\n    else:\n        data = [\n            go.Scatter(\n                x=x,\n                y=y,\n                name=label,\n                line=lineattr,\n                mode=mode,\n                text=text,\n                fill=fill,\n                opacity=opacity,\n                yaxis=yn,\n                marker=dict(size=markersize, opacity=opacity),\n            )\n        ]\n    if yaxis == 1:\n        return Chart(data=data)\n\n    return Chart(data=data, layout={'yaxis' + str(yaxis): dict(overlaying='y')})", "response": "Draws connected dots.\n\n    Parameters\n    ----------\n    x : array-like, optional\n    y : array-like, optional\n    label : array-like, optional\n\n    Returns\n    -------\n    Chart"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a 3d line chart.", "response": "def line3d(\n    x, y, z, label=None, color=None, width=None, dash=None, opacity=None, mode='lines+markers'\n):\n    \"\"\"Create a 3d line chart.\"\"\"\n    x = np.atleast_1d(x)\n    y = np.atleast_1d(y)\n    z = np.atleast_1d(z)\n    assert x.shape == y.shape\n    assert y.shape == z.shape\n    lineattr = {}\n    if color:\n        lineattr['color'] = color\n    if width:\n        lineattr['width'] = width\n    if dash:\n        lineattr['dash'] = dash\n    if y.ndim == 2:\n        if not hasattr(label, '__iter__'):\n            if label is None:\n                label = _labels()\n            else:\n                label = _labels(label)\n        data = [\n            go.Scatter3d(x=xx, y=yy, z=zz, name=ll, line=lineattr, mode=mode, opacity=opacity)\n            for ll, xx, yy, zz in zip(label, x.T, y.T, z.T)\n        ]\n    else:\n        data = [go.Scatter3d(x=x, y=y, z=z, name=label, line=lineattr, mode=mode, opacity=opacity)]\n    return Chart(data=data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndraw dots. Parameters ---------- x : array-like, optional y : array-like, optional label : array-like, optional Returns ------- Chart", "response": "def scatter(\n    x=None,\n    y=None,\n    label=None,\n    color=None,\n    width=None,\n    dash=None,\n    opacity=None,\n    markersize=6,\n    yaxis=1,\n    fill=None,\n    text=\"\",\n    mode='markers',\n):\n    \"\"\"Draws dots.\n\n    Parameters\n    ----------\n    x : array-like, optional\n    y : array-like, optional\n    label : array-like, optional\n\n    Returns\n    -------\n    Chart\n\n    \"\"\"\n    return line(\n        x=x,\n        y=y,\n        label=label,\n        color=color,\n        width=width,\n        dash=dash,\n        opacity=opacity,\n        mode=mode,\n        yaxis=yaxis,\n        fill=fill,\n        text=text,\n        markersize=markersize,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a bar chart.", "response": "def bar(x=None, y=None, label=None, mode='group', yaxis=1, opacity=None):\n    \"\"\"Create a bar chart.\n\n    Parameters\n    ----------\n    x : array-like, optional\n    y : TODO, optional\n    label : TODO, optional\n    mode : 'group' or 'stack', default 'group'\n    opacity : TODO, optional\n\n    Returns\n    -------\n    Chart\n        A Chart with bar graph data.\n\n    \"\"\"\n    assert x is not None or y is not None, \"x or y must be something\"\n    yn = 'y' + str(yaxis)\n    if y is None:\n        y = x\n        x = None\n    if x is None:\n        x = np.arange(len(y))\n    else:\n        x = _try_pydatetime(x)\n    x = np.atleast_1d(x)\n    y = np.atleast_1d(y)\n    if y.ndim == 2:\n        if not hasattr(label, '__iter__'):\n            if label is None:\n                label = _labels()\n            else:\n                label = _labels(label)\n        data = [go.Bar(x=x, y=yy, name=ll, yaxis=yn, opacity=opacity) for ll, yy in zip(label, y.T)]\n    else:\n        data = [go.Bar(x=x, y=y, name=label, yaxis=yn, opacity=opacity)]\n    if yaxis == 1:\n        return Chart(data=data, layout={'barmode': mode})\n\n    return Chart(data=data, layout={'barmode': mode, 'yaxis' + str(yaxis): dict(overlaying='y')})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a heatmap. Parameters ---------- z : TODO x : TODO, optional y : TODO, optional colorscale : TODO, optional Returns ------- Chart", "response": "def heatmap(z, x=None, y=None, colorscale='Viridis'):\n    \"\"\"Create a heatmap.\n\n    Parameters\n    ----------\n    z : TODO\n    x : TODO, optional\n    y : TODO, optional\n    colorscale : TODO, optional\n\n    Returns\n    -------\n    Chart\n\n\n    \"\"\"\n    z = np.atleast_1d(z)\n    data = [go.Heatmap(z=z, x=x, y=y, colorscale=colorscale)]\n    return Chart(data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fill_zero(\n    x=None,\n    y=None,\n    label=None,\n    color=None,\n    width=None,\n    dash=None,\n    opacity=None,\n    mode='lines+markers',\n    **kargs\n):\n    \"\"\"Fill to zero.\n\n    Parameters\n    ----------\n    x : array-like, optional\n    y : TODO, optional\n    label : TODO, optional\n\n    Returns\n    -------\n    Chart\n\n    \"\"\"\n    return line(\n        x=x,\n        y=y,\n        label=label,\n        color=color,\n        width=width,\n        dash=dash,\n        opacity=opacity,\n        mode=mode,\n        fill='tozeroy',\n        **kargs\n    )", "response": "Fill to zero.\n\n    Parameters\n    ----------\n    x : array-like, optional\n    y : TODO, optional\n    label : TODO, optional\n\n    Returns\n    -------\n    Chart"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fill_between(\n    x=None,\n    ylow=None,\n    yhigh=None,\n    label=None,\n    color=None,\n    width=None,\n    dash=None,\n    opacity=None,\n    mode='lines+markers',\n    **kargs\n):\n    \"\"\"Fill between `ylow` and `yhigh`.\n\n    Parameters\n    ----------\n    x : array-like, optional\n    ylow : TODO, optional\n    yhigh : TODO, optional\n\n    Returns\n    -------\n    Chart\n\n    \"\"\"\n    plot = line(\n        x=x,\n        y=ylow,\n        label=label,\n        color=color,\n        width=width,\n        dash=dash,\n        opacity=opacity,\n        mode=mode,\n        fill=None,\n        **kargs\n    )\n    plot += line(\n        x=x,\n        y=yhigh,\n        label=label,\n        color=color,\n        width=width,\n        dash=dash,\n        opacity=opacity,\n        mode=mode,\n        fill='tonexty',\n        **kargs\n    )\n    return plot", "response": "Fill between ylow and yhigh."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a chart that shows the rug of the object.", "response": "def rug(x, label=None, opacity=None):\n    \"\"\"Rug chart.\n\n    Parameters\n    ----------\n    x : array-like, optional\n    label : TODO, optional\n    opacity : TODO, optional\n\n    Returns\n    -------\n    Chart\n\n    \"\"\"\n    x = _try_pydatetime(x)\n    x = np.atleast_1d(x)\n    data = [\n        go.Scatter(\n            x=x,\n            y=np.ones_like(x),\n            name=label,\n            opacity=opacity,\n            mode='markers',\n            marker=dict(symbol='line-ns-open'),\n        )\n    ]\n    layout = dict(\n        barmode='overlay',\n        hovermode='closest',\n        legend=dict(traceorder='reversed'),\n        xaxis1=dict(zeroline=False),\n        yaxis1=dict(\n            domain=[0.85, 1],\n            showline=False,\n            showgrid=False,\n            zeroline=False,\n            anchor='free',\n            position=0.0,\n            showticklabels=False,\n        ),\n    )\n    return Chart(data=data, layout=layout)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsurfacing plot. Parameters ---------- x : array-like, optional y : array-like, optional z : array-like, optional Returns ------- Chart", "response": "def surface(x, y, z):\n    \"\"\"Surface plot.\n\n    Parameters\n    ----------\n    x : array-like, optional\n    y : array-like, optional\n    z : array-like, optional\n\n    Returns\n    -------\n    Chart\n\n    \"\"\"\n    data = [go.Surface(x=x, y=y, z=z)]\n    return Chart(data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a chart that contains a histogram of the data points x.", "response": "def hist(x, mode='overlay', label=None, opacity=None, horz=False, histnorm=None):\n    \"\"\"Histogram.\n\n    Parameters\n    ----------\n    x : array-like\n    mode : str, optional\n    label : TODO, optional\n    opacity : float, optional\n    horz : bool, optional\n    histnorm : None, \"percent\", \"probability\", \"density\", \"probability density\", optional\n        Specifies the type of normalization used for this histogram trace.\n        If ``None``, the span of each bar corresponds to the number of occurrences\n        (i.e. the number of data points lying inside the bins). If \"percent\",\n        the span of each bar corresponds to the percentage of occurrences with\n        respect to the total number of sample points (here, the sum of all bin\n        area equals 100%). If \"density\", the span of each bar corresponds to the\n        number of occurrences in a bin divided by the size of the bin interval\n        (here, the sum of all bin area equals the total number of sample\n        points). If \"probability density\", the span of each bar corresponds to\n        the probability that an event will fall into the corresponding bin\n        (here, the sum of all bin area equals 1).\n\n    Returns\n    -------\n    Chart\n\n    \"\"\"\n    x = np.atleast_1d(x)\n    if horz:\n        kargs = dict(y=x)\n    else:\n        kargs = dict(x=x)\n    layout = dict(barmode=mode)\n    data = [go.Histogram(opacity=opacity, name=label, histnorm=histnorm, **kargs)]\n    return Chart(data=data, layout=layout)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ytickangle(self, angle, index=1):\n        self.layout['yaxis' + str(index)]['tickangle'] = angle\n        return self", "response": "Set the angle of the y - axis tick labels."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the size of the label.", "response": "def ylabelsize(self, size, index=1):\n        \"\"\"Set the size of the label.\n\n        Parameters\n        ----------\n        size : int\n\n        Returns\n        -------\n        Chart\n\n        \"\"\"\n        self.layout['yaxis' + str(index)]['titlefont']['size'] = size\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef yticksize(self, size, index=1):\n        self.layout['yaxis' + str(index)]['tickfont']['size'] = size\n        return self", "response": "Set the tick font size."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the tick values.", "response": "def ytickvals(self, values, index=1):\n        \"\"\"Set the tick values.\n\n        Parameters\n        ----------\n        values : array-like\n\n        Returns\n        -------\n        Chart\n\n        \"\"\"\n        self.layout['yaxis' + str(index)]['tickvals'] = values\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef yticktext(self, labels, index=1):\n        self.layout['yaxis' + str(index)]['ticktext'] = labels\n        return self", "response": "Set the tick labels."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ylim(self, low, high, index=1):\n        self.layout['yaxis' + str(index)]['range'] = [low, high]\n        return self", "response": "Set yaxis limits.\n\n        Parameters\n        ----------\n        low : number\n        high : number\n        index : int, optional\n\n        Returns\n        -------\n        Chart"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the tick distance.", "response": "def ydtick(self, dtick, index=1):\n        \"\"\"Set the tick distance.\"\"\"\n        self.layout['yaxis' + str(index)]['dtick'] = dtick\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ynticks(self, nticks, index=1):\n        self.layout['yaxis' + str(index)]['nticks'] = nticks\n        return self", "response": "Set the number of ticks."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show(\n        self,\n        filename: Optional[str] = None,\n        show_link: bool = True,\n        auto_open: bool = True,\n        detect_notebook: bool = True,\n    ) -> None:\n        \"\"\"Display the chart.\n\n        Parameters\n        ----------\n        filename : str, optional\n            Save plot to this filename, otherwise it's saved to a temporary file.\n        show_link : bool, optional\n            Show link to plotly.\n        auto_open : bool, optional\n            Automatically open the plot (in the browser).\n        detect_notebook : bool, optional\n            Try to detect if we're running in a notebook.\n\n        \"\"\"\n        kargs = {}\n        if detect_notebook and _detect_notebook():\n            py.init_notebook_mode()\n            plot = py.iplot\n        else:\n            plot = py.plot\n            if filename is None:\n                filename = NamedTemporaryFile(prefix='plotly', suffix='.html', delete=False).name\n            kargs['filename'] = filename\n            kargs['auto_open'] = auto_open\n\n        plot(self, show_link=show_link, **kargs)", "response": "Display the chart.\n\n        Parameters\n        ----------\n        filename : str, optional\n            Save plot to this filename, otherwise it's saved to a temporary file.\n        show_link : bool, optional\n            Show link to plotly.\n        auto_open : bool, optional\n            Automatically open the plot (in the browser).\n        detect_notebook : bool, optional\n            Try to detect if we're running in a notebook."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves the chart to an html file.", "response": "def save(\n        self,\n        filename: Optional[str] = None,\n        show_link: bool = True,\n        auto_open: bool = False,\n        output: str = 'file',\n        plotlyjs: bool = True,\n    ) -> str:\n        \"\"\"Save the chart to an html file.\"\"\"\n        if filename is None:\n            filename = NamedTemporaryFile(prefix='plotly', suffix='.html', delete=False).name\n        # NOTE: this doesn't work for output 'div'\n        py.plot(\n            self,\n            show_link=show_link,\n            filename=filename,\n            auto_open=auto_open,\n            output_type=output,\n            include_plotlyjs=plotlyjs,\n        )\n        return filename"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef RegisterMethod(cls, *args, **kwargs):\n        unpack_error = True\n\n        try:\n            f, library_path = args\n            unpack_error = False\n            cls._RegisterMethod(f, library_path, **kwargs)\n\n        except:\n            if not unpack_error:\n                raise\n\n            def register_decorator(f):\n                library_path, = args\n                cls._RegisterMethod(f, library_path, **kwargs)\n\n                return f\n            return register_decorator", "response": "Register a method in the class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef RegisterAt(cls, *args, **kwargs):\n        unpack_error = True\n\n        try:\n            n, f, library_path = args\n            unpack_error = False\n            cls._RegisterAt(n, f, library_path, **kwargs)\n\n        except:\n            if not unpack_error:\n                raise\n\n            def register_decorator(f):\n                n, library_path = args\n                cls._RegisterAt(n, f, library_path, **kwargs)\n\n                return f\n            return register_decorator", "response": "**RegisterAt**\n\n    RegisterAt(n, f, library_path, alias=None, original_name=None, doc=None, wrapped=None, explanation=\"\", method_type=utils.identity, explain=True, _return_type=None)\n\nMost of the time you don't want to register an method as such, that is, you don't care about the `self` builder object, instead you want to register a function that transforms the value being piped down the DSL. For this you can use `RegisterAt` so e.g.\n\n    def some_fun(obj, arg1, arg2):\n        # code\n\n    @MyBuilder.RegisterMethod(\"my_lib.\")\n    def some_fun_wrapper(self, arg1, arg2):\n        return self.ThenAt(1, some_fun, arg1, arg2)\n\ncan be written directly as\n\n    @MyBuilder.RegisterAt(1, \"my_lib.\")\n    def some_fun(obj, arg1, arg2):\n        # code\n\nFor this case you can just use `Register` which is a shortcut for `RegisterAt(1, ...)`\n\n    @MyBuilder.Register(\"my_lib.\")\n    def some_fun(obj, arg1, arg2):\n        # code\n\n**Also See**\n\n* `phi.builder.Builder.RegisterMethod`"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef PatchAt(cls, n, module, method_wrapper=None, module_alias=None, method_name_modifier=utils.identity, blacklist_predicate=_False, whitelist_predicate=_True, return_type_predicate=_None, getmembers_predicate=inspect.isfunction, admit_private=False, explanation=\"\"):\n        _rtp = return_type_predicate\n\n        return_type_predicate = (lambda x: _rtp) if inspect.isclass(_rtp) and issubclass(_rtp, Builder) else _rtp\n        module_name = module_alias if module_alias else module.__name__ + '.'\n        patch_members = _get_patch_members(module, blacklist_predicate=blacklist_predicate, whitelist_predicate=whitelist_predicate, getmembers_predicate=getmembers_predicate, admit_private=admit_private)\n\n        for name, f in patch_members:\n            wrapped = None\n\n            if method_wrapper:\n                g = method_wrapper(f)\n                wrapped = f\n            else:\n                g = f\n\n            cls.RegisterAt(n, g, module_name, wrapped=wrapped, _return_type=return_type_predicate(name), alias=method_name_modifier(name), explanation=explanation)", "response": "This classmethod allows you to patch all of functions or methods at a specific position."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a function it returns a string that pretty much looks how the method signature_ would be written in python.", "response": "def get_method_sig(method):\n    \"\"\" Given a function, it returns a string that pretty much looks how the\n    function signature_ would be written in python.\n\n    :param method: a python method\n    :return: A string similar describing the pythong method signature_.\n    eg: \"my_method(first_argArg, second_arg=42, third_arg='something')\"\n    \"\"\"\n\n    # The return value of ArgSpec is a bit weird, as the list of arguments and\n    # list of defaults are returned in separate array.\n    # eg: ArgSpec(args=['first_arg', 'second_arg', 'third_arg'],\n    # varargs=None, keywords=None, defaults=(42, 'something'))\n    argspec = inspect.getargspec(method)\n    arg_index=0\n    args = []\n\n    # Use the args and defaults array returned by argspec and find out\n    # which arguments has default\n    for arg in argspec.args:\n        default_arg = _get_default_arg(argspec.args, argspec.defaults, arg_index)\n        if default_arg.has_default:\n            args.append(\"%s=%s\" % (arg, default_arg.default_value))\n        else:\n            args.append(arg)\n        arg_index += 1\n    return \"%s(%s)\" % (method.__name__, \", \".join(args))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ThenAt(self, n, f, *_args, **kwargs):\n        _return_type = None\n        n_args = n - 1\n\n        if '_return_type' in kwargs:\n            _return_type = kwargs['_return_type']\n            del kwargs['_return_type']\n\n        @utils.lift\n        def g(x):\n\n            new_args = _args[0:n_args] + (x,) + _args[n_args:] if n_args >= 0 else _args\n            return f(*new_args, **kwargs)\n\n        return self.__then__(g, _return_type=_return_type)", "response": "A function that takes a single argument and returns a partial that expects a single argument at the given position."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef Then(self, f, *args, **kwargs):\n        return self.ThenAt(1, f, *args, **kwargs)", "response": "A second order then function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef Then5(self, f, arg1, arg2, arg3, arg4, *args, **kwargs):\n        args = (arg1, arg2, arg3, arg4) + args\n        return self.ThenAt(5, f, *args, **kwargs)", "response": "A second order then 5 function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwhile `Seq` is sequential, `phi.dsl.Expression.List` allows you to split the computation and get back a list with the result of each path. While the list literal should be the most incarnation of this expresion, it can actually be any iterable (implements `__iter__`) that is not a tuple and yields a valid expresion. The expression k = List(f, g) is equivalent to k = lambda x: [ f(x), g(x) ] In general, the following rules apply after compilation: **General Branching** List(f0, f1, ..., fn) is equivalent to lambda x: [ f0(x), f1(x), ..., fn(x) ] **Composing & Branching** It is interesting to see how braching interacts with composing. The expression Seq(f, List(g, h)) is *almost* equivalent to List( Seq(f, g), Seq(f, h) ) As you see its as if `f` where distributed over the List. We say *almost* because their implementation is different def _lambda(x): x = f(x) return [ g(x), h(x) ] vs lambda x: [ g(f(x)), h(f(x)) ] As you see `f` is only executed once in the first one. Both should yield the same result if `f` is a pure function. ### Examples form phi import P, List avg_word_length = P.Pipe( \"1 22 333\", lambda s: s.split(' '), # ['1', '22', '333'] lambda l: map(len, l), # [1, 2, 3] List( sum # 1 + 2 + 3 == 6 , len # len([1, 2, 3]) == 3 ), lambda l: l[0] / l[1] # sum / len == 6 / 3 == 2 ) assert avg_word_length == 2 The previous could also be done more briefly like this form phi import P, Obj, List avg_word_length = P.Pipe( \"1 22 333\", Obj .split(' ') # ['1', '22', '333'] .map(len) # [1, 2, 3] .List( sum #sum([1, 2, 3]) == 6 , len #len([1, 2, 3]) == 3 ), P[0] / P[1] #6 / 3 == 2 ) assert avg_word_length == 2 In the example above the last expression P[0] / P[1] works for a couple of reasons 1. The previous expression returns a list 2. In general the expression `P[x]` compiles to a function with the form `lambda obj: obj[x]` 3. The class `Expression` (the class from which the object `P` inherits) overrides most operators to create functions easily. For example, the expression (P * 2) / (P + 1) compile to a function of the form lambda x: (x * 2) / (x + 1) Check out the documentatio for Phi [lambdas](https://cgarciae.github.io/phi/lambdas.m.html).", "response": "def List(self, *branches, **kwargs):\n        \"\"\"\nWhile `Seq` is sequential, `phi.dsl.Expression.List` allows you to split the computation and get back a list with the result of each path. While the list literal should be the most incarnation of this expresion, it can actually be any iterable (implements `__iter__`) that is not a tuple and yields a valid expresion.\n\nThe expression\n\n    k = List(f, g)\n\nis equivalent to\n\n    k = lambda x: [ f(x), g(x) ]\n\n\nIn general, the following rules apply after compilation:\n\n**General Branching**\n\n    List(f0, f1, ..., fn)\n\nis equivalent to\n\n    lambda x: [ f0(x), f1(x), ..., fn(x) ]\n\n\n**Composing & Branching**\n\nIt is interesting to see how braching interacts with composing. The expression\n\n    Seq(f, List(g, h))\n\nis *almost* equivalent to\n\n    List( Seq(f, g), Seq(f, h) )\n\nAs you see its as if `f` where distributed over the List. We say *almost* because their implementation is different\n\n    def _lambda(x):\n        x = f(x)\n        return [ g(x), h(x) ]\n\nvs\n\n    lambda x: [ g(f(x)), h(f(x)) ]\n\nAs you see `f` is only executed once in the first one. Both should yield the same result if `f` is a pure function.\n\n### Examples\n\n    form phi import P, List\n\n    avg_word_length = P.Pipe(\n        \"1 22 333\",\n        lambda s: s.split(' '), # ['1', '22', '333']\n        lambda l: map(len, l), # [1, 2, 3]\n        List(\n            sum # 1 + 2 + 3 == 6\n        ,\n            len # len([1, 2, 3]) == 3\n        ),\n        lambda l: l[0] / l[1] # sum / len == 6 / 3 == 2\n    )\n\n    assert avg_word_length == 2\n\nThe previous could also be done more briefly like this\n\n    form phi import P, Obj, List\n\n    avg_word_length = P.Pipe(\n        \"1 22 333\", Obj\n        .split(' ')  # ['1', '22', '333']\n        .map(len)    # [1, 2, 3]\n        .List(\n            sum  #sum([1, 2, 3]) == 6\n        ,\n            len  #len([1, 2, 3]) == 3\n        ),\n        P[0] / P[1]  #6 / 3 == 2\n    )\n\n    assert avg_word_length == 2\n\nIn the example above the last expression\n\n    P[0] / P[1]\n\nworks for a couple of reasons\n\n1. The previous expression returns a list\n2. In general the expression `P[x]` compiles to a function with the form `lambda obj: obj[x]`\n3. The class `Expression` (the class from which the object `P` inherits) overrides most operators to create functions easily. For example, the expression\n\n    (P * 2) / (P + 1)\n\ncompile to a function of the form\n\n    lambda x: (x * 2) / (x + 1)\n\nCheck out the documentatio for Phi [lambdas](https://cgarciae.github.io/phi/lambdas.m.html).\n\n        \"\"\"\n        gs = [ _parse(code)._f for code in branches ]\n\n        def h(x, state):\n            ys = []\n            for g in gs:\n                y, state = g(x, state)\n                ys.append(y)\n\n            return (ys, state)\n\n        return self.__then__(h, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a new sequence that is the sequence of the given elements.", "response": "def Seq(self, *sequence, **kwargs):\n        \"\"\"\n`Seq` is used to express function composition. The expression\n\n    Seq(f, g)\n\nbe equivalent to\n\n    lambda x: g(f(x))\n\nAs you see, its a little different from the mathematical definition. Excecution order flow from left to right, this makes reading and reasoning about code way more easy. This bahaviour is based upon the `|>` (pipe) operator found in languages like F#, Elixir and Elm. You can pack as many expressions as you like and they will be applied in order to the data that is passed through them when compiled an excecuted.\n\nIn general, the following rules apply for Seq:\n\n**General Sequence**\n\n    Seq(f0, f1, ..., fn-1, fn)\n\nis equivalent to\n\n    lambda x: fn(fn-1(...(f1(f0(x)))))\n\n**Single Function**\n\n    Seq(f)\n\nis equivalent to\n\n    f\n\n**Identity**\n\nThe empty Seq\n\n    Seq()\n\nis equivalent to\n\n    lambda x: x\n\n### Examples\n\n    from phi import P, Seq\n\n    f = Seq(\n        P * 2,\n        P + 1,\n        P ** 2\n    )\n\n    assert f(1) == 9 # ((1 * 2) + 1) ** 2\n\nThe previous example using `P.Pipe`\n\n    from phi import P\n\n    assert 9 == P.Pipe(\n        1,\n        P * 2,  #1 * 2 == 2\n        P + 1,  #2 + 1 == 3\n        P ** 2  #3 ** 2 == 9\n    )\n        \"\"\"\n        fs = [ _parse(elem)._f for elem in sequence ]\n\n        def g(x, state):\n            return functools.reduce(lambda args, f: f(*args), fs, (x, state))\n\n        return self.__then__(g, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef With(self, context_manager, *body, **kwargs):\n        context_f = _parse(context_manager)._f\n        body_f = E.Seq(*body)._f\n\n        def g(x, state):\n            context, state = context_f(x, state)\n            with context as scope:\n                with _WithContextManager(scope):\n                    return body_f(x, state)\n\n        return self.__then__(g, **kwargs)", "response": "A simple context manager with a given DSL."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ReadList(self, *branches, **kwargs):\n        branches = map(lambda x: E.Read(x) if isinstance(x, str) else x, branches)\n\n        return self.List(*branches, **kwargs)", "response": "A version of phi. dsl. Expression. List that handles the case where a string argument x is translated to Read."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef Write(self, *state_args, **state_dict):\n        if len(state_dict) + len(state_args) < 1:\n            raise Exception(\"Please include at-least 1 state variable, got {0} and {1}\".format(state_args, state_dict))\n\n        if len(state_dict) > 1:\n            raise Exception(\"Please include at-most 1 keyword argument expression, got {0}\".format(state_dict))\n\n        if len(state_dict) > 0:\n            state_key = next(iter(state_dict.keys()))\n            write_expr = state_dict[state_key]\n\n            state_args += (state_key,)\n\n            expr = self >> write_expr\n\n        else:\n            expr = self\n\n\n\n        def g(x, state):\n            update = { key: x for key in state_args }\n            state = utils.merge(state, update)\n\n            #side effect for convenience\n            _StateContextManager.REFS.update(state)\n\n            return x, state\n\n\n        return expr.__then__(g)", "response": "See phi. dsl. Expression. Write"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new Seq with the given value.", "response": "def Val(self, val, **kwargs):\n        \"\"\"\nThe expression\n\n    Val(a)\n\nis equivalent to the constant function\n\n    lambda x: a\n\nAll expression in this module interprete values that are not functions as constant functions using `Val`, for example\n\n    Seq(1, P + 1)\n\nis equivalent to\n\n    Seq(Val(1), P + 1)\n\nThe previous expression as a whole is a constant function since it will return `2` no matter what input you give it.\n        \"\"\"\n        f = utils.lift(lambda z: val)\n\n        return self.__then__(f, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef Else(self, *Else, **kwargs):\n        root = self._root\n        ast = self._ast\n\n        next_else = E.Seq(*Else)._f\n        ast = _add_else(ast, next_else)\n\n        g = _compile_if(ast)\n\n        return root.__then__(g, **kwargs)", "response": "See phi. dsl. Expression. If"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef length(string, until=None):\n    if until is None:\n        return sum(1 for _ in GraphemeIterator(string))\n\n    iterator = graphemes(string)\n    count = 0\n    while True:\n        try:\n            if count >= until:\n                break\n            next(iterator)\n        except StopIteration:\n            break\n        else:\n            count += 1\n\n    return count", "response": "Returns the length of the string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef slice(string, start=None, end=None):\n\n    if start is None:\n        start = 0\n    if end is not None and start >= end:\n        return \"\"\n\n    if start < 0:\n        raise NotImplementedError(\"Negative indexing is currently not supported.\")\n\n    sum_ = 0\n    start_index = None\n    for grapheme_index, grapheme_length in enumerate(grapheme_lengths(string)):\n        if grapheme_index == start:\n            start_index = sum_\n        elif grapheme_index == end:\n            return string[start_index:sum_]\n        sum_ += grapheme_length\n\n    if start_index is not None:\n        return string[start_index:]\n\n    return \"\"", "response": "Returns a substring of the given string counting graphemes instead of codepoints."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if the grapheme sequence of graphemes in substring is also present in string.", "response": "def contains(string, substring):\n    \"\"\"\n    Returns true if the sequence of graphemes in substring is also present in string.\n\n    This differs from the normal python `in` operator, since the python operator will return\n    true if the sequence of codepoints are withing the other string without considering\n    grapheme boundaries.\n\n    Performance notes: Very fast if `substring not in string`, since that also means that\n    the same graphemes can not be in the two strings. Otherwise this function has linear time\n    complexity in relation to the string length. It will traverse the sequence of graphemes until\n    a match is found, so it will generally perform better for grapheme sequences that match early.\n\n    >>> \"\ud83c\uddf8\ud83c\uddea\" in \"\ud83c\uddea\ud83c\uddf8\ud83c\uddea\ud83c\uddea\"\n    True\n    >>> grapheme.contains(\"\ud83c\uddea\ud83c\uddf8\ud83c\uddea\ud83c\uddea\", \"\ud83c\uddf8\ud83c\uddea\")\n    False\n    \"\"\"\n    if substring not in string:\n        return False\n\n    substr_graphemes = list(graphemes(substring))\n\n    if len(substr_graphemes) == 0:\n        return True\n    elif len(substr_graphemes) == 1:\n        return substr_graphemes[0] in graphemes(string)\n    else:\n        str_iter = graphemes(string)\n        str_sub_part = []\n        for _ in range(len(substr_graphemes)):\n            try:\n                str_sub_part.append(next(str_iter))\n            except StopIteration:\n                return False\n\n        for g in str_iter:\n            if str_sub_part == substr_graphemes:\n                return True\n\n            str_sub_part.append(g)\n            str_sub_part.pop(0)\n        return str_sub_part == substr_graphemes"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlike str. startswith but checks that the given string starts with the given prefixes sequence of graphemes.", "response": "def startswith(string, prefix):\n    \"\"\"\n    Like str.startswith, but also checks that the string starts with the given prefixes sequence of graphemes.\n\n    str.startswith may return true for a prefix that is not visually represented as a prefix if a grapheme cluster\n    is continued after the prefix ends.\n\n    >>> grapheme.startswith(\"\u270a\ud83c\udffe\", \"\u270a\")\n    False\n    >>> \"\u270a\ud83c\udffe\".startswith(\"\u270a\")\n    True\n    \"\"\"\n    return string.startswith(prefix) and safe_split_index(string, len(prefix)) == len(prefix)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef endswith(string, suffix):\n    expected_index = len(string) - len(suffix)\n    return string.endswith(suffix) and safe_split_index(string, expected_index) == expected_index", "response": "Like str. endswith but checks that the given string ends with the given suffix."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the highest index up to `max_len` at which the given string can be sliced, without breaking a grapheme. This is useful for when you want to split or take a substring from a string, and don't really care about the exact grapheme length, but don't want to risk breaking existing graphemes. This function does normally not traverse the full grapheme sequence up to the given length, so it can be used for arbitrarily long strings and high `max_len`s. However, some grapheme boundaries depend on the previous state, so the worst case performance is O(n). In practice, it's only very long non-broken sequences of country flags (represented as Regional Indicators) that will perform badly. The return value will always be between `0` and `len(string)`. >>> string = \"tamil \u0ba8\u0bbf (ni)\" >>> i = grapheme.safe_split_index(string, 7) >>> i 6 >>> string[:i] 'tamil ' >>> string[i:] '\u0ba8\u0bbf (ni)'", "response": "def safe_split_index(string, max_len):\n    \"\"\"\n    Returns the highest index up to `max_len` at which the given string can be sliced, without breaking a grapheme.\n\n    This is useful for when you want to split or take a substring from a string, and don't really care about\n    the exact grapheme length, but don't want to risk breaking existing graphemes.\n\n    This function does normally not traverse the full grapheme sequence up to the given length, so it can be used\n    for arbitrarily long strings and high `max_len`s. However, some grapheme boundaries depend on the previous state,\n    so the worst case performance is O(n). In practice, it's only very long non-broken sequences of country flags\n    (represented as Regional Indicators) that will perform badly.\n\n    The return value will always be between `0` and `len(string)`.\n\n    >>> string = \"tamil \u0ba8\u0bbf (ni)\"\n    >>> i = grapheme.safe_split_index(string, 7)\n    >>> i\n    6\n    >>> string[:i]\n    'tamil '\n    >>> string[i:]\n    '\u0ba8\u0bbf (ni)'\n    \"\"\"\n    last_index = get_last_certain_break_index(string, max_len)\n    for l in grapheme_lengths(string[last_index:]):\n        if last_index + l > max_len:\n            break\n        last_index += l\n    return last_index"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef readB1logfile(filename):\n    dic = dict()\n    # try to open. If this fails, an exception is raised\n    with open(filename, 'rt', encoding='utf-8') as f:\n        for l in f:\n            l = l.strip()\n            if l[0] in '#!%\\'':\n                continue  # treat this line as a comment\n            try:\n                # find the first tuple in _logfile_data where the first element of the\n                # tuple is the starting of the line.\n                ld = [ld_ for ld_ in _logfile_data if l.split(\n                    ':', 1)[0].strip() == ld_[0]][0]\n            except IndexError:\n                # line is not recognized. We can still try to load it: find the first\n                # semicolon. If found, the part of the line before it is stripped\n                # from whitespaces and will be the key. The part after it is stripped\n                # from whitespaces and parsed with misc.parse_number(). If no\n                if ':' in l:\n                    key, val = [x.strip() for x in l.split(':', 1)]\n                    val = misc.parse_number(val)\n                    dic[key] = val\n                    try:\n                        # fix the character encoding in files written by a\n                        # previous version of this software.\n                        dic[key] = dic[key].encode('latin2').decode('utf-8')\n                    except (UnicodeDecodeError, UnicodeEncodeError, AttributeError):\n                        pass\n                else:\n                    dic[l.strip()] = True\n                continue\n            try:\n                reader = ld[3]\n            except IndexError:\n                reader = str\n            rhs = l.split(':', 1)[1].strip()\n            try:\n                vals = reader(rhs)\n            except ValueError:\n                if rhs.lower() == 'none':\n                    vals = None\n                else:\n                    raise\n            if isinstance(ld[1], tuple):\n                # more than one field names. The reader function should return a\n                # tuple here, a value for each field.\n                if len(vals) != len(ld[1]):\n                    raise ValueError(\n                        'Cannot read %d values from line %s in file!' % (len(ld[1]), l))\n                dic.update(dict(list(zip(ld[1], vals))))\n            else:\n                dic[ld[1]] = vals\n    dic['__Origin__'] = 'B1 log'\n    dic['__particle__'] = 'photon'\n    return dic", "response": "Read the B1 logfile and return a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef writeB1logfile(filename, data):\n    allkeys = list(data.keys())\n    f = open(filename, 'wt', encoding='utf-8')\n    for ld in _logfile_data:  # process each line\n        linebegin = ld[0]\n        fieldnames = ld[1]\n        # set the default formatter if it is not given\n        if len(ld) < 3:\n            formatter = str\n        elif ld[2] is None:\n            formatter = str\n        else:\n            formatter = ld[2]\n        # this will contain the formatted values.\n        formatted = ''\n        if isinstance(fieldnames, str):\n            # scalar field name, just one field. Formatter should be a\n            # callable.\n            if fieldnames not in allkeys:\n                # this field has already been processed\n                continue\n            try:\n                formatted = formatter(data[fieldnames])\n            except KeyError:\n                # field not found in param structure\n                continue\n        elif isinstance(fieldnames, tuple):\n            # more than one field names in a tuple. In this case, formatter can\n            # be a tuple of callables...\n            if all([(fn not in allkeys) for fn in fieldnames]):\n                # if all the fields have been processed:\n                continue\n            if isinstance(formatter, tuple) and len(formatter) == len(fieldnames):\n                formatted = ' '.join([ft(data[fn])\n                                      for ft, fn in zip(formatter, fieldnames)])\n            # ...or a single callable...\n            elif not isinstance(formatter, tuple):\n                formatted = formatter([data[fn] for fn in fieldnames])\n            # ...otherwise raise an exception.\n            else:\n                raise SyntaxError('Programming error: formatter should be a scalar or a tuple\\\nof the same length as the field names in logfile_data.')\n        else:  # fieldnames is neither a string, nor a tuple.\n            raise SyntaxError(\n                'Invalid syntax (programming error) in logfile_data in writeparamfile().')\n        # try to get the values\n        linetowrite = linebegin + ':\\t' + formatted + '\\n'\n        f.write(linetowrite)\n        if isinstance(fieldnames, tuple):\n            for fn in fieldnames:  # remove the params treated.\n                if fn in allkeys:\n                    allkeys.remove(fn)\n        else:\n            if fieldnames in allkeys:\n                allkeys.remove(fieldnames)\n    # write untreated params\n    for k in allkeys:\n        linetowrite = k + ':\\t' + str(data[k]) + '\\n'\n        f.write(linetowrite)\n\n    f.close()", "response": "Write a header structure into a B1 logfile."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads beamline B1 header data from file.", "response": "def readB1header(filename):\n    \"\"\"Read beamline B1 (HASYLAB, Hamburg) header data\n\n    Input\n    -----\n    filename: string\n        the file name. If ends with ``.gz``, it is fed through a ``gunzip``\n        filter\n\n    Output\n    ------\n    A header dictionary.\n\n    Examples\n    --------\n    read header data from 'ORG000123.DAT'::\n\n        header=readB1header('ORG00123.DAT')\n    \"\"\"\n    # Planck's constant times speed of light: incorrect\n    # constant in the old program on hasjusi1, which was\n    # taken over by the measurement program, to keep\n    # compatibility with that.\n    hed = {}\n    if libconfig.LENGTH_UNIT == 'A':\n        jusifaHC = 12396.4\n    elif libconfig.LENGTH_UNIT == 'nm':\n        jusifaHC = 1239.64\n    else:\n        raise NotImplementedError(\n            'Invalid length unit: ' + str(libconfig.LENGTH_UNIT))\n\n    if filename.upper().endswith('.GZ'):\n        fid = gzip.GzipFile(filename, 'r')\n    else:\n        fid = open(filename, 'rt')\n    lines = fid.readlines()\n    fid.close()\n    hed['FSN'] = int(lines[0].strip())\n    hed['Hour'] = int(lines[17].strip())\n    hed['Minutes'] = int(lines[18].strip())\n    hed['Month'] = int(lines[19].strip())\n    hed['Day'] = int(lines[20].strip())\n    hed['Year'] = int(lines[21].strip()) + 2000\n    hed['FSNref1'] = int(lines[23].strip())\n    hed['FSNdc'] = int(lines[24].strip())\n    hed['FSNsensitivity'] = int(lines[25].strip())\n    hed['FSNempty'] = int(lines[26].strip())\n    hed['FSNref2'] = int(lines[27].strip())\n    hed['Monitor'] = float(lines[31].strip())\n    hed['Anode'] = float(lines[32].strip())\n    hed['MeasTime'] = float(lines[33].strip())\n    hed['Temperature'] = float(lines[34].strip())\n    hed['BeamPosX'] = float(lines[36].strip())\n    hed['BeamPosY'] = float(lines[37].strip())\n    hed['Transm'] = float(lines[41].strip())\n    hed['Wavelength'] = float(lines[43].strip())\n    hed['Energy'] = jusifaHC / hed['Wavelength']\n    hed['Dist'] = float(lines[46].strip())\n    hed['XPixel'] = 1 / float(lines[49].strip())\n    hed['YPixel'] = 1 / float(lines[50].strip())\n    hed['Title'] = lines[53].strip().replace(' ', '_').replace('-', '_')\n    hed['MonitorDORIS'] = float(lines[56].strip())  # aka. DORIS counter\n    hed['Owner'] = lines[57].strip()\n    hed['RotXSample'] = float(lines[59].strip())\n    hed['RotYSample'] = float(lines[60].strip())\n    hed['PosSample'] = float(lines[61].strip())\n    hed['DetPosX'] = float(lines[62].strip())\n    hed['DetPosY'] = float(lines[63].strip())\n    hed['MonitorPIEZO'] = float(lines[64].strip())  # aka. PIEZO counter\n    hed['BeamsizeX'] = float(lines[66].strip())\n    hed['BeamsizeY'] = float(lines[67].strip())\n    hed['PosRef'] = float(lines[70].strip())\n    hed['Monochromator1Rot'] = float(lines[77].strip())\n    hed['Monochromator2Rot'] = float(lines[78].strip())\n    hed['Heidenhain1'] = float(lines[79].strip())\n    hed['Heidenhain2'] = float(lines[80].strip())\n    hed['Current1'] = float(lines[81].strip())\n    hed['Current2'] = float(lines[82].strip())\n    hed['Detector'] = 'Unknown'\n    hed['PixelSize'] = (hed['XPixel'] + hed['YPixel']) / 2.0\n\n    hed['AnodeError'] = math.sqrt(hed['Anode'])\n    hed['TransmError'] = 0\n    hed['MonitorError'] = math.sqrt(hed['Monitor'])\n    hed['MonitorPIEZOError'] = math.sqrt(hed['MonitorPIEZO'])\n    hed['MonitorDORISError'] = math.sqrt(hed['MonitorDORIS'])\n    hed['Date'] = datetime.datetime(\n        hed['Year'], hed['Month'], hed['Day'], hed['Hour'], hed['Minutes'])\n    hed['__Origin__'] = 'B1 original'\n    hed['__particle__'] = 'photon'\n    return hed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readehf(filename):\n    f = open(filename, 'r')\n    edf = {}\n    if not f.readline().strip().startswith('{'):\n        raise ValueError('Invalid file format.')\n    for l in f:\n        l = l.strip()\n        if not l:\n            continue\n        if l.endswith('}'):\n            break  # last line of header\n        try:\n            left, right = l.split('=', 1)\n        except ValueError:\n            raise ValueError('Invalid line: ' + l)\n        left = left.strip()\n        right = right.strip()\n        if not right.endswith(';'):\n            raise ValueError(\n                'Invalid line (does not end with a semicolon): ' + l)\n        right = right[:-1].strip()\n        m = re.match('^(?P<left>.*)~(?P<continuation>\\d+)$', left)\n        if m is not None:\n            edf[m.group('left')] = edf[m.group('left')] + right\n        else:\n            edf[left] = _readedf_extractline(left, right)\n    f.close()\n    edf['FileName'] = filename\n    edf['__Origin__'] = 'EDF ID02'\n    edf['__particle__'] = 'photon'\n    return edf", "response": "Read the EDF header from a file and return a dictionary of the EDF header structure."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading the header data from a Bessy Data Format v1 file.", "response": "def readbhfv1(filename, load_data=False, bdfext='.bdf', bhfext='.bhf'):\n    \"\"\"Read header data from bdf/bhf file (Bessy Data Format v1)\n\n    Input:\n        filename: the name of the file\n        load_data: if the matrices are to be loaded\n\n    Output:\n        bdf: the BDF header structure\n\n    Adapted the bdf_read.m macro from Sylvio Haas.\n    \"\"\"\n    # strip the bhf or bdf extension if there.\n    if filename.endswith(bdfext):\n        basename = filename[:-len(bdfext)]\n    elif filename.endswith(bhfext):\n        basename = filename[:-len(bhfext)]\n    else:  # assume a single file of header and data.\n        basename, bhfext = os.path.splitext(filename)\n        bdfext = bhfext\n    headername = basename + bhfext\n    dataname = basename + bdfext\n    bdf = {}\n    bdf['his'] = []  # empty list for history\n    bdf['C'] = {}  # empty list for bdf file descriptions\n    namelists = {}\n    valuelists = {}\n    with open(headername, 'rb') as fid:  # if fails, an exception is raised\n        for line in fid:\n            if not line.strip():\n                continue  # empty line\n            mat = line.split(None, 1)\n            prefix = mat[0]\n            if prefix == '#C':\n                left, right = mat[1].split('=', 1)\n                left = left.strip()\n                right = right.strip()\n                if left in ['xdim', 'ydim']:\n                    bdf[left] = int(right)\n                elif left in ['type', 'bdf']:\n                    bdf[left] = right\n                if left in ['Sendtime']:\n                    bdf['C'][left] = float(right)\n                elif left in ['xdim', 'ydim']:\n                    bdf['C'][left] = int(right)\n                else:\n                    bdf['C'][left] = misc.parse_number(right)\n            elif prefix.startswith(\"#H\"):\n                bdf['his'].append(mat[1])\n#            elif prefix.startswith(\"#DATA\"):\n#                if not load_data:\n#                    break\n#                darray = np.fromfile(fid, dtype = bdf['type'], count = int(bdf['xdim'] * bdf['ydim']))\n#                bdf['data'] = np.rot90((darray.reshape(bdf['xdim'], bdf['ydim'])).astype('double').T, 1).copy() # this weird transformation is needed to get the matrix in the same form as bdf_read.m gets it.\n#            elif prefix.startswith('#ERROR'):\n#                if not load_data:\n#                    break\n#                darray = np.fromfile(fid, dtype = bdf['type'], count = int(bdf['xdim'] * bdf['ydim']))\n#                bdf['error'] = np.rot90((darray.reshape(bdf['xdim'], bdf['ydim'])).astype('double').T, 1).copy()\n            else:\n                for prf in ['M', 'G', 'S', 'T']:\n                    if prefix.startswith('#C%sL' % prf):\n                        if prf not in namelists:\n                            namelists[prf] = []\n                        namelists[prf].extend(mat[1].split())\n                    elif prefix.startswith('#C%sV' % prf):\n                        if prf not in valuelists:\n                            valuelists[prf] = []\n                        valuelists[prf].extend([float(x)\n                                                for x in mat[1].split()])\n                    else:\n                        continue\n    for dictname, prfname in zip(['M', 'CG', 'CS', 'CT'], ['M', 'G', 'S', 'T']):\n        bdf[dictname] = dict(\n            list(zip(namelists[prfname], valuelists[prfname])))\n    bdf['__Origin__'] = 'BDFv1'\n    bdf['__particle__'] = 'photon'\n\n    if load_data:\n        f = open(dataname, 'r')\n        try:\n            s = f.read()\n        except IOError as ioe:\n            # an ugly bug (M$ KB899149) in W!nd0w$ causes an error if loading too\n            # large a file from a network drive and opening it read-only.\n            if ioe.errno == 22:\n                f.close()\n                try:\n                    # one work-around is to open it read-write.\n                    f = open(dataname, 'r+b')\n                    s = f.read()\n                except IOError:\n                    # if this does not work, inform the user to either obtain\n                    # write permission for that file or copy it to a local\n                    # drive\n                    f.close()\n                    raise IOError(22, \"\"\"\nYou were probably trying to open a read-only file from a network drive on\nWindows, weren\\'t you? There is a bug in Windows causing this error\n(see http://support.microsoft.com/default.aspx?scid=kb;en-us;899149).\nTo work around this, please either obtain write permission for that file\n(I won't write anything to it, I promise!!!) or copy it to a local drive.\nSorry for the inconvenience.\"\"\", ioe.filename)\n        datasets = re.findall(\n            '#\\s*(?P<name>\\w+)\\[(?P<xsize>\\d+):(?P<ysize>\\d+)\\]', s)\n        names = [d[0] for d in datasets]\n        xsize = [int(d[1]) for d in datasets]\n        ysize = [int(d[2]) for d in datasets]\n        dt = np.dtype(bdf['type'])\n        for i in range(len(datasets)):\n            start = s.find('#%s' % names[i])\n            if i < len(datasets) - 1:\n                end = s.find('#%s' % (names[i + 1]))\n            else:\n                end = len(s)\n            s1 = s[start:end]\n            datasize = xsize[i] * ysize[i] * dt.itemsize\n            if datasize > len(s1):\n                # assume we are dealing with a BOOL matrix\n                bdf[names[i]] = np.fromstring(\n                    s1[-xsize[i] * ysize[i]:], dtype=np.uint8)\n            else:\n                bdf[names[i]] = np.fromstring(\n                    s1[-xsize[i] * ysize[i] * dt.itemsize:], dtype=dt)\n            # conversion: Matlab saves the array in Fortran-style ordering (columns first).\n            # Python however loads in C-style: rows first. We need to take care:\n            #   1) reshape from linear to (ysize,xsize) and not (xsize,ysize)\n            #   2) transpose (swaps columns and rows)\n            # After these operations, we only have to rotate this counter-clockwise by 90\n            # degrees because bdf2_write rotates by +270 degrees before saving.\n            bdf[names[i]] = np.rot90(\n                bdf[names[i]].reshape((ysize[i], xsize[i]), order='F'), 1)\n\n    return bdf"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef readmarheader(filename):\n    with open(filename, 'rb') as f:\n        intheader = np.fromstring(f.read(10 * 4), np.int32)\n        floatheader = np.fromstring(f.read(15 * 4), '<f4')\n        strheader = f.read(24)\n        f.read(4)\n        otherstrings = [f.read(16) for i in range(29)]\n    return {'Xsize': intheader[0], 'Ysize': intheader[1], 'MeasTime': intheader[8],\n            'BeamPosX': floatheader[7], 'BeamPosY': floatheader[8],\n            'Wavelength': floatheader[9], 'Dist': floatheader[10],\n            '__Origin__': 'MarResearch .image', 'recordlength': intheader[2],\n            'highintensitypixels': intheader[4],\n            'highintensityrecords': intheader[5],\n            'Date': dateutil.parser.parse(strheader),\n            'Detector': 'MARCCD', '__particle__': 'photon'}", "response": "Read a header from a MarResearch. image file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readBerSANS(filename):\n    hed = {'Comment': ''}\n    translate = {'Lambda': 'Wavelength',\n                 'Title': 'Owner',\n                 'SampleName': 'Title',\n                 'BeamcenterX': 'BeamPosY',\n                 'BeamcenterY': 'BeamPosX',\n                 'Time': 'MeasTime',\n                 'TotalTime': 'MeasTime',\n                 'Moni1': 'Monitor',\n                 'Moni2': 'Monitor',\n                 'Moni': 'Monitor',\n                 'Transmission': 'Transm',\n                 }\n    with open(filename, 'rt') as f:\n        comment_next = False\n        for l in f:\n            l = l.strip()\n            if comment_next:\n                hed['Comment'] = hed['Comment'] + '\\n' + l\n                comment_next = False\n            elif l.startswith('%Counts'):\n                break\n            elif l.startswith('%Comment'):\n                comment_next = True\n            elif l.startswith('%'):\n                continue\n            elif l.split('=', 1)[0] in translate:\n                hed[translate[l.split('=', 1)[0]]] = misc.parse_number(\n                    l.split('=', 1)[1])\n            else:\n                try:\n                    hed[l.split('=', 1)[0]] = misc.parse_number(\n                        l.split('=', 1)[1])\n                except IndexError:\n                    print(l.split('=', 1))\n    if 'FileName' in hed:\n        m = re.match('D(\\d+)\\.(\\d+)', hed['FileName'])\n        if m is not None:\n            hed['FSN'] = int(m.groups()[0])\n            hed['suffix'] = int(m.groups()[1])\n    if 'FileDate' in hed:\n        hed['Date'] = dateutil.parser.parse(hed['FileDate'])\n    if 'FileTime' in hed:\n        hed['Date'] = datetime.datetime.combine(\n            hed['Date'].date(), dateutil.parser.parse(hed['FileTime']).time())\n    hed['__Origin__'] = 'BerSANS'\n    if 'SD' in hed:\n        hed['Dist'] = hed['SD'] * 1000\n    if hed['Comment'].startswith('\\n'):\n        hed['Comment'] = hed['Comment'][1:]\n    hed['__particle__'] = 'neutron'\n    hed['Wavelength'] *= 10  # convert from nanometres to Angstroems\n    return hed", "response": "Read a header from a BerSANS file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Cosine(x, a, omega, phi, y0):\n    return a * np.cos(x * omega + phi) + y0", "response": "Cosine function for frequency - based variables."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nseconds order polynomial of a set of terms.", "response": "def Square(x, a, b, c):\n    \"\"\"Second order polynomial\n\n    Inputs:\n    -------\n        ``x``: independent variable\n        ``a``: coefficient of the second-order term\n        ``b``: coefficient of the first-order term\n        ``c``: additive constant\n\n    Formula:\n    --------\n        ``a*x^2 + b*x + c``\n    \"\"\"\n    return a * x ** 2 + b * x + c"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nthird order polynomial of a set of terms.", "response": "def Cube(x, a, b, c, d):\n    \"\"\"Third order polynomial\n\n    Inputs:\n    -------\n        ``x``: independent variable\n        ``a``: coefficient of the third-order term\n        ``b``: coefficient of the second-order term\n        ``c``: coefficient of the first-order term\n        ``d``: additive constant\n\n    Formula:\n    --------\n        ``a*x^3 + b*x^2 + c*x + d``\n    \"\"\"\n    return a * x ** 3 + b * x ** 2 + c * x + d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef Exponential(x, a, tau, y0):\n    return np.exp(x / tau) * a + y0", "response": "Exponential function that returns the log - likelihood of a time - series."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef Lorentzian(x, a, x0, sigma, y0):\n    return a / (1 + ((x - x0) / sigma) ** 2) + y0", "response": "Lorentzian peak\n\n    Inputs:\n    -------\n        ``x``: independent variable\n        ``a``: scaling factor (extremal value)\n        ``x0``: center\n        ``sigma``: half width at half maximum\n        ``y0``: additive constant\n\n    Formula:\n    --------\n        ``a/(1+((x-x0)/sigma)^2)+y0``"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef LogNormal(x, a, mu, sigma):\n    return a / np.sqrt(2 * np.pi * sigma ** 2 * x ** 2) *\\\n        np.exp(-(np.log(x) - mu) ** 2 / (2 * sigma ** 2))", "response": "PDF of a log - normal distribution."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef radintpix(data, dataerr, bcx, bcy, mask=None, pix=None, returnavgpix=False,\n              phi0=0, dphi=0, returnmask=False, symmetric_sector=False,\n              doslice=False, errorpropagation=2, autoqrange_linear=True):\n    \"\"\"Radial integration (averaging) on the detector plane\n\n    Inputs:\n        data: scattering pattern matrix (np.ndarray, dtype: np.double)\n        dataerr: error matrix (np.ndarray, dtype: np.double; or None)\n        bcx, bcy: beam position, counting from 1\n        mask: mask matrix (np.ndarray, dtype: np.uint8)\n        pix: pixel distance values (abscissa) from origin. If None,\n            auto-determine.\n        returnavgpix: if the averaged pixel values should be returned\n        phi0: starting angle (radian) for sector integration. If doslice is True,\n            this is the angle of the slice.\n        dphi: angular width (radian) of the sector or width (pixels) of the\n            slice. If negative or zero, full radial average is requested.\n        returnmask: if the effective mask matrix is to be returned\n        symmetric_sector: the sector defined by phi0+pi is also to be used for\n            integration.\n        doslice: if slicing is to be done instead of sector averaging.\n        autoqrange_linear: if the automatically determined q-range is to be\n            linspace-d. Otherwise log10 spacing will be applied.\n\n    Outputs: pix, Intensity, [Error], Area, [mask]\n        Error is only returned if dataerr is not None\n        mask is only returned if returnmask is True\n\n    Relies heavily (completely) on radint().\n    \"\"\"\n    if isinstance(data, np.ndarray):\n        data = data.astype(np.double)\n    if isinstance(dataerr, np.ndarray):\n        dataerr = dataerr.astype(np.double)\n    if isinstance(mask, np.ndarray):\n        mask = mask.astype(np.uint8)\n    return radint(data, dataerr, -1, -1, -1,\n                  1.0 * bcx, 1.0 * bcy, mask, pix, returnavgpix,\n                  phi0, dphi, returnmask, symmetric_sector, doslice, False, errorpropagation, autoqrange_linear)", "response": "Radial integration of a single image on the detector plane."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind all subdirs of a directory.", "response": "def find_subdirs(startdir='.', recursion_depth=None):\n    \"\"\"Find all subdirectory of a directory.\n\n    Inputs:\n        startdir: directory to start with. Defaults to the current folder.\n        recursion_depth: number of levels to traverse. None is infinite.\n\n    Output: a list of absolute names of subfolders.\n\n    Examples:\n        >>> find_subdirs('dir',0)  # returns just ['dir']\n\n        >>> find_subdirs('dir',1)  # returns all direct (first-level) subdirs\n                                   # of 'dir'.\n    \"\"\"\n    startdir = os.path.expanduser(startdir)\n    direct_subdirs = [os.path.join(startdir, x) for x in os.listdir(\n        startdir) if os.path.isdir(os.path.join(startdir, x))]\n    if recursion_depth is None:\n        next_recursion_depth = None\n    else:\n        next_recursion_depth = recursion_depth - 1\n    if (recursion_depth is not None) and (recursion_depth <= 1):\n        return [startdir] + direct_subdirs\n    else:\n        subdirs = []\n        for d in direct_subdirs:\n            subdirs.extend(find_subdirs(d, next_recursion_depth))\n        return [startdir] + subdirs"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef findpeak(x, y, dy=None, position=None, hwhm=None, baseline=None, amplitude=None, curve='Lorentz'):\n    warnings.warn('Function findpeak() is deprecated, please use findpeak_single() instead.', DeprecationWarning)\n    pos, hwhm, baseline, ampl = findpeak_single(x, y, dy, position, hwhm, baseline, amplitude, curve)\n    return pos.val, pos.err, hwhm.val, hwhm.err, baseline.val, baseline.err, ampl.val, ampl.err", "response": "This function finds a positive peak in the dataset."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef findpeak_single(x, y, dy=None, position=None, hwhm=None, baseline=None, amplitude=None, curve='Lorentz',\n                    return_stat=False, signs=(-1, 1), return_x=None):\n    \"\"\"Find a (positive or negative) peak in the dataset.\n\n    Inputs:\n        x, y, dy: abscissa, ordinate and the error of the ordinate (can be None)\n        position, hwhm, baseline, amplitude: first guesses for the named parameters\n        curve: 'Gauss' or 'Lorentz' (default)\n        return_stat: return fitting statistics from easylsq.nlsq_fit()\n        signs: a tuple, can be (1,), (-1,), (1,-1). Will try these signs for the peak amplitude\n        return_x: abscissa on which the fitted function form has to be evaluated\n\n    Outputs:\n        peak position, hwhm, baseline, amplitude[, stat][, peakfunction]\n\n        where:\n            peak position, hwhm, baseline, amplitude are ErrorValue instances.\n            stat is the statistics dictionary, returned only if return_stat is True\n            peakfunction is the fitted peak evaluated at return_x if it is not None.\n\n    Notes:\n        A Gauss or a Lorentz curve is fitted, depending on the value of 'curve'. The abscissa\n        should be sorted, ascending.\n    \"\"\"\n    y_orig=y\n    if dy is None: dy = np.ones_like(x)\n    if curve.upper().startswith('GAUSS'):\n        def fitfunc(x_, amplitude_, position_, hwhm_, baseline_):\n            return amplitude_ * np.exp(-0.5 * (x_ - position_) ** 2 / hwhm_ ** 2) + baseline_\n    elif curve.upper().startswith('LORENTZ'):\n        def fitfunc(x_, amplitude_, position_, hwhm_, baseline_):\n            return amplitude_ * hwhm_ ** 2 / (hwhm_ ** 2 + (position_ - x_) ** 2) + baseline_\n    else:\n        raise ValueError('Invalid curve type: {}'.format(curve))\n    results=[]\n    # we try fitting a positive and a negative peak and return the better fit (where R2 is larger)\n    for sign in signs:\n        init_params={'position':position,'hwhm':hwhm,'baseline':baseline,'amplitude':amplitude}\n        y = y_orig * sign\n        if init_params['position'] is None: init_params['position'] = x[y == y.max()][0]\n        if init_params['hwhm'] is None: init_params['hwhm'] = 0.5 * (x.max() - x.min())\n        if init_params['baseline'] is None: init_params['baseline'] = y.min()\n        if init_params['amplitude'] is None: init_params['amplitude'] = y.max() - init_params['baseline']\n        results.append(nlsq_fit(x, y, dy, fitfunc, (init_params['amplitude'],\n                                                   init_params['position'],\n                                                   init_params['hwhm'],\n                                                   init_params['baseline']))+(sign,))\n    max_R2=max([r[2]['R2'] for r in results])\n    p,dp,stat,sign=[r for r in results if r[2]['R2']==max_R2][0]\n    retval = [ErrorValue(p[1], dp[1]), ErrorValue(abs(p[2]), dp[2]), sign * ErrorValue(p[3], dp[3]),\n              sign * ErrorValue(p[0], dp[0])]\n    if return_stat:\n        stat['func_value'] = stat['func_value'] * sign\n        retval.append(stat)\n    if return_x is not None:\n        retval.append(sign * fitfunc(return_x, p[0], p[1], p[2], p[3]))\n    return tuple(retval)", "response": "Find a single peak in the dataset."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef findpeak_multi(x, y, dy, N, Ntolerance, Nfit=None, curve='Lorentz', return_xfit=False, return_stat=False):\n    if Nfit is None:\n        Nfit = N\n    # find points where the curve grows for N points before them and\n    # decreases for N points after them. To accomplish this, we create\n    # an indicator array of the sign of the first derivative.\n    sgndiff = np.sign(np.diff(y))\n    xdiff = x[:-1]  # associate difference values to the lower 'x' value.\n    pix = np.arange(len(x) - 1)  # pixel coordinates create an indicator\n    # array as the sum of sgndiff shifted left and right.  whenever an\n    # element of this is 2*N, it fulfills the criteria above.\n    indicator = np.zeros(len(sgndiff) - 2 * N)\n    for i in range(2 * N):\n        indicator += np.sign(N - i) * sgndiff[i:-2 * N + i]\n    # add the last one, since the indexing is different (would be\n    # [2*N:0], which is not what we want)\n    indicator += -sgndiff[2 * N:]\n    # find the positions (indices) of the peak. The strict criteria is\n    # relaxed somewhat by using the Ntolerance value. Note the use of\n    # 2*Ntolerance, since each outlier point creates two outliers in\n    # sgndiff (-1 insted of +1 and vice versa).\n    peakpospix = pix[N:-N][indicator >= 2 * N - 2 * Ntolerance]\n    ypeak = y[peakpospix]\n    # Now refine the found positions by least-squares fitting. But\n    # first we have to sort out other non-peaks, i.e. found points\n    # which have other found points with higher values in their [-N,N]\n    # neighbourhood.\n    pos = []; ampl = []; hwhm = []; baseline = []; xfit = []; stat = []\n    dy1 = None\n    for i in range(len(ypeak)):\n        if not [j for j in list(range(i + 1, len(ypeak))) + list(range(0, i)) if abs(peakpospix[j] - peakpospix[i]) <= N and ypeak[i] < ypeak[j]]:\n            # only leave maxima.\n            idx = peakpospix[i]\n            if dy is not None:\n                dy1 = dy[(idx - Nfit):(idx + Nfit + 1)]\n            xfit_ = x[(idx - Nfit):(idx + Nfit + 1)]\n            pos_, hwhm_, baseline_, ampl_, stat_ = findpeak_single(xfit_, y[(idx - Nfit):(idx + Nfit + 1)], dy1, position=x[idx], return_stat=True)\n            \n            stat.append(stat_)\n            xfit.append(xfit_)\n            pos.append(pos_)\n            ampl.append(ampl_)\n            hwhm.append(hwhm_)\n            baseline.append(baseline_)\n    results = [pos, hwhm, baseline, ampl]\n    if return_xfit:\n        results.append(xfit)\n    if return_stat:\n        results.append(stat)\n    return tuple(results)", "response": "Find multiple peaks in the dataset given by vectors x and y."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef findpeak_asymmetric(x, y, dy=None, curve='Lorentz', return_x=None, init_parameters=None):\n    idx = np.logical_and(np.isfinite(x), np.isfinite(y))\n    if dy is not None:\n        idx = np.logical_and(idx, np.isfinite(dy))\n    x=x[idx]\n    y=y[idx]\n    if dy is not None:\n        dy=dy[idx]\n    if curve.lower().startswith('loren'):\n        lorentzian = True\n    elif curve.lower().startswith('gauss'):\n        lorentzian = False\n    else:\n        raise ValueError('Unknown peak type {}'.format(curve))\n\n    def peakfunc(pars, x, lorentzian=True):\n        x0, sigma1, sigma2, C, A = pars\n        result = np.empty_like(x)\n        if lorentzian:\n            result[x < x0] = A * sigma1 ** 2 / (sigma1 ** 2 + (x0 - x[x < x0]) ** 2) + C\n            result[x >= x0] = A * sigma2 ** 2 / (sigma2 ** 2 + (x0 - x[x >= x0]) ** 2) + C\n        else:\n            result[x < x0] = A * np.exp(-(x[x < x0] - x0) ** 2 / (2 * sigma1 ** 2))\n            result[x >= x0] = A * np.exp(-(x[x >= x0] - x0) ** 2 / (2 * sigma1 ** 2))\n        return result\n\n    def fitfunc(pars, x, y, dy, lorentzian=True):\n        yfit = peakfunc(pars, x, lorentzian)\n        if dy is None:\n            return yfit - y\n        else:\n            return (yfit - y) / dy\n    if init_parameters is not None:\n        pos, hwhmleft, hwhmright, baseline, amplitude = [float(x) for x in init_parameters]\n    else:\n        baseline = y.min()\n        amplitude = y.max() - baseline\n        hwhmleft = hwhmright = (x.max() - x.min()) * 0.5\n        pos = x[np.argmax(y)]\n    #print([pos,hwhm,hwhm,baseline,amplitude])\n    result = scipy.optimize.least_squares(fitfunc, [pos, hwhmleft, hwhmright, baseline, amplitude],\n                                          args=(x, y, dy, lorentzian),\n                                          bounds=([x.min(), 0, 0, -np.inf, 0],\n                                                  [x.max(), np.inf, np.inf, np.inf, np.inf]))\n#    print(result.x[0], result.x[1], result.x[2], result.x[3], result.x[4], result.message, result.success)\n    if not result.success:\n        raise RuntimeError('Error while peak fitting: {}'.format(result.message))\n    if dy is None:\n        ret = (result.x[0], result.x[1], result.x[2], result.x[3], result.x[4])\n    else:\n        # noinspection PyTupleAssignmentBalance\n        _, s, VT = svd(result.jac, full_matrices=False)\n        threshold = np.finfo(float).eps * max(result.jac.shape) * s[0]\n        s = s[s > threshold]\n        VT = VT[:s.size]\n        pcov = np.dot(VT.T / s ** 2, VT)\n        ret = tuple([ErrorValue(result.x[i], pcov[i, i] ** 0.5) for i in range(5)])\n    if return_x is not None:\n        ret = ret + (peakfunc([float(x) for x in ret], return_x, lorentzian),)\n    return ret", "response": "This function finds an asymmetric peak in the dataset."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads the next spec scan in the file.", "response": "def readspecscan(f, number=None):\n    \"\"\"Read the next spec scan in the file, which starts at the current position.\"\"\"\n    scan = None\n    scannumber = None\n    while True:\n        l = f.readline()\n        if l.startswith('#S'):\n            scannumber = int(l[2:].split()[0])\n            if not ((number is None) or (number == scannumber)):\n                # break the loop, will skip to the next empty line after this\n                # loop\n                break\n            if scan is None:\n                scan = {}\n            scan['number'] = scannumber\n            scan['command'] = l[2:].split(None, 1)[1].strip()\n            scan['data'] = []\n        elif l.startswith('#C'):\n            scan['comment'] = l[2:].strip()\n        elif l.startswith('#D'):\n            scan['datestring'] = l[2:].strip()\n        elif l.startswith('#T'):\n            scan['countingtime'] = float(l[2:].split()[0])\n            scan['scantimeunits'] = l[2:].split()[1].strip()\n        elif l.startswith('#M'):\n            scan['countingcounts'] = float(l[2:].split()[0])\n        elif l.startswith('#G'):\n            if 'G' not in scan:\n                scan['G'] = []\n            scan['G'].extend([float(x) for x in l.split()[1:]])\n        elif l.startswith('#P'):\n            if 'positions' not in scan:\n                scan['positions'] = []\n            scan['positions'].extend([float(x) for x in l.split()[1:]])\n        elif l.startswith('#Q'):\n            pass\n        elif l.startswith('#N'):\n            n = [float(x) for x in l[2:].strip().split()]\n            if len(n) == 1:\n                scan['N'] = n[0]\n            else:\n                scan['N'] = n\n        elif l.startswith('#L'):\n            scan['Columns'] = [x.strip() for x in l[3:].split('  ')]\n        elif not l:\n            # end of file\n            if scan is None:\n                raise SpecFileEOF\n            else:\n                break\n        elif not l.strip():\n            break  # empty line, end of scan in file.\n        elif l.startswith('#'):\n            # ignore other lines starting with a hashmark.\n            continue\n        else:\n            scan['data'].append(tuple(float(x) for x in l.split()))\n    while l.strip():\n        l = f.readline()\n    if scan is not None:\n        scan['data'] = np.array(\n            scan['data'], dtype=list(zip(scan['Columns'], itertools.repeat(np.float))))\n        return scan\n    else:\n        return scannumber"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nopens a SPEC file and read its content into a dict.", "response": "def readspec(filename, read_scan=None):\n    \"\"\"Open a SPEC file and read its content\n\n    Inputs:\n\n        filename: string\n            the file to open\n\n        read_scan: None, 'all' or integer\n            the index of scan to be read from the file. If None, no scan should be read. If\n            'all', all scans should be read. If a number, just the scan with that number\n            should be read.\n\n    Output:\n        the data in the spec file in a dict.\n    \"\"\"\n    with open(filename, 'rt') as f:\n        sf = {'motors': [], 'maxscannumber': 0}\n        sf['originalfilename'] = filename\n        lastscannumber = None\n        while True:\n            l = f.readline()\n            if l.startswith('#F'):\n                sf['filename'] = l[2:].strip()\n            elif l.startswith('#E'):\n                sf['epoch'] = int(l[2:].strip())\n                sf['datetime'] = datetime.datetime.fromtimestamp(sf['epoch'])\n            elif l.startswith('#D'):\n                sf['datestring'] = l[2:].strip()\n            elif l.startswith('#C'):\n                sf['comment'] = l[2:].strip()\n            elif l.startswith('#O'):\n                try:\n                    l = l.split(None, 1)[1]\n                except IndexError:\n                    continue\n                if 'motors' not in list(sf.keys()):\n                    sf['motors'] = []\n                sf['motors'].extend([x.strip() for x in l.split('  ')])\n            elif not l.strip():\n                # empty line, signifies the end of the header part. The next\n                # line will be a scan.\n                break\n        sf['scans'] = {}\n        if read_scan is not None:\n            if read_scan == 'all':\n                nr = None\n            else:\n                nr = read_scan\n            try:\n                while True:\n                    s = readspecscan(f, nr)\n                    if isinstance(s, dict):\n                        sf['scans'][s['number']] = s\n                        if nr is not None:\n                            break\n                        sf['maxscannumber'] = max(\n                            sf['maxscannumber'], s['number'])\n                    elif s is not None:\n                        sf['maxscannumber'] = max(sf['maxscannumber'], s)\n            except SpecFileEOF:\n                pass\n        else:\n            while True:\n                l = f.readline()\n                if not l:\n                    break\n                if l.startswith('#S'):\n                    n = int(l[2:].split()[0])\n                    sf['maxscannumber'] = max(sf['maxscannumber'], n)\n        for n in sf['scans']:\n            s = sf['scans'][n]\n            s['motors'] = sf['motors']\n            if 'comment' not in s:\n                s['comment'] = sf['comment']\n            if 'positions' not in s:\n                s['positions'] = [None] * len(sf['motors'])\n    return sf"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading a file from beamline B1 HASYLAB and return a dictionary. The keys are self - planatory. The values are self - planatory.", "response": "def readabt(filename, dirs='.'):\n    \"\"\"Read abt_*.fio type files from beamline B1, HASYLAB.\n\n    Input:\n        filename: the name of the file.\n        dirs: directories to search for files in\n\n    Output:\n        A dictionary. The fields are self-explanatory.\n    \"\"\"\n    # resolve filename\n    filename = misc.findfileindirs(filename, dirs)\n    f = open(filename, 'rt')\n    abt = {'offsetcorrected': False, 'params': {}, 'columns': [], 'data': [], 'title': '<no_title>',\n           'offsets': {}, 'filename': filename}\n    readingmode = ''\n    for l in f:\n        l = l.strip()\n        if l.startswith('!') or len(l) == 0:\n            continue\n        elif l.startswith('%c'):\n            readingmode = 'comments'\n        elif l.startswith('%p'):\n            readingmode = 'params'\n        elif l.startswith('%d'):\n            readingmode = 'data'\n        elif readingmode == 'comments':\n            m = re.match(\n                r'(?P<scantype>\\w+)-Scan started at (?P<startdate>\\d+-\\w+-\\d+) (?P<starttime>\\d+:\\d+:\\d+), ended (?P<endtime>\\d+:\\d+:\\d+)', l)\n            if m:\n                abt.update(m.groupdict())\n                continue\n            else:\n                m = re.match(r'Name: (?P<name>\\w+)', l)\n                if m:\n                    abt.update(m.groupdict())\n                    m1 = re.search(r'from (?P<from>\\d+(?:.\\d+)?)', l)\n                    if m1:\n                        abt.update(m1.groupdict())\n                    m1 = re.search(r'to (?P<to>\\d+(?:.\\d+)?)', l)\n                    if m1:\n                        abt.update(m1.groupdict())\n                    m1 = re.search(r'by (?P<by>\\d+(?:.\\d+)?)', l)\n                    if m1:\n                        abt.update(m1.groupdict())\n                    m1 = re.search(r'sampling (?P<sampling>\\d+(?:.\\d+)?)', l)\n                    if m1:\n                        abt.update(m1.groupdict())\n                    continue\n            if l.find('Counter readings are offset corrected') >= 0:\n                abt['offsetcorrected'] = True\n                readingmode = 'offsets'\n                continue\n            # if we reach here in 'comments' mode, this is the title line\n            abt['title'] = l\n            continue\n        elif readingmode == 'offsets':\n            m = re.findall(r'(\\w+)\\s(\\d+(?:.\\d+)?)', l)\n            if m:\n                abt['offsets'].update(dict(m))\n                for k in abt['offsets']:\n                    abt['offsets'][k] = float(abt['offsets'][k])\n        elif readingmode == 'params':\n            abt['params'][l.split('=')[0].strip()] = float(\n                l.split('=')[1].strip())\n        elif readingmode == 'data':\n            if l.startswith('Col'):\n                abt['columns'].append(l.split()[2])\n            else:\n                abt['data'].append([float(x) for x in l.split()])\n    f.close()\n    # some post-processing\n    # remove common prefix from column names\n    maxcolnamelen = max(len(c) for c in abt['columns'])\n    l = 1\n    for l in range(1, maxcolnamelen):\n        if len(set([c[:l] for c in abt['columns']])) > 1:\n            break\n    abt['columns'] = [c[l - 1:] for c in abt['columns']]\n    # represent data as a structured array\n    dt = np.dtype(list(zip(abt['columns'], itertools.repeat(np.double))))\n    abt['data'] = np.array(abt['data'], dtype=np.double).view(dt)\n    # dates and times in datetime formats\n    monthnames = ['Jan', 'Feb', 'Mar', 'Apr', 'May',\n                  'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    for m, i in zip(monthnames, itertools.count(1)):\n        abt['startdate'] = abt['startdate'].replace(m, str(i))\n    abt['startdate'] = datetime.date(\n        *reversed([int(x) for x in abt['startdate'].split('-')]))\n    abt['starttime'] = datetime.time(\n        *[int(x) for x in abt['starttime'].split(':')])\n    abt['endtime'] = datetime.time(\n        *[int(x) for x in abt['endtime'].split(':')])\n    abt['start'] = datetime.datetime.combine(\n        abt['startdate'], abt['starttime'])\n    if abt['endtime'] <= abt['starttime']:\n        abt['end'] = datetime.datetime.combine(\n            abt['startdate'] + datetime.timedelta(1), abt['endtime'])\n    else:\n        abt['end'] = datetime.datetime.combine(\n            abt['startdate'], abt['endtime'])\n    del abt['starttime']\n    del abt['startdate']\n    del abt['endtime']\n    # convert some fields to float\n    for k in ['from', 'to', 'by', 'sampling']:\n        if k in abt:\n            abt[k] = float(abt[k])\n    # change space and dash in title to underscore\n    abt['title'] = abt['title'].replace('-', '_').replace(' ', '_')\n    return abt"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef energy(self) -> ErrorValue:\n        return (ErrorValue(*(scipy.constants.physical_constants['speed of light in vacuum'][0::2])) *\n                ErrorValue(*(scipy.constants.physical_constants['Planck constant in eV s'][0::2])) /\n                scipy.constants.nano /\n                self.wavelength)", "response": "X - ray energy"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef maskname(self) -> Optional[str]:\n        try:\n            maskid = self._data['maskname']\n            if not maskid.endswith('.mat'):\n                maskid = maskid + '.mat'\n            return maskid\n        except KeyError:\n            return None", "response": "Name of the mask matrix file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds the beam center with the gravity method.", "response": "def findbeam_gravity(data, mask):\n    \"\"\"Find beam center with the \"gravity\" method\n\n    Inputs:\n        data: scattering image\n        mask: mask matrix\n\n    Output:\n        a vector of length 2 with the x (row) and y (column) coordinates\n         of the origin, starting from 1\n    \"\"\"\n    # for each row and column find the center of gravity\n    data1 = data.copy()  # take a copy, because elements will be tampered with\n    data1[mask == 0] = 0  # set masked elements to zero\n    # vector of x (row) coordinates\n    x = np.arange(data1.shape[0])\n    # vector of y (column) coordinates\n    y = np.arange(data1.shape[1])\n    # two column vectors, both containing ones. The length of onex and\n    # oney corresponds to length of x and y, respectively.\n    onex = np.ones_like(x)\n    oney = np.ones_like(y)\n    # Multiply the matrix with x. Each element of the resulting column\n    # vector will contain the center of gravity of the corresponding row\n    # in the matrix, multiplied by the \"weight\". Thus: nix_i=sum_j( A_ij\n    # * x_j). If we divide this by spamx_i=sum_j(A_ij), then we get the\n    # center of gravity. The length of this column vector is len(y).\n    nix = np.dot(x, data1)\n    spamx = np.dot(onex, data1)\n    # indices where both nix and spamx is nonzero.\n    goodx = ((nix != 0) & (spamx != 0))\n    # trim y, nix and spamx by goodx, eliminate invalid points.\n    nix = nix[goodx]\n    spamx = spamx[goodx]\n\n    # now do the same for the column direction.\n    niy = np.dot(data1, y)\n    spamy = np.dot(data1, oney)\n    goody = ((niy != 0) & (spamy != 0))\n    niy = niy[goody]\n    spamy = spamy[goody]\n    # column coordinate of the center in each row will be contained in\n    # ycent, the row coordinate of the center in each column will be\n    # in xcent.\n    ycent = nix / spamx\n    xcent = niy / spamy\n    # return the mean values as the centers.\n    return [xcent.mean(), ycent.mean()]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind beam center with the slices method.", "response": "def findbeam_slices(data, orig_initial, mask=None, maxiter=0, epsfcn=0.001,\n                    dmin=0, dmax=np.inf, sector_width=np.pi / 9.0, extent=10, callback=None):\n    \"\"\"Find beam center with the \"slices\" method\n\n    Inputs:\n        data: scattering matrix\n        orig_initial: estimated value for x (row) and y (column)\n            coordinates of the beam center, starting from 1.\n        mask: mask matrix. If None, nothing will be masked. Otherwise it\n            should be of the same size as data. Nonzero means non-masked.\n        maxiter: maximum number of iterations for scipy.optimize.leastsq\n        epsfcn: input for scipy.optimize.leastsq\n        dmin: disregard pixels nearer to the origin than this\n        dmax: disregard pixels farther from the origin than this\n        sector_width: width of sectors in radians\n        extent: approximate distance of the current and the real origin in pixels.\n            Too high a value makes the fitting procedure unstable. Too low a value\n            does not permit to move away the current origin.\n        callback: callback function (expects no arguments)\n\n    Output:\n        a vector of length 2 with the x (row) and y (column) coordinates\n         of the origin.\n    \"\"\"\n    if mask is None:\n        mask = np.ones(data.shape)\n    data = data.astype(np.double)\n\n    def targetfunc(orig, data, mask, orig_orig, callback):\n        # integrate four sectors\n        I = [None] * 4\n        p, Ints, A = radint_nsector(data, None, -1, -1, -1, orig[0] + orig_orig[0], orig[1] + orig_orig[1], mask=mask,\n                                    phi0=np.pi / 4 - 0.5 * sector_width, dphi=sector_width,\n                                    Nsector=4)\n        minpix = max(max(p.min(0).tolist()), dmin)\n        maxpix = min(min(p.max(0).tolist()), dmax)\n        if (maxpix < minpix):\n            raise ValueError('The four slices do not overlap! Please give a\\\n better approximation for the origin or use another centering method.')\n        for i in range(4):\n            I[i] = Ints[:, i][(p[:, i] >= minpix) & (p[:, i] <= maxpix)]\n        ret = ((I[0] - I[2]) ** 2 + (I[1] - I[3]) ** 2) / (maxpix - minpix)\n        if callback is not None:\n            callback()\n        return ret\n    orig = scipy.optimize.leastsq(targetfunc, np.array([extent, extent]),\n                                  args=(data, 1 - mask.astype(np.uint8),\n                                        np.array(orig_initial) - extent, callback),\n                                  maxfev=maxiter, epsfcn=0.01)\n    return orig[0] + np.array(orig_initial) - extent"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef findbeam_azimuthal(data, orig_initial, mask=None, maxiter=100, Ntheta=50,\n                       dmin=0, dmax=np.inf, extent=10, callback=None):\n    \"\"\"Find beam center using azimuthal integration\n\n    Inputs:\n        data: scattering matrix\n        orig_initial: estimated value for x (row) and y (column)\n            coordinates of the beam center, starting from 1.\n        mask: mask matrix. If None, nothing will be masked. Otherwise it\n            should be of the same size as data. Nonzero means non-masked.\n        maxiter: maximum number of iterations for scipy.optimize.fmin\n        Ntheta: the number of theta points for the azimuthal integration\n        dmin: pixels nearer to the origin than this will be excluded from\n            the azimuthal integration\n        dmax: pixels farther from the origin than this will be excluded from\n            the azimuthal integration\n        extent: approximate distance of the current and the real origin in pixels.\n            Too high a value makes the fitting procedure unstable. Too low a value\n            does not permit to move away the current origin.\n        callback: callback function (expects no arguments)\n    Output:\n        a vector of length 2 with the x and y coordinates of the origin,\n            starting from 1\n    \"\"\"\n    if mask is None:\n        mask = np.ones(data.shape)\n    data = data.astype(np.double)\n\n    def targetfunc(orig, data, mask, orig_orig, callback):\n        def sinfun(p, x, y):\n            return (y - np.sin(x + p[1]) * p[0] - p[2]) / np.sqrt(len(x))\n        t, I, a = azimintpix(data, None, orig[\n                             0] + orig_orig[0], orig[1] + orig_orig[1], mask.astype('uint8'), Ntheta, dmin, dmax)\n        if len(a) > (a > 0).sum():\n            raise ValueError('findbeam_azimuthal: non-complete azimuthal average, please consider changing dmin, dmax and/or orig_initial!')\n        p = ((I.max() - I.min()) / 2.0, t[I == I.max()][0], I.mean())\n        p = scipy.optimize.leastsq(sinfun, p, (t, I))[0]\n        # print \"findbeam_azimuthal: orig=\",orig,\"amplitude=\",abs(p[0])\n        if callback is not None:\n            callback()\n        return abs(p[0])\n    orig1 = scipy.optimize.fmin(targetfunc, np.array([extent, extent]),\n                                args=(data, 1 - mask, np.array(orig_initial) - extent,\n                                      callback), maxiter=maxiter, disp=0)\n    return orig1 + np.array(orig_initial) - extent", "response": "This function finds the beam center using azimuthal integration."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef findbeam_azimuthal_fold(data, orig_initial, mask=None, maxiter=100,\n                            Ntheta=50, dmin=0, dmax=np.inf, extent=10, callback=None):\n    \"\"\"Find beam center using azimuthal integration and folding\n\n    Inputs:\n        data: scattering matrix\n        orig_initial: estimated value for x (row) and y (column)\n            coordinates of the beam center, starting from 1.\n        mask: mask matrix. If None, nothing will be masked. Otherwise it\n            should be of the same size as data. Nonzero means non-masked.\n        maxiter: maximum number of iterations for scipy.optimize.fmin\n        Ntheta: the number of theta points for the azimuthal integration.\n            Should be even!\n        dmin: pixels nearer to the origin than this will be excluded from\n            the azimuthal integration\n        dmax: pixels farther from the origin than this will be excluded from\n            the azimuthal integration\n        extent: approximate distance of the current and the real origin in pixels.\n            Too high a value makes the fitting procedure unstable. Too low a value\n            does not permit to move away the current origin.\n        callback: callback function (expects no arguments)\n    Output:\n        a vector of length 2 with the x and y coordinates of the origin,\n            starting from 1\n    \"\"\"\n    if Ntheta % 2:\n        raise ValueError('Ntheta should be even!')\n    if mask is None:\n        mask = np.ones_like(data).astype(np.uint8)\n    data = data.astype(np.double)\n    # the function to minimize is the sum of squared difference of two halves of\n    # the azimuthal integral.\n\n    def targetfunc(orig, data, mask, orig_orig, callback):\n        I = azimintpix(data, None, orig[\n                       0] + orig_orig[0], orig[1] + orig_orig[1], mask, Ntheta, dmin, dmax)[1]\n        if callback is not None:\n            callback()\n        return np.sum((I[:Ntheta / 2] - I[Ntheta / 2:]) ** 2) / Ntheta\n    orig1 = scipy.optimize.fmin(targetfunc, np.array([extent, extent]),\n                                args=(data, 1 - mask, np.array(orig_initial) - extent, callback), maxiter=maxiter, disp=0)\n    return orig1 + np.array(orig_initial) - extent", "response": "This function finds the beam center using azimuthal integration and folding."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding beam with 2D weighting of semitransparent beamstop area.", "response": "def findbeam_semitransparent(data, pri, threshold=0.05):\n    \"\"\"Find beam with 2D weighting of semitransparent beamstop area\n\n    Inputs:\n        data: scattering matrix\n        pri: list of four: [xmin,xmax,ymin,ymax] for the borders of the beam\n            area under the semitransparent beamstop. X corresponds to the column\n            index (ie. A[Y,X] is the element of A from the Xth column and the\n            Yth row). You can get these by zooming on the figure and retrieving\n            the result of axis() (like in Matlab)\n        threshold: do not count pixels if their intensity falls below\n            max_intensity*threshold. max_intensity is the highest count rate\n            in the current row or column, respectively. Set None to disable\n            this feature.\n\n    Outputs: bcx,bcy\n        the x and y coordinates of the primary beam\n    \"\"\"\n    rowmin = np.floor(min(pri[2:]))\n    rowmax = np.ceil(max(pri[2:]))\n    colmin = np.floor(min(pri[:2]))\n    colmax = np.ceil(max(pri[:2]))\n\n    if threshold is not None:\n        # beam area on the scattering image\n        B = data[rowmin:rowmax, colmin:colmax]\n        # print B.shape\n        # row and column indices\n        Ri = np.arange(rowmin, rowmax)\n        Ci = np.arange(colmin, colmax)\n        # print len(Ri)\n        # print len(Ci)\n        Ravg = B.mean(1)  # average over column index, will be a concave curve\n        Cavg = B.mean(0)  # average over row index, will be a concave curve\n        # find the maxima im both directions and their positions\n        maxR = Ravg.max()\n        maxRpos = Ravg.argmax()\n        maxC = Cavg.max()\n        maxCpos = Cavg.argmax()\n        # cut off pixels which are smaller than threshold*peak_height\n        Rmin = Ri[\n            ((Ravg - Ravg[0]) >= ((maxR - Ravg[0]) * threshold)) & (Ri < maxRpos)][0]\n        Rmax = Ri[\n            ((Ravg - Ravg[-1]) >= ((maxR - Ravg[-1]) * threshold)) & (Ri > maxRpos)][-1]\n        Cmin = Ci[\n            ((Cavg - Cavg[0]) >= ((maxC - Cavg[0]) * threshold)) & (Ci < maxCpos)][0]\n        Cmax = Ci[\n            ((Cavg - Cavg[-1]) >= ((maxC - Cavg[-1]) * threshold)) & (Ci > maxCpos)][-1]\n    else:\n        Rmin = rowmin\n        Rmax = rowmax\n        Cmin = colmin\n        Cmax = colmax\n    d = data[Rmin:Rmax + 1, Cmin:Cmax + 1]\n    x = np.arange(Rmin, Rmax + 1)\n    y = np.arange(Cmin, Cmax + 1)\n    bcx = (d.sum(1) * x).sum() / d.sum()\n    bcy = (d.sum(0) * y).sum() / d.sum()\n    return bcx, bcy"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the beam in the radial average.", "response": "def findbeam_radialpeak(data, orig_initial, mask, rmin, rmax, maxiter=100,\n                        drive_by='amplitude', extent=10, callback=None):\n    \"\"\"Find the beam by minimizing the width of a peak in the radial average.\n\n    Inputs:\n        data: scattering matrix\n        orig_initial: first guess for the origin\n        mask: mask matrix. Nonzero is non-masked.\n        rmin,rmax: distance from the origin (in pixels) of the peak range.\n        drive_by: 'hwhm' to minimize the hwhm of the peak or 'amplitude' to\n            maximize the peak amplitude\n        extent: approximate distance of the current and the real origin in pixels.\n            Too high a value makes the fitting procedure unstable. Too low a value\n            does not permit to move away the current origin.\n        callback: callback function (expects no arguments)\n    Outputs:\n        the beam coordinates\n\n    Notes:\n        A Gaussian will be fitted.\n    \"\"\"\n    orig_initial = np.array(orig_initial)\n    mask = 1 - mask.astype(np.uint8)\n    data = data.astype(np.double)\n    pix = np.arange(rmin * 1.0, rmax * 1.0, 1)\n    if drive_by.lower() == 'hwhm':\n        def targetfunc(orig, data, mask, orig_orig, callback):\n            I = radintpix(\n                data, None, orig[0] + orig_orig[0], orig[1] + orig_orig[1], mask, pix)[1]\n            hwhm = float(misc.findpeak_single(pix, I)[1])\n            # print orig[0] + orig_orig[0], orig[1] + orig_orig[1], p\n            if callback is not None:\n                callback()\n            return abs(hwhm)\n    elif drive_by.lower() == 'amplitude':\n        def targetfunc(orig, data, mask, orig_orig, callback):\n            I = radintpix(\n                data, None, orig[0] + orig_orig[0], orig[1] + orig_orig[1], mask, pix)[1]\n            fp = misc.findpeak_single(pix, I)\n            height = -float(fp[2] + fp[3])\n            # print orig[0] + orig_orig[0], orig[1] + orig_orig[1], p\n            if callback is not None:\n                callback()\n            return height\n    else:\n        raise ValueError('Invalid argument for drive_by %s' % drive_by)\n    orig1 = scipy.optimize.fmin(targetfunc, np.array([extent, extent]),\n                                args=(\n                                    data, mask, orig_initial - extent, callback),\n                                maxiter=maxiter, disp=0)\n    return np.array(orig_initial) - extent + orig1"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the beam of a Guinier scattering.", "response": "def findbeam_Guinier(data, orig_initial, mask, rmin, rmax, maxiter=100,\n                     extent=10, callback=None):\n    \"\"\"Find the beam by minimizing the width of a Gaussian centered at the\n    origin (i.e. maximizing the radius of gyration in a Guinier scattering).\n\n    Inputs:\n        data: scattering matrix\n        orig_initial: first guess for the origin\n        mask: mask matrix. Nonzero is non-masked.\n        rmin,rmax: distance from the origin (in pixels) of the Guinier range.\n        extent: approximate distance of the current and the real origin in pixels.\n            Too high a value makes the fitting procedure unstable. Too low a value\n            does not permit to move away the current origin.\n        callback: callback function (expects no arguments)\n    Outputs:\n        the beam coordinates\n\n    Notes:\n        A Gaussian with its will be fitted.\n    \"\"\"\n    orig_initial = np.array(orig_initial)\n    mask = 1 - mask.astype(np.uint8)\n    data = data.astype(np.double)\n    pix = np.arange(rmin * 1.0, rmax * 1.0, 1)\n    pix2 = pix ** 2\n\n    def targetfunc(orig, data, mask, orig_orig, callback):\n        I = radintpix(\n            data, None, orig[0] + orig_orig[0], orig[1] + orig_orig[1], mask, pix)[1]\n        p = np.polyfit(pix2, np.log(I), 1)[0]\n        if callback is not None:\n            callback()\n        return p\n    orig1 = scipy.optimize.fmin(targetfunc, np.array([extent, extent]),\n                                args=(\n                                    data, mask, orig_initial - extent, callback),\n                                maxiter=maxiter, disp=0)\n    return np.array(orig_initial) - extent + orig1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind the beam of a Guinier scattering.", "response": "def findbeam_powerlaw(data, orig_initial, mask, rmin, rmax, maxiter=100,\n                      drive_by='R2', extent=10, callback=None):\n    \"\"\"Find the beam by minimizing the width of a Gaussian centered at the\n    origin (i.e. maximizing the radius of gyration in a Guinier scattering).\n\n    Inputs:\n        data: scattering matrix\n        orig_initial: first guess for the origin\n        mask: mask matrix. Nonzero is non-masked.\n        rmin,rmax: distance from the origin (in pixels) of the fitting range\n        drive_by: 'R2' or 'Chi2'\n        extent: approximate distance of the current and the real origin in pixels.\n            Too high a value makes the fitting procedure unstable. Too low a value\n            does not permit to move away the current origin.\n        callback: callback function (expects no arguments)\n    Outputs:\n        the beam coordinates\n\n    Notes:\n        A power-law will be fitted\n    \"\"\"\n    orig_initial = np.array(orig_initial)\n    mask = 1 - mask.astype(np.uint8)\n    data = data.astype(np.double)\n    pix = np.arange(rmin * 1.0, rmax * 1.0, 1)\n\n    def targetfunc(orig, data, mask, orig_orig, callback):\n        I, E = radintpix(\n            data, None, orig[0] + orig_orig[0], orig[1] + orig_orig[1], mask, pix)[1:3]\n        p, dp, stat = misc.easylsq.nlsq_fit(\n            pix, I, E, lambda q, A, alpha: A * q ** alpha, [1.0, -3.0])\n        if callback is not None:\n            callback()\n        #        print(orig, orig_orig, orig + orig_orig, stat[drive_by])\n        if drive_by == 'R2':\n            return 1 - stat['R2']\n        elif drive_by.startswith('Chi2'):\n            return stat[drive_by]\n    orig1 = scipy.optimize.fmin(targetfunc, np.array([extent, extent]),\n                                args=(\n                                    data, mask, orig_initial - extent, callback),\n                                maxiter=maxiter, disp=False)\n    return np.array(orig_initial) - extent + orig1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef maskname(self) -> Optional[str]:\n        mask = self._data['geometry']['mask']\n        if os.path.abspath(mask):\n            mask = os.path.split(mask)[-1]\n        return mask", "response": "Name of the mask matrix file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fit(self, fitfunction, parinit, unfittableparameters=(), *args, **kwargs):\n        kwargs['otherparameters'] = unfittableparameters\n        fitter = Fitter(fitfunction, parinit, self.q, self.Intensity, self.qError, self.Error, *args, **kwargs)\n        fixedvalues = [[None, p][isinstance(p, FixedParameter)] for p in parinit]\n        fitter.fixparameters(fixedvalues)\n        fitter.fit()\n        pars = fitter.parameters()\n        uncs = fitter.uncertainties()\n        stats = fitter.stats()\n        results = [ErrorValue(p, u) for p, u in zip(pars, uncs)] + [stats, type(self)(self.q, stats['func_value'])]\n        return results", "response": "Perform a nonlinear least - squares fit using sastool. misc. fitter. Fitter. fit"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef momentum(self, exponent=1, errorrequested=True):\n        y = self.Intensity * self.q ** exponent\n        m = np.trapz(y, self.q)\n        if errorrequested:\n            err = self.Error * self.q ** exponent\n            dm = errtrapz(self.q, err)\n            return ErrorValue(m, dm)\n        else:\n            return m", "response": "Calculate the momentum of the object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef scalefactor(self, other, qmin=None, qmax=None, Npoints=None):\n        if qmin is None:\n            qmin = max(self.q.min(), other.q.min())\n        if qmax is None:\n            xmax = min(self.q.max(), other.q.max())\n        data1 = self.trim(qmin, qmax)\n        data2 = other.trim(qmin, qmax)\n        if Npoints is None:\n            Npoints = min(len(data1), len(data2))\n        commonx = np.linspace(\n                max(data1.q.min(), data2.q.min()), min(data2.q.max(), data1.q.max()), Npoints)\n        data1 = data1.interpolate(commonx)\n        data2 = data2.interpolate(commonx)\n        return nonlinear_odr(data1.Intensity, data2.Intensity, data1.Error, data2.Error, lambda x, a: a * x, [1])[0]", "response": "Calculates a scaling factor by which this curve is to be multiplied to best fit the other one."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _substitute_fixed_parameters_covar(self, covar):\n        covar_resolved = np.empty((len(self._fixed_parameters), len(self._fixed_parameters)))\n        indices_of_fixed_parameters = [i for i in range(len(self.parameters())) if\n                                       self._fixed_parameters[i] is not None]\n        indices_of_free_parameters = [i for i in range(len(self.parameters())) if self._fixed_parameters[i] is None]\n        for i in range(covar_resolved.shape[0]):\n            if i in indices_of_fixed_parameters:\n                # the i-eth argument was fixed. This means that the row and column corresponding to this argument\n                # must be None\n                covar_resolved[i, :] = 0\n                continue\n            for j in range(covar_resolved.shape[1]):\n                if j in indices_of_fixed_parameters:\n                    covar_resolved[:, j] = 0\n                    continue\n                covar_resolved[i, j] = covar[indices_of_free_parameters.index(i), indices_of_free_parameters.index(j)]\n        return covar_resolved", "response": "Insert fixed parameters in a covariance matrix"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef loadmask(self, filename: str) -> np.ndarray:\n        mask = scipy.io.loadmat(self.find_file(filename, what='mask'))\n        maskkey = [k for k in mask.keys() if not (k.startswith('_') or k.endswith('_'))][0]\n        return mask[maskkey].astype(np.bool)", "response": "Load a mask file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads a radial scattering curve", "response": "def loadcurve(self, fsn: int) -> classes2.Curve:\n        \"\"\"Load a radial scattering curve\"\"\"\n        return classes2.Curve.new_from_file(self.find_file(self._exposureclass + '_%05d.txt' % fsn))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef readcbf(name, load_header=False, load_data=True, for_nexus=False):\n    with open(name, 'rb') as f:\n        cbfbin = f.read()\n    datastart = cbfbin.find(b'\\x0c\\x1a\\x04\\xd5') + 4\n    hed = [x.strip() for x in cbfbin[:datastart].split(b'\\n')]\n    header = {}\n    readingmode = None\n    for i in range(len(hed)):\n        if not hed[i]:\n            # skip empty header lines\n            continue\n        elif hed[i] == b';':\n            continue\n        elif hed[i].startswith(b'_array_data.header_convention'):\n            header['CBF_header_convention'] = str(hed[i][\n                len(b'_array_data.header_convention'):].strip().replace(b'\"', b''), encoding='utf-8')\n        elif hed[i].startswith(b'_array_data.header_contents'):\n            readingmode = 'PilatusHeader'\n        elif hed[i].startswith(b'_array_data.data'):\n            readingmode = 'CIFHeader'\n        elif readingmode == 'PilatusHeader':\n            if not hed[i].startswith(b'#'):\n                continue\n            line = hed[i].strip()[1:].strip()\n            try:\n                # try to interpret the line as the date.\n                header['CBF_Date'] = dateutil.parser.parse(line)\n                header['Date'] = header['CBF_Date']\n                continue\n            except (ValueError, TypeError):\n                # eat exception: if we cannot parse this line as a date, try\n                # another format.\n                pass\n            treated = False\n            for sep in (b':', b'='):\n                if treated:\n                    continue\n                if line.count(sep) == 1:\n                    name, value = tuple(x.strip() for x in line.split(sep, 1))\n                    try:\n                        m = re.match(\n                            b'^(?P<number>-?(\\d+(.\\d+)?(e-?\\d+)?))\\s+(?P<unit>m|s|counts|eV)$', value).groupdict()\n                        value = float(m['number'])\n                        m['unit'] = str(m['unit'], encoding='utf-8')\n                    except AttributeError:\n                        # the regex did not match the string, thus re.match()\n                        # returned None.\n                        pass\n                    header[str(name, 'utf-8')] = value\n                    treated = True\n            if treated:\n                continue\n            if line.startswith(b'Pixel_size'):\n                header['XPixel'], header['YPixel'] = tuple(\n                    [float(a.strip().split(b' ')[0]) * 1000 for a in line[len(b'Pixel_size'):].split(b'x')])\n            else:\n                try:\n                    m = re.match(\n                        b'^(?P<label>[a-zA-Z0-9,_\\.\\-!\\?\\ ]*?)\\s+(?P<number>-?(\\d+(.\\d+)?(e-?\\d+)?))\\s+(?P<unit>m|s|counts|eV)$', line).groupdict()\n                except AttributeError:\n                    pass\n                else:\n                    m['label'] = str(m['label'], 'utf-8')\n                    m['unit'] = str(m['unit'], encoding='utf-8')\n                    if m['unit'] == b'counts':\n                        header[m['label']] = int(m['number'])\n                    else:\n                        header[m['label']] = float(m['number'])\n                    if 'sensor' in m['label'] and 'thickness' in m['label']:\n                        header[m['label']] *= 1e6\n        elif readingmode == 'CIFHeader':\n            line = hed[i]\n            for sep in (b':', b'='):\n                if line.count(sep) == 1:\n                    label, content = tuple(x.strip()\n                                           for x in line.split(sep, 1))\n                    if b'\"' in content:\n                        content = content.replace(b'\"', b'')\n                    try:\n                        content = int(content)\n                    except ValueError:\n                        content = str(content, encoding='utf-8')\n                    header['CBF_' + str(label, encoding='utf-8')] = content\n\n        else:\n            pass\n    ret = []\n    if load_data:\n        if header['CBF_X-Binary-Element-Type'] != 'signed 32-bit integer':\n            raise NotImplementedError(\n                'element type is not \"signed 32-bit integer\" in CBF, but %s.' % header['CBF_X-Binary-Element-Type'])\n        if header['CBF_conversions'] != 'x-CBF_BYTE_OFFSET':\n            raise NotImplementedError(\n                'compression is not \"x-CBF_BYTE_OFFSET\" in CBF!')\n        dim1 = header['CBF_X-Binary-Size-Fastest-Dimension']\n        dim2 = header['CBF_X-Binary-Size-Second-Dimension']\n        nbytes = header['CBF_X-Binary-Size']\n        cbfdata = cbfdecompress(\n            bytearray(cbfbin[datastart:datastart + nbytes]), dim1, dim2, for_nexus)\n        ret.append(cbfdata)\n    if load_header:\n        ret.append(header)\n    return tuple(ret)", "response": "Reads a cbf file from a Dectris PILATUS\n    detector."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading a Bessy Data Format v1 file.", "response": "def readbdfv1(filename, bdfext='.bdf', bhfext='.bhf'):\n    \"\"\"Read bdf file (Bessy Data Format v1)\n\n    Input\n    -----\n    filename: string\n        the name of the file\n\n    Output\n    ------\n    the BDF structure in a dict\n\n    Notes\n    -----\n    This is an adaptation of the bdf_read.m macro of Sylvio Haas.\n    \"\"\"\n    return header.readbhfv1(filename, True, bdfext, bhfext)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads corrected intensity and error matrices from a file.", "response": "def readint2dnorm(filename):\n    \"\"\"Read corrected intensity and error matrices (Matlab mat or numpy npz\n    format for Beamline B1 (HASYLAB/DORISIII))\n\n    Input\n    -----\n    filename: string\n        the name of the file\n\n    Outputs\n    -------\n    two ``np.ndarray``-s, the Intensity and the Error matrices\n\n    File formats supported:\n    -----------------------\n\n    ``.mat``\n        Matlab MAT file, with (at least) two fields: Intensity and Error\n\n    ``.npz``\n        Numpy zip file, with (at least) two fields: Intensity and Error\n\n    other\n        the file is opened with ``np.loadtxt``. The error matrix is tried\n        to be loaded from the file ``<name>_error<ext>`` where the intensity was\n        loaded from file ``<name><ext>``. I.e. if ``somedir/matrix.dat`` is given,\n        the existence of ``somedir/matrix_error.dat`` is checked. If not found,\n        None is returned for the error matrix.\n\n    Notes\n    -----\n    The non-existence of the Intensity matrix results in an exception. If the\n    Error matrix does not exist, None is returned for it.\n    \"\"\"\n    # the core of read2dintfile\n    if filename.upper().endswith('.MAT'):  # Matlab\n        m = scipy.io.loadmat(filename)\n    elif filename.upper().endswith('.NPZ'):  # Numpy\n        m = np.load(filename)\n    else:  # loadtxt\n        m = {'Intensity': np.loadtxt(filename)}\n        name, ext = os.path.splitext(filename)\n        errorfilename = name + '_error' + ext\n        if os.path.exists(errorfilename):\n            m['Error'] = np.loadtxt(errorfilename)\n    Intensity = m['Intensity']\n    try:\n        Error = m['Error']\n        return Intensity, Error\n    except:\n        return Intensity, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves the intensity and error matrices to a file.", "response": "def writeint2dnorm(filename, Intensity, Error=None):\n    \"\"\"Save the intensity and error matrices to a file\n\n    Inputs\n    ------\n    filename: string\n        the name of the file\n    Intensity: np.ndarray\n        the intensity matrix\n    Error: np.ndarray, optional\n        the error matrix (can be ``None``, if no error matrix is to be saved)\n\n    Output\n    ------\n    None\n    \"\"\"\n    whattosave = {'Intensity': Intensity}\n    if Error is not None:\n        whattosave['Error'] = Error\n    if filename.upper().endswith('.NPZ'):\n        np.savez(filename, **whattosave)\n    elif filename.upper().endswith('.MAT'):\n        scipy.io.savemat(filename, whattosave)\n    else:  # text file\n        np.savetxt(filename, Intensity)\n        if Error is not None:\n            name, ext = os.path.splitext(filename)\n            np.savetxt(name + '_error' + ext, Error)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntry to load a maskfile from a matlab R matrix file.", "response": "def readmask(filename, fieldname=None):\n    \"\"\"Try to load a maskfile from a matlab(R) matrix file\n\n    Inputs\n    ------\n    filename: string\n        the input file name\n    fieldname: string, optional\n        field in the mat file. None to autodetect.\n\n    Outputs\n    -------\n    the mask in a numpy array of type np.uint8\n    \"\"\"\n    f = scipy.io.loadmat(filename)\n    if fieldname is not None:\n        return f[fieldname].astype(np.uint8)\n    else:\n        validkeys = [\n            k for k in list(f.keys()) if not (k.startswith('_') and k.endswith('_'))]\n        if len(validkeys) < 1:\n            raise ValueError('mask file contains no masks!')\n        if len(validkeys) > 1:\n            raise ValueError('mask file contains multiple masks!')\n        return f[validkeys[0]].astype(np.uint8)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readedf(filename):\n    edf = header.readehf(filename)\n    f = open(filename, 'rb')\n    f.read(edf['EDF_HeaderSize'])  # skip header.\n    if edf['DataType'] == 'FloatValue':\n        dtype = np.float32\n    else:\n        raise NotImplementedError(\n            'Not supported data type: %s' % edf['DataType'])\n    edf['data'] = np.fromstring(f.read(edf['EDF_BinarySize']), dtype).reshape(\n        edf['Dim_1'], edf['Dim_2'])\n    return edf", "response": "Read an ESRF file and return a dict with the data as a numpy array."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef readbdfv2(filename, bdfext='.bdf', bhfext='.bhf'):\n    datas = header.readbhfv2(filename, True, bdfext, bhfext)\n    return datas", "response": "Read a version 2 Bessy Data File"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads a two - dimensional scattering pattern from a MarResearch. image file.", "response": "def readmar(filename):\n    \"\"\"Read a two-dimensional scattering pattern from a MarResearch .image file.\n    \"\"\"\n    hed = header.readmarheader(filename)\n    with open(filename, 'rb') as f:\n        h = f.read(hed['recordlength'])\n        data = np.fromstring(\n            f.read(2 * hed['Xsize'] * hed['Ysize']), '<u2').astype(np.float64)\n        if hed['highintensitypixels'] > 0:\n            raise NotImplementedError(\n                'Intensities over 65535 are not yet supported!')\n        data = data.reshape(hed['Xsize'], hed['Ysize'])\n    return data, hed"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite a version 2 BDF file with the given data.", "response": "def writebdfv2(filename, bdf, bdfext='.bdf', bhfext='.bhf'):\n    \"\"\"Write a version 2 Bessy Data File\n\n    Inputs\n    ------\n    filename: string\n        the name of the output file. One can give the complete header or\n        datafile name or just the base name without the extensions.\n    bdf: dict\n        the BDF structure (in the same format as loaded by ``readbdfv2()``\n    bdfext: string, optional\n        the extension of the data file\n    bhfext: string, optional\n        the extension of the header file\n\n    Output\n    ------\n    None\n\n    Notes\n    -----\n    BDFv2 header and scattering data are stored separately in the header and\n    the data files. Given the file name both are saved.\n    \"\"\"\n    if filename.endswith(bdfext):\n        basename = filename[:-len(bdfext)]\n    elif filename.endswith(bhfext):\n        basename = filename[:-len(bhfext)]\n    else:\n        basename = filename\n    header.writebhfv2(basename + '.bhf', bdf)\n    f = open(basename + '.bdf', 'wb')\n    keys = ['RAWDATA', 'RAWERROR', 'CORRDATA', 'CORRERROR', 'NANDATA']\n    keys.extend(\n        [x for x in list(bdf.keys()) if isinstance(bdf[x], np.ndarray) and x not in keys])\n    for k in keys:\n        if k not in list(bdf.keys()):\n            continue\n        f.write('#%s[%d:%d]\\n' % (k, bdf['xdim'], bdf['ydim']))\n        f.write(np.rot90(bdf[k], 3).astype('float32').tostring(order='F'))\n    f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rebinmask(mask, binx, biny, enlarge=False):\n    if not enlarge and ((mask.shape[0] % binx) or (mask.shape[1] % biny)):\n        raise ValueError(\n            'The number of pixels of the mask matrix should be divisible by the binning in each direction!')\n    if enlarge:\n        return mask.repeat(binx, axis=0).repeat(biny, axis=1)\n    else:\n        return mask[::binx, ::biny]", "response": "Re - bin a mask matrix."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fill_padding(padded_string):\n    # type: (bytes) -> bytes\n    \"\"\"\n    Fill up missing padding in a string.\n\n    This function makes sure that the string has length which is multiplication of 4,\n    and if not, fills the missing places with dots.\n\n    :param str padded_string: string to be decoded that might miss padding dots.\n    :return: properly padded string\n    :rtype: str\n    \"\"\"\n    length = len(padded_string)\n    reminder = len(padded_string) % 4\n    if reminder:\n        return padded_string.ljust(length + 4 - reminder, b'.')\n    return padded_string", "response": "Fills up missing padding in a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndecoding a querystringsafe base64 string or a regular base64 string.", "response": "def decode(encoded):\n    # type: (bytes) -> bytes\n    \"\"\"\n    Decode the result of querystringsafe_base64_encode or a regular base64.\n\n    .. note ::\n        As a regular base64 string does not contain dots, replacing dots with\n        equal signs does basically noting to it. Also,\n        base64.urlsafe_b64decode allows to decode both safe and unsafe base64.\n        Therefore this function may also be used to decode the regular base64.\n\n    :param (str, unicode) encoded: querystringsafe_base64 string or unicode\n    :rtype: str, bytes\n    :return: decoded string\n    \"\"\"\n    padded_string = fill_padding(encoded)\n    return urlsafe_b64decode(padded_string.replace(b'.', b'='))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef normalize_listargument(arg):\n    if isinstance(arg, np.ndarray):\n        return arg.flatten()\n    if isinstance(arg, str):\n        return [arg]\n    if isinstance(arg, list) or isinstance(arg, tuple) or isinstance(arg, dict) or isinstance(arg, set):\n        return list(arg)\n    return [arg]", "response": "Check if arg is iterable and if not make a list of it. Numpy arrays are flattened and\n        converted to lists."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntries to auto - detect the numeric type of the value.", "response": "def parse_number(val, use_dateutilparser=False):\n    \"\"\"Try to auto-detect the numeric type of the value. First a conversion to\n    int is tried. If this fails float is tried, and if that fails too, unicode()\n    is executed. If this also fails, a ValueError is raised.\n    \"\"\"\n    if use_dateutilparser:\n        funcs = [int, float, parse_list_from_string,\n                 dateutil.parser.parse, str]\n    else:\n        funcs = [int, float, parse_list_from_string, str]\n    if (val.strip().startswith(\"'\") and val.strip().endswith(\"'\")) or (val.strip().startswith('\"') and val.strip().endswith('\"')):\n        return val[1:-1]\n    for f in funcs:\n        try:\n            return f(val)\n        # eat exception\n        except (ValueError, UnicodeEncodeError, UnicodeDecodeError) as ve:\n            pass\n    raise ValueError('Cannot parse number:', val)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef flatten_hierarchical_dict(original_dict, separator='.', max_recursion_depth=None):\n    if max_recursion_depth is not None and max_recursion_depth <= 0:\n        # we reached the maximum recursion depth, refuse to go further\n        return original_dict\n    if max_recursion_depth is None:\n        next_recursion_depth = None\n    else:\n        next_recursion_depth = max_recursion_depth - 1\n    dict1 = {}\n    for k in original_dict:\n        if not isinstance(original_dict[k], dict):\n            dict1[k] = original_dict[k]\n        else:\n            dict_recursed = flatten_hierarchical_dict(\n                original_dict[k], separator, next_recursion_depth)\n            dict1.update(\n                dict([(k + separator + x, dict_recursed[x]) for x in dict_recursed]))\n    return dict1", "response": "Flatten a dictionary of hierarchical items."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a random string of Nchars characters. Characters are sampled from randstrbase.", "response": "def random_str(Nchars=6, randstrbase='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'):\n    \"\"\"Return a random string of <Nchars> characters. Characters are sampled\n    uniformly from <randstrbase>.\n    \"\"\"\n    return ''.join([randstrbase[random.randint(0, len(randstrbase) - 1)] for i in range(Nchars)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef listB1(fsns, xlsname, dirs, whattolist = None, headerformat = 'org_%05d.header'):\n    if whattolist is None:\n        whattolist = [('FSN', 'FSN'), ('Time', 'MeasTime'), ('Energy', 'Energy'),\n                    ('Distance', 'Dist'), ('Position', 'PosSample'),\n                    ('Transmission', 'Transm'), ('Temperature', 'Temperature'),\n                    ('Title', 'Title'), ('Date', ('Day', 'Month', 'Year', 'Hour', 'Minutes'), '%02d.%02d.%04d %02d:%02d')]\n    wb = xlwt.Workbook(encoding = 'utf8')\n    ws = wb.add_sheet('Measurements')\n    for i in range(len(whattolist)):\n        ws.write(0, i, whattolist[i][0])\n    i = 1\n    for fsn in fsns:\n        try:\n            hed = readB1header(findfileindirs(headerformat % fsn, dirs))\n        except IOError:\n            continue\n        # for each param structure create a line in the table\n        for j in range(len(whattolist)):\n            # for each parameter to be listed, create a column\n            if np.isscalar(whattolist[j][1]):\n                # if the parameter is a scalar, make it a list\n                fields = tuple([whattolist[j][1]])\n            else:\n                fields = whattolist[j][1]\n            if len(whattolist[j]) == 2:\n                if len(fields) >= 2:\n                    strtowrite = ''.join([str(hed[f]) for f in fields])\n                else:\n                    strtowrite = hed[fields[0]]\n            elif len(whattolist[j]) >= 3:\n                strtowrite = whattolist[j][2] % tuple([hed[f] for f in fields])\n            else:\n                assert False\n            ws.write(i, j, strtowrite)\n        i += 1\n    wb.save(xlsname)", "response": "This function lists the contents of a single file in a single cell."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fit_shullroess(q, Intensity, Error, R0=None, r=None):\n    q = np.array(q)\n    Intensity = np.array(Intensity)\n    Error = np.array(Error)\n    if R0 is None:\n        r0s = np.linspace(1, 2 * np.pi / q.min(), 1000)\n        def naive_fit_chi2(q, Intensity, r0):\n            p = np.polyfit(np.log(q ** 2 + 3 / r0 ** 2), np.log(Intensity), 1)\n            return ((np.polyval(p, q) - Intensity) ** 2).sum() / (len(q) - 3)\n        chi2 = np.array([naive_fit_chi2(q, Intensity, r0) for r0 in r0s.tolist()])\n        R0 = r0s[chi2 == chi2.min()][0]\n    def naive_fit(q, Intensity, r0):\n        p = np.polyfit(np.log(q ** 2 + 3 / r0 ** 2), np.log(Intensity), 1)\n        return np.exp(p[1]), -2 * p[0] - 4\n    K, n = naive_fit(q, Intensity, R0)\n    def SR_function(q, A, r0, n):\n        return A * (q ** 2 + 3 / r0 ** 2) ** (-(n + 4.) * 0.5)\n    p, dp, statdict = easylsq.nlsq_fit(q, Intensity, Error, SR_function, (K, R0, n))\n    n = ErrorValue(p[2], dp[2])\n    r0 = ErrorValue(p[1], dp[1])\n    A = ErrorValue(p[0], dp[0])\n    if r is None:\n        r = np.linspace(np.pi / q.max(), np.pi / q.min(), 1000)\n    return A, r0, n, r, maxwellian(r, r0, n), statdict", "response": "This function is used to fit a single object in a set of objects."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef maxwellian(r, r0, n):\n    r0 = ErrorValue(r0)\n    n = ErrorValue(n)\n\n    expterm = np.exp(-r ** 2 / r0.val ** 2)\n    dmaxdr0 = -2 * r ** n.val * r0.val ** (-n.val - 4) * ((n.val + 1) * r0.val ** 2 - 2 * r ** 2) * expterm / gamma((n.val + 1) * 0.5)\n    dmaxdn = -r ** n.val * r0.val ** (-n.val - 1) * expterm * (2 * np.log(r0.val) - 2 * np.log(r) + psi((n.val + 1) * 0.5)) / gamma((n.val + 1) * 0.5)\n\n    maxwellian = 2 * r ** n.val * r0.val ** (-n.val - 1) * expterm / gamma((n.val + 1) * 0.5)\n    dmaxwellian = (dmaxdn ** 2 * n.err ** 2 + dmaxdr0 ** 2 * r0.err ** 2) ** 0.5\n    return ErrorValue(maxwellian, dmaxwellian)", "response": "Maxwellian - like distribution of spherical particles in a single species."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef findfileindirs(filename, dirs=None, use_pythonpath=True, use_searchpath=True, notfound_is_fatal=True, notfound_val=None):\n    if os.path.isabs(filename):\n        if os.path.exists(filename):\n            return filename\n        elif notfound_is_fatal:\n            raise IOError('File ' + filename + ' not found.')\n        else:\n            return notfound_val\n    if dirs is None:\n        dirs = []\n    dirs = normalize_listargument(dirs)\n    if not dirs:  # dirs is empty\n        dirs = ['.']\n    if use_pythonpath:\n        dirs.extend(sys.path)\n    if use_searchpath:\n        dirs.extend(sastool_search_path)\n    # expand ~ and ~user constructs\n    dirs = [os.path.expanduser(d) for d in dirs]\n    logger.debug('Searching for file %s in several folders: %s' % (filename, ', '.join(dirs)))\n    for d in dirs:\n        if os.path.exists(os.path.join(d, filename)):\n            logger.debug('Found file %s in folder %s.' % (filename, d))\n            return os.path.join(d, filename)\n    logger.debug('Not found file %s in any folders.' % filename)\n    if notfound_is_fatal:\n        raise IOError('File %s not found in any of the directories.' % filename)\n    else:\n        return notfound_val", "response": "Find file in multiple directories."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the two - theta matrix for a scattering matrix.", "response": "def twotheta(matrix, bcx, bcy, pixsizeperdist):\n    \"\"\"Calculate the two-theta matrix for a scattering matrix\n\n    Inputs:\n        matrix: only the shape of it is needed\n        bcx, bcy: beam position (counting from 0; x is row, y is column index)\n        pixsizeperdist: the pixel size divided by the sample-to-detector\n            distance\n\n    Outputs:\n        the two theta matrix, same shape as 'matrix'.\n    \"\"\"\n    col, row = np.meshgrid(list(range(matrix.shape[1])), list(range(matrix.shape[0])))\n    return np.arctan(np.sqrt((row - bcx) ** 2 + (col - bcy) ** 2) * pixsizeperdist)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef angledependentabsorption(twotheta, transmission):\n    cor = np.ones(twotheta.shape)\n    if transmission == 1:\n        return cor\n    mud = -np.log(transmission)\n\n    cor[twotheta > 0] = transmission * mud * (1 - 1 / np.cos(twotheta[twotheta > 0])) / (np.exp(-mud / np.cos(twotheta[twotheta > 0])) - np.exp(-mud))\n    return cor", "response": "Correction for angle - dependent absorption of the sample\nTaxonomy"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_file(self, filename: str, strip_path: bool = True, what='exposure') -> str:\n        if what == 'exposure':\n            path = self._path\n        elif what == 'header':\n            path = self._headerpath\n        elif what == 'mask':\n            path = self._maskpath\n        else:\n            path = self._path\n        tried = []\n        if strip_path:\n            filename = os.path.split(filename)[-1]\n        for d in path:\n            if os.path.exists(os.path.join(d, filename)):\n                tried.append(os.path.join(d, filename))\n                return os.path.join(d, filename)\n        raise FileNotFoundError('Not found: {}. Tried: {}'.format(filename, ', '.join(tried)))", "response": "Find the file in the path"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches a file or directory relative to the base path", "response": "def get_subpath(self, subpath: str):\n        \"\"\"Search a file or directory relative to the base path\"\"\"\n        for d in self._path:\n            if os.path.exists(os.path.join(d, subpath)):\n                return os.path.join(d, subpath)\n        raise FileNotFoundError"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading an exposure from a file.", "response": "def new_from_file(self, filename: str, header_data: Optional[Header] = None,\n                      mask_data: Optional[np.ndarray] = None):\n        \"\"\"Load an exposure from a file.\"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the sum of pixels not counting the masked ones.", "response": "def sum(self, only_valid=True) -> ErrorValue:\n        \"\"\"Calculate the sum of pixels, not counting the masked ones if only_valid is True.\"\"\"\n        if not only_valid:\n            mask = 1\n        else:\n            mask = self.mask\n        return ErrorValue((self.intensity * mask).sum(),\n                          ((self.error * mask) ** 2).sum() ** 0.5)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mean(self, only_valid=True) -> ErrorValue:\n        if not only_valid:\n            intensity = self.intensity\n            error = self.error\n        else:\n            intensity = self.intensity[self.mask]\n            error = self.error[self.mask]\n        return ErrorValue(intensity.mean(),\n                          (error ** 2).mean() ** 0.5)", "response": "Calculate the mean of the pixels not counting the masked ones."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the two - theta array", "response": "def twotheta(self) -> ErrorValue:\n        \"\"\"Calculate the two-theta array\"\"\"\n        row, column = np.ogrid[0:self.shape[0], 0:self.shape[1]]\n        rho = (((self.header.beamcentery - row) * self.header.pixelsizey) ** 2 +\n               ((self.header.beamcenterx - column) * self.header.pixelsizex) ** 2) ** 0.5\n        assert isinstance(self.header.pixelsizex, ErrorValue)\n        assert isinstance(self.header.pixelsizey, ErrorValue)\n        assert isinstance(rho, ErrorValue)\n        return (rho / self.header.distance).arctan()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pixel_to_q(self, row: float, column: float):\n        qrow = 4 * np.pi * np.sin(\n            0.5 * np.arctan(\n                (row - float(self.header.beamcentery)) *\n                float(self.header.pixelsizey) /\n                float(self.header.distance))) / float(self.header.wavelength)\n        qcol = 4 * np.pi * np.sin(0.5 * np.arctan(\n                (column - float(self.header.beamcenterx)) *\n                float(self.header.pixelsizex) /\n                float(self.header.distance))) / float(self.header.wavelength)\n        return qrow, qcol", "response": "Return the q coordinates of a given pixel."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nplotting the image of the current state of the object.", "response": "def imshow(self, *args, show_crosshair=True, show_mask=True,\n               show_qscale=True, axes=None, invalid_color='black',\n               mask_opacity=0.8, show_colorbar=True, **kwargs):\n        \"\"\"Plot the matrix (imshow)\n\n        Keyword arguments [and their default values]:\n\n        show_crosshair [True]: if a cross-hair marking the beam position is\n            to be plotted.\n        show_mask [True]: if the mask is to be plotted.\n        show_qscale [True]: if the horizontal and vertical axes are to be\n            scaled into q\n        axes [None]: the axes into which the image should be plotted. If\n            None, defaults to the currently active axes (returned by plt.gca())\n        invalid_color ['black']: the color for invalid (NaN or infinite) pixels\n        mask_opacity [0.8]: the opacity of the overlaid mask (1 is fully\n            opaque, 0 is fully transparent)\n        show_colorbar [True]: if a colorbar is to be added. Can be a boolean\n            value (True or False) or an instance of matplotlib.axes.Axes, into\n            which the color bar should be drawn.\n\n        All other keywords are forwarded to plt.imshow() or\n            matplotlib.Axes.imshow()\n\n        Returns: the image instance returned by imshow()\n        \"\"\"\n        if 'aspect' not in kwargs:\n            kwargs['aspect'] = 'equal'\n        if 'interpolation' not in kwargs:\n            kwargs['interpolation'] = 'nearest'\n        if 'origin' not in kwargs:\n            kwargs['origin'] = 'upper'\n        if show_qscale:\n            ymin, xmin = self.pixel_to_q(0, 0)\n            ymax, xmax = self.pixel_to_q(*self.shape)\n            if kwargs['origin'].upper() == 'UPPER':\n                kwargs['extent'] = [xmin, xmax, -ymax, -ymin]\n            else:\n                kwargs['extent'] = [xmin, xmax, ymin, ymax]\n            bcx = 0\n            bcy = 0\n        else:\n            bcx = self.header.beamcenterx\n            bcy = self.header.beamcentery\n            xmin = 0\n            xmax = self.shape[1]\n            ymin = 0\n            ymax = self.shape[0]\n            if kwargs['origin'].upper() == 'UPPER':\n                kwargs['extent'] = [0, self.shape[1], self.shape[0], 0]\n            else:\n                kwargs['extent'] = [0, self.shape[1], 0, self.shape[0]]\n        if axes is None:\n            axes = plt.gca()\n        ret = axes.imshow(self.intensity, **kwargs)\n        if show_mask:\n            # workaround: because of the colour-scaling we do here, full one and\n            #   full zero masks look the SAME, i.e. all the image is shaded.\n            #   Thus if we have a fully unmasked matrix, skip this section.\n            #   This also conserves memory.\n            if (self.mask == 0).sum():  # there are some masked pixels\n                # we construct another representation of the mask, where the masked pixels are 1.0, and the\n                # unmasked ones will be np.nan. They will thus be not rendered.\n                mf = np.ones(self.mask.shape, np.float)\n                mf[self.mask != 0] = np.nan\n                kwargs['cmap'] = matplotlib.cm.gray_r\n                kwargs['alpha'] = mask_opacity\n                kwargs['norm'] = matplotlib.colors.Normalize()\n                axes.imshow(mf, **kwargs)\n        if show_crosshair:\n            ax = axes.axis()  # save zoom state\n            axes.plot([xmin, xmax], [bcy] * 2, 'w-')\n            axes.plot([bcx] * 2, [ymin, ymax], 'w-')\n            axes.axis(ax)  # restore zoom state\n        axes.set_facecolor(invalid_color)\n        if show_colorbar:\n            if isinstance(show_colorbar, matplotlib.axes.Axes):\n                axes.figure.colorbar(\n                        ret, cax=show_colorbar)\n            else:\n                # try to find a suitable colorbar axes: check if the plot target axes already\n                # contains some images, then check if their colorbars exist as\n                # axes.\n                cax = [i.colorbar[1]\n                       for i in axes.images if i.colorbar is not None]\n                cax = [c for c in cax if c in c.figure.axes]\n                if cax:\n                    cax = cax[0]\n                else:\n                    cax = None\n                axes.figure.colorbar(ret, cax=cax, ax=axes)\n        axes.figure.canvas.draw()\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef radial_average(self, qrange=None, pixel=False, returnmask=False,\n                       errorpropagation=3, abscissa_errorpropagation=3,\n                       raw_result=False) -> Curve:\n        \"\"\"Do a radial averaging\n\n        Inputs:\n            qrange: the q-range. If None, auto-determine. If 'linear', auto-determine\n                with linear spacing (same as None). If 'log', auto-determine\n                with log10 spacing.\n            pixel: do a pixel-integration (instead of q)\n            returnmask: if the effective mask matrix is to be returned.\n            errorpropagation: the type of error propagation (3: highest of squared or\n                std-dev, 2: squared, 1: linear, 0: independent measurements of\n                the same quantity)\n            abscissa_errorpropagation: the type of the error propagation in the\n                abscissa (3: highest of squared or std-dev, 2: squared, 1: linear,\n                0: independent measurements of the same quantity)\n            raw_result: if True, do not pack the result in a SASCurve, return the\n                individual np.ndarrays.\n\n        Outputs:\n            the one-dimensional curve as an instance of SASCurve (if pixel is\n                False) or SASPixelCurve (if pixel is True), if raw_result was True.\n                otherwise the q (or pixel), dq (or dpixel), I, dI, area vectors\n            the mask matrix (if returnmask was True)\n        \"\"\"\n        retmask = None\n        if isinstance(qrange, str):\n            if qrange == 'linear':\n                qrange = None\n                autoqrange_linear = True\n            elif qrange == 'log':\n                qrange = None\n                autoqrange_linear = False\n            else:\n                raise ValueError(\n                        'Value given for qrange (''%s'') not understood.' % qrange)\n        else:\n            autoqrange_linear = True  # whatever\n        if pixel:\n            abscissa_kind = 3\n        else:\n            abscissa_kind = 0\n        res = radint_fullq_errorprop(self.intensity, self.error, self.header.wavelength.val,\n                                     self.header.wavelength.err, self.header.distance.val,\n                                     self.header.distance.err, self.header.pixelsizey.val,\n                                     self.header.pixelsizex.val, self.header.beamcentery.val,\n                                     self.header.beamcentery.err, self.header.beamcenterx.val,\n                                     self.header.beamcenterx.err, (self.mask == 0).astype(np.uint8),\n                                     qrange, returnmask=returnmask, errorpropagation=errorpropagation,\n                                     autoqrange_linear=autoqrange_linear, abscissa_kind=abscissa_kind,\n                                     abscissa_errorpropagation=abscissa_errorpropagation)\n        q, dq, I, E, area = res[:5]\n        if not raw_result:\n            c = Curve(q, I, E, dq)\n            if returnmask:\n                return c, res[5]\n            else:\n                return c\n        else:\n            if returnmask:\n                return q, dq, I, E, area, res[5]\n            else:\n                return q, dq, I, E, area", "response": "This function performs a radial averaging of the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mask_negative(self):\n        self.mask = np.logical_and(self.mask, ~(self.intensity < 0))", "response": "Extend the mask with the image elements where the intensity is negative."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextends the mask with the image elements where the intensity is NaN.", "response": "def mask_nan(self):\n        \"\"\"Extend the mask with the image elements where the intensity is NaN.\"\"\"\n        self.mask = np.logical_and(self.mask, ~(np.isnan(self.intensity)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextend the mask with the image elements where the intensity is NaN.", "response": "def mask_nonfinite(self):\n        \"\"\"Extend the mask with the image elements where the intensity is NaN.\"\"\"\n        self.mask = np.logical_and(self.mask, (np.isfinite(self.intensity)))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsample - to - detector distance", "response": "def distance(self) -> ErrorValue:\n        \"\"\"Sample-to-detector distance\"\"\"\n        if 'DistCalibrated' in self._data:\n            dist = self._data['DistCalibrated']\n        else:\n            dist = self._data[\"Dist\"]\n        if 'DistCalibratedError' in self._data:\n            disterr = self._data['DistCalibratedError']\n        elif 'DistError' in self._data:\n            disterr = self._data['DistError']\n        else:\n            disterr = 0.0\n        return ErrorValue(dist, disterr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndates of the experiment", "response": "def date(self) -> datetime.datetime:\n        \"\"\"Date of the experiment (start of exposure)\"\"\"\n        return self._data['Date'] - datetime.timedelta(0, float(self.exposuretime), 0)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the flux in photons.", "response": "def flux(self) -> ErrorValue:\n        \"\"\"X-ray flux in photons/sec.\"\"\"\n        try:\n            return ErrorValue(self._data['Flux'], self._data.setdefault('FluxError',0.0))\n        except KeyError:\n            return 1 / self.pixelsizex / self.pixelsizey / ErrorValue(self._data['NormFactor'],\n                                                                      self._data.setdefault('NormFactorError',0.0))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nonlinear_leastsquares(x: np.ndarray, y: np.ndarray, dy: np.ndarray, func: Callable, params_init: np.ndarray,\n                           verbose: bool = False, **kwargs):\n    \"\"\"Perform a non-linear least squares fit, return the results as\n    ErrorValue() instances.\n\n    Inputs:\n        x: one-dimensional numpy array of the independent variable\n        y: one-dimensional numpy array of the dependent variable\n        dy: absolute error (square root of the variance) of the dependent\n            variable. Either a one-dimensional numpy array or None. In the array\n            case, if any of its elements is NaN, the whole array is treated as\n            NaN (= no weighting)\n        func: a callable with the signature\n            func(x,par1,par2,par3,...)\n        params_init: list or tuple of the first estimates of the\n            parameters par1, par2, par3 etc. to be fitted\n        `verbose`: if various messages useful for debugging should be printed on\n            stdout.\n\n        other optional keyword arguments will be passed to leastsq().\n\n    Outputs: par1, par2, par3, ... , statdict\n        par1, par2, par3, ...: fitted values of par1, par2, par3 etc\n            as instances of ErrorValue.\n        statdict: dictionary of various statistical parameters:\n            'DoF': Degrees of freedom\n            'Chi2': Chi-squared\n            'Chi2_reduced': Reduced Chi-squared\n            'R2': Coefficient of determination\n            'num_func_eval': number of function evaluations during fit.\n            'func_value': the function evaluated in the best fitting parameters\n            'message': status message from leastsq()\n            'error_flag': integer status flag from leastsq() ('ier')\n            'Covariance': covariance matrix (variances in the diagonal)\n            'Correlation_coeffs': Pearson's correlation coefficients (usually\n                denoted by 'r') in a matrix. The diagonal is unity.\n\n    Notes:\n        for the actual fitting, nlsq_fit() is used, which in turn delegates the\n            job to scipy.optimize.leastsq().\n    \"\"\"\n    newfunc, newparinit = hide_fixedparams(func, params_init)\n    p, dp, statdict = nlsq_fit(x, y, dy, newfunc, newparinit, verbose, **kwargs)\n    p, statdict['Covariance'] = resubstitute_fixedparams(p, params_init, statdict['Covariance'])\n    dp, statdict['Correlation_coeffs'] = resubstitute_fixedparams(dp, [type(p_)(0) for p_ in params_init], statdict['Correlation_coeffs'])\n    def convert(p_, dp_):\n        if isinstance(p_, FixedParameter) or isinstance(dp_, FixedParameter):\n            return p_\n        else:\n            return ErrorValue(p_, dp_)\n    return tuple([convert(p_, dp_) for (p_, dp_) in zip(p, dp)] + [statdict])", "response": "This function is used to fit a nonlinear least squares problem."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms a non - linear orthogonal distance regression on the given set of elements.", "response": "def nonlinear_odr(x, y, dx, dy, func, params_init, **kwargs):\n    \"\"\"Perform a non-linear orthogonal distance regression, return the results as\n    ErrorValue() instances.\n\n    Inputs:\n        x: one-dimensional numpy array of the independent variable\n        y: one-dimensional numpy array of the dependent variable\n        dx: absolute error (square root of the variance) of the independent\n            variable. Either a one-dimensional numpy array or None. If None,\n            weighting is disabled. Non-finite (NaN or inf) elements signify\n            that the corresponding element in x is to be treated as fixed by\n            ODRPACK.\n        dy: absolute error (square root of the variance) of the dependent\n            variable. Either a one-dimensional numpy array or None. If None,\n            weighting is disabled.\n        func: a callable with the signature\n            func(x,par1,par2,par3,...)\n        params_init: list or tuple of the first estimates of the\n            parameters par1, par2, par3 etc. to be fitted\n\n        other optional keyword arguments will be passed to leastsq().\n\n    Outputs: par1, par2, par3, ... , statdict\n        par1, par2, par3, ...: fitted values of par1, par2, par3 etc\n            as instances of ErrorValue.\n        statdict: dictionary of various statistical parameters:\n            'DoF': Degrees of freedom\n            'Chi2': Chi-squared\n            'Chi2_reduced': Reduced Chi-squared\n            'num_func_eval': number of function evaluations during fit.\n            'func_value': the function evaluated in the best fitting parameters\n            'message': status message from leastsq()\n            'error_flag': integer status flag from leastsq() ('ier')\n            'Covariance': covariance matrix (variances in the diagonal)\n            'Correlation_coeffs': Pearson's correlation coefficients (usually\n                denoted by 'r') in a matrix. The diagonal is unity.\n\n    Notes:\n        for the actual fitting, the module scipy.odr is used.\n    \"\"\"\n    odrmodel=odr.Model(lambda pars, x: func(x,*pars))\n    if dx is not None:\n        # treat non-finite values as fixed\n        xfixed=np.isfinite(dx)\n    else:\n        xfixed=None\n\n    odrdata=odr.RealData(x, y, sx=dx,sy=dy, fix=xfixed)\n    odrodr=odr.ODR(odrdata,odrmodel,params_init,ifixb=[not(isinstance(p,FixedParameter)) for p in params_init],\n                   **kwargs)\n    odroutput=odrodr.run()\n    statdict=odroutput.__dict__.copy()\n    statdict['Covariance']=odroutput.cov_beta\n    statdict['Correlation_coeffs']=odroutput.cov_beta/np.outer(odroutput.sd_beta,odroutput.sd_beta)\n    statdict['DoF']=len(x)-len(odroutput.beta)\n    statdict['Chi2_reduced']=statdict['res_var']\n    statdict['func_value']=statdict['y']\n    statdict['Chi2']=statdict['sum_square']\n    def convert(p_, dp_, pi):\n        if isinstance(pi, FixedParameter):\n            return FixedParameter(p_)\n        else:\n            return ErrorValue(p_, dp_)\n    return tuple([convert(p_, dp_, pi) for (p_, dp_, pi) in zip(odroutput.beta, odroutput.sd_beta, params_init)] + [statdict])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef simultaneous_nonlinear_leastsquares(xs, ys, dys, func, params_inits, verbose=False, **kwargs):\n    p, dp, statdict = simultaneous_nlsq_fit(xs, ys, dys, func, params_inits,\n                                            verbose, **kwargs)\n    params = [[ErrorValue(p_, dp_) for (p_, dp_) in zip(pcurrent, dpcurrent)]\n              for (pcurrent, dpcurrent) in zip(p, dp)]\n    return tuple(params + [statdict])", "response": "A function that fit a set of parameters and return the fitted parameters as instances of ErrorValue."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform a non - linear least squares fit on the base of the unity tree.", "response": "def nlsq_fit(x, y, dy, func, params_init, verbose=False, **kwargs):\n    \"\"\"Perform a non-linear least squares fit\n\n    Inputs:\n        x: one-dimensional numpy array of the independent variable\n        y: one-dimensional numpy array of the dependent variable\n        dy: absolute error (square root of the variance) of the dependent\n            variable. Either a one-dimensional numpy array or None. In the array\n            case, if any of its elements is NaN, the whole array is treated as\n            NaN (= no weighting)\n        func: a callable with the signature\n            func(x,par1,par2,par3,...)\n        params_init: list or tuple of the first estimates of the\n            parameters par1, par2, par3 etc. to be fitted\n        `verbose`: if various messages useful for debugging should be printed on\n            stdout.\n\n        other optional keyword arguments will be passed to leastsq().\n\n    Outputs: p, dp, statdict where\n        p: list of fitted values of par1, par2 etc.\n        dp: list of estimated errors\n        statdict: dictionary of various statistical parameters:\n            'DoF': Degrees of freedom\n            'Chi2': Chi-squared\n            'Chi2_reduced': Reduced Chi-squared\n            'R2': Coefficient of determination\n            'num_func_eval': number of function evaluations during fit.\n            'func_value': the function evaluated in the best fitting parameters\n            'message': status message from leastsq()\n            'error_flag': integer status flag from leastsq() ('ier')\n            'Covariance': covariance matrix (variances in the diagonal)\n            'Correlation_coeffs': Pearson's correlation coefficients (usually\n                denoted by 'r') in a matrix. The diagonal is unity.\n\n    Notes:\n        for the actual fitting, scipy.optimize.leastsq() is used.\n    \"\"\"\n    if verbose:\n        t0 = time.monotonic()\n        print(\"nlsq_fit starting.\")\n    else:\n        t0 = 0\n    func_orig = func\n    params_init_orig = params_init\n    func, params_init = hide_fixedparams(func_orig, params_init_orig)\n    if (dy is None) or (dy == np.nan).sum() > 0 or (dy <= 0).sum() > 0:\n        if verbose:\n            print(\"nlsq_fit: no weighting\")\n        dy = None\n\n    def objectivefunc(params, x, y, dy):\n        \"\"\"The target function for leastsq().\"\"\"\n        if dy is None:\n            return (func(x, *(params.tolist())) - y)\n        else:\n            return (func(x, *(params.tolist())) - y) / dy\n    # do the fitting\n    if verbose:\n        print(\"nlsq_fit: now doing the fitting...\")\n        t1 = time.monotonic()\n    else:\n        t1 = 0\n    par, cov, infodict, mesg, ier = leastsq(objectivefunc,\n                                            np.array(params_init),\n                                            (x, y, dy), full_output=True,\n                                            **kwargs)\n    if verbose:\n        print(\"nlsq_fit: fitting done in %.2f seconds.\" % (time.monotonic() - t1))\n        print(\"nlsq_fit: status from scipy.optimize.leastsq(): %d (%s)\" % (ier, mesg))\n        print(\"nlsq_fit: extracting statistics.\")\n    # test if the covariance was singular (cov is None)\n    if cov is None:\n        cov = np.ones((len(par), len(par))) * np.nan  # set it to a NaN matrix\n    # calculate the Pearson's R^2 parameter (coefficient of determination)\n    if dy is None:\n        sserr = np.sum(((func(x, *(par.tolist())) - y)) ** 2)\n        sstot = np.sum((y - np.mean(y)) ** 2)\n    else:\n        sserr = np.sum(((func(x, *(par.tolist())) - y) / dy) ** 2)\n        sstot = np.sum((y - np.mean(y)) ** 2 / dy ** 2)\n    r2 = 1 - sserr / sstot\n    # assemble the statistics dictionary\n    statdict = {'DoF' : len(x) - len(par),  # degrees of freedom\n                'Chi2' : (infodict['fvec'] ** 2).sum(),\n                'R2' : r2,\n                'num_func_eval' : infodict['nfev'],\n                'func_value' : func(x, *(par.tolist())),\n                'message' : mesg,\n                'error_flag' : ier,\n               }\n    statdict['Chi2_reduced'] = statdict['Chi2'] / statdict['DoF']\n    statdict['Covariance'] = cov * statdict['Chi2_reduced']\n    par, statdict['Covariance'] = resubstitute_fixedparams(par, params_init_orig, statdict['Covariance'])\n    # calculate the estimated errors of the fit parameters\n    dpar = np.sqrt(statdict['Covariance'].diagonal())\n    # Pearson's correlation coefficients (usually 'r') in a matrix.\n    statdict['Correlation_coeffs'] = statdict['Covariance'] / np.outer(dpar,\n                                                                       dpar)\n    if verbose:\n        print(\"nlsq_fit: returning with results.\")\n        print(\"nlsq_fit: total time: %.2f sec.\" % (time.monotonic() - t0))\n    return par, dpar, statdict"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndo a simultaneous nonlinear least - squares fit on a single base language tree.", "response": "def simultaneous_nlsq_fit(xs, ys, dys, func, params_inits, verbose=False,\n                             **kwargs):\n    \"\"\"Do a simultaneous nonlinear least-squares fit\n\n    Input:\n    ------\n    `xs`: tuple of abscissa vectors (1d numpy ndarrays)\n    `ys`: tuple of ordinate vectors (1d numpy ndarrays)\n    `dys`: tuple of the errors of ordinate vectors (1d numpy ndarrays or Nones)\n    `func`: fitting function (the same for all the datasets)\n    `params_init`: tuples of *lists* or *tuples* (not numpy ndarrays!) of the\n        initial values of the parameters to be fitted. The special value `None`\n        signifies that the corresponding parameter is the same as in the\n        previous dataset. Of course, none of the parameters of the first dataset\n        can be None.\n    `verbose`: if various messages useful for debugging should be printed on\n        stdout.\n\n    additional keyword arguments get forwarded to nlsq_fit()\n\n    Output:\n    -------\n    `p`: tuple of a list of fitted parameters\n    `dp`: tuple of a list of errors of the fitted parameters\n    `statdict`: statistics dictionary. This is of the same form as in\n        `nlsq_fit` except that func_value is a sequence of one-dimensional\n        np.ndarrays containing the best-fitting function values for each curve.\n    \"\"\"\n    if not isinstance(xs, collections.Sequence) or \\\n        not isinstance(ys, collections.Sequence) or \\\n        not isinstance(dys, collections.Sequence) or \\\n        not isinstance(params_inits, collections.Sequence):\n        raise ValueError('Parameters `xs`, `ys`, `dys` and `params_inits` should be tuples or lists.')\n    Ndata = len(xs)\n    if len(ys) != Ndata or len(dys) != Ndata or len(params_inits) != Ndata:\n        raise ValueError('Parameters `xs`, `ys`, `dys` and `params_inits` should have the same length.')\n\n    if not all([isinstance(x, collections.Sequence) for x in params_inits]):\n        raise ValueError('Elements of `params_inits` should be tuples or Python lists.')\n    Ns = set([len(x) for x in params_inits])\n    if len(Ns) != 1:\n        raise ValueError('Elements of `params_inits` should have the same length.')\n    Npar = Ns.pop()\n    for i in range(Ndata):\n        if dys[i] is None:\n            dys[i] = np.ones(len(xs[i]), np.double) * np.nan\n    # concatenate the x, y and dy vectors\n    xcat = np.concatenate(xs)\n    ycat = np.concatenate(ys)\n    dycat = np.concatenate(dys)\n    # find the start and end indices for each dataset in the concatenated datasets.\n    lens = [len(x) for x in xs]\n    starts = [int(sum(lens[:i])) for i in range(len(lens))]\n    ends = [int(sum(lens[:i + 1])) for i in range(len(lens))]\n\n    # flatten the initial parameter list. A single list is needed, where the\n    # constrained parameters occur only once. Of course, we have to do some\n    # bookkeeping to be able to find the needed parameters for each sub-range\n    # later during the fit.\n    paramcat = []  # this will be the concatenated list of parameters\n    param_indices = []  # this will have the same structure as params_inits (i.e.\n        # a tuple of tuples of ints). Each tuple corresponds to a dataset.\n        # Each integer number in each tuple holds\n        # the index of the corresponding fit parameter in the \n        # concatenated parameter list.\n    for j in range(Ndata):  # for each dataset\n        param_indices.append([])\n        jorig = j\n        for i in range(Npar):\n            j = jorig\n            while params_inits[j][i] is None and (j >= 0):\n                j = j - 1\n            if j < 0:\n                raise ValueError('None of the parameters in the very first dataset should be `None`.')\n            if jorig == j:  # not constrained parameter\n                paramcat.append(params_inits[j][i])\n                param_indices[jorig].append(len(paramcat) - 1)\n            else:\n                param_indices[jorig].append(param_indices[j][i])\n\n    if verbose:\n        print(\"Number of datasets for simultaneous fitting:\", Ndata)\n        print(\"Total number of data points:\", len(xcat))\n        print(\"Number of parameters in each dataset:\", Npar)\n        print(\"Total number of parameters:\", Ndata * Npar)\n        print(\"Number of independent parameters:\", len(paramcat))\n    # the flattened function\n    def func_flat(x, *params):\n        y = []\n        for j in range(Ndata):\n            if verbose > 1:\n                print(\"Simultaneous fitting: evaluating function for dataset #\", j, \"/\", Ndata)\n            pars = [params[i] for i in param_indices[j]]\n            y.append(func(x[starts[j]:ends[j]], *pars))\n        return np.concatenate(tuple(y))\n\n    # Now we reduced the problem to a single least-squares fit. Carry it out and\n    # interpret the results.\n    pflat, dpflat, statdictflat = nlsq_fit(xcat, ycat, dycat, func_flat, paramcat, verbose, **kwargs)\n    for n in ['func_value', 'R2', 'Chi2', 'Chi2_reduced', 'DoF', 'Covariance', 'Correlation_coeffs']:\n        statdictflat[n + '_global'] = statdictflat[n]\n        statdictflat[n] = []\n    p = []\n    dp = []\n    for j in range(Ndata):  # unpack the results\n        p.append([pflat[i] for i in param_indices[j]])\n        dp.append([dpflat[i] for i in param_indices[j]])\n        statdictflat['func_value'].append(statdictflat['func_value_global'][starts[j]:ends[j]])\n        if np.isfinite(dys[j]).all():\n            statdictflat['Chi2'].append((((statdictflat['func_value'][-1] - ys[j]) / dys[j]) ** 2).sum())\n            sstot = np.sum((ys[j] - np.mean(ys[j])) ** 2 / dys[j] ** 2)\n        else:\n            statdictflat['Chi2'].append(((statdictflat['func_value'][-1] - ys[j]) ** 2).sum())\n            sstot = np.sum((ys[j] - np.mean(ys[j])) ** 2)\n        sserr = statdictflat['Chi2'][-1]\n        statdictflat['R2'].append(1 - sserr / sstot)\n        statdictflat['DoF'].append(len(xs[j] - len(p[-1])))\n        statdictflat['Covariance'].append(slice_covarmatrix(statdictflat['Covariance_global'], param_indices[j]))\n        statdictflat['Correlation_coeffs'].append(slice_covarmatrix(statdictflat['Correlation_coeffs_global'], param_indices[j]))\n        statdictflat['Chi2_reduced'].append(statdictflat['Chi2'][-1] / statdictflat['DoF'][-1])\n    return p, dp, statdictflat"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tostring(self: 'ErrorValue', extra_digits: int = 0, plusminus: str = ' +/- ', fmt: str = None) -> str:\n        if isinstance(fmt, str) and fmt.lower().endswith('tex'):\n            return re.subn('(\\d*)(\\.(\\d)*)?[eE]([+-]?\\d+)',\n                           lambda m: (r'$%s%s\\cdot 10^{%s}$' % (m.group(1), m.group(2), m.group(4))).replace('None',\n                                                                                                             ''),\n                           self.tostring(extra_digits=extra_digits, plusminus=plusminus, fmt=None))[0]\n        if isinstance(self.val, numbers.Real):\n            try:\n                Ndigits = -int(math.floor(math.log10(self.err))) + extra_digits\n            except (OverflowError, ValueError):\n                return str(self.val) + plusminus + str(self.err)\n            else:\n                return str(round(self.val, Ndigits)) + plusminus + str(round(self.err, Ndigits))\n        return str(self.val) + ' +/- ' + str(self.err)", "response": "Convert the ErrorValue object into a string representation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef random(self: 'ErrorValue') -> np.ndarray:\n        if isinstance(self.val, np.ndarray):\n            # IGNORE:E1103\n            return np.random.randn(self.val.shape) * self.err + self.val\n        else:\n            return np.random.randn() * self.err + self.val", "response": "Sample a random number of the distribution defined by the error and variance of the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nevaluate a function with error propagation.", "response": "def evalfunc(cls, func, *args, **kwargs):\n        \"\"\"Evaluate a function with error propagation.\n\n        Inputs:\n        -------\n            ``func``: callable\n                this is the function to be evaluated. Should return either a\n                number or a np.ndarray.\n            ``*args``: other positional arguments of func. Arguments which are\n                not instances of `ErrorValue` are taken as constants.\n\n            keyword arguments supported:\n                ``NMC``: number of Monte-Carlo steps. If not defined, defaults\n                to 1000\n                ``exceptions_to_retry``: list of exception types to ignore:\n                    if one of these is raised the given MC step is repeated once\n                    again. Notice that this might induce an infinite loop!\n                    The exception types in this list should be subclasses of\n                    ``Exception``.\n                ``exceptions_to_skip``: list of exception types to skip: if\n                    one of these is raised the given MC step is skipped, never\n                    to be repeated. The exception types in this list should be\n                    subclasses of ``Exception``.\n\n\n        Output:\n        -------\n            ``result``: an `ErrorValue` with the result. The error is estimated\n                via a Monte-Carlo approach to Gaussian error propagation.\n        \"\"\"\n\n        def do_random(x):\n            if isinstance(x, cls):\n                return x.random()\n            else:\n                return x\n\n        if 'NMC' not in kwargs:\n            kwargs['NMC'] = 1000\n        if 'exceptions_to_skip' not in kwargs:\n            kwargs['exceptions_to_skip'] = []\n        if 'exceptions_to_repeat' not in kwargs:\n            kwargs['exceptions_to_repeat'] = []\n        meanvalue = func(*args)\n        # this way we get either a number or a np.array\n        stdcollector = meanvalue * 0\n        mciters = 0\n        while mciters < kwargs['NMC']:\n            try:\n                # IGNORE:W0142\n                stdcollector += (func(*[do_random(a)\n                                        for a in args]) - meanvalue) ** 2\n                mciters += 1\n            except Exception as e:  # IGNORE:W0703\n                if any(isinstance(e, etype) for etype in kwargs['exceptions_to_skip']):\n                    kwargs['NMC'] -= 1\n                elif any(isinstance(e, etype) for etype in kwargs['exceptions_to_repeat']):\n                    pass\n                else:\n                    raise\n        return cls(meanvalue, stdcollector ** 0.5 / (kwargs['NMC'] - 1))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the F - factor amplitude of a sphere normalized to F ( q = 0 ) = V", "response": "def Fsphere(q, R):\n    \"\"\"Scattering form-factor amplitude of a sphere normalized to F(q=0)=V\n\n    Inputs:\n    -------\n        ``q``: independent variable\n        ``R``: sphere radius\n\n    Formula:\n    --------\n        ``4*pi/q^3 * (sin(qR) - qR*cos(qR))``\n    \"\"\"\n    return 4 * np.pi / q ** 3 * (np.sin(q * R) - q * R * np.cos(q * R))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngeneralizes Guinier scattering of a set of variables.", "response": "def GeneralGuinier(q, G, Rg, s):\n    \"\"\"Generalized Guinier scattering\n\n    Inputs:\n    -------\n        ``q``: independent variable\n        ``G``: factor\n        ``Rg``: radius of gyration\n        ``s``: dimensionality parameter (can be 1, 2, 3)\n\n    Formula:\n    --------\n        ``G/q**(3-s)*exp(-(q^2*Rg^2)/s)``\n    \"\"\"\n    return G / q ** (3 - s) * np.exp(-(q * Rg) ** 2 / s)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef GuinierPorod(q, G, Rg, alpha):\n    return GuinierPorodMulti(q, G, Rg, alpha)", "response": "Empirical Guinier - Porod scattering."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef PorodGuinierPorod(q, a, alpha, Rg, beta):\n    return PorodGuinierMulti(q, a, alpha, Rg, beta)", "response": "Empirical Porod - Guinier - Porod scattering."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef GuinierPorodGuinier(q, G, Rg1, alpha, Rg2):\n    return GuinierPorodMulti(q, G, Rg1, alpha, Rg2)", "response": "Empirical Guinier - Porod - Guinier scattering."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndamping power - law of a set of variables.", "response": "def DampedPowerlaw(q, a, alpha, sigma):\n    \"\"\"Damped power-law\n\n    Inputs:\n    -------\n        ``q``: independent variable\n        ``a``: factor\n        ``alpha``: exponent\n        ``sigma``: hwhm of the damping Gaussian\n\n    Formula:\n    --------\n        ``a*q^alpha*exp(-q^2/(2*sigma^2))``\n    \"\"\"\n    return a * q ** alpha * np.exp(-q ** 2 / (2 * sigma ** 2))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs Normal Spheres in the hierarchy of non - correlated spheres.", "response": "def LogNormSpheres(q, A, mu, sigma, N=1000):\n    \"\"\"Scattering of a population of non-correlated spheres (radii from a log-normal distribution)\n\n    Inputs:\n    -------\n        ``q``: independent variable\n        ``A``: scaling factor\n        ``mu``: expectation of ``ln(R)``\n        ``sigma``: hwhm of ``ln(R)``\n\n    Non-fittable inputs:\n    --------------------\n        ``N``: the (integer) number of spheres\n\n    Formula:\n    --------\n        The integral of ``F_sphere^2(q,R) * P(R)`` where ``P(R)`` is a\n        log-normal distribution of the radii.\n\n    \"\"\"\n    Rmin = 0\n    Rmax = np.exp(mu + 3 * sigma)\n    R = np.linspace(Rmin, Rmax, N + 1)[1:]\n    P = 1 / np.sqrt(2 * np.pi * sigma ** 2 * R ** 2) * np.exp(-(np.log(R) - mu) ** 2 / (2 * sigma ** 2))\n    def Fsphere_outer(q, R):\n        qR = np.outer(q, R)\n        q1 = np.outer(q, np.ones_like(R))\n        return 4 * np.pi / q1 ** 3 * (np.sin(qR) - qR * np.cos(qR))\n    I = (Fsphere_outer(q, R) ** 2 * np.outer(np.ones_like(q), P))\n    return A * I.sum(1) / P.sum()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef GaussSpheres(q, A, R0, sigma, N=1000, weighting='intensity'):\n    Rmin = max(0, R0 - 3 * sigma)\n    Rmax = R0 + 3 * sigma\n    R = np.linspace(Rmin, Rmax, N + 1)[1:]\n    P = 1 / np.sqrt(2 * np.pi * sigma ** 2) * np.exp(-(R - R0) ** 2 / (2 * sigma ** 2))\n    def Fsphere_outer(q, R):\n        qR = np.outer(q, R)\n        return 3 / qR ** 3 * (np.sin(qR) - qR * np.cos(qR))\n    V=R**3*4*np.pi/3.\n    if weighting=='intensity':\n        P=P*V*V\n    elif weighting=='volume':\n        P=P*V\n    elif weighting=='number':\n        pass\n    else:\n        raise ValueError('Invalid weighting: '+str(weighting))    \n    I = (Fsphere_outer(q, R) ** 2 * np.outer(np.ones_like(q), P))\n    return A * I.sum(1) / P.sum()", "response": "Computes the scattering of non - correlated spheres in a single population of non - correlated spheres."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsums of a Power - law a Guinier - Porod curve and a constant.", "response": "def PowerlawGuinierPorodConst(q, A, alpha, G, Rg, beta, C):\n    \"\"\"Sum of a Power-law, a Guinier-Porod curve and a constant.\n\n    Inputs:\n    -------\n        ``q``: independent variable (momentum transfer)\n        ``A``: scaling factor of the power-law\n        ``alpha``: power-law exponent\n        ``G``: scaling factor of the Guinier-Porod curve\n        ``Rg``: Radius of gyration\n        ``beta``: power-law exponent of the Guinier-Porod curve\n        ``C``: additive constant\n\n    Formula:\n    --------\n        ``A*q^alpha + GuinierPorod(q,G,Rg,beta) + C``\n    \"\"\"\n    return PowerlawPlusConstant(q, A, alpha, C) + GuinierPorod(q, G, Rg, beta)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef GuinierPorodMulti(q, G, *Rgsalphas):\n    scalefactor = G\n    funcs = [lambda q: Guinier(q, G, Rgsalphas[0])]\n    indices = np.ones_like(q, dtype=np.bool)\n    constraints = []\n    for i in range(1, len(Rgsalphas)):\n        if i % 2:\n            # Rgsalphas[i] is an exponent, Rgsalphas[i-1] is a radius of gyration\n            qsep = _PGgen_qsep(Rgsalphas[i], Rgsalphas[i - 1], 3)\n            scalefactor = _PGgen_A(Rgsalphas[i], Rgsalphas[i - 1], 3, scalefactor)\n            funcs.append(lambda q, a=scalefactor, alpha=Rgsalphas[i]: Powerlaw(q, a, alpha))\n        else:\n            # Rgsalphas[i] is a radius of gyration, Rgsalphas[i-1] is a power-law exponent\n            qsep = _PGgen_qsep(Rgsalphas[i - 1], Rgsalphas[i], 3)\n            scalefactor = _PGgen_G(Rgsalphas[i - 1], Rgsalphas[i], 3, scalefactor)\n            funcs.append(lambda q, G=scalefactor, Rg=Rgsalphas[i]: Guinier(q, G, Rg))\n        # this belongs to the previous\n        constraints.append(indices & (q < qsep))\n        indices[q < qsep] = False\n    constraints.append(indices)\n    return np.piecewise(q, constraints, funcs)", "response": "Empirical multi - part Guinier - Porod scattering."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngeneralizing multi - part Guinier - Porod scattering.", "response": "def GeneralGuinierPorod(q, factor, *args, **kwargs):\n    \"\"\"Empirical generalized multi-part Guinier-Porod scattering\n\n    Inputs:\n    -------\n        ``q``: independent variable\n        ``factor``: factor for the first branch\n        other arguments (*args): the defining arguments of the consecutive\n             parts: radius of gyration (``Rg``) and dimensionality\n             parameter (``s``) for Guinier and exponent (``alpha``) for\n             power-law parts.\n        supported keyword arguments:\n            ``startswithguinier``: True if the first segment is a Guinier-type\n            scattering (this is the default) or False if it is a power-law\n\n    Formula:\n    --------\n        The intensity is a piecewise function with continuous first derivatives.\n        The separating points in ``q`` between the consecutive parts and the\n        intensity factors of them (except the first) are determined from\n        conditions of smoothness (continuity of the function and its first\n        derivative) at the border points of the intervals. Guinier-type\n        (``G*q**(3-s)*exp(-q^2*Rg1^2/s)``) and Power-law type (``A*q^alpha``)\n        parts follow each other in alternating sequence. The exact number of\n        parts is determined from the number of positional arguments (*args).\n\n    Literature:\n    -----------\n        B. Hammouda: A new Guinier-Porod model. J. Appl. Crystallogr. (2010) 43,\n            716-719.\n    \"\"\"\n    if kwargs.get('startswithguinier', True):\n        funcs = [lambda q, A = factor:GeneralGuinier(q, A, args[0], args[1])]\n        i = 2\n        guiniernext = False\n    else:\n        funcs = [lambda q, A = factor: Powerlaw(q, A, args[0])]\n        i = 1\n        guiniernext = True\n    indices = np.ones_like(q, dtype=np.bool)\n    constraints = []\n    while i < len(args):\n        if guiniernext:\n            # args[i] is a radius of gyration, args[i+1] is a dimensionality parameter, args[i-1] is a power-law exponent\n            qsep = _PGgen_qsep(args[i - 1], args[i], args[i + 1])\n            factor = _PGgen_G(args[i - 1], args[i], args[i + 1], factor)\n            funcs.append(lambda q, G=factor, Rg=args[i], s=args[i + 1]: GeneralGuinier(q, G, Rg, s))\n            guiniernext = False\n            i += 2\n        else:\n            # args[i] is an exponent, args[i-2] is a radius of gyration, args[i-1] is a dimensionality parameter\n            qsep = _PGgen_qsep(args[i], args[i - 2], args[i - 1])\n            factor = _PGgen_A(args[i], args[i - 2], args[i - 1], factor)\n            funcs.append(lambda q, a=factor, alpha=args[i]: a * q ** alpha)\n            guiniernext = True\n            i += 1\n        # this belongs to the previous\n        constraints.append(indices & (q < qsep))\n        indices[q < qsep] = False\n    constraints.append(indices)\n    return np.piecewise(q, constraints, funcs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef DebyeChain(q, Rg):\n    a = (q * Rg) ** 2\n    return 2 * (np.exp(-a) - 1 + a) / a ** 2", "response": "Returns the scattering form - factor intensity of a Gaussian chain."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngeneralizes excluded - volume Gaussian chain.", "response": "def ExcludedVolumeChain(q, Rg, nu):\n    \"\"\"Scattering intensity of a generalized excluded-volume Gaussian chain\n\n    Inputs:\n    -------\n        ``q``: independent variable\n        ``Rg``: radius of gyration\n        ``nu``: excluded volume exponent\n\n    Formula:\n    --------\n        ``(u^(1/nu)*gamma(0.5/nu)*gammainc_lower(0.5/nu,u)-\n            gamma(1/nu)*gammainc_lower(1/nu,u)) / (nu*u^(1/nu))``\n        where ``u = q^2*Rg^2*(2*nu+1)*(2*nu+2)/6`` is the reduced scattering\n        variable, ``gamma(x)`` is the gamma function and ``gammainc_lower(x,t)``\n        is the lower incomplete gamma function.\n\n    Literature:\n    -----------\n        SASFit manual 6. nov. 2010. Equation (3.60b)\n    \"\"\"\n    u = (q * Rg) ** 2 * (2 * nu + 1) * (2 * nu + 2) / 6.\n    return (u ** (0.5 / nu) * gamma(0.5 / nu) * gammainc(0.5 / nu, u) -\n            gamma(1. / nu) * gammainc(1. / nu, u)) / (nu * u ** (1. / nu))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsampling a patch from the data object.", "response": "def sample(self, data, interval):\n        '''Sample a patch from the data object\n\n        Parameters\n        ----------\n        data : dict\n            A data dict as produced by pumpp.Pump.transform\n\n        interval : slice\n            The time interval to sample\n\n        Returns\n        -------\n        data_slice : dict\n            `data` restricted to `interval`.\n        '''\n        data_slice = dict()\n\n        for key in data:\n            if '_valid' in key:\n                continue\n\n            index = [slice(None)] * data[key].ndim\n\n            # if we have multiple observations for this key, pick one\n            index[0] = self.rng.randint(0, data[key].shape[0])\n            index[0] = slice(index[0], index[0] + 1)\n\n            for tdim in self._time[key]:\n                index[tdim] = interval\n\n            data_slice[key] = data[key][tuple(index)]\n\n        return data_slice"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a generator of indices for the set of keys in the data dictionary.", "response": "def indices(self, data):\n        '''Generate patch indices\n\n        Parameters\n        ----------\n        data : dict of np.ndarray\n            As produced by pumpp.transform\n\n        Yields\n        ------\n        start : int >= 0\n            The start index of a sample patch\n        '''\n        duration = self.data_duration(data)\n\n        if self.duration > duration:\n            raise DataError('Data duration={} is less than '\n                            'sample duration={}'.format(duration, self.duration))\n\n        while True:\n            # Generate a sampling interval\n            yield self.rng.randint(0, duration - self.duration + 1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating patch start indices for the set of keys in the data dictionary", "response": "def indices(self, data):\n        '''Generate patch start indices\n\n        Parameters\n        ----------\n        data : dict of np.ndarray\n            As produced by pumpp.transform\n\n        Yields\n        ------\n        start : int >= 0\n            The start index of a sample patch\n        '''\n        duration = self.data_duration(data)\n\n        for start in range(0, duration - self.duration, self.stride):\n            yield start"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef indices(self, data):\n        '''Generate patch indices\n\n        Parameters\n        ----------\n        data : dict of np.ndarray\n            As produced by pumpp.transform\n\n        Yields\n        ------\n        start : int >= 0\n            The start index of a sample patch\n        '''\n        duration = self.data_duration(data)\n\n        while True:\n            # Generate a sampling interval\n            yield self.rng.randint(0, duration - self.min_duration + 1)", "response": "Generate a generator of indices for the set of keys in the data dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\napply the name scope to a key.", "response": "def scope(self, key):\n        '''Apply the name scope to a key\n\n        Parameters\n        ----------\n        key : string\n\n        Returns\n        -------\n        `name/key` if `name` is not `None`;\n        otherwise, `key`.\n        '''\n        if self.name is None:\n            return key\n        return '{:s}/{:s}'.format(self.name, key)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering a field as a tensor with the given shape and type.", "response": "def register(self, field, shape, dtype):\n        '''Register a field as a tensor with specified shape and type.\n\n        A `Tensor` of the given shape and type will be registered in this\n        object's `fields` dict.\n\n        Parameters\n        ----------\n        field : str\n            The name of the field\n\n        shape : iterable of `int` or `None`\n            The shape of the output variable.\n            This does not include a dimension for multiple outputs.\n\n            `None` may be used to indicate variable-length outputs\n\n        dtype : type\n            The data type of the field\n\n        Raises\n        ------\n        ParameterError\n            If dtype or shape are improperly specified\n        '''\n        if not isinstance(dtype, type):\n            raise ParameterError('dtype={} must be a type'.format(dtype))\n\n        if not (isinstance(shape, Iterable) and\n                all([s is None or isinstance(s, int) for s in shape])):\n            raise ParameterError('shape={} must be an iterable of integers'.format(shape))\n\n        self.fields[self.scope(field)] = Tensor(tuple(shape), dtype)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmerging an array of output dicts into a single dictionary with properly scoped names.", "response": "def merge(self, data):\n        '''Merge an array of output dictionaries into a single dictionary\n        with properly scoped names.\n\n        Parameters\n        ----------\n        data : list of dict\n            Output dicts as produced by `pumpp.task.BaseTaskTransformer.transform`\n            or `pumpp.feature.FeatureExtractor.transform`.\n\n        Returns\n        -------\n        data_out : dict\n            All elements of the input dicts are stacked along the 0 axis,\n            and keys are re-mapped by `scope`.\n        '''\n        data_out = dict()\n\n        # Iterate over all keys in data\n        for key in set().union(*data):\n            data_out[self.scope(key)] = np.stack([np.asarray(d[key]) for d in data],\n                                                 axis=0)\n        return data_out"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an operator to the Slicer object", "response": "def add(self, operator):\n        '''Add an operator to the Slicer\n\n        Parameters\n        ----------\n        operator : Scope (TaskTransformer or FeatureExtractor)\n            The new operator to add\n        '''\n        if not isinstance(operator, Scope):\n            raise ParameterError('Operator {} must be a TaskTransformer '\n                                 'or FeatureExtractor'.format(operator))\n        for key in operator.fields:\n            self._time[key] = []\n            # We add 1 to the dimension here to account for batching\n            for tdim, idx in enumerate(operator.fields[key].shape, 1):\n                if idx is None:\n                    self._time[key].append(tdim)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing the valid data duration of a dict", "response": "def data_duration(self, data):\n        '''Compute the valid data duration of a dict\n\n        Parameters\n        ----------\n        data : dict\n            As produced by pumpp.transform\n\n        Returns\n        -------\n        length : int\n            The minimum temporal extent of a dynamic observation in data\n        '''\n        # Find all the time-like indices of the data\n        lengths = []\n        for key in self._time:\n            for idx in self._time.get(key, []):\n                lengths.append(data[key].shape[idx])\n\n        return min(lengths)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef crop(self, data):\n        '''Crop a data dictionary down to its common time\n\n        Parameters\n        ----------\n        data : dict\n            As produced by pumpp.transform\n\n        Returns\n        -------\n        data_cropped : dict\n            Like `data` but with all time-like axes truncated to the\n            minimum common duration\n        '''\n\n        duration = self.data_duration(data)\n        data_out = dict()\n        for key in data:\n            idx = [slice(None)] * data[key].ndim\n            for tdim in self._time.get(key, []):\n                idx[tdim] = slice(duration)\n            data_out[key] = data[key][tuple(idx)]\n\n        return data_out", "response": "Crop a data dictionary down to its common time - like axes truncated to the minimum common duration\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute the Mel spectrogram of the audio buffer y.", "response": "def transform_audio(self, y):\n        '''Compute the Mel spectrogram\n\n        Parameters\n        ----------\n        y : np.ndarray\n            The audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['mag'] : np.ndarray, shape=(n_frames, n_mels)\n                The Mel spectrogram\n        '''\n        n_frames = self.n_frames(get_duration(y=y, sr=self.sr))\n\n        mel = np.sqrt(melspectrogram(y=y, sr=self.sr,\n                                     n_fft=self.n_fft,\n                                     hop_length=self.hop_length,\n                                     n_mels=self.n_mels,\n                                     fmax=self.fmax)).astype(np.float32)\n\n        mel = fix_length(mel, n_frames)\n\n        if self.log:\n            mel = amplitude_to_db(mel, ref=np.max)\n\n        return {'mag': mel.T[self.idx]}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nemptying vector annotations. This returns an empty vector annotation with a single observation vector consisting of all - zeroes.", "response": "def empty(self, duration):\n        '''Empty vector annotations.\n\n        This returns an annotation with a single observation\n        vector consisting of all-zeroes.\n\n        Parameters\n        ----------\n        duration : number >0\n            Length of the track\n\n        Returns\n        -------\n        ann : jams.Annotation\n            The empty annotation\n        '''\n        ann = super(VectorTransformer, self).empty(duration)\n\n        ann.append(time=0, duration=duration, confidence=0,\n                   value=np.zeros(self.dimension, dtype=np.float32))\n        return ann"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\napply the vector transformation.", "response": "def transform_annotation(self, ann, duration):\n        '''Apply the vector transformation.\n\n        Parameters\n        ----------\n        ann : jams.Annotation\n            The input annotation\n\n        duration : number > 0\n            The duration of the track\n\n        Returns\n        -------\n        data : dict\n            data['vector'] : np.ndarray, shape=(dimension,)\n\n        Raises\n        ------\n        DataError\n            If the input dimension does not match\n        '''\n        _, values = ann.to_interval_values()\n        vector = np.asarray(values[0], dtype=self.dtype)\n        if len(vector) != self.dimension:\n            raise DataError('vector dimension({:0}) '\n                            '!= self.dimension({:1})'\n                            .format(len(vector), self.dimension))\n\n        return {'vector': vector}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the transition matrix according to self - loop probabilities.", "response": "def set_transition(self, p_self):\n        '''Set the transition matrix according to self-loop probabilities.\n\n        Parameters\n        ----------\n        p_self : None, float in (0, 1), or np.ndarray [shape=(n_labels,)]\n            Optional self-loop probability(ies), used for Viterbi decoding\n        '''\n        if p_self is None:\n            self.transition = None\n        else:\n            self.transition = np.empty((len(self._classes), 2, 2))\n            if np.isscalar(p_self):\n                self.transition = transition_loop(2, p_self)\n            elif len(p_self) != len(self._classes):\n                raise ParameterError('Invalid p_self.shape={} for vocabulary size={}'.format(p_self.shape, len(self._classes)))\n            else:\n                for i in range(len(self._classes)):\n                    self.transition[i] = transition_loop(2, p_self[i])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nempty label annotations. Empty label annotations.", "response": "def empty(self, duration):\n        '''Empty label annotations.\n\n        Constructs a single observation with an empty value (None).\n\n        Parameters\n        ----------\n        duration : number > 0\n            The duration of the annotation\n        '''\n        ann = super(DynamicLabelTransformer, self).empty(duration)\n        ann.append(time=0, duration=duration, value=None)\n        return ann"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntransforms an annotation to dynamic label encoding.", "response": "def transform_annotation(self, ann, duration):\n        '''Transform an annotation to dynamic label encoding.\n\n        Parameters\n        ----------\n        ann : jams.Annotation\n            The annotation to convert\n\n        duration : number > 0\n            The duration of the track\n\n        Returns\n        -------\n        data : dict\n            data['tags'] : np.ndarray, shape=(n, n_labels)\n                A time-varying binary encoding of the labels\n        '''\n        intervals, values = ann.to_interval_values()\n\n        # Suppress all intervals not in the encoder\n        tags = []\n        for v in values:\n            if v in self._classes:\n                tags.extend(self.encoder.transform([[v]]))\n            else:\n                tags.extend(self.encoder.transform([[]]))\n\n        tags = np.asarray(tags)\n        target = self.encode_intervals(duration, intervals, tags)\n\n        return {'tags': target}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef inverse(self, encoded, duration=None):\n        '''Inverse transformation'''\n\n        ann = jams.Annotation(namespace=self.namespace, duration=duration)\n        for start, end, value in self.decode_intervals(encoded,\n                                                       duration=duration,\n                                                       transition=self.transition,\n                                                       p_init=self.p_init,\n                                                       p_state=self.p_state):\n            # Map start:end to frames\n            f_start, f_end = time_to_frames([start, end],\n                                            sr=self.sr,\n                                            hop_length=self.hop_length)\n\n            confidence = np.mean(encoded[f_start:f_end+1, value])\n\n            value_dec = self.encoder.inverse_transform(np.atleast_2d(value))[0]\n\n            for vd in value_dec:\n                ann.append(time=start,\n                           duration=end-start,\n                           value=vd,\n                           confidence=confidence)\n\n        return ann", "response": "Inverse transformation of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntransform an annotation to static label encoding.", "response": "def transform_annotation(self, ann, duration):\n        '''Transform an annotation to static label encoding.\n\n        Parameters\n        ----------\n        ann : jams.Annotation\n            The annotation to convert\n\n        duration : number > 0\n            The duration of the track\n\n        Returns\n        -------\n        data : dict\n            data['tags'] : np.ndarray, shape=(n_labels,)\n                A static binary encoding of the labels\n        '''\n        intervals = np.asarray([[0, 1]])\n        values = list([obs.value for obs in ann])\n        intervals = np.tile(intervals, [len(values), 1])\n\n        # Suppress all intervals not in the encoder\n        tags = [v for v in values if v in self._classes]\n        if len(tags):\n            target = self.encoder.transform([tags]).astype(np.bool).max(axis=0)\n        else:\n            target = np.zeros(len(self._classes), dtype=np.bool)\n\n        return {'tags': target}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef inverse(self, encoded, duration=None):\n        '''Inverse static tag transformation'''\n\n        ann = jams.Annotation(namespace=self.namespace, duration=duration)\n\n        if np.isrealobj(encoded):\n            detected = (encoded >= 0.5)\n        else:\n            detected = encoded\n\n        for vd in self.encoder.inverse_transform(np.atleast_2d(detected))[0]:\n            vid = np.flatnonzero(self.encoder.transform(np.atleast_2d(vd)))\n            ann.append(time=0,\n                       duration=duration,\n                       value=vd,\n                       confidence=encoded[vid])\n        return ann", "response": "Inverse static tag transformation"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef transform_audio(self, y):\n        '''Compute the time position encoding\n\n        Parameters\n        ----------\n        y : np.ndarray\n            Audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['relative'] = np.ndarray, shape=(n_frames, 2)\n            data['absolute'] = np.ndarray, shape=(n_frames, 2)\n\n                Relative and absolute time positional encodings.\n        '''\n\n        duration = get_duration(y=y, sr=self.sr)\n        n_frames = self.n_frames(duration)\n\n        relative = np.zeros((n_frames, 2), dtype=np.float32)\n        relative[:, 0] = np.cos(np.pi * np.linspace(0, 1, num=n_frames))\n        relative[:, 1] = np.sin(np.pi * np.linspace(0, 1, num=n_frames))\n\n        absolute = relative * np.sqrt(duration)\n\n        return {'relative': relative[self.idx],\n                'absolute': absolute[self.idx]}", "response": "Compute the time position encoding of the audio buffer y."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an operation to this pump.", "response": "def add(self, operator):\n        '''Add an operation to this pump.\n\n        Parameters\n        ----------\n        operator : BaseTaskTransformer, FeatureExtractor\n            The operation to add\n\n        Raises\n        ------\n        ParameterError\n            if `op` is not of a correct type\n        '''\n        if not isinstance(operator, (BaseTaskTransformer, FeatureExtractor)):\n            raise ParameterError('operator={} must be one of '\n                                 '(BaseTaskTransformer, FeatureExtractor)'\n                                 .format(operator))\n\n        if operator.name in self.opmap:\n            raise ParameterError('Duplicate operator name detected: '\n                                 '{}'.format(operator))\n\n        super(Pump, self).add(operator)\n        self.opmap[operator.name] = operator\n        self.ops.append(operator)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef transform(self, audio_f=None, jam=None, y=None, sr=None, crop=False):\n        '''Apply the transformations to an audio file, and optionally JAMS object.\n\n        Parameters\n        ----------\n        audio_f : str\n            Path to audio file\n\n        jam : optional, `jams.JAMS`, str or file-like\n            Optional JAMS object/path to JAMS file/open file descriptor.\n\n            If provided, this will provide data for task transformers.\n\n        y : np.ndarray\n        sr : number > 0\n            If provided, operate directly on an existing audio buffer `y` at\n            sampling rate `sr` rather than load from `audio_f`.\n\n        crop : bool\n            If `True`, then data are cropped to a common time index across all\n            fields.  Otherwise, data may have different time extents.\n\n        Returns\n        -------\n        data : dict\n            Data dictionary containing the transformed audio (and annotations)\n\n        Raises\n        ------\n        ParameterError\n            At least one of `audio_f` or `(y, sr)` must be provided.\n\n        '''\n\n        if y is None:\n            if audio_f is None:\n                raise ParameterError('At least one of `y` or `audio_f` '\n                                     'must be provided')\n\n            # Load the audio\n            y, sr = librosa.load(audio_f, sr=sr, mono=True)\n\n        if sr is None:\n            raise ParameterError('If audio is provided as `y`, you must '\n                                 'specify the sampling rate as sr=')\n\n        if jam is None:\n            jam = jams.JAMS()\n            jam.file_metadata.duration = librosa.get_duration(y=y, sr=sr)\n\n        # Load the jams\n        if not isinstance(jam, jams.JAMS):\n            jam = jams.load(jam)\n\n        data = dict()\n\n        for operator in self.ops:\n            if isinstance(operator, BaseTaskTransformer):\n                data.update(operator.transform(jam))\n            elif isinstance(operator, FeatureExtractor):\n                data.update(operator.transform(y, sr))\n        if crop:\n            data = self.crop(data)\n        return data", "response": "Apply the transformations to an audio file and optionally JAMS object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sampler(self, n_samples, duration, random_state=None):\n        '''Construct a sampler object for this pump's operators.\n\n        Parameters\n        ----------\n        n_samples : None or int > 0\n            The number of samples to generate\n\n        duration : int > 0\n            The duration (in frames) of each sample patch\n\n        random_state : None, int, or np.random.RandomState\n            If int, random_state is the seed used by the random number\n            generator;\n\n            If RandomState instance, random_state is the random number\n            generator;\n\n            If None, the random number generator is the RandomState instance\n            used by np.random.\n\n        Returns\n        -------\n        sampler : pumpp.Sampler\n            The sampler object\n\n        See Also\n        --------\n        pumpp.sampler.Sampler\n        '''\n\n        return Sampler(n_samples, duration,\n                       random_state=random_state,\n                       *self.ops)", "response": "Construct a sampler object for this pump s operators."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fields(self):\n        '''A dictionary of fields constructed by this pump'''\n        out = dict()\n        for operator in self.ops:\n            out.update(**operator.fields)\n\n        return out", "response": "A dictionary of fields constructed by this pump"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef layers(self):\n        '''Construct Keras input layers for all feature transformers\n        in the pump.\n\n        Returns\n        -------\n        layers : {field: keras.layers.Input}\n            A dictionary of keras input layers, keyed by the corresponding\n            fields.\n        '''\n\n        layermap = dict()\n        for operator in self.ops:\n            if hasattr(operator, 'layers'):\n                layermap.update(operator.layers())\n        return layermap", "response": "Construct Keras input layers for all feature transformers\n        in the pump."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the beat - tracking transition matrix according to the self - loop probabilities.", "response": "def set_transition_beat(self, p_self):\n        '''Set the beat-tracking transition matrix according to\n        self-loop probabilities.\n\n        Parameters\n        ----------\n        p_self : None, float in (0, 1), or np.ndarray [shape=(2,)]\n            Optional self-loop probability(ies), used for Viterbi decoding\n        '''\n        if p_self is None:\n            self.beat_transition = None\n        else:\n            self.beat_transition = transition_loop(2, p_self)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_transition_down(self, p_self):\n        '''Set the downbeat-tracking transition matrix according to\n        self-loop probabilities.\n\n        Parameters\n        ----------\n        p_self : None, float in (0, 1), or np.ndarray [shape=(2,)]\n            Optional self-loop probability(ies), used for Viterbi decoding\n        '''\n        if p_self is None:\n            self.down_transition = None\n        else:\n            self.down_transition = transition_loop(2, p_self)", "response": "Set the downbeat - tracking transition matrix according to the self - loop probabilities."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\napplies the beat transformer to the specific resource.", "response": "def transform_annotation(self, ann, duration):\n        '''Apply the beat transformer\n\n        Parameters\n        ----------\n        ann : jams.Annotation\n            The input annotation\n\n        duration : number > 0\n            The duration of the audio\n\n        Returns\n        -------\n        data : dict\n            data['beat'] : np.ndarray, shape=(n, 1)\n                Binary indicator of beat/non-beat\n\n            data['downbeat'] : np.ndarray, shape=(n, 1)\n                Binary indicator of downbeat/non-downbeat\n\n            mask_downbeat : bool\n                True if downbeat annotations are present\n        '''\n\n        mask_downbeat = False\n\n        intervals, values = ann.to_interval_values()\n        values = np.asarray(values)\n\n        beat_events = intervals[:, 0]\n        beat_labels = np.ones((len(beat_events), 1))\n\n        idx = (values == 1)\n        if np.any(idx):\n            downbeat_events = beat_events[idx]\n            downbeat_labels = np.ones((len(downbeat_events), 1))\n            mask_downbeat = True\n        else:\n            downbeat_events = np.zeros(0)\n            downbeat_labels = np.zeros((0, 1))\n\n        target_beat = self.encode_events(duration,\n                                         beat_events,\n                                         beat_labels)\n\n        target_downbeat = self.encode_events(duration,\n                                             downbeat_events,\n                                             downbeat_labels)\n\n        return {'beat': target_beat,\n                'downbeat': target_downbeat,\n                'mask_downbeat': mask_downbeat}"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef inverse(self, encoded, downbeat=None, duration=None):\n        '''Inverse transformation for beats and optional downbeats'''\n\n        ann = jams.Annotation(namespace=self.namespace, duration=duration)\n\n        beat_times = np.asarray([t for t, _ in self.decode_events(encoded,\n                                                                  transition=self.beat_transition,\n                                                                  p_init=self.beat_p_init,\n                                                                  p_state=self.beat_p_state) if _])\n        beat_frames = time_to_frames(beat_times,\n                                     sr=self.sr,\n                                     hop_length=self.hop_length)\n\n        if downbeat is not None:\n            downbeat_times = set([t for t, _ in self.decode_events(downbeat,\n                                                                   transition=self.down_transition,\n                                                                   p_init=self.down_p_init,\n                                                                   p_state=self.down_p_state) if _])\n            pickup_beats = len([t for t in beat_times\n                                if t < min(downbeat_times)])\n        else:\n            downbeat_times = set()\n            pickup_beats = 0\n\n        value = - pickup_beats - 1\n        for beat_t, beat_f in zip(beat_times, beat_frames):\n            if beat_t in downbeat_times:\n                value = 1\n            else:\n                value += 1\n            confidence = encoded[beat_f]\n            ann.append(time=beat_t,\n                       duration=0,\n                       value=value,\n                       confidence=confidence)\n\n        return ann", "response": "Inverse transformation for beats and optional downbeats"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef transform_annotation(self, ann, duration):\n        '''Transform an annotation to the beat-position encoding\n\n        Parameters\n        ----------\n        ann : jams.Annotation\n            The annotation to convert\n\n        duration : number > 0\n            The duration of the track\n\n        Returns\n        -------\n        data : dict\n            data['position'] : np.ndarray, shape=(n, n_labels) or (n, 1)\n                A time-varying label encoding of beat position\n        '''\n\n        # 1. get all the events\n        # 2. find all the downbeats\n        # 3. map each downbeat to a subdivision counter\n        #       number of beats until the next downbeat\n        # 4. pad out events to intervals\n        # 5. encode each beat interval to its position\n\n        boundaries, values = ann.to_interval_values()\n        # Convert to intervals and span the duration\n        # padding at the end of track does not propagate the right label\n        # this is an artifact of inferring end-of-track from boundaries though\n        boundaries = list(boundaries[:, 0])\n        if boundaries and boundaries[-1] < duration:\n            boundaries.append(duration)\n        intervals = boundaries_to_intervals(boundaries)\n        intervals, values = adjust_intervals(intervals, values,\n                                             t_min=0,\n                                             t_max=duration,\n                                             start_label=0,\n                                             end_label=0)\n\n        values = np.asarray(values, dtype=int)\n        downbeats = np.flatnonzero(values == 1)\n\n        position = []\n        for i, v in enumerate(values):\n            # If the value is a 0, mark it as X and move on\n            if v == 0:\n                position.extend(self.encoder.transform(['X']))\n                continue\n\n            # Otherwise, let's try to find the surrounding downbeats\n            prev_idx = np.searchsorted(downbeats, i, side='right') - 1\n            next_idx = 1 + prev_idx\n\n            if prev_idx >= 0 and next_idx < len(downbeats):\n                # In this case, the subdivision is well-defined\n                subdivision = downbeats[next_idx] - downbeats[prev_idx]\n            elif prev_idx < 0 and next_idx < len(downbeats):\n                subdivision = np.max(values[:downbeats[0]+1])\n            elif next_idx >= len(downbeats):\n                subdivision = len(values) - downbeats[prev_idx]\n\n            if subdivision > self.max_divisions or subdivision < 1:\n                position.extend(self.encoder.transform(['X']))\n            else:\n                position.extend(self.encoder.transform(['{:02d}/{:02d}'.format(subdivision, v)]))\n\n        dtype = self.fields[self.scope('position')].dtype\n\n        position = np.asarray(position)\n        if self.sparse:\n            position = position[:, np.newaxis]\n\n        target = self.encode_intervals(duration, intervals, position,\n                                       multi=False, dtype=dtype)\n        return {'position': target}", "response": "Transform an annotation to the beat - position encoding"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef transform_audio(self, y):\n        '''Compute the tempogram\n\n        Parameters\n        ----------\n        y : np.ndarray\n            Audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['tempogram'] : np.ndarray, shape=(n_frames, win_length)\n                The tempogram\n        '''\n        n_frames = self.n_frames(get_duration(y=y, sr=self.sr))\n\n        tgram = tempogram(y=y, sr=self.sr,\n                          hop_length=self.hop_length,\n                          win_length=self.win_length).astype(np.float32)\n\n        tgram = fix_length(tgram, n_frames)\n        return {'tempogram': tgram.T[self.idx]}", "response": "Compute the tempogram of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef transform_audio(self, y):\n        '''Apply the scale transform to the tempogram\n\n        Parameters\n        ----------\n        y : np.ndarray\n            The audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['temposcale'] : np.ndarray, shape=(n_frames, n_fmt)\n                The scale transform magnitude coefficients\n        '''\n        data = super(TempoScale, self).transform_audio(y)\n        data['temposcale'] = np.abs(fmt(data.pop('tempogram'),\n                                        axis=1,\n                                        n_fmt=self.n_fmt)).astype(np.float32)[self.idx]\n        return data", "response": "Apply the scale transform to the tempogram\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\napplies the structure agreement transformation.", "response": "def transform_annotation(self, ann, duration):\n        '''Apply the structure agreement transformation.\n\n        Parameters\n        ----------\n        ann : jams.Annotation\n            The segment annotation\n\n        duration : number > 0\n            The target duration\n\n        Returns\n        -------\n        data : dict\n            data['agree'] : np.ndarray, shape=(n, n), dtype=bool\n        '''\n\n        intervals, values = ann.to_interval_values()\n\n        intervals, values = adjust_intervals(intervals, values,\n                                             t_min=0, t_max=duration)\n        # Re-index the labels\n        ids, _ = index_labels(values)\n\n        rate = float(self.hop_length) / self.sr\n        # Sample segment labels on our frame grid\n        _, labels = intervals_to_samples(intervals, ids, sample_size=rate)\n\n        # Make the agreement matrix\n        return {'agree': np.equal.outer(labels, labels)}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef transform_audio(self, y):\n        '''Compute the STFT magnitude and phase.\n\n        Parameters\n        ----------\n        y : np.ndarray\n            The audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['mag'] : np.ndarray, shape=(n_frames, 1 + n_fft//2)\n                STFT magnitude\n\n            data['phase'] : np.ndarray, shape=(n_frames, 1 + n_fft//2)\n                STFT phase\n        '''\n        n_frames = self.n_frames(get_duration(y=y, sr=self.sr))\n\n        D = stft(y, hop_length=self.hop_length,\n                 n_fft=self.n_fft)\n\n        D = fix_length(D, n_frames)\n\n        mag, phase = magphase(D)\n        if self.log:\n            mag = amplitude_to_db(mag, ref=np.max)\n\n        return {'mag': mag.T[self.idx].astype(np.float32),\n                'phase': np.angle(phase.T)[self.idx].astype(np.float32)}", "response": "Compute the STFT magnitude and phase of the audio buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef transform_audio(self, y):\n        '''Compute the STFT with phase differentials.\n\n        Parameters\n        ----------\n        y : np.ndarray\n            the audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['mag'] : np.ndarray, shape=(n_frames, 1 + n_fft//2)\n                The STFT magnitude\n\n            data['dphase'] : np.ndarray, shape=(n_frames, 1 + n_fft//2)\n                The unwrapped phase differential\n        '''\n        data = super(STFTPhaseDiff, self).transform_audio(y)\n        data['dphase'] = self.phase_diff(data.pop('phase'))\n        return data", "response": "Compute the STFT with phase differentials."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the STFT data from the audio data.", "response": "def transform_audio(self, y):\n        '''Compute the STFT\n\n        Parameters\n        ----------\n        y : np.ndarray\n            The audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['mag'] : np.ndarray, shape=(n_frames, 1 + n_fft//2)\n                The STFT magnitude\n        '''\n        data = super(STFTMag, self).transform_audio(y)\n        data.pop('phase')\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _pad_nochord(target, axis=-1):\n    '''Pad a chord annotation with no-chord flags.\n\n    Parameters\n    ----------\n    target : np.ndarray\n        the input data\n\n    axis : int\n        the axis along which to pad\n\n    Returns\n    -------\n    target_pad\n        `target` expanded by 1 along the specified `axis`.\n        The expanded dimension will be 0 when `target` is non-zero\n        before padding, and 1 otherwise.\n    '''\n    ncmask = ~np.max(target, axis=axis, keepdims=True)\n\n    return np.concatenate([target, ncmask], axis=axis)", "response": "Pad a chord annotation with no - chord flags."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef empty(self, duration):\n        '''Empty chord annotations\n\n        Parameters\n        ----------\n        duration : number\n            The length (in seconds) of the empty annotation\n\n        Returns\n        -------\n        ann : jams.Annotation\n            A chord annotation consisting of a single `no-chord` observation.\n        '''\n        ann = super(ChordTransformer, self).empty(duration)\n\n        ann.append(time=0,\n                   duration=duration,\n                   value='N', confidence=0)\n\n        return ann", "response": "Empty chord annotations\n\n        Parameters\n        ----------\n        duration : number\n            The length (in seconds) of the empty annotation\n\n        Returns\n        -------\n        ann : jams.Annotation\n            A chord annotation consisting of a single `no-chord` observation."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\napplies the chord transformation.", "response": "def transform_annotation(self, ann, duration):\n        '''Apply the chord transformation.\n\n        Parameters\n        ----------\n        ann : jams.Annotation\n            The chord annotation\n\n        duration : number > 0\n            The target duration\n\n        Returns\n        -------\n        data : dict\n            data['pitch'] : np.ndarray, shape=(n, 12)\n            data['root'] : np.ndarray, shape=(n, 13) or (n, 1)\n            data['bass'] : np.ndarray, shape=(n, 13) or (n, 1)\n\n            `pitch` is a binary matrix indicating pitch class\n            activation at each frame.\n\n            `root` is a one-hot matrix indicating the chord\n            root's pitch class at each frame.\n\n            `bass` is a one-hot matrix indicating the chord\n            bass (lowest note) pitch class at each frame.\n\n            If sparsely encoded, `root` and `bass` are integers\n            in the range [0, 12] where 12 indicates no chord.\n\n            If densely encoded, `root` and `bass` have an extra\n            final dimension which is active when there is no chord\n            sounding.\n        '''\n        # Construct a blank annotation with mask = 0\n        intervals, chords = ann.to_interval_values()\n\n        # Get the dtype for root/bass\n        if self.sparse:\n            dtype = np.int\n        else:\n            dtype = np.bool\n\n        # If we don't have any labeled intervals, fill in a no-chord\n        if not chords:\n            intervals = np.asarray([[0, duration]])\n            chords = ['N']\n\n        # Suppress all intervals not in the encoder\n        pitches = []\n        roots = []\n        basses = []\n\n        # default value when data is missing\n        if self.sparse:\n            fill = 12\n        else:\n            fill = False\n\n        for chord in chords:\n            # Encode the pitches\n            root, semi, bass = mir_eval.chord.encode(chord)\n            pitches.append(np.roll(semi, root))\n\n            if self.sparse:\n                if root in self._classes:\n                    roots.append([root])\n                    basses.append([(root + bass) % 12])\n                else:\n                    roots.append([fill])\n                    basses.append([fill])\n            else:\n                if root in self._classes:\n                    roots.extend(self.encoder.transform([[root]]))\n                    basses.extend(self.encoder.transform([[(root + bass) % 12]]))\n                else:\n                    roots.extend(self.encoder.transform([[]]))\n                    basses.extend(self.encoder.transform([[]]))\n\n        pitches = np.asarray(pitches, dtype=np.bool)\n        roots = np.asarray(roots, dtype=dtype)\n        basses = np.asarray(basses, dtype=dtype)\n\n        target_pitch = self.encode_intervals(duration, intervals, pitches)\n\n        target_root = self.encode_intervals(duration, intervals, roots,\n                                            multi=False,\n                                            dtype=dtype,\n                                            fill=fill)\n        target_bass = self.encode_intervals(duration, intervals, basses,\n                                            multi=False,\n                                            dtype=dtype,\n                                            fill=fill)\n\n        if not self.sparse:\n            target_root = _pad_nochord(target_root)\n            target_bass = _pad_nochord(target_bass)\n\n        return {'pitch': target_pitch,\n                'root': target_root,\n                'bass': target_bass}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef transform_annotation(self, ann, duration):\n        '''Apply the chord transformation.\n\n        Parameters\n        ----------\n        ann : jams.Annotation\n            The chord annotation\n\n        duration : number > 0\n            The target duration\n\n        Returns\n        -------\n        data : dict\n            data['pitch'] : np.ndarray, shape=(n, 12)\n\n            `pitch` is a binary matrix indicating pitch class\n            activation at each frame.\n        '''\n        data = super(SimpleChordTransformer,\n                     self).transform_annotation(ann, duration)\n\n        data.pop('root', None)\n        data.pop('bass', None)\n        return data", "response": "Apply the chord transformation."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_transition(self, p_self):\n        '''Set the transition matrix according to self-loop probabilities.\n\n        Parameters\n        ----------\n        p_self : None, float in (0, 1), or np.ndarray [shape=(n_labels,)]\n            Optional self-loop probability(ies), used for Viterbi decoding\n        '''\n        if p_self is None:\n            self.transition = None\n        else:\n            self.transition = transition_loop(len(self._classes), p_self)", "response": "Set the transition matrix according to self - loop probabilities."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsimplify a chord string down to the vocabulary space", "response": "def simplify(self, chord):\n        '''Simplify a chord string down to the vocabulary space'''\n        # Drop inversions\n        chord = re.sub(r'/.*$', r'', chord)\n        # Drop any additional or suppressed tones\n        chord = re.sub(r'\\(.*?\\)', r'', chord)\n        # Drop dangling : indicators\n        chord = re.sub(r':$', r'', chord)\n\n        # Encode the chord\n        root, pitches, _ = mir_eval.chord.encode(chord)\n\n        # Build the query\n        # To map the binary vector pitches down to bit masked integer,\n        # we just dot against powers of 2\n        P = 2**np.arange(12, dtype=int)\n        query = self.mask_ & pitches[::-1].dot(P)\n\n        if root < 0 and chord[0].upper() == 'N':\n            return 'N'\n        if query not in QUALITIES:\n            return 'X'\n\n        return '{}:{}'.format(PITCHES[root], QUALITIES[query])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntransforming an annotation to chord - tag encoding", "response": "def transform_annotation(self, ann, duration):\n        '''Transform an annotation to chord-tag encoding\n\n        Parameters\n        ----------\n        ann : jams.Annotation\n            The annotation to convert\n\n        duration : number > 0\n            The duration of the track\n\n        Returns\n        -------\n        data : dict\n            data['chord'] : np.ndarray, shape=(n, n_labels)\n                A time-varying binary encoding of the chords\n        '''\n\n        intervals, values = ann.to_interval_values()\n\n        chords = []\n        for v in values:\n            chords.extend(self.encoder.transform([self.simplify(v)]))\n\n        dtype = self.fields[self.scope('chord')].dtype\n\n        chords = np.asarray(chords)\n\n        if self.sparse:\n            chords = chords[:, np.newaxis]\n\n        target = self.encode_intervals(duration, intervals, chords,\n                                       multi=False, dtype=dtype)\n\n        return {'chord': target}"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the CQT magnitude and phase of the audio buffer.", "response": "def transform_audio(self, y):\n        '''Compute the CQT\n\n        Parameters\n        ----------\n        y : np.ndarray\n            The audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['mag'] : np.ndarray, shape = (n_frames, n_bins)\n                The CQT magnitude\n\n            data['phase']: np.ndarray, shape = mag.shape\n                The CQT phase\n        '''\n        n_frames = self.n_frames(get_duration(y=y, sr=self.sr))\n\n        C = cqt(y=y, sr=self.sr, hop_length=self.hop_length,\n                fmin=self.fmin,\n                n_bins=(self.n_octaves * self.over_sample * 12),\n                bins_per_octave=(self.over_sample * 12))\n\n        C = fix_length(C, n_frames)\n\n        cqtm, phase = magphase(C)\n        if self.log:\n            cqtm = amplitude_to_db(cqtm, ref=np.max)\n\n        return {'mag': cqtm.T.astype(np.float32)[self.idx],\n                'phase': np.angle(phase).T.astype(np.float32)[self.idx]}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing CQT magnitude. Parameters ---------- y : np.ndarray the audio buffer Returns ------- data : dict data['mag'] : np.ndarray, shape=(n_frames, n_bins) The CQT magnitude", "response": "def transform_audio(self, y):\n        '''Compute CQT magnitude.\n\n        Parameters\n        ----------\n        y : np.ndarray\n            the audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['mag'] : np.ndarray, shape=(n_frames, n_bins)\n                The CQT magnitude\n        '''\n        data = super(CQTMag, self).transform_audio(y)\n        data.pop('phase')\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the CQT with unwrapped phase", "response": "def transform_audio(self, y):\n        '''Compute the CQT with unwrapped phase\n\n        Parameters\n        ----------\n        y : np.ndarray\n            The audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['mag'] : np.ndarray, shape=(n_frames, n_bins)\n                CQT magnitude\n\n            data['dphase'] : np.ndarray, shape=(n_frames, n_bins)\n                Unwrapped phase differential\n        '''\n        data = super(CQTPhaseDiff, self).transform_audio(y)\n        data['dphase'] = self.phase_diff(data.pop('phase'))\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transform_audio(self, y):\n        '''Compute the HCQT\n\n        Parameters\n        ----------\n        y : np.ndarray\n            The audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['mag'] : np.ndarray, shape = (n_frames, n_bins, n_harmonics)\n                The CQT magnitude\n\n            data['phase']: np.ndarray, shape = mag.shape\n                The CQT phase\n        '''\n        cqtm, phase = [], []\n\n        n_frames = self.n_frames(get_duration(y=y, sr=self.sr))\n\n        for h in self.harmonics:\n            C = cqt(y=y, sr=self.sr, hop_length=self.hop_length,\n                    fmin=self.fmin * h,\n                    n_bins=(self.n_octaves * self.over_sample * 12),\n                    bins_per_octave=(self.over_sample * 12))\n\n            C = fix_length(C, n_frames)\n\n            C, P = magphase(C)\n            if self.log:\n                C = amplitude_to_db(C, ref=np.max)\n            cqtm.append(C)\n            phase.append(P)\n\n        cqtm = np.asarray(cqtm).astype(np.float32)\n        phase = np.angle(np.asarray(phase)).astype(np.float32)\n\n        return {'mag': self._index(cqtm),\n                'phase': self._index(phase)}", "response": "Compute the HCQT magnitude and phase of the audio buffer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrearranging a tensor according to the convolution mode Input is assumed to be in ( channels bins time format.", "response": "def _index(self, value):\n        '''Rearrange a tensor according to the convolution mode\n\n        Input is assumed to be in (channels, bins, time) format.\n        '''\n\n        if self.conv in ('channels_last', 'tf'):\n            return np.transpose(value, (2, 1, 0))\n\n        else:  # self.conv in ('channels_first', 'th')\n            return np.transpose(value, (0, 2, 1))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef transform_audio(self, y):\n        '''Compute HCQT magnitude.\n\n        Parameters\n        ----------\n        y : np.ndarray\n            the audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['mag'] : np.ndarray, shape=(n_frames, n_bins)\n                The CQT magnitude\n        '''\n        data = super(HCQTMag, self).transform_audio(y)\n        data.pop('phase')\n        return data", "response": "Compute HCQT magnitude.\n\n        Parameters\n        ----------\n        y : np.ndarray\n            the audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['mag'] : np.ndarray, shape=(n_frames, n_bins)\n                The CQT magnitude"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef transform_audio(self, y):\n        '''Compute the HCQT with unwrapped phase\n\n        Parameters\n        ----------\n        y : np.ndarray\n            The audio buffer\n\n        Returns\n        -------\n        data : dict\n            data['mag'] : np.ndarray, shape=(n_frames, n_bins)\n                CQT magnitude\n\n            data['dphase'] : np.ndarray, shape=(n_frames, n_bins)\n                Unwrapped phase differential\n        '''\n        data = super(HCQTPhaseDiff, self).transform_audio(y)\n        data['dphase'] = self.phase_diff(data.pop('phase'))\n        return data", "response": "Compute the HCQT with unwrapped phase\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a fill - value for a given dtype", "response": "def fill_value(dtype):\n    '''Get a fill-value for a given dtype\n\n    Parameters\n    ----------\n    dtype : type\n\n    Returns\n    -------\n    `np.nan` if `dtype` is real or complex\n\n    0 otherwise\n    '''\n    if np.issubdtype(dtype, np.floating) or np.issubdtype(dtype, np.complexfloating):\n        return dtype(np.nan)\n\n    return dtype(0)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an empty jams. Annotation for this task.", "response": "def empty(self, duration):\n        '''Create an empty jams.Annotation for this task.\n\n        This method should be overridden by derived classes.\n\n        Parameters\n        ----------\n        duration : int >= 0\n            Duration of the annotation\n        '''\n        return jams.Annotation(namespace=self.namespace, time=0, duration=0)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntransforms the jam object to make data for this task.", "response": "def transform(self, jam, query=None):\n        '''Transform jam object to make data for this task\n\n        Parameters\n        ----------\n        jam : jams.JAMS\n            The jams container object\n\n        query : string, dict, or callable [optional]\n            An optional query to narrow the elements of `jam.annotations`\n            to be considered.\n\n            If not provided, all annotations are considered.\n\n        Returns\n        -------\n        data : dict\n            A dictionary of transformed annotations.\n            All annotations which can be converted to the target namespace\n            will be converted.\n        '''\n        anns = []\n        if query:\n            results = jam.search(**query)\n        else:\n            results = jam.annotations\n\n        # Find annotations that can be coerced to our target namespace\n        for ann in results:\n            try:\n                anns.append(jams.nsconvert.convert(ann, self.namespace))\n            except jams.NamespaceError:\n                pass\n\n        duration = jam.file_metadata.duration\n\n        # If none, make a fake one\n        if not anns:\n            anns = [self.empty(duration)]\n\n        # Apply transformations\n        results = []\n        for ann in anns:\n\n            results.append(self.transform_annotation(ann, duration))\n            # If the annotation range is None, it spans the entire track\n            if ann.time is None or ann.duration is None:\n                valid = [0, duration]\n            else:\n                valid = [ann.time, ann.time + ann.duration]\n\n            results[-1]['_valid'] = time_to_frames(valid, sr=self.sr,\n                                                   hop_length=self.hop_length)\n\n        # Prefix and collect\n        return self.merge(results)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nencode labeled events as a time - series matrix.", "response": "def encode_events(self, duration, events, values, dtype=np.bool):\n        '''Encode labeled events as a time-series matrix.\n\n        Parameters\n        ----------\n        duration : number\n            The duration of the track\n\n        events : ndarray, shape=(n,)\n            Time index of the events\n\n        values : ndarray, shape=(n, m)\n            Values array.  Must have the same first index as `events`.\n\n        dtype : numpy data type\n\n        Returns\n        -------\n        target : ndarray, shape=(n_frames, n_values)\n        '''\n\n        frames = time_to_frames(events, sr=self.sr,\n                                hop_length=self.hop_length)\n\n        n_total = int(time_to_frames(duration, sr=self.sr,\n                                     hop_length=self.hop_length))\n\n        n_alloc = n_total\n        if np.any(frames):\n            n_alloc = max(n_total, 1 + int(frames.max()))\n\n        target = np.empty((n_alloc, values.shape[1]),\n                          dtype=dtype)\n\n        target.fill(fill_value(dtype))\n        values = values.astype(dtype)\n        for column, event in zip(values, frames):\n            target[event] += column\n\n        return target[:n_total]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nencodes labeled intervals as a time - series matrix.", "response": "def encode_intervals(self, duration, intervals, values, dtype=np.bool,\n                         multi=True, fill=None):\n        '''Encode labeled intervals as a time-series matrix.\n\n        Parameters\n        ----------\n        duration : number\n            The duration (in frames) of the track\n\n        intervals : np.ndarray, shape=(n, 2)\n            The list of intervals\n\n        values : np.ndarray, shape=(n, m)\n            The (encoded) values corresponding to each interval\n\n        dtype : np.dtype\n            The desired output type\n\n        multi : bool\n            If `True`, allow multiple labels per interval.\n\n        fill : dtype (optional)\n            Optional default fill value for missing data.\n\n            If not provided, the default is inferred from `dtype`.\n\n        Returns\n        -------\n        target : np.ndarray, shape=(duration * sr / hop_length, m)\n            The labeled interval encoding, sampled at the desired frame rate\n        '''\n        if fill is None:\n            fill = fill_value(dtype)\n\n        frames = time_to_frames(intervals, sr=self.sr,\n                                hop_length=self.hop_length)\n\n        n_total = int(time_to_frames(duration, sr=self.sr,\n                                     hop_length=self.hop_length))\n\n        values = values.astype(dtype)\n\n        n_alloc = n_total\n        if np.any(frames):\n            n_alloc = max(n_total, 1 + int(frames.max()))\n\n        target = np.empty((n_alloc, values.shape[1]),\n\n                          dtype=dtype)\n\n        target.fill(fill)\n\n        for column, interval in zip(values, frames):\n            if multi:\n                target[interval[0]:interval[1]] += column\n            else:\n                target[interval[0]:interval[1]] = column\n\n        return target[:n_total]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef decode_events(self, encoded, transition=None, p_state=None, p_init=None):\n        '''Decode labeled events into (time, value) pairs\n\n        Real-valued inputs are thresholded at 0.5.\n\n        Optionally, viterbi decoding can be applied to each event class.\n\n        Parameters\n        ----------\n        encoded : np.ndarray, shape=(n_frames, m)\n            Frame-level annotation encodings as produced by ``encode_events``.\n\n        transition : None or np.ndarray [shape=(2, 2) or (m, 2, 2)]\n            Optional transition matrix for each event, used for Viterbi\n\n        p_state : None or np.ndarray [shape=(m,)]\n            Optional marginal probability for each event\n\n        p_init : None or np.ndarray [shape=(m,)]\n            Optional marginal probability for each event\n\n        Returns\n        -------\n        [(time, value)] : iterable of tuples\n            where `time` is the event time and `value` is an\n            np.ndarray, shape=(m,) of the encoded value at that time\n\n        See Also\n        --------\n        librosa.sequence.viterbi_binary\n        '''\n        if np.isrealobj(encoded):\n            if transition is None:\n                encoded = (encoded >= 0.5)\n            else:\n                encoded = viterbi_binary(encoded.T, transition,\n                                         p_state=p_state,\n                                         p_init=p_init).T\n\n        times = times_like(encoded,\n                           sr=self.sr,\n                           hop_length=self.hop_length,\n                           axis=0)\n\n        return zip(times, encoded)", "response": "Decode labeled events into time value pairs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decode_intervals(self, encoded, duration=None, multi=True, sparse=False,\n                         transition=None, p_state=None, p_init=None):\n        '''Decode labeled intervals into (start, end, value) triples\n\n        Parameters\n        ----------\n        encoded : np.ndarray, shape=(n_frames, m)\n            Frame-level annotation encodings as produced by\n            ``encode_intervals``\n\n        duration : None or float > 0\n            The max duration of the annotation (in seconds)\n            Must be greater than the length of encoded array.\n\n        multi : bool\n            If true, allow multiple labels per input frame.\n            If false, take the most likely label per input frame.\n\n        sparse : bool\n            If true, values are returned as indices, not one-hot.\n            If false, values are returned as one-hot encodings.\n\n            Only applies when `multi=False`.\n\n        transition : None or np.ndarray [shape=(m, m) or (2, 2) or (m, 2, 2)]\n            Optional transition matrix for each interval, used for Viterbi\n            decoding.  If `multi=True`, then transition should be `(2, 2)` or\n            `(m, 2, 2)`-shaped.  If `multi=False`, then transition should be\n            `(m, m)`-shaped.\n\n        p_state : None or np.ndarray [shape=(m,)]\n            Optional marginal probability for each label.\n\n        p_init : None or np.ndarray [shape=(m,)]\n            Optional marginal probability for each label.\n\n        Returns\n        -------\n        [(start, end, value)] : iterable of tuples\n            where `start` and `end` are the interval boundaries (in seconds)\n            and `value` is an np.ndarray, shape=(m,) of the encoded value\n            for this interval.\n        '''\n        if np.isrealobj(encoded):\n            if multi:\n                if transition is None:\n                    encoded = encoded >= 0.5\n                else:\n                    encoded = viterbi_binary(encoded.T, transition,\n                                             p_init=p_init, p_state=p_state).T\n            elif sparse and encoded.shape[1] > 1:\n                # map to argmax if it's densely encoded (logits)\n                if transition is None:\n                    encoded = np.argmax(encoded, axis=1)[:, np.newaxis]\n                else:\n                    encoded = viterbi_discriminative(encoded.T, transition,\n                                                     p_init=p_init,\n                                                     p_state=p_state)[:, np.newaxis]\n            elif not sparse:\n                # if dense and multi, map to one-hot encoding\n                if transition is None:\n                    encoded = (encoded == np.max(encoded, axis=1, keepdims=True))\n                else:\n                    encoded_ = viterbi_discriminative(encoded.T, transition,\n                                                      p_init=p_init,\n                                                      p_state=p_state)\n                    # Map to one-hot encoding\n                    encoded = np.zeros(encoded.shape, dtype=bool)\n                    encoded[np.arange(len(encoded_)), encoded_] = True\n\n        if duration is None:\n            # 1+ is fair here, because encode_intervals already pads\n            duration = 1 + encoded.shape[0]\n        else:\n            duration = 1 + time_to_frames(duration,\n                                          sr=self.sr,\n                                          hop_length=self.hop_length)\n\n        # [0, duration] inclusive\n        times = times_like(duration + 1,\n                           sr=self.sr, hop_length=self.hop_length)\n\n        # Find the change-points of the rows\n        if sparse:\n            idx = np.where(encoded[1:] != encoded[:-1])[0]\n        else:\n            idx = np.where(np.max(encoded[1:] != encoded[:-1], axis=-1))[0]\n\n        idx = np.unique(np.append(idx, encoded.shape[0]))\n        delta = np.diff(np.append(-1, idx))\n\n        # Starting positions can be integrated from changes\n        position = np.cumsum(np.append(0, delta))\n\n        return [(times[p], times[p + d], encoded[p])\n                for (p, d) in zip(position, delta)]", "response": "Decode labeled intervals into start end value pairs."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntransform an audio signal y into a dictionary containing features extracted from y.", "response": "def transform(self, y, sr):\n        '''Transform an audio signal\n\n        Parameters\n        ----------\n        y : np.ndarray\n            The audio signal\n\n        sr : number > 0\n            The native sampling rate of y\n\n        Returns\n        -------\n        dict\n            Data dictionary containing features extracted from y\n\n        See Also\n        --------\n        transform_audio\n        '''\n        if sr != self.sr:\n            y = resample(y, sr, self.sr)\n\n        return self.merge([self.transform_audio(y)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes the phase differential along a given axis", "response": "def phase_diff(self, phase):\n        '''Compute the phase differential along a given axis\n\n        Parameters\n        ----------\n        phase : np.ndarray\n            Input phase (in radians)\n\n        Returns\n        -------\n        dphase : np.ndarray like `phase`\n            The phase differential.\n        '''\n\n        if self.conv is None:\n            axis = 0\n        elif self.conv in ('channels_last', 'tf'):\n            axis = 0\n        elif self.conv in ('channels_first', 'th'):\n            axis = 1\n\n        # Compute the phase differential\n        dphase = np.empty(phase.shape, dtype=phase.dtype)\n        zero_idx = [slice(None)] * phase.ndim\n        zero_idx[axis] = slice(1)\n        else_idx = [slice(None)] * phase.ndim\n        else_idx[axis] = slice(1, None)\n        zero_idx = tuple(zero_idx)\n        else_idx = tuple(else_idx)\n        dphase[zero_idx] = phase[zero_idx]\n        dphase[else_idx] = np.diff(np.unwrap(phase, axis=axis), axis=axis)\n        return dphase"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef layers(self):\n        '''Construct Keras input layers for the given transformer\n\n        Returns\n        -------\n        layers : {field: keras.layers.Input}\n            A dictionary of keras input layers, keyed by the corresponding\n            field keys.\n        '''\n        from keras.layers import Input\n\n        L = dict()\n        for key in self.fields:\n            L[key] = Input(name=key,\n                           shape=self.fields[key].shape,\n                           dtype=self.fields[key].dtype)\n\n        return L", "response": "Construct Keras input layers for the given transformer\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef n_frames(self, duration):\n        '''Get the number of frames for a given duration\n\n        Parameters\n        ----------\n        duration : number >= 0\n            The duration, in seconds\n\n        Returns\n        -------\n        n_frames : int >= 0\n            The number of frames at this extractor's sampling rate and\n            hop length\n        '''\n\n        return int(time_to_frames(duration, sr=self.sr,\n                                  hop_length=self.hop_length))", "response": "Get the number of frames for a given duration"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef start(component, exact):\n    # type: (str, str) -> None\n    \"\"\" Create a new release branch.\n\n    Args:\n        component (str):\n            Version component to bump when creating the release. Can be *major*,\n            *minor* or *patch*.\n        exact (str):\n            The exact version to set for the release. Overrides the component\n            argument. This allows to re-release a version if something went\n            wrong with the release upload.\n    \"\"\"\n    version_file = conf.get_path('version_file', 'VERSION')\n\n    develop = conf.get('git.devel_branch', 'develop')\n    common.assert_on_branch(develop)\n\n    with conf.within_proj_dir():\n        out = shell.run('git status --porcelain', capture=True).stdout\n        lines = out.split(os.linesep)\n        has_changes = any(\n            not l.startswith('??') for l in lines if l.strip()\n        )\n\n    if has_changes:\n        log.info(\"Cannot release: there are uncommitted changes\")\n        exit(1)\n\n    old_ver, new_ver = versioning.bump(component, exact)\n\n    log.info(\"Bumping package version\")\n    log.info(\"  old version: <35>{}\".format(old_ver))\n    log.info(\"  new version: <35>{}\".format(new_ver))\n\n    with conf.within_proj_dir():\n        branch = 'release/' + new_ver\n\n        common.git_checkout(branch, create=True)\n\n        log.info(\"Creating commit for the release\")\n        shell.run('git add {ver_file} && git commit -m \"{msg}\"'.format(\n            ver_file=version_file,\n            msg=\"Releasing v{}\".format(new_ver)\n        ))", "response": "Create a new release branch."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntagging the current commit with the current version.", "response": "def tag(message):\n    # type: () -> None\n    \"\"\" Tag the current commit with the current version. \"\"\"\n    release_ver = versioning.current()\n    message = message or 'v{} release'.format(release_ver)\n\n    with conf.within_proj_dir():\n        log.info(\"Creating release tag\")\n        git.tag(\n            author=git.latest_commit().author,\n            name='v{}'.format(release_ver),\n            message=message,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlint python files. Args: exclude (list[str]): A list of glob string patterns to test against. If the file/path matches any of those patters, it will be filtered out. skip_untracked (bool): If set to **True** it will skip all files not tracked by git. commit_only (bool): Only lint files that are staged for commit.", "response": "def lint(exclude, skip_untracked, commit_only):\n    # type: (List[str], bool, bool) -> None\n    \"\"\" Lint python files.\n\n    Args:\n        exclude (list[str]):\n            A list of glob string patterns to test against. If the file/path\n            matches any of those patters, it will be filtered out.\n        skip_untracked (bool):\n            If set to **True** it will skip all files not tracked by git.\n        commit_only (bool):\n            Only lint files that are staged for commit.\n    \"\"\"\n    exclude = list(exclude) + conf.get('lint.exclude', [])\n    runner = LintRunner(exclude, skip_untracked, commit_only)\n\n    if not runner.run():\n        exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pep8_check(files):\n    # type: (List[str]) -> int\n    \"\"\" Run code checks using pep8.\n\n    Args:\n        files (list[str]):\n            A list of files to check\n\n    Returns:\n        bool: **True** if all files passed the checks, **False** otherwise.\n\n    pep8 tool is **very** fast. Especially compared to pylint and the bigger the\n    code base the bigger the difference. If you want to reduce check times you\n    might disable all pep8 checks in pylint and use pep8 for that. This way you\n    use pylint only for the more advanced checks (the number of checks enabled\n    in pylint will make a visible difference in it's run times).\n    \"\"\"\n    files = fs.wrap_paths(files)\n    cfg_path = conf.get_path('lint.pep8_cfg', 'ops/tools/pep8.ini')\n    pep8_cmd = 'pep8 --config {} {}'.format(cfg_path, files)\n\n    return shell.run(pep8_cmd, exit_on_error=False).return_code", "response": "Run code checks using pep8."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning code checks using pylint.", "response": "def pylint_check(files):\n    # type: (List[str]) -> int\n    \"\"\" Run code checks using pylint.\n\n    Args:\n        files (list[str]):\n            A list of files to check\n\n    Returns:\n        bool: **True** if all files passed the checks, **False** otherwise.\n    \"\"\"\n    files = fs.wrap_paths(files)\n    cfg_path = conf.get_path('lint.pylint_cfg', 'ops/tools/pylint.ini')\n    pylint_cmd = 'pylint --rcfile {} {}'.format(cfg_path, files)\n\n    return shell.run(pylint_cmd, exit_on_error=False).return_code"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns all linters and report results.", "response": "def run(self):\n        # type: () -> bool\n        \"\"\" Run all linters and report results.\n\n        Returns:\n            bool: **True** if all checks were successful, **False** otherwise.\n        \"\"\"\n        with util.timed_block() as t:\n            files = self._collect_files()\n\n        log.info(\"Collected <33>{} <32>files in <33>{}s\".format(\n            len(files), t.elapsed_s\n        ))\n        if self.verbose:\n            for p in files:\n                log.info(\"  <0>{}\", p)\n\n        # No files to lint - return success if empty runs are allowed.\n        if not files:\n            return self.allow_empty\n\n        with util.timed_block() as t:\n            results = self._run_checks(files)\n\n        log.info(\"Code checked in <33>{}s\", t.elapsed_s)\n\n        success = True\n        for name, retcodes in results.items():\n            if any(x != 0 for x in retcodes):\n                success = False\n                log.err(\"<35>{} <31>failed with: <33>{}\".format(\n                    name, retcodes\n                ))\n\n        return success"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_to_azure(instance, data, replace=True, types=None, primary_key=(), sub_commit=True):\n\n    # Time initialization\n    start = datetime.datetime.now()\n\n    # Extract info\n    rows = data[\"rows\"]\n    if not rows:\n        return 0\n    table_name = data[\"table_name\"]\n    columns_name = data[\"columns_name\"]\n    total_len_data = len(rows)\n\n    # Create table if needed\n    if not existing_test(instance, table_name) or (types is not None) or (primary_key != ()):\n        create.create_table(instance, data, primary_key, types)\n\n    # Clean table if needed\n    if replace:\n        cleaning_function(instance, table_name)\n\n    connection_kwargs = credential(instance)\n\n    # Create an SSH tunnel\n    ssh_host = os.environ.get(\"SSH_%s_HOST\" % instance)\n    ssh_user = os.environ.get(\"SSH_%s_USER\" % instance)\n    ssh_path_private_key = os.environ.get(\"SSH_%s_PATH_PRIVATE_KEY\" % instance)\n    if ssh_host:\n        tunnel = SSHTunnelForwarder(\n            (ssh_host, 22),\n            ssh_username=ssh_user,\n            ssh_private_key=ssh_path_private_key,\n            remote_bind_address=(\n                os.environ.get(\"AZURE_%s_HOST\" % instance), int(os.environ.get(\"AZURE_%s_PORT\" % instance))),\n            local_bind_address=('localhost', 1433),  # could be any available port\n        )\n        # Start the tunnel\n        try:\n            tunnel.start()\n            print(\"Tunnel opened!\")\n        except sshtunnel.HandlerSSHTunnelForwarderError:\n            pass\n\n        connection_kwargs[\"host\"] = \"localhost,1433\"\n        connection_kwargs[\"port\"] = 1433\n\n    cnxn = pyodbc.connect(**connection_kwargs)\n    cursor = cnxn.cursor()\n\n    small_batch_size = int(2099 / len(columns_name))\n\n    print(\"Initiate send_to_azure...\")\n\n    # Initialize counters\n    boolean = True\n    question_mark_pattern = \"(%s)\" % \",\".join([\"?\" for i in range(len(rows[0]))])\n    counter = 0\n    while boolean:\n        temp_row = []\n        question_mark_list = []\n        for i in range(small_batch_size):\n            if rows:\n                temp_row.append(rows.pop())\n                question_mark_list.append(question_mark_pattern)\n            else:\n                boolean = False\n                continue\n        counter = counter + len(temp_row)\n        # percent = round(float(counter * 100) / total_len_data)\n        if sub_commit:\n            suffix = \"%% rows sent\"\n            print_progress_bar(counter, total_len_data, suffix=suffix)\n            # print(\"%s %% rows sent\" % str(percent))\n        else:\n            suffix = \"% rows prepared to be sent\"\n            print_progress_bar(counter, total_len_data, suffix=suffix)\n            # print(\"%s %% rows prepared to be sent\" % str(percent))\n        data_values_str = ','.join(question_mark_list)\n        columns_name_str = \", \".join(columns_name)\n        inserting_request = '''INSERT INTO %s (%s) VALUES %s ;''' % (table_name, columns_name_str, data_values_str)\n\n        final_data = [y for x in temp_row for y in x]\n        if final_data:\n            cursor.execute(inserting_request, final_data)\n\n        if sub_commit:\n            commit_function(cnxn)\n    if not sub_commit:\n        commit_function(cnxn)\n    cursor.close()\n    cnxn.close()\n\n    if ssh_host:\n        tunnel.close()\n        print(\"Tunnel closed!\")\n\n    print(\"data sent to azure\")\n    print(\"Total rows: %s\" % str(total_len_data))\n    print(C.BOLD + \"Total time in seconds : %s\" % str((datetime.datetime.now() - start).seconds) + C.ENDC)\n    return 0", "response": "Send data to the Azure Cloud"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a standard python Dict with computed values from the DynDict", "response": "def getdict(source):\n    \"\"\"Returns a standard python Dict with computed values\n    from the DynDict\n    :param source: (DynDict) input\n    :return: (dict) Containing computed values\n    \"\"\"\n    std_dict = {}\n    for var, val in source.iteritems():\n        std_dict[var] = source[var]\n    return std_dict"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef enrich_app(self, name, value):\n        '''\n        Add a new property to the app (with setattr)\n\n        Args:\n            name (str): the name of the new property\n            value (any): the value of the new property\n        '''\n        #Method shouldn't be added:  https://stackoverflow.com/a/28060251/3042398\n        if type(value) == type(self.enrich_app):\n            raise ValueError(\"enrich_app can't add method\")\n\n        setattr(self.app, name, value)", "response": "Add a new property to the app with setattr"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a new node with the least squares linear fit.", "response": "def linfit(x_true, y, sigmay=None, relsigma=True, cov=False, chisq=False, residuals=False):\n    \"\"\"\n    Least squares linear fit.\n     \n    Fit a straight line `f(x_true) = a + bx` to points `(x_true, y)`.  Returns\n    coefficients `a` and `b` that minimize the squared error.\n     \n    Parameters\n    ----------\n    x_true : array_like\n        one dimensional array of `x_true` data with `n`>2 data points.\n    y : array_like\n        one dimensional array of `y` data with `n`>2 data points.\n    sigmay : NoneType or float or array_like, optional\n        one dimensional array of uncertainties (errors) in `y` data or a single\n        positive number if all uncertainties are the same.  `sigmay` determines\n        the weighting in the least squares minimization. Leaving `sigmay=None`\n        uses no weighting and is equivalent to `sigmay=1`.\n    relsigma : bool, optional\n        If `relsigma` is True, the residuals are used to scale the covariance\n        matrix.  Use this option if you do not know the absolute uncertainties\n        (`sigmay`) in the data but still want a covariance matrix whose entries\n        give meaningful estimates of the uncertainties in the fitting parameters\n        `a` and `b` (from `f = a + bx`).  If `relsigma` is False, the covariance\n        matrix is calculated (provided `cov` = True) using sigmay assuming\n        sigmay represents absolute undertainties.\n    cov : bool, optional\n        If True, calculate and return the 2x2 covarience matrix of the fitting\n        parameters.\n    chisq : bool, optional\n        If True, calculate and return redchisq.\n    residuals : bool, optional\n        If True, calculate and return residuals.\n     \n    Returns\n    -------\n    fit : array([a,b]) ndarray of floats\n        The best fit model parameters `a` (the slope) and `b` (the\n        `y`-intercept) for the input data arrays `x_true` and `y`\n        \n    cvm : array, shape (2,2) : returned only if cov=True\n        Covarience matrix of the fitting parameters.  Diagonal elements are\n        estimated variances of the fitting parameters a and b; square roots of\n        the diagonal elements thus provide estimates of the uncertainties in the\n        fitting parameters `a` and `b`. Off diagonal elements (equal to each\n        other) are the covarience between the fitting parameters `a` and `b`.\n           \n    redchisq : float : returned only if chisq=True\n        Reduced chi-squared goodness of fit parameter.\n         \n    residuals : ndarray of floats : returned only if residuals=True\n        Length n array of the differences `y-(ax+b)` between `y`-data and the\n        fitted data `ax + b`.\n \n    Raises\n    ------\n    TypeError : if `x_true` and `y` have different lengths\n    TypeError : If `x_true` and `y` have 2 or fewer elements\n    TypeError : If `sigmay` length is not 1 or the same as `y`\n \n    See Also\n    --------\n    polyfit : Least squares fit to polynomial.\n    linalg.lstsq : Least-squares solution to a linear matrix equation.\n                 \n    Notes\n    -----\n    By default, ``linfit`` returns optimal fitting parameters `a` and `b` without\n    weighting of the data.  In that case, linfit minimizes the squared error\n     \n    .. math ::\n        E = \\\\sum_{i=0}^n [y_i - (a x_i + b)]^2\n    \n    If `sigmay` is set equal to the uncertainties in the `y` data points, then\n    linfit minimizes the `chi-squared` sum \n      \n    .. math ::\n        \\chi^2 = \\\\sum_{i=0}^n \\\\left[ \\\\frac{y_i-(a x_i + b)}{\\\\sigma_i} \\\\right]^2\n \n    where :math:`\\sigma_i` is given by `sigmay`, the \"error\" or standard\n    deviation of :math:`y_i`.  `sigmay` can be either a single number that gives the\n    uncertainty for all elements of `y`, or it can be an array of the same\n    length as `y` that gives the \"error\" for each element of `y`.\n    `redchisq` is :math:`\\chi^2/(n-2)` where :math:`n` is the number of data\n    points (the length of `x_true` or `y`).\n     \n    If `relsigma` is False, then the uncertainties `sigmay` in `y` are\n    assumed to be the absolute one-standard-deviation uncertainties in `y`.\n    In this case, the reduced chi-squared value :math:`\\chi^2/(n-2)` provides a\n    measure of the goodness of the fit.  If it is near 1, then the linear\n    fitting model is considered to be good and the values of the covariance\n    matrix are appropriately scaled.  In particular, the square root of the\n    diagonal elements of the covariance matrix give the estimated uncertainty\n    in the fitting parameters `a` and `b`.  See Refernece [2] below for more\n    information. \n     \n    If `relsigma` is True, then the uncertainties `sigmay` in `y` are\n    considered to be only relative uncertainties.  They are used to weight\n    the data for the fit, but in this case, the covariance matrix is rescaled\n    using the residuals between the fit and the data.  In this case, the reduced\n    chi-squared value :math:`\\chi^2/(n-2)` does not provide a measure of the\n    goodness of the fit.  Nevertheless, the diagonal elements of the rescaled\n    covariance matrix (returned by linfit) give the estimated uncertainty in the\n    fitting parameters `a` and `b`.\n     \n    The covariance matrix is a 2x2 symmetric matrix where the diagonal elements\n    are the variance of the fitting parameters.  Their square roots provide\n    estimates of the uncertainties in the fitting parameters.  The off-diagonal\n    elements are equal and give the cross correlation between the two fitting\n    parameters `a` and `b`.\n     \n    linfit runs faster, by a factor of 2 to 3, if calculation of the residuals\n    is suppressed letting `cov`, `chisq`, and `residuals` remain False (the\n    default setting).\n     \n    Fitting a straight line to a single set of `(x_true, y)` data using ``linfit`` is\n    typically 2 to 10 times faster than using either ``polyfit`` or \n    ``linalg.lstsq``, especially when weighting is used and for very large data\n    sets.\n     \n    References\n    ----------\n    .. [1] An Introduction to Error Analysis, 2nd Ed. by John R. Taylor\n           (University Science Books, 1997)\n    .. [2] Numerical Recipes, The Art of Scientific Computing, 3rd Edition\n           by W.H. Press, S. A. Teukolsky, W. T. Vetterling, & B. P. Flannery\n           (Cambridge University Press, 2007)\n     \n    Examples\n    --------\n    Fit a line, `y = ax + b`, through some noisy `(x_true, y)` data-points without\n    any weighting (`sigmay` = None) to obtain fitting parameters `a` and `b`:\n     \n    >>> x_true = np.array([0, 1, 2, 3])\n    >>> y = np.array([-1, 0.2, 0.9, 2.1])\n    >>> fit = linfit(x_true, y)\n    >>> print(\"a = {0:0.2f}, b = {1:0.2f}\".format(fit[0], fit[1]))\n    a = 1.00, b = -0.95\n \n    Setting `cov` = True in the input, returns the covariance matrix `cvm`.\n    When uncertainties `sigmay` are left unspecified, meaningful estimates of\n    the uncertainties `da` and `db` in the fitting parameters `a` and `b`\n    are given by the square roots of the diagonals of the covariance matrix\n    `cvm`, provided `relsigma` = True (the default state).\n     \n    >>> fit, cvm = linfit(x_true, y, cov=True)\n    >>> dfit = [np.sqrt(cvm[i,i]) for i in range(2)]\n    >>> print(\"da = {0:0.2f}, db = {1:0.2f}\".format(dfit[0], dfit[1]))\n    da = 0.07, db = 0.13\n     \n    A better practice is to supply estimates of the uncertainties in the\n    input argument `sigmay`.  `sigmay` can be a single float, if the\n    uncertainties are the same for all data points, or it can be an array, if\n    the uncertainties for different data points are different.  Here we\n    enter sigmay as an array.\n     \n    >>> dy = np.array([0.18, 0.13, 0.15, 0.17])\n    >>> fit, cvm, redchisq, resids = linfit(x_true, y, cov=True, sigmay=dy, relsigma=False, chisq=True, residuals=True)\n    >>> print(\"a = {0:0.2f}, b = {1:0.2f}\".format(fit[0], fit[1]))\n    a = 0.98, b = -0.91\n    >>> dfit = [np.sqrt(cvm[i,i]) for i in range(2)]\n    >>> print(\"da = {0:0.2f}, db = {1:0.2f}\".format(dfit[0], dfit[1]))\n    da = 0.08, db = 0.14\n    >>> print(\"reduced chi-squared = {0:0.2f}\".format(redchisq))\n    reduced chi-squared = 1.21\n    >>> print(resids)\n    [-0.08856653  0.12781099 -0.1558115   0.06056602]\n     \n    The value of reduced chi-squared `redchisq` is 1.21 indicating that a\n    linear model is valid for these data.  The residuals :math:`y_i - (a+bx_i)`\n    are given by the output `resids`.\n     \n    If absolute estimates of the uncertainties are not available, but relative\n    estimates of the uncertainties are known, a fit can be obtained with \n    reasonable estimates of the uncertainties in the fitting parameters by\n    setting `relsigma` = True.\n     \n    >>> dy = np.array([1.0, 0.75, 0.75, 1.25])\n    >>> fit, cvm, redchisq = linfit(x_true, y, cov=True, sigmay=dy, relsigma=True, chisq=True)\n    >>> print(\"a = {0:0.2f}, b = {1:0.2f}\".format(fit[0], fit[1]))\n    a = 0.97, b = -0.91\n    >>> dfit = [np.sqrt(cvm[i,i]) for i in range(2)]\n    >>> print(\"da = {0:0.2f}, db = {1:0.2f}\".format(dfit[0], dfit[1]))\n    da = 0.09, db = 0.16\n    >>> print(\"reduced chi-squared = {0:0.2f}\".format(redchisq))\n    reduced chi-squared = 0.04\n     \n    In this case, the value `redchisq` is meaningless, because only the\n    relative, rather than the absolute uncertainties are known.  Nevertheless,\n    by setting `relsigma` = True, reasonable estimates for the uncertainties\n    in the fitting parameters are obtained.\n     \n    Illustration:\n         \n    .. image:: example.png\n        :scale: 75 %\n    \"\"\"\n \n    x_true = asarray(x_true)\n    y = asarray(y)\n    if x_true.size != y.size:\n        raise TypeError('Expected x_true and y to have same length')\n    if x_true.size <= 2:\n        raise TypeError('Expected x_true and y length > 2')\n    if sigmay is None: sigmay = 1.0\n    sigmay = asarray(sigmay)\n \n    if sigmay.size == 1:\n        sigy = float(sigmay)    # convert 0-d array to a float\n        wt = 1./(sigy*sigy)\n        s = wt * y.size\n        sx = wt * x_true.sum()\n        sy = wt * y.sum()\n        t = x_true-sx/s\n        stt = wt * (t*t).sum()\n        slope = wt * (t*y).sum()/stt\n        yint = (sy - sx * slope)/s\n    else:\n        if sigmay.size != y.size:\n            raise TypeError('Expected sigmay size to be 1 or same as y')\n        wt = 1./(sigmay*sigmay)\n        s = wt.sum()\n        sx = (x_true*wt).sum()\n        sy = (y*wt).sum()\n        t = (x_true-sx/s)/sigmay\n        stt = (t*t).sum()\n        slope = (t*y/sigmay).sum()/stt\n        yint = (sy - sx * slope)/s\n    returns = array([slope, yint])\n \n    if cov is True:\n        cvm00 = 1./stt\n        cvm01 = -sx/(s*stt)\n        cvm11 = (1.0-sx*cvm01)/s\n        if relsigma is True:\n            redchisq, resids = _resids(x_true, y, sigmay, slope, yint)\n            cvm00 *= redchisq\n            cvm01 *= redchisq\n            cvm11 *= redchisq\n        returns = [returns] + [array([[cvm00, cvm01],\n                                         [cvm01, cvm11]])]\n \n    if residuals or chisq is True:\n        if relsigma is False:\n            redchisq, resids = _resids(x_true, y, sigmay, slope, yint)\n        if type(returns) is not list:\n            returns = [returns]\n        if chisq is True:\n            returns += [redchisq]\n        if residuals is True:\n            returns += [resids]\n \n    return returns"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_base_url(self, platform: str = \"prod\"):\n        platform = platform.lower()\n        self.platform = platform\n        if platform == \"prod\":\n            ssl = True\n            logging.debug(\"Using production platform.\")\n        elif platform == \"qa\":\n            ssl = False\n            logging.debug(\"Using Quality Assurance platform (reduced perfs).\")\n        else:\n            logging.error(\n                \"Platform must be one of: {}\".format(\" | \".join(self.API_URLS.keys()))\n            )\n            raise ValueError(\n                3,\n                \"Platform must be one of: {}\".format(\" | \".join(self.API_URLS.keys())),\n            )\n        # method ending\n        return (\n            platform.lower(),\n            self.API_URLS.get(platform),\n            self.APP_URLS.get(platform),\n            self.CSW_URLS.get(platform),\n            self.MNG_URLS.get(platform),\n            self.OC_URLS.get(platform),\n            ssl,\n        )", "response": "Set Isogeo base URL according to platform."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a UUID to its URI equivalent.", "response": "def convert_uuid(self, in_uuid: str = str, mode: bool = 0):\n        \"\"\"Convert a metadata UUID to its URI equivalent. And conversely.\n\n        :param str in_uuid: UUID or URI to convert\n        :param int mode: conversion direction. Options:\n\n          * 0 to HEX\n          * 1 to URN (RFC4122)\n          * 2 to URN (Isogeo specific style)\n\n        \"\"\"\n        # parameters check\n        if not isinstance(in_uuid, str):\n            raise TypeError(\"'in_uuid' expected a str value.\")\n        else:\n            pass\n        if not checker.check_is_uuid(in_uuid):\n            raise ValueError(\"{} is not a correct UUID\".format(in_uuid))\n        else:\n            pass\n        if not isinstance(mode, int):\n            raise TypeError(\"'mode' expects an integer value\")\n        else:\n            pass\n        # handle Isogeo specific UUID in XML exports\n        if \"isogeo:metadata\" in in_uuid:\n            in_uuid = \"urn:uuid:{}\".format(in_uuid.split(\":\")[-1])\n            logging.debug(\"Isogeo UUUID URN spotted: {}\".format(in_uuid))\n        else:\n            pass\n        # operate\n        if mode == 0:\n            return uuid.UUID(in_uuid).hex\n        elif mode == 1:\n            return uuid.UUID(in_uuid).urn\n        elif mode == 2:\n            urn = uuid.UUID(in_uuid).urn\n            return \"urn:isogeo:metadata:uuid:{}\".format(urn.split(\":\")[2])\n        else:\n            raise ValueError(\"'mode' must be  one of: 0 | 1 | 2\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npull out the character set, encoding, and encoded text from the input encoded words. Next, it decodes the encoded words into a byte string, using either the quopri module or base64 module as determined by the encoding. Finally, it decodes the byte string using the character set and returns the result. See: - https://github.com/isogeo/isogeo-api-py-minsdk/issues/32 - https://dmorgan.info/posts/encoded-word-syntax/ :param str in_encoded_words: base64 or quori encoded character string.", "response": "def encoded_words_to_text(self, in_encoded_words: str):\n        \"\"\"Pull out the character set, encoding, and encoded text from the input\n        encoded words. Next, it decodes the encoded words into a byte string,\n        using either the quopri module or base64 module as determined by the\n        encoding. Finally, it decodes the byte string using the\n        character set and returns the result.\n\n        See:\n\n        - https://github.com/isogeo/isogeo-api-py-minsdk/issues/32\n        - https://dmorgan.info/posts/encoded-word-syntax/\n\n        :param str in_encoded_words: base64 or quori encoded character string.\n        \"\"\"\n        # handle RFC2047 quoting\n        if '\"' in in_encoded_words:\n            in_encoded_words = in_encoded_words.strip('\"')\n        # regex\n        encoded_word_regex = r\"=\\?{1}(.+)\\?{1}([B|Q])\\?{1}(.+)\\?{1}=\"\n        # pull out\n        try:\n            charset, encoding, encoded_text = re.match(\n                encoded_word_regex, in_encoded_words\n            ).groups()\n        except AttributeError:\n            logging.debug(\"Input text was not encoded into base64 or quori\")\n            return in_encoded_words\n\n        # decode depending on encoding\n        if encoding == \"B\":\n            byte_string = base64.b64decode(encoded_text)\n        elif encoding == \"Q\":\n            byte_string = quopri.decodestring(encoded_text)\n        return byte_string.decode(charset)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting Isogeo components versions. Authentication not required.", "response": "def get_isogeo_version(self, component: str = \"api\", prot: str = \"https\"):\n        \"\"\"Get Isogeo components versions. Authentication not required.\n\n        :param str component: which platform component. Options:\n\n          * api [default]\n          * db\n          * app\n\n        \"\"\"\n        # which component\n        if component == \"api\":\n            version_url = \"{}://v1.{}.isogeo.com/about\".format(prot, self.api_url)\n        elif component == \"db\":\n            version_url = \"{}://v1.{}.isogeo.com/about/database\".format(\n                prot, self.api_url\n            )\n        elif component == \"app\" and self.platform == \"prod\":\n            version_url = \"https://app.isogeo.com/about\"\n        elif component == \"app\" and self.platform == \"qa\":\n            version_url = \"https://qa-isogeo-app.azurewebsites.net/about\"\n        else:\n            raise ValueError(\n                \"Component value must be one of: \" \"api [default], db, app.\"\n            )\n\n        # send request\n        version_req = requests.get(version_url, proxies=self.proxies, verify=self.ssl)\n\n        # checking response\n        checker.check_api_response(version_req)\n\n        # end of method\n        return version_req.json().get(\"version\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_edit_url(\n        self,\n        md_id: str = None,\n        md_type: str = None,\n        owner_id: str = None,\n        tab: str = \"identification\",\n    ):\n        \"\"\"Constructs the edition URL of a metadata.\n\n        :param str md_id: metadata/resource UUID\n        :param str owner_id: owner UUID\n        :param str tab: target tab in the web form\n        \"\"\"\n        # checks inputs\n        if not checker.check_is_uuid(md_id) or not checker.check_is_uuid(owner_id):\n            raise ValueError(\"One of md_id or owner_id is not a correct UUID.\")\n        else:\n            pass\n        if checker.check_edit_tab(tab, md_type=md_type):\n            pass\n        # construct URL\n        return (\n            \"{}\"\n            \"/groups/{}\"\n            \"/resources/{}\"\n            \"/{}\".format(self.APP_URLS.get(self.platform), owner_id, md_id, tab)\n        )", "response": "Constructs the edition URL of a metadata."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconstructs the view URL of a metadata.", "response": "def get_view_url(self, webapp: str = \"oc\", **kwargs):\n        \"\"\"Constructs the view URL of a metadata.\n\n        :param str webapp: web app destination\n        :param dict kwargs: web app specific parameters. For example see WEBAPPS\n        \"\"\"\n        # build wbeapp URL depending on choosen webapp\n        if webapp in self.WEBAPPS:\n            webapp_args = self.WEBAPPS.get(webapp).get(\"args\")\n            # check kwargs parameters\n            if set(webapp_args) <= set(kwargs):\n                # construct and return url\n                url = self.WEBAPPS.get(webapp).get(\"url\")\n\n                return url.format(**kwargs)\n            else:\n                raise TypeError(\n                    \"'{}' webapp expects {} argument(s): {}.\"\n                    \" Args passed: {}\".format(\n                        webapp, len(webapp_args), webapp_args, kwargs\n                    )\n                )\n        else:\n            raise ValueError(\n                \"'{}' is not a recognized webapp among: {}.\"\n                \" Try to register it.\".format(self.WEBAPPS.keys(), webapp)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_webapp(self, webapp_name: str, webapp_args: list, webapp_url: str):\n        # check parameters\n        for arg in webapp_args:\n            if arg not in webapp_url:\n                raise ValueError(\n                    \"Inconsistent web app arguments and URL.\"\n                    \" It should contain arguments to replace\"\n                    \" dynamically. Example: 'http://webapp.com\"\n                    \"/isogeo?metadata={md_id}'\"\n                )\n        # register\n        self.WEBAPPS[webapp_name] = {\"args\": webapp_args, \"url\": webapp_url}", "response": "Register a new WEBAPP to use with the view URL builder."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_url_base_from_url_token(\n        self, url_api_token: str = \"https://id.api.isogeo.com/oauth/token\"\n    ):\n        \"\"\"Returns the Isogeo API root URL (which is not included into\n        credentials file) from the token URL (which is always included).\n\n        :param url_api_token str: url to Isogeo API ID token generator\n        \"\"\"\n        in_parsed = urlparse(url_api_token)\n        api_url_base = in_parsed._replace(\n            path=\"\", netloc=in_parsed.netloc.replace(\"id.\", \"\")\n        )\n        return api_url_base.geturl()", "response": "Returns the Isogeo API root URL from the Isogeo API ID token generator."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pages_counter(self, total: int, page_size: int = 100) -> int:\n        if total <= page_size:\n            count_pages = 1\n        else:\n            if (total % page_size) == 0:\n                count_pages = total / page_size\n            else:\n                count_pages = (total / page_size) + 1\n        # method ending\n        return int(count_pages)", "response": "Simple helper to handle pagination. Returns the number of pages for a specific number of results."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tags_to_dict(self, tags=dict, prev_query=dict, duplicated: str = \"rename\"):\n        # for rename option, get workgroups\n        if duplicated == \"rename\":\n            wgs = {k.split(\":\")[1]: v for k, v in tags.items() if k.startswith(\"owner\")}\n            # wgs = list(filter(lambda x[1]: x[0].startswith(\"owner\"), tags.items()))\n        elif duplicated == \"ignore\" or duplicated == \"merge\":\n            wgs = None\n        else:\n            raise ValueError(\n                \"Duplicated value is not an accepted value.\"\n                \" Please refer to __doc__ method.\"\n            )\n\n        # inner function\n        def _duplicate_mng(\n            target_dict: dict, duplicate, mode: str = duplicated, workgroups: dict = wgs\n        ):\n            if mode == \"merge\":\n                target_dict[duplicate[0]] += \"||\" + duplicate[1]\n            elif mode == \"rename\":\n                # get workgroup uuid\n                if checker.check_is_uuid(k.split(\":\")[1]):\n                    k_uuid = k.split(\":\")[1]\n                else:\n                    k_uuid = k.split(\":\")[2]\n                # match with workgroups owners\n                if k_uuid in workgroups:\n                    repl = workgroups.get(k_uuid)\n                else:\n                    repl = k_uuid[:5]\n                target_dict[\"{} ({})\".format(duplicate[0], repl)] = duplicate[1]\n            else:\n                pass\n            return\n\n        # -- SEARCH TAGS -------------\n        # output dicts structure\n        tags_as_dicts = {\n            \"actions\": {},\n            \"catalogs\": {},\n            \"contacts\": {},\n            \"data-sources\": {},\n            \"formats\": {},\n            \"inspires\": {},\n            \"keywords\": {},\n            \"licenses\": {},\n            \"owners\": {},\n            \"providers\": {},\n            \"shares\": {},\n            \"srs\": {},\n            \"types\": {},\n        }\n\n        # parsing tags and storing each one in a dict\n        for k, v in sorted(tags.items()):\n            if k.startswith(\"action\"):\n                tags_as_dicts.get(\"actions\")[v] = k\n                continue\n            elif k.startswith(\"catalog\"):\n                if v in tags_as_dicts.get(\"catalogs\") and duplicated != \"ignore\":\n                    _duplicate_mng(tags_as_dicts.get(\"catalogs\"), (v, k))\n                else:\n                    logging.debug(\n                        \"Duplicated catalog name: {}. Last catalog is retained.\".format(\n                            v\n                        )\n                    )\n                    tags_as_dicts.get(\"catalogs\")[v] = k\n                continue\n            elif k.startswith(\"contact\"):\n                if v in tags_as_dicts.get(\"contacts\") and duplicated != \"ignore\":\n                    _duplicate_mng(tags_as_dicts.get(\"contacts\"), (v, k))\n                else:\n                    logging.debug(\n                        \"Duplicated contact name: {}. Last contact is retained.\".format(\n                            v\n                        )\n                    )\n                    tags_as_dicts.get(\"contacts\")[v] = k\n                continue\n            elif k.startswith(\"coordinate-system\"):\n                tags_as_dicts.get(\"srs\")[v] = k\n                continue\n            elif k.startswith(\"data-source\"):\n                if v in tags_as_dicts.get(\"data-sources\") and duplicated != \"ignore\":\n                    _duplicate_mng(tags_as_dicts.get(\"data-sources\"), (v, k))\n                else:\n                    logging.debug(\n                        \"Duplicated data-source name: {}. Last data-source is retained.\".format(\n                            v\n                        )\n                    )\n                    tags_as_dicts.get(\"data-sources\")[v] = k\n                continue\n            elif k.startswith(\"format\"):\n                tags_as_dicts.get(\"formats\")[v] = k\n                continue\n            elif k.startswith(\"keyword:in\"):\n                tags_as_dicts.get(\"inspires\")[v] = k\n                continue\n            elif k.startswith(\"keyword:is\"):\n                tags_as_dicts.get(\"keywords\")[v] = k\n                continue\n            elif k.startswith(\"license\"):\n                if v in tags_as_dicts.get(\"licenses\") and duplicated != \"ignore\":\n                    _duplicate_mng(tags_as_dicts.get(\"licenses\"), (v, k))\n                else:\n                    logging.debug(\n                        \"Duplicated license name: {}. Last license is retained.\".format(\n                            v\n                        )\n                    )\n                    tags_as_dicts.get(\"licenses\")[v] = k\n                continue\n            elif k.startswith(\"owner\"):\n                tags_as_dicts.get(\"owners\")[v] = k\n                continue\n            elif k.startswith(\"provider\"):\n                # providers are particular bcause its value is always null.\n                tags_as_dicts.get(\"providers\")[k.split(\":\")[1]] = k\n                continue\n            elif k.startswith(\"share\"):\n                tags_as_dicts.get(\"shares\")[v] = k\n                continue\n            elif k.startswith(\"type\"):\n                tags_as_dicts.get(\"types\")[v] = k\n                continue\n            # ignored tags\n            else:\n                logging.debug(\"A tag has been ignored during parsing: {}\".format(k))\n\n        # -- QUERY TAGS -------------\n        # handle share case\n        if prev_query.get(\"_shares\"):\n            prev_query.get(\"_tags\").append(\n                \"share:{}\".format(prev_query.get(\"_shares\")[0])\n            )\n        else:\n            pass\n        # output dict struture\n        logging.debug(prev_query)\n        query_as_dicts = {\n            \"_tags\": {\n                \"actions\": {},\n                \"catalogs\": {},\n                \"contacts\": {},\n                \"data-sources\": {},\n                \"formats\": {},\n                \"inspires\": {},\n                \"keywords\": {},\n                \"licenses\": {},\n                \"owners\": {},\n                \"providers\": {},\n                \"shares\": {},\n                \"srs\": {},\n                \"types\": {},\n            },\n            \"_shares\": prev_query.get(\"_shares\"),\n            \"_terms\": prev_query.get(\"_terms\"),\n        }\n\n        # parsing and matching tags\n        query_tags = query_as_dicts.get(\"_tags\")\n        for t in prev_query.get(\"_tags\"):\n            if t.startswith(\"action\"):\n                query_tags.get(\"actions\")[tags.get(t)] = t\n                continue\n            elif t.startswith(\"catalog\"):\n                if v in query_tags.get(\"catalogs\") and duplicated != \"ignore\":\n                    _duplicate_mng(query_tags.get(\"catalogs\"), (v, k))\n                else:\n                    logging.debug(\n                        \"Duplicated catalog name: {}. Last catalog is retained.\".format(\n                            v\n                        )\n                    )\n                    query_tags.get(\"catalogs\")[tags.get(t)] = t\n                continue\n            elif t.startswith(\"contact\"):\n                if v in query_tags.get(\"contacts\") and duplicated != \"ignore\":\n                    _duplicate_mng(query_tags.get(\"contacts\"), (v, k))\n                else:\n                    logging.debug(\n                        \"Duplicated contact name: {}. Last contact is retained.\".format(\n                            v\n                        )\n                    )\n                    query_tags.get(\"contacts\")[tags.get(t)] = t\n                continue\n            elif t.startswith(\"coordinate-system\"):\n                query_tags.get(\"srs\")[tags.get(t)] = t\n                continue\n            elif t.startswith(\"data-source\"):\n                if v in query_tags.get(\"data-sources\") and duplicated != \"ignore\":\n                    _duplicate_mng(query_tags.get(\"data-sources\"), (v, k))\n                else:\n                    logging.debug(\n                        \"Duplicated data-source name: {}. Last data-source is retained.\".format(\n                            v\n                        )\n                    )\n                    query_tags.get(\"data-sources\")[tags.get(t)] = t\n                continue\n            elif t.startswith(\"format\"):\n                query_tags.get(\"formats\")[tags.get(t)] = t\n                continue\n            elif t.startswith(\"keyword:in\"):\n                query_tags.get(\"inspires\")[tags.get(t)] = t\n                continue\n            elif t.startswith(\"keyword:is\"):\n                query_tags.get(\"keywords\")[tags.get(t)] = t\n                continue\n            elif t.startswith(\"license\"):\n                if v in query_tags.get(\"licenses\") and duplicated != \"ignore\":\n                    _duplicate_mng(query_tags.get(\"licenses\"), (v, k))\n                else:\n                    logging.debug(\n                        \"Duplicated license name: {}. Last license is retained.\".format(\n                            v\n                        )\n                    )\n                    query_tags.get(\"licenses\")[tags.get(t)] = t\n                continue\n            elif t.startswith(\"owner\"):\n                query_tags.get(\"owners\")[tags.get(t)] = t\n                continue\n            elif t.startswith(\"provider\"):\n                # providers are particular bcause its value is always null.\n                query_tags.get(\"providers\")[k.split(\":\")[1]] = k\n                continue\n            elif t.startswith(\"share\"):\n                query_tags.get(\"shares\")[tags.get(t)] = t\n                continue\n            elif t.startswith(\"type\"):\n                query_tags.get(\"types\")[tags.get(t)] = t\n                continue\n            # ignored tags\n            else:\n                logging.debug(\n                    \"A query tag has been ignored during parsing: {}\".format(t)\n                )\n\n        # return the output\n        return tags_as_dicts, query_as_dicts", "response": "Reverse search tags dictionary to values as keys. Used to populate filters comboboxes for example."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef share_extender(self, share: dict, results_filtered: dict):\n        # add share administration URL\n        creator_id = share.get(\"_creator\").get(\"_tag\")[6:]\n        share[\"admin_url\"] = \"{}/groups/{}/admin/shares/{}\".format(\n            self.app_url, creator_id, share.get(\"_id\")\n        )\n        # check if OpenCatalog is activated\n        opencat_url = \"{}/s/{}/{}\".format(\n            self.oc_url, share.get(\"_id\"), share.get(\"urlToken\")\n        )\n        if requests.head(opencat_url):\n            share[\"oc_url\"] = opencat_url\n        else:\n            pass\n        # add metadata ids list\n        share[\"mds_ids\"] = (i.get(\"_id\") for i in results_filtered)\n\n        return share", "response": "Extend share model with additional informations."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef configure(username, password):\n    # type: (str, str) -> None\n    \"\"\"\n    Generate .pypirc config with the given credentials.\n\n    Example:\n\n        $ peltak pypi configure my_pypi_user my_pypi_pass\n\n    \"\"\"\n    from peltak.extra.pypi import logic\n    logic.gen_pypirc(username, password)", "response": "Generate. pypirc config with the given credentials."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tr(self, subdomain: str, string_to_translate: str = \"\") -> str:\n        if subdomain not in self.translations.keys():\n            raise ValueError(\n                \"'{}' is not a correct subdomain.\"\n                \" Must be one of {}\".format(subdomain, self.translations.keys())\n            )\n        else:\n            pass\n        # translate\n        str_translated = self.translations.get(\n            subdomain, {\"error\": \"Subdomain not found: {}\".format(subdomain)}\n        ).get(string_to_translate, \"String not found\")\n\n        # end of method\n        return str_translated", "response": "Returns the string in the translation dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_ec2_client(region_name=None, aws_access_key_id=None, aws_secret_access_key=None):\n    log = logging.getLogger(mod_logger + '.get_ec2_client')\n    # Connect to EC2 API\n    try:\n        client = boto3.client('ec2', region_name=region_name, aws_access_key_id=aws_access_key_id,\n                              aws_secret_access_key=aws_secret_access_key)\n    except ClientError:\n        _, ex, trace = sys.exc_info()\n        msg = 'There was a problem connecting to EC2, please check AWS CLI and boto configuration, ensure ' \\\n              'credentials and region are set appropriately.\\n{e}'.format(e=str(ex))\n        log.error(msg)\n        raise AWSAPIError, msg, trace\n    else:\n        log.debug('Successfully created an EC2 client')\n        return client", "response": "Creates an EC2 client object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the VPC ID for this instance", "response": "def get_vpc_id(self):\n        \"\"\"Gets the VPC ID for this EC2 instance\n\n        :return: String instance ID or None\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.get_vpc_id')\n\n        # Exit if not running on AWS\n        if not self.is_aws:\n            log.info('This machine is not running in AWS, exiting...')\n            return\n\n        if self.instance_id is None:\n            log.error('Unable to get the Instance ID for this machine')\n            return\n        log.info('Found Instance ID: {i}'.format(i=self.instance_id))\n\n        log.info('Querying AWS to get the VPC ID...')\n        try:\n            response = self.client.describe_instances(\n                    DryRun=False,\n                    InstanceIds=[self.instance_id])\n        except ClientError as ex:\n            log.error('Unable to query AWS to get info for instance {i}\\n{e}'.format(\n                    i=self.instance_id, e=ex))\n            return\n\n        # Get the VPC ID from the response\n        try:\n            vpc_id = response['Reservations'][0]['Instances'][0]['VpcId']\n        except KeyError as ex:\n            log.error('Unable to get VPC ID from response: {r}\\n{e}'.format(r=response, e=ex))\n            return\n        log.info('Found VPC ID: {v}'.format(v=vpc_id))\n        return vpc_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives an interface number gets the elastic network interface ID associated with the interface.", "response": "def get_eni_id(self, interface=1):\n        \"\"\"Given an interface number, gets the AWS elastic network\n        interface associated with the interface.\n\n        :param interface: Integer associated to the interface/device number\n        :return: String Elastic Network Interface ID or None if not found\n        :raises OSError, AWSAPIError, EC2UtilError\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.get_eni_id')\n\n        # Get the instance-id\n        if self.instance_id is None:\n            msg = 'Instance ID not found for this machine'\n            log.error(msg)\n            raise OSError(msg)\n        log.info('Found instance ID: {i}'.format(i=self.instance_id))\n\n        log.debug('Querying EC2 instances...')\n        try:\n            response = self.client.describe_instances(\n                    DryRun=False,\n                    InstanceIds=[self.instance_id]\n            )\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to query EC2 for instances\\n{e}'.format(e=str(ex))\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n        log.debug('Found instance info: {r}'.format(r=response))\n\n        # Find the ENI ID\n        log.info('Looking for the ENI ID to alias...')\n        eni_id = None\n        try:\n            for reservation in response['Reservations']:\n                for instance in reservation['Instances']:\n                    if instance['InstanceId'] == self.instance_id:\n                        for network_interface in instance['NetworkInterfaces']:\n                            if network_interface['Attachment']['DeviceIndex'] == interface:\n                                eni_id = network_interface['NetworkInterfaceId']\n        except KeyError:\n            _, ex, trace = sys.exc_info()\n            msg = 'ENI ID not found in AWS response for interface: {i}'.format(i=interface)\n            log.error(msg)\n            raise EC2UtilError, msg, trace\n\n        log.info('Found ENI ID: {e}'.format(e=eni_id))\n        return eni_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_secondary_ip(self, ip_address, interface=1):\n        log = logging.getLogger(self.cls_logger + '.add_secondary_ip')\n\n        # Get the ENI ID\n        eni_id = self.get_eni_id(interface)\n\n        # Verify the ENI ID was found\n        if eni_id is None:\n            msg = 'Unable to find the corresponding ENI ID for interface: {i}'. \\\n                format(i=interface)\n            log.error(msg)\n            raise EC2UtilError(msg)\n        else:\n            log.info('Found ENI ID: {e}'.format(e=eni_id))\n\n        # Assign the secondary IP address\n        log.info('Attempting to assign the secondary IP address...')\n        try:\n            self.client.assign_private_ip_addresses(\n                    NetworkInterfaceId=eni_id,\n                    PrivateIpAddresses=[\n                        ip_address,\n                    ],\n                    AllowReassignment=True\n            )\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to assign secondary IP address\\n{e}'.format(e=str(ex))\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n        log.info('Successfully added secondary IP address {s} to ENI ID {e} on interface {i}'.format(\n                s=ip_address, e=eni_id, i=interface))", "response": "Adds an IP address as a secondary IP address."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef associate_elastic_ip(self, allocation_id, interface=1, private_ip=None):\n        log = logging.getLogger(self.cls_logger + '.associate_elastic_ip')\n\n        if private_ip is None:\n            log.info('No private IP address provided, getting the primary IP'\n                     'address on interface {i}...'.format(i=interface))\n            private_ip = get_ip_addresses()['eth{i}'.format(i=interface)]\n\n        log.info('Associating Elastic IP {e} on interface {i} on IP {p}'.format(\n                e=allocation_id, i=interface, p=private_ip))\n\n        # Get the ENI ID\n        log.info('Getting the ENI ID for interface: {i}'.format(i=interface))\n        eni_id = self.get_eni_id(interface)\n\n        # Verify the ENI ID was found\n        if eni_id is None:\n            msg = 'Unable to find the corresponding ENI ID for interface: {i}'. \\\n                format(i=interface)\n            log.error(msg)\n            raise OSError(msg)\n        else:\n            log.info('Found ENI ID: {e}'.format(e=eni_id))\n\n        # Assign the secondary IP address\n        log.info('Attempting to assign the secondary IP address...')\n        try:\n            response = self.client.associate_address(\n                    NetworkInterfaceId=eni_id,\n                    AllowReassociation=True,\n                    AllocationId=allocation_id,\n                    PrivateIpAddress=private_ip\n            )\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to attach elastic IP address {a} to interface {i}\\n{e}'.format(\n                    a=allocation_id, i=interface, e=str(ex))\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n\n        code = response['ResponseMetadata']['HTTPStatusCode']\n        if code != 200:\n            msg = 'associate_address returned invalid code: {c}'.format(c=code)\n            log.error(msg)\n            raise AWSAPIError(msg)\n        log.info('Successfully associated elastic IP address ID {a} to interface {i} on ENI ID {e}'.format(\n                a=allocation_id, i=interface, e=eni_id))", "response": "This function associates an elastic IP to the interface number on this host."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nallocating an elastic IP address and returns the allocation ID and Public IP that were created.", "response": "def allocate_elastic_ip(self):\n        \"\"\"Allocates an elastic IP address\n\n        :return: Dict with allocation ID and Public IP that were created\n        :raises: AWSAPIError, EC2UtilError\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.allocate_elastic_ip')\n\n        # Attempt to allocate a new elastic IP\n        log.info('Attempting to allocate an elastic IP...')\n        try:\n            response = self.client.allocate_address(\n                    DryRun=False,\n                    Domain='vpc'\n            )\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to allocate a new elastic IP address\\n{e}'.format(e=str(ex))\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n\n        allocation_id = response['AllocationId']\n        public_ip = response['PublicIp']\n        log.info('Allocated Elastic IP with ID {a} and Public IP address {p}'.\n                 format(a=allocation_id, p=public_ip))\n\n        # Verify the Address was allocated successfully\n        log.info('Verifying the elastic IP address was allocated and is available '\n                 'for use...')\n        ready = False\n        verification_timer = [2]*60 + [5]*60 + [10]*18\n        num_checks = len(verification_timer)\n        for i in range(0, num_checks):\n            wait_time = verification_timer[i]\n            try:\n                self.client.describe_addresses(\n                        DryRun=False,\n                        AllocationIds=[allocation_id]\n                )\n            except ClientError:\n                _, ex, trace = sys.exc_info()\n                log.info('Elastic IP address {p} with Allocation ID {a} is not available for use, trying again in '\n                         '{w} sec...\\n{e}'.format(p=public_ip, a=allocation_id, w=wait_time, e=str(ex)))\n                time.sleep(wait_time)\n            else:\n                log.info('Elastic IP {p} with Allocation ID {a} is available for use'.format(\n                    p=public_ip, a=allocation_id))\n                ready = True\n                break\n        if ready:\n            return {'AllocationId': allocation_id, 'PublicIp': public_ip}\n        else:\n            msg = 'Unable to verify existence of new Elastic IP {p} with Allocation ID: {a}'. \\\n                format(p=public_ip, a=allocation_id)\n            log.error(msg)\n            raise EC2UtilError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef attach_new_eni(self, subnet_name, security_group_ids, device_index=2, allocation_id=None, description=''):\n        log = logging.getLogger(self.cls_logger + '.attach_new_eni')\n        log.info('Attempting to attach a new network interface to this instance...')\n\n        # Validate args\n        if not isinstance(security_group_ids, list):\n            msg = 'security_group_name argument is not a string'\n            log.error(msg)\n            raise EC2UtilError(msg)\n        if not isinstance(subnet_name, basestring):\n            msg = 'subnet_name argument is not a string'\n            log.error(msg)\n            raise EC2UtilError(msg)\n        if allocation_id is not None:\n            if not isinstance(allocation_id, basestring):\n                msg = 'allocation_id argument is not a string'\n                log.error(msg)\n                raise EC2UtilError(msg)\n        try:\n            device_index = int(device_index)\n        except ValueError:\n            _, ex, trace = sys.exc_info()\n            msg = 'device_index argument is not an int\\n{e}'.format(e=str(ex))\n            log.error(msg)\n            raise EC2UtilError, msg, trace\n\n        # Get the instance ID and VPC ID for this machine\n        if self.instance_id is None or self.vpc_id is None:\n            msg = 'Unable to obtain instance ID or VPC ID'\n            log.error(msg)\n            raise EC2UtilError(msg)\n\n        # Get the subnet ID by name\n        log.info('Looking up the subnet ID by name: {n}'.format(n=subnet_name))\n        filters = [\n            {'Name': 'vpc-id', 'Values': [self.vpc_id]},\n            {'Name': 'tag-key', 'Values': ['Name']},\n            {'Name': 'tag-value', 'Values': [subnet_name]}]\n        try:\n            response = self.client.describe_subnets(\n                    DryRun=False,\n                    Filters=filters\n            )\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to find subnet by name {n} in VPC {v}\\n{e}'.format(n=subnet_name, v=self.vpc_id, e=str(ex))\n            log.error(msg)\n            raise EC2UtilError, msg, trace\n\n        if len(response['Subnets']) < 1:\n            msg = 'No subnets found with name {n} in VPC {v}'.format(n=subnet_name, v=self.vpc_id)\n            log.error(msg)\n            raise EC2UtilError(msg)\n        elif len(response['Subnets']) > 1:\n            msg = 'More than 1 subnet found in VPC {v} with name {n}'.format(n=subnet_name, v=self.vpc_id)\n            log.error(msg)\n            raise EC2UtilError(msg)\n\n        subnet_id = response['Subnets'][0]['SubnetId']\n        log.info('Found Subnet ID: {s}'.format(s=subnet_id))\n\n        # Create the ENI\n        log.info('Attempting to create the Elastic Network Interface on subnet: {s}, with Security Groups: {g}'.format(\n                s=subnet_id, g=security_group_ids))\n        try:\n            response = self.client.create_network_interface(\n                    DryRun=False,\n                    SubnetId=subnet_id,\n                    Description=description,\n                    Groups=security_group_ids)\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to create a network interface on Subnet {s} using Security Groups {g}\\n{e}'.format(\n                    s=subnet_id, g=security_group_ids, e=str(ex))\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n\n        code = response['ResponseMetadata']['HTTPStatusCode']\n        if code != 200:\n            msg = 'create_network_interface returned invalid code: {c}'.format(c=code)\n            log.error(msg)\n            raise AWSAPIError(msg)\n\n        try:\n            eni_id = response['NetworkInterface']['NetworkInterfaceId']\n        except KeyError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to parse ENI ID from response: {r}\\n{e}'.format(r=response, e=str(ex))\n            log.error(msg)\n            raise EC2UtilError, msg, trace\n        log.info('Created ENI ID: {eni}'.format(eni=eni_id))\n\n        # Verify the ENI was created successfully\n        log.info('Verifying the ENI was created and is available for use...')\n        ready = False\n        num_checks = 60\n        for _ in range(num_checks):\n            try:\n                self.client.describe_network_interfaces(\n                        DryRun=False,\n                        NetworkInterfaceIds=[eni_id]\n                )\n            except ClientError as ex:\n                log.info('ENI ID {eni} is not available for use, trying again in 1 sec...\\n{e}'.format(\n                        eni=eni_id, e=ex))\n                time.sleep(2)\n            else:\n                log.info('ENI ID {eni} is available for use'.format(eni=eni_id))\n                ready = True\n                break\n        if not ready:\n            msg = 'Unable to verify existence of new ENI ID: {eni}'.format(eni=eni_id)\n            log.error(msg)\n            raise EC2UtilError(msg)\n\n        # If an allocation_id is specified, attach the elastic IP to the new ENI\n        if allocation_id is not None:\n            log.info('Attempting to attach elastic IP {a} to ENI {e}'.format(a=allocation_id, e=eni_id))\n            try:\n                response = self.client.associate_address(\n                        AllocationId=allocation_id,\n                        DryRun=False,\n                        NetworkInterfaceId=eni_id,\n                        AllowReassociation=True)\n            except ClientError:\n                _, ex, trace = sys.exc_info()\n                msg = 'Unable to associate Elastic IP {a} to ENI {eni}\\n{e}'.format(\n                        a=allocation_id, eni=eni_id, e=str(ex))\n                log.error(msg)\n                raise AWSAPIError, msg, trace\n\n            code = response['ResponseMetadata']['HTTPStatusCode']\n            if code != 200:\n                msg = 'associate_address returned invalid code: {c}'.format(c=code)\n                log.error(msg)\n                raise AWSAPIError(msg)\n            log.info('Successfully attached Elastic IP {a} to ENI ID {eni}'.format(\n                    eni=eni_id, a=allocation_id))\n\n        # Attach the ENI to this EC2 instance\n        log.info('Attempting to attach ENI ID {eni} to instance ID {i}'.format(\n                eni=eni_id, i=self.instance_id))\n        try:\n            response = self.client.attach_network_interface(\n                    DryRun=False,\n                    NetworkInterfaceId=eni_id,\n                    InstanceId=self.instance_id,\n                    DeviceIndex=device_index)\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to attach ENI ID {eni} to instance {i} at device index {d}\\n{e}'.format(\n                    eni=eni_id, i=self.instance_id, d=device_index, e=ex)\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n\n        code = response['ResponseMetadata']['HTTPStatusCode']\n        if code != 200:\n            msg = 'attach_network_interface returned invalid code: {c}'.format(c=code)\n            log.error(msg)\n            raise AWSAPIError(msg)\n        log.info('Successfully attached ENI ID {eni} to EC2 instance ID {i}'.format(\n                eni=eni_id, i=self.instance_id))", "response": "Creates a new elastic network interface on the subnet with the specified name and security group IDs and then attaches an Elastic IP address to the EC2 instance instance_id at the specified device index."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_elastic_ips(self):\n        log = logging.getLogger(self.cls_logger + '.get_elastic_ips')\n        instance_id = get_instance_id()\n        if instance_id is None:\n            log.error('Unable to get the Instance ID for this machine')\n            return\n        log.info('Found Instance ID: {i}'.format(i=instance_id))\n\n        log.info('Querying AWS for info about instance ID {i}...'.format(i=instance_id))\n        try:\n            instance_info = self.client.describe_instances(DryRun=False, InstanceIds=[instance_id])\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to query AWS to get info for instance {i}\\n{e}'.format(i=instance_id, e=ex)\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n\n        # Get the list of Public/Elastic IPs for this instance\n        public_ips = []\n        for network_interface in instance_info['Reservations'][0]['Instances'][0]['NetworkInterfaces']:\n            network_interface_id = network_interface['NetworkInterfaceId']\n            log.info('Checking ENI: {n}...'.format(n=network_interface_id))\n            try:\n                public_ips.append(network_interface['Association']['PublicIp'])\n            except KeyError:\n                log.info('No Public IP found for Network Interface ID: {n}'.format(n=network_interface_id))\n            else:\n                log.info('Found public IP for Network Interface ID {n}: {p}'.format(\n                        n=network_interface_id, p=network_interface['Association']['PublicIp']))\n\n        # Return if no Public/Elastic IPs found\n        if len(public_ips) == 0:\n            log.info('No Elastic IPs found for this instance: {i}'.format(i=instance_id))\n            return\n        else:\n            log.info('Found Public IPs: {p}'.format(p=public_ips))\n\n        # Get info for each Public/Elastic IP\n        try:\n            address_info = self.client.describe_addresses(DryRun=False, PublicIps=public_ips)\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to query AWS to get info for addresses {p}\\n{e}'.format(p=public_ips, e=str(ex))\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n        if not address_info:\n            msg = 'No address info return for Public IPs: {p}'.format(p=public_ips)\n            log.error(msg)\n            raise AWSAPIError(msg)\n        return address_info", "response": "Returns the Elastic IPs for this instance any are\n        attached to the instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndisassociate each attached Elastic IP from the instance.", "response": "def disassociate_elastic_ips(self):\n        \"\"\"For each attached Elastic IP, disassociate it\n\n        :return: None\n        :raises AWSAPIError\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.disassociate_elastic_ips')\n\n        try:\n            address_info = self.get_elastic_ips()\n        except AWSAPIError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to determine Elastic IPs on this EC2 instance'\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n\n        # Return is no elastic IPs were found\n        if not address_info:\n            log.info('No elastic IPs found to disassociate')\n            return\n\n        # Disassociate each Elastic IP\n        for address in address_info['Addresses']:\n            association_id = address['AssociationId']\n            public_ip = address['PublicIp']\n            log.info('Attempting to disassociate address {p} from Association ID: {a}'.format(\n                    p=public_ip, a=association_id))\n            try:\n                self.client.disassociate_address(PublicIp=public_ip, AssociationId=association_id)\n            except ClientError:\n                _, ex, trace = sys.exc_info()\n                msg = 'There was a problem disassociating Public IP {p} from Association ID {a}'.format(\n                        p=public_ip, a=association_id)\n                log.error(msg)\n                raise AWSAPIError, msg, trace\n            else:\n                log.info('Successfully disassociated Public IP: {p}'.format(p=public_ip))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new Security Group with the specified name and description in the specified VPC ID.", "response": "def create_security_group(self, name, description='', vpc_id=None):\n        \"\"\"Creates a new Security Group with the specified name,\n        description, in the specified vpc_id if provided.  If\n        vpc_id is not provided, use self.vpc_id\n\n        :param name: (str) Security Group Name\n        :param description: (str) Security Group Description\n        :param vpc_id: (str) VPC ID to create the Security Group\n        :return: (str) Security Group ID\n        :raises: AWSAPIError, EC2UtilError\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.create_security_group')\n        # Validate args\n        if not isinstance(name, basestring):\n            msg = 'name argument is not a string'\n            log.error(msg)\n            raise EC2UtilError(msg)\n        if not isinstance(description, basestring):\n            msg = 'description argument is not a string'\n            log.error(msg)\n            raise EC2UtilError(msg)\n        if vpc_id is None and self.vpc_id is not None:\n            vpc_id = self.vpc_id\n        else:\n            msg = 'Unable to determine VPC ID to use to create the Security Group'\n            log.error(msg)\n            raise EC2UtilError(msg)\n\n        # See if a Security Group already exists with the same name\n        log.info('Checking for an existing security group with name {n} in VPC: {v}'.format(n=name, v=vpc_id))\n        filters = [{\n                'Name': 'vpc-id',\n                'Values': [vpc_id]\n            },\n            {\n                'Name': 'group-name',\n                'Values': [name]\n            }]\n        try:\n            response = self.client.describe_security_groups(DryRun=False, Filters=filters)\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to query Security Groups to determine if {n} exists in VPC ID {v}\\n{e}'.format(\n                n=name, v=vpc_id, e=str(ex))\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n        else:\n            log.debug('Found Security Group: {r}'.format(r=response))\n            if len(response['SecurityGroups']) == 1:\n                log.info('Found an existing security group with name {n} in VPC: {v}'.format(n=name, v=vpc_id))\n                try:\n                    group_id = response['SecurityGroups'][0]['GroupId']\n                except KeyError:\n                    _, ex, trace = sys.exc_info()\n                    msg = 'Unable to determine the Security Group GroupId from response: {r}\\n{e}'.format(\n                        r=response, e=str(ex))\n                    log.error(msg)\n                    raise AWSAPIError, msg, trace\n                else:\n                    log.info('Found existing Security Group with GroupId: {g}'.format(g=group_id))\n                    return group_id\n            else:\n                log.info('No existing Security Group with name {n} found in VPC: {v}'.format(n=name, v=vpc_id))\n\n        # Create a new Security Group\n        log.info('Attempting to create a Security Group with name <{n}>, description <{d}>, in VPC: {v}'.format(\n            n=name, d=description, v=vpc_id))\n        try:\n            response = self.client.create_security_group(\n                DryRun=False,\n                GroupName=name,\n                Description=description,\n                VpcId=vpc_id\n            )\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to create Security Group <{n}> in VPC: {v}'.format(n=name, v=vpc_id)\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n        else:\n            log.info('Successfully created Security Group <{n}> in VPC: {v}'.format(n=name, v=vpc_id))\n        return response['GroupId']"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of security groups in the VPC.", "response": "def list_security_groups_in_vpc(self, vpc_id=None):\n        \"\"\"Lists security groups in the VPC.  If vpc_id is not provided, use self.vpc_id\n\n        :param vpc_id: (str) VPC ID to list security groups for\n        :return: (list) Security Group info\n        :raises: AWSAPIError, EC2UtilError\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.list_security_groups_in_vpc')\n        if vpc_id is None and self.vpc_id is not None:\n            vpc_id = self.vpc_id\n        else:\n            msg = 'Unable to determine VPC ID to use to create the Security Group'\n            log.error(msg)\n            raise EC2UtilError(msg)\n\n        # Create a filter on the VPC ID\n        filters = [\n            {\n                'Name': 'vpc-id',\n                'Values': [vpc_id]\n            }\n        ]\n\n        # Get a list of security groups in the VPC\n        log.info('Querying for a list of security groups in VPC ID: {v}'.format(v=vpc_id))\n        try:\n            security_groups = self.client.describe_security_groups(DryRun=False, Filters=filters)\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to query AWS for a list of security groups in VPC ID: {v}\\n{e}'.format(\n                v=vpc_id, e=str(ex))\n            raise AWSAPIError, msg, trace\n        return security_groups"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconfiguring the security group ID allowing access to the specified CIDR blocks for the specified TCP Port number.", "response": "def configure_security_group_ingress(self, security_group_id, port, desired_cidr_blocks):\n        \"\"\"Configures the security group ID allowing access\n        only to the specified CIDR blocks, for the specified\n        port number.\n\n        :param security_group_id: (str) Security Group ID\n        :param port: (str) TCP Port number\n        :param desired_cidr_blocks: (list) List of desired CIDR\n               blocks, e.g. 192.168.1.2/32\n        :return: None\n        :raises: AWSAPIError, EC2UtilError\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.configure_security_group_ingress')\n        # Validate args\n        if not isinstance(security_group_id, basestring):\n            msg = 'security_group_id argument is not a string'\n            log.error(msg)\n            raise EC2UtilError(msg)\n        if not isinstance(port, basestring):\n            msg = 'port argument is not a string'\n            log.error(msg)\n            raise EC2UtilError(msg)\n        if not isinstance(desired_cidr_blocks, list):\n            msg = 'desired_cidr_blocks argument is not a list'\n            log.error(msg)\n            raise EC2UtilError(msg)\n        log.info('Configuring Security Group <{g}> on port {p} to allow: {r}'.format(\n            g=security_group_id, p=port, r=desired_cidr_blocks\n        ))\n        log.debug('Querying AWS for info on Security Group ID: {g}...'.format(g=security_group_id))\n        try:\n            security_group_info = self.client.describe_security_groups(DryRun=False, GroupIds=[security_group_id])\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to query AWS for Security Group ID: {g}\\n{e}'.format(g=security_group_id, e=str(ex))\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n        else:\n            log.debug('Found Security Group: {g}'.format(g=security_group_info))\n        try:\n            ingress_rules = security_group_info['SecurityGroups'][0]['IpPermissions']\n        except KeyError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to get list of ingress rules for Security Group ID: {g}\\n{e}'.format(\n                    g=security_group_id, e=str(ex))\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n        else:\n            log.debug('Found ingress rules: {r}'.format(r=ingress_rules))\n\n        # Evaluate each rule against the provided port and IP address list\n        log.debug('Setting ingress rules...')\n        for ingress_rule in ingress_rules:\n            log.debug('Evaluating ingress rule: {r}'.format(r=ingress_rule))\n            if ingress_rule['ToPort'] != int(port):\n                log.debug('Skipping rule not matching port: {p}'.format(p=port))\n                continue\n            log.info('Removing existing rules from Security Group {g} for port: {p}...'.format(\n                    g=security_group_id, p=port))\n            try:\n                self.client.revoke_security_group_ingress(\n                        DryRun=False,\n                        GroupId=security_group_id,\n                        IpPermissions=[ingress_rule])\n            except ClientError:\n                _, ex, trace = sys.exc_info()\n                msg = 'Unable to remove existing Security Group rules for port {p} from Security Group: ' \\\n                      '{g}\\n{e}'.format(p=port, g=security_group_id, e=str(ex))\n                log.error(msg)\n                raise AWSAPIError, msg, trace\n\n        # Build ingress rule based on the provided CIDR block list\n        desired_ip_permissions = [\n            {\n                'IpProtocol': 'tcp',\n                'FromPort': int(port),\n                'ToPort': int(port),\n                'UserIdGroupPairs': [],\n                'IpRanges': [],\n                'PrefixListIds': []\n            }\n        ]\n\n        # Add IP rules\n        for desired_cidr_block in desired_cidr_blocks:\n            log.debug('Adding ingress for CIDR block: {b}'.format(b=desired_cidr_block))\n            cidr_block_entry = {\n                'CidrIp': desired_cidr_block\n            }\n            desired_ip_permissions[0]['IpRanges'].append(cidr_block_entry)\n\n        # Add the ingress rule\n        log.debug('Adding ingress rule: {r}'.format(r=desired_ip_permissions))\n        try:\n            self.client.authorize_security_group_ingress(\n                DryRun=False,\n                GroupId=security_group_id,\n                IpPermissions=desired_ip_permissions\n            )\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to authorize Security Group ingress rule for Security Group {g}: {r}\\n{e}'.format(\n                    g=security_group_id, r=desired_ip_permissions, e=str(ex))\n            log.error(msg)\n            raise AWSAPIError, msg, trace\n        else:\n            log.info('Successfully added ingress rule for Security Group {g} on port: {p}'.format(\n                    g=security_group_id, p=port))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef revoke_security_group_ingress(self, security_group_id, ingress_rules):\n        log = logging.getLogger(self.cls_logger + '.revoke_security_group_ingress')\n        log.info('Revoking ingress rules from security group: {g}'.format(g=security_group_id))\n        try:\n            self.client.revoke_security_group_ingress(\n                DryRun=False,\n                GroupId=security_group_id,\n                IpPermissions=ingress_rules)\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to remove existing Security Group rules for port from Security Group: {g}\\n{e}'.format(\n                g=security_group_id, e=str(ex))\n            raise AWSAPIError, msg, trace", "response": "Revokes all ingress rules for a security group bu ID\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlaunch an EC2 instance with the specified parameters intended to create a CONS3RT template.", "response": "def launch_instance(self, ami_id, key_name, subnet_id, security_group_id=None, security_group_list=None,\n                        user_data_script_path=None, instance_type='t2.small', root_device_name='/dev/xvda'):\n        \"\"\"Launches an EC2 instance with the specified parameters, intended to launch\n        an instance for creation of a CONS3RT template.\n\n        :param ami_id: (str) ID of the AMI to launch from\n        :param key_name: (str) Name of the key-pair to use\n        :param subnet_id: (str) IF of the VPC subnet to attach the instance to\n        :param security_group_id: (str) ID of the security group, of not provided the default will be applied\n                appended to security_group_list if provided\n        :param security_group_id_list: (list) of IDs of the security group, if not provided the default will be applied\n        :param user_data_script_path: (str) Path to the user-data script to run\n        :param instance_type: (str) Instance Type (e.g. t2.micro)\n        :param root_device_name: (str) The device name for the root volume\n        :return:\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.launch_instance')\n        log.info('Launching with AMI ID: {a}'.format(a=ami_id))\n        log.info('Launching with Key Pair: {k}'.format(k=key_name))\n\n        if security_group_list:\n            if not isinstance(security_group_list, list):\n                raise EC2UtilError('security_group_list must be a list')\n\n        if security_group_id and security_group_list:\n            security_group_list.append(security_group_id)\n        elif security_group_id and not security_group_list:\n            security_group_list = [security_group_id]\n            log.info('Launching with security group list: {s}'.format(s=security_group_list))\n        user_data = None\n        if user_data_script_path is not None:\n            if os.path.isfile(user_data_script_path):\n                with open(user_data_script_path, 'r') as f:\n                    user_data = f.read()\n        monitoring = {'Enabled': False}\n        block_device_mappings = [\n            {\n                'DeviceName': root_device_name,\n                'Ebs': {\n                    'VolumeSize': 100,\n                    'DeleteOnTermination': True\n                }\n            }\n        ]\n        log.info('Attempting to launch the EC2 instance now...')\n        try:\n            response = self.client.run_instances(\n                DryRun=False,\n                ImageId=ami_id,\n                MinCount=1,\n                MaxCount=1,\n                KeyName=key_name,\n                SecurityGroupIds=security_group_list,\n                UserData=user_data,\n                InstanceType=instance_type,\n                Monitoring=monitoring,\n                SubnetId=subnet_id,\n                InstanceInitiatedShutdownBehavior='stop',\n                BlockDeviceMappings=block_device_mappings\n            )\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a problem launching the EC2 instance\\n{e}'.format(n=ex.__class__.__name__, e=str(ex))\n            raise EC2UtilError, msg, trace\n        instance_id = response['Instances'][0]['InstanceId']\n        output = {\n            'InstanceId': instance_id,\n            'InstanceInfo': response['Instances'][0]\n        }\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_ec2_instances(self):\n        log = logging.getLogger(self.cls_logger + '.get_ec2_instances')\n        log.info('Describing EC2 instances...')\n        try:\n            response = self.client.describe_instances()\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a problem describing EC2 instances\\n{e}'.format(n=ex.__class__.__name__, e=str(ex))\n            raise EC2UtilError, msg, trace\n        return response", "response": "Describes the EC2 instances and returns a dict containing the EC2 instance data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef docs_cli(ctx, recreate, gen_index, run_doctests):\n    # type: (click.Context, bool, bool, bool) -> None\n    \"\"\" Build project documentation.\n\n    This command will run sphinx-refdoc first to generate the reference\n    documentation for the code base. Then it will run sphinx to generate the\n    final docs. You can configure the directory that stores the docs source\n    (index.rst, conf.py, etc.) using the DOC_SRC_PATH conf variable. In case you\n    need it, the sphinx build directory is located in ``BUILD_DIR/docs``.\n\n    The reference documentation will be generated for all directories listed\n    under 'REFDOC_PATHS conf variable. By default it is empty so no reference\n    docs are generated.\n\n    Sample Config::\n\n        \\b\n        build_dir: '.build'\n\n        docs:\n          path: 'docs'\n          reference:\n            - 'src/mypkg'\n\n    Examples::\n\n        \\b\n        $ peltak docs                           # Generate docs for the project\n        $ peltak docs --no-index                # Skip main reference index\n        $ peltak docs --recreate --no-index     # Build docs from clean slate\n\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    from peltak.logic import docs\n    docs.docs(recreate, gen_index, run_doctests)", "response": "Build the documentation for the current project."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef as_string(value):\n    if six.PY2:\n        buffer_types = buffer, memoryview  # noqa: F821\n    else:\n        buffer_types = memoryview\n\n    if value is None:\n        return u''\n    elif isinstance(value, buffer_types):\n        return bytes(value).decode('utf8', 'ignore')\n    elif isinstance(value, bytes):\n        return value.decode('utf8', 'ignore')\n    else:\n        return six.text_type(value)", "response": "Convert a value to a Unicode string for matching with a query."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef displayable_path(path, separator=u'; '):\n    if isinstance(path, (list, tuple)):\n        return separator.join(displayable_path(p) for p in path)\n    elif isinstance(path, six.text_type):\n        return path\n    elif not isinstance(path, bytes):\n        # A non-string object: just get its unicode representation.\n        return six.text_type(path)\n\n    try:\n        return path.decode(_fsencoding(), 'ignore')\n    except (UnicodeError, LookupError):\n        return path.decode('utf8', 'ignore')", "response": "Given a bytestring path to a unicode object for the\n    purpose of displaying it to the user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef syspath(path, prefix=True):\n    # Don't do anything if we're not on windows\n    if os.path.__name__ != 'ntpath':\n        return path\n\n    if not isinstance(path, six.text_type):\n        # Beets currently represents Windows paths internally with UTF-8\n        # arbitrarily. But earlier versions used MBCS because it is\n        # reported as the FS encoding by Windows. Try both.\n        try:\n            path = path.decode('utf8')\n        except UnicodeError:\n            # The encoding should always be MBCS, Windows' broken\n            # Unicode representation.\n            encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()\n            path = path.decode(encoding, 'replace')\n\n    # Add the magic prefix if it isn't already there.\n    # http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx\n    if prefix and not path.startswith(WINDOWS_MAGIC_PREFIX):\n        if path.startswith(u'\\\\\\\\'):\n            # UNC path. Final path should look like \\\\?\\UNC\\...\n            path = u'UNC' + path[1:]\n        path = WINDOWS_MAGIC_PREFIX + path\n\n    return path", "response": "Convert a path to a Unicode string for use by the operating system."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_new(self, button):\n        '''\n        Copy selected notebook template to notebook directory.\n\n        ## Notes ##\n\n         - An exception is raised if the parent of the selected file is the\n           notebook directory.\n         - If notebook with same name already exists in notebook directory,\n           offer is made to overwrite (the new copy of the file is renamed with\n           a count if overwrite is not selected).\n        '''\n        buttons = (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,\n                   Gtk.STOCK_OPEN, Gtk.ResponseType.OK)\n        dialog = Gtk.FileChooserDialog(\"Select notebook template\", self.parent,\n                                       Gtk.FileChooserAction.OPEN, buttons)\n        add_filters(dialog, [{'name': 'IPython notebook (*.ipynb)',\n                              'pattern': '*.ipynb'}])\n        response = dialog.run()\n        if response == Gtk.ResponseType.OK:\n            selected_path = path(dialog.get_filename())\n            output_path = self.notebook_dir.joinpath(selected_path.name)\n\n            overwrite = False\n            if output_path.isfile():\n                response = yesno('%s already exists. Overwrite?' % output_path.name,\n                                 'Overwrite?')\n                if response == Gtk.ResponseType.YES:\n                    overwrite = True\n                else:\n                    counter = 1\n                    renamed_path = output_path\n                    while renamed_path.isfile():\n                        new_name = '%s (%d)%s' % (output_path.namebase, counter,\n                                                  output_path.ext)\n                        renamed_path = output_path.parent.joinpath(new_name)\n                        counter += 1\n                    output_path = renamed_path\n            self.notebook_manager.launch_from_template(selected_path,\n                                                       overwrite=overwrite,\n                                                       output_name=output_path.name,\n                                                       notebook_dir=self.notebook_dir)\n        dialog.destroy()", "response": "This method is called when a new notebook template is selected."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef se_iban_load_map(filename: str) -> list:\n    out = []\n    name_repl = {\n        'BNP Paribas Fortis SA/NV, Bankfilial Sverige': 'BNP Paribas Fortis SA/NV',\n        'Citibank International Plc, Sweden Branch': 'Citibank International Plc',\n        'Santander Consumer Bank AS (deltar endast i Dataclearingen)': 'Santander Consumer Bank AS',\n        'Nordax Bank AB (deltar endast i Dataclearingen)': 'Nordax Bank AB',\n        'Swedbank och frist\u00e5ende Sparbanker, t ex Leksands Sparbank och Roslagsbanken.': 'Swedbank',\n        '\u00c5landsbanken Abp (Finland),svensk filial': '\u00c5landsbanken Abp',\n        'SBAB deltar endast i Dataclearingen': 'SBAB',\n    }\n    with open(filename) as fp:\n        for row in csv.reader(fp):\n            if len(row) == 3:\n                name, series, acc_digits = row\n                # pprint([name, series, acc_digits])\n\n                # clean up name\n                name = re.sub(r'\\n.*', '', name)\n                if name in name_repl:\n                    name = name_repl[name]\n\n                # clean up series\n                ml_acc_digits = acc_digits.split('\\n')\n                for i, ser in enumerate(series.split('\\n')):\n                    begin, end = None, None\n                    res = re.match(r'^(\\d+)-(\\d+).*$', ser)\n                    if res:\n                        begin, end = res.group(1), res.group(2)\n                    if begin is None:\n                        res = re.match(r'^(\\d{4}).*$', ser)\n                        if res:\n                            begin = res.group(1)\n                            end = begin\n\n                    if begin and end:\n                        digits = None\n                        try:\n                            digits = int(acc_digits)\n                        except ValueError:\n                            pass\n                        if digits is None:\n                            try:\n                                digits = int(ml_acc_digits[i])\n                            except ValueError:\n                                digits = '?'\n                            except IndexError:\n                                digits = '?'\n\n                        out.append([name, begin, end, digits])\n                        # print('OK!')\n    return out", "response": "Loads Swedish monetary institution codes in CSV format."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs an entry to admin logs of model instances.", "response": "def admin_log(instances, msg: str, who: User=None, **kw):\n    \"\"\"\n    Logs an entry to admin logs of model(s).\n    :param instances: Model instance or list of instances\n    :param msg: Message to log\n    :param who: Who did the change\n    :param kw: Optional key-value attributes to append to message\n    :return: None\n    \"\"\"\n\n    from django.contrib.admin.models import LogEntry, CHANGE\n    from django.contrib.admin.options import get_content_type_for_model\n    from django.utils.encoding import force_text\n\n    # use system user if 'who' is missing\n    if not who:\n        username = settings.DJANGO_SYSTEM_USER if hasattr(settings, 'DJANGO_SYSTEM_USER') else 'system'\n        who, created = User.objects.get_or_create(username=username)\n\n    # append extra keyword attributes if any\n    att_str = ''\n    for k, v in kw.items():\n        if hasattr(v, 'pk'):  # log only primary key for model instances, not whole str representation\n            v = v.pk\n        att_str += '{}={}'.format(k, v) if not att_str else ', {}={}'.format(k, v)\n    if att_str:\n        att_str = ' [{}]'.format(att_str)\n    msg = str(msg) + att_str\n\n    if not isinstance(instances, list) and not isinstance(instances, tuple):\n        instances = [instances]\n    for instance in instances:\n        if instance:\n            LogEntry.objects.log_action(\n                user_id=who.pk,\n                content_type_id=get_content_type_for_model(instance).pk,\n                object_id=instance.pk,\n                object_repr=force_text(instance),\n                action_flag=CHANGE,\n                change_message=msg,\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef history_view(self, request, object_id, extra_context=None):\n        from django.template.response import TemplateResponse\n        from django.contrib.admin.options import get_content_type_for_model\n        from django.contrib.admin.utils import unquote\n        from django.core.exceptions import PermissionDenied\n        from django.utils.text import capfirst\n        from django.utils.encoding import force_text\n        from django.utils.translation import ugettext as _\n\n        \"The 'history' admin view for this model.\"\n        from django.contrib.admin.models import LogEntry\n        # First check if the user can see this history.\n        model = self.model\n        obj = self.get_object(request, unquote(object_id))\n        if obj is None:\n            return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)\n\n        if not self.has_change_permission(request, obj):\n            raise PermissionDenied\n\n        # Then get the history for this object.\n        opts = model._meta\n        app_label = opts.app_label\n        action_list = LogEntry.objects.filter(\n            object_id=unquote(object_id),\n            content_type=get_content_type_for_model(model)\n        ).select_related().order_by('-action_time')[:self.max_history_length]\n\n        context = dict(\n            self.admin_site.each_context(request),\n            title=_('Change history: %s') % force_text(obj),\n            action_list=action_list,\n            module_name=capfirst(force_text(opts.verbose_name_plural)),\n            object=obj,\n            opts=opts,\n            preserved_filters=self.get_preserved_filters(request),\n        )\n        context.update(extra_context or {})\n\n        request.current_app = self.admin_site.name\n\n        return TemplateResponse(request, self.object_history_template or [\n            \"admin/%s/%s/object_history.html\" % (app_label, opts.model_name),\n            \"admin/%s/object_history.html\" % app_label,\n            \"admin/object_history.html\"\n        ], context)", "response": "The history admin view for this model."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn owner object by filename.", "response": "def get_object_by_filename(self, request, filename):\n        \"\"\"\n        Returns owner object by filename (to be downloaded).\n        This can be used to implement custom permission checks.\n        :param request: HttpRequest\n        :param filename: File name of the downloaded object.\n        :return: owner object\n        \"\"\"\n        kw = dict()\n        kw[self.file_field] = filename\n        obj = self.get_queryset(request).filter(**kw).first()\n        if not obj:\n            raise Http404(_('File {} not found').format(filename))\n        return self.get_object(request, obj.id)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_download_urls(self):\n        info = self.model._meta.app_label, self.model._meta.model_name\n        return [\n            url(r'^.+(' + self.upload_to + '/.+)/$', self.file_download_view, name='%s_%s_file_download' % info),\n        ]", "response": "Returns a list of file download URLs for this model."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite the given version to the VERSION_FILE.", "response": "def write(version):\n    # type: (str) -> None\n    \"\"\" Write the given version to the VERSION_FILE \"\"\"\n    if not is_valid(version):\n        raise ValueError(\"Invalid version: \".format(version))\n\n    storage = get_version_storage()\n    storage.write(version)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbump the given version component.", "response": "def bump(component='patch', exact=None):\n    # type: (str, str) -> Tuple[str, str]\n    \"\"\" Bump the given version component.\n\n    Args:\n        component (str):\n            What part of the version should be bumped. Can be one of:\n\n            - major\n            - minor\n            - patch\n\n        exact (str):\n            The exact version that should be set instead of bumping the current\n            one.\n\n    Returns:\n        tuple(str, str): A tuple of old and bumped version.\n    \"\"\"\n    old_ver = current()\n\n    if exact is None:\n        new_ver = _bump_version(old_ver, component)\n    else:\n        new_ver = exact\n\n    write(new_ver)\n    return old_ver, new_ver"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _bump_version(version, component='patch'):\n    # type: (str, str) -> str\n    \"\"\" Bump the given version component.\n\n    Args:\n        version (str):\n            The current version. The format is: MAJOR.MINOR[.PATCH].\n        component (str):\n            What part of the version should be bumped. Can be one of:\n\n            - major\n            - minor\n            - patch\n\n    Returns:\n        str: Bumped version as a string.\n    \"\"\"\n    if component not in ('major', 'minor', 'patch'):\n        raise ValueError(\"Invalid version component: {}\".format(component))\n\n    m = RE_VERSION.match(version)\n    if m is None:\n        raise ValueError(\"Version must be in MAJOR.MINOR[.PATCH] format\")\n\n    major = m.group('major')\n    minor = m.group('minor') or '0'\n    patch = m.group('patch') or None\n\n    if patch == '0':\n        patch = None\n\n    if component == 'major':\n        major = str(int(major) + 1)\n        minor = '0'\n        patch = None\n\n    elif component == 'minor':\n        minor = str(int(minor) + 1)\n        patch = None\n\n    else:\n        patch = patch or 0\n        patch = str(int(patch) + 1)\n\n    new_ver = '{}.{}'.format(major, minor)\n    if patch is not None:\n        new_ver += '.' + patch\n\n    return new_ver", "response": "Bump the given version component."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_version_storage():\n    # type: () -> VersionStorage\n    \"\"\" Get version storage for the given version file.\n\n    The storage engine used depends on the extension of the *version_file*.\n    \"\"\"\n    version_file = conf.get_path('version_file', 'VERSION')\n    if version_file.endswith('.py'):\n        return PyVersionStorage(version_file)\n    elif version_file.endswith('package.json'):\n        return NodeVersionStorage(version_file)\n    else:\n        return RawVersionStorage(version_file)", "response": "Returns the version storage for the given version file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading the project version from. py file.", "response": "def read(self):\n        # type: () -> Optional[str]\n        \"\"\" Read the project version from .py file.\n\n        This will regex search in the file for a\n        ``__version__ = VERSION_STRING`` and read the version string.\n        \"\"\"\n        with open(self.version_file) as fp:\n            content = fp.read()\n            m = RE_PY_VERSION.search(content)\n            if not m:\n                return None\n            else:\n                return m.group('version')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write(self, version):\n        # type: (str) -> None\n        \"\"\" Write the project version to .py file.\n\n        This will regex search in the file for a\n        ``__version__ = VERSION_STRING`` and substitute the version string\n        for the new version.\n        \"\"\"\n        with open(self.version_file) as fp:\n            content = fp.read()\n\n        ver_statement = \"__version__ = '{}'\".format(version)\n        new_content = RE_PY_VERSION.sub(ver_statement, content)\n        fs.write_file(self.version_file, new_content)", "response": "Writes the project version to. py file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the project version from. py file.", "response": "def read(self):\n        # type: () -> Optional[str]\n        \"\"\" Read the project version from .py file.\n\n        This will regex search in the file for a\n        ``__version__ = VERSION_STRING`` and read the version string.\n        \"\"\"\n        with open(self.version_file) as fp:\n            version = fp.read().strip()\n\n            if is_valid(version):\n                return version\n\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fromfits(infile, hdu = 0, verbose = True):\n    \n    pixelarray, hdr = ft.getdata(infile, hdu, header=True)\n    pixelarray = np.asarray(pixelarray).transpose()\n    #print pixelarray\n    \n    pixelarrayshape = pixelarray.shape\n    if verbose :\n        print \"Input shape : (%i, %i)\" % (pixelarrayshape[0], pixelarrayshape[1])\n        print \"Input file BITPIX : %s\" % (hdr[\"BITPIX\"])\n    pixelarrayshape = np.asarray(pixelarrayshape)\n    if verbose :\n        print \"Internal array type :\", pixelarray.dtype.name\n    \n    return f2nimage(pixelarray, verbose = verbose)", "response": "Returns a nimage object from a FITS file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rebin(a, newshape):\n        \n    shape = a.shape\n\n    lenShape = len(shape)\n\n    factor = np.asarray(shape)/np.asarray(newshape)\n    #print factor\n\n    evList = ['a.reshape('] + \\\n             ['newshape[%d],factor[%d],'%(i,i) for i in xrange(lenShape)] + \\\n             [')'] + ['.sum(%d)'%(i+1) for i in xrange(lenShape)] + \\\n             ['/factor[%d]'%i for i in xrange(lenShape)]\n\n    return eval(''.join(evList))", "response": "Auxiliary function to rebin ndarray data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake f2nimages and writes them into one png file side by side.", "response": "def compose(f2nimages, outfile):\n    \"\"\"\n    Takes f2nimages and writes them into one single png file, side by side.\n    f2nimages is a list of horizontal lines, where each line is a list of f2nimages.\n    For instance :\n    [\n    [image1, image2],\n    [image3, image4]\n    ]\n    The sizes of these images have to \"match\", so that the final result is rectangular.\n    \n    This function is verbose if any of the images is verbose.\n    \n    \"\"\"\n    # We start by doing some checks, and try to print out helpfull error messages.\n    verbosity = []\n    colourmodes = []\n    for i, line in enumerate(f2nimages):\n        for j, img in enumerate(line):\n            if img.verbose:\n                print \"Checking line %i, image %i (verbose)...\" % (i+1, j+1)\n            img.checkforpilimage()\n            verbosity.append(img.verbose)\n            colourmodes.append(img.pilimage.mode)\n    verbose = np.any(np.array(verbosity)) # So we set the verbosity used in this function to true if any of the images is verbose.\n    colours = list(set(colourmodes))\n    \n    \n    # We check if the widths are compatible :\n    widths = [np.sum(np.array([img.pilimage.size[0] for img in line])) for line in f2nimages]\n    if len(set(widths)) != 1 :\n        print \"Total widths of the lines :\"\n        print widths\n        raise RuntimeError, \"The total widths of your lines are not compatible !\"\n    totwidth = widths[0]\n    \n    # Similar for the heights :\n    for i, line in enumerate(f2nimages):\n        heights = [img.pilimage.size[1] for img in line]\n        if len(set(heights)) != 1 :\n            print \"Heights of the images in line %i :\" % (i + 1)\n            print heights\n            raise RuntimeError, \"Heights of the images in line %i are not compatible.\" % (i + 1)\n    \n    totheight = np.sum(np.array([line[0].pilimage.size[1] for line in f2nimages]))\n    # Ok, now it should be safe to go for the composition :\n    if verbose:\n        print \"Composition size : %i x %i\" % (totwidth, totheight)\n    \n    if verbose:\n        print \"Colour modes of input : %s\" % colours\n    if len(colours) == 1 and colours[0] == \"L\" :\n        if verbose :\n            print \"Builing graylevel composition\"\n        compoimg = im.new(\"L\", (totwidth, totheight), 128)\n    else:\n        if verbose :\n            print \"Building RGB composition\"\n        compoimg = im.new(\"RGB\", (totwidth, totheight), (255, 0, 0))\n        \n    y = 0\n    for line in f2nimages:\n        x = 0\n        for img in line:\n            box = (x, y, x+img.pilimage.size[0], y+img.pilimage.size[1])\n            #print box\n            compoimg.paste(img.pilimage, box)\n            x += img.pilimage.size[0]\n        y += img.pilimage.size[1]\n    \n    \n    if verbose:\n        print \"Writing compositions to %s...\\n%i x %i pixels, mode %s\" % (outfile, compoimg.size[0], compoimg.size[1], compoimg.mode)\n    compoimg.save(outfile, \"PNG\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef crop(self, xa, xb, ya, yb):\n        \n        if self.pilimage != None:\n            raise RuntimeError, \"Cannot crop anymore, PIL image already exists !\"\n        \n        if self.verbose:\n            print \"Cropping : [%i:%i, %i:%i]\" % (xa, xb, ya, yb)\n        self.numpyarray = self.numpyarray[xa:xb, ya:yb]\n        \n        self.xa += xa\n        self.ya += ya\n        self.xb = self.xa + (xb - xa)\n        self.yb = self.ya + (yb - ya)", "response": "Crops the image. Two points :\n        \n            - We use numpy conventions\n            xa = 200 and xb = 400 will give you a width of 200 pixels !\n        \n            - We crop relative to the current array (i.e. not necessarily to the original array !)\n            This means you can crop several times in a row with xa = 10, it will each time remove 10 pixels in x !\n        \n        But we update the crop region specifications, so that the object remembers how it was cut.\n        \n        Please give positive integers in compatible ranges, no checks are made."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef irafcrop(self, irafcropstring):\n        irafcropstring = irafcropstring[1:-1] # removing the [ ]\n        ranges = irafcropstring.split(\",\")\n        xr = ranges[0].split(\":\")\n        yr = ranges[1].split(\":\")\n        xmin = int(xr[0])\n        xmax = int(xr[1])+1\n        ymin = int(yr[0])\n        ymax = int(yr[1])+1\n        self.crop(xmin, xmax, ymin, ymax)", "response": "Crop the image with the given irafcropstring."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking a PIL image out of the array.", "response": "def makepilimage(self, scale = \"log\", negative = False):\n        \"\"\"\n        Makes a PIL image out of the array, respecting the z1 and z2 cutoffs.\n        By default we use a log scaling identical to iraf's, and produce an image of mode \"L\", i.e. grayscale.\n        But some drawings or colourscales will change the mode to \"RGB\" later, if you choose your own colours.\n        If you choose scale = \"clog\" or \"clin\", you get hue values (aka rainbow colours).\n        \"\"\"\n        \n        if scale == \"log\" or scale == \"lin\":\n            self.negative = negative\n            numpyarrayshape = self.numpyarray.shape\n            calcarray = self.numpyarray.copy()\n            #calcarray.ravel() # does not change in place in fact !\n            calcarray = calcarray.clip(min = self.z1, max = self.z2)\n            \n            if scale == \"log\":\n                calcarray = np.array(map(lambda x: loggray(x, self.z1, self.z2), calcarray))\n            else :\n                calcarray = np.array(map(lambda x: lingray(x, self.z1, self.z2), calcarray))\n            \n            \n            calcarray.shape = numpyarrayshape\n            bwarray = np.zeros(numpyarrayshape, dtype=np.uint8)\n            calcarray.round(out=bwarray)\n            if negative:\n                if self.verbose:\n                    print \"Using negative scale\"\n                bwarray = 255 - bwarray\n            \n            if self.verbose:\n                print \"PIL range : [%i, %i]\" % (np.min(bwarray), np.max(bwarray))\n            \n            # We flip it so that (0, 0) is back in the bottom left corner as in ds9\n            # We do this here, so that you can write on the image from left to right :-)    \n\n            self.pilimage = imop.flip(im.fromarray(bwarray.transpose()))\n            if self.verbose:\n                    print \"PIL image made with scale : %s\" % scale\n            return 0\n    \n        if scale == \"clog\" or scale == \"clin\":\n            \n            \"\"\"\n            rainbow !\n            Algorithm for HSV to RGB from http://www.cs.rit.edu/~ncs/color/t_convert.html, by Eugene Vishnevsky\n            Same stuff then for f2n in C\n            \n            h is from 0 to 360 (hue)\n            s from 0 to 1 (saturation)\n            v from 0 to 1 (brightness)    \n            \"\"\"\n        \n            self.negative = False\n            calcarray = self.numpyarray.transpose()\n            if scale == \"clin\":\n                calcarray = (calcarray.clip(min = self.z1, max = self.z2)-self.z1)/(self.z2 - self.z1) # 0 to 1\n            if scale == \"clog\":\n                calcarray = 10.0 + 990.0 * (calcarray.clip(min = self.z1, max = self.z2)-self.z1)/(self.z2 - self.z1) # 10 to 1000\n                calcarray = (np.log10(calcarray)-1.0)*0.5 # 0 to 1 \n\n            #calcarray = calcarray * 359.0 # This is now our \"hue value\", 0 to 360\n            calcarray = (1.0-calcarray) * 300.0 # I limit this to not go into red again\n            # The order of colours is Violet < Blue < Green < Yellow < Red\n            \n            # We prepare the output arrays\n            rcalcarray = np.ones(calcarray.shape)\n            gcalcarray = np.ones(calcarray.shape)\n            bcalcarray = np.ones(calcarray.shape)\n            \n            h = calcarray/60.0 # sector 0 to 5\n            i = np.floor(h).astype(np.int)\n            \n            v = 1.0 * np.ones(calcarray.shape)\n            s = 1.0 * np.ones(calcarray.shape)\n            \n            f = h - i # factorial part of h, this is an array\n            p = v * ( 1.0 - s )\n            q = v * ( 1.0 - s * f )\n            t = v * ( 1.0 - s * ( 1.0 - f ) )\n            \n            # sector 0:\n            indices = (i == 0)\n            rcalcarray[indices] = 255.0 * v[indices]\n            gcalcarray[indices] = 255.0 * t[indices]\n            bcalcarray[indices] = 255.0 * p[indices]\n            \n            # sector 1:\n            indices = (i == 1)\n            rcalcarray[indices] = 255.0 * q[indices]\n            gcalcarray[indices] = 255.0 * v[indices]\n            bcalcarray[indices] = 255.0 * p[indices]\n            \n            # sector 2:\n            indices = (i == 2)\n            rcalcarray[indices] = 255.0 * p[indices]\n            gcalcarray[indices] = 255.0 * v[indices]\n            bcalcarray[indices] = 255.0 * t[indices]\n            \n            # sector 3:\n            indices = (i == 3)\n            rcalcarray[indices] = 255.0 * p[indices]\n            gcalcarray[indices] = 255.0 * q[indices]\n            bcalcarray[indices] = 255.0 * v[indices]\n            \n            # sector 4:\n            indices = (i == 4)\n            rcalcarray[indices] = 255.0 * t[indices]\n            gcalcarray[indices] = 255.0 * p[indices]\n            bcalcarray[indices] = 255.0 * v[indices]\n            \n            # sector 5:\n            indices = (i == 5)\n            rcalcarray[indices] = 255.0 * v[indices]\n            gcalcarray[indices] = 255.0 * p[indices]\n            bcalcarray[indices] = 255.0 * q[indices]\n            \n            \n            rarray = np.zeros(calcarray.shape, dtype=np.uint8)\n            garray = np.zeros(calcarray.shape, dtype=np.uint8)\n            barray = np.zeros(calcarray.shape, dtype=np.uint8)\n            rcalcarray.round(out=rarray)\n            gcalcarray.round(out=garray)\n            bcalcarray.round(out=barray)\n            \n            carray = np.dstack((rarray,garray,barray))\n            \n            self.pilimage = imop.flip(im.fromarray(carray, \"RGB\"))\n            if self.verbose:\n                    print \"PIL image made with scale : %s\" % scale\n            return 0\n    \n        raise RuntimeError, \"I don't know your colourscale, choose lin log clin or clog !\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef showcutoffs(self, redblue = False):\n        \n        highmask = self.numpyarray > self.z2\n        lowmask = self.numpyarray < self.z1\n        if redblue == False :\n            if self.negative :\n                self.drawmask(highmask, colour = 255)\n                self.drawmask(lowmask, colour = 0)\n            else :\n                self.drawmask(highmask, colour = 0)\n                self.drawmask(lowmask, colour = 255)\n        else :\n            \n            self.drawmask(highmask, colour = (255, 0, 0))\n            self.drawmask(lowmask, colour = (0, 0, 255))", "response": "This method shows the cutoffs of the related image."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef makedraw(self):\n        if self.draw == None:\n            self.draw = imdw.Draw(self.pilimage)", "response": "Auxiliary method to make a draw object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef loadtitlefont(self):\n        if self.titlefont == None:\n#             print 'the bloody fonts dir is????', fontsdir\n#             print 'pero esto que hace??', os.path.join(fontsdir, \"courR18.pil\")\n#             /home/vital/Workspace/pyResources/Scientific_Lib/f2n_fonts/f2n_fonts/courR18.pil\n#             /home/vital/Workspace/pyResources/Scientific_Lib/f2n_fonts\n            self.titlefont = imft.load_path(os.path.join(fontsdir, \"courR18.pil\"))", "response": "Loads the title font from the file system."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef loadlabelfont(self):\n        if self.labelfont == None:\n            self.labelfont = imft.load_path(os.path.join(fontsdir, \"courR10.pil\"))", "response": "Auxiliary method to load label font if not yet done."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef changecolourmode(self, newcolour):\n        if type(newcolour) != type(0) and self.pilimage.mode != \"RGB\":\n            if self.verbose :\n                print \"Switching to RGB !\"\n            self.pilimage = self.pilimage.convert(\"RGB\")\n            self.draw = None # important, we have to bebuild the draw object.\n            self.makedraw()", "response": "Change the colour mode of the current image."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts the coordinates x y of the original array or FITS file to the current coordinates of the PIL image.", "response": "def pilcoords(self, (x,y)):\n        \"\"\"\n        Converts the coordinates (x,y) of the original array or FITS file to the current coordinates of the PIL image,\n        respecting cropping, rebinning, and upsampling.\n        This is only used once the PIL image is available, for drawing.\n        Note that we also have to take care about the different origin conventions here !\n        For PIL, (0,0) is top left, so the y axis needs to be inverted.\n        \"\"\"\n        \n        pilx = int((x - 1 - self.xa) * float(self.upsamplefactor) / float(self.binfactor))\n        pily = int((self.yb - y) * float(self.upsamplefactor) / float(self.binfactor))\n        \n        return (pilx, pily)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a scale from the original array or FITS file to the current PIL coordinates.", "response": "def pilscale(self, r):\n        \"\"\"\n        Converts a \"scale\" (like an aperture radius) of the original array or FITS file to the current PIL coordinates.\n        \"\"\"\n        return r * float(self.upsamplefactor) / float(self.binfactor)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndraw a point on the current image.", "response": "def drawpoint(self, x, y, colour = None):\n        \"\"\"\n        Most elementary drawing, single pixel, used mainly for testing purposes.\n        Coordinates are those of your initial image !\n        \"\"\"\n        self.checkforpilimage()\n        colour = self.defaultcolour(colour)\n        self.changecolourmode(colour)\n        self.makedraw()\n        \n        (pilx, pily) = self.pilcoords((x,y))\n        \n        self.draw.point((pilx, pily), fill = colour)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndraw a circle centered on x y with radius r.", "response": "def drawcircle(self, x, y, r = 10, colour = None, label = None):\n        \"\"\"\n        Draws a circle centered on (x, y) with radius r. All these are in the coordinates of your initial image !\n        You give these x and y in the usual ds9 pixels, (0,0) is bottom left.\n        I will convert this into the right PIL coordiates.\n        \"\"\"\n        \n        self.checkforpilimage()\n        colour = self.defaultcolour(colour)\n        self.changecolourmode(colour)\n        self.makedraw()\n        \n        (pilx, pily) = self.pilcoords((x,y))\n        pilr = self.pilscale(r)\n        \n        self.draw.ellipse([(pilx-pilr+1, pily-pilr+1), (pilx+pilr+1, pily+pilr+1)], outline = colour)\n        \n        if label != None:\n            # The we write it :\n            self.loadlabelfont()\n            textwidth = self.draw.textsize(label, font = self.labelfont)[0]\n            self.draw.text((pilx - float(textwidth)/2.0 + 2, pily + pilr + 4), label, fill = colour, font = self.labelfont)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndrawing a 1 - pixel wide frame AROUND the region you specify.", "response": "def drawrectangle(self, xa, xb, ya, yb, colour=None, label = None):\n        \"\"\"\n        Draws a 1-pixel wide frame AROUND the region you specify. Same convention as for crop().\n        \n        \"\"\"\n    \n        self.checkforpilimage()\n        colour = self.defaultcolour(colour)\n        self.changecolourmode(colour)\n        self.makedraw()\n        \n        (pilxa, pilya) = self.pilcoords((xa,ya))\n        (pilxb, pilyb) = self.pilcoords((xb,yb))\n        \n        self.draw.rectangle([(pilxa, pilyb-1), (pilxb+1, pilya)], outline = colour)\n        \n        if label != None:\n            # The we write it :\n            self.loadlabelfont()\n            textwidth = self.draw.textsize(label, font = self.labelfont)[0]\n            self.draw.text(((pilxa + pilxb)/2.0 - float(textwidth)/2.0 + 1, pilya + 2), label, fill = colour, font = self.labelfont)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef writetitle(self, titlestring, colour = None):\n        \n        self.checkforpilimage()\n        colour = self.defaultcolour(colour)\n        self.changecolourmode(colour)\n        self.makedraw()\n        \n        self.loadtitlefont()\n        \n        imgwidth = self.pilimage.size[0]\n        imgheight = self.pilimage.size[1]\n        textwidth = self.draw.textsize(titlestring, font = self.titlefont)[0]\n        textxpos = imgwidth/2.0 - textwidth/2.0\n        textypos = imgheight - 30\n        \n        self.draw.text((textxpos, textypos), titlestring, fill = colour, font = self.titlefont)\n        \n        if self.verbose :\n            print \"I've written a title on the image.\"", "response": "Writes a title on the image."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite some info on the image.", "response": "def writeinfo(self, linelist, colour = None):\n        \"\"\"\n        We add a longer chunk of text on the upper left corner of the image.\n        Provide linelist, a list of strings that will be written one below the other.\n        \"\"\"\n        \n        self.checkforpilimage()\n        colour = self.defaultcolour(colour)\n        self.changecolourmode(colour)\n        self.makedraw()\n        \n        self.loadinfofont()\n        \n        \n        for i, line in enumerate(linelist):\n            topspacing = 5 + (12 + 5)*i\n            self.draw.text((10, topspacing), line, fill = colour, font = self.infofont)\n        \n        \n        if self.verbose :\n            print \"I've written some info on the image.\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling drawcircle and writelable for an list of stars.", "response": "def drawstarslist(self, dictlist, r = 10, colour = None):\n        \"\"\"\n        Calls drawcircle and writelable for an list of stars.\n        Provide a list of dictionnaries, where each dictionnary contains \"name\", \"x\", and \"y\".\n        \n        \"\"\"\n        \n        self.checkforpilimage()\n        colour = self.defaultcolour(colour)\n        self.changecolourmode(colour)\n        self.makedraw()\n        \n        \n        for star in dictlist:\n            self.drawcircle(star[\"x\"], star[\"y\"], r = r, colour = colour, label = star[\"name\"])\n            #self.writelabel(star[\"x\"], star[\"y\"], star[\"name\"], r = r, colour = colour)\n        \n        if self.verbose :\n            print \"I've drawn %i stars.\" % len(dictlist)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting the PIL image into a png file.", "response": "def tonet(self, outfile):\n        \"\"\"\n        Writes the PIL image into a png.\n        We do not want to flip the image at this stage, as you might have written on it !\n        \"\"\"\n        \n        self.checkforpilimage()\n        if self.verbose :\n            print \"Writing image to %s...\\n%i x %i pixels, mode %s\" % (outfile, self.pilimage.size[0], self.pilimage.size[1], self.pilimage.mode)\n        self.pilimage.save(outfile, \"PNG\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cors_setup(self, request):\n        def cors_headers(request, response):\n            if request.method.lower() == 'options':\n                response.headers.update({\n                    '-'.join([p.capitalize() for p in k.split('_')]): v\n                    for k, v in self.cors_options.items()\n                })\n            else:\n                origin = self.cors_options.get('access_control_allow_origin', '*')\n                expose_headers = self.cors_options.get('access_control_expose_headers', '')\n                response.headers['Access-Control-Allow-Origin'] = origin\n                if expose_headers:\n                    response.headers['Access-Control-Expose-Headers'] = expose_headers\n\n        # setup the CORS supported response\n        request.add_response_callback(cors_headers)", "response": "Sets up the CORS headers response based on the settings used for the API."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef factory(self, request, parent=None, name=None):\n        traverse = request.matchdict['traverse']\n\n        # show documentation at the root path\n        if not traverse:\n            return {}\n        else:\n            service = {}\n            name = name or traverse[0]\n\n            # look for direct pattern matches\n            traversed = '/' + '/'.join(traverse)\n            service_type = None\n            service_object = None\n\n            for route, endpoint in self.routes:\n                result = route.match(traversed)\n                if result is not None:\n                    request.matchdict = result\n                    request.endpoint = endpoint\n                    break\n            else:\n                try:\n                    service_type, service_object = self.services[name]\n                except KeyError:\n                    raise HTTPNotFound()\n\n            if service_type:\n                if isinstance(service_type, Endpoint):\n                    service[name] = service_type\n                elif service_object is None:\n                    service[name] = service_type(request)\n                else:\n                    service[name] = service_type(request, service_object)\n\n            request.api_service = service\n            return service", "response": "Returns a new service for the given request."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a given service to this API.", "response": "def register(self, service, name=''):\n        \"\"\"\n        Exposes a given service to this API.\n        \"\"\"\n        # expose a sub-factory\n        if isinstance(service, ApiFactory):\n            self.services[name] = (service.factory, None)\n\n        # expose a module dynamically as a service\n        elif inspect.ismodule(service):\n            name = name or service.__name__.split('.')[-1]\n\n            # exclude endpoints with patterns\n            for obj in vars(service).values():\n                endpoint = getattr(obj, 'endpoint', None)\n                if isinstance(endpoint, Endpoint) and endpoint.pattern:\n                    route = Route('', endpoint.pattern)\n                    self.routes.append((route, endpoint))\n\n            self.services[name] = (ModuleService, service)\n\n        # expose a class dynamically as a service\n        elif inspect.isclass(service):\n            name = name or service.__name__\n            self.services[name] = (ClassService, service)\n\n        # expose an endpoint directly\n        elif isinstance(getattr(service, 'endpoint', None), Endpoint):\n            if service.endpoint.pattern:\n                route = Route('', service.endpoint.pattern)\n                self.routes.append((route, service.endpoint))\n            else:\n                self.services[service.endpoint.name] = (service.endpoint, None)\n\n        # expose a scope\n        elif isinstance(service, dict):\n            for srv in service.values():\n                try:\n                    self.register(srv)\n                except RuntimeError:\n                    pass\n\n        # expose a list of services\n        elif isinstance(service, list):\n            for srv in service:\n                try:\n                    self.register(srv)\n                except RuntimeError:\n                    pass\n\n        # expose a service directly\n        else:\n            raise RuntimeError('Invalid service provide: {0} ({1}).'.format(service, type(service)))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef serve(self, config, path, route_name=None, permission=None, **view_options):\n        route_name = route_name or path.replace('/', '.').strip('.')\n        path = path.strip('/') + '*traverse'\n\n        self.route_name = route_name\n        self.base_permission = permission\n\n        # configure the route and the path\n        config.add_route(route_name, path, factory=self.factory)\n        config.add_view(\n            self.handle_standard_error,\n            route_name=route_name,\n            renderer='json2',\n            context=StandardError\n        ),\n        config.add_view(\n            self.handle_http_error,\n            route_name=route_name,\n            renderer='json2',\n            context=HTTPException\n        )\n        config.add_view(\n            self.process,\n            route_name=route_name,\n            renderer='json2',\n            **view_options\n        )", "response": "Serves this API from the inputted root path"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef line(separator=\"-\u00b7-\", color=None, padding=None, num=1):\n    for x in range(num):\n        columns = get_terminal_width()\n        separator = \"\".join(\n            separator for x in\n            range(floor(columns/len(separator))))\n        print(padd(colorize(separator.strip(), color), padding))", "response": "Prints a line from the terminal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef padd(text, padding=\"top\", size=1):\n    if padding:\n        padding = padding.lower()\n        pad_all = padding == 'all'\n        padding_top = \"\"\n        if padding and (padding == 'top' or pad_all):\n            padding_top = \"\".join(\"\\n\" for x in range(size))\n        padding_bottom = \"\"\n        if padding and (padding == 'bottom' or pad_all):\n            padding_bottom = \"\".join(\"\\n\" for x in range(size))\n        return \"{}{}{}\".format(padding_top, text, padding_bottom)\n    return text", "response": "Adds extra new lines to the top bottom or all of a String\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef colorize(text, color=\"BLUE\", close=True):\n    if color:\n        color = getattr(colors, color.upper())\n        return color + uncolorize(str(text)) + (colors.RESET if close else \"\")\n    return text", "response": "Colorizes the text for terminal outputs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bold(text, close=True):\n    return getattr(colors, \"BOLD\") + str(text) + \\\n        (colors.RESET if close else \"\")", "response": "Bolds text for terminal outputs\n\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nshorten text to length appends replace_with to end of string", "response": "def cut(text, length=50, replace_with=\"\u2026\"):\n    \"\"\" Shortens text to @length, appends @replace_with to end of string\n        if the string length is > @length\n\n        @text: #str text to shortens\n        @length: #int max length of string\n        @replace_with: #str to replace chars beyond @length with\n        ..\n            from vital.debug import cut\n\n            cut(\"Hello world\", 8)\n            # -> 'Hello w\u2026'\n\n            cut(\"Hello world\", 15)\n            # -> 'Hello world'\n        ..\n    \"\"\"\n    text_len = len(uncolorize(text))\n    if text_len > length:\n        replace_len = len(replace_with)\n        color_spans = [\n            _colors.span() for _colors in _find_colors.finditer(text)]\n        chars = 0\n        _length = length+1 - replace_len\n        for i, c in enumerate(text):\n            broken = False\n            for span in color_spans:\n                if span[0] <= i < span[1]:\n                    broken = True\n                    break\n            if broken:\n                continue\n            chars += 1\n            if chars <= _length:\n                cutoff = i\n            else:\n                break\n        if color_spans:\n            return text[:cutoff] + replace_with + colors.RESET\n        else:\n            return text[:cutoff] + replace_with\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwrapping @text in parentheses (), optionally colors and pads and prints the text. @text: #str text to (flag) @color: #str color to :func:colorize the text within @padding: #str location of padding from :func:padd @show: #bool whether or not to print the text in addition to returning it -> #str (flagged) text .. from vital.debug import flag flag(\"Hello world\", \"blue\") # -> (Hello world) # '(\\x1b[0;34mHello world\\x1b[1;m)' flag(\"Hello world\", \"blue\", show=False) # -> '(\\x1b[0;34mHello world\\x1b[1;m)' flag(\"Hello world\", color=\"blue\", padding=\"all\") # -> # (Hello world) # # '\\\\n(\\x1b[0;34mHello world\\x1b[1;m)\\\\n' ..", "response": "def flag(text=None, color=None, padding=None, show=True, brackets='\u2e28\u2e29'):\n    \"\"\" Wraps @text in parentheses (), optionally colors and pads and\n        prints the text.\n\n        @text: #str text to (flag)\n        @color: #str color to :func:colorize the text within\n        @padding: #str location of padding from :func:padd\n        @show: #bool whether or not to print the text in addition to returning\n            it\n\n        -> #str (flagged) text\n        ..\n            from vital.debug import flag\n\n            flag(\"Hello world\", \"blue\")\n            # -> (Hello world)\n            #    '(\\x1b[0;34mHello world\\x1b[1;m)'\n\n            flag(\"Hello world\", \"blue\", show=False)\n            # -> '(\\x1b[0;34mHello world\\x1b[1;m)'\n\n            flag(\"Hello world\", color=\"blue\", padding=\"all\")\n            # ->\n            #    (Hello world)\n            #\n            #    '\\\\n(\\x1b[0;34mHello world\\x1b[1;m)\\\\n'\n        ..\n    \"\"\"\n    _flag = None\n    if text:\n        _flag = padd(\n            \"{}{}{}\".format(\n                brackets[0],\n                colorize(text, color) if color else text,\n                brackets[1]\n            ),\n            padding\n        )\n        if not show:\n            return _flag\n        else:\n            print(_flag)\n    return _flag or text"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gen_rand_str(*size, use=None, keyspace=None):\n    keyspace = keyspace or (string.ascii_letters + string.digits)\n    keyspace = [char for char in keyspace]\n    use = use or _random\n    use.seed()\n    if size:\n        size = size if len(size) == 2 else (size[0], size[0])\n    else:\n        size = (10, 12)\n    return ''.join(\n        use.choice(keyspace)\n        for _ in range(use.randint(*size)))", "response": "Generates a random string from the specified random module."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the name of the object containing the object and returns as a string", "response": "def get_parent_name(obj):\n    \"\"\" Gets the name of the object containing @obj and returns as a string\n\n        @obj: any python object\n\n        -> #str parent object name or None\n        ..\n            from vital.debug import get_parent_name\n\n            get_parent_name(get_parent_name)\n            # -> 'vital.debug'\n\n            get_parent_name(vital.debug)\n            # -> 'vital'\n\n            get_parent_name(str)\n            # -> 'builtins'\n        ..\n    \"\"\"\n    parent_obj = get_parent_obj(obj)\n    parent_name = get_obj_name(parent_obj) if parent_obj else None\n    n = 0\n    while parent_obj and n < 2500:\n        parent_obj = get_parent_obj(parent_obj)\n        if parent_obj:\n            parent_name = \"{}.{}\".format(get_obj_name(parent_obj), parent_name)\n            n += 1\n    if not parent_name or not len(parent_name):\n        parent_name = None\n        objname = get_obj_name(obj)\n        if objname and len(objname.split(\".\")) > 1:\n            return \".\".join(objname.split(\".\")[:-1])\n        return None\n    return parent_name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_class_that_defined_method(meth):\n    if inspect.ismethod(meth):\n        for cls in inspect.getmro(meth.__self__.__class__):\n            if cls.__dict__.get(meth.__name__) is meth:\n                return cls\n        meth = meth.__func__  # fallback to __qualname__ parsing\n    if inspect.isfunction(meth):\n        cls = getattr(\n            inspect.getmodule(meth),\n            meth.__qualname__.split('.<locals>', 1)[0].rsplit('.', 1)[0])\n        if isinstance(cls, type):\n            return cls\n    return None", "response": "Gets the class object which defined a given method."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_parent_obj(obj):\n    try:\n        cls = get_class_that_defined_method(obj)\n        if cls and cls != obj:\n            return cls\n    except AttributeError:\n        pass\n    if hasattr(obj, '__module__') and obj.__module__:\n        try:\n            module = locate(obj.__module__)\n            assert module is not obj\n            return module\n        except Exception:\n            try:\n                module = module.__module__.split('.')[:-1]\n                if len(module):\n                    return locate(module)\n            except Exception:\n                pass\n    elif hasattr(obj, '__objclass__') and obj.__objclass__:\n        return obj.__objclass__\n    try:\n        assert hasattr(obj, '__qualname__') or hasattr(obj, '__name__')\n        objname = obj.__qualname__ if hasattr(obj, '__qualname__') \\\n            else obj.__name__\n        objname = objname.split(\".\")\n        assert len(objname) > 1\n        return locate(\".\".join(objname[:-1]))\n    except Exception:\n        try:\n            module = importlib.import_module(\".\".join(objname[:-1]))\n            return module\n        except Exception:\n            pass\n    return None", "response": "Gets the name of the object containing obj and returns as a string\n       .."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats the object name in a pretty way that contains a parent object name.", "response": "def format_obj_name(obj, delim=\"<>\"):\n    \"\"\" Formats the object name in a pretty way\n\n        @obj: any python object\n        @delim: the characters to wrap a parent object name in\n\n        -> #str formatted name\n        ..\n            from vital.debug import format_obj_name\n\n            format_obj_name(vital.debug.Timer)\n            # -> 'Timer<vital.debug>'\n\n            format_obj_name(vital.debug)\n            # -> 'debug<vital>'\n\n            format_obj_name(vital.debug.Timer.time)\n            # -> 'time<vital.debug.Timer>'\n        ..\n    \"\"\"\n    pname = \"\"\n    parent_name = get_parent_name(obj)\n    if parent_name:\n        pname = \"{}{}{}\".format(delim[0], get_parent_name(obj), delim[1])\n    return \"{}{}\".format(get_obj_name(obj), pname)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef preprX(*attributes, address=True, full_name=False,\n           pretty=False, keyless=False, **kwargs):\n    \"\"\" `Creates prettier object representations`\n\n        @*attributes: (#str) instance attributes within the object you\n            wish to display. Attributes can be recursive\n            e.g. |one.two.three| for access to |self.one.two.three|\n        @address: (#bool) |True| to include the memory address\n        @full_name: (#bool) |True| to include the full path to the\n            object vs. the qualified name\n        @pretty: (#bool) |True| to allow bolding and coloring\n        @keyless: (#bool) |True| to display the values of @attributes\n            withotu their attribute names\n        ..\n            class Foo(object):\n\n                def __init__(self, bar, baz=None):\n                    self.bar = bar\n                    self.baz = baz\n\n                __repr__ = prepr('bar', 'baz', address=False)\n\n            foo = Foo('foobar')\n            repr(foo)\n        ..\n        |<Foo:bar=`foobar`, baz=None>|\n    \"\"\"\n    def _format(obj, attribute):\n        try:\n            if keyless:\n                val = getattr_in(obj, attribute)\n                if val is not None:\n                    return repr(val)\n            else:\n                return '%s=%s' % (attribute,\n                                  repr(getattr_in(obj, attribute)))\n        except AttributeError:\n            return None\n\n    def prep(obj, address=address, full_name=full_name, pretty=pretty,\n             keyless=keyless, **kwargs):\n        if address:\n            address = \":%s\" % hex(id(obj))\n        else:\n            address = \"\"\n        data = list(filter(lambda x: x is not None,\n                           map(lambda a: _format(obj, a), attributes)))\n        if data:\n            data = ':%s' % ', '.join(data)\n        else:\n            data = ''\n        return stdout_encode(\"<%s%s%s>\" % (get_obj_name(obj), data, address))\n    return prep", "response": "Creates prettier object representations"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_attrs(self, *args, _order=[], **kwargs):\n        for arg in args:\n            if isinstance(arg, (tuple, list)):\n                key, color = arg\n                self.attrs[key] = (None, color)\n            else:\n                self.attrs[arg] = (None, None)\n        if not _order:\n            for key, value in kwargs.items():\n                self.attrs[key] = (value, None)\n        else:\n            for key in _order:\n                self.attrs[key] = (kwargs[key], None)", "response": "Adds attributes to the __repr__ string"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _format_attrs(self):\n        _bold = bold\n        _colorize = colorize\n        if not self.pretty:\n            _bold = lambda x: x\n            _colorize = lambda x, c: x\n        attrs = []\n        add_attr = attrs.append\n        if self.doc and hasattr(self.obj, \"__doc__\"):\n            # Optionally attaches documentation\n            if self.obj.__doc__:\n                add_attr(\"`{}`\".format(self.obj.__doc__.strip()))\n        if self.attrs:\n            # Attach request attributes\n            for key, value in self.attrs.items():\n                value, color = value\n                try:\n                    value = value or \\\n                        self._getattrs(getattr, self.obj, key.split(\".\"))\n                except AttributeError:\n                    pass\n                value = _colorize(value, color) if color else value\n                v = None\n                if value is not None:\n                    value = \"`{}`\".format(value) \\\n                        if isinstance(value, Look.str_) else value\n                    k, v = _bold(key), value\n                else:\n                    k, v = _bold(key), str(value)\n                if v:\n                    k = '{}='.format(k) if not self._no_keys else ''\n                    add_attr(\"{}{}\".format(k, v))\n        if len(attrs):\n            breaker = \"\\n    \" if self.line_break and len(attrs) > 1 else \"\"\n            return breaker + ((\", \"+breaker).join(attrs)) + breaker.strip(\" \")\n        else:\n            return \"\"", "response": "Formats the attributes of the current object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nformats the __repr__ string containing __repr__ output", "response": "def format(self):\n        \"\"\" Formats the __repr__ string\n            -> #str containing __repr__ output\n        \"\"\"\n        _bold = bold\n        _break = \"\\n    \"\n        if not self.pretty:\n            _bold = lambda x: x\n        # Attach memory address and return\n        _attrs = self._format_attrs()\n        parent_name = get_parent_name(self.obj) if self.full_name else None\n        self.data = \"<{}{}:{}{}>{}\".format(\n            parent_name + \".\" if parent_name else \"\",\n            get_obj_name(self.obj),\n            _attrs,\n            \":{}\".format(hex(id(self.obj))) if self.address else \"\",\n            _break+self.supplemental if self.supplemental else \"\")\n        return stdout_encode(self.data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates random string from the current system.", "response": "def randstr(self):\n        \"\"\" -> #str result of :func:gen_rand_str \"\"\"\n        return gen_rand_str(\n            4, 10, use=self.random, keyspace=list(string.ascii_letters))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a random bytes - encoded version of the current n - z instance.", "response": "def randbytes(self):\n        \"\"\" -> #bytes result of bytes-encoded :func:gen_rand_str \"\"\"\n        return gen_rand_str(\n            10, 30, use=self.random, keyspace=list(self.keyspace)\n        ).encode(\"utf-8\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a randomized domain - like name", "response": "def randdomain(self):\n        \"\"\" -> a randomized domain-like name \"\"\"\n        return '.'.join(\n            rand_readable(3, 6, use=self.random, density=3)\n            for _ in range(self.random.randint(1, 2))\n        ).lower()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a random URI - like path", "response": "def randpath(self):\n        \"\"\" -> a random URI-like #str path \"\"\"\n        return '/'.join(\n            gen_rand_str(3, 10, use=self.random, keyspace=list(self.keyspace))\n            for _ in range(self.random.randint(0, 3)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a random tld from the set of TLDs", "response": "def randtld(self):\n        \"\"\" -> a random #str tld via :mod:tlds \"\"\"\n        self.tlds = tuple(tlds.tlds) if not self.tlds else self.tlds\n        return self.random.choice(self.tlds)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a random url - like string via Random.", "response": "def randurl(self):\n        \"\"\" -> a random url-like #str via :prop:randdomain, :prop:randtld,\n                and :prop:randpath\n        \"\"\"\n        return \"{}://{}.{}/{}\".format(\n            self.random.choice((\"http\", \"https\")),\n            self.randdomain, self.randtld, self.randpath)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef randtuple(self):\n        return tuple(\n            self.randint\n            for x in range(0, self.random.randint(3, 10)))", "response": "Returns a random tuple of random integers"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef randdeque(self):\n        return deque(\n            self.randint\n            for x in range(0, self.random.randint(3, 10)))", "response": "Returns a deque of random integers."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a random dictionary of the class", "response": "def randdict(self):\n        \"\"\" -> a #dict of |{random_string: random_int}| \"\"\"\n        return {\n            self.randstr: self._map_type(int)\n            for x in range(self.random.randint(3, 10))}"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef randset(self):\n        return {\n            self._map_type(int)\n            for x in range(self.random.randint(3, 10))}", "response": "Returns a set of random integers"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dict(self, key_depth=1000, tree_depth=1):\n        if not tree_depth:\n            return self._map_type()\n        return {\n            self.randstr: self.dict(key_depth, tree_depth-1)\n            for x in range(key_depth)}", "response": "Creates a dict of random items for the current tree depth."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef defaultdict(self, key_depth=1000, tree_depth=1):\n        if not tree_depth:\n            return self._map_type()\n        _dict = defaultdict()\n        _dict.update({\n            self.randstr: self.defaultdict(key_depth, tree_depth-1)\n            for x in range(key_depth)})\n        return _dict", "response": "Creates a dictionary of random values for the available node types."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a random tuple of size and tree_depth", "response": "def tuple(self, size=1000, tree_depth=1):\n        \"\"\" Creates a random #tuple\n\n            @size: #int number of random values to include in each @tree_depth\n            @tree_depth: #int dict tree dimensions size, i.e.\n                1=|(value1, value2)|\n                2=|((value1, value2), (value1, value2))|\n\n            -> random #tuple\n        \"\"\"\n        if not tree_depth:\n            return self._map_type()\n        return tuple(self.tuple(size, tree_depth-1) for x in range(size))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generator(self, size=1000, tree_depth=1):\n        if not tree_depth:\n            return self._map_type()\n        return (self.generator(size, tree_depth-1) for x in range(size))", "response": "Creates a random generator for the size of the items in the tree_depth."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating random values for the sequence - like objects in the specified structure.", "response": "def sequence(self, struct, size=1000, tree_depth=1, append_callable=None):\n        \"\"\" Generates random values for sequence-like objects\n\n            @struct: the sequence-like structure you want to fill with random\n                data\n            @size: #int number of random values to include in each @tree_depth\n            @tree_depth: #int dict tree dimensions size, i.e.\n                1=|(value1, value2)|\n                2=|((value1, value2), (value1, value2))|\n            @append_callable: #callable method which appends/adds data to your\n                sequence-like structure - e.g. :meth:list.append\n\n            -> random @struct\n            ..\n                from collections import UserList\n                from vital.debug import RandData\n\n                class MySequence(UserList):\n                    pass\n\n                rd = RandData(int)\n\n                my_seq = MySequence()\n                rd.sequence(my_seq, 3, 1, my_seq.append)\n                # -> [88508293836062443, 49097807561770961, 55043550817099444]\n            ..\n        \"\"\"\n        if not tree_depth:\n            return self._map_type()\n        _struct = struct()\n        add_struct = _struct.append if not append_callable \\\n            else getattr(_struct, append_callable)\n        for x in range(size):\n            add_struct(self.sequence(\n                struct, size, tree_depth-1, append_callable))\n        return _struct"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate random values for the dict - like object in the tree.", "response": "def mapping(self, struct, key_depth=1000, tree_depth=1,\n                update_callable=None):\n        \"\"\" Generates random values for dict-like objects\n\n            @struct: the dict-like structure you want to fill with random data\n            @size: #int number of random values to include in each @tree_depth\n            @tree_depth: #int dict tree dimensions size, i.e.\n                1=|{key: value}|\n                2=|{key: {key: value}, key2: {key2: value2}}|\n            @update_callable: #callable method which updates data in your\n                dict-like structure - e.g. :meth:builtins.dict.update\n\n            -> random @struct\n            ..\n                from collections import UserDict\n                from vital.debug import RandData\n\n                class MyDict(UserDict):\n                    pass\n\n                rd = RandData(int)\n\n                my_dict = MyDict()\n                rd.dict(my_dict, 3, 1, my_dict.update)\n                # -> {\n                #   'SE0ZNy0F6O': 42078648993195761,\n                #   'pbK': 70822820981335987,\n                #   '0A5Aa7': 17503122029338459}\n            ..\n        \"\"\"\n        if not tree_depth:\n            return self._map_type()\n        _struct = struct()\n        add_struct = _struct.update if not update_callable \\\n            else getattr(_struct, update_callable)\n        for x in range(key_depth):\n            add_struct({\n                self.randstr: self.mapping(\n                    struct, key_depth, tree_depth-1, update_callable)\n            })\n        return _struct"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a string that is prefixed with the key and value.", "response": "def _dict_prefix(self, key, value, i, dj=0, color=None, separator=\":\"):\n        just = self._justify if i > 0 else dj\n        key = cut(str(key), self._key_maxlen).rjust(just)\n        key = colorize(key, color=color)\n        pref = \"{}{} {}\".format(key, separator, value)\n        \"\"\"pref = \"{}{} {}\".format(colorize(str(key)[:self._key_maxlen]\\\n            .rjust(just), color=color), separator, value)\"\"\"\n        return pref"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat object names in a pretty fashion", "response": "def objname(self, obj=None):\n        \"\"\" Formats object names in a pretty fashion \"\"\"\n        obj = obj or self.obj\n        _objname = self.pretty_objname(obj, color=None)\n        _objname = \"'{}'\".format(colorize(_objname, \"blue\"))\n        return _objname"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nformatting the object in a pretty format.", "response": "def pretty(self, obj=None, display=True):\n        \"\"\" Formats @obj or :prop:obj\n\n            @obj: the object you'd like to prettify\n\n            -> #str pretty object\n        \"\"\"\n        ret = self._format_obj(obj if obj is not None else self.obj)\n        if display:\n            print(ret)\n        else:\n            return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nformat the object to the correct format for the", "response": "def _format_obj(self, item=None):\n        \"\"\" Determines the type of the object and maps it to the correct\n            formatter\n        \"\"\"\n        # Order here matters, odd behavior with tuples\n        if item is None:\n            return getattr(self, 'number')(item)\n        elif isinstance(item, self.str_):\n            #: String\n            return item + \" \"\n        elif isinstance(item, bytes):\n            #: Bytes\n            return getattr(self, 'bytes')(item)\n        elif isinstance(item, self.numeric_):\n            #: Float, int, etc.\n            return getattr(self, 'number')(item)\n        elif isinstance(item, self.dict_):\n            #: Dict\n            return getattr(self, 'dict')(item)\n        elif isinstance(item, self.list_):\n            #: List\n            return getattr(self, 'list')(item)\n        elif isinstance(item, tuple):\n            #: Tuple\n            return getattr(self, 'tuple')(item)\n        elif isinstance(item, types.GeneratorType):\n            #: Generator\n            return getattr(self, 'generator')(item)\n        elif isinstance(item, self.set_):\n            #: Set\n            return getattr(self, 'set')(item)\n        elif isinstance(item, deque):\n            #: Deque\n            return getattr(self, 'deque')(item)\n        elif isinstance(item, Sequence):\n            #: Sequence\n            return getattr(self, 'sequence')(item)\n        #: Any other object\n        return getattr(self, 'object')(item)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_level(self, level):\n        if not level:\n            return None\n        self.levelmap = set()\n        for char in level:\n            self.levelmap = self.levelmap.union(self.levels[char])\n        self.loglevel = level\n        return self.loglevel", "response": "Sets the loglevel to the given level."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlog the message with the given text using the given color.", "response": "def log(self, flag_message=None, padding=None, color=None, force=False):\n        \"\"\" Log Level: :attr:LOG\n\n            @flag_message: #str flags the message with the given text\n                using :func:flag\n            @padding: #str 'top', 'bottom' or 'all', adds a new line to the\n                specified area with :func:padd\n            @color: #str colorizes @flag_message using :func:colorize\n            @force: #bool whether or not to force the message to log in spite\n                of the assigned log level\n\n            ..\n                from vital.debug import Logg\n                logg = Logg(loglevel=\"v\")\n\n                logg(\"World\").log(\"Hello\")\n                # (Hello) World\n\n                logg(\"Hello world\").log()\n                # Hello world\n            ..\n        \"\"\"\n        if self.should_log(self.LOG) or force:\n            self._print_message(\n                flag_message=flag_message, color=color or colors.bold,\n                padding=padding)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef success(self, flag_message=\"Success\", padding=None, force=False):\n        if self.should_log(self.SUCCESS) or force:\n            self._print_message(\n                flag_message=flag_message, color=colors.success_color,\n                padding=padding)", "response": "Log the message with the given text and padding."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlogging the message with the given text and flag the message with the given text using the given padding.", "response": "def complete(self, flag_message=\"Complete\", padding=None, force=False):\n        \"\"\" Log Level: :attr:COMPLETE\n\n            @flag_message: #str flags the message with the given text\n                using :func:flag\n            @padding: #str 'top', 'bottom' or 'all', adds a new line to the\n                specified area with :func:padd\n            @color: #str colorizes @flag_message using :func:colorize\n            @force: #bool whether or not to force the message to log in spite\n                of the assigned log level\n\n            ..\n                from vital.debug import Logg\n                logg = Logg(loglevel=\"v\")\n\n                logg(\"World\").complete(\"Hello\")\n                # (Hello) World\n\n                logg(\"Hello world\").complete()\n                # (Complete) Hello world\n            ..\n        \"\"\"\n        if self.should_log(self.COMPLETE) or force:\n            self._print_message(\n                flag_message=flag_message, color=colors.complete_color,\n                padding=padding)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlogging a notice message to the log file.", "response": "def notice(self, flag_message=\"Notice\", padding=None, force=False):\n        \"\"\" Log Level: :attr:NOTICE\n\n            @flag_message: #str flags the message with the given text\n                using :func:flag\n            @padding: #str 'top', 'bottom' or 'all', adds a new line to the\n                specified area with :func:padd\n            @color: #str colorizes @flag_message using :func:colorize\n            @force: #bool whether or not to force the message to log in spite\n                of the assigned log level\n\n            ..\n                from vital.debug import Logg\n                logg = Logg(loglevel=\"v\")\n\n                logg(\"World\").notice(\"Hello\")\n                # (Hello) World\n\n                logg(\"Hello world\").notice()\n                # (Notice) Hello world\n            ..\n        \"\"\"\n        if self.should_log(self.NOTICE) or force:\n            self._print_message(\n                flag_message=flag_message, color=colors.notice_color,\n                padding=padding)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlog a warning message to the log file.", "response": "def warning(self, flag_message=\"Warning\", padding=None, force=False):\n        \"\"\" Log Level: :attr:WARNING\n\n            @flag_message: #str flags the message with the given text\n                using :func:flag\n            @padding: #str 'top', 'bottom' or 'all', adds a new line to the\n                specified area with :func:padd\n            @color: #str colorizes @flag_message using :func:colorize\n            @force: #bool whether or not to force the message to log in spite\n                of the assigned log level\n\n            ..\n                from vital.debug import Logg\n                logg = Logg(loglevel=\"v\")\n\n                logg(\"World\").warning(\"Hello\")\n                # (Hello) World\n\n                logg(\"Hello world\").warning()\n                # (Warning) Hello world\n            ..\n        \"\"\"\n        if self.should_log(self.WARNING) or force:\n            self._print_message(\n                flag_message=flag_message, color=colors.warning_color,\n                padding=padding)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef error(self, flag_message=\"Error\", padding=None, force=False):\n        if self.should_log(self.ERROR) or force:\n            self._print_message(\n                flag_message=flag_message, color=colors.error_color,\n                padding=padding)", "response": "Log an error message for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef timing(self, flag_message, padding=None, force=False):\n        if self.should_log(self.TIMING) or force:\n            self._print_message(\n                flag_message=Timer.format_time(flag_message), padding=padding,\n                reverse=True, color=colors.timing_color)", "response": "Log a timing message to the log file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncount the number of available log entries in the available log files.", "response": "def count(self, flag_message, padding=None, force=False):\n        \"\"\" Log Level: :attr:COUNT\n\n            @flag_message: time-like #float\n            @padding: #str 'top', 'bottom' or 'all', adds a new line to the\n                specified area with :func:padd\n            @force: #bool whether or not to force the message to log in spite\n                of the assigned log level\n\n            ..\n                from vital.debug import Logg\n                logg = Logg(loglevel=\"v\")\n\n                logg(\"Total apps\").count(3)\n                # Total apps (3)\n\n                logg().count([0, 1, 2, 3])\n                # (4)\n            ..\n        \"\"\"\n        if self.should_log(self.COUNT) or force:\n            flag_message = flag_message \\\n                if isinstance(flag_message, (int, float)) else \\\n                str(len(flag_message))\n            self._print_message(\n                flag_message=flag_message, padding=padding, reverse=True,\n                color=colors.timing_color)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nformats a message with a Look object", "response": "def format_message(self, message):\n        \"\"\" Formats a message with :class:Look \"\"\"\n        look = Look(message)\n        return look.pretty(display=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_messages(self, messages):\n        mess = \"\"\n        for message in self.message:\n            if self.pretty:\n                mess = \"{}{}\".format(mess, self.format_message(message))\n            else:\n                mess += str(message)\n        if self.include_time:\n            return \": {} : {}\".format(\n                datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), mess)\n        return stdout_encode(mess)", "response": "Formats several messages with the same class and encodes them with stdout_encode"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\noutputs the message to the terminal", "response": "def _print_message(self, flag_message=None, color=None, padding=None,\n                       reverse=False):\n        \"\"\" Outputs the message to the terminal \"\"\"\n        if flag_message:\n            flag_message = stdout_encode(flag(flag_message,\n                                              color=color if self.pretty else None,\n                                              show=False))\n            if not reverse:\n                print(padd(flag_message, padding),\n                      self.format_messages(self.message))\n            else:\n                print(self.format_messages(self.message),\n                      padd(flag_message, padding))\n        else:\n            print(self.format_messages(self.message))\n        self.message = []"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild the progress bar", "response": "def format_bar(self):\n        \"\"\" Builds the progress bar \"\"\"\n        pct = floor(round(self.progress/self.size, 2)*100)\n        pr = floor(pct*.33)\n        bar = \"\".join(\n            [\"\u2012\" for x in range(pr)] + [\"\u21a6\"] +\n            [\" \" for o in range(self._barsize-pr-1)])\n        subprogress = self.format_parent_bar() if self.parent_bar else \"\"\n        message = \"Loading{} ={}{} ({}%)\".format(subprogress, bar, \"\u2609\", pct)\n        return message.ljust(len(message)+5)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprint the progress bar and clears it from the terminal", "response": "def finish(self):\n        \"\"\" Resets the progress bar and clears it from the terminal \"\"\"\n        pct = floor(round(self.progress/self.size, 2)*100)\n        pr = floor(pct*.33)\n        bar = \"\".join([\" \" for x in range(pr-1)] + [\"\u21a6\"])\n        subprogress = self.format_parent_bar() if self.parent_bar else \"\"\n        fin = \"Loading{} ={}{} ({}%)\".format(subprogress, bar, \"\u04ff\", pct)\n        print(fin.ljust(len(fin)+5), end=\"\\r\")\n        time.sleep(0.10)\n        print(\"\\033[K\\033[1A\")\n        self.progress = 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, progress=0):\n        self.progress += (progress or 1)\n        if self.visible:\n            if self.progress % self._mod == 1 or\\\n               self.progress == self.size - 1:\n                print(self.format_bar(), end=\"\\r\")\n            if self.progress == (self.size):\n                self.finish()", "response": "Updates the progress bar with the given value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstops the timer and adds it as an interval to the intervals property", "response": "def stop(self, precision=0):\n        \"\"\" Stops the timer, adds it as an interval to :prop:intervals\n            @precision: #int number of decimal places to round to\n\n            -> #str formatted interval time\n        \"\"\"\n        self._stop = time.perf_counter()\n        return self.add_interval(precision)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef format_time(self, sec):\n        # \u00b5sec\n        if sec < 0.001:\n            return \"{}{}\".format(\n                colorize(round(sec*1000000, 2), \"purple\"), bold(\"\u00b5s\"))\n        # ms\n        elif sec < 1.0:\n            return \"{}{}\".format(\n                colorize(round(sec*1000, 2), \"purple\"), bold(\"ms\"))\n        # s\n        elif sec < 60.0:\n            return \"{}{}\".format(\n                colorize(round(sec, 2), \"purple\"), bold(\"s\"))\n        else:\n            floored = floor(sec/60)\n            return \"{}{} {}{}\".format(\n                colorize(floored, \"purple\"),\n                bold(\"m\"),\n                colorize(floor(sec-(floored*60)), \"purple\"),\n                bold(\"s\"))", "response": "Pretty - formats a given time in a readable manner."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_interval(self, precision=0):\n        precision = precision or self.precision\n        interval = round((self._stop - self._start), precision)\n        self.intervals.append(interval)\n        self._intervals_len += 1\n        self._start = time.perf_counter()\n        return self.format_time(interval)", "response": "Adds an interval to the list of intervals and returns a formatted string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef time(self, intervals=1, *args, _show_progress=True, _print=True,\n             _collect_garbage=True, _quiet=True, **kwargs):\n        \"\"\" Measures the execution time of :prop:_callable for @intervals\n\n            @intervals: #int number of intervals to measure the execution time\n                of the function for\n            @*args: arguments to pass to the callable being timed\n            @**kwargs: arguments to pass to the callable being timed\n            @_show_progress: #bool whether or not to print a progress bar\n            @_print: #bool whether or not to print the results of the timing\n            @_collect_garbage: #bool whether or not to garbage collect\n                while timing\n            @_quiet: #bool whether or not to disable the print() function's\n                ability to output to terminal during the timing\n\n            -> :class:collections.OrderedDict of stats about the timing\n        \"\"\"\n        self.reset()\n        args = list(args) + list(self._callableargs[0])\n        _kwargs = self._callableargs[1]\n        _kwargs.update(kwargs)\n        kwargs = _kwargs\n        if not _collect_garbage:\n            gc.disable()  # Garbage collection setting\n        gc.collect()\n        self.allocated_memory = 0\n        for x in self.progress(intervals):\n            if _quiet:  # Quiets print()s in the tested function\n                sys.stdout = NullIO()\n            try:\n                self.start()  # Starts the timer\n                self._callable(*args, **kwargs)\n                self.stop()  # Stops the timer\n            except Exception as e:\n                if _quiet:  # Unquiets prints()\n                    sys.stdout = sys.__stdout__\n                raise e\n            if _quiet:  # Unquiets prints()\n                sys.stdout = sys.__stdout__\n        if not _collect_garbage:\n            gc.enable()  # Garbage collection setting\n        if _print:\n            self.info()", "response": "Measure the execution time of the function for the given number of intervals."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mean(self):\n        return round(np.mean(self.array), self.precision)\\\n            if len(self.array) else None", "response": "Returns the mean value of the time intervals"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef median(self):\n        return round(float(np.median(self.array)), self.precision)\\\n            if len(self.array) else None", "response": "Returns the median value of the time intervals"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef max(self):\n        return round(np.max(self.array), self.precision)\\\n            if len(self.array) else None", "response": "Returns the maximum value of the resource in the array"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the minimum value of the resource class", "response": "def min(self):\n        \"\"\" -> #float :func:numpy.min of the timing intervals \"\"\"\n        return round(np.min(self.array), self.precision)\\\n            if len(self.array) else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stdev(self):\n        return round(np.std(self.array), self.precision)\\\n            if len(self.array) else None", "response": "Returns the standard deviation of the time intervals"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an OrderedDict of stats about the time intervals", "response": "def stats(self):\n        \"\"\" -> :class:collections.OrderedDict of stats about the time intervals\n        \"\"\"\n        return OrderedDict([\n            (\"Intervals\", len(self.array)),\n            (\"Mean\", self.format_time(self.mean or 0)),\n            (\"Min\", self.format_time(self.min or 0)),\n            (\"Median\", self.format_time(self.median or 0)),\n            (\"Max\", self.format_time(self.max or 0)),\n            (\"St. Dev.\", self.format_time(self.stdev or 0)),\n            (\"Total\", self.format_time(self.exectime or 0)),\n        ])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _pct_diff(self, best, other):\n        return colorize(\"{}%\".format(\n            round(((best-other)/best)*100, 2)).rjust(10), \"red\")", "response": "Calculates and colorizes the percent difference between the best and other cluster keys."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef info(self, verbose=None):\n        if self.name:\n            flag(bold(self.name))\n        flag(\"Results after {} intervals\".format(\n            bold(self.num_intervals, close=False)),\n            colors.notice_color, padding=\"top\")\n        line(\"\u2012\")\n        verbose = verbose if verbose is not None else self.verbose\n        if verbose:\n            for result in self._callable_results:\n                result.info()\n                line()\n        diffs = [\n            (i, result.mean)\n            for i, result in enumerate(self._callable_results)\n            if result.mean]\n        ranking = [\n            (i, self._callable_results[i].format_time(r))\n            for i, r in sorted(diffs, key=lambda x: x[1])]\n        max_rlen = len(str(len(ranking)))+2\n        max_rlen2 = max(len(r) for i, r in ranking)+1\n        best = self._callable_results[ranking[0][0]].mean\n        for idx, (i, rank) in enumerate(ranking, 1):\n            _obj_name = Look(self._callables[i]).objname()\n            pct = \"\".rjust(10) if idx == 1 else \\\n                self._pct_diff(best, self._callable_results[i].mean)\n            print(\n                (\"#\"+str(idx)+\" \u00a6\").rjust(max_rlen), rank.rjust(max_rlen2),\n                pct, \"{}\".format(_obj_name))\n        line(\"\u2012\", padding=\"bottom\")", "response": "Prints and formats the results of the timing\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fi_iban_load_map(filename: str) -> dict:\n    out = {}\n    with open(filename, 'rt') as fp:\n        lines = [line.strip().split(',') for line in fp.readlines()]\n        ver = lines.pop(0)\n        head = lines.pop(0)\n        if head != ['National ID', 'BIC Code', 'Financial Institution Name']:\n            raise ValidationError('Incompatible file content in {}'.format(filename))\n        for line in lines:\n            if len(line) == 3 and line[0]:\n                nat_id = str(line[0]).strip()\n                bic_code = line[1].strip()\n                name = line[2].strip()\n                out[nat_id] = (bic_code, name)\n    return out", "response": "Loads Finnish monetary institution codes and BICs from CSV format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef async_lru(size=100):\n    cache = collections.OrderedDict()\n\n    def decorator(fn):\n        @wraps(fn)\n        @asyncio.coroutine\n        def memoizer(*args, **kwargs):\n            key = str((args, kwargs))\n            try:\n                result = cache.pop(key)\n                cache[key] = result\n            except KeyError:\n                if len(cache) >= size:\n                    cache.popitem(last=False)\n                result = cache[key] = yield from fn(*args, **kwargs)\n            return result\n        return memoizer\n    return decorator", "response": "A decorator that returns an asynchronous LRU cache for Python 3. 5."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef choices_label(choices: tuple, value) -> str:\n    for key, label in choices:\n        if key == value:\n            return label\n    return ''", "response": "Returns the label of the object in the choices list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef info(msg, *args, **kw):\n    # type: (str, *Any, **Any) -> None\n    \"\"\" Print sys message to stdout.\n\n    System messages should inform about the flow of the script. This should\n    be a major milestones during the build.\n    \"\"\"\n    if len(args) or len(kw):\n        msg = msg.format(*args, **kw)\n\n    shell.cprint('-- <32>{}<0>'.format(msg))", "response": "Print sys message to stdout."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetermine whether the string pattern is username - like .", "response": "def is_username(string, minlen=1, maxlen=15):\n    \"\"\" Determines whether the @string pattern is username-like\n        @string: #str being tested\n        @minlen: minimum required username length\n        @maxlen: maximum username length\n\n        -> #bool\n    \"\"\"\n    if string:\n        string = string.strip()\n        return username_re.match(string) and (minlen <= len(string) <= maxlen)\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a big integer to a string if it is a big integer.", "response": "def bigint_to_string(val):\n    \"\"\" Converts @val to a string if it is a big integer (|>2**53-1|)\n\n        @val: #int or #float\n\n        -> #str if @val is a big integer, otherwise @val\n    \"\"\"\n    if isinstance(val, _NUMBERS) and not abs(val) <= 2**53-1:\n        return str(val)\n    return val"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves all blank lines in the string", "response": "def remove_blank_lines(string):\n    \"\"\" Removes all blank lines in @string\n\n        -> #str without blank lines\n    \"\"\"\n    return \"\\n\".join(line\n                     for line in string.split(\"\\n\")\n                     if len(line.strip()))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns django. manage. py command manually.", "response": "def _manage_cmd(cmd, settings=None):\n    # type: () -> None\n    \"\"\" Run django ./manage.py command manually.\n\n    This function eliminates the need for having ``manage.py`` (reduces file\n    clutter).\n    \"\"\"\n    import sys\n    from os import environ\n    from peltak.core import conf\n    from peltak.core import context\n    from peltak.core import log\n\n    sys.path.insert(0, conf.get('src_dir'))\n\n    settings = settings or conf.get('django.settings', None)\n    environ.setdefault(\"DJANGO_SETTINGS_MODULE\", settings)\n\n    args = sys.argv[0:-1] + cmd\n\n    if context.get('pretend', False):\n        log.info(\"Would run the following manage command:\\n<90>{}\", args)\n    else:\n        from django.core.management import execute_from_command_line\n        execute_from_command_line(args)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the BranchDetails for the current branch.", "response": "def current_branch():\n    # type: () -> BranchDetails\n    \"\"\" Return the BranchDetails for the current branch.\n\n    Return:\n        BranchDetails: The details of the current branch.\n    \"\"\"\n    cmd = 'git symbolic-ref --short HEAD'\n    branch_name = shell.run(\n        cmd,\n        capture=True,\n        never_pretend=True\n    ).stdout.strip()\n\n    return BranchDetails.parse(branch_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef commit_branches(sha1):\n    # type: (str) -> List[str]\n    \"\"\" Get the name of the branches that this commit belongs to. \"\"\"\n    cmd = 'git branch --contains {}'.format(sha1)\n    return shell.run(\n        cmd,\n        capture=True,\n        never_pretend=True\n    ).stdout.strip().split()", "response": "Returns the names of branches that this commit belongs to."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntry to guess the base branch for the current branch.", "response": "def guess_base_branch():\n    # type: (str) -> Optional[str, None]\n    \"\"\" Try to guess the base branch for the current branch.\n\n    Do not trust this guess. git makes it pretty much impossible to guess\n    the base branch reliably so this function implements few heuristics that\n    will work on most common use cases but anything a bit crazy will probably\n    trip this function.\n\n    Returns:\n        Optional[str]: The name of the base branch for the current branch if\n        guessable or **None** if can't guess.\n    \"\"\"\n    my_branch = current_branch(refresh=True).name\n\n    curr = latest_commit()\n    if len(curr.branches) > 1:\n        # We're possibly at the beginning of the new branch (currently both\n        # on base and new branch).\n        other = [x for x in curr.branches if x != my_branch]\n        if len(other) == 1:\n            return other[0]\n        return None\n    else:\n        # We're on one branch\n        parent = curr\n\n        while parent and my_branch in parent.branches:\n            curr = parent\n\n            if len(curr.branches) > 1:\n                other = [x for x in curr.branches if x != my_branch]\n                if len(other) == 1:\n                    return other[0]\n                return None\n\n            parents = [p for p in curr.parents if my_branch in p.branches]\n            num_parents = len(parents)\n\n            if num_parents > 2:\n                # More than two parent, give up\n                return None\n            if num_parents == 2:\n                # This is a merge commit.\n                for p in parents:\n                    if p.branches == [my_branch]:\n                        parent = p\n                        break\n            elif num_parents == 1:\n                parent = parents[0]\n            elif num_parents == 0:\n                parent = None\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef commit_author(sha1=''):\n    # type: (str) -> Author\n    \"\"\" Return the author of the given commit.\n\n    Args:\n        sha1 (str):\n            The sha1 of the commit to query. If not given, it will return the\n            sha1 for the current commit.\n    Returns:\n        Author: A named tuple ``(name, email)`` with the commit author details.\n    \"\"\"\n    with conf.within_proj_dir():\n        cmd = 'git show -s --format=\"%an||%ae\" {}'.format(sha1)\n        result = shell.run(\n            cmd,\n            capture=True,\n            never_pretend=True\n        ).stdout\n        name, email = result.split('||')\n        return Author(name, email)", "response": "Returns the author of the given commit."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unstaged():\n    # type: () -> List[str]\n    \"\"\" Return a list of unstaged files in the project repository.\n\n    Returns:\n        list[str]: The list of files not tracked by project git repo.\n    \"\"\"\n    with conf.within_proj_dir():\n        status = shell.run(\n            'git status --porcelain',\n            capture=True,\n            never_pretend=True\n        ).stdout\n        results = []\n\n        for file_status in status.split(os.linesep):\n            if file_status.strip() and file_status[0] == ' ':\n                results.append(file_status[3:].strip())\n\n        return results", "response": "Return a list of unstaged files in the project repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ignore():\n    # type: () -> List[str]\n    \"\"\" Return a list of patterns in the project .gitignore\n\n    Returns:\n        list[str]: List of patterns set to be ignored by git.\n    \"\"\"\n\n    def parse_line(line):   # pylint: disable=missing-docstring\n        # Decode if necessary\n        if not isinstance(line, string_types):\n            line = line.decode('utf-8')\n\n        # Strip comment\n        line = line.split('#', 1)[0].strip()\n\n        return line\n\n    ignore_files = [\n        conf.proj_path('.gitignore'),\n        conf.proj_path('.git/info/exclude'),\n        config().get('core.excludesfile')\n    ]\n\n    result = []\n    for ignore_file in ignore_files:\n        if not (ignore_file and os.path.exists(ignore_file)):\n            continue\n\n        with open(ignore_file) as fp:\n            parsed = (parse_line(l) for l in fp.readlines())\n            result += [x for x in parsed if x]\n\n    return result", "response": "Return a list of patterns in the project. gitignore that are not in the project. gitignore file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of branches in the current repo.", "response": "def branches():\n    # type: () -> List[str]\n    \"\"\" Return a list of branches in the current repo.\n\n    Returns:\n        list[str]: A list of branches in the current repo.\n    \"\"\"\n    out = shell.run(\n        'git branch',\n        capture=True,\n        never_pretend=True\n    ).stdout.strip()\n    return [x.strip('* \\t\\n') for x in out.splitlines()]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntag the current commit.", "response": "def tag(name, message, author=None):\n    # type: (str, str, Author, bool) -> None\n    \"\"\" Tag the current commit.\n\n    Args:\n        name (str):\n            The tag name.\n        message (str):\n            The tag message. Same as ``-m`` parameter in ``git tag``.\n        author (Author):\n            The commit author. Will default to the author of the commit.\n        pretend (bool):\n            If set to **True** it will print the full ``git tag`` command\n            instead of actually executing it.\n    \"\"\"\n    cmd = (\n        'git -c \"user.name={author.name}\" -c \"user.email={author.email}\" '\n        'tag -a \"{name}\" -m \"{message}\"'\n    ).format(\n        author=author or latest_commit().author,\n        name=name,\n        message=message.replace('\"', '\\\\\"').replace('`', '\\\\`'),\n    )\n    shell.run(cmd)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef config():\n    # type: () -> dict[str, Any]\n    \"\"\" Return the current git configuration.\n\n    Returns:\n        dict[str, Any]: The current git config taken from ``git config --list``.\n    \"\"\"\n    out = shell.run(\n        'git config --list',\n        capture=True,\n        never_pretend=True\n    ).stdout.strip()\n\n    result = {}\n    for line in out.splitlines():\n        name, value = line.split('=', 1)\n        result[name.strip()] = value.strip()\n\n    return result", "response": "Return the current git configuration."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tags():\n    # type: () -> List[str]\n    \"\"\" Returns all tags in the repo.\n\n    Returns:\n        list[str]: List of all tags in the repo, sorted as versions.\n\n    All tags returned by this function will be parsed as if the contained\n    versions (using ``v:refname`` sorting).\n    \"\"\"\n    return shell.run(\n        'git tag --sort=v:refname',\n        capture=True,\n        never_pretend=True\n    ).stdout.strip().splitlines()", "response": "Returns all tags in the repo sorted as versions."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef verify_branch(branch_name):\n    # type: (str) -> bool\n    \"\"\" Verify if the given branch exists.\n\n    Args:\n        branch_name (str):\n            The name of the branch to check.\n\n    Returns:\n        bool: **True** if a branch with name *branch_name* exits, **False**\n        otherwise.\n    \"\"\"\n    try:\n        shell.run(\n            'git rev-parse --verify {}'.format(branch_name),\n            never_pretend=True\n        )\n        return True\n    except IOError:\n        return False", "response": "Verify if a given branch exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef protected_branches():\n    # type: () -> list[str]\n    \"\"\" Return branches protected by deletion.\n\n    By default those are master and devel branches as configured in pelconf.\n\n    Returns:\n        list[str]: Names of important branches that should not be deleted.\n    \"\"\"\n    master = conf.get('git.master_branch', 'master')\n    develop = conf.get('git.devel_branch', 'develop')\n    return conf.get('git.protected_branches', (master, develop))", "response": "Return branches protected by deletion.\n\n    By default those are master and devel branches as configured in pelconf.\n\n    Returns:\n        list[str]: Names of important branches that should not be deleted."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting of all branches this commit is a part of.", "response": "def branches(self):\n        # type: () -> List[str]\n        \"\"\" List of all branches this commit is a part of. \"\"\"\n        if self._branches is None:\n            cmd = 'git branch --contains {}'.format(self.sha1)\n            out = shell.run(\n                cmd,\n                capture=True,\n                never_pretend=True\n            ).stdout.strip()\n            self._branches = [x.strip('* \\t\\n') for x in out.splitlines()]\n\n        return self._branches"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parents(self):\n        # type: () -> List[CommitDetails]\n        \"\"\" Parents of the this commit. \"\"\"\n        if self._parents is None:\n            self._parents = [CommitDetails.get(x) for x in self.parents_sha1]\n\n        return self._parents", "response": "Return the list of parents of this commit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef number(self):\n        # type: () -> int\n        \"\"\" Return this commits number.\n\n        This is the same as the total number of commits in history up until\n        this commit.\n\n        This value can be useful in some CI scenarios as it allows to track\n        progress on any given branch (although there can be two commits with the\n        same number existing on different branches).\n\n        Returns:\n            int: The commit number/index.\n        \"\"\"\n        cmd = 'git log --oneline {}'.format(self.sha1)\n        out = shell.run(cmd, capture=True, never_pretend=True).stdout.strip()\n        return len(out.splitlines())", "response": "Return this commits number."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(cls, sha1=''):\n        # type: (str) -> CommitDetails\n        \"\"\" Return details about a given commit.\n\n        Args:\n            sha1 (str):\n                The sha1 of the commit to query. If not given, it will return\n                the details for the latest commit.\n\n        Returns:\n            CommitDetails: Commit details. You can use the instance of the\n            class to query git tree further.\n        \"\"\"\n        with conf.within_proj_dir():\n            cmd = 'git show -s --format=\"%H||%an||%ae||%s||%b||%P\" {}'.format(\n                sha1\n            )\n            result = shell.run(cmd, capture=True, never_pretend=True).stdout\n\n        sha1, name, email, title, desc, parents = result.split('||')\n\n        return CommitDetails(\n            sha1=sha1,\n            author=Author(name, email),\n            title=title,\n            desc=desc,\n            parents_sha1=parents.split(),\n        )", "response": "Returns the details about a given commit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsampling usage for this python module This main method simply illustrates sample usage for this python module. :return: None", "response": "def main():\n    \"\"\"Sample usage for this python module\n\n    This main method simply illustrates sample usage for this python\n    module.\n\n    :return: None\n    \"\"\"\n    log = logging.getLogger(Logify.get_name() + '.logify.main')\n    log.info('logger name is: %s', Logify.get_name())\n    log.debug('This is DEBUG')\n    log.info('This is INFO')\n    log.warning('This is a WARNING')\n    log.error('This is an ERROR')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the log level for cons3rt assets using .", "response": "def set_log_level(cls, log_level):\n        \"\"\"Sets the log level for cons3rt assets\n\n        This method sets the logging level for cons3rt assets using\n        pycons3rt. The loglevel is read in from a deployment property\n        called loglevel and set appropriately.\n\n        :type log_level: str\n        :return: True if log level was set, False otherwise.\n        \"\"\"\n        log = logging.getLogger(cls.cls_logger + '.set_log_level')\n        log.info('Attempting to set the log level...')\n        if log_level is None:\n            log.info('Arg loglevel was None, log level will not be updated.')\n            return False\n        if not isinstance(log_level, basestring):\n            log.error('Passed arg loglevel must be a string')\n            return False\n        log_level = log_level.upper()\n        log.info('Attempting to set log level to: %s...', log_level)\n        if log_level == 'DEBUG':\n            cls._logger.setLevel(logging.DEBUG)\n        elif log_level == 'INFO':\n            cls._logger.setLevel(logging.INFO)\n        elif log_level == 'WARN':\n            cls._logger.setLevel(logging.WARN)\n        elif log_level == 'WARNING':\n            cls._logger.setLevel(logging.WARN)\n        elif log_level == 'ERROR':\n            cls._logger.setLevel(logging.ERROR)\n        else:\n            log.error('Could not set log level, this is not a valid log level: %s', log_level)\n            return False\n        log.info('pycons3rt loglevel set to: %s', log_level)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch for a single record in the given index on the name field.", "response": "def get_record_by_name(self, index, name):\n        \"\"\"\n        Searches for a single document in the given index on the 'name' field .\n        Performs a case-insensitive search by utilizing Elasticsearch's `match_phrase` query.\n    \n        Args:\n            index: `str`. The name of an Elasticsearch index (i.e. biosamples).\n            name: `str`. The value of a document's name key to search for.\n    \n        Returns:\n            `dict` containing the document that was indexed into Elasticsearch.\n    \n        Raises:\n            `MultipleHitsException`: More than 1 hit is returned.\n        \"\"\"\n        result = self.ES.search(\n            index=index,\n            body={\n                \"query\": {\n                    \"match_phrase\": {\n                        \"name\": name,\n                    }\n                }\n            }\n        )\n        hits = result[\"hits\"][\"hits\"]\n        if not hits:\n            return {}\n        elif len(hits) == 1:\n            return hits[0][\"_source\"]\n        else:\n            # Mult. records found with same prefix. See if a single record whose name attr matches\n            # the match phrase exactly (in a lower-case comparison).  \n            for h in hits:\n                source = h[\"_source\"]\n                record_name = source[\"name\"]\n                if record_name.lower().strip() == name.lower().strip():\n                    return source\n            msg = \"match_phrase search found multiple records matching query '{}' for index '{}'.\".format(name, index)\n            raise MultipleHitsException(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getattr_in(obj, name):\n    for part in name.split('.'):\n        obj = getattr(obj, part)\n    return obj", "response": "Finds an in object via a period - delimited string name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nimporting a module class or method from string and unwraps it AttributeNames if wrapped by functools AttributeNames.", "response": "def import_from(name):\n    \"\"\" Imports a module, class or method from string and unwraps it\n        if wrapped by functools\n\n        @name: (#str) name of the python object\n\n        -> imported object\n    \"\"\"\n    obj = name\n    if isinstance(name, str) and len(name):\n        try:\n            obj = locate(name)\n            assert obj is not None\n        except (AttributeError, TypeError, AssertionError, ErrorDuringImport):\n            try:\n                name = name.split(\".\")\n                attr = name[-1]\n                name = \".\".join(name[:-1])\n                mod = importlib.import_module(name)\n                obj = getattr(mod, attr)\n            except (SyntaxError, AttributeError, ImportError, ValueError):\n                try:\n                    name = name.split(\".\")\n                    attr_sup = name[-1]\n                    name = \".\".join(name[:-1])\n                    mod = importlib.import_module(name)\n                    obj = getattr(getattr(mod, attr_sup), attr)\n                except:\n                    # We give up.\n                    pass\n\n    obj = unwrap_obj(obj)\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the actual object from a decorated or wrapped function AttributeNames", "response": "def unwrap_obj(obj):\n    \"\"\" Gets the actual object from a decorated or wrapped function\n        @obj: (#object) the object to unwrap\n    \"\"\"\n    try:\n        obj = obj.fget\n    except (AttributeError, TypeError):\n        pass\n    try:\n        # Cached properties\n        if obj.func.__doc__ == obj.__doc__:\n            obj = obj.func\n    except AttributeError:\n        pass\n    try:\n        # Setter/Getters\n        obj = obj.getter\n    except AttributeError:\n        pass\n    try:\n        # Wrapped Funcs\n        obj = inspect.unwrap(obj)\n    except:\n        pass\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds modality to the file name.", "response": "def add_modality(output_path, modality):\n    \"\"\"Modality can be appended to the file name (such as 'bold') or use in the\n    folder (such as \"func\"). You should always use the specific modality ('bold').\n    This function converts it to the folder name.\n    \"\"\"\n    if modality is None:\n        return output_path\n    else:\n        if modality in ('T1w', 'T2star', 'FLAIR', 'PD'):\n            modality = 'anat'\n\n        elif modality == 'bold':\n            modality = 'func'\n\n        elif modality == 'epi':  # topup\n            modality = 'fmap'\n\n        elif modality in ('electrodes', 'coordsystem', 'channels'):\n            modality = 'ieeg'\n\n        elif modality == 'events':\n            raise ValueError('modality \"events\" is ambiguous (can be in folder \"ieeg\" or \"func\"). Assuming \"ieeg\"')\n\n        return output_path / modality"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading configuration from file.", "response": "def load():\n    # type: () -> None\n    \"\"\" Load configuration from file.\n\n    This will search the directory structure upwards to find the project root\n    (directory containing ``pelconf.py`` file). Once found it will import the\n    config file which should initialize all the configuration (using\n    `peltak.core.conf.init()` function).\n\n    You can also have both yaml (configuration) and python (custom commands)\n    living together. Just remember that calling `conf.init()` will overwrite\n    the config defined in YAML.\n    \"\"\"\n    with within_proj_dir():\n        if os.path.exists('pelconf.yaml'):\n            load_yaml_config('pelconf.yaml')\n\n        if os.path.exists('pelconf.py'):\n            load_py_config('pelconf.py')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading a YAML file into the global configuration object.", "response": "def load_yaml_config(conf_file):\n    # type: (str) -> None\n    \"\"\" Load a YAML configuration.\n\n    This will not update the configuration but replace it entirely.\n\n    Args:\n        conf_file (str):\n            Path to the YAML config. This function will not check the file name\n            or extension and will just crash if the given file does not exist or\n            is not a valid YAML file.\n    \"\"\"\n    global g_config\n\n    with open(conf_file) as fp:\n        # Initialize config\n        g_config = util.yaml_load(fp)\n\n        # Add src_dir to sys.paths if it's set. This is only done with YAML\n        # configs, py configs have to do this manually.\n        src_dir = get_path('src_dir', None)\n        if src_dir is not None:\n            sys.path.insert(0, src_dir)\n\n        for cmd in get('commands', []):\n            _import(cmd)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload a configuration file into a python module.", "response": "def load_py_config(conf_file):\n    # type: (str) -> None\n    \"\"\" Import configuration from a python file.\n\n    This will just import the file into python. Sky is the limit. The file\n    has to deal with the configuration all by itself (i.e. call conf.init()).\n    You will also need to add your src directory to sys.paths if it's not the\n    current working directory. This is done automatically if you use yaml\n    config as well.\n\n    Args:\n        conf_file (str):\n            Path to the py module config. This function will not check the file\n            name or extension and will just crash if the given file does not\n            exist or is not a valid python file.\n    \"\"\"\n    if sys.version_info >= (3, 5):\n        from importlib import util\n\n        spec = util.spec_from_file_location('pelconf', conf_file)\n        mod = util.module_from_spec(spec)\n        spec.loader.exec_module(mod)\n\n    elif sys.version_info >= (3, 3):\n        from importlib import machinery\n        loader = machinery.SourceFileLoader('pelconf', conf_file)\n        _ = loader.load_module()\n\n    elif sys.version_info <= (3, 0):\n        import imp\n\n        imp.load_source('pelconf', conf_file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a template from a file.", "response": "def load_template(filename):\n    # type: (str) -> str\n    \"\"\" Load template from file.\n\n    The templates are part of the package and must be included as\n    ``package_data`` in project ``setup.py``.\n\n    Args:\n        filename (str):\n            The template path. Relative to `peltak` package directory.\n\n    Returns:\n        str: The content of the chosen template.\n    \"\"\"\n    template_file = os.path.join(PKG_DIR, 'templates', filename)\n    with open(template_file) as fp:\n        return fp.read()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the absolute path to the project directory.", "response": "def proj_path(*path_parts):\n    # type: (str) -> str\n    \"\"\" Return absolute path to the repo dir (root project directory).\n\n    Args:\n        path (str):\n            The path relative to the project root (pelconf.yaml).\n\n    Returns:\n        str: The given path converted to an absolute path.\n    \"\"\"\n    path_parts = path_parts or ['.']\n\n    # If path represented by path_parts is absolute, do not modify it.\n    if not os.path.isabs(path_parts[0]):\n        proj_path = _find_proj_root()\n\n        if proj_path is not None:\n            path_parts = [proj_path] + list(path_parts)\n\n    return os.path.normpath(os.path.join(*path_parts))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an absolute path to the given project relative path.", "response": "def within_proj_dir(path='.'):\n    # type: (Optional[str]) -> str\n    \"\"\" Return an absolute path to the given project relative path.\n\n    :param path:\n        Project relative path that will be converted to the system wide absolute\n        path.\n    :return:\n        Absolute path.\n    \"\"\"\n    curr_dir = os.getcwd()\n\n    os.chdir(proj_path(path))\n\n    yield\n\n    os.chdir(curr_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the config value with the given name and optional default.", "response": "def get(name, *default):\n    # type: (str, Any) -> Any\n    \"\"\" Get config value with the given name and optional default.\n\n    Args:\n        name (str):\n            The name of the config value.\n        *default (Any):\n            If given and the key doesn't not exist, this will be returned\n            instead. If it's not given and the config value does not exist,\n            AttributeError will be raised\n\n    Returns:\n        The requested config value. This is one of the global values defined\n        in this file. If the value does not exist it will return `default` if\n        give or raise `AttributeError`.\n\n    Raises:\n        AttributeError: If the value does not exist and `default` was not given.\n    \"\"\"\n    global g_config\n\n    curr = g_config\n    for part in name.split('.'):\n        if part in curr:\n            curr = curr[part]\n        elif default:\n            return default[0]\n        else:\n            raise AttributeError(\"Config value '{}' does not exist\".format(\n                name\n            ))\n\n    return curr"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the config value as path relative to the project directory.", "response": "def get_path(name, *default):\n    # type: (str, Any) -> Any\n    \"\"\" Get config value as path relative to the project directory.\n\n    This allows easily defining the project configuration within the fabfile\n    as always relative to that fabfile.\n\n    Args:\n        name (str):\n            The name of the config value containing the path.\n        *default (Any):\n            If given and the key doesn't not exist, this will be returned\n            instead. If it's not given and the config value does not exist,\n            AttributeError will be raised\n\n    Returns:\n        The requested config value. This is one of the global values defined\n        in this file. If the value does not exist it will return `default` if\n        give or raise `AttributeError`.\n\n    Raises:\n        AttributeError: If the value does not exist and `default` was not given.\n    \"\"\"\n    global g_config\n\n    value = get(name, *default)\n\n    if value is None:\n        return None\n\n    return proj_path(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _find_proj_root():\n    # type: () -> Optional[str]\n    \"\"\" Find the project path by going up the file tree.\n\n    This will look in the current directory and upwards for the pelconf file\n    (.yaml or .py)\n    \"\"\"\n    proj_files = frozenset(('pelconf.py', 'pelconf.yaml'))\n    curr = os.getcwd()\n\n    while curr.startswith('/') and len(curr) > 1:\n        if proj_files & frozenset(os.listdir(curr)):\n            return curr\n        else:\n            curr = os.path.dirname(curr)\n\n    return None", "response": "Find the project root of the current directory."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef verify(verified_entity, verification_key):\n        verification = get_object_or_none(Verification, verified_entity=verified_entity)\n\n        if verification is None:\n            raise ServerError(VerificationHandler.STATUS_VERIFICATION_NOT_FOUND)\n        if not verification.verify(verification_key):\n            raise ServerError(VerificationHandler.STATUS_INVALID_VERIFICATION_KEY)\n\n        verification.verified = True\n        verification.save()", "response": "\u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u043e\u0448\u0438\u0431\u043a\u0438 \u043a\u043b\u044e\u0447 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043f\u043e\u043b"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _xml_element_value(el: Element, int_tags: list):\n    # None\n    if el.text is None:\n        return None\n    # int\n    try:\n        if el.tag in int_tags:\n            return int(el.text)\n    except:\n        pass\n    # default to str if not empty\n    s = str(el.text).strip()\n    return s if s else None", "response": "Gets the XML element value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfilter XML tags to remove namespaces.", "response": "def _xml_tag_filter(s: str, strip_namespaces: bool) -> str:\n    \"\"\"\n    Returns tag name and optionally strips namespaces.\n    :param el: Element\n    :param strip_namespaces: Strip namespace prefix\n    :return: str\n    \"\"\"\n    if strip_namespaces:\n        ns_end = s.find('}')\n        if ns_end != -1:\n            s = s[ns_end+1:]\n        else:\n            ns_end = s.find(':')\n            if ns_end != -1:\n                s = s[ns_end+1:]\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef xml_to_dict(xml_bytes: bytes, tags: list=[], array_tags: list=[], int_tags: list=[],\n                strip_namespaces: bool=True, parse_attributes: bool=True,\n                value_key: str='@', attribute_prefix: str='@',\n                document_tag: bool=False) -> dict:\n    \"\"\"\n    Parses XML string to dict. In case of simple elements (no children, no attributes) value is stored as is.\n    For complex elements value is stored in key '@', attributes '@xxx' and children as sub-dicts.\n    Optionally strips namespaces.\n\n    For example:\n        <Doc version=\"1.2\">\n          <A class=\"x\">\n            <B class=\"x2\">hello</B>\n          </A>\n          <A class=\"y\">\n            <B class=\"y2\">world</B>\n          </A>\n          <C>value node</C>\n        </Doc>\n    is returned as follows:\n        {'@version': '1.2',\n         'A': [{'@class': 'x', 'B': {'@': 'hello', '@class': 'x2'}},\n               {'@class': 'y', 'B': {'@': 'world', '@class': 'y2'}}],\n         'C': 'value node'}\n\n    Args:\n        xml_bytes: XML file contents in bytes\n        tags: list of tags to parse (pass empty to return all chilren of top-level tag)\n        array_tags: list of tags that should be treated as arrays by default\n        int_tags: list of tags that should be treated as ints\n        strip_namespaces: if true namespaces will be stripped\n        parse_attributes: Elements with attributes are stored as complex types with '@' identifying text value and @xxx identifying each attribute\n        value_key: Key to store (complex) element value. Default is '@'\n        attribute_prefix: Key prefix to store element attribute values. Default is '@'\n        document_tag: Set True if Document root tag should be included as well\n\n    Returns: dict\n    \"\"\"\n    from xml.etree import ElementTree as ET\n\n    root = ET.fromstring(xml_bytes)\n    if tags:\n        if document_tag:\n            raise Exception('xml_to_dict: document_tag=True does not make sense when using selective tag list since selective tag list finds tags from the whole document, not only directly under root document tag')\n        root_elements = []\n        for tag in tags:\n            root_elements.extend(root.iter(tag))\n    else:\n        root_elements = list(root)\n\n    data = {}\n    for el in root_elements:\n        _xml_set_element_data_r(data, el, array_tags=array_tags, int_tags=int_tags,\n                                strip_namespaces=strip_namespaces, parse_attributes=parse_attributes,\n                                value_key=value_key, attribute_prefix=attribute_prefix)\n\n    # set root attributes\n    if parse_attributes:\n        for a_key, a_val in root.attrib.items():\n            data[attribute_prefix + _xml_tag_filter(a_key, strip_namespaces)] = a_val\n\n    return data if not document_tag else {root.tag: data}", "response": "Parses XML string to dict."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dict_to_element(doc: dict, value_key: str='@', attribute_prefix: str='@') -> Element:\n    from xml.etree import ElementTree as ET\n\n    if len(doc) != 1:\n        raise Exception('Invalid data dict for XML generation, document root must have single element')\n\n    for tag, data in doc.items():\n        el = ET.Element(tag)\n        assert isinstance(el, Element)\n        _xml_element_set_data_r(el, data, value_key, attribute_prefix)\n        return el", "response": "Generates XML element from dict."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef local_property():\n    ls = local()\n\n    def fget(self):\n        try:\n            return ls.var\n        except AttributeError:\n            raise RuntimeError(\"Request context not initialized.\")\n\n    def fset(self, value):\n        ls.var = value\n\n    def fdel(self):\n        del ls.var\n\n    return property(fget, fset, fdel, 'Thread-local property')", "response": "Property structure which maps within the thread - local variable."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_bucket_keys(bucket_name, regex, region_name=None, aws_access_key_id=None, aws_secret_access_key=None):\n    log = logging.getLogger(mod_logger + '.find_bucket_keys')\n    matched_keys = []\n    if not isinstance(regex, basestring):\n        log.error('regex argument is not a string, found: {t}'.format(t=regex.__class__.__name__))\n        return None\n    if not isinstance(bucket_name, basestring):\n        log.error('bucket_name argument is not a string, found: {t}'.format(t=bucket_name.__class__.__name__))\n        return None\n\n    # Set up S3 resources\n    s3resource = boto3.resource('s3', region_name=region_name, aws_access_key_id=aws_access_key_id,\n                                aws_secret_access_key=aws_secret_access_key)\n    bucket = s3resource.Bucket(bucket_name)\n\n    log.info('Looking up S3 keys based on regex: {r}'.format(r=regex))\n    for item in bucket.objects.all():\n        log.debug('Checking if regex matches key: {k}'.format(k=item.key))\n        match = re.search(regex, item.key)\n        if match:\n            matched_keys.append(item.key)\n    log.info('Found matching keys: {k}'.format(k=matched_keys))\n    return matched_keys", "response": "This method searches the S3 bucket for matching the passed regular expression and returns a list of strings containing the keys that match the passed regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_bucket(self):\n        log = logging.getLogger(self.cls_logger + '.validate_bucket')\n        log.info('Attempting to get bucket: {b}'.format(b=self.bucket_name))\n        max_tries = 10\n        count = 1\n        while count <= max_tries:\n            log.info('Attempting to connect to S3 bucket %s, try %s of %s',\n                     self.bucket_name, count, max_tries)\n            try:\n                self.s3client.head_bucket(Bucket=self.bucket_name)\n            except ClientError as e:\n                _, ex, trace = sys.exc_info()\n                error_code = int(e.response['Error']['Code'])\n                log.debug(\n                    'Connecting to bucket %s produced response code: %s',\n                    self.bucket_name, error_code)\n                if error_code == 404:\n                    msg = 'Error 404 response indicates that bucket {b} does not ' \\\n                          'exist:\\n{e}'.format(b=self.bucket_name, e=str(ex))\n                    log.error(msg)\n                    raise S3UtilError, msg, trace\n                elif error_code == 500 or error_code == 503:\n                    if count >= max_tries:\n                        msg = 'S3 bucket is not accessible at this time: {b}\\n{e}'.format(\n                            b=self.bucket_name, e=str(ex))\n                        log.error(msg)\n                        raise S3UtilError, msg, trace\n                    else:\n                        log.warn('AWS returned error code 500 or 503, re-trying in 2 sec...')\n                        time.sleep(5)\n                        count += 1\n                        continue\n                else:\n                    msg = 'Connecting to S3 bucket {b} returned code: {c}\\n{e}'.\\\n                        format(b=self.bucket_name, c=error_code, e=str(ex))\n                    log.error(msg)\n                    raise S3UtilError, msg, trace\n            else:\n                log.info('Found bucket: %s', self.bucket_name)\n                return", "response": "Verify that the specified bucket exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download_file_by_key(self, key, dest_dir):\n        log = logging.getLogger(self.cls_logger + '.download_file_by_key')\n        if not isinstance(key, basestring):\n            log.error('key argument is not a string')\n            return None\n        if not isinstance(dest_dir, basestring):\n            log.error('dest_dir argument is not a string')\n            return None\n        if not os.path.isdir(dest_dir):\n            log.error('Directory not found on file system: %s', dest_dir)\n            return None\n        try:\n            dest_path = self.__download_from_s3(key, dest_dir)\n        except S3UtilError:\n            raise\n        return dest_path", "response": "Downloads a file from the specified S3 bucket and stores it in the specified destination directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef download_file(self, regex, dest_dir):\n        log = logging.getLogger(self.cls_logger + '.download_file')\n        if not isinstance(regex, basestring):\n            log.error('regex argument is not a string')\n            return None\n        if not isinstance(dest_dir, basestring):\n            log.error('dest_dir argument is not a string')\n            return None\n        if not os.path.isdir(dest_dir):\n            log.error('Directory not found on file system: %s', dest_dir)\n            return None\n        key = self.find_key(regex)\n        if key is None:\n            log.warn('Could not find a matching S3 key for: %s', regex)\n            return None\n        return self.__download_from_s3(key, dest_dir)", "response": "Downloads a file from the specified S3 bucket and stores it in the specified destination directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nattempts to find a single S3 key based on the passed regex Given a regular expression, this method searches the S3 bucket for a matching key, and returns it if exactly 1 key matches. Otherwise, None is returned. :param regex: (str) Regular expression for an S3 key :return: (str) Full length S3 key matching the regex, None otherwise", "response": "def find_key(self, regex):\n        \"\"\"Attempts to find a single S3 key based on the passed regex\n\n        Given a regular expression, this method searches the S3 bucket\n        for a matching key, and returns it if exactly 1 key matches.\n        Otherwise, None is returned.\n\n        :param regex: (str) Regular expression for an S3 key\n        :return: (str) Full length S3 key matching the regex, None\n            otherwise\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.find_key')\n        if not isinstance(regex, basestring):\n            log.error('regex argument is not a string')\n            return None\n        log.info('Looking up a single S3 key based on regex: %s', regex)\n        matched_keys = []\n        for item in self.bucket.objects.all():\n            log.debug('Checking if regex matches key: %s', item.key)\n            match = re.search(regex, item.key)\n            if match:\n                matched_keys.append(item.key)\n        if len(matched_keys) == 1:\n            log.info('Found matching key: %s', matched_keys[0])\n            return matched_keys[0]\n        elif len(matched_keys) > 1:\n            log.info('Passed regex matched more than 1 key: %s', regex)\n            return None\n        else:\n            log.info('Passed regex did not match any key: %s', regex)\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_keys(self, regex, bucket_name=None):\n        log = logging.getLogger(self.cls_logger + '.find_keys')\n        matched_keys = []\n        if not isinstance(regex, basestring):\n            log.error('regex argument is not a string, found: {t}'.format(t=regex.__class__.__name__))\n            return None\n\n        # Determine which bucket to use\n        if bucket_name is None:\n            s3bucket = self.bucket\n        else:\n            log.debug('Using the provided S3 bucket: {n}'.format(n=bucket_name))\n            s3bucket = self.s3resource.Bucket(bucket_name)\n\n        log.info('Looking up S3 keys based on regex: {r}'.format(r=regex))\n        for item in s3bucket.objects.all():\n            log.debug('Checking if regex matches key: {k}'.format(k=item.key))\n            match = re.search(regex, item.key)\n            if match:\n                matched_keys.append(item.key)\n        log.info('Found matching keys: {k}'.format(k=matched_keys))\n        return matched_keys", "response": "This method searches the S3 bucket for matching the passed regular expression and returns a list of strings containing the matched S3 keys."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nuploading a file to the specified S3 key using the passed S3 key.", "response": "def upload_file(self, filepath, key):\n        \"\"\"Uploads a file using the passed S3 key\n\n        This method uploads a file specified by the filepath to S3\n        using the provided S3 key.\n\n        :param filepath: (str) Full path to the file to be uploaded\n        :param key: (str) S3 key to be set for the upload\n        :return: True if upload is successful, False otherwise.\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.upload_file')\n        log.info('Attempting to upload file %s to S3 bucket %s as key %s...',\n                 filepath, self.bucket_name, key)\n\n        if not isinstance(filepath, basestring):\n            log.error('filepath argument is not a string')\n            return False\n\n        if not isinstance(key, basestring):\n            log.error('key argument is not a string')\n            return False\n\n        if not os.path.isfile(filepath):\n            log.error('File not found on file system: %s', filepath)\n            return False\n\n        try:\n            self.s3client.upload_file(\n                Filename=filepath, Bucket=self.bucket_name, Key=key)\n        except ClientError as e:\n            log.error('Unable to upload file %s to bucket %s as key %s:\\n%s',\n                      filepath, self.bucket_name, key, e)\n            return False\n        else:\n            log.info('Successfully uploaded file to S3 bucket %s as key %s',\n                     self.bucket_name, key)\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting the specified key in the specified bucket.", "response": "def delete_key(self, key_to_delete):\n        \"\"\"Deletes the specified key\n\n        :param key_to_delete:\n        :return:\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.delete_key')\n\n        log.info('Attempting to delete key: {k}'.format(k=key_to_delete))\n        try:\n            self.s3client.delete_object(Bucket=self.bucket_name, Key=key_to_delete)\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            log.error('ClientError: Unable to delete key: {k}\\n{e}'.format(k=key_to_delete, e=str(ex)))\n            return False\n        else:\n            log.info('Successfully deleted key: {k}'.format(k=key_to_delete))\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck that the current branch is of a given type.", "response": "def assert_branch_type(branch_type):\n    # type: (str) -> None\n    \"\"\" Print error and exit if the current branch is not of a given type.\n\n    Args:\n        branch_type (str):\n            The branch type. This assumes the branch is in the '<type>/<title>`\n            format.\n    \"\"\"\n    branch = git.current_branch(refresh=True)\n\n    if branch.type != branch_type:\n        if context.get('pretend', False):\n            log.info(\"Would assert that you're on a <33>{}/*<32> branch\",\n                     branch_type)\n        else:\n            log.err(\"Not on a <33>{}<31> branch!\", branch_type)\n            fmt = (\"The branch must follow <33>{required_type}/<name><31>\"\n                   \"format and your branch is called <33>{name}<31>.\")\n            log.err(fmt, required_type=branch_type, name=branch.name)\n            sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints error and exit if you re not on a branch.", "response": "def assert_on_branch(branch_name):\n    # type: (str) -> None\n    \"\"\" Print error and exit if *branch_name* is not the current branch.\n\n    Args:\n        branch_name (str):\n            The supposed name of the current branch.\n    \"\"\"\n    branch = git.current_branch(refresh=True)\n\n    if branch.name != branch_name:\n        if context.get('pretend', False):\n            log.info(\"Would assert that you're on a <33>{}<32> branch\",\n                     branch_name)\n        else:\n            log.err(\"You're not on a <33>{}<31> branch!\", branch_name)\n            sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef git_branch_delete(branch_name):\n    # type: (str) -> None\n    \"\"\" Delete the given branch.\n\n    Args:\n        branch_name (str):\n            Name of the branch to delete.\n    \"\"\"\n    if branch_name not in git.protected_branches():\n        log.info(\"Deleting branch <33>{}\", branch_name)\n        shell.run('git branch -d {}'.format(branch_name))", "response": "Delete the given branch."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrenames the current branch to new name.", "response": "def git_branch_rename(new_name):\n    # type: (str) -> None\n    \"\"\" Rename the current branch\n\n    Args:\n        new_name (str):\n            New name for the current branch.\n    \"\"\"\n    curr_name = git.current_branch(refresh=True).name\n\n    if curr_name not in git.protected_branches():\n        log.info(\"Renaming branch from <33>{}<32> to <33>{}\".format(\n            curr_name, new_name\n        ))\n        shell.run('git branch -m {}'.format(new_name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef git_checkout(branch_name, create=False):\n    # type: (str, bool) -> None\n    \"\"\" Checkout or create a given branch\n\n    Args:\n        branch_name (str):\n            The name of the branch to checkout or create.\n        create (bool):\n            If set to **True** it will create the branch instead of checking it\n            out.\n    \"\"\"\n    log.info(\"Checking out <33>{}\".format(branch_name))\n    shell.run('git checkout {} {}'.format('-b' if create else '', branch_name))", "response": "Checkout or create a given branch"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef git_merge(base, head, no_ff=False):\n    # type: (str, str, bool) -> None\n    \"\"\" Merge *head* into *base*.\n\n    Args:\n        base (str):\n            The base branch. *head* will be merged into this branch.\n        head (str):\n            The branch that will be merged into *base*.\n        no_ff (bool):\n            If set to **True** it will force git to create merge commit. If set\n            to **False** (default) it will do a fast-forward merge if possible.\n    \"\"\"\n    pretend = context.get('pretend', False)\n    branch = git.current_branch(refresh=True)\n\n    if branch.name != base and not pretend:\n        git_checkout(base)\n\n    args = []\n\n    if no_ff:\n        args.append('--no-ff')\n\n    log.info(\"Merging <33>{}<32> into <33>{}<32>\", head, base)\n    shell.run('git merge {args} {branch}'.format(\n        args=' '.join(args),\n        branch=head,\n    ))\n\n    if branch.name != base and not pretend:\n        git_checkout(branch.name)", "response": "Merge head into base branch."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the base branch for the current branch.", "response": "def get_base_branch():\n    # type: () -> str\n    \"\"\" Return the base branch for the current branch.\n\n    This function will first try to guess the base branch and if it can't it\n    will let the user choose the branch from the list of all local branches.\n\n    Returns:\n        str: The name of the branch the current branch is based on.\n    \"\"\"\n    base_branch = git.guess_base_branch()\n\n    if base_branch is None:\n        log.info(\"Can't guess the base branch, you have to pick one yourself:\")\n        base_branch = choose_branch()\n\n    return base_branch"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshowing the user a menu to choose a branch from the existing ones.", "response": "def choose_branch(exclude=None):\n    # type: (List[str]) -> str\n    \"\"\" Show the user a menu to pick a branch from the existing ones.\n\n    Args:\n        exclude (list[str]):\n            List of branch names to exclude from the menu. By default it will\n            exclude master and develop branches. To show all branches pass an\n            empty array here.\n\n    Returns:\n        str: The name of the branch chosen by the user. If the user inputs an\n        invalid choice, he will be asked again (and again) until he picks a\n        a valid branch.\n    \"\"\"\n    if exclude is None:\n        master = conf.get('git.master_branch', 'master')\n        develop = conf.get('git.devel_branch', 'develop')\n        exclude = {master, develop}\n\n    branches = list(set(git.branches()) - exclude)\n\n    # Print the menu\n    for i, branch_name in enumerate(branches):\n        shell.cprint('<90>[{}] <33>{}'.format(i + 1, branch_name))\n\n    # Get a valid choice from the user\n    choice = 0\n    while choice < 1 or choice > len(branches):\n        prompt = \"Pick a base branch from the above [1-{}]\".format(\n            len(branches)\n        )\n        choice = click.prompt(prompt, value_proc=int)\n        if not (1 <= choice <= len(branches)):\n            fmt = \"Invalid choice {}, you must pick a number between {} and {}\"\n            log.err(fmt.format(choice, 1, len(branches)))\n\n    return branches[choice - 1]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall the run method of the decorated class if the current file is the main file", "response": "def autorun():\n    '''\n    Call the run method of the decorated class if the current file is the main file\n    '''\n    def wrapper(cls):\n\n        import inspect\n        if inspect.getmodule(cls).__name__ == \"__main__\":\n            cls().run()\n        return cls\n\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unique_list(seq):\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "response": "Returns a list of unique elements from given list or sequence - like object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef flatten(*seqs):\n    for seq in seqs:\n        for item in seq:\n            if isinstance(item, (tuple, list, UserList)):\n                for subitem in flatten(item):\n                    yield subitem\n            else:\n                yield item", "response": "Flattens a sequence e. g. |1 2 3 4 5"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef randrange(seq):\n    seq = seq.copy()\n    choose = rng().choice\n    remove = seq.remove\n    for x in range(len(seq)):\n        y = choose(seq)\n        remove(y)\n        yield y", "response": "Yields random values from the given sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef linear_least_squares(a, b, residuals=False):\n    #  Copyright (c) 2013 Alexandre Drouin. All rights reserved.\n    #  From https://gist.github.com/aldro61/5889795\n    from warnings import warn\n#    from scipy.linalg.fblas import dgemm\n    from scipy.linalg.blas import dgemm\n#    if type(a) != np.ndarray or not a.flags['C_CONTIGUOUS']:\n#        warn('Matrix a is not a C-contiguous numpy array. The solver will create a copy, which will result' + \\\n#             ' in increased memory usage.')\n    a = np.asarray(a, order='c')\n    i = dgemm(alpha=1.0, a=a.T, b=a.T, trans_b=True)\n    x = np.linalg.solve(i, dgemm(alpha=1.0, a=a.T, b=b)).flatten()\n    if residuals:\n        return x, np.linalg.norm(np.dot(a, x) - b)\n    else:\n        return x", "response": "Linearly solve a least - squares solution to a linear matrix equation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating the IP address and return a boolean if the IP address is valid otherwise False", "response": "def validate_ip_address(ip_address):\n    \"\"\"Validate the ip_address\n\n    :param ip_address: (str) IP address\n    :return: (bool) True if the ip_address is valid\n    \"\"\"\n    # Validate the IP address\n    log = logging.getLogger(mod_logger + '.validate_ip_address')\n    if not isinstance(ip_address, basestring):\n        log.warn('ip_address argument is not a string')\n        return False\n\n    # Ensure there are 3 dots\n    num_dots = 0\n    for c in ip_address:\n        if c == '.':\n            num_dots += 1\n    if num_dots != 3:\n        log.info('Not a valid IP address: {i}'.format(i=ip_address))\n        return False\n\n    # Use the socket module to test\n    try:\n        socket.inet_aton(ip_address)\n    except socket.error as e:\n        log.info('Not a valid IP address: {i}\\n{e}'.format(i=ip_address, e=e))\n        return False\n    else:\n        log.info('Validated IP address: %s', ip_address)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ip_addr():\n    log = logging.getLogger(mod_logger + '.ip_addr')\n    log.debug('Running the ip addr command...')\n    ip_addr_output = {}\n\n    command = ['ip', 'addr']\n    try:\n        ip_addr_result = run_command(command, timeout_sec=20)\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        msg = 'There was a problem running command: {c}'.format(c=' '.join(command))\n        raise CommandError, msg, trace\n\n    ip_addr_lines = ip_addr_result['output'].split('\\n')\n\n    for line in ip_addr_lines:\n        line = line.strip()\n        if line.startswith('inet6'):\n            continue\n        elif line.startswith('inet'):\n            parts = line.split()\n            try:\n                ip_address = parts[1].strip().split('/')[0]\n            except KeyError:\n                continue\n            else:\n                if not validate_ip_address(ip_address):\n                    continue\n                else:\n                    for part in parts:\n                        part = part.strip()\n                        if part.strip().startswith('eth') or part.strip().startswith('eno') or \\\n                                part.strip().startswith('ens'):\n                            device = part\n                            ip_addr_output[device] = ip_address\n    return ip_addr_output", "response": "Uses the ip addr command to enumerate IP addresses by device"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding an IP address to an existing alias on the specified interface on the specified Linux systems.", "response": "def alias_ip_address(ip_address, interface, aws=False):\n    \"\"\"Adds an IP alias to a specific interface\n\n    Adds an ip address as an alias to the specified interface on\n    Linux systems.\n\n    :param ip_address: (str) IP address to set as an alias\n    :param interface: (str) The interface number or full device name, if\n        an int is provided assumes the device name is eth<i>\n    :param aws (bool) True to perform additional AWS config\n    :return: None\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.alias_ip_address')\n\n    # Validate args\n    if not isinstance(ip_address, basestring):\n        msg = 'ip_address argument is not a string'\n        log.error(msg)\n        raise TypeError(msg)\n\n    # Validate the IP address\n    if not validate_ip_address(ip_address):\n        msg = 'The provided IP address arg is invalid: {i}'.format(i=ip_address)\n        log.error(msg)\n        raise ValueError(msg)\n\n    # Determine if the interface provided is a full device name\n    try:\n        int(interface)\n    except ValueError:\n        if isinstance(interface, basestring):\n            device_name = str(interface)\n            log.info('Full device name provided, will attempt to alias: {d}'.format(d=device_name))\n        else:\n            raise TypeError('Provided interface arg must be an int or str')\n    else:\n        device_name = 'eth{i}'.format(i=interface)\n        log.info('Integer provided as interface, using device name: {d}'.format(d=device_name))\n\n    # Add alias\n    command = ['ifconfig', '{d}:0'.format(d=device_name), ip_address, 'up']\n    log.info('Running command to bring up the alias: {c}'.format(c=' '.join(command)))\n    try:\n        result = run_command(command)\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        log.warn('CommandError: There was a problem running command: {c}\\n{e}'.format(\n            c=' '.join(command), e=str(ex)))\n    else:\n        log.info('Command produced output:\\n{o}'.format(o=result['output']))\n        if int(result['code']) != 0:\n            log.warn('ifconfig up command produced exit code: {c} and output:\\n{o}'.format(\n                c=result['code'], o=result['output']))\n        else:\n            log.info('ifconfig up exited successfully')\n\n    # Create interface file from the existing file\n    base_ifcfg = os.path.abspath(os.path.join(os.sep, 'etc', 'sysconfig', 'network-scripts', 'ifcfg-{d}'.format(\n            d=device_name)))\n    alias_ifcfg = base_ifcfg + ':0'\n    log.info('Creating interface config file: {f}'.format(f=alias_ifcfg))\n\n    # Ensure the base config file exists\n    if not os.path.isfile(base_ifcfg):\n        raise OSError('Required interface config file not found: {f}'.format(f=base_ifcfg))\n    else:\n        log.info('Found base interface config file: {f}'.format(f=base_ifcfg))\n\n    # Delete the existing interface file if it exists\n    if os.path.isfile(alias_ifcfg):\n        log.info('Alias interface configuration file already exists, removing: {f}'.format(f=alias_ifcfg))\n        try:\n            os.remove(alias_ifcfg)\n        except OSError:\n            _, ex, trace = sys.exc_info()\n            msg = 'OSError: There was a problem removing existing alias config file: {f}\\n{e}'.format(\n                f=alias_ifcfg, e=str(ex))\n            raise OSError, msg, trace\n    else:\n        log.info('No existing alias interface configuration exists yet: {f}'.format(f=alias_ifcfg))\n\n    # Create the interface file\n    log.info('Gathering entries from file: {f}...'.format(f=base_ifcfg))\n    ifcfg_entries = {}\n    try:\n        with open(base_ifcfg, 'r') as f:\n            for line in f:\n                if '=' in line:\n                    parts = line.split('=')\n                    if len(parts) == 2:\n                        parts[0] = parts[0].strip()\n                        parts[1] = parts[1].translate(None, '\"').strip()\n                        ifcfg_entries[parts[0]] = parts[1]\n    except(IOError, OSError):\n        _, ex, trace = sys.exc_info()\n        msg = 'Unable to read file: {f}\\n{e}'.format(f=base_ifcfg, e=str(ex))\n        raise OSError, msg, trace\n\n    # Defined the ifcfg file entries for the alias\n    ifcfg_entries['IPADDR'] = ip_address\n    ifcfg_entries['NETMASK'] = '255.255.255.0'\n    ifcfg_entries['DEVICE'] = '{d}:0'.format(d=device_name)\n    ifcfg_entries['NAME'] = '{d}:0'.format(d=device_name)\n\n    log.info('Creating file: {f}'.format(f=alias_ifcfg))\n    try:\n        with open(alias_ifcfg, 'a') as f:\n            for var, val in ifcfg_entries.iteritems():\n                out_str = str(var) + '=\"' + str(val) + '\"\\n'\n                log.info('Adding entry to %s: %s', alias_ifcfg, out_str)\n                f.write(out_str)\n    except(IOError, OSError):\n        _, ex, trace = sys.exc_info()\n        msg = 'Unable to write to file: {f}\\n{e}'.format(f=alias_ifcfg, e=str(ex))\n        raise OSError, msg, trace\n\n    # Performing additional configuration for AWS\n    if aws:\n        log.info('Checking if this host is actually on AWS...')\n        if is_aws():\n            log.info('Performing additional configuration for AWS...')\n            try:\n                ec2 = EC2Util()\n                ec2.add_secondary_ip(ip_address, interface)\n            except EC2UtilError:\n                _, ex, trace = sys.exc_info()\n                msg = 'Unable to instruct AWS to add a secondary IP address <{ip}> on interface <{d}>\\n{e}'.format(\n                    ip=ip_address, d=device_name, e=str(ex))\n                raise OSError, msg, trace\n            else:\n                log.info('AWS added the secondary IP address <{ip}> on interface <{d}>'.format(\n                    ip=ip_address, d=device_name))\n        else:\n            log.warn('This system is not on AWS, not performing additional configuration')\n\n    log.info('Restarting networking to ensure the changes take effect...')\n    try:\n        service_network_restart()\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        msg = 'CommandError: There was a problem restarting network services\\n{e}'.format(e=str(ex))\n        raise NetworkRestartError, msg, trace\n\n    # Verify the alias was created\n    log.info('Verifying the alias was successfully created...')\n    command = ['/sbin/ifconfig']\n    try:\n        result = run_command(command)\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        log.warn('CommandError: Unable to run ifconfig to verify the IP alias was created\\n{e}'.format(e=str(ex)))\n        return\n\n    # Check for the alias\n    if '{d}:0'.format(d=device_name) not in result['output']:\n        log.warn('The alias was not created yet, system reboot may be required: {d}:0'.format(d=device_name))\n    else:\n        log.info('Alias created successfully!')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconfigure the source IP address for a Linux interface.", "response": "def set_source_ip_for_interface(source_ip_address, desired_source_ip_address, device_num=0):\n    \"\"\"Configures the source IP address for a Linux interface\n\n    :param source_ip_address: (str) Source IP address to change\n    :param desired_source_ip_address: (str) IP address to configure as the source in outgoing packets\n    :param device_num: (int) Integer interface device number to configure\n    :return: None\n    :raises: TypeError, ValueError, OSError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.set_source_ip_for_interface')\n    if not isinstance(source_ip_address, basestring):\n        msg = 'arg source_ip_address must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n    if not isinstance(desired_source_ip_address, basestring):\n        msg = 'arg desired_source_ip_address must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n    if not validate_ip_address(ip_address=source_ip_address):\n        msg = 'The arg source_ip_address was found to be an invalid IP address.  Please pass a valid IP address'\n        log.error(msg)\n        raise ValueError(msg)\n    if not validate_ip_address(ip_address=desired_source_ip_address):\n        msg = 'The arg desired_source_ip_address was found to be an invalid IP address.  Please pass a valid IP address'\n        log.error(msg)\n        raise ValueError(msg)\n\n    # Determine the device name based on the device_num\n    log.debug('Attempting to determine the device name based on the device_num arg...')\n    try:\n        int(device_num)\n    except ValueError:\n        if isinstance(device_num, basestring):\n            device_name = device_num\n            log.info('Provided device_num is not an int, assuming it is the full device name: {d}'.format(\n                d=device_name))\n        else:\n            raise TypeError('device_num arg must be a string or int')\n    else:\n        device_name = 'eth{n}'.format(n=str(device_num))\n        log.info('Provided device_num is an int, assuming device name is: {d}'.format(d=device_name))\n\n    # Build the command\n    # iptables -t nat -I POSTROUTING -o eth0 -s ${RA_ORIGINAL_IP} -j SNAT --to-source\n\n    command = ['iptables', '-t', 'nat', '-I', 'POSTROUTING', '-o', device_name, '-s',\n               source_ip_address, '-j', 'SNAT', '--to-source', desired_source_ip_address]\n    log.info('Running command: {c}'.format(c=command))\n    try:\n        result = run_command(command, timeout_sec=20)\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        msg = 'There was a problem running iptables command: {c}\\n{e}'.format(c=' '.join(command), e=str(ex))\n        log.error(msg)\n        raise OSError, msg, trace\n\n    if int(result['code']) != 0:\n        msg = 'The iptables command produced an error with exit code: {c}, and output:\\n{o}'.format(\n            c=result['code'], o=result['output'])\n        log.error(msg)\n        raise OSError(msg)\n    log.info('Successfully configured the source IP for {d} to be: {i}'.format(\n        d=device_name, i=desired_source_ip_address))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save_logic(self, some_object):\n        some_object.validate_model()\n        some_object.save()\n        self.send_success_response(data=some_object.to_dict())", "response": "Save the object to the database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fmt(msg, *args, **kw):\n    # type: (str, *Any, **Any) -> str\n    \"\"\" Generate shell color opcodes from a pretty coloring syntax. \"\"\"\n    global is_tty\n\n    if len(args) or len(kw):\n        msg = msg.format(*args, **kw)\n\n    opcode_subst = '\\x1b[\\\\1m' if is_tty else ''\n    return re.sub(r'<(\\d{1,2})>', opcode_subst, msg)", "response": "Generate shell color opcodes from a pretty coloring syntax."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint a message to stdout.", "response": "def cprint(msg, *args, **kw):\n    # type: (str, *Any, **Any) -> None\n    \"\"\" Print colored message to stdout. \"\"\"\n    if len(args) or len(kw):\n        msg = msg.format(*args, **kw)\n\n    print(fmt('{}<0>'.format(msg)))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(cmd,\n        capture=False,\n        shell=True,\n        env=None,\n        exit_on_error=None,\n        never_pretend=False):\n    # type: (str, bool, bool, Dict[str, str], bool) -> ExecResult\n    \"\"\" Run a shell command.\n\n    Args:\n        cmd (str):\n            The shell command to execute.\n        shell (bool):\n            Same as in `subprocess.Popen`.\n        capture (bool):\n            If set to True, it will capture the standard input/error instead of\n            just piping it to the caller stdout/stderr.\n        env (dict[str, str]):\n            The subprocess environment variables.\n        exit_on_error (bool):\n            If set to **True**, on failure it will call `sys.exit` with the\n            return code for the executed command.\n        never_pretend (bool):\n            If set to **True** the command will always be executed, even if\n            context.get('pretend') is set to True. If set to **False** or not\n            given, if the `pretend` context value is **True**, this function\n            will only print the command it would execute and then return\n            a fake result.\n\n    Returns:\n        ExecResult: The execution result containing the return code and output\n        (if capture was set to *True*).\n    \"\"\"\n    if context.get('pretend', False) and not never_pretend:\n        cprint('<90>{}', cmd)\n        return ExecResult(\n            cmd,\n            0,              # retcode\n            '',             # stdout\n            '',             # stderr\n            True,           # succeeded\n            False,          # failed\n        )\n\n    if context.get('verbose', 0) > 2:\n        cprint('<90>{}', cmd)\n\n    options = {\n        'bufsize': 1,       # line buffered\n        'shell': shell\n    }\n\n    if exit_on_error is None:\n        exit_on_error = not capture\n\n    if capture:\n        options.update({\n            'stdout': subprocess.PIPE,\n            'stderr': subprocess.PIPE,\n        })\n\n    if env is not None:\n        options['env'] = dict(os.environ)\n        options['env'].update(env)\n\n    p = subprocess.Popen(cmd, **options)\n    stdout, stderr = p.communicate()\n\n    try:\n        if stdout is not None:\n            stdout = stdout.decode('utf-8')\n\n        if stderr is not None:\n            stderr = stderr.decode('utf-8')\n    except AttributeError:\n        # 'str' has no attribute 'decode'\n        pass\n\n    if exit_on_error and p.returncode != 0:\n        sys.exit(p.returncode)\n\n    return ExecResult(\n        cmd,\n        p.returncode,\n        stdout,\n        stderr,\n        p.returncode == 0,\n        p.returncode != 0\n    )", "response": "Runs a command and returns a list of the return code and output of the command."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_payload(request):\n    # always extract values from the URL\n    payload = dict(request.params.mixed())\n\n    # provide override capability from the JSON body\n    try:\n        json_data = request.json_body\n\n    # no JSON body was found, pyramid raises an error\n    # in this situation\n    except StandardError:\n        pass\n\n    else:\n        if not isinstance(json_data, dict):\n            raise HTTPBadRequest('JSON body must be a key=value pairing')\n        else:\n            payload.update(json_data)\n\n    return payload", "response": "Extracts the request s payload information."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main():\n    log = logging.getLogger(mod_logger + '.main')\n    parser = argparse.ArgumentParser(description='This module allows sending email messages.')\n    parser.add_argument('-f', '--file', help='Full path to a plain text file', required=False)\n    parser.add_argument('-s', '--sender', help='Email address of the sender', required=False)\n    parser.add_argument('-r', '--recipient', help='Email address of the recipient', required=False)\n    args = parser.parse_args()\n\n    am = AssetMailer()\n    err = None\n    if args.file:\n        try:\n            am.send_text_file(text_file=args.file, sender=args.sender, recipient=args.recipient)\n        except AssetMailerError:\n            _, ex, trace = sys.exc_info()\n            err = '{n}: There was a problem sending email with file {f} from sender {s} to recipient {r}:\\n{e}'.format(\n                n=ex.__class__.__name__, f=args.file, s=args.sender, r=args.recipient, e=str(ex))\n            log.error(err)\n    else:\n        try:\n            am.send_cons3rt_agent_logs()\n        except AssetMailerError:\n            _, ex, trace = sys.exc_info()\n            err = '{n}: There was a problem sending cons3rt agent log files:\\n{e}'.format(\n                n=ex.__class__.__name__, e=str(ex))\n            log.error(err)\n    if err is None:\n        log.info('Successfully send email')", "response": "This module is called by the module s main function."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends the cons3rt agent log files to the system", "response": "def send_cons3rt_agent_logs(self):\n        \"\"\"Send the cons3rt agent log file\n\n        :return:\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.send_cons3rt_agent_logs')\n\n        if self.cons3rt_agent_log_dir is None:\n            log.warn('There is not CONS3RT agent log directory on this system')\n            return\n\n        log.debug('Searching for log files in directory: {d}'.format(d=self.cons3rt_agent_log_dir))\n        for item in os.listdir(self.cons3rt_agent_log_dir):\n            item_path = os.path.join(self.cons3rt_agent_log_dir, item)\n            if os.path.isfile(item_path):\n                log.info('Sending email with cons3rt agent log file: {f}'.format(f=item_path))\n                try:\n                    self.send_text_file(text_file=item_path)\n                except (TypeError, OSError, AssetMailerError):\n                    _, ex, trace = sys.exc_info()\n                    msg = '{n}: There was a problem sending CONS3RT agent log file: {f}\\n{e}'.format(\n                        n=ex.__class__.__name__, f=item_path, e=str(ex))\n                    raise AssetMailerError, msg, trace\n                else:\n                    log.info('Successfully sent email with file: {f}'.format(f=item_path))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_text_file(self, text_file, sender=None, recipient=None):\n        log = logging.getLogger(self.cls_logger + '.send_text_file')\n\n        if not isinstance(text_file, basestring):\n            msg = 'arg text_file must be a string, found type: {t}'.format(t=text_file.__class__.__name__)\n            raise AssetMailerError(msg)\n\n        if not os.path.isfile(text_file):\n            msg = 'The provided text_file was not found or is not a file: {f}'.format(f=text_file)\n            raise AssetMailerError(msg)\n\n        # Determine sender/recipient\n        if sender is None:\n            sender = default_sender_email\n        if recipient is None:\n            recipient = self.recipient_email\n\n        # Set the email subject\n        file_name = text_file.split(os.path.sep)[-1]\n        subject = self.subject + file_name\n\n        # Read the input text file\n        try:\n            fp = open(text_file, 'rb')\n            mail_message = MIMEText(fp.read())\n            fp.close()\n        except OSError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a problem reading text file: {f}\\n{e}'.format(\n                n=ex.__class__.__name__, f=text_file, e=str(ex))\n            raise AssetMailerError, msg, trace\n\n        # Configure the mail message\n        mail_message['Subject'] = subject\n        mail_message['From'] = sender\n        mail_message['To'] = recipient\n\n        # Configure the SMTP server\n        log.debug('Configuring the SMTP server...')\n        try:\n            s = smtplib.SMTP(self.smtp_server)\n        except (smtplib.SMTPConnectError, socket.timeout, socket.error):\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a problem connecting to SMTP server: {s}\\n{e}'.format(\n                n=ex.__class__.__name__, s=self.smtp_server, e=str(ex))\n            raise AssetMailerError, msg, trace\n\n        # Set the SMTP log level\n        # s.set_debuglevel(debuglevel=__debug__)\n\n        # Set the SMTP server to be localhost\n        log.debug('Sending email with subject {s} to {e}...'.format(s=subject, e=recipient))\n        try:\n            s.sendmail(sender, [recipient], mail_message.as_string())\n        except smtplib.SMTPRecipientsRefused:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: All recipients were refused, nobody got the mail: {r}:\\n{e}'.format(\n                n=ex.__class__.__name__, r=recipient, e=str(ex))\n            raise AssetMailerError, msg, trace\n        except smtplib.SMTPSenderRefused:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: The server did not accept the sender address: {s}:\\n{e}'.format(\n                n=ex.__class__.__name__, s=sender, e=str(ex))\n            raise AssetMailerError, msg, trace\n        except smtplib.SMTPHeloError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: The server did not respond to the HELO greeting\\n{e}'.format(\n                n=ex.__class__.__name__, e=str(ex))\n            raise AssetMailerError, msg, trace\n        except smtplib.SMTPDataError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: The server replied with an unexpected error code (other than a refusal of a recipient)\\n{e}'.\\\n                format(n=ex.__class__.__name__, r=recipient, e=str(ex))\n            raise AssetMailerError, msg, trace\n        except smtplib.SMTPConnectError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a connection error\\n{e}'. \\\n                format(n=ex.__class__.__name__, r=recipient, e=str(ex))\n            raise AssetMailerError, msg, trace\n        else:\n            log.info('Sent email to: {r}'.format(r=recipient))\n        finally:\n            s.quit()", "response": "Sends an email with the contents of the provided text file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_date_range_by_name(name: str, today: datetime=None, tz=None) -> (datetime, datetime):\n    if today is None:\n        today = datetime.utcnow()\n    if name == 'last_month':\n        return last_month(today, tz)\n    elif name == 'last_week':\n        return last_week(today, tz)\n    elif name == 'this_month':\n        return this_month(today, tz)\n    elif name == 'last_year':\n        return last_year(today, tz)\n    elif name == 'yesterday':\n        return yesterday(today, tz)\n    elif name == 'today':\n        begin = today.replace(hour=0, minute=0, second=0, microsecond=0)\n        end = begin + timedelta(hours=24)\n        return localize_time_range(begin, end, tz)\n    else:\n        m = re.match(r'^plus_minus_(\\d+)d$', name)\n        if m:\n            days = int(m.group(1))\n            return localize_time_range(today - timedelta(days=days), today + timedelta(days=days), tz)\n        m = re.match(r'^prev_(\\d+)d$', name)\n        if m:\n            days = int(m.group(1))\n            return localize_time_range(today - timedelta(days=days), today, tz)\n        m = re.match(r'^next_(\\d+)d$', name)\n        if m:\n            days = int(m.group(1))\n            return localize_time_range(today, today + timedelta(days=days), tz)\n    raise ValueError('Invalid date range name: {}'.format(name))", "response": "Get a date range by name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the options dictionary to get the datetime range and the list of times that are needed to select the next time.", "response": "def parse_date_range_arguments(options: dict, default_range='last_month') -> (datetime, datetime, list):\n    \"\"\"\n    :param options:\n    :param default_range: Default datetime range to return if no other selected\n    :return: begin, end, [(begin1,end1), (begin2,end2), ...]\n    \"\"\"\n    begin, end = get_date_range_by_name(default_range)\n    for range_name in TIME_RANGE_NAMES:\n        if options.get(range_name):\n            begin, end = get_date_range_by_name(range_name)\n    if options.get('begin'):\n        t = parse(options['begin'], default=datetime(2000, 1, 1))\n        begin = pytz.utc.localize(t)\n        end = now()\n    if options.get('end'):\n        end = pytz.utc.localize(parse(options['end'], default=datetime(2000, 1, 1)))\n\n    step_type = None\n    after_end = end\n    for step_name in TIME_STEP_NAMES:\n        if options.get(step_name):\n            step_type = getattr(rrule, step_name.upper())\n            if rrule.DAILY == step_type:\n                after_end += timedelta(days=1)\n            if rrule.WEEKLY == step_type:\n                after_end += timedelta(days=7)\n            if rrule.MONTHLY == step_type:\n                after_end += timedelta(days=31)\n    steps = None\n    if step_type:\n        begins = [t for t in rrule.rrule(step_type, dtstart=begin, until=after_end)]\n        steps = [(begins[i], begins[i+1]) for i in range(len(begins)-1)]\n    if steps is None:\n        steps = [(begin, end)]\n    return begin, end, steps"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload the elements of the current species and set the attributes of the current species.", "response": "def load_elements(self):\n\n        #Set atomic data \n        #atomicData.setDataFile('he_i_rec_Pal12-Pal13.fits')\n        atomicData.setDataFile('s_iii_coll_HRS12.dat')\n \n        #Default: 's_iii_atom_PKW09.dat' \n        'S3: All energy and A values: Podobedova, Kelleher, and Wiese 2009, J. Phys. Chem. Ref. Data, Vol.'\n        'S3: collision strengths: Tayal & Gupta 1999, ApJ, 526, 544'\n\n        #New Atomic data s_iii_coll_HRS12.dat\n        'S3: All energy and A values: Podobedova, Kelleher, and Wiese 2009, J. Phys. Chem. Ref. Data, Vol.'\n        'S3: collision strengths: Hudson, Ramsbottom & Scott 2012, ApJ, 750, 65'\n        \n        #Declare ions\n        self.S2_atom            = Atom('S', 2)\n        self.S3_atom            = Atom('S', 3)\n        self.Ar3_atom           = Atom('Ar', 3)\n        self.Ar4_atom           = Atom('Ar', 4)\n        self.N2_atom            = Atom('N', 2)\n        self.O2_atom            = Atom('O', 2)\n        self.O3_atom            = Atom('O', 3)\n        self.H1_atom            = RecAtom('H', 1)\n        self.He1_atom           = RecAtom('He', 1)\n        self.He2_atom           = RecAtom('He', 2)\n        \n        #Pyneb objects\n        self.diags              = Diagnostics()\n        \n        #Ohrs 2016 relation for the OI_SI gradient\n        self.logSI_OI_Gradient  = random.normal(-1.53,  0.05, size = self.MC_array_len) # random.normal(-1.78,  0.03, size = self.MC_array_len)\n        self.OI_SI              = power(10, -self.logSI_OI_Gradient)\n        \n        #Theoretical ratios\n        self.S3_ratio           = self.S3_atom.getEmissivity(10000, 100, wave = 9531) / self.S3_atom.getEmissivity(10000, 100, wave = 9069)\n        self.S3_9000_ratio      = random.normal(self.S3_atom.getEmissivity(10000, 100, wave = 9531) / self.S3_atom.getEmissivity(10000, 100, wave = 9069),  0.01, size = self.MC_array_len)\n        self.N2_6000_ratio      = self.N2_atom.getEmissivity(10000, 100, wave = 6584) / self.N2_atom.getEmissivity(10000, 100, wave = 6548)\n        self.O3_5000_ratio      = self.O3_atom.getEmissivity(10000, 100, wave = 5007) / self.O3_atom.getEmissivity(10000, 100, wave = 4959)\n        \n        #Factors to speed calculations\n        self.lines_factors = {}\n        self.lines_factors['S3_9069A'] = 1 + self.S3_ratio\n        self.lines_factors['S3_9531A'] = 1 + 1/self.S3_ratio\n        \n        #Cloudy models for the SIV contribution\n        \n        self.m_SIV_correction   = random.normal(1.1628,  0.00559, size = self.MC_array_len)\n        self.n_SIV_correction   = random.normal(0.0470,  0.0097, size = self.MC_array_len)\n        #self.m_SIV_correction   = random.normal(1.109,  0.01, size = self.MC_array_len)\n        #self.n_SIV_correction   = random.normal(0.135,  0.0173, size = self.MC_array_len)\n \n        #CHAOS relation TNII-TSIII\n        #T[SIII]  = 1.312(+-0.075)T[NII]-0.313(+-0.058)\n                #TNII     = (0.762+-0.044)*TSIII  + 0.239+-0.046\n        self.m_TNII_correction   = random.normal(0.762,  0.044, size = self.MC_array_len)\n        self.n_TNII_correction   = random.normal(0.239,  0.046, size = self.MC_array_len)       \n        \n        \n        #Truncated gaussian for the density\n        lower_trunc, upper_trunc = (1.0 - 50.0) / 25.0, (100 - 50) / 25.0\n        self.Truncated_gaussian  = truncnorm(lower_trunc,  upper_trunc, loc = 50, scale = 25)\n       \n        print '-Elements loaded\\n'\n       \n        return"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef git_clone(url, clone_dir, branch='master', username=None, password=None, max_retries=10, retry_sec=30,\n              git_cmd=None):\n    \"\"\"Clones a git url\n\n    :param url: (str) Git URL in https or ssh\n    :param clone_dir: (str) Path to the desired destination dir\n    :param branch: (str) branch to clone\n    :param username: (str) username for the git repo\n    :param password: (str) password for the git repo\n    :param max_retries: (int) the number of attempt to clone the git repo\n    :param retry_sec: (int) number of seconds in between retries of the git clone\n    :param git_cmd: (str) Path to git executable (required on Windows)\n    :return: None\n    :raises: PyGitError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.git_clone')\n\n    if not isinstance(url, basestring):\n        msg = 'url arg must be a string'\n        log.error(msg)\n        raise PyGitError(msg)\n    if not isinstance(clone_dir, basestring):\n        msg = 'clone_dir arg must be a string'\n        log.error(msg)\n        raise PyGitError(msg)\n    if not isinstance(max_retries, int):\n        msg = 'max_retries arg must be an int'\n        log.error(msg)\n        raise PyGitError(msg)\n    if not isinstance(retry_sec, int):\n        msg = 'retry_sec arg must be an int'\n        log.error(msg)\n        raise PyGitError(msg)\n\n    # Configure username/password if provided\n    if url.startswith('https://') and username is not None and password is not None:\n        stripped_url = str(url)[8:]\n        log.info('Encoding password: {p}'.format(p=password))\n        encoded_password = encode_password(password=password)\n        clone_url = 'https://{u}:{p}@{v}'.format(u=username, p=encoded_password, v=stripped_url)\n        log.info('Configured username/password for the GIT Clone URL: {u}'.format(u=url))\n    else:\n        clone_url = str(url)\n\n    # Find the git command\n    if git_cmd is None:\n        log.info('Git executable not provided, attempting to determine (this will only work on *NIX platforms...')\n        command = ['which', 'git']\n        try:\n            result = run_command(command)\n        except CommandError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to find the git executable\\n{e}'.format(e=str(ex))\n            log.error(msg)\n            raise PyGitError, msg, trace\n        else:\n            git_cmd = result['output']\n\n    if not os.path.isfile(git_cmd):\n        msg = 'Could not find git command: {g}'.format(g=git_cmd)\n        log.error(msg)\n        raise PyGitError(msg)\n\n    # Build a git clone or git pull command based on the existence of the clone directory\n    if os.path.isdir(clone_dir):\n        log.debug('Git repo directory already exists, updating repo in: {d}'.format(d=clone_dir))\n        os.chdir(clone_dir)\n        command = [git_cmd, 'pull']\n    else:\n        # Create a subdirectory to clone into\n        log.debug('Creating the repo directory: {d}'.format(d=clone_dir))\n        try:\n            mkdir_p(clone_dir)\n        except CommandError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to create source directory: {d}\\n{e}'.format(d=clone_dir, e=str(ex))\n            log.error(msg)\n            raise PyGitError, msg, trace\n\n        # Create the git clone command\n        command = [git_cmd, 'clone', '-b', branch, clone_url, clone_dir]\n\n    # Run the git command\n    log.info('Running git command: {c}'.format(c=command))\n    for i in range(max_retries):\n        attempt_num = i + 1\n        log.info('Attempt #{n} to git clone the repository...'.format(n=attempt_num))\n        try:\n            result = run_command(command)\n        except CommandError:\n            _, ex, trace = sys.exc_info()\n            log.warn('There was a problem running the git command: {c}\\n{e}'.format(c=command, e=str(ex)))\n        else:\n            if result['code'] != 0:\n                log.warn('The git command {g} failed and returned exit code: {c}\\n{o}'.format(\n                    g=command, c=result['code'], o=result['output']))\n            else:\n                log.info('Successfully cloned/updated GIT repo: {u}'.format(u=url))\n                return\n        if attempt_num == max_retries:\n            msg = 'Attempted unsuccessfully to clone the git repo after {n} attempts'.format(n=attempt_num)\n            log.error(msg)\n            raise PyGitError(msg)\n        log.info('Waiting to retry the git clone in {t} seconds...'.format(t=retry_sec))\n        time.sleep(retry_sec)", "response": "Clones a git repository into a new directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef encode_password(password):\n    log = logging.getLogger(mod_logger + '.password_encoder')\n    log.debug('Encoding password: {p}'.format(p=password))\n    encoded_password = ''\n    for c in password:\n        encoded_password += encode_character(char=c)\n    log.debug('Encoded password: {p}'.format(p=encoded_password))\n    return encoded_password", "response": "Performs URL encoding for passwords\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting different tags as dicts ready to use as dropdown lists.", "response": "def search_tags_as_filters(tags):\n    \"\"\"Get different tags as dicts ready to use as dropdown lists.\"\"\"\n    # set dicts\n    actions = {}\n    contacts = {}\n    formats = {}\n    inspire = {}\n    keywords = {}\n    licenses = {}\n    md_types = dict()\n    owners = defaultdict(str)\n    srs = {}\n    unused = {}\n    # 0/1 values\n    compliance = 0\n    type_dataset = 0\n    # parsing tags\n    print(len(tags.keys()))\n    i = 0\n    for tag in sorted(tags.keys()):\n        i += 1\n        # actions\n        if tag.startswith(\"action\"):\n            actions[tags.get(tag, tag)] = tag\n            continue\n        # compliance INSPIRE\n        elif tag.startswith(\"conformity\"):\n            compliance = 1\n            continue\n        # contacts\n        elif tag.startswith(\"contact\"):\n            contacts[tags.get(tag)] = tag\n            continue\n        # formats\n        elif tag.startswith(\"format\"):\n            formats[tags.get(tag)] = tag\n            continue\n        # INSPIRE themes\n        elif tag.startswith(\"keyword:inspire\"):\n            inspire[tags.get(tag)] = tag\n            continue\n        # keywords\n        elif tag.startswith(\"keyword:isogeo\"):\n            keywords[tags.get(tag)] = tag\n            continue\n        # licenses\n        elif tag.startswith(\"license\"):\n            licenses[tags.get(tag)] = tag\n            continue\n        # owners\n        elif tag.startswith(\"owner\"):\n            owners[tags.get(tag)] = tag\n            continue\n        # SRS\n        elif tag.startswith(\"coordinate-system\"):\n            srs[tags.get(tag)] = tag\n            continue\n        # types\n        elif tag.startswith(\"type\"):\n            md_types[tags.get(tag)] = tag\n            if tag in (\"type:vector-dataset\", \"type:raster-dataset\"):\n                type_dataset += 1\n            else:\n                pass\n            continue\n        # ignored tags\n        else:\n            unused[tags.get(tag)] = tag\n            continue\n\n    # override API tags to allow all datasets filter - see #\n    if type_dataset == 2:\n        md_types[\"Donn\u00e9e\"] = \"type:dataset\"\n    else:\n        pass\n    # printing\n    # print(\"There are:\"\n    #       \"\\n{} actions\"\n    #       \"\\n{} contacts\"\n    #       \"\\n{} formats\"\n    #       \"\\n{} INSPIRE themes\"\n    #       \"\\n{} keywords\"\n    #       \"\\n{} licenses\"\n    #       \"\\n{} owners\"\n    #       \"\\n{} SRS\"\n    #       \"\\n{} types\"\n    #       \"\\n{} unused\".format(len(actions),\n    #                            len(contacts),\n    #                            len(formats),\n    #                            len(inspire),\n    #                            len(keywords),\n    #                            len(licenses),\n    #                            len(owners),\n    #                            len(srs),\n    #                            len(md_types),\n    #                            len(unused)\n    #                            ))\n    # storing dicts\n    tags_parsed = {\n        \"actions\": actions,\n        \"compliance\": compliance,\n        \"contacts\": contacts,\n        \"formats\": formats,\n        \"inspire\": inspire,\n        \"keywords\": keywords,\n        \"licenses\": licenses,\n        \"owners\": owners,\n        \"srs\": srs,\n        \"types\": md_types,\n        \"unused\": unused,\n    }\n\n    # method ending\n    return tags_parsed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate(self, verified, keygen):\n        return Verification(\n            verified_entity=verified,\n            key=keygen(),\n            verified=False\n        )", "response": "Generate a new instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning BIC code and bank name from IBAN number.", "response": "def iban_bank_info(v: str) -> (str, str):\n    \"\"\"\n    Returns BIC code and bank name from IBAN number.\n    :param v: IBAN account number\n    :return: (BIC code, bank name) or ('', '') if not found / unsupported country\n    \"\"\"\n    v = iban_filter(v)\n    if v[:2] == 'FI':\n        return fi_iban_bank_info(v)\n    else:\n        return '', ''"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd Finland reference number checksum to existing number.", "response": "def fi_payment_reference_number(num: str):\n    \"\"\"\n    Appends Finland reference number checksum to existing number.\n    :param num: At least 3 digits\n    :return: Number plus checksum\n    \"\"\"\n    assert isinstance(num, str)\n    num = STRIP_WHITESPACE.sub('', num)\n    num = re.sub(r'^0+', '', num)\n    assert len(num) >= 3\n    weights = [7, 3, 1]\n    weighed_sum = 0\n    numlen = len(num)\n    for j in range(numlen):\n        weighed_sum += int(num[numlen - 1 - j]) * weights[j % 3]\n    return num + str((10 - (weighed_sum % 10)) % 10)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef iso_payment_reference_validator(v: str):\n    num = ''\n    v = STRIP_WHITESPACE.sub('', v)\n    for ch in v[4:] + v[0:4]:\n        x = ord(ch)\n        if ord('0') <= x <= ord('9'):\n            num += ch\n        else:\n            x -= 55\n            if x < 10 or x > 35:\n                raise ValidationError(_('Invalid payment reference: {}').format(v))\n            num += str(x)\n    res = Decimal(num) % Decimal('97')\n    if res != Decimal('1'):\n        raise ValidationError(_('Invalid payment reference: {}').format(v))", "response": "Validates ISO payment reference checksum."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fi_iban_bank_info(v: str) -> (str, str):\n    from jutil.bank_const_fi import FI_BIC_BY_ACCOUNT_NUMBER, FI_BANK_NAME_BY_BIC\n    v = iban_filter(v)\n    bic = FI_BIC_BY_ACCOUNT_NUMBER.get(v[4:7], None)\n    return (bic, FI_BANK_NAME_BY_BIC[bic]) if bic is not None else ('', '')", "response": "Returns BIC code and bank name from FI IBAN number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning Sweden bank info by clearing code.", "response": "def se_clearing_code_bank_info(clearing: str) -> (str, int):\n    \"\"\"\n    Returns Sweden bank info by clearning code.\n    :param clearing: 4-digit clearing code\n    :return: (Bank name, account digit count) or ('', None) if not found\n    \"\"\"\n    from jutil.bank_const_se import SE_BANK_CLEARING_LIST\n    for name, begin, end, acc_digits in SE_BANK_CLEARING_LIST:\n        if begin <= clearing <= end:\n            return name, acc_digits\n    return '', None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef http_date(value):\n    if isinstance(value, datetime.datetime):\n        value = value.utctimetuple()\n    elif isinstance(value, (int, float)):\n        value = time.gmtime(value)\n    if not isinstance(value, str):\n        value = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", value)\n    return value", "response": "Formats the value in required HTTP style\n\n        -> string HTTP - style formatted date\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_auth(header):\n    try:\n        method, data = header.split(None, 1)\n        if method.lower() == 'basic':\n            data = base64.b64decode(uniorbytes(data, bytes))\n            user, pwd = uniorbytes(data).split(':', 1)\n            return user, pwd\n    except (KeyError, AttributeError, ValueError):\n        return (None, None)", "response": "Parse RFC 2617 HTTP authentication header string and return user and pass tuple."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef image(request, data):\n\n    # Get image width, height, padding, and format from GET parameters, or\n    # fall-back to default values from settings.\n    try:\n        width = int(request.GET.get(\"w\", PYDENTICON_WIDTH))\n    except ValueError:\n        raise SuspiciousOperation(\"Identicon width must be a positive integer.\")\n    try:\n        height = int(request.GET.get(\"h\", PYDENTICON_HEIGHT))\n    except ValueError:\n        raise SuspiciousOperation(\"Identicon height must be a positive integer.\")\n    output_format = request.GET.get(\"f\", PYDENTICON_FORMAT)\n    try:\n        padding = [int(p) for p in request.GET[\"p\"].split(\",\")]\n    except KeyError:\n        padding = PYDENTICON_PADDING\n    except ValueError:\n        raise SuspiciousOperation(\"Identicon padding must consist out of 4 positive integers separated with commas.\")\n    if \"i\" in request.GET:\n        inverted = request.GET.get(\"i\")\n        if inverted.lower() == \"true\":\n            inverted = True\n        elif inverted.lower() == \"false\":\n            inverted = False\n        else:\n            raise SuspiciousOperation(\"Inversion parameter must be a boolean (true/false).\")\n    else:\n        inverted = PYDENTICON_INVERT\n\n    # Validate the input parameters.\n    if not isinstance(width, int) or width <= 0:\n        raise SuspiciousOperation(\"Identicon width must be a positive integer.\")\n    if not isinstance(height, int) or height <= 0:\n        raise SuspiciousOperation(\"Identicon height must be a positive integer.\")\n    if not all([isinstance(p, int) and p >= 0 for p in padding]) or len(padding) != 4:\n        raise SuspiciousOperation(\"Padding must be a 4-element tuple consisting out of positive integers.\")\n\n    # Set-up correct content type based on requested identicon format.\n    if output_format == \"png\":\n        content_type = \"image/png\"\n    elif output_format == \"ascii\":\n        content_type = \"text/plain\"\n    else:\n        raise SuspiciousOperation(\"Unsupported identicon format requested - '%s' % output_format\")\n\n    # Initialise a generator.\n    generator = Generator(PYDENTICON_ROWS, PYDENTICON_COLUMNS,\n                          foreground = PYDENTICON_FOREGROUND, background = PYDENTICON_BACKGROUND,\n                          digest = PYDENTICON_DIGEST)\n\n    # Generate the identicion.\n    content = generator.generate(data, width, height, padding=padding, output_format=output_format, inverted=inverted)\n\n    # Create and return the response.\n    response = HttpResponse(content, content_type=content_type)\n\n    return response", "response": "Generates an identicon image based on the data passed in."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive the currently developed hotfix a new name.", "response": "def rename(name):\n    # type: (str) -> None\n    \"\"\" Give the currently developed hotfix a new name. \"\"\"\n    from peltak.extra.gitflow import logic\n\n    if name is None:\n        name = click.prompt('Hotfix name')\n\n    logic.hotfix.rename(name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef typed_lru(maxsize, types=None):\n    types = types or collections.Hashable\n\n    def lru(obj):\n        @lru_cache(maxsize)\n        def _lru_cache(*args, **kwargs):\n            return obj(*args, **kwargs)\n\n        @wraps(obj)\n        def _convenience(*args, **kwargs):\n            broken = False\n            for arg in args:\n                if not isinstance(arg, types):\n                    broken = True\n                    break\n            for arg, val in kwargs.items():\n                if not isinstance(arg, types) and isinstance(val, types):\n                    broken = True\n                    break\n            if not broken:\n                try:\n                    return _lru_cache(*args, **kwargs)\n                except TypeError:\n                    return obj(*args, **kwargs)\n            return obj(*args, **kwargs)\n        return _convenience\n    return lru", "response": "A function to wrap a lru_cache function that can be used to cache the objects in a single thread."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, name, *default):\n        # type: (str, Any) -> Any\n        \"\"\" Get context value with the given name and optional default.\n\n        Args:\n            name (str):\n                The name of the context value.\n            *default (Any):\n                If given and the key doesn't not exist, this will be returned\n                instead. If it's not given and the context value does not exist,\n                `AttributeError` will be raised\n\n        Returns:\n            The requested context value.  If the value does not exist it will\n            return `default` if give or raise `AttributeError`.\n\n        Raises:\n            AttributeError: If the value does not exist and `default` was not\n                given.\n        \"\"\"\n\n        curr = self.values\n        for part in name.split('.'):\n            if part in curr:\n                curr = curr[part]\n            elif default:\n                return default[0]\n            else:\n                fmt = \"Context value '{}' does not exist:\\n{}\"\n                raise AttributeError(fmt.format(\n                    name, util.yaml_dump(self.values)\n                ))\n\n        return curr", "response": "Get the context value with the given name and optional default value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the value of the context value.", "response": "def set(self, name, value):\n        \"\"\" Set context value.\n\n        Args:\n            name (str):\n                The name of the context value to change.\n            value (Any):\n                The new value for the selected context value\n        \"\"\"\n        curr = self.values\n        parts = name.split('.')\n\n        for i, part in enumerate(parts[:-1]):\n            try:\n                curr = curr.setdefault(part, {})\n            except AttributeError:\n                raise InvalidPath('.'.join(parts[:i + 1]))\n\n        try:\n            curr[parts[-1]] = value\n        except TypeError:\n            raise InvalidPath('.'.join(parts[:-1]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef alias_exists(alias, keystore_path=None, keystore_password='changeit'):\n    log = logging.getLogger(mod_logger + '.alias_exists')\n    if not isinstance(alias, basestring):\n        msg = 'alias arg must be a string'\n        log.error(msg)\n        raise OSError(msg)\n\n    # Ensure JAVA_HOME is set\n    log.debug('Determining JAVA_HOME...')\n    try:\n        java_home = os.environ['JAVA_HOME']\n    except KeyError:\n        msg = 'JAVA_HOME is required but not set'\n        log.error(msg)\n        raise OSError(msg)\n\n    # Ensure keytool can be found\n    keytool = os.path.join(java_home, 'bin', 'keytool')\n    if not os.path.isfile(keytool):\n        msg = 'keytool file not found: {f}'.format(f=keytool)\n        log.error(msg)\n        raise OSError(msg)\n\n    # Find the cacerts file\n    if keystore_path is None:\n        keystore_path = os.path.join(java_home, 'lib', 'security', 'cacerts')\n\n        # If the JRE cacerts location is not found, look for the JDK cacerts\n        if not os.path .isfile(keystore_path):\n            keystore_path = os.path.join(java_home, 'jre', 'lib', 'security', 'cacerts')\n            if not os.path.isfile(keystore_path):\n                msg = 'Unable to file cacerts file'\n                log.error(msg)\n                raise OSError(msg)\n\n    log.info('Checking keystore {k} for alias: {a}...'.format(k=keystore_path, a=alias))\n\n    # Build the keytool command\n    command = [keytool, '-keystore', keystore_path, '-storepass', keystore_password, '-list']\n\n    # Running the keytool list command\n    log.debug('Running the keytool list command...')\n    try:\n        result = run_command(command)\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        msg = 'There was a problem running keytool on keystore: {k}\\n{e}'.format(k=keystore_path, e=str(ex))\n        log.error(msg)\n        raise OSError, msg, trace\n    if result['code'] != 0:\n        msg = 'keytool command exited with a non-zero code: {c}, and produced output: {o}'.format(\n            c=result['code'], o=result['output'])\n        log.error(msg)\n        raise OSError(msg)\n\n    # Check for the alias in the output\n    if alias in result['output']:\n        log.info('Found alias {a} in keystore: {k}'.format(a=alias, k=keystore_path))\n        return True\n    else:\n        log.info('Alias {a} was not found in keystore: {k}'.format(a=alias, k=keystore_path))\n        return False", "response": "Checks if an alias already exists in a keystore"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter(self, query: Query, entity: type) -> Tuple[Query, Any]:\n        raise NotImplementedError('You must implement this.')", "response": "Define the filter function that every node must to implement."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _extract_relations(self, attribute: str) -> Tuple[List[str], str]:\n        splitted = attribute.split(self._attr_sep)\n        return (splitted[:-1], splitted[-1])", "response": "Split and return the list of relation ( s ) and the attribute."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntransform the list of relation to list of class.", "response": "def _get_relation(self, related_model: type, relations: List[str]) -> Tuple[Optional[List[type]], Optional[type]]:\n        \"\"\"Transform the list of relation to list of class.\n\n        :param related_mode: The model of the query.\n        :type related_mode: type\n\n        :param relations: The relation list get from the `_extract_relations`.\n        :type relations: List[str]\n\n        :return: Tuple with the list of relations (class) and the second\n            element is the last relation class.\n        :rtype: Tuple[Optional[List[type]], Optional[type]]\n        \"\"\"\n        relations_list, last_relation = [], related_model\n        for relation in relations:\n            relationship = getattr(last_relation, relation, None)\n            if relationship is None:\n                return (None, None)\n            last_relation = relationship.mapper.class_\n            relations_list.append(last_relation)\n        return (relations_list, last_relation)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter(self, query: Query, entity: type) -> Tuple[Query, Any]:\n        new_query = query\n        c_filter_list = []\n        for child in self._childs:\n            new_query, f_list = child.filter(new_query, entity)\n            c_filter_list.append(f_list)\n        return (\n            new_query,\n            self._method(*c_filter_list)\n        )", "response": "Apply the _method to all childs of the node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_sms(phone: str, message: str, sender: str='', **kw):\n    if not hasattr(settings, 'SMS_TOKEN'):\n        raise Exception('Invalid configuration: settings.SMS_TOKEN missing')\n    if not sender:\n        sender = settings.SMS_SENDER_NAME\n    if not sender:\n        raise Exception('Invalid configuration: settings.SMS_SENDER_NAME missing')\n    headers = {\n        'Content-Type': 'application/json',\n        'Authorization': 'Token ' + settings.SMS_TOKEN,\n    }\n    data = {\n        'dst': phone_filter(phone),\n        'msg': message,\n        'src': sender,\n    }\n    for k, v in kw.items():\n        data[k] = v\n    return requests.post(\"https://sms.kajala.com/api/sms/\", json=data, headers=headers)", "response": "Sends SMS via Kajala Group SMS API. Contact info@kajala. com for access."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _meta_get_resource_sync(md_uuid):\n    isogeo.resource(id_resource=md_uuid)\n\n    elapsed = default_timer() - START_TIME\n    time_completed_at = \"{:5.2f}s\".format(elapsed)\n    print(\"{0:<30} {1:>20}\".format(md_uuid, time_completed_at))\n\n    return", "response": "Just a meta func to get execution time"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlog exception message and sends email to ADMINS if DEBUG = False.", "response": "def process_exception(self, request, e):\n        \"\"\"\n        Logs exception error message and sends email to ADMINS if hostname is not testserver and DEBUG=False.\n        :param request: HttpRequest\n        :param e: Exception\n        \"\"\"\n        from jutil.email import send_email\n\n        assert isinstance(request, HttpRequest)\n        full_path = request.get_full_path()\n        user = request.user\n        msg = '{full_path}\\n{err} (IP={ip}, user={user}) {trace}'.format(full_path=full_path, user=user, ip=get_real_ip(request), err=e, trace=str(traceback.format_exc()))\n        logger.error(msg)\n        hostname = request.get_host()\n        if not settings.DEBUG and hostname != 'testserver':\n            send_email(settings.ADMINS, 'Error @ {}'.format(hostname), msg)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_first_builder_window(builder):\n    for obj in builder.get_objects():\n        if isinstance(obj, Gtk.Window):\n            # first window\n            return obj", "response": "Get the first Gtk. Window in a Gtk. Builder hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a slave to the container", "response": "def add_slave(self, slave, container_name=\"widget\"):\n        \"\"\"Add a slave delegate\n        \"\"\"\n        cont = getattr(self, container_name, None)\n        if cont is None:\n            raise AttributeError(\n                'Container name must be a member of the delegate')\n        cont.add(slave.widget)\n        self.slaves.append(slave)\n        return slave"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the toplevel widget from a Gtk. Builder file.", "response": "def get_builder_toplevel(self, builder):\n        \"\"\"Get the toplevel widget from a Gtk.Builder file.\n\n        The slave view implementation first searches for the widget named as\n        self.toplevel_name (which defaults to \"main\". If this is missing, the\n        first toplevel widget is discovered in the Builder file, and it's\n        immediate child is used as the toplevel widget for the delegate.\n        \"\"\"\n        toplevel = builder.get_object(self.toplevel_name)\n        if toplevel is None:\n            toplevel = get_first_builder_window(builder).child\n        if toplevel is not None:\n            #XXX: what to do if a developer\n            #     gave the name of a window instead of its child\n            toplevel.get_parent().remove(toplevel)\n        return toplevel"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_and_run(self):\n        if not self._ui_ready:\n            self.prepare_ui()\n        self.display_widget = Gtk.Window()\n        self.display_widget.add(self.widget)\n        self.display_widget.show()\n        self.display_widget.connect('destroy', lambda *args: self.hide_and_quit())\n        BaseDelegate.show_and_run(self)", "response": "Show the main widget in a window and run the gtk loop"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the toplevel widget from a Gtk. Builder file.", "response": "def get_builder_toplevel(self, builder):\n        \"\"\"Get the toplevel widget from a Gtk.Builder file.\n\n        The main view implementation first searches for the widget named as\n        self.toplevel_name (which defaults to \"main\". If this is missing, or not\n        a Gtk.Window, the first toplevel window found in the Gtk.Builder is\n        used.\n        \"\"\"\n        toplevel = builder.get_object(self.toplevel_name)\n        if not GObject.type_is_a(toplevel, Gtk.Window):\n            toplevel = None\n        if toplevel is None:\n            toplevel = get_first_builder_window(builder)\n        return toplevel"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef round_sig(x, sig):\n    return round(x, sig - int(floor(log10(abs(x)))) - 1)", "response": "Round the number to the specified number of significant figures"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open_file(filename, as_text=False):\n    if filename.lower().endswith('.gz'):\n        if as_text:\n            return gzip.open(filename, 'rt')\n        else:\n            return gzip.open(filename, 'rb')\n    else:\n        if as_text:\n            return open(filename, 'rt')\n        else:\n            return open(filename, 'rb')", "response": "Open the file with gzipping it if it ends with. gz."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_simple_writer(outputDef, defaultOutput, outputFormat, fieldNames,\n                         compress=True, valueClassMappings=None,\n                         datasetMetaProps=None, fieldMetaProps=None):\n    \"\"\"Create a simple writer suitable for writing flat data\n    e.g. as BasicObject or TSV.\"\"\"\n\n    if not outputDef:\n        outputBase = defaultOutput\n    else:\n        outputBase = outputDef\n\n    if outputFormat == 'json':\n        write_squonk_datasetmetadata(outputBase, True, valueClassMappings,\n                                     datasetMetaProps, fieldMetaProps)\n        return BasicObjectWriter(open_output(outputDef, 'data', compress)), outputBase\n\n    elif outputFormat == 'tsv':\n        return TsvWriter(open_output(outputDef, 'tsv', compress), fieldNames), outputBase\n\n    else:\n        raise ValueError(\"Unsupported format: \" + outputFormat)", "response": "Create a simple writer suitable for writing flat data\n    e. g. as BasicObject or TSV."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_squonk_datasetmetadata(outputBase, thinOutput, valueClassMappings, datasetMetaProps, fieldMetaProps):\n    meta = {}\n    props = {}\n    # TODO add created property - how to handle date formats?\n    if datasetMetaProps:\n        props.update(datasetMetaProps)\n\n    if fieldMetaProps:\n        meta[\"fieldMetaProps\"] = fieldMetaProps\n\n    if len(props) > 0:\n        meta[\"properties\"] = props\n\n    if valueClassMappings:\n        meta[\"valueClassMappings\"] = valueClassMappings\n    if thinOutput:\n        meta['type'] = 'org.squonk.types.BasicObject'\n    else:\n        meta['type'] = 'org.squonk.types.MoleculeObject'\n    s = json.dumps(meta)\n    meta = open(outputBase + '.metadata', 'w')\n    meta.write(s)\n    meta.close()", "response": "This function writes the minimal metadata that Squonk needs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite the metrics to the file", "response": "def write_metrics(baseName, values):\n    \"\"\"Write the metrics data\n\n    :param baseName: The base name of the output files.\n                     e.g. extensions will be appended to this base name\n    :param values dictionary of values to write\n    \"\"\"\n    m = open(baseName  + '_metrics.txt', 'w')\n    for key in values:\n        m.write(key + '=' + str(values[key]) + \"\\n\")\n    m.flush()\n    m.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a dictionary that represents a Squonk MoleculeObject when written as JSON", "response": "def generate_molecule_object_dict(source, format, values):\n    \"\"\"Generate a dictionary that represents a Squonk MoleculeObject when\n    written as JSON\n\n    :param source: Molecules in molfile or smiles format\n    :param format: The format of the molecule. Either 'mol' or 'smiles'\n    :param values: Optional dict of values (properties) for the MoleculeObject\n    \"\"\"\n    m = {\"uuid\": str(uuid.uuid4()), \"source\": source, \"format\": format}\n    if values:\n        m[\"values\"] = values\n    return m"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_undecorated_calling_module():\n    frame = inspect.stack()[2]\n    module = inspect.getmodule(frame[0])\n    # Return the module's file and its path\n    # and omit the extension...\n    # so /a/c.py becomes /a/c\n    return module.__file__.rsplit('.', 1)[0]", "response": "Returns the module name of the caller s calling module."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nquery Nexus for an artifact and returns the response object.", "response": "def query_nexus(query_url, timeout_sec, basic_auth=None):\n    \"\"\"Queries Nexus for an artifact\n\n    :param query_url: (str) Query URL\n    :param timeout_sec: (int) query timeout\n    :param basic_auth (HTTPBasicAuth) object or none\n    :return: requests.Response object\n    :raises: RuntimeError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.query_nexus')\n\n    # Attempt to query Nexus\n    retry_sec = 5\n    max_retries = 6\n    try_num = 1\n    query_success = False\n    nexus_response = None\n    while try_num <= max_retries:\n        if query_success:\n            break\n        log.debug('Attempt # {n} of {m} to query the Nexus URL: {u}'.format(n=try_num, u=query_url, m=max_retries))\n        try:\n            nexus_response = requests.get(query_url, auth=basic_auth, stream=True, timeout=timeout_sec)\n        except requests.exceptions.Timeout:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: Nexus initial query timed out after {t} seconds:\\n{e}'.format(\n                n=ex.__class__.__name__, t=timeout_sec, r=retry_sec, e=str(ex))\n            log.warn(msg)\n            if try_num < max_retries:\n                log.info('Retrying query in {t} sec...'.format(t=retry_sec))\n                time.sleep(retry_sec)\n        except (requests.exceptions.RequestException, requests.exceptions.ConnectionError):\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: Nexus initial query failed with the following exception:\\n{e}'.format(\n                n=ex.__class__.__name__, r=retry_sec, e=str(ex))\n            log.warn(msg)\n            if try_num < max_retries:\n                log.info('Retrying query in {t} sec...'.format(t=retry_sec))\n                time.sleep(retry_sec)\n        else:\n            query_success = True\n        try_num += 1\n\n    if not query_success:\n        msg = 'Unable to query Nexus after {m} attempts using URL: {u}'.format(\n            u=query_url, m=max_retries)\n        log.error(msg)\n        raise RuntimeError(msg)\n\n    if nexus_response.status_code != 200:\n        msg = 'Nexus request returned code {c}, unable to query Nexus using URL: {u}'.format(\n            u=query_url, c=nexus_response.status_code)\n        log.error(msg)\n        raise RuntimeError(msg)\n    return nexus_response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving an artifact from Nexus server and returns it.", "response": "def get_artifact(suppress_status=False, nexus_url=sample_nexus_url, timeout_sec=600, overwrite=True,\n                 username=None, password=None, **kwargs):\n    \"\"\"Retrieves an artifact from Nexus\n\n    :param suppress_status: (bool) Set to True to suppress printing download status\n    :param nexus_url: (str) URL of the Nexus Server\n    :param timeout_sec: (int) Number of seconds to wait before\n        timing out the artifact retrieval.\n    :param overwrite: (bool) True overwrites the file on the local system if it exists,\n        False does will log an INFO message and exist if the file already exists\n    :param username: (str) username for basic auth\n    :param password: (str) password for basic auth\n    :param kwargs:\n        group_id: (str) The artifact's Group ID in Nexus\n        artifact_id: (str) The artifact's Artifact ID in Nexus\n        packaging: (str) The artifact's packaging (e.g. war, zip)\n        version: (str) Version of the artifact to retrieve (e.g.\n            LATEST, 4.8.4, 4.9.0-SNAPSHOT)\n        destination_dir: (str) Full path to the destination directory\n        classifier: (str) The artifact's classifier (e.g. bin)\n    :return: None\n    :raises: TypeError, ValueError, OSError, RuntimeError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.get_artifact')\n\n    required_args = ['group_id', 'artifact_id', 'packaging', 'version', 'destination_dir']\n\n    if not isinstance(overwrite, bool):\n        msg = 'overwrite arg must be a string, found: {t}'.format(t=overwrite.__class__.__name__)\n        log.error(msg)\n        raise TypeError(msg)\n\n    if not isinstance(nexus_url, basestring):\n        msg = 'nexus_url arg must be a string, found: {t}'.format(t=nexus_url.__class__.__name__)\n        log.error(msg)\n        raise TypeError(msg)\n\n    log.debug('Using Nexus Server URL: {u}'.format(u=nexus_url))\n\n    # Ensure the required args are supplied, and that they are all strings\n    for required_arg in required_args:\n        try:\n            assert required_arg in kwargs\n        except AssertionError:\n            _, ex, trace = sys.exc_info()\n            msg = 'A required arg was not supplied. Required args are: group_id, artifact_id, classifier, version, ' \\\n                  'packaging and destination_dir\\n{e}'.format(e=str(ex))\n            log.error(msg)\n            raise ValueError(msg)\n        if not isinstance(kwargs[required_arg], basestring):\n            msg = 'Arg {a} should be a string'.format(a=required_arg)\n            log.error(msg)\n            raise TypeError(msg)\n\n    # Set variables to be used in the REST call\n    group_id = kwargs['group_id']\n    artifact_id = kwargs['artifact_id']\n    version = kwargs['version']\n    packaging = kwargs['packaging']\n    destination_dir = kwargs['destination_dir']\n\n    # Ensure the destination directory exists\n    if not os.path.isdir(destination_dir):\n        log.debug('Specified destination_dir not found on file system, creating: {d}'.format(d=destination_dir))\n        try:\n            mkdir_p(destination_dir)\n        except CommandError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to create destination directory: {d}\\n{e}'.format(d=destination_dir, e=str(ex))\n            raise OSError(msg)\n\n    # Set the classifier if it was provided\n    classifier = None\n    if 'classifier' in kwargs:\n        if isinstance(kwargs['classifier'], basestring):\n            classifier = kwargs['classifier']\n            log.debug('Using classifier: {c}'.format(c=classifier))\n        else:\n            log.warn('Arg classifier provided but it was not an instance of basestring')\n\n    # Set the repo if it was provided\n    repo = None\n    if 'repo' in kwargs:\n        if isinstance(kwargs['repo'], basestring):\n            repo = kwargs['repo']\n            log.debug('Using repo: {r}'.format(r=repo))\n\n    # Determine the repo based on the version\n    if repo is None:\n        repo_test = version.lower().strip()\n        log.debug('Checking if the version {v} is a release or snapshot...'.format(v=repo_test))\n        # Determine the repo based on the version\n        if ('snapshot' in repo_test) or (repo_test == 'latest'):\n            repo = 'snapshots'\n        else:\n            repo = 'releases'\n        log.info('Based on the version {v}, determined repo: {r}'.format(v=version, r=repo))\n\n    # Construct the parameter string\n    params = 'g=' + group_id + '&a=' + artifact_id + '&v=' + version + '&r=' + repo + '&p=' + packaging\n\n    # Add the classifier if it was provided\n    if classifier is not None:\n        params = params + '&c=' + classifier\n\n    # Determine the auth based on username and password\n    basic_auth = None\n    if (username is not None) and (password is not None):\n        log.info('Using the provided username/password for basic authentication...')\n        basic_auth = HTTPBasicAuth(username, password)\n\n    # Build the query URL\n    query_url = nexus_url + '?' + params\n\n    # Set up for download attempts\n    retry_sec = 5\n    max_retries = 6\n    try_num = 1\n    download_success = False\n    dl_err = None\n    failed_attempt = False\n\n    # Start the retry loop\n    while try_num <= max_retries:\n\n        # Break the loop if the download was successful\n        if download_success:\n            break\n\n        log.info('Attempting to query Nexus for the Artifact using URL:  {u}'.format(u=query_url))\n        try:\n            nexus_response = query_nexus(query_url=query_url, timeout_sec=timeout_sec, basic_auth=basic_auth)\n        except RuntimeError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a problem querying Nexus URL: {u}\\n{e}'.format(\n                n=ex.__class__.__name__, u=query_url, e=str(ex))\n            log.error(msg)\n            raise RuntimeError, msg, trace\n\n        # Attempt to get the content-length\n        file_size = 0\n        try:\n            file_size = int(nexus_response.headers['Content-Length'])\n        except(KeyError, ValueError):\n            log.debug('Could not get Content-Length, suppressing download status...')\n            suppress_status = True\n        else:\n            log.info('Artifact file size: {s}'.format(s=file_size))\n\n        # Determine the full download file path\n        file_name = nexus_response.url.split('/')[-1]\n        download_file = os.path.join(destination_dir, file_name)\n\n        # Attempt to download the content from the response\n        log.info('Attempting to download content of size {s} from Nexus to file: {d}'.format(\n            s=file_size, d=download_file))\n\n        # Remove the existing file if it exists, or exit if the file exists, overwrite is set,\n        # and there was not a previous failed attempted download\n        if os.path.isfile(download_file) and overwrite:\n            log.debug('File already exists, removing: {d}'.format(d=download_file))\n            os.remove(download_file)\n        elif os.path.isfile(download_file) and not overwrite and not failed_attempt:\n            log.info('File already downloaded, and overwrite is set to False.  The Artifact will '\n                     'not be retrieved from Nexus: {f}.  To overwrite the existing downloaded file, '\n                     'set overwrite=True'.format(f=download_file))\n            return\n\n        # Attempt to download content\n        log.debug('Attempt # {n} of {m} to download content from the Nexus response'.format(n=try_num, m=max_retries))\n        chunk_size = 1024\n        file_size_dl = 0\n        try:\n            with open(download_file, 'wb') as f:\n                for chunk in nexus_response.iter_content(chunk_size=chunk_size):\n                    if chunk:\n                        f.write(chunk)\n                        file_size_dl += len(chunk)\n                        status = r\"%10d  [%3.2f%%]\" % (file_size_dl, file_size_dl * 100. / file_size)\n                        status += chr(8)*(len(status)+1)\n                        if not suppress_status:\n                            print(status),\n        except(requests.exceptions.ConnectionError, requests.exceptions.RequestException, OSError):\n            _, ex, trace = sys.exc_info()\n            dl_err = '{n}: There was an error reading content from the Nexus response. Downloaded ' \\\n                     'size: {s}.\\n{e}'.format(n=ex.__class__.__name__, s=file_size_dl, t=retry_sec, e=str(ex))\n            failed_attempt = True\n            log.warn(dl_err)\n            if try_num < max_retries:\n                log.info('Retrying download in {t} sec...'.format(t=retry_sec))\n                time.sleep(retry_sec)\n        else:\n            log.info('File download of size {s} completed without error: {f}'.format(s=file_size_dl, f=download_file))\n            failed_attempt = False\n            download_success = True\n        try_num += 1\n\n    # Raise an exception if the download did not complete successfully\n    if not download_success:\n        msg = 'Unable to download file content from Nexus after {n} attempts'.format(n=max_retries)\n        if dl_err:\n            msg += '\\n{m}'.format(m=dl_err)\n        log.error(msg)\n        raise RuntimeError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_artifact_nexus3(suppress_status=False, nexus_base_url=sample_nexus_base_url, repository=None,\n                        timeout_sec=600, overwrite=True, username=None, password=None, **kwargs):\n    \"\"\"Retrieves an artifact from the Nexus 3 ReST API\n\n    :param suppress_status: (bool) Set to True to suppress printing download status\n    :param nexus_base_url: (str) Base URL of the Nexus Server (domain name portion only, see sample)\n    :param repository: (str) Repository to query (e.g. snapshots) if not provided, will attempt to determine\n    :param timeout_sec: (int) Number of seconds to wait before\n        timing out the artifact retrieval.\n    :param overwrite: (bool) True overwrites the file on the local system if it exists,\n        False does will log an INFO message and exist if the file already exists\n    :param username: (str) username for basic auth\n    :param password: (str) password for basic auth\n    :param kwargs:\n        group_id: (str) The artifact's Group ID in Nexus\n        artifact_id: (str) The artifact's Artifact ID in Nexus\n        packaging: (str) The artifact's packaging (e.g. war, zip)\n        version: (str) Version of the artifact to retrieve (e.g.\n            LATEST, 4.8.4, 4.9.0-SNAPSHOT)\n        destination_dir: (str) Full path to the destination directory\n        classifier: (str) The artifact's classifier (e.g. bin)\n    :return: None\n    :raises: TypeError, ValueError, OSError, RuntimeError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.get_artifact_nexus3')\n\n    required_args = ['group_id', 'artifact_id', 'packaging', 'version', 'destination_dir']\n\n    if not isinstance(overwrite, bool):\n        msg = 'overwrite arg must be a string, found: {t}'.format(t=overwrite.__class__.__name__)\n        log.error(msg)\n        raise TypeError(msg)\n\n    if not isinstance(nexus_base_url, basestring):\n        msg = 'nexus_url arg must be a string, found: {t}'.format(t=nexus_base_url.__class__.__name__)\n        log.error(msg)\n        raise TypeError(msg)\n\n    log.debug('Using Nexus Server URL: {u}'.format(u=nexus_base_url))\n\n    # Ensure the required args are supplied, and that they are all strings\n    for required_arg in required_args:\n        try:\n            assert required_arg in kwargs\n        except AssertionError:\n            _, ex, trace = sys.exc_info()\n            msg = 'A required arg was not supplied. Required args are: group_id, artifact_id, classifier, version, ' \\\n                  'packaging and destination_dir\\n{e}'.format(e=str(ex))\n            log.error(msg)\n            raise ValueError(msg)\n        if not isinstance(kwargs[required_arg], basestring):\n            msg = 'Arg {a} should be a string'.format(a=required_arg)\n            log.error(msg)\n            raise TypeError(msg)\n\n    # Set variables to be used in the REST call\n    group_id = kwargs['group_id']\n    artifact_id = kwargs['artifact_id']\n    version = kwargs['version']\n    packaging = kwargs['packaging']\n    destination_dir = kwargs['destination_dir']\n\n    # Ensure the destination directory exists\n    if not os.path.isdir(destination_dir):\n        log.debug('Specified destination_dir not found on file system, creating: {d}'.format(d=destination_dir))\n        try:\n            mkdir_p(destination_dir)\n        except CommandError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to create destination directory: {d}\\n{e}'.format(d=destination_dir, e=str(ex))\n            raise OSError(msg)\n\n    # Determine the auth based on username and password\n    basic_auth = None\n    if (username is not None) and (password is not None):\n        log.info('Using the provided username/password for basic authentication...')\n        basic_auth = HTTPBasicAuth(username, password)\n\n    # Set the classifier if it was provided\n    classifier = None\n    if 'classifier' in kwargs:\n        if isinstance(kwargs['classifier'], basestring):\n            classifier = kwargs['classifier']\n            log.debug('Using classifier: {c}'.format(c=classifier))\n        else:\n            log.warn('Arg classifier provided but it was not an instance of basestring')\n\n    # Determine the repository (snapshots or releases)\n    if not repository:\n        if 'SNAPSHOT' in version:\n            repository = 'snapshots'\n        else:\n            repository = 'releases'\n    log.debug('Using repository: {r}'.format(r=repository))\n\n    # Compute the query URL\n    group_id_url = group_id.replace('.', '/')\n\n    # Get the Maven metadata\n    query_url_version = nexus_base_url + '/repository/{r}/{g}/{a}/{v}'.format(\n        r=repository, g=group_id_url, a=artifact_id, v=version\n    )\n\n    if 'snapshot' in repository.lower():\n        # Query nexus for metadata to determine the proper file name\n        query_url_metadata = query_url_version + '/maven-metadata.xml'\n\n        log.info('Attempting to query Nexus for the snapshot metadata using URL:  {u}'.format(u=query_url_metadata))\n        try:\n            nexus_response = query_nexus(query_url=query_url_metadata, timeout_sec=timeout_sec, basic_auth=basic_auth)\n        except RuntimeError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a problem querying Nexus URL: {u}\\n{e}'.format(\n                n=ex.__class__.__name__, u=query_url_metadata, e=str(ex))\n            log.error(msg)\n            raise RuntimeError, msg, trace\n\n        if nexus_response.status_code != 200:\n            raise RuntimeError('Bad response from Nexus metadata URL [{c}]: {u}'.format(\n                c=nexus_response.status_code, u=query_url_metadata))\n\n        # Parse the XML output\n        root = ET.fromstring(nexus_response.text)\n        log.info('Attempting to find the value of the file name...')\n        try:\n            value = root.find('versioning').find('snapshotVersions').find('snapshotVersion').find('value')\n        except AttributeError:\n            _, ex, trace = sys.exc_info()\n            msg = 'AttributeError: Unable to find versioning/snapshotVersions/snapshotVersion/value\\n{e}'.format(\n                e=str(ex))\n            raise ValueError, msg, trace\n\n        # Ensure a value was found\n        if value is None:\n            raise ValueError('Unable to determine the value of the snapshot version')\n\n        # Get the text version\n        text_version = value.text\n        log.info('Found version value: {t}'.format(t=text_version))\n\n        # Determine the artifact file name\n        artifact_file_name = '{a}-{t}'.format(\n            a=artifact_id,\n            t=text_version\n        )\n    else:\n        # Construct the file name for releases (e.g. cons3rt-backend-install-18.14.0-package-otto.zip)\n        artifact_file_name = '{a}-{v}'.format(\n            a=artifact_id,\n            v=version\n        )\n\n    # Add classifier if provided and packaging\n    if classifier:\n        artifact_file_name += '-{c}'.format(c=classifier)\n    artifact_file_name += '.{p}'.format(p=packaging)\n    log.info('Using artifact file name: {n}'.format(n=artifact_file_name))\n\n    # Determine the full query URL\n    query_url = query_url_version + '/{n}'.format(n=artifact_file_name)\n    log.info('Using Nexus query URL: {u}'.format(u=query_url))\n\n    # Set up for download attempts\n    retry_sec = 5\n    max_retries = 6\n    try_num = 1\n    download_success = False\n    dl_err = None\n    failed_attempt = False\n\n    # Start the retry loop\n    while try_num <= max_retries:\n\n        # Break the loop if the download was successful\n        if download_success:\n            break\n\n        log.info('Attempting to query Nexus for the Artifact using URL:  {u}'.format(u=query_url))\n        try:\n            nexus_response = query_nexus(query_url=query_url, timeout_sec=timeout_sec, basic_auth=basic_auth)\n        except RuntimeError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a problem querying Nexus URL: {u}\\n{e}'.format(\n                n=ex.__class__.__name__, u=query_url, e=str(ex))\n            log.error(msg)\n            raise RuntimeError, msg, trace\n\n        # Attempt to get the content-length\n        file_size = 0\n        try:\n            file_size = int(nexus_response.headers['Content-Length'])\n        except(KeyError, ValueError):\n            log.debug('Could not get Content-Length, suppressing download status...')\n            suppress_status = True\n        else:\n            log.info('Artifact file size: {s}'.format(s=file_size))\n\n        # Determine the full download file path\n        file_name = nexus_response.url.split('/')[-1]\n        download_file = os.path.join(destination_dir, file_name)\n\n        # Attempt to download the content from the response\n        log.info('Attempting to download content of size {s} from Nexus to file: {d}'.format(\n            s=file_size, d=download_file))\n\n        # Remove the existing file if it exists, or exit if the file exists, overwrite is set,\n        # and there was not a previous failed attempted download\n        if os.path.isfile(download_file) and overwrite:\n            log.debug('File already exists, removing: {d}'.format(d=download_file))\n            os.remove(download_file)\n        elif os.path.isfile(download_file) and not overwrite and not failed_attempt:\n            log.info('File already downloaded, and overwrite is set to False.  The Artifact will '\n                     'not be retrieved from Nexus: {f}.  To overwrite the existing downloaded file, '\n                     'set overwrite=True'.format(f=download_file))\n            return\n\n        # Attempt to download content\n        log.debug('Attempt # {n} of {m} to download content from the Nexus response'.format(n=try_num, m=max_retries))\n        chunk_size = 1024\n        file_size_dl = 0\n        try:\n            with open(download_file, 'wb') as f:\n                for chunk in nexus_response.iter_content(chunk_size=chunk_size):\n                    if chunk:\n                        f.write(chunk)\n                        file_size_dl += len(chunk)\n                        status = r\"%10d  [%3.2f%%]\" % (file_size_dl, file_size_dl * 100. / file_size)\n                        status += chr(8)*(len(status)+1)\n                        if not suppress_status:\n                            print(status),\n        except(requests.exceptions.ConnectionError, requests.exceptions.RequestException, OSError):\n            _, ex, trace = sys.exc_info()\n            dl_err = '{n}: There was an error reading content from the Nexus response. Downloaded ' \\\n                     'size: {s}.\\n{e}'.format(n=ex.__class__.__name__, s=file_size_dl, t=retry_sec, e=str(ex))\n            failed_attempt = True\n            log.warn(dl_err)\n            if try_num < max_retries:\n                log.info('Retrying download in {t} sec...'.format(t=retry_sec))\n                time.sleep(retry_sec)\n        else:\n            log.info('File download of size {s} completed without error: {f}'.format(s=file_size_dl, f=download_file))\n            failed_attempt = False\n            download_success = True\n        try_num += 1\n\n    # Raise an exception if the download did not complete successfully\n    if not download_success:\n        msg = 'Unable to download file content from Nexus after {n} attempts'.format(n=max_retries)\n        if dl_err:\n            msg += '\\n{m}'.format(m=dl_err)\n        log.error(msg)\n        raise RuntimeError(msg)", "response": "Retrieves an artifact from Nexus 3 ReST API."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef main():\n    log = logging.getLogger(mod_logger + '.main')\n    parser = argparse.ArgumentParser(description='This Python module retrieves artifacts from Nexus.')\n    parser.add_argument('-u', '--url', help='Nexus Server URL', required=False)\n    parser.add_argument('-g', '--groupId', help='Group ID', required=True)\n    parser.add_argument('-a', '--artifactId', help='Artifact ID', required=True)\n    parser.add_argument('-v', '--version', help='Artifact Version', required=True)\n    parser.add_argument('-c', '--classifier', help='Artifact Classifier', required=False)\n    parser.add_argument('-p', '--packaging', help='Artifact Packaging', required=True)\n    parser.add_argument('-r', '--repo', help='Nexus repository name', required=False)\n    parser.add_argument('-d', '--destinationDir', help='Directory to download to', required=True)\n    parser.add_argument('-n', '--username', help='Directory to download to', required=True)\n    parser.add_argument('-w', '--password', help='Directory to download to', required=True)\n    args = parser.parse_args()\n    try:\n        get_artifact(\n            nexus_url=args.url,\n            group_id=args.groupId,\n            artifact_id=args.artifactId,\n            version=args.version,\n            classifier=args.classifier,\n            packaging=args.packaging,\n            repo=args.repo,\n            destination_dir=args.destinationDir,\n            username=args.username,\n            password=args.password\n        )\n    except Exception as e:\n        msg = 'Caught exception {n}, unable for download artifact from Nexus\\n{s}'.format(\n            n=e.__class__.__name__, s=e)\n        log.error(msg)\n        return", "response": "This module handles calling this module as a script\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a formated string containing documentation about the audio Formula fields.", "response": "def get_doc(additional_doc=False,\n            field_prefix='$',\n            field_suffix=':',\n            indent=4):\n    \"\"\"Return a formated string containing documentation about the audio\n    fields.\n    \"\"\"\n    if additional_doc:\n        f = fields.copy()\n        f.update(additional_doc)\n    else:\n        f = fields\n    field_length = get_max_field_length(f)\n    field_length = field_length + len(field_prefix) + len(field_suffix) + 4\n    description_indent = ' ' * (indent + field_length)\n    output = ''\n    for field, description in sorted(f.items()):\n        description = description['description']\n        field = ' ' * indent + field_prefix + field + ':'\n        output += field.ljust(field_length) + \\\n            textwrap.fill(\n                description,\n                width=78,\n                initial_indent=description_indent,\n                subsequent_indent=description_indent\n            )[field_length:] + '\\n\\n\\n'\n\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlisting images stored in the registry.", "response": "def list_images(self):\n        # type: () -> List[str]\n        \"\"\" List images stored in the registry.\n\n        Returns:\n            list[str]: List of image names.\n        \"\"\"\n        r = self.get(self.registry_url + '/v2/_catalog', auth=self.auth)\n        return r.json()['repositories']"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_tags(self, image_name):\n        # type: (str) -> Iterator[str]\n        \"\"\" List all tags for the given image stored in the registry.\n\n        Args:\n            image_name (str):\n                The name of the image to query. The image must be present on the\n                registry for this call to return any values.\n        Returns:\n            list[str]: List of tags for that image.\n        \"\"\"\n        tags_url = self.registry_url + '/v2/{}/tags/list'\n\n        r = self.get(tags_url.format(image_name), auth=self.auth)\n        data = r.json()\n\n        if 'tags' in data:\n            return reversed(sorted(data['tags']))\n\n        return []", "response": "List all tags for the given image in the registry."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking the validity of the asset structure", "response": "def validate_asset_structure(asset_dir_path):\n    \"\"\"Checks asset structure validity\n\n    :param asset_dir_path: (str) path to the directory containing the asset\n    :return: (str) Asset name\n    :raises: Cons3rtAssetStructureError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.validate_asset_structure')\n\n    log.info('Validating asset directory: {d}'.format(d=asset_dir_path))\n\n    # Ensure there is an asset.properties file\n    asset_props = os.path.join(asset_dir_path, 'asset.properties')\n\n    if not os.path.isfile(asset_props):\n        raise Cons3rtAssetStructureError('Asset properties file not found: {f}'.format(f=asset_props))\n\n    # Props to find\n    install_script_rel_path = None\n    doc_file_rel_path = None\n    license_file_rel_path = None\n    asset_type = None\n    license_file_path = ''\n    doc_file_path = ''\n    asset_name = None\n\n    log.info('Reading asset properties file: {f}'.format(f=asset_props))\n    with open(asset_props, 'r') as f:\n        for line in f:\n            if line.strip().startswith('installScript='):\n                install_script_name = line.strip().split('=')[1]\n                install_script_rel_path = os.path.join('scripts', install_script_name)\n            elif line.strip().startswith('documentationFile='):\n                doc_file_rel_path = line.strip().split('=')[1]\n            elif line.strip().startswith('licenseFile='):\n                license_file_rel_path = line.strip().split('=')[1]\n            elif line.strip().startswith('assetType='):\n                asset_type = line.strip().split('=')[1]\n                asset_type = asset_type.lower()\n            elif line.strip().startswith('name='):\n                asset_name = line.strip().split('=')[1]\n\n    # Ensure a name was provided\n    if asset_name is None:\n        raise Cons3rtAssetStructureError('Required property [name] not found in asset properties file: {f}'.format(\n            f=asset_props))\n    if asset_name == '':\n        raise Cons3rtAssetStructureError('Required property [name] found blank in asset properties file: {f}'.format(\n            f=asset_props))\n\n    # Ensure asset_type was provided\n    if asset_type is None:\n        raise Cons3rtAssetStructureError('Required property [asset_type] not found in asset properties '\n                                         'file: {f}'.format(f=asset_props))\n    if asset_type == '':\n        raise Cons3rtAssetStructureError('Required property [asset_type] found blank in asset properties '\n                                         'file: {f}'.format(f=asset_props))\n\n    log.info('Found installScript={f}'.format(f=install_script_rel_path))\n    log.info('Found assetType={f}'.format(f=asset_type))\n\n    # Verify the doc file exists if specified\n    if doc_file_rel_path:\n        log.info('Found documentationFile={f}'.format(f=doc_file_rel_path))\n        doc_file_path = os.path.join(asset_dir_path, doc_file_rel_path)\n        if not os.path.isfile(doc_file_path):\n            raise Cons3rtAssetStructureError('Documentation file not found: {f}'.format(f=doc_file_path))\n        else:\n            log.info('Verified documentation file: {f}'.format(f=doc_file_path))\n    else:\n        log.info('The documentationFile property was not specified in asset.properties')\n\n    # Verify the license file exists if specified\n    if license_file_rel_path:\n        log.info('Found licenseFile={f}'.format(f=license_file_rel_path))\n        license_file_path = os.path.join(asset_dir_path, license_file_rel_path)\n        if not os.path.isfile(license_file_path):\n            raise Cons3rtAssetStructureError('License file not found: {f}'.format(f=license_file_path))\n        else:\n            log.info('Verified license file: {f}'.format(f=license_file_path))\n    else:\n        log.info('The licenseFile property was not specified in asset.properties')\n\n    if asset_type == 'software':\n        if not install_script_rel_path:\n            raise Cons3rtAssetStructureError('Software asset has an asset.properties missing the installScript '\n                                             'prop: {f}'.format(f=asset_props))\n        else:\n            install_script_path = os.path.join(asset_dir_path, install_script_rel_path)\n            if not os.path.isfile(install_script_path):\n                raise Cons3rtAssetStructureError('Install script file not found: {f}'.format(f=install_script_path))\n            else:\n                log.info('Verified install script for software asset: {f}'.format(f=install_script_path))\n\n    log.info('Checking items at the root of the asset directory...')\n    for item in os.listdir(asset_dir_path):\n        log.info('Checking item: {i}'.format(i=item))\n        item_path = os.path.join(asset_dir_path, item)\n        if item_path == license_file_path:\n            continue\n        elif item_path == doc_file_path:\n            continue\n        elif item_path == asset_props:\n            continue\n        elif item in ignore_items:\n            continue\n        elif ignore_by_extension(item_path=item_path):\n            continue\n        elif item in acceptable_dirs and os.path.isdir(item_path):\n            continue\n        else:\n            if item == 'VERSION':\n                os.remove(item_path)\n                log.warn('Deleted file: {f}'.format(f=item_path))\n            elif item == 'doc':\n                raise Cons3rtAssetStructureError('Found a doc directory at the asset root, this is not allowed')\n            elif item in potential_doc_files:\n                if not doc_file_rel_path:\n                    raise Cons3rtAssetStructureError('Documentation file found but not specified in '\n                                                     'asset.properties: {f}'.format(f=item_path))\n                else:\n                    raise Cons3rtAssetStructureError('Extra documentation file found: {f}'.format(f=item_path))\n            elif item in potential_license_files:\n                if not license_file_rel_path:\n                    raise Cons3rtAssetStructureError('License file found but not specified in '\n                                                     'asset.properties: {f}'.format(f=item_path))\n                else:\n                    raise Cons3rtAssetStructureError('Extra license file found: {f}'.format(f=item_path))\n            else:\n                raise Cons3rtAssetStructureError('Found illegal item at the asset root dir: {i}'.format(i=item))\n    log.info('Validated asset directory successfully: {d}'.format(d=asset_dir_path))\n    return asset_name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngive an asset directory path creates an asset zip file in the provided directory containing the asset.", "response": "def make_asset_zip(asset_dir_path, destination_directory=None):\n    \"\"\"Given an asset directory path, creates an asset zip file in the provided\n    destination directory\n\n    :param asset_dir_path: (str) path to the directory containing the asset\n    :param destination_directory: (str) path to the destination directory for\n            the asset\n    :return: (str) Path to the asset zip file\n    :raises: AssetZipCreationError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.make_asset_zip')\n    log.info('Attempting to create an asset zip from directory: {d}'.format(d=asset_dir_path))\n\n    # Ensure the path is a directory\n    if not os.path.isdir(asset_dir_path):\n        raise AssetZipCreationError('Provided asset_dir_path is not a directory: {d}'.format(d=asset_dir_path))\n\n    # Determine a destination directory if not provided\n    if destination_directory is None:\n        destination_directory = os.path.join(os.path.expanduser('~'), 'Downloads')\n        mkdir_p(destination_directory)\n\n    # Ensure the destination is a directory\n    if not os.path.isdir(destination_directory):\n        raise AssetZipCreationError('Provided destination_directory is not a directory: {d}'.format(\n            d=destination_directory))\n\n    # Validate the asset structure\n    try:\n        asset_name = validate_asset_structure(asset_dir_path=asset_dir_path)\n    except Cons3rtAssetStructureError:\n        _, ex, trace = sys.exc_info()\n        msg = 'Cons3rtAssetStructureError: Problem found in the asset structure: {d}\\n{e}'.format(\n            d=asset_dir_path, e=str(ex))\n        raise AssetZipCreationError, msg, trace\n\n    # Determine the asset zip file name (same as asset name without spaces)\n    zip_file_name = 'asset-' + asset_name.replace(' ', '') + '.zip'\n    log.info('Using asset zip file name: {n}'.format(n=zip_file_name))\n\n    # Determine the zip file path\n    zip_file_path = os.path.join(destination_directory, zip_file_name)\n\n    # Remove existing zip file if it exists\n    if os.path.isfile(zip_file_path):\n        log.info('Removing existing asset zip file: {f}'.format(f=zip_file_path))\n        os.remove(zip_file_path)\n\n    # Attempt to create the zip\n    log.info('Attempting to create asset zip file: {f}'.format(f=zip_file_path))\n    try:\n        with contextlib.closing(zipfile.ZipFile(zip_file_path, 'w', allowZip64=True)) as zip_w:\n            for root, dirs, files in os.walk(asset_dir_path):\n                for f in files:\n                    skip = False\n                    file_path = os.path.join(root, f)\n\n                    # Skip files in the ignore directories list\n                    for ignore_dir in ignore_dirs:\n                        if ignore_dir in file_path:\n                            skip = True\n                            break\n\n                    # Skip file in the ignore files list\n                    for ignore_file in ignore_files:\n                        if f.startswith(ignore_file):\n                            skip = True\n                            break\n\n                    # Skip if the file ends with the specified extension\n                    if ignore_by_extension(item_path=file_path):\n                        skip = True\n\n                    if skip:\n                        log.info('Skipping file: {f}'.format(f=file_path))\n                        continue\n\n                    log.info('Adding file to zip: {f}'.format(f=file_path))\n                    archive_name = os.path.join(root[len(asset_dir_path):], f)\n                    if archive_name.startswith('/'):\n                        log.debug('Trimming the leading char: [/]')\n                        archive_name = archive_name[1:]\n                    log.info('Adding to archive as: {a}'.format(a=archive_name))\n                    zip_w.write(file_path, archive_name)\n    except Exception:\n        _, ex, trace = sys.exc_info()\n        msg = 'Unable to create zip file: {f}\\n{e}'.format(f=zip_file_path, e=str(ex))\n        raise AssetZipCreationError, msg, trace\n    log.info('Successfully created asset zip file: {f}'.format(f=zip_file_path))\n    return zip_file_path"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncommands line call to validate an asset structure", "response": "def validate(asset_dir):\n    \"\"\"Command line call to validate an asset structure\n\n    :param asset_dir: (full path to the asset dir)\n    :return: (int)\n    \"\"\"\n    try:\n        asset_name = validate_asset_structure(asset_dir_path=asset_dir)\n    except Cons3rtAssetStructureError:\n        _, ex, trace = sys.exc_info()\n        msg = 'Cons3rtAssetStructureError: Problem with asset validation\\n{e}'.format(e=str(ex))\n        print('ERROR: {m}'.format(m=msg))\n        return 1\n    print('Validated asset with name: {n}'.format(n=asset_name))\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(asset_dir, dest_dir):\n    val = validate(asset_dir=asset_dir)\n    if val != 0:\n        return 1\n    try:\n        asset_zip = make_asset_zip(asset_dir_path=asset_dir, destination_directory=dest_dir)\n    except AssetZipCreationError:\n        _, ex, trace = sys.exc_info()\n        msg = 'AssetZipCreationError: Problem with asset zip creation\\n{e}'.format(e=str(ex))\n        print('ERROR: {m}'.format(m=msg))\n        return 1\n    print('Created asset zip file: {z}'.format(z=asset_zip))\n    return 0", "response": "Command line call to create an asset zip file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn model instance or None if not found.", "response": "def get_object_or_none(cls, **kwargs):\n    \"\"\"\n    Returns model instance or None if not found.\n    :param cls: Class or queryset\n    :param kwargs: Filters for get() call\n    :return: Object or None\n    \"\"\"\n    from django.shortcuts import _get_queryset\n    qs = _get_queryset(cls)\n    try:\n        return qs.get(**kwargs)\n    except qs.model.DoesNotExist:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_model_field_label_and_value(instance, field_name) -> (str, str):\n    label = field_name\n    value = str(getattr(instance, field_name))\n    for f in instance._meta.fields:\n        if f.attname == field_name:\n            label = f.verbose_name\n            if hasattr(f, 'choices') and len(f.choices) > 0:\n                value = choices_label(f.choices, value)\n            break\n    return label, force_text(value)", "response": "Returns model field label and value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clone_model(instance, cls, commit: bool=True, exclude_fields: tuple=('id',), base_class_suffix: str='_ptr', **kw):\n    keys = [f.name for f in cls._meta.fields if f.name not in exclude_fields and not f.name.endswith(base_class_suffix)]\n    new_instance = cls()\n    for k in keys:\n        v = getattr(instance, k)\n        setattr(new_instance, k, v)\n    for k, v in kw.items():\n        setattr(new_instance, k, v)\n    if commit:\n        new_instance.save()\n    return new_instance", "response": "Clones the model instance to new object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_queryset(self):\n        query_params = list(self.request.query_params.keys())\n\n        # variable that stores criteria to filter identities by\n        filter_criteria = {}\n        # variable that stores a list of addresses that should be active\n        # if the special filter is passed in\n        exclude_if_address_inactive = []\n\n        # Determine from param \"include_inactive\" whether inactive identities\n        # should be included in the search results\n        if \"include_inactive\" in query_params:\n            if self.request.query_params[\"include_inactive\"] in [\n                \"False\",\n                \"false\",\n                False,\n            ]:\n                include_inactive = False\n            else:\n                include_inactive = True\n        else:\n            include_inactive = True  # default to True\n\n        # Compile a list of criteria to filter the identities by, based on the\n        # query parameters\n        for filter in query_params:\n            if filter in [\"include_inactive\", \"cursor\"]:\n                # Don't add the cursor to the filter_criteria\n                pass\n            elif filter.startswith(\"details__addresses__\"):\n                # Edit the query_param to evaluate the key instead of the value\n                # and add it to the filter_criteria\n                filter_criteria[filter + \"__has_key\"] = self.request.query_params[\n                    filter\n                ]\n\n                # Add the address to the list of addresses that should not\n                # be inactive (tuple e.g (\"msisdn\", \"+27123\"))\n                if include_inactive is False:\n                    exclude_if_address_inactive.append(\n                        (\n                            filter.replace(\"details__addresses__\", \"\"),\n                            self.request.query_params[filter],\n                        )\n                    )\n            else:\n                # Add the normal params to the filter criteria\n                filter_criteria[filter] = self.request.query_params[filter]\n\n        identities = Identity.objects.filter(**filter_criteria)\n\n        if include_inactive is False:\n            # Check through all the identities and exclude ones where the\n            # addresses are inactive\n            for identity in identities:\n                for param in exclude_if_address_inactive:\n                    q_key = identity.details[\"addresses\"][param[0]][param[1]]\n                    if \"inactive\" in q_key and q_key[\"inactive\"] in [\n                        True,\n                        \"True\",\n                        \"true\",\n                    ]:  # noqa\n                        identities = identities.exclude(id=identity.id)\n\n        return identities", "response": "This method returns a list of all the identities that are in the database for the specified query parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntest if an internet connection is operational.", "response": "def check_internet_connection(self, remote_server: str = \"api.isogeo.com\") -> bool:\n        \"\"\"Test if an internet connection is operational.\n        Src: http://stackoverflow.com/a/20913928/2556577.\n\n        :param str remote_server: remote server used to check\n        \"\"\"\n        try:\n            # see if we can resolve the host name -- tells us if there is\n            # a DNS listening\n            host = socket.gethostbyname(remote_server)\n            # connect to the host -- tells us if it's reachable\n            sock = socket.create_connection((host, 80), 2)\n            sock.close()\n            return True\n        except Exception as e:\n            logging.error(e)\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_bearer_validity(self, token: dict, connect_mtd) -> dict:\n        warnings.warn(\n            \"Method is now executed as a decorator within the main SDK class. Will be removed in future versions.\",\n            DeprecationWarning,\n        )\n        if datetime.now() < token.get(\"expires_at\"):\n            token = connect_mtd\n            logging.debug(\"Token was about to expire, so has been renewed.\")\n        else:\n            logging.debug(\"Token is still valid.\")\n            pass\n\n        # end of method\n        return token", "response": "Check the validity of the given token."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_api_response(self, response):\n        # check response\n        if response.status_code == 200:\n            return True\n        elif response.status_code >= 400:\n            logging.error(\n                \"{}: {} - {} - URL: {}\".format(\n                    response.status_code,\n                    response.reason,\n                    response.json().get(\"error\"),\n                    response.request.url,\n                )\n            )\n            return False, response.status_code", "response": "Check API response and raise exceptions if needed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_request_parameters(self, parameters: dict = dict):\n        # -- SEMANTIC QUERY ---------------------------------------------------\n        li_args = parameters.get(\"q\").split()\n        logging.debug(li_args)\n\n        # Unicity\n        li_filters = [i.split(\":\")[0] for i in li_args]\n        filters_count = Counter(li_filters)\n        li_filters_must_be_unique = (\"coordinate-system\", \"format\", \"owner\", \"type\")\n        for i in filters_count:\n            if i in li_filters_must_be_unique and filters_count.get(i) > 1:\n                raise ValueError(\n                    \"This query filter must be unique: {}\"\n                    \" and it occured {} times.\".format(i, filters_count.get(i))\n                )\n\n        # dict\n        dico_query = FILTER_KEYS.copy()\n        for i in li_args:\n            if i.startswith(\"action\"):\n                dico_query[\"action\"].append(i.split(\":\")[1:][0])\n                continue\n            elif i.startswith(\"catalog\"):\n                dico_query[\"catalog\"].append(i.split(\":\")[1:][0])\n                continue\n            elif i.startswith(\"contact\") and i.split(\":\")[1] == \"group\":\n                dico_query[\"contact:group\"].append(i.split(\":\")[1:][1])\n                continue\n            elif i.startswith(\"contact\"):\n                dico_query[\"contact:isogeo\"].append(i.split(\":\", 1)[1])\n                continue\n            elif i.startswith(\"coordinate-system\"):\n                dico_query[\"coordinate-system\"].append(i.split(\":\")[1:][0])\n                continue\n            elif i.startswith(\"data-source\"):\n                dico_query[\"data-source\"].append(i.split(\":\")[1:][0])\n                continue\n            elif i.startswith(\"format\"):\n                dico_query[\"format\"].append(i.split(\":\")[1:][0])\n                continue\n            elif i.startswith(\"has-no\"):\n                dico_query[\"has-no\"].append(i.split(\":\")[1:][0])\n                continue\n            elif i.startswith(\"keyword:isogeo\"):\n                dico_query[\"keyword:isogeo\"].append(i.split(\":\")[1:][1])\n                continue\n            elif i.startswith(\"keyword:inspire-theme\"):\n                dico_query[\"keyword:inspire-theme\"].append(i.split(\":\")[1:][1])\n                continue\n            elif i.startswith(\"license:isogeo\"):\n                dico_query[\"license:isogeo\"].append(i.split(\":\")[1:][1:])\n                continue\n            elif i.startswith(\"license\"):\n                dico_query[\"license:group\"].append(i.split(\":\", 1)[1:][0:])\n                continue\n            elif i.startswith(\"owner\"):\n                dico_query[\"owner\"].append(i.split(\":\")[1:][0])\n                continue\n            elif i.startswith(\"provider\"):\n                dico_query[\"provider\"].append(i.split(\":\")[1:][0])\n                continue\n            elif i.startswith(\"share\"):\n                dico_query[\"share\"].append(i.split(\":\")[1:][0])\n                continue\n            elif i.startswith(\"type\"):\n                dico_query[\"type\"].append(i.split(\":\")[1:][0])\n                continue\n            else:\n                # logging.debug(i.split(\":\")[1], i.split(\":\")[1].isdigit())\n                dico_query[\"text\"].append(i)\n                continue\n\n        # Values\n        dico_filters = {i.split(\":\")[0]: i.split(\":\")[1:] for i in li_args}\n        if dico_filters.get(\"type\", (\"dataset\",))[0].lower() not in FILTER_TYPES:\n            raise ValueError(\n                \"type value must be one of: {}\".format(\" | \".join(FILTER_TYPES))\n            )\n        elif dico_filters.get(\"action\", (\"download\",))[0].lower() not in FILTER_ACTIONS:\n            raise ValueError(\n                \"action value must be one of: {}\".format(\" | \".join(FILTER_ACTIONS))\n            )\n        elif (\n            dico_filters.get(\"provider\", (\"manual\",))[0].lower() not in FILTER_PROVIDERS\n        ):\n            raise ValueError(\n                \"provider value must be one of: {}\".format(\" | \".join(FILTER_PROVIDERS))\n            )\n        else:\n            logging.debug(dico_filters)\n\n        # -- GEOGRAPHIC -------------------------------------------------------\n        in_box = parameters.get(\"box\")\n        in_geo = parameters.get(\"geo\")\n        # geometric relation\n        in_rel = parameters.get(\"rel\")\n        if in_rel and in_box is None and in_geo is None:\n            raise ValueError(\"'rel' should'nt be used without box or geo.\")\n        elif in_rel not in GEORELATIONS and in_rel is not None:\n            raise ValueError(\n                \"{} is not a correct value for 'georel'.\"\n                \" Must be one of: {}.\".format(in_rel, \" | \".join(GEORELATIONS))\n            )", "response": "Check the parameters passed to avoid errors and help debug."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_is_uuid(self, uuid_str: str):\n        # check uuid type\n        if not isinstance(uuid_str, str):\n            raise TypeError(\"'uuid_str' expected a str value.\")\n        else:\n            pass\n        # handle Isogeo specific UUID in XML exports\n        if \"isogeo:metadata\" in uuid_str:\n            uuid_str = \"urn:uuid:{}\".format(uuid_str.split(\":\")[-1])\n        else:\n            pass\n        # test it\n        try:\n            uid = UUID(uuid_str)\n            return uid.hex == uuid_str.replace(\"-\", \"\").replace(\"urn:uuid:\", \"\")\n        except ValueError as e:\n            logging.error(\n                \"uuid ValueError. {} ({})  -- {}\".format(type(uuid_str), uuid_str, e)\n            )\n            return False", "response": "Check if the given string is an Isogeo UUID handling specific form."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_edit_tab(self, tab: str, md_type: str):\n        # check parameters types\n        if not isinstance(tab, str):\n            raise TypeError(\"'tab' expected a str value.\")\n        else:\n            pass\n        if not isinstance(md_type, str):\n            raise TypeError(\"'md_type' expected a str value.\")\n        else:\n            pass\n        # check parameters values\n        if tab not in EDIT_TABS:\n            raise ValueError(\n                \"'{}' isn't a valid edition tab. \"\n                \"Available values: {}\".format(tab, \" | \".join(EDIT_TABS))\n            )\n        else:\n            pass\n        if md_type not in FILTER_TYPES:\n            if md_type in FILTER_TYPES.values():\n                md_type = self._convert_md_type(md_type)\n            else:\n                raise ValueError(\n                    \"'{}' isn't a valid metadata type. \"\n                    \"Available values: {}\".format(md_type, \" | \".join(FILTER_TYPES))\n                )\n        else:\n            pass\n        # check adequation tab/md_type\n        if md_type not in EDIT_TABS.get(tab):\n            raise ValueError(\n                \"'{}'  isn't a valid tab for a '{}'' metadata.\"\n                \" Only for these types: {}.\".format(tab, md_type, EDIT_TABS.get(tab))\n            )\n        else:\n            return True", "response": "Check if asked tab is part of Isogeo web form and reliable\n            with metadata type."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if specific metadata UUID is correct.", "response": "def _check_filter_specific_md(self, specific_md: list):\n        \"\"\"Check if specific_md parameter is valid.\n\n        :param list specific_md: list of specific metadata UUID to check\n        \"\"\"\n        if isinstance(specific_md, list):\n            if len(specific_md) > 0:\n                # checking UUIDs and poping bad ones\n                for md in specific_md:\n                    if not self.check_is_uuid(md):\n                        specific_md.remove(md)\n                        logging.error(\"Metadata UUID is not correct: {}\".format(md))\n                # joining survivors\n                specific_md = \",\".join(specific_md)\n            else:\n                specific_md = \"\"\n        else:\n            raise TypeError(\"'specific_md' expects a list\")\n        return specific_md"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if specific_tag parameter is valid.", "response": "def _check_filter_specific_tag(self, specific_tag: list):\n        \"\"\"Check if specific_tag parameter is valid.\n\n        :param list specific_tag: list of specific tag to check\n        \"\"\"\n        if isinstance(specific_tag, list):\n            if len(specific_tag) > 0:\n                specific_tag = \",\".join(specific_tag)\n            else:\n                specific_tag = \"\"\n        else:\n            raise TypeError(\"'specific_tag' expects a list\")\n        return specific_tag"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _check_filter_includes(self, includes: list, resource: str = \"metadata\"):\n        # check resource parameter\n        if resource == \"metadata\":\n            ref_subresources = _SUBRESOURCES_MD\n        elif resource == \"keyword\":\n            ref_subresources = _SUBRESOURCES_KW\n        else:\n            raise ValueError(\"Must be one of: metadata | keyword.\")\n\n        # sub resources manager\n        if isinstance(includes, str) and includes.lower() == \"all\":\n            includes = \",\".join(ref_subresources)\n        elif isinstance(includes, list):\n            if len(includes) > 0:\n                includes = \",\".join(includes)\n            else:\n                includes = \"\"\n        else:\n            raise TypeError(\"'includes' expect a list or a str='all'\")\n        return includes", "response": "Check if specific_resources parameter is valid."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if specific_resources parameter is valid.", "response": "def _check_subresource(self, subresource: str):\n        \"\"\"Check if specific_resources parameter is valid.\n\n        :param str resource: subresource to check.\n        \"\"\"\n        warnings.warn(\n            \"subresource in URL is deprecated.\" \" Use _include mecanism instead.\",\n            DeprecationWarning,\n        )\n        l_subresources = (\n            \"conditions\",\n            \"contacts\",\n            \"coordinate-system\",\n            \"events\",\n            \"feature-attributes\",\n            \"keywords\",\n            \"layers\",\n            \"limitations\",\n            \"links\",\n            \"operations\",\n            \"specifications\",\n        )\n        if isinstance(subresource, str):\n            if subresource in l_subresources:\n                subresource = subresource\n            elif subresource == \"tags\":\n                subresource = \"keywords\"\n                logging.debug(\n                    \"'tags' is an include not a subresource.\"\n                    \" Don't worry, it has be automatically renamed \"\n                    \"into 'keywords' which is the correct subresource.\"\n                )\n            elif subresource == \"serviceLayers\":\n                subresource = \"layers\"\n                logging.debug(\n                    \"'serviceLayers' is an include not a subresource.\"\n                    \" Don't worry, it has be automatically renamed \"\n                    \"into 'layers' which is the correct subresource.\"\n                )\n            else:\n                raise ValueError(\n                    \"Invalid subresource. Must be one of: {}\".format(\n                        \"|\".join(l_subresources)\n                    )\n                )\n        else:\n            raise TypeError(\"'subresource' expects a str\")\n        return subresource"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert metadata types to Isogeo API format", "response": "def _convert_md_type(self, type_to_convert: str):\n        \"\"\"Metadata types are not consistent in Isogeo API. A vector dataset is\n         defined as vector-dataset in query filter but as vectorDataset in\n         resource (metadata) details.\n\n        see: https://github.com/isogeo/isogeo-api-py-minsdk/issues/29\n        \"\"\"\n        if type_to_convert in FILTER_TYPES:\n            return FILTER_TYPES.get(type_to_convert)\n        elif type_to_convert in FILTER_TYPES.values():\n            return [k for k, v in FILTER_TYPES.items() if v == type_to_convert][0]\n        else:\n            raise ValueError(\n                \"Incorrect metadata type to convert: {}\".format(type_to_convert)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshows project version. Has sub commands. For this command to work you must specify where the project version is stored. You can do that with version_file conf variable. peltak supports multiple ways to store the project version. Right now you can store it in a python file using built-in __version__ variable. You can use node.js package.json and keep the version there or you can just use a plain text file that just holds the raw project version. The appropriate storage is guessed based on the file type and name. Example Configuration:: version_file: 'src/mypackage/__init__.py' Examples: \\b $ peltak version # Pretty print current version $ peltak version --porcelain # Print version as raw string $ peltak version bump patch # Bump patch version component $ peltak version bump minor # Bump minor version component $ peltak version bump major # Bump major version component $ peltak version bump release # same as version bump patch $ peltak version bump --exact=1.2.1 # Set project version to 1.2.1", "response": "def version_cli(ctx, porcelain):\n    # type: (click.Context, bool) -> None\n    \"\"\" Show project version. Has sub commands.\n\n    For this command to work you must specify where the project version is\n    stored. You can do that with version_file conf variable. peltak supports\n    multiple ways to store the project version. Right now you can store it in a\n    python file using built-in __version__ variable. You can use node.js\n    package.json and keep the version there or you can just use a plain text\n    file that just holds the raw project version. The appropriate storage is\n    guessed based on the file type and name.\n\n    Example Configuration::\n\n        version_file: 'src/mypackage/__init__.py'\n\n    Examples:\n\n        \\b\n        $ peltak version                        # Pretty print current version\n        $ peltak version --porcelain            # Print version as raw string\n        $ peltak version bump patch             # Bump patch version component\n        $ peltak version bump minor             # Bump minor version component\n        $ peltak version bump major             # Bump major version component\n        $ peltak version bump release           # same as version bump patch\n        $ peltak version bump --exact=1.2.1     # Set project version to 1.2.1\n\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    from peltak.core import log\n    from peltak.core import versioning\n\n    current = versioning.current()\n\n    if porcelain:\n        print(current)\n    else:\n        log.info(\"Version: <35>{}\".format(current))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbump current project version without committing anything.", "response": "def bump_version(component='patch', exact=None):\n    # type: (str, str) -> None\n    \"\"\" Bump current project version without committing anything.\n\n    No tags are created either.\n\n    Examples:\n\n        \\b\n        $ peltak version bump patch             # Bump patch version component\n        $ peltak version bump minor             # Bump minor version component\n        $ peltak version bump major             # Bump major version component\n        $ peltak version bump release           # same as version bump patch\n        $ peltak version bump --exact=1.2.1     # Set project version to 1.2.1\n\n    \"\"\"\n    from peltak.core import log\n    from peltak.core import versioning\n\n    old_ver, new_ver = versioning.bump(component, exact)\n\n    log.info(\"Project version bumped\")\n    log.info(\"  old version: <35>{}\".format(old_ver))\n    log.info(\"  new version: <35>{}\".format(new_ver))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_logfile_name(tag):\n        if not os.path.exists(p.LOG_DIR):\n            os.mkdir(p.LOG_DIR)\n        filename = \"log_\" + p.HOST + \"_\" + tag + \".txt\"\n        filename = os.path.join(p.LOG_DIR, filename)\n        return filename", "response": "Returns a name for a log file that is meant to be used in a call to the\nEffectiveLogFile method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch a record by the record s ID or upstream_identifier.", "response": "def _get(self, rec_id=None, upstream=None):\n        \"\"\"\n        Fetches a record by the record's ID or upstream_identifier.\n\n        Raises:\n            `pulsarpy.models.RecordNotFound`: A record could not be found.\n        \"\"\"\n        if rec_id:\n            self.record_url = self.__class__.get_record_url(rec_id)\n            self.debug_logger.debug(\"GET {} record with ID {}: {}\".format(self.__class__.__name__, rec_id, self.record_url))\n            response = requests.get(url=self.record_url, headers=HEADERS, verify=False)\n            if not response.ok and response.status_code == requests.codes.NOT_FOUND:\n                raise RecordNotFound(\"Search for {} record with ID '{}' returned no results.\".format(self.__class__.__name__, rec_id))\n            self.write_response_html_to_file(response,\"get_bob.html\")\n            response.raise_for_status()\n            return response.json()\n        elif upstream:\n            rec_json = self.__class__.find_by({\"upstream_identifier\": upstream}, require=True)\n            self.record_url = self.__class__.get_record_url(rec_json[\"id\"])\n        return rec_json"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreplacing a foreign key reference using a name with an ID.", "response": "def replace_name_with_id(cls, name):\n        \"\"\"\n        Used to replace a foreign key reference using a name with an ID. Works by searching the\n        record in Pulsar and expects to find exactly one hit. First, will check if the foreign key\n        reference is an integer value and if so, returns that as it is presumed to be the foreign key.\n\n        Raises:\n            `pulsarpy.elasticsearch_utils.MultipleHitsException`: Multiple hits were returned from the name search.\n            `pulsarpy.models.RecordNotFound`: No results were produced from the name search.\n        \"\"\"\n        try:\n            int(name)\n            return name #Already a presumed ID.\n        except ValueError:\n            pass\n        #Not an int, so maybe a combination of MODEL_ABBR and Primary Key, i.e. B-8.\n        if name.split(\"-\")[0] in Meta._MODEL_ABBREVS:\n            return int(name.split(\"-\", 1)[1])\n        try:\n            result = cls.ES.get_record_by_name(cls.ES_INDEX_NAME, name)\n            if result:\n                return result[\"id\"]\n        except pulsarpy.elasticsearch_utils.MultipleHitsException as e:\n            raise\n        raise RecordNotFound(\"Name '{}' for model '{}' not found.\".format(name, cls.__name__))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_model_name_to_payload(cls, payload):\n        if not cls.MODEL_NAME in payload:\n            payload = {cls.MODEL_NAME: payload}\n        return payload", "response": "Adds the model name to the payload."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_by(cls, payload, require=False):\n        if not isinstance(payload, dict):\n            raise ValueError(\"The 'payload' parameter must be provided a dictionary object.\")\n        url = os.path.join(cls.URL, \"find_by\")\n        payload = {\"find_by\": payload}\n        cls.debug_logger.debug(\"Searching Pulsar {} for {}\".format(cls.__name__, json.dumps(payload, indent=4)))\n        res = requests.post(url=url, json=payload, headers=HEADERS, verify=False)\n        #cls.write_response_html_to_file(res,\"bob.html\")\n        res.raise_for_status()\n        res_json = res.json()\n        if res_json:\n           try:\n               res_json = res_json[cls.MODEL_NAME]\n           except KeyError:\n               # Key won't be present if there isn't a serializer for it on the server.\n               pass\n        else:\n            if require:\n                raise RecordNotFound(\"Can't find any {} records with search criteria: '{}'.\".format(cls.__name__, payload))\n        return res_json", "response": "Searches the model in question by AND joining the query parameters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsearching the model in question by OR joining the query parameters.", "response": "def find_by_or(cls, payload):\n        \"\"\"\n        Searches the model in question by OR joining the query parameters.\n\n        Implements a Railsy way of looking for a record using a method by the same name and passing\n        in the query as a string (for the OR operator joining to be specified).\n\n        Only the first hit is returned, and there is not particular ordering specified in the server-side\n        API method.\n\n        Args:\n            payload: `dict`. The attributes of a record to search for by using OR operator joining\n                for each query parameter.\n\n        Returns:\n            `dict`: The JSON serialization of the record, if any, found by the API call.\n            `None`: If the API call didnt' return any results.\n        \"\"\"\n        if not isinstance(payload, dict):\n            raise ValueError(\"The 'payload' parameter must be provided a dictionary object.\")\n        url = os.path.join(cls.URL, \"find_by_or\")\n        payload = {\"find_by_or\": payload}\n        cls.debug_logger.debug(\"Searching Pulsar {} for {}\".format(cls.__name__, json.dumps(payload, indent=4)))\n        res = requests.post(url=url, json=payload, headers=HEADERS, verify=False)\n        cls.write_response_html_to_file(res,\"bob.html\")\n        if res:\n           try:\n               res = res[cls.MODEL_NAME]\n           except KeyError:\n               # Key won't be present if there isn't a serializer for it on the server.\n               pass\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef index(cls):\n        res = requests.get(cls.URL, headers=HEADERS, verify=False)\n        res.raise_for_status()\n        return res.json()", "response": "Fetches all records.\n\n        Returns:\n            `dict`. The JSON formatted response.\n\n        Raises:\n            `requests.exceptions.HTTPError`: The status code is not ok."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef patch(self, payload, append_to_arrays=True):\n        if not isinstance(payload, dict):\n            raise ValueError(\"The 'payload' parameter must be provided a dictionary object.\")\n        payload = self.__class__.set_id_in_fkeys(payload)\n        if append_to_arrays:\n            for key in payload:\n                val = payload[key]\n                if type(val) == list:\n                    val.extend(getattr(self, key))\n                    payload[key] = list(set(val))\n        payload = self.check_boolean_fields(payload)\n        payload = self.__class__.add_model_name_to_payload(payload)\n        self.debug_logger.debug(\"PATCHING payload {}\".format(json.dumps(payload, indent=4)))\n        res = requests.patch(url=self.record_url, json=payload, headers=HEADERS, verify=False)\n        self.write_response_html_to_file(res,\"bob.html\")\n        res.raise_for_status()\n        json_res = res.json()\n        self.debug_logger.debug(\"Success\")\n        self.attrs = json_res\n        return json_res", "response": "Patches the current record and udpates the current instance s attrs attribute to reflect the new changes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_id_in_fkeys(cls, payload):\n        for key in payload:\n            val = payload[key]\n            if not val:\n               continue\n            if key.endswith(\"_id\"):\n                model = getattr(THIS_MODULE, cls.FKEY_MAP[key])\n                rec_id = model.replace_name_with_id(name=val)\n                payload[key] = rec_id\n            elif key.endswith(\"_ids\"):\n                model = getattr(THIS_MODULE, cls.FKEY_MAP[key])\n                rec_ids = []\n                for v in val:\n                   rec_id = model.replace_name_with_id(name=v)\n                   rec_ids.append(rec_id)\n                payload[key] = rec_ids\n        return payload", "response": "Sets the ID of the record that is referenced by the foreign key fields in the payload."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nposts the data to the specified record.", "response": "def post(cls, payload):\n        \"\"\"Posts the data to the specified record.\n\n        Args:\n            payload: `dict`. This will be JSON-formatted prior to sending the request.\n\n        Returns:\n            `dict`. The JSON formatted response.\n\n        Raises:\n            `Requests.exceptions.HTTPError`: The status code is not ok.\n            `RecordNotUnique`: The Rails server returned the exception ActiveRecord::RecordNotUnique.\n        \"\"\"\n        if not isinstance(payload, dict):\n            raise ValueError(\"The 'payload' parameter must be provided a dictionary object.\")\n        payload = cls.set_id_in_fkeys(payload)\n        payload = cls.check_boolean_fields(payload)\n        payload = cls.add_model_name_to_payload(payload)\n        # Run any pre-post hooks:\n        payload = cls.prepost_hooks(payload)\n        cls.debug_logger.debug(\"POSTING payload {}\".format(json.dumps(payload, indent=4)))\n        res = requests.post(url=cls.URL, json=(payload), headers=HEADERS, verify=False)\n        cls.write_response_html_to_file(res,\"bob.html\")\n        if not res.ok:\n            cls.log_error(res.text)\n            res_json = res.json()\n            if \"exception\" in res_json:\n                exc_type = res_json[\"exception\"]\n                if exc_type == \"ActiveRecord::RecordNotUnique\":\n                    raise RecordNotUnique()\n        res.raise_for_status()\n        res = res.json()\n        cls.log_post(res)\n        cls.debug_logger.debug(\"Success\")\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef log_error(cls, msg):\n        cls.error_logger.error(msg)\n        cls.debug_logger.debug(msg)", "response": "Logs the provided error message to both the error logger and the debug logger logging\n        instances."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite the response to a file.", "response": "def write_response_html_to_file(response,filename):\n        \"\"\"\n        An aid in troubleshooting internal application errors, i.e.  <Response [500]>, to be mainly\n        beneficial when developing the server-side API. This method will write the response HTML\n        for viewing the error details in the browesr.\n\n        Args:\n            response: `requests.models.Response` instance.\n            filename: `str`. The output file name.\n        \"\"\"\n        fout = open(filename,'w')\n        if not str(response.status_code).startswith(\"2\"):\n            Model.debug_logger.debug(response.text)\n        fout.write(response.text)\n        fout.close()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parent_ids(self):\n        action = os.path.join(self.record_url, \"parent_ids\")\n        res = requests.get(url=action, headers=HEADERS, verify=False)\n        res.raise_for_status()\n        return res.json()[\"biosamples\"]", "response": "Returns an array of parent Biosample IDs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_first_wt_parent(self, with_ip=False):\n        parent_id = self.part_of_id\n        if not parent_id:\n            return False\n        parent = Biosample(parent_id)\n        if parent.wild_type:\n            if with_ip and parent.immunoblot_ids:\n                return parent.id\n            elif not with_ip:\n                return parent.id\n        return parent.find_first_wt_parent(with_ip=with_ip)", "response": "Recursively searches the part_of_id_of_wt_parent method and returns the first WT parent that is not a parent of the Biosample."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef upload(cls, path, document_type, is_protocol, description=\"\"):\n        file_name = os.path.basename(path)\n        mime_type = mimetypes.guess_type(file_name)[0]\n        data = base64.b64encode(open(path, 'rb').read())\n        temp_uri = str(data, \"utf-8\")\n        #href = \"data:{mime_type};base64,{temp_uri}\".format(mime_type=mime_type, temp_uri=temp_uri) \n        payload = {}\n        payload[\"content_type\"] = mime_type \n        payload[\"data\"] = temp_uri\n        payload[\"description\"] = description\n        payload[\"document_type_id\"] = DocumentType(document_type).id\n        payload[\"name\"] =  file_name\n        payload[\"is_protocol\"] = is_protocol\n        cls.post(payload)", "response": "Uploads a new entry to the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_library_barcode_sequence_hash(self, inverse=False):\n        action = os.path.join(self.record_url, \"get_library_barcode_sequence_hash\")\n        res = requests.get(url=action, headers=HEADERS, verify=False)\n        res.raise_for_status()\n        res_json = res.json()\n        # Convert library ID from string to int\n        new_res = {}\n        for lib_id in res_json:\n            new_res[int(lib_id)] = res_json[lib_id]\n        res_json = new_res\n\n        if inverse:\n            rev = {}\n            for lib_id in res_json:\n                rev[res_json[lib_id]] = lib_id\n        res_json = rev\n        return res_json", "response": "Returns a hash of all Libraries and barcode_sequence for all Libraries on the SequencingRequest."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef library_sequencing_results(self):\n        sres_ids = self.sequencing_result_ids\n        res = {}\n        for i in sres_ids:\n            sres = SequencingResult(i)\n            res[sres.library_id] = sres\n        return res", "response": "Generates a dictionary where each key is a Library ID and each value is a SequencingResult. Each key is a SequencingRequest and each value is a SequencingResult. Each value is a SequencingResult."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unarchive_user(self, user_id):\n        url = self.record_url + \"/unarchive\"\n        res = requests.patch(url=url, json={\"user_id\": user_id}, headers=HEADERS, verify=False)\n        self.write_response_html_to_file(res,\"bob.html\")\n        res.raise_for_status()", "response": "Unarchives the user with the specified user ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_api_key(self):\n        url = self.record_url + \"/remove_api_key\"\n        res = requests.patch(url=url, headers=HEADERS, verify=False)\n        res.raise_for_status()\n        self.api_key = \"\"", "response": "Removes the user s existing API key if present and sets the current instance s api_key attribute to the empty string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate the synth observation for the given bases wavelength flux and sigma.", "response": "def generate_synthObs(self, bases_wave, bases_flux, basesCoeff, Av_star, z_star, sigma_star, resample_range = None, resample_int = 1):\n        \n        '''basesWave: Bases wavelength must be at rest'''\n        nbases              = basesCoeff.shape[0]        \n        bases_wave_resam    = arange(int(resample_range[0]), int(resample_range[-1]), resample_int, dtype=float)\n        npix_resample       = len(bases_wave_resam)\n        \n        #Resampling the range\n        bases_flux_resam = empty((nbases, npix_resample))\n        for i in range(nbases):\n#             print bases_wave[i][0], bases_wave[i][-1]\n#             print bases_wave_resam[0], bases_wave_resam[-1]\n            bases_flux_resam[i,:] = interp1d(bases_wave[i], bases_flux[i], bounds_error=True)(bases_wave_resam)            \n        \n        #Display physical parameters\n        synth_wave                  = bases_wave_resam * (1 + z_star)\n        \n        Av_vector                   = Av_star * ones(nbases)\n        Xx_redd                     = CCM89_Bal07(3.4, bases_wave_resam)   \n        r_sigma                     = sigma_star/(synth_wave[1] - synth_wave[0])\n\n        #Defining empty kernel\n        box                         = int(3 * r_sigma) if int(3 * r_sigma) < 3 else 3\n        kernel_len                  = 2 * box + 1\n        kernel                      = zeros((1, kernel_len)) \n        kernel_range                = arange(0, 2 * box + 1)\n        \n        #Generating the kernel with sigma (the norm factor is the sum of the gaussian)\n        kernel[0,:]                 = exp(-0.5 * ((square(kernel_range-box)/r_sigma)))\n        norm                        = np_sum(kernel[0,:])        \n        kernel                      = kernel / norm\n\n        #Convove bases with respect to kernel for dispersion velocity calculation\n        bases_grid_convolve         = convolve2d(bases_flux_resam, kernel, mode='same', boundary='symm')  \n        \n        #Interpolate bases to wavelength range\n        interBases_matrix           = (interp1d(bases_wave_resam, bases_grid_convolve, axis=1, bounds_error=True)(bases_wave_resam)).T       \n\n        #Generate final flux model including dust        \n        dust_attenuation            = power(10, -0.4 * outer(Xx_redd, Av_vector))\n        bases_grid_model            = interBases_matrix * dust_attenuation\n                    \n        #Generate combined flux\n        synth_flux                  = np_sum(basesCoeff.T * bases_grid_model, axis=1)\n                                      \n        return synth_wave, synth_flux"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _process(self, resource=None, data={}):\n        # use object's data if no data is passed\n        _data = data or self._data\n        rsc_url = self.get_rsc_endpoint(resource)\n        if _data:\n            req = requests.post(rsc_url, data=json.dumps(_data),\n                                headers=self.headers)\n        else:\n            req = requests.get(rsc_url, params=_data,\n                               headers=self.headers)\n        if req.status_code == 200:\n            self._response = json.loads(req.text)\n            if int(self._response['response_code']) == 00:\n                return (True, self._response)\n            else:\n                return (False, self._response['response_text'])\n        else:\n            return (500, \"Request Failed\")", "response": "Processes the current transaction and returns the status of the current object"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a custom HTTP header to the client s request headers", "response": "def add_header(self, header):\n        \"\"\"Add a custom HTTP header to the client's request headers\"\"\"\n        if type(header) is dict:\n            self._headers.update(header)\n        else:\n            raise ValueError(\n                \"Dictionary expected, got '%s' instead\" % type(header)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef changelog_cli(ctx):\n    # type: () -> None\n    \"\"\" Generate changelog from commit messages. \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    from peltak.core import shell\n    from . import logic\n    shell.cprint(logic.changelog())", "response": "Generate changelog from commit messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef convert_to_argument(self):\n        '''\n            Convert the Argument object to a tuple use in :meth:`~argparse.ArgumentParser.add_argument` calls on the parser\n        '''\n\n        field_list = [\n            \"action\", \"nargs\", \"const\", \"default\", \"type\",\n            \"choices\", \"required\", \"help\", \"metavar\", \"dest\"\n        ]\n\n        return (\n            self.name,\n            {\n                field: getattr(self, field) for field in field_list if getattr(self, field) is not None\n            }\n        )", "response": "Convert the Argument object to a tuple use in the argument parser. add_argument call on the parser"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the default generated name for the option.", "response": "def get_default_name(self):\n        '''\n        Return the default generated name to store value on the parser for this option.\n\n        eg. An option *['-s', '--use-ssl']* will generate the *use_ssl* name\n\n        Returns:\n            str: the default name of the option\n        '''\n        long_names = [name for name in self.name if name.startswith(\"--\")]\n        short_names = [name for name in self.name if not name.startswith(\"--\")]\n\n        if long_names:\n            return to_snake_case(long_names[0].lstrip(\"-\"))\n\n        return to_snake_case(short_names[0].lstrip(\"-\"))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_filename(self, base_dir=None, modality=None):\n        filename = 'sub-' + self.subject\n        if self.session is not None:\n            filename += '_ses-' + self.session\n        if self.task is not None:\n            filename += '_task-' + self.task\n        if self.run is not None and self.direction is None:\n            filename += '_run-' + self.run\n        if self.acquisition is not None:\n            filename += '_acq-' + self.acquisition\n        if self.direction is not None:\n            filename += '_dir-' + self.direction\n        if self.run is not None and self.direction is not None:\n            filename += '_run-' + self.run\n        if self.modality is not None:\n            filename += '_' + self.modality\n        if self.extension is not None:\n            filename += self.extension\n\n        if base_dir is None:\n            return filename\n\n        else:\n            dir_name = base_dir / ('sub-' + self.subject)\n            if self.session is not None:\n                dir_name /= 'ses-' + self.session\n\n            if modality is not None:\n                dir_name /= modality\n            else:\n                dir_name = add_modality(dir_name, self.modality)\n\n            return dir_name / filename", "response": "Construct the filename based on the attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nselects elements of the TSV using python filter and map.", "response": "def get(self, filter_lambda=None, map_lambda=None):\n        \"\"\"Select elements of the TSV, using python filter and map.\n\n        Parameters\n        ----------\n        filter_lambda : function\n            function to filter the tsv rows (the function needs to return True/False)\n        map_lambda : function\n            function to select the tsv columns\n\n        Returns\n        -------\n        list\n            list (not a generator, because that's the most common case)\n\n        Examples\n        --------\n        To select all the channels in one list, called \"good_labels\"::\n\n            >>> file_Tsv.get(lambda x: x['name'] in good_labels)\n\n        To select all the names of the channels:\n\n            >>> file_Tsv.get(map_filter=lambda x: x['name'])\n\n        \"\"\"\n        if filter_lambda is None:\n            filter_lambda = lambda x: True\n        if map_lambda is None:\n            map_lambda = lambda x: x\n        return list(map(map_lambda, filter(filter_lambda, self.tsv)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(self, client_id: str = None, client_secret: str = None) -> dict:\n        # instanciated or direct call\n        if not client_id and not client_secret:\n            client_id = self.client_id\n            client_secret = self.client_secret\n        else:\n            pass\n\n        # Basic Authentication header in Base64 (https://en.wikipedia.org/wiki/Base64)\n        # see: http://tools.ietf.org/html/rfc2617#section-2\n        # using Client Credentials Grant method\n        # see: http://tools.ietf.org/html/rfc6749#section-4.4\n        payload = {\"grant_type\": \"client_credentials\"}\n        head = {\"user-agent\": self.app_name}\n\n        # passing request to get a 24h bearer\n        # see: http://tools.ietf.org/html/rfc6750#section-2\n        id_url = \"https://id.{}.isogeo.com/oauth/token\".format(self.api_url)\n        try:\n            conn = self.post(\n                id_url,\n                auth=(client_id, client_secret),\n                headers=head,\n                data=payload,\n                proxies=self.proxies,\n                verify=self.ssl,\n            )\n        except ConnectionError as e:\n            raise ConnectionError(\"Connection to Isogeo ID\" \"failed: {}\".format(e))\n\n        # just a fast check\n        check_params = checker.check_api_response(conn)\n        if check_params == 1:\n            pass\n        elif isinstance(check_params, tuple) and len(check_params) == 2:\n            raise ValueError(2, check_params)\n\n        # getting access\n        self.token = conn.json()\n\n        # add expiration date - calculating with a prevention of 10%\n        expiration_delay = self.token.get(\"expires_in\", 3600) - (\n            self.token.get(\"expires_in\", 3600) / 10\n        )\n        self.token[\"expires_at\"] = datetime.utcnow() + timedelta(\n            seconds=expiration_delay\n        )\n\n        # end of method\n        return self.token", "response": "Authenticate application and get token bearer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking API Bearer token validity. Isogeo ID delivers authentication bearers which are valid during a certain time. So this decorator checks the validity of the token comparing with actual datetime (UTC) and renews it if necessary. See: http://tools.ietf.org/html/rfc6750#section-2 :param decorated_func token: original function to execute after check", "response": "def _check_bearer_validity(decorated_func):\n        \"\"\"Check API Bearer token validity.\n\n        Isogeo ID delivers authentication bearers which are valid during\n        a certain time. So this decorator checks the validity of the token\n        comparing with actual datetime (UTC) and renews it if necessary.\n        See: http://tools.ietf.org/html/rfc6750#section-2\n\n        :param decorated_func token: original function to execute after check\n        \"\"\"\n\n        @wraps(decorated_func)\n        def wrapper(self, *args, **kwargs):\n            # compare token expiration date and ask for a new one if it's expired\n            if datetime.now() < self.token.get(\"expires_at\"):\n                self.connect()\n                logging.debug(\"Token was about to expire, so has been renewed.\")\n            else:\n                logging.debug(\"Token is still valid.\")\n                pass\n\n            # let continue running the original function\n            return decorated_func(self, *args, **kwargs)\n\n        return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsearches within the resources shared to the application.", "response": "def search(\n        self,\n        token: dict = None,\n        query: str = \"\",\n        bbox: list = None,\n        poly: str = None,\n        georel: str = None,\n        order_by: str = \"_created\",\n        order_dir: str = \"desc\",\n        page_size: int = 100,\n        offset: int = 0,\n        share: str = None,\n        specific_md: list = [],\n        include: list = [],\n        whole_share: bool = True,\n        check: bool = True,\n        augment: bool = False,\n        tags_as_dicts: bool = False,\n        prot: str = \"https\",\n    ) -> dict:\n        \"\"\"Search within the resources shared to the application.\n\n        It's the main method to use.\n\n        :param str token: API auth token - DEPRECATED: token is now automatically included\n        :param str query: search terms and semantic filters. Equivalent of\n         **q** parameter in Isogeo API. It could be a simple\n         string like *oil* or a tag like *keyword:isogeo:formations*\n         or *keyword:inspire-theme:landcover*. The *AND* operator\n         is applied when various tags are passed.\n        :param list bbox: Bounding box to limit the search.\n         Must be a 4 list of coordinates in WGS84 (EPSG 4326).\n         Could be associated with *georel*.\n        :param str poly: Geographic criteria for the search, in WKT format.\n         Could be associated with *georel*.\n        :param str georel: geometric operator to apply to the bbox or poly\n         parameters.\n\n         Available values (see: *isogeo.GEORELATIONS*):\n\n          * 'contains',\n          * 'disjoint',\n          * 'equals',\n          * 'intersects' - [APPLIED BY API if NOT SPECIFIED]\n          * 'overlaps',\n          * 'within'.\n\n        :param str order_by: sorting results.\n\n         Available values:\n\n          * '_created': metadata creation date [DEFAULT if relevance is null]\n          * '_modified': metadata last update\n          * 'title': metadata title\n          * 'created': data creation date (possibly None)\n          * 'modified': data last update date\n          * 'relevance': relevance score calculated by API [DEFAULT].\n\n        :param str order_dir: sorting direction.\n\n         Available values:\n          * 'desc': descending\n          * 'asc': ascending\n\n        :param int page_size: limits the number of results.\n         Useful to paginate results display. Default value: 100.\n        :param int offset: offset to start page size\n         from a specific results index\n        :param str share: share UUID to filter on\n        :param list specific_md: list of metadata UUIDs to filter on\n        :param list include: subresources that should be returned.\n         Must be a list of strings. Available values: *isogeo.SUBRESOURCES*\n        :param bool whole_share: option to return all results or only the\n         page size. *True* by DEFAULT.\n        :param bool check: option to check query parameters and avoid erros.\n         *True* by DEFAULT.\n        :param bool augment: option to improve API response by adding\n         some tags on the fly (like shares_id)\n        :param bool tags_as_dicts: option to store tags as key/values by filter.\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n        # specific resources specific parsing\n        specific_md = checker._check_filter_specific_md(specific_md)\n\n        # sub resources specific parsing\n        include = checker._check_filter_includes(include)\n\n        # handling request parameters\n        payload = {\n            \"_id\": specific_md,\n            \"_include\": include,\n            \"_lang\": self.lang,\n            \"_limit\": page_size,\n            \"_offset\": offset,\n            \"box\": bbox,\n            \"geo\": poly,\n            \"rel\": georel,\n            \"ob\": order_by,\n            \"od\": order_dir,\n            \"q\": query,\n            \"s\": share,\n        }\n\n        if check:\n            checker.check_request_parameters(payload)\n        else:\n            pass\n\n        # search request\n        search_url = \"{}://v1.{}.isogeo.com/resources/search\".format(prot, self.api_url)\n        try:\n            search_req = self.get(\n                search_url,\n                headers=self.header,\n                params=payload,\n                proxies=self.proxies,\n                verify=self.ssl,\n            )\n        except Exception as e:\n            logging.error(e)\n            raise Exception\n\n        # fast response check\n        checker.check_api_response(search_req)\n\n        # serializing result into dict and storing resources in variables\n        search_rez = search_req.json()\n        resources_count = search_rez.get(\"total\")  # total of metadatas shared\n\n        # handling Isogeo API pagination\n        # see: http://help.isogeo.com/api/fr/methods/pagination.html\n        if resources_count > page_size and whole_share:\n            # if API returned more than one page of results, let's get the rest!\n            metadatas = []  # a recipient list\n            payload[\"_limit\"] = 100  # now it'll get pages of 100 resources\n            # let's parse pages\n            for idx in range(0, int(ceil(resources_count / 100)) + 1):\n                payload[\"_offset\"] = idx * 100\n                search_req = self.get(\n                    search_url,\n                    headers=self.header,\n                    params=payload,\n                    proxies=self.proxies,\n                    verify=self.ssl,\n                )\n                # storing results by addition\n                metadatas.extend(search_req.json().get(\"results\"))\n            search_rez[\"results\"] = metadatas\n        else:\n            pass\n\n        # add shares to tags and query\n        if augment:\n            self.add_tags_shares(search_rez.get(\"tags\"))\n            if share:\n                search_rez.get(\"query\")[\"_shares\"] = [share]\n            else:\n                search_rez.get(\"query\")[\"_shares\"] = []\n        else:\n            pass\n\n        # store tags in dicts\n        if tags_as_dicts:\n            new_tags = utils.tags_to_dict(\n                tags=search_rez.get(\"tags\"), prev_query=search_rez.get(\"query\")\n            )\n            # clear\n            search_rez.get(\"tags\").clear()\n            search_rez.get(\"query\").clear()\n            # update\n            search_rez.get(\"tags\").update(new_tags[0])\n            search_rez.get(\"query\").update(new_tags[1])\n        else:\n            pass\n        # end of method\n        return search_rez"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget complete or partial metadata about one specific resource.", "response": "def resource(\n        self,\n        token: dict = None,\n        id_resource: str = None,\n        subresource=None,\n        include: list = [],\n        prot: str = \"https\",\n    ) -> dict:\n        \"\"\"Get complete or partial metadata about one specific resource.\n\n        :param str token: API auth token\n        :param str id_resource: metadata UUID to get\n        :param list include: subresources that should be included.\n         Must be a list of strings. Available values: 'isogeo.SUBRESOURCES'\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n        # if subresource route\n        if isinstance(subresource, str):\n            subresource = \"/{}\".format(checker._check_subresource(subresource))\n        else:\n            subresource = \"\"\n            # _includes specific parsing\n            include = checker._check_filter_includes(include)\n\n        # handling request parameters\n        payload = {\"id\": id_resource, \"_include\": include}\n        # resource search\n        md_url = \"{}://v1.{}.isogeo.com/resources/{}{}\".format(\n            prot, self.api_url, id_resource, subresource\n        )\n        resource_req = self.get(\n            md_url,\n            headers=self.header,\n            params=payload,\n            proxies=self.proxies,\n            verify=self.ssl,\n        )\n        checker.check_api_response(resource_req)\n\n        # end of method\n        return resource_req.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets information about the application s shares.", "response": "def shares(self, token: dict = None, prot: str = \"https\") -> dict:\n        \"\"\"Get information about shares which feed the application.\n\n        :param str token: API auth token\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n        # passing auth parameter\n        shares_url = \"{}://v1.{}.isogeo.com/shares/\".format(prot, self.api_url)\n        shares_req = self.get(\n            shares_url, headers=self.header, proxies=self.proxies, verify=self.ssl\n        )\n\n        # checking response\n        checker.check_api_response(shares_req)\n\n        # end of method\n        return shares_req.json()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget information about a specific share and its applications.", "response": "def share(\n        self,\n        share_id: str,\n        token: dict = None,\n        augment: bool = False,\n        prot: str = \"https\",\n    ) -> dict:\n        \"\"\"Get information about a specific share and its applications.\n\n        :param str token: API auth token\n        :param str share_id: share UUID\n        :param bool augment: option to improve API response by adding\n         some tags on the fly.\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n        # passing auth parameter\n        share_url = \"{}://v1.{}.isogeo.com/shares/{}\".format(\n            prot, self.api_url, share_id\n        )\n        share_req = self.get(\n            share_url, headers=self.header, proxies=self.proxies, verify=self.ssl\n        )\n\n        # checking response\n        checker.check_api_response(share_req)\n\n        # enhance share model\n        share = share_req.json()\n        if augment:\n            share = utils.share_extender(\n                share, self.search(whole_share=1, share=share_id).get(\"results\")\n            )\n        else:\n            pass\n\n        # end of method\n        return share"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef licenses(\n        self, token: dict = None, owner_id: str = None, prot: str = \"https\"\n    ) -> dict:\n        \"\"\"Get information about licenses owned by a specific workgroup.\n\n        :param str token: API auth token\n        :param str owner_id: workgroup UUID\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n        # handling request parameters\n        payload = {\"gid\": owner_id}\n\n        # search request\n        licenses_url = \"{}://v1.{}.isogeo.com/groups/{}/licenses\".format(\n            prot, self.api_url, owner_id\n        )\n        licenses_req = self.get(\n            licenses_url,\n            headers=self.header,\n            params=payload,\n            proxies=self.proxies,\n            verify=self.ssl,\n        )\n\n        # checking response\n        req_check = checker.check_api_response(licenses_req)\n        if isinstance(req_check, tuple):\n            return req_check\n\n        # end of method\n        return licenses_req.json()", "response": "Get information about licenses owned by a specific workgroup."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef license(self, license_id: str, token: dict = None, prot: str = \"https\") -> dict:\n        # handling request parameters\n        payload = {\"lid\": license_id}\n\n        # search request\n        license_url = \"{}://v1.{}.isogeo.com/licenses/{}\".format(\n            prot, self.api_url, license_id\n        )\n        license_req = self.get(\n            license_url,\n            headers=self.header,\n            params=payload,\n            proxies=self.proxies,\n            verify=self.ssl,\n        )\n\n        # checking response\n        checker.check_api_response(license_req)\n\n        # end of method\n        return license_req.json()", "response": "Get details about a specific license."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef thesauri(self, token: dict = None, prot: str = \"https\") -> dict:\n        # passing auth parameter\n        thez_url = \"{}://v1.{}.isogeo.com/thesauri\".format(prot, self.api_url)\n        thez_req = self.get(\n            thez_url, headers=self.header, proxies=self.proxies, verify=self.ssl\n        )\n\n        # checking response\n        checker.check_api_response(thez_req)\n\n        # end of method\n        return thez_req.json()", "response": "Get list of available thesauri."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a thesaurus. :param str token: API auth token :param str thez_id: thesaurus UUID :param str prot: https [DEFAULT] or http (use it only for dev and tracking needs).", "response": "def thesaurus(\n        self,\n        token: dict = None,\n        thez_id: str = \"1616597fbc4348c8b11ef9d59cf594c8\",\n        prot: str = \"https\",\n    ) -> dict:\n        \"\"\"Get a thesaurus.\n\n        :param str token: API auth token\n        :param str thez_id: thesaurus UUID\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n        # handling request parameters\n        payload = {\"tid\": thez_id}\n\n        # passing auth parameter\n        thez_url = \"{}://v1.{}.isogeo.com/thesauri/{}\".format(\n            prot, self.api_url, thez_id\n        )\n        thez_req = self.get(\n            thez_url,\n            headers=self.header,\n            params=payload,\n            proxies=self.proxies,\n            verify=self.ssl,\n        )\n\n        # checking response\n        checker.check_api_response(thez_req)\n\n        # end of method\n        return thez_req.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches for keywords within a specific thesaurus.", "response": "def keywords(\n        self,\n        token: dict = None,\n        thez_id: str = \"1616597fbc4348c8b11ef9d59cf594c8\",\n        query: str = \"\",\n        offset: int = 0,\n        order_by: str = \"text\",\n        order_dir: str = \"desc\",\n        page_size: int = 20,\n        specific_md: list = [],\n        specific_tag: list = [],\n        include: list = [],\n        prot: str = \"https\",\n    ) -> dict:\n        \"\"\"Search for keywords within a specific thesaurus.\n\n        :param str token: API auth token\n        :param str thez_id: thesaurus UUID\n        :param str query: search terms\n        :param int offset: pagination start\n        :param str order_by: sort criteria. Available values :\n        \n            - count.group,\n            - count.isogeo,\n            - text\n\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n        # specific resources specific parsing\n        specific_md = checker._check_filter_specific_md(specific_md)\n        # sub resources specific parsing\n        include = checker._check_filter_includes(include, \"keyword\")\n        # specific tag specific parsing\n        specific_tag = checker._check_filter_specific_tag(specific_tag)\n\n        # handling request parameters\n        payload = {\n            \"_id\": specific_md,\n            \"_include\": include,\n            \"_limit\": page_size,\n            \"_offset\": offset,\n            \"_tag\": specific_tag,\n            \"tid\": thez_id,\n            \"ob\": order_by,\n            \"od\": order_dir,\n            \"q\": query,\n        }\n\n        # search request\n        keywords_url = \"{}://v1.{}.isogeo.com/thesauri/{}/keywords/search\".format(\n            prot, self.api_url, thez_id\n        )\n\n        kwds_req = self.get(\n            keywords_url,\n            headers=self.header,\n            params=payload,\n            proxies=self.proxies,\n            verify=self.ssl,\n        )\n\n        # checking response\n        checker.check_api_response(kwds_req)\n\n        # end of method\n        return kwds_req.json()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndownload hosted resource. :param str token: API auth token :param dict resource_link: link dictionary :param bool encode_clean: option to ensure a clean filename and avoid OS errors :param str proxy_url: proxy to use to download :param str prot: https [DEFAULT] or http (use it only for dev and tracking needs). Example of resource_link dict: .. code-block:: json { \"_id\": \"g8h9i0j11k12l13m14n15o16p17Q18rS\", \"type\": \"hosted\", \"title\": \"label_of_hosted_file.zip\", \"url\": \"/resources/1a2b3c4d5e6f7g8h9i0j11k12l13m14n/links/g8h9i0j11k12l13m14n15o16p17Q18rS.bin\", \"kind\": \"data\", \"actions\": [\"download\", ], \"size\": \"2253029\", }", "response": "def dl_hosted(\n        self,\n        token: dict = None,\n        resource_link: dict = None,\n        encode_clean: bool = 1,\n        proxy_url: str = None,\n        prot: str = \"https\",\n    ) -> tuple:\n        \"\"\"Download hosted resource.\n\n        :param str token: API auth token\n        :param dict resource_link: link dictionary\n        :param bool encode_clean: option to ensure a clean filename and avoid OS errors\n        :param str proxy_url: proxy to use to download\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n\n        Example of resource_link dict:\n\n        .. code-block:: json\n\n            {\n            \"_id\": \"g8h9i0j11k12l13m14n15o16p17Q18rS\",\n            \"type\": \"hosted\",\n            \"title\": \"label_of_hosted_file.zip\",\n            \"url\": \"/resources/1a2b3c4d5e6f7g8h9i0j11k12l13m14n/links/g8h9i0j11k12l13m14n15o16p17Q18rS.bin\",\n            \"kind\": \"data\",\n            \"actions\": [\"download\", ],\n            \"size\": \"2253029\",\n            }\n\n        \"\"\"\n        # check resource link parameter type\n        if not isinstance(resource_link, dict):\n            raise TypeError(\"Resource link expects a dictionary.\")\n        else:\n            pass\n        # check resource link type\n        if not resource_link.get(\"type\") == \"hosted\":\n            raise ValueError(\n                \"Resource link passed is not a hosted one: {}\".format(\n                    resource_link.get(\"type\")\n                )\n            )\n        else:\n            pass\n\n        # handling request parameters\n        payload = {\"proxyUrl\": proxy_url}\n\n        # prepare URL request\n        hosted_url = \"{}://v1.{}.isogeo.com/{}\".format(\n            prot, self.api_url, resource_link.get(\"url\")\n        )\n\n        # send stream request\n        hosted_req = self.get(\n            hosted_url,\n            headers=self.header,\n            stream=True,\n            params=payload,\n            proxies=self.proxies,\n            verify=self.ssl,\n        )\n        # quick check\n        req_check = checker.check_api_response(hosted_req)\n        if not req_check:\n            raise ConnectionError(req_check[1])\n        else:\n            pass\n\n        # get filename from header\n        content_disposition = hosted_req.headers.get(\"Content-Disposition\")\n        if content_disposition:\n            filename = re.findall(\"filename=(.+)\", content_disposition)[0]\n        else:\n            filename = resource_link.get(\"title\")\n\n        # remove special characters\n        if encode_clean:\n            filename = utils.encoded_words_to_text(filename)\n            filename = re.sub(r\"[^\\w\\-_\\. ]\", \"\", filename)\n\n        # well-formed size\n        in_size = resource_link.get(\"size\")\n        for size_cat in (\"octets\", \"Ko\", \"Mo\", \"Go\"):\n            if in_size < 1024.0:\n                out_size = \"%3.1f %s\" % (in_size, size_cat)\n            in_size /= 1024.0\n\n        out_size = \"%3.1f %s\" % (in_size, \" To\")\n\n        # end of method\n        return (hosted_req, filename, out_size)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget resource exported into XML ISO 19139.", "response": "def xml19139(\n        self,\n        token: dict = None,\n        id_resource: str = None,\n        proxy_url=None,\n        prot: str = \"https\",\n    ):\n        \"\"\"Get resource exported into XML ISO 19139.\n\n        :param str token: API auth token\n        :param str id_resource: metadata UUID to export\n        :param str proxy_url: proxy to use to download\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n        # check metadata UUID\n        if not checker.check_is_uuid(id_resource):\n            raise ValueError(\"Metadata ID is not a correct UUID.\")\n        else:\n            pass\n\n        # handling request parameters\n        payload = {\"proxyUrl\": proxy_url, \"id\": id_resource}\n\n        # resource search\n        md_url = \"{}://v1.{}.isogeo.com/resources/{}.xml\".format(\n            prot, self.api_url, id_resource\n        )\n        xml_req = self.get(\n            md_url,\n            headers=self.header,\n            stream=True,\n            params=payload,\n            proxies=self.proxies,\n            verify=self.ssl,\n        )\n\n        # end of method\n        return xml_req"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding shares list to the tags dictionary in search results.", "response": "def add_tags_shares(self, tags: dict = dict()):\n        \"\"\"Add shares list to the tags attributes in search results.\n\n        :param dict tags: tags dictionary from a search request\n        \"\"\"\n        # check if shares_id have already been retrieved or not\n        if not hasattr(self, \"shares_id\"):\n            shares = self.shares()\n            self.shares_id = {\n                \"share:{}\".format(i.get(\"_id\")): i.get(\"name\") for i in shares\n            }\n        else:\n            pass\n        # update query tags\n        tags.update(self.shares_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets information about the application declared on Isogeo.", "response": "def get_app_properties(self, token: dict = None, prot: str = \"https\"):\n        \"\"\"Get information about the application declared on Isogeo.\n\n        :param str token: API auth token\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n        # check if app properties have already been retrieved or not\n        if not hasattr(self, \"app_properties\"):\n            first_app = self.shares()[0].get(\"applications\")[0]\n            app = {\n                \"admin_url\": \"{}/applications/{}\".format(\n                    self.mng_url, first_app.get(\"_id\")\n                ),\n                \"creation_date\": first_app.get(\"_created\"),\n                \"last_update\": first_app.get(\"_modified\"),\n                \"name\": first_app.get(\"name\"),\n                \"type\": first_app.get(\"type\"),\n                \"kind\": first_app.get(\"kind\"),\n                \"url\": first_app.get(\"url\"),\n            }\n            self.app_properties = app\n        else:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting environment directives which represent INSPIRE limitations.", "response": "def get_directives(self, token: dict = None, prot: str = \"https\") -> dict:\n        \"\"\"Get environment directives which represent INSPIRE limitations.\n\n        :param str token: API auth token\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n        # search request\n        req_url = \"{}://v1.{}.isogeo.com/directives\".format(prot, self.api_url)\n\n        req = self.get(\n            req_url, headers=self.header, proxies=self.proxies, verify=self.ssl\n        )\n\n        # checking response\n        checker.check_api_response(req)\n\n        # end of method\n        return req.json()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_coordinate_systems(\n        self, token: dict = None, srs_code: str = None, prot: str = \"https\"\n    ) -> dict:\n        \"\"\"Get available coordinate systems in Isogeo API.\n\n        :param str token: API auth token\n        :param str srs_code: code of a specific coordinate system\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n        # if specific format\n        if isinstance(srs_code, str):\n            specific_srs = \"/{}\".format(srs_code)\n        else:\n            specific_srs = \"\"\n\n        # search request\n        req_url = \"{}://v1.{}.isogeo.com/coordinate-systems{}\".format(\n            prot, self.api_url, specific_srs\n        )\n\n        req = self.get(\n            req_url, headers=self.header, proxies=self.proxies, verify=self.ssl\n        )\n\n        # checking response\n        checker.check_api_response(req)\n\n        # end of method\n        return req.json()", "response": "Get available coordinate systems in Isogeo API."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the formats for a specific language.", "response": "def get_formats(\n        self, token: dict = None, format_code: str = None, prot: str = \"https\"\n    ) -> dict:\n        \"\"\"Get formats.\n\n        :param str token: API auth token\n        :param str format_code: code of a specific format\n        :param str prot: https [DEFAULT] or http\n         (use it only for dev and tracking needs).\n        \"\"\"\n        # if specific format\n        if isinstance(format_code, str):\n            specific_format = \"/{}\".format(format_code)\n        else:\n            specific_format = \"\"\n\n        # search request\n        req_url = \"{}://v1.{}.isogeo.com/formats{}\".format(\n            prot, self.api_url, specific_format\n        )\n\n        req = self.get(\n            req_url, headers=self.header, proxies=self.proxies, verify=self.ssl\n        )\n\n        # checking response\n        checker.check_api_response(req)\n\n        # end of method\n        return req.json()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a boolean value from the input string and returns the corresponding value.", "response": "def parse_bool(v, default=None, exceptions: bool=True) -> bool:\n    \"\"\"\n    Parses boolean value\n    :param v: Input string\n    :param default: Default value if exceptions=False\n    :param exceptions: Raise exception on error or not\n    :return: bool\n    \"\"\"\n    if isinstance(v, bool):\n        return v\n    s = str(v).lower()\n    if s in TRUE_VALUES:\n        return True\n    elif s in FALSE_VALUES:\n        return False\n    else:\n        if exceptions:\n            raise ValidationError('Failed to parse boolean from \"{}\"'.format(v))\n        return default"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_datetime(v, default=None, tz=None, exceptions: bool=True) -> datetime:\n    try:\n        t = dateutil_parse(v, default=datetime(2000, 1, 1))\n        if tz is None:\n            tz = pytz.utc\n        return t if t.tzinfo else tz.localize(t)\n    except Exception:\n        if exceptions:\n            raise ValidationError('Failed to parse datetime from \"{}\"'.format(v))\n        return default", "response": "Parses a datetime from a string into a datetime object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert_boolean(string_value):\n\n    lean_string_value = string_value.strip().lower()\n    if lean_string_value in ['yes', 'true', 'on', '1']:\n        return True\n    elif lean_string_value in ['no', 'false', 'off', '0']:\n        return False\n\n    # Not recognised boolean if we get here\n    raise ValueError('Unrecognised boolean ({})'.format(lean_string_value))", "response": "Converts a string to a boolean."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _handle_hdr(self, hdr):\n\n        column_number = 1\n        for cell in hdr:\n            cell_parts = cell.split(self._type_sep)\n            if len(cell_parts) not in [1, 2]:\n                raise ContentError(column_number, self._c_reader.line_num,\n                                   cell, 'Expected name and type (up to 2 items)')\n            name = cell_parts[0].strip()\n            if len(name) == 0:\n                raise ContentError(column_number, self._c_reader.line_num,\n                                   cell, 'Column name is empty')\n            if name in self._column_names:\n                raise ContentError(column_number, self._c_reader.line_num,\n                                   name, 'Duplicate column name')\n\n            if len(cell_parts) == 2:\n                column_type = cell_parts[1].strip().lower()\n                if column_type not in CONVERTERS:\n                    raise UnknownTypeError(column_number, column_type)\n            else:\n                # Unspecified - assume built-in 'string'\n                column_type = 'string'\n            self._converters.append([name, CONVERTERS[column_type]])\n            self._column_names.append(name)\n            column_number += 1", "response": "Handles the header line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching datasets within uData portal.", "response": "def search_datasets(\n        self,\n        license=None,\n        format=None,\n        query=None,\n        featured=None,\n        owner=None,\n        organization=None,\n        badge=None,\n        reuses=None,\n        page_size=20,\n        x_fields=None,\n    ):\n        \"\"\"Search datasets within uData portal.\"\"\"\n        # handling request parameters\n        payload = {\"badge\": badge, \"size\": page_size, \"X-Fields\": x_fields}\n\n        # search request\n        # head = {\"X-API-KEY\": self.api_key}\n        search_url = \"{}/datasets\".format(\n            self.base_url,\n            # org_id,\n            # page_size\n        )\n\n        search_req = requests.get(\n            search_url,\n            # headers=head,\n            params=payload,\n        )\n\n        # serializing result into dict and storing resources in variables\n        logger.debug(search_req.url)\n        return search_req.json()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_filters_values(self):\n        # DATASETS --\n        # badges\n        self._DST_BADGES = requests.get(self.base_url + \"datasets/badges/\").json()\n        # licences\n        self._DST_LICENSES = {\n            l.get(\"id\"): l.get(\"title\")\n            for l in requests.get(self.base_url + \"datasets/licenses\").json()\n        }\n        # frequencies\n        self._DST_FREQUENCIES = {\n            f.get(\"id\"): f.get(\"label\")\n            for f in requests.get(self.base_url + \"datasets/frequencies\").json()\n        }\n        # ORGANIZATIONS --\n        # badges\n        self._ORG_BADGES = requests.get(self.base_url + \"organizations/badges/\").json()\n        # # licences\n        # self._DST_LICENSES = {l.get(\"id\"): l.get(\"title\")\n        #                   for l in requests.get(self.base_url + \"datasets/licenses\").json()}\n        # # frequencies\n        # self._DST_FREQUENCIES = {f.get(\"id\"): f.get(\"label\")\n        #                      for f in requests.get(self.base_url + \"datasets/frequencies\").json()}\n        # SPATIAL --\n        # granularities\n        self._GRANULARITIES = {\n            g.get(\"id\"): g.get(\"name\")\n            for g in requests.get(self.base_url + \"spatial/granularities\").json()\n        }\n        # levels\n        self._LEVELS = {\n            g.get(\"id\"): g.get(\"name\")\n            for g in requests.get(self.base_url + \"spatial/levels\").json()\n        }\n        # MISC --\n        # facets\n        self._FACETS = (\n            \"all\",\n            \"badge\",\n            \"featured\",\n            \"format\",\n            \"geozone\",\n            \"granularity\",\n            \"license\",\n            \"owner\",\n            \"organization\",\n            \"reuses\",\n            \"tag\",\n            \"temporal_coverage\",\n        )\n        # reuses\n        self._REUSES = (\"none\", \"few\", \"quite\", \"many\")", "response": "Get different filters values as dicts."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeploys the app to AppEngine.", "response": "def deploy(app_id, version, promote, quiet):\n    # type: (str, str, bool, bool) -> None\n    \"\"\" Deploy the app to AppEngine.\n\n    Args:\n        app_id (str):\n            AppEngine App ID. Overrides config value app_id if given.\n        version (str):\n            AppEngine project version. Overrides config values if given.\n        promote (bool):\n            If set to **True** promote the current remote app version to the one\n            that's being deployed.\n        quiet (bool):\n            If set to **True** this will pass the ``--quiet`` flag to gcloud\n            command.\n    \"\"\"\n    gae_app = GaeApp.for_branch(git.current_branch().name)\n\n    if gae_app is None and None in (app_id,  version):\n        msg = (\n            \"Can't find an AppEngine app setup for branch <35>{}<32> and\"\n            \"--project and --version were not given.\"\n        )\n        log.err(msg, git.current_branch().name)\n        sys.exit(1)\n\n    if version is not None:\n        gae_app.version = version\n\n    if app_id is not None:\n        gae_app.app_id = app_id\n\n    gae_app.deploy(promote, quiet)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef devserver(port, admin_port, clear):\n    # type: (int, int, bool) -> None\n    \"\"\" Run devserver.\n\n    Args:\n        port (int):\n            Port on which the app will be served.\n        admin_port (int):\n            Port on which the admin interface is served.\n        clear (bool):\n            If set to **True**, clear the datastore on startup.\n    \"\"\"\n    admin_port = admin_port or (port + 1)\n\n    args = [\n        '--port={}'.format(port),\n        '--admin_port={}'.format(admin_port)\n    ]\n\n    if clear:\n        args += ['--clear_datastore=yes']\n\n    with conf.within_proj_dir():\n        shell.run('dev_appserver.py . {args}'.format(args=' '.join(args)))", "response": "Run devserver on startup."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setup_ci():\n    # type: () -> None\n    \"\"\" Setup AppEngine SDK on CircleCI \"\"\"\n    gcloud_path = shell.run('which gcloud', capture=True).stdout.strip()\n    sdk_path = normpath(join(gcloud_path, '../../platform/google_appengine'))\n    gcloud_cmd = gcloud_path + ' --quiet'\n\n    if not exists(sdk_path):\n        log.info(\"Installing AppEngine SDK\")\n        shell.run('sudo {} components install app-engine-python'.format(\n            gcloud_cmd\n        ))\n    else:\n        # Only initialise once. To reinitialise, just build without cache.\n        log.info(\"AppEngine SDK already initialised\")\n\n    log.info(\"Using service account authentication\")\n    shell.run('{} auth activate-service-account --key-file {}'.format(\n        gcloud_cmd,\n        conf.proj_path('ops/client_secret.json')\n    ))", "response": "Setup AppEngine SDK on CircleCI"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmark function as experimental.", "response": "def mark_experimental(fn):\n    # type: (FunctionType) -> FunctionType\n    \"\"\" Mark function as experimental.\n\n    Args:\n        fn (FunctionType):\n            The command function to decorate.\n    \"\"\"\n    @wraps(fn)\n    def wrapper(*args, **kw):   # pylint: disable=missing-docstring\n        from peltak.core import shell\n\n        if shell.is_tty:\n            warnings.warn(\"This command is has experimental status. The \"\n                          \"interface is not yet stable and might change \"\n                          \"without notice within with a patch version update. \"\n                          \"Use at your own risk\")\n        return fn(*args, **kw)\n\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmarking a function as deprecated.", "response": "def mark_deprecated(replaced_by):\n    # type: (Text) -> FunctionType\n    \"\"\" Mark command as deprecated.\n\n    Args:\n        replaced_by (str):\n            The command that deprecated this command and should be used instead.\n    \"\"\"\n    def decorator(fn):   # pylint: disable=missing-docstring\n        @wraps(fn)\n        def wrapper(*args, **kw):   # pylint: disable=missing-docstring\n            from peltak.core import shell\n\n            if shell.is_tty:\n                warnings.warn(\"This command is has been deprecated. Please use \"\n                              \"{new} instead.\".format(new=replaced_by))\n\n            return fn(*args, **kw)\n\n        return wrapper\n\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsplit the given iterable into batches of size batch_size.", "response": "def in_batches(iterable, batch_size):\n    # type: (Iterable[Any]) -> Generator[List[Any]]\n    \"\"\" Split the given iterable into batches.\n\n    Args:\n        iterable (Iterable[Any]):\n            The iterable you want to split into batches.\n        batch_size (int):\n            The size of each bach. The last batch will be probably smaller (if\n            the number of elements cannot be equally divided.\n\n    Returns:\n        Generator[list[Any]]: Will yield all items in batches of **batch_size**\n            size.\n\n    Example:\n\n        >>> from peltak.core import util\n        >>>\n        >>> batches = util.in_batches([1, 2, 3, 4, 5, 6, 7], 3)\n        >>> batches = list(batches)     # so we can query for lenght\n        >>> len(batches)\n        3\n        >>> batches\n        [[1, 2, 3], [4, 5, 6], [7]]\n\n    \"\"\"\n    items = list(iterable)\n    size = len(items)\n\n    for i in range(0, size, batch_size):\n        yield items[i:min(i + batch_size, size)]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef yaml_dump(data, stream=None):\n    # type: (YamlData, Optional[TextIO]) -> Text\n    \"\"\" Dump data to a YAML string/file.\n\n    Args:\n        data (YamlData):\n            The data to serialize as YAML.\n        stream (TextIO):\n            The file-like object to save to. If given, this function will write\n            the resulting YAML to that stream.\n\n    Returns:\n        str: The YAML string.\n    \"\"\"\n    return yaml.dump(\n        data,\n        stream=stream,\n        Dumper=Dumper,\n        default_flow_style=False\n    )", "response": "Dump data to a YAML string or file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clear(cls, fn):\n        # type: (FunctionType) -> None\n        \"\"\" Clear result cache on the given function.\n\n        If the function has no cached result, this call will do nothing.\n\n        Args:\n            fn (FunctionType):\n                The function whose cache should be cleared.\n        \"\"\"\n        if hasattr(fn, cls.CACHE_VAR):\n            delattr(fn, cls.CACHE_VAR)", "response": "Clears the result cache on the given function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstart working on a new feature by branching off develop.", "response": "def start(name):\n    # type: (str) -> None\n    \"\"\" Start working on a new feature by branching off develop.\n\n    This will create a new branch off develop called feature/<name>.\n\n    Args:\n        name (str):\n            The name of the new feature.\n    \"\"\"\n    branch = git.current_branch(refresh=True)\n    task_branch = 'task/' + common.to_branch_name(name)\n\n    if branch.type not in ('feature', 'hotfix'):\n        log.err(\"Task branches can only branch off <33>feature<32> or \"\n                \"<33>hotfix<32> branches\")\n        sys.exit(1)\n\n    common.git_checkout(task_branch, create=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update():\n    # type: () -> None\n    \"\"\" Update the feature with updates committed to develop.\n\n    This will merge current develop into the current branch.\n    \"\"\"\n    branch = git.current_branch(refresh=True)\n    base_branch = common.get_base_branch()\n\n    common.assert_branch_type('task')\n    common.git_checkout(base_branch)\n    common.git_pull(base_branch)\n    common.git_checkout(branch.name)\n    common.git_merge(branch.name, base_branch)", "response": "Update the feature with updates committed to develop."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef finish():\n    # type: () -> None\n    \"\"\" Merge current feature branch into develop. \"\"\"\n    pretend = context.get('pretend', False)\n\n    if not pretend and (git.staged() or git.unstaged()):\n        log.err(\n            \"You have uncommitted changes in your repo!\\n\"\n            \"You need to stash them before you merge the hotfix branch\"\n        )\n        sys.exit(1)\n\n    branch = git.current_branch(refresh=True)\n    base = common.get_base_branch()\n\n    prompt = \"<32>Merge <33>{}<32> into <33>{}<0>?\".format(branch.name, base)\n    if not click.confirm(shell.fmt(prompt)):\n        log.info(\"Cancelled\")\n        return\n\n    common.assert_branch_type('task')\n\n    # Merge task into it's base feature branch\n    common.git_checkout(base)\n    common.git_pull(base)\n    common.git_merge(base, branch.name)\n\n    # Cleanup\n    common.git_branch_delete(branch.name)\n    common.git_prune()\n\n    common.git_checkout(base)", "response": "Merge current feature branch into develop."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef merged():\n    # type: () -> None\n    \"\"\" Cleanup a remotely merged branch. \"\"\"\n    base_branch = common.get_base_branch()\n    branch = git.current_branch(refresh=True)\n\n    common.assert_branch_type('task')\n\n    # Pull feature branch with the merged task\n    common.git_checkout(base_branch)\n    common.git_pull(base_branch)\n\n    # Cleanup\n    common.git_branch_delete(branch.name)\n    common.git_prune()\n\n    common.git_checkout(base_branch)", "response": "Cleanup a remotely merged task."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling a Mutagen function with appropriate error handling.", "response": "def mutagen_call(action, path, func, *args, **kwargs):\n    \"\"\"Call a Mutagen function with appropriate error handling.\n\n    `action` is a string describing what the function is trying to do,\n    and `path` is the relevant filename. The rest of the arguments\n    describe the callable to invoke.\n\n    We require at least Mutagen 1.33, where `IOError` is *never* used,\n    neither for internal parsing errors *nor* for ordinary IO error\n    conditions such as a bad filename. Mutagen-specific parsing errors and IO\n    errors are reraised as `UnreadableFileError`. Other exceptions\n    raised inside Mutagen---i.e., bugs---are reraised as `MutagenError`.\n    \"\"\"\n    try:\n        return func(*args, **kwargs)\n    except mutagen.MutagenError as exc:\n        log.debug(u'%s failed: %s', action, six.text_type(exc))\n        raise UnreadableFileError(path, six.text_type(exc))\n    except Exception as exc:\n        # Isolate bugs in Mutagen.\n        log.debug(u'%s', traceback.format_exc())\n        log.error(u'uncaught Mutagen exception in %s: %s', action, exc)\n        raise MutagenError(path, exc)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _safe_cast(out_type, val):\n    if val is None:\n        return None\n\n    if out_type == int:\n        if isinstance(val, int) or isinstance(val, float):\n            # Just a number.\n            return int(val)\n        else:\n            # Process any other type as a string.\n            if isinstance(val, bytes):\n                val = val.decode('utf-8', 'ignore')\n            elif not isinstance(val, six.string_types):\n                val = six.text_type(val)\n            # Get a number from the front of the string.\n            match = re.match(r'[\\+-]?[0-9]+', val.strip())\n            return int(match.group(0)) if match else 0\n\n    elif out_type == bool:\n        try:\n            # Should work for strings, bools, ints:\n            return bool(int(val))\n        except ValueError:\n            return False\n\n    elif out_type == six.text_type:\n        if isinstance(val, bytes):\n            return val.decode('utf-8', 'ignore')\n        elif isinstance(val, six.text_type):\n            return val\n        else:\n            return six.text_type(val)\n\n    elif out_type == float:\n        if isinstance(val, int) or isinstance(val, float):\n            return float(val)\n        else:\n            if isinstance(val, bytes):\n                val = val.decode('utf-8', 'ignore')\n            else:\n                val = six.text_type(val)\n            match = re.match(r'[\\+-]?([0-9]+\\.?[0-9]*|[0-9]*\\.[0-9]+)',\n                             val.strip())\n            if match:\n                val = match.group(0)\n                if val:\n                    return float(val)\n            return 0.0\n\n    else:\n        return val", "response": "Try to covert val to out_type but never raise an exception."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nunpacking image data from a WM / Picture tag. Return a tuple containing the MIME type the raw image data a type indicator and the image s description.", "response": "def _unpack_asf_image(data):\n    \"\"\"Unpack image data from a WM/Picture tag. Return a tuple\n    containing the MIME type, the raw image data, a type indicator, and\n    the image's description.\n\n    This function is treated as \"untrusted\" and could throw all manner\n    of exceptions (out-of-bounds, etc.). We should clean this up\n    sometime so that the failure modes are well-defined.\n    \"\"\"\n    type, size = struct.unpack_from('<bi', data)\n    pos = 5\n    mime = b''\n    while data[pos:pos + 2] != b'\\x00\\x00':\n        mime += data[pos:pos + 2]\n        pos += 2\n    pos += 2\n    description = b''\n    while data[pos:pos + 2] != b'\\x00\\x00':\n        description += data[pos:pos + 2]\n        pos += 2\n    pos += 2\n    image_data = data[pos:pos + size]\n    return (mime.decode(\"utf-16-le\"), image_data, type,\n            description.decode(\"utf-16-le\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npacks image data for a WM / Picture tag.", "response": "def _pack_asf_image(mime, data, type=3, description=\"\"):\n    \"\"\"Pack image data for a WM/Picture tag.\n    \"\"\"\n    tag_data = struct.pack('<bi', type, len(data))\n    tag_data += mime.encode(\"utf-16-le\") + b'\\x00\\x00'\n    tag_data += description.encode(\"utf-16-le\") + b'\\x00\\x00'\n    tag_data += data\n    return tag_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a Sound Check bytestring value to a tuple of gain and peak.", "response": "def _sc_decode(soundcheck):\n    \"\"\"Convert a Sound Check bytestring value to a (gain, peak) tuple as\n    used by ReplayGain.\n    \"\"\"\n    # We decode binary data. If one of the formats gives us a text\n    # string, interpret it as UTF-8.\n    if isinstance(soundcheck, six.text_type):\n        soundcheck = soundcheck.encode('utf-8')\n\n    # SoundCheck tags consist of 10 numbers, each represented by 8\n    # characters of ASCII hex preceded by a space.\n    try:\n        soundcheck = codecs.decode(soundcheck.replace(b' ', b''), 'hex')\n        soundcheck = struct.unpack('!iiiiiiiiii', soundcheck)\n    except (struct.error, TypeError, binascii.Error):\n        # SoundCheck isn't in the format we expect, so return default\n        # values.\n        return 0.0, 0.0\n\n    # SoundCheck stores absolute calculated/measured RMS value in an\n    # unknown unit. We need to find the ratio of this measurement\n    # compared to a reference value of 1000 to get our gain in dB. We\n    # play it safe by using the larger of the two values (i.e., the most\n    # attenuation).\n    maxgain = max(soundcheck[:2])\n    if maxgain > 0:\n        gain = math.log10(maxgain / 1000.0) * -10\n    else:\n        # Invalid gain value found.\n        gain = 0.0\n\n    # SoundCheck stores peak values as the actual value of the sample,\n    # and again separately for the left and right channels. We need to\n    # convert this to a percentage of full scale, which is 32768 for a\n    # 16 bit sample. Once again, we play it safe by using the larger of\n    # the two values.\n    peak = max(soundcheck[6:8]) / 32768.0\n\n    return round(gain, 2), round(peak, 6)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nencode the given gain and peak values as a Sound Check string.", "response": "def _sc_encode(gain, peak):\n    \"\"\"Encode ReplayGain gain/peak values as a Sound Check string.\n    \"\"\"\n    # SoundCheck stores the peak value as the actual value of the\n    # sample, rather than the percentage of full scale that RG uses, so\n    # we do a simple conversion assuming 16 bit samples.\n    peak *= 32768.0\n\n    # SoundCheck stores absolute RMS values in some unknown units rather\n    # than the dB values RG uses. We can calculate these absolute values\n    # from the gain ratio using a reference value of 1000 units. We also\n    # enforce the maximum value here, which is equivalent to about\n    # -18.2dB.\n    g1 = int(min(round((10 ** (gain / -10)) * 1000), 65534))\n    # Same as above, except our reference level is 2500 units.\n    g2 = int(min(round((10 ** (gain / -10)) * 2500), 65534))\n\n    # The purpose of these values are unknown, but they also seem to be\n    # unused so we just use zero.\n    uk = 0\n    values = (g1, g1, g2, g2, uk, uk, int(peak), int(peak), uk, uk)\n    return (u' %08X' * 10) % values"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the MIME type of the image data.", "response": "def image_mime_type(data):\n    \"\"\"Return the MIME type of the image data (a bytestring).\n    \"\"\"\n    # This checks for a jpeg file with only the magic bytes (unrecognized by\n    # imghdr.what). imghdr.what returns none for that type of file, so\n    # _wider_test_jpeg is run in that case. It still returns None if it didn't\n    # match such a jpeg file.\n    kind = _imghdr_what_wrapper(data)\n    if kind in ['gif', 'jpeg', 'png', 'tiff', 'bmp']:\n        return 'image/{0}'.format(kind)\n    elif kind == 'pgm':\n        return 'image/x-portable-graymap'\n    elif kind == 'pbm':\n        return 'image/x-portable-bitmap'\n    elif kind == 'ppm':\n        return 'image/x-portable-pixmap'\n    elif kind == 'xbm':\n        return 'image/x-xbitmap'\n    else:\n        return 'image/x-{0}'.format(kind)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a raw value stored on a Mutagen object decode and return the represented value.", "response": "def deserialize(self, mutagen_value):\n        \"\"\"Given a raw value stored on a Mutagen object, decode and\n        return the represented value.\n        \"\"\"\n        if self.suffix and isinstance(mutagen_value, six.text_type) \\\n           and mutagen_value.endswith(self.suffix):\n            return mutagen_value[:-len(self.suffix)]\n        else:\n            return mutagen_value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set(self, mutagen_file, value):\n        self.store(mutagen_file, self.serialize(value))", "response": "Assign the value for the field using this style."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef serialize(self, value):\n        if isinstance(value, float) and self.as_type is six.text_type:\n            value = u'{0:.{1}f}'.format(value, self.float_places)\n            value = self.as_type(value)\n        elif self.as_type is six.text_type:\n            if isinstance(value, bool):\n                # Store bools as 1/0 instead of True/False.\n                value = six.text_type(int(bool(value)))\n            elif isinstance(value, bytes):\n                value = value.decode('utf-8', 'ignore')\n            else:\n                value = six.text_type(value)\n        else:\n            value = self.as_type(value)\n\n        if self.suffix:\n            value += self.suffix\n\n        return value", "response": "Convert the external Python value to a type that is suitable for storing in a Mutagen file object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_list(self, mutagen_file):\n        return [self.deserialize(item) for item in self.fetch(mutagen_file)]", "response": "Get a list of all values for the field using this style."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_list(self, mutagen_file, values):\n        self.store(mutagen_file, [self.serialize(value) for value in values])", "response": "Set all values for the field using this style. values should be an iterable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting APIC frame into Image.", "response": "def deserialize(self, apic_frame):\n        \"\"\"Convert APIC frame into Image.\"\"\"\n        return Image(data=apic_frame.data, desc=apic_frame.desc,\n                     type=apic_frame.type)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an APIC frame populated with data from image.", "response": "def serialize(self, image):\n        \"\"\"Return an APIC frame populated with data from ``image``.\n        \"\"\"\n        assert isinstance(image, Image)\n        frame = mutagen.id3.Frames[self.key]()\n        frame.data = image.data\n        frame.mime = image.mime_type\n        frame.desc = image.desc or u''\n\n        # For compatibility with OS X/iTunes prefer latin-1 if possible.\n        # See issue #899\n        try:\n            frame.desc.encode(\"latin-1\")\n        except UnicodeEncodeError:\n            frame.encoding = mutagen.id3.Encoding.UTF16\n        else:\n            frame.encoding = mutagen.id3.Encoding.LATIN1\n\n        frame.type = image.type_index\n        return frame"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nturn a Image into a base64 encoded FLAC picture block.", "response": "def serialize(self, image):\n        \"\"\"Turn a Image into a base64 encoded FLAC picture block.\n        \"\"\"\n        pic = mutagen.flac.Picture()\n        pic.data = image.data\n        pic.type = image.type_index\n        pic.mime = image.mime_type\n        pic.desc = image.desc or u''\n\n        # Encoding with base64 returns bytes on both Python 2 and 3.\n        # Mutagen requires the data to be a Unicode string, so we decode\n        # it before passing it along.\n        return base64.b64encode(pic.write()).decode('ascii')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstoring the given pictures in the given mutagen file.", "response": "def store(self, mutagen_file, pictures):\n        \"\"\"``pictures`` is a list of mutagen.flac.Picture instances.\n        \"\"\"\n        mutagen_file.clear_pictures()\n        for pic in pictures:\n            mutagen_file.add_picture(pic)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nturning a Image into a mutagen. flac. Picture.", "response": "def serialize(self, image):\n        \"\"\"Turn a Image into a mutagen.flac.Picture.\n        \"\"\"\n        pic = mutagen.flac.Picture()\n        pic.data = image.data\n        pic.type = image.type_index\n        pic.mime = image.mime_type\n        pic.desc = image.desc or u''\n        return pic"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self, mutagen_file):\n        for cover_tag in self.TAG_NAMES.values():\n            try:\n                del mutagen_file[cover_tag]\n            except KeyError:\n                pass", "response": "Delete all images from the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nyields the list of storage styles that can handle the MediaFile s format.", "response": "def styles(self, mutagen_file):\n        \"\"\"Yields the list of storage styles of this field that can\n        handle the MediaFile's format.\n        \"\"\"\n        for style in self._styles:\n            if mutagen_file.__class__.__name__ in style.formats:\n                yield style"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _none_value(self):\n        if self.out_type == int:\n            return 0\n        elif self.out_type == float:\n            return 0.0\n        elif self.out_type == bool:\n            return False\n        elif self.out_type == six.text_type:\n            return u''", "response": "Get an appropriate null value for this field s type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a 3 - item sequence representing the date consisting of year month and day number. Each number is either an integer or None.", "response": "def _get_date_tuple(self, mediafile):\n        \"\"\"Get a 3-item sequence representing the date consisting of a\n        year, month, and day number. Each number is either an integer or\n        None.\n        \"\"\"\n        # Get the underlying data and split on hyphens and slashes.\n        datestring = super(DateField, self).__get__(mediafile, None)\n        if isinstance(datestring, six.string_types):\n            datestring = re.sub(r'[Tt ].*$', '', six.text_type(datestring))\n            items = re.split('[-/]', six.text_type(datestring))\n        else:\n            items = []\n\n        # Ensure that we have exactly 3 components, possibly by\n        # truncating or padding.\n        items = items[:3]\n        if len(items) < 3:\n            items += [None] * (3 - len(items))\n\n        # Use year field if year is missing.\n        if not items[0] and hasattr(self, '_year_field'):\n            items[0] = self._year_field.__get__(mediafile)\n\n        # Convert each component to an integer if possible.\n        items_ = []\n        for item in items:\n            try:\n                items_.append(int(item))\n            except (TypeError, ValueError):\n                items_.append(None)\n        return items_"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the value of the field given a year month and day number.", "response": "def _set_date_tuple(self, mediafile, year, month=None, day=None):\n        \"\"\"Set the value of the field given a year, month, and day\n        number. Each number can be an integer or None to indicate an\n        unset component.\n        \"\"\"\n        if year is None:\n            self.__delete__(mediafile)\n            return\n\n        date = [u'{0:04d}'.format(int(year))]\n        if month:\n            date.append(u'{0:02d}'.format(int(month)))\n        if month and day:\n            date.append(u'{0:02d}'.format(int(day)))\n        date = map(six.text_type, date)\n        super(DateField, self).__set__(mediafile, u'-'.join(date))\n\n        if hasattr(self, '_year_field'):\n            self._year_field.__set__(mediafile, year)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the names of all writable properties that reflect metadata tags.", "response": "def fields(cls):\n        \"\"\"Get the names of all writable properties that reflect\n        metadata tags (i.e., those that are instances of\n        :class:`MediaField`).\n        \"\"\"\n        for property, descriptor in cls.__dict__.items():\n            if isinstance(descriptor, MediaField):\n                if isinstance(property, bytes):\n                    # On Python 2, class field names are bytes. This method\n                    # produces text strings.\n                    yield property.decode('utf8', 'ignore')\n                else:\n                    yield property"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a sort key for a field name that determines the order fields should be written in.", "response": "def _field_sort_name(cls, name):\n        \"\"\"Get a sort key for a field name that determines the order\n        fields should be written in.\n\n        Fields names are kept unchanged, unless they are instances of\n        :class:`DateItemField`, in which case `year`, `month`, and `day`\n        are replaced by `date0`, `date1`, and `date2`, respectively, to\n        make them appear in that order.\n        \"\"\"\n        if isinstance(cls.__dict__[name], DateItemField):\n            name = re.sub('year',  'date0', name)\n            name = re.sub('month', 'date1', name)\n            name = re.sub('day',   'date2', name)\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the names of all writable metadata fields sorted in the order that they should be written.", "response": "def sorted_fields(cls):\n        \"\"\"Get the names of all writable metadata fields, sorted in the\n        order that they should be written.\n\n        This is a lexicographic order, except for instances of\n        :class:`DateItemField`, which are sorted in year-month-day\n        order.\n        \"\"\"\n        for property in sorted(cls.fields(), key=cls._field_sort_name):\n            yield property"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a field to store custom tags.", "response": "def add_field(cls, name, descriptor):\n        \"\"\"Add a field to store custom tags.\n\n        :param name: the name of the property the field is accessed\n                     through. It must not already exist on this class.\n\n        :param descriptor: an instance of :class:`MediaField`.\n        \"\"\"\n        if not isinstance(descriptor, MediaField):\n            raise ValueError(\n                u'{0} must be an instance of MediaField'.format(descriptor))\n        if name in cls.__dict__:\n            raise ValueError(\n                u'property \"{0}\" already exists on MediaField'.format(name))\n        setattr(cls, name, descriptor)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, dict):\n        for field in self.sorted_fields():\n            if field in dict:\n                if dict[field] is None:\n                    delattr(self, field)\n                else:\n                    setattr(self, field, dict[field])", "response": "Updates all the fields of the MediaFile with the values from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the number of channels in the audio file.", "response": "def channels(self):\n        \"\"\"The number of channels in the audio (an int).\"\"\"\n        if hasattr(self.mgfile.info, 'channels'):\n            return self.mgfile.info.channels\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bitrate(self):\n        if hasattr(self.mgfile.info, 'bitrate') and self.mgfile.info.bitrate:\n            # Many formats provide it explicitly.\n            return self.mgfile.info.bitrate\n        else:\n            # Otherwise, we calculate bitrate from the file size. (This\n            # is the case for all of the lossless formats.)\n            if not self.length:\n                # Avoid division by zero if length is not available.\n                return 0\n            size = os.path.getsize(self.path)\n            return int(size * 8 / self.length)", "response": "The bitrate of the audio in the file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fromfits(infilename, hdu = 0, verbose = True):\n    \n    pixelarray, hdr = pyfits.getdata(infilename, hdu, header=True)\n    pixelarray = np.asarray(pixelarray).transpose()\n    \n    pixelarrayshape = pixelarray.shape\n    if verbose :\n        print \"FITS import shape : (%i, %i)\" % (pixelarrayshape[0], pixelarrayshape[1])\n        print \"FITS file BITPIX : %s\" % (hdr[\"BITPIX\"])\n        print \"Internal array type :\", pixelarray.dtype.name\n    \n    return pixelarray, hdr", "response": "Reads a FITS file and returns a 2D numpy array of the data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite a 2D numpy array to a FITS file.", "response": "def tofits(outfilename, pixelarray, hdr = None, verbose = True):\n    \"\"\"\n    Takes a 2D numpy array and write it into a FITS file.\n    If you specify a header (pyfits format, as returned by fromfits()) it will be used for the image.\n    You can give me boolean numpy arrays, I will convert them into 8 bit integers.\n    \"\"\"\n    pixelarrayshape = pixelarray.shape\n    if verbose :\n        print \"FITS export shape : (%i, %i)\" % (pixelarrayshape[0], pixelarrayshape[1])\n\n    if pixelarray.dtype.name == \"bool\":\n        pixelarray = np.cast[\"uint8\"](pixelarray)\n\n    if os.path.isfile(outfilename):\n        os.remove(outfilename)\n    \n    if hdr == None: # then a minimal header will be created \n        hdu = pyfits.PrimaryHDU(pixelarray.transpose())\n    else: # this if else is probably not needed but anyway ...\n        hdu = pyfits.PrimaryHDU(pixelarray.transpose(), hdr)\n\n    hdu.writeto(outfilename)\n    \n    if verbose :\n        print \"Wrote %s\" % outfilename"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef subsample(a): # this is more a generic function then a method ...\n    \"\"\"\n    # Ouuwww this is slow ...\n    outarray = np.zeros((a.shape[0]*2, a.shape[1]*2), dtype=np.float64)\n    for i in range(a.shape[0]):\n        for j in range(a.shape[1]):    \n            outarray[2*i,2*j] = a[i,j]\n            outarray[2*i+1,2*j] = a[i,j]\n            outarray[2*i,2*j+1] = a[i,j]\n            outarray[2*i+1,2*j+1] = a[i,j]\n    return outarray\n    \"\"\"\n    # much better :\n    newshape = (2*a.shape[0], 2*a.shape[1])\n    slices = [slice(0,old, float(old)/new) for old,new in zip(a.shape,newshape) ]\n    coordinates = np.mgrid[slices]\n    indices = coordinates.astype('i')   #choose the biggest smaller integer index\n    return a[tuple(indices)]", "response": "Subsample a array by 2x2"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwrapping around rebin that actually rebins 2 by 2", "response": "def rebin2x2(a):\n    \"\"\"\n    Wrapper around rebin that actually rebins 2 by 2\n    \"\"\"\n    inshape = np.array(a.shape)\n    if not (inshape % 2 == np.zeros(2)).all(): # Modulo check to see if size is even\n        raise RuntimeError, \"I want even image shapes !\"\n        \n    return rebin(a, inshape/2)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlabel the cosmicislands and return a list of dicts containing their positions.", "response": "def labelmask(self, verbose = None):\n        \"\"\"\n        Finds and labels the cosmic \"islands\" and returns a list of dicts containing their positions.\n        This is made on purpose for visualizations a la f2n.drawstarslist, but could be useful anyway.\n        \"\"\"\n        if verbose == None:\n            verbose = self.verbose\n        if verbose:\n            print \"Labeling mask pixels ...\"\n        # We morphologicaly dilate the mask to generously connect \"sparse\" cosmics :\n        #dilstruct = np.ones((5,5))\n        dilmask = ndimage.morphology.binary_dilation(self.mask, structure=dilstruct, iterations=1, mask=None, output=None, border_value=0, origin=0, brute_force=False)\n        # origin = 0 means center\n        (labels, n) = ndimage.measurements.label(dilmask)\n        #print \"Number of cosmic ray hits : %i\" % n\n        #tofits(labels, \"labels.fits\", verbose = False)\n        slicecouplelist = ndimage.measurements.find_objects(labels)\n        # Now we have a huge list of couples of numpy slice objects giving a frame around each object\n        # For plotting purposes, we want to transform this into the center of each object.\n        if len(slicecouplelist) != n:\n            # This never happened, but you never know ...\n            raise RuntimeError, \"Mega error in labelmask !\"\n        centers = [[(tup[0].start + tup[0].stop)/2.0, (tup[1].start + tup[1].stop)/2.0] for tup in slicecouplelist]\n        # We also want to know how many pixels where affected by each cosmic ray.\n        # Why ? Dunno... it's fun and available in scipy :-)\n        sizes = ndimage.measurements.sum(self.mask.ravel(), labels.ravel(), np.arange(1,n+1,1))\n        retdictlist = [{\"name\":\"%i\" % size, \"x\":center[0], \"y\":center[1]} for (size, center) in zip(sizes, centers)]\n        \n        if verbose:\n            print \"Labeling done\"\n\n        return retdictlist"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngive the mask, we replace the actual problematic pixels with the masked 5x5 median value. This mimics what is done in L.A.Cosmic, but it's a bit harder to do in python, as there is no readymade masked median. So for now we do a loop... Saturated stars, if calculated, are also masked : they are not \"cleaned\", but their pixels are not used for the interpolation. We will directly change self.cleanimage. Instead of using the self.mask, you can supply your own mask as argument. This might be useful to apply this cleaning function iteratively. But for the true L.A.Cosmic, we don't use this, i.e. we use the full mask at each iteration.", "response": "def clean(self, mask = None, verbose = None):\n        \"\"\"\n        Given the mask, we replace the actual problematic pixels with the masked 5x5 median value.\n        This mimics what is done in L.A.Cosmic, but it's a bit harder to do in python, as there is no\n        readymade masked median. So for now we do a loop...\n        Saturated stars, if calculated, are also masked : they are not \"cleaned\", but their pixels are not\n        used for the interpolation.\n        \n        We will directly change self.cleanimage. Instead of using the self.mask, you can supply your\n        own mask as argument. This might be useful to apply this cleaning function iteratively.\n        But for the true L.A.Cosmic, we don't use this, i.e. we use the full mask at each iteration.\n\n        \"\"\"\n        if verbose == None:\n            verbose = self.verbose\n        if mask == None:\n            mask = self.mask\n            \n        if verbose:\n            print \"Cleaning cosmic affected pixels ...\"\n        \n        # So... mask is a 2D array containing False and True, where True means \"here is a cosmic\"\n        # We want to loop through these cosmics one by one.\n        cosmicindices = np.argwhere(mask)\n        # This is a list of the indices of cosmic affected pixels.\n        #print cosmicindices\n        \n        # We put cosmic ray pixels to np.Inf to flag them :\n        self.cleanarray[mask] = np.Inf\n        \n        # Now we want to have a 2 pixel frame of Inf padding around our image.\n        w = self.cleanarray.shape[0]\n        h = self.cleanarray.shape[1]\n        padarray = np.zeros((w+4,h+4))+np.Inf\n        padarray[2:w+2,2:h+2] = self.cleanarray.copy() # that copy is important, we need 2 independent arrays\n        \n        # The medians will be evaluated in this padarray, skipping the np.Inf.\n        # Now in this copy called padarray, we also put the saturated stars to np.Inf, if available :\n        if self.satstars is not None:\n            padarray[2:w+2,2:h+2][self.satstars] = np.Inf\n            # Viva python, I tested this one, it works...\n        \n        # A loop through every cosmic pixel :\n        for cosmicpos in cosmicindices:\n            x = cosmicpos[0]\n            y = cosmicpos[1]\n            cutout = padarray[x:x+5, y:y+5].ravel() # remember the shift due to the padding !\n            #print cutout\n            # Now we have our 25 pixels, some of them are np.Inf, and we want to take the median\n            goodcutout = cutout[cutout != np.Inf]\n            #print np.alen(goodcutout)\n            \n            if np.alen(goodcutout) >= 25 :\n                # This never happened, but you never know ...\n                raise RuntimeError, \"Mega error in clean !\"\n            elif np.alen(goodcutout) > 0 :\n                replacementvalue = np.median(goodcutout)\n            else :    \n                # i.e. no good pixels : Shit, a huge cosmic, we will have to improvise ...\n                print \"OH NO, I HAVE A HUUUUUUUGE COSMIC !!!!!\"\n                replacementvalue = self.guessbackgroundlevel()\n            \n            # We update the cleanarray,\n            # but measure the medians in the padarray, so to not mix things up...\n            self.cleanarray[x, y] = replacementvalue\n            \n        # That's it.\n        if verbose:\n            print \"Cleaning done\"\n\n        # FYI, that's how the LACosmic cleaning looks in iraf :\n        \"\"\"\n        imarith(outmask,\"+\",finalsel,outmask)\n        imreplace(outmask,1,lower=1,upper=INDEF) # ok so outmask = 1 are the cosmics\n        imcalc(outmask,inputmask,\"(1.-10000.*im1)\",verb-)\n        imarith(oldoutput,\"*\",inputmask,inputmask)\n        median(inputmask,med5,5,5,zloreject=-9999,zhi=INDEF,verb-)\n        imarith(outmask,\"*\",med5,med5)\n        if (i>1) imdel(output)\n        imcalc(oldoutput//\",\"//outmask//\",\"//med5,output,\"(1.-im2)*im1+im3\",verb-)\n        \n        # =\n        \n        merging to full mask\n        inputmask = 1.0 - 10000.0 * finalsel # So this is 1.0, but cosmics are very negative\n        inputmask = oldoutput * inputmask # orig image, with very negative cosmics\n        med5 = median of inputmask, but rejecting these negative cosmics\n        # i dunno how to do this in python -> had to do the loop\n        med5 = finalsel * med5 # we keep only the cosmics of this median\n        # actual replacement :\n        output = (1.0 - outmask)*oldoutput + med5 # ok \n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds saturated stars in the image and store them in self. satstars.", "response": "def findsatstars(self, verbose = None):\n        \"\"\"\n        Uses the satlevel to find saturated stars (not cosmics !), and puts the result as a mask in self.satstars.\n        This can then be used to avoid these regions in cosmic detection and cleaning procedures.\n        Slow ...\n        \"\"\"\n        if verbose == None:\n            verbose = self.verbose\n        if verbose:\n                print \"Detecting saturated stars ...\"\n        # DETECTION\n        \n        satpixels = self.rawarray > self.satlevel # the candidate pixels\n        \n        # We build a smoothed version of the image to look for large stars and their support :\n        m5 = ndimage.filters.median_filter(self.rawarray, size=5, mode='mirror')\n        # We look where this is above half the satlevel\n        largestruct = m5 > (self.satlevel/2.0)\n        # The rough locations of saturated stars are now :\n        satstarscenters = np.logical_and(largestruct, satpixels)\n        \n        if verbose:\n                print \"Building mask of saturated stars ...\"\n        \n        # BUILDING THE MASK\n        # The subtility is that we want to include all saturated pixels connected to these saturated stars...\n        # I haven't found a better solution then the double loop\n        \n        # We dilate the satpixels alone, to ensure connectivity in glitchy regions and to add a safety margin around them.\n        #dilstruct = np.array([[0,1,0], [1,1,1], [0,1,0]])\n        \n        dilsatpixels = ndimage.morphology.binary_dilation(satpixels, structure=dilstruct, iterations=2, mask=None, output=None, border_value=0, origin=0, brute_force=False)\n        # It turns out it's better to think large and do 2 iterations...\n        \n        \n        # We label these :\n        (dilsatlabels, nsat) = ndimage.measurements.label(dilsatpixels)\n        #tofits(dilsatlabels, \"test.fits\")\n        \n        if verbose:\n                print \"We have %i saturated stars.\" % nsat\n        \n        # The ouput, False for now :\n        outmask = np.zeros(self.rawarray.shape)\n        \n        for i in range(1,nsat+1): # we go through the islands of saturated pixels\n            thisisland = dilsatlabels == i # gives us a boolean array\n            # Does this intersect with satstarscenters ?\n            overlap = np.logical_and(thisisland, satstarscenters)\n            if np.sum(overlap) > 0:\n                outmask = np.logical_or(outmask, thisisland) # we add thisisland to the mask\n            \n        self.satstars = np.cast['bool'](outmask)\n        \n        if verbose:\n                print \"Mask of saturated stars done\""}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getsatstars(self, verbose = None):\n        if verbose == None:\n            verbose = self.verbose\n        if not self.satlevel > 0:\n            raise RuntimeError, \"Cannot determine satstars : you gave satlevel <= 0 !\" \n        if self.satstars == None:\n            self.findsatstars(verbose = verbose)\n        return self.satstars", "response": "Returns the saturated stars for this instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef guessbackgroundlevel(self):\n        if self.backgroundlevel == None:\n            self.backgroundlevel = np.median(self.rawarray.ravel())\n        return self.backgroundlevel", "response": "Guesses the background level of the current instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lacosmiciteration(self, verbose = None):\n        \n        if verbose == None:\n            verbose = self.verbose\n\n        if verbose:\n            print \"Convolving image with Laplacian kernel ...\"\n        \n        # We subsample, convolve, clip negative values, and rebin to original size\n        subsam = subsample(self.cleanarray)\n        conved = signal.convolve2d(subsam, laplkernel, mode=\"same\", boundary=\"symm\")\n        cliped = conved.clip(min=0.0)\n        #cliped = np.abs(conved) # unfortunately this does not work to find holes as well ...\n        lplus = rebin2x2(cliped)\n        \n        if verbose:\n            print \"Creating noise model ...\"\n            \n        # We build a custom noise map, so to compare the laplacian to\n        m5 = ndimage.filters.median_filter(self.cleanarray, size=5, mode='mirror')\n        # We keep this m5, as I will use it later for the interpolation.\n        m5clipped = m5.clip(min=0.00001) # As we will take the sqrt\n        noise = (1.0/self.gain) * np.sqrt(self.gain*m5clipped + self.readnoise*self.readnoise)\n\n        if verbose:\n           print \"Calculating Laplacian signal to noise ratio ...\"\n\n        # Laplacian signal to noise ratio :\n        s = lplus / (2.0 * noise) # the 2.0 is from the 2x2 subsampling\n        # This s is called sigmap in the original lacosmic.cl\n        \n        # We remove the large structures (s prime) :\n        sp = s - ndimage.filters.median_filter(s, size=5, mode='mirror')\n         \n        if verbose:\n            print \"Selecting candidate cosmic rays ...\"\n            \n         # Candidate cosmic rays (this will include stars + HII regions)\n        candidates = sp > self.sigclip    \n        nbcandidates = np.sum(candidates)\n        \n        if verbose:\n            print \"  %5i candidate pixels\" % nbcandidates\n         \n         # At this stage we use the saturated stars to mask the candidates, if available :\n        if self.satstars is not None:\n            if verbose:\n                 print \"Masking saturated stars ...\"\n                 candidates = np.logical_and(np.logical_not(self.satstars), candidates)\n                 nbcandidates = np.sum(candidates)\n        \n            if verbose:\n                print \"  %5i candidate pixels not part of saturated stars\" % nbcandidates\n         \n        if verbose:\n            print \"Building fine structure image ...\"\n            \n         # We build the fine structure image :\n        m3 = ndimage.filters.median_filter(self.cleanarray, size=3, mode='mirror')\n        m37 = ndimage.filters.median_filter(m3, size=7, mode='mirror')\n        f = m3 - m37\n        # In the article that's it, but in lacosmic.cl f is divided by the noise...\n        # Ok I understand why, it depends on if you use sp/f or L+/f as criterion.\n        # There are some differences between the article and the iraf implementation.\n        # So I will stick to the iraf implementation.\n        f = f / noise\n        f = f.clip(min=0.01) # as we will divide by f. like in the iraf version.\n        \n        if verbose:\n            print \"Removing suspected compact bright objects ...\"\n            \n        # Now we have our better selection of cosmics :\n        cosmics = np.logical_and(candidates, sp/f > self.objlim)\n        # Note the sp/f and not lplus/f ... due to the f = f/noise above.\n        \n        nbcosmics = np.sum(cosmics)\n        \n        if verbose:\n            print \"  %5i remaining candidate pixels\" % nbcosmics\n        \n        # What follows is a special treatment for neighbors, with more relaxed constains.\n        \n        if verbose:\n            print \"Finding neighboring pixels affected by cosmic rays ...\"\n            \n        # We grow these cosmics a first time to determine the immediate neighborhod  :\n        growcosmics = np.cast['bool'](signal.convolve2d(np.cast['float32'](cosmics), growkernel, mode=\"same\", boundary=\"symm\"))\n        \n        # From this grown set, we keep those that have sp > sigmalim\n        # so obviously not requiring sp/f > objlim, otherwise it would be pointless\n        growcosmics = np.logical_and(sp > self.sigclip, growcosmics)\n        \n        # Now we repeat this procedure, but lower the detection limit to sigmalimlow :\n            \n        finalsel = np.cast['bool'](signal.convolve2d(np.cast['float32'](growcosmics), growkernel, mode=\"same\", boundary=\"symm\"))\n        finalsel = np.logical_and(sp > self.sigcliplow, finalsel)\n        \n        # Again, we have to kick out pixels on saturated stars :\n        if self.satstars is not None:\n            if verbose:\n                print \"Masking saturated stars ...\"\n            finalsel = np.logical_and(np.logical_not(self.satstars), finalsel)\n             \n        nbfinal = np.sum(finalsel)\n        \n        if verbose:\n            print \"  %5i pixels detected as cosmics\" % nbfinal\n        \n        # Now the replacement of the cosmics...\n        # we outsource this to the function clean(), as for some purposes the cleaning might not even be needed.\n        # Easy way without masking would be :\n        #self.cleanarray[finalsel] = m5[finalsel]\n        \n        # We find how many cosmics are not yet known :\n        newmask = np.logical_and(np.logical_not(self.mask), finalsel)\n        nbnew = np.sum(newmask)\n        \n        # We update the mask with the cosmics we have found :\n        self.mask = np.logical_or(self.mask, finalsel)\n    \n        # We return\n        # (used by function lacosmic)\n        \n        return {\"niter\":nbfinal, \"nnew\":nbnew, \"itermask\":finalsel, \"newmask\":newmask}", "response": "This function performs one iteration of the L. A. Cosmic algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun the cosmic algorithm.", "response": "def run(self, maxiter = 4, verbose = False):\n        \"\"\"\n        Full artillery :-)\n            - Find saturated stars\n            - Run maxiter L.A.Cosmic iterations (stops if no more cosmics are found)\n    \n        Stops if no cosmics are found or if maxiter is reached.\n        \"\"\"\n            \n        if self.satlevel > 0 and self.satstars == None:\n            self.findsatstars(verbose=True)\n            \n        print \"Starting %i L.A.Cosmic iterations ...\" % maxiter\n        for i in range(1, maxiter+1):\n            print \"Iteration %i\" % i\n            \n            iterres = self.lacosmiciteration(verbose=verbose)\n            print \"%i cosmic pixels (%i new)\" % (iterres[\"niter\"], iterres[\"nnew\"])\n            \n            #self.clean(mask = iterres[\"mask\"]) # No, we want clean to operate on really clean pixels only !\n            # Thus we always apply it on the full mask, as lacosmic does :\n            self.clean(verbose=verbose)\n            # But note that for huge cosmics, one might want to revise this.\n            # Thats why I added a feature to skip saturated stars !\n            \n            if iterres[\"niter\"] == 0:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch your Django project root for Miragefile. py and Miragefile. py files.", "response": "def search_project_root():\n        \"\"\"\n        Search your Django project root.\n\n        returns:\n            - path:string  Django project root path\n        \"\"\"\n\n        while True:\n\n            current = os.getcwd()\n\n            if pathlib.Path(\"Miragefile.py\").is_file() or pathlib.Path(\"Miragefile\").is_file():\n                return current\n            elif os.getcwd() == \"/\":\n                raise FileNotFoundError\n            else:\n                os.chdir(\"../\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch your Django application root for a specific locale.", "response": "def search_app_root():\n        \"\"\"\n        Search your Django application root\n\n        returns:\n            - (String) Django application root path\n        \"\"\"\n        while True:\n\n            current = os.getcwd()\n\n            if pathlib.Path(\"apps.py\").is_file():\n                return current\n            elif pathlib.Path.cwd() == \"/\":\n                raise FileNotFoundError\n            else:\n                os.chdir(\"../\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\njudging where current working directory is in Django application or not.", "response": "def in_app() -> bool:\n        \"\"\"\n        Judge where current working directory is in Django application or not.\n\n        returns:\n            - (Bool) cwd is in app dir returns True\n        \"\"\"\n        try:\n            MirageEnvironment.set_import_root()\n            import apps\n            if os.path.isfile(\"apps.py\"):\n                return True\n            else:\n                return False\n        except ImportError:\n            return False\n        except:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling update_cached_fields() for each object passed in as argument.", "response": "def update_cached_fields(*args):\n    \"\"\"\n    Calls update_cached_fields() for each object passed in as argument.\n    Supports also iterable objects by checking __iter__ attribute.\n    :param args: List of objects\n    :return: None\n    \"\"\"\n    for a in args:\n        if a is not None:\n            if hasattr(a, '__iter__'):\n                for e in a:\n                    e.update_cached_fields()\n            else:\n                a.update_cached_fields()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_cached_fields_pre_save(self, update_fields: list):\n        if self.id and update_fields is None:\n            self.update_cached_fields(commit=False, exceptions=False)", "response": "Call on pre_save signal for objects to automatically refresh on save."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(name):\n    # type: (str) -> None\n    \"\"\" Start working on a new hotfix.\n\n    This will create a new branch off master called hotfix/<name>.\n\n    Args:\n        name (str):\n            The name of the new feature.\n    \"\"\"\n    hotfix_branch = 'hotfix/' + common.to_branch_name(name)\n    master = conf.get('git.master_branch', 'master')\n\n    common.assert_on_branch(master)\n    common.git_checkout(hotfix_branch, create=True)", "response": "Start working on a new hotfix."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmerges current feature into develop.", "response": "def finish():\n    # type: () -> None\n    \"\"\" Merge current feature into develop. \"\"\"\n    pretend = context.get('pretend', False)\n\n    if not pretend and (git.staged() or git.unstaged()):\n        log.err(\n            \"You have uncommitted changes in your repo!\\n\"\n            \"You need to stash them before you merge the hotfix branch\"\n        )\n        sys.exit(1)\n\n    develop = conf.get('git.devel_branch', 'develop')\n    master = conf.get('git.master_branch', 'master')\n    branch = git.current_branch(refresh=True)\n\n    common.assert_branch_type('hotfix')\n\n    # Merge hotfix into master\n    common.git_checkout(master)\n    common.git_pull(master)\n    common.git_merge(master, branch.name)\n\n    # Merge hotfix into develop\n    common.git_checkout(develop)\n    common.git_pull(develop)\n    common.git_merge(develop, branch.name)\n\n    # Cleanup\n    common.git_branch_delete(branch.name)\n    common.git_prune()\n\n    common.git_checkout(master)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun the shell command", "response": "def run(self):\n        \"\"\"\n        Run the shell command\n\n        Returns:\n            ShellCommand: return this ShellCommand instance for chaining\n        \"\"\"\n        if not self.block:\n            self.output = []\n            self.error = []\n            self.thread = threading.Thread(target=self.run_non_blocking)\n            self.thread.start()\n        else:\n            self.__create_process()\n            self.process.wait()\n            if self._stdout is not None:\n                self.output = self.process.stdout.read().decode(\"utf-8\")\n            if self._stderr is not None:\n                self.error = self.process.stderr.read().decode(\"utf-8\")\n            self.return_code = self.process.returncode\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending text to stdin. Can only be used on non blocking commands", "response": "def send(self, value):\n        \"\"\"\n        Send text to stdin. Can only be used on non blocking commands\n\n        Args:\n            value (str): the text to write on stdin\n        Raises:\n            TypeError: If command is blocking\n        Returns:\n            ShellCommand: return this ShellCommand instance for chaining\n        \"\"\"\n        if not self.block and self._stdin is not None:\n            self.writer.write(\"{}\\n\".format(value))\n            return self\n        else:\n            raise TypeError(NON_BLOCKING_ERROR_MESSAGE)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef poll_output(self):\n        if self.block:\n            return self.output\n\n        new_list = self.output[self.old_output_size:]\n        self.old_output_size += len(new_list)\n        return new_list", "response": "Append lines from stdout to self. output."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nappending lines from stderr to self. error.", "response": "def poll_error(self):\n        \"\"\"\n        Append lines from stderr to self.errors.\n\n        Returns:\n            list: The lines added since last call\n        \"\"\"\n        if self.block:\n            return self.error\n\n        new_list = self.error[self.old_error_size:]\n        self.old_error_size += len(new_list)\n        return new_list"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nkill the current non blocking command", "response": "def kill(self):\n        \"\"\"\n        Kill the current non blocking command\n\n        Raises:\n            TypeError: If command is blocking\n        \"\"\"\n        if self.block:\n            raise TypeError(NON_BLOCKING_ERROR_MESSAGE)\n\n        try:\n            self.process.kill()\n        except ProcessLookupError as exc:\n            self.logger.debug(exc)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef wait_for(self, pattern, timeout=None):\n        should_continue = True\n\n        if self.block:\n            raise TypeError(NON_BLOCKING_ERROR_MESSAGE)\n\n        def stop(signum, frame):  # pylint: disable=W0613\n            nonlocal should_continue\n            if should_continue:\n                raise TimeoutError()\n\n        if timeout:\n            signal.signal(signal.SIGALRM, stop)\n            signal.alarm(timeout)\n\n        while should_continue:\n            output = self.poll_output() + self.poll_error()\n            filtered = [line for line in output if re.match(pattern, line)]\n            if filtered:\n                should_continue = False", "response": "Block until a pattern is found in stdout and stderr."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the command is currently running", "response": "def is_running(self):\n        \"\"\"\n        Check if the command is currently running\n\n        Returns:\n            bool: True if running, else False\n        \"\"\"\n        if self.block:\n            return False\n\n        return self.thread.is_alive() or self.process.poll() is None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nblock and print the output of the command", "response": "def print_live_output(self):\n        '''\n        Block and print the output of the command\n\n        Raises:\n            TypeError: If command is blocking\n        '''\n        if self.block:\n            raise TypeError(NON_BLOCKING_ERROR_MESSAGE)\n        else:\n            while self.thread.is_alive() or self.old_output_size < len(self.output) or self.old_error_size < len(self.error):\n                if self._stdout is not None and len(self.output) > self.old_output_size:\n                    while self.old_output_size < len(self.output):\n                        self.logger.info(self.output[self.old_output_size])\n                        self.old_output_size += 1\n\n                if self._stderr is not None and len(self.error) > self.old_error_size:\n                    while self.old_error_size < len(self.error):\n                        self.logger.error(self.error[self.old_error_size])\n                        self.old_error_size += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns a command in the current working directory.", "response": "def run(self, command, block=True, cwd=None, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE):\n        \"\"\"\n        Create an instance of :class:`~ShellCommand` and run it\n\n        Args:\n            command (str): :class:`~ShellCommand`\n            block (bool): See :class:`~ShellCommand`\n            cwd (str): Override the runner cwd. Useb by the :class:`~ShellCommand` instance\n        \"\"\"\n        if cwd is None:\n            cwd = self.cwd\n\n        return ShellCommand(command=command, logger=self.logger, block=block, cwd=cwd, stdin=stdin, stdout=stdout, stderr=stderr).run()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bces(x1, x2, x1err=[], x2err=[], cerr=[], logify=True, model='yx', \\\n         bootstrap=5000, verbose='normal', full_output=True):\n    \"\"\"\n    Bivariate, Correlated Errors and intrinsic Scatter (BCES)\n    translated from the FORTRAN code by Christina Bird and Matthew Bershady\n    (Akritas & Bershady, 1996)\n\n    Linear regression in the presence of heteroscedastic errors on both\n    variables and intrinsic scatter\n\n    Parameters\n    ----------\n      x1        : array of floats\n                  Independent variable, or observable\n      x2        : array of floats\n                  Dependent variable\n      x1err     : array of floats (optional)\n                  Uncertainties on the independent variable\n      x2err     : array of floats (optional)\n                  Uncertainties on the dependent variable\n      cerr      : array of floats (optional)\n                  Covariances of the uncertainties in the dependent and\n                  independent variables\n      logify    : bool (default True)\n                  Whether to take the log of the measurements in order to\n                  estimate the best-fit power law instead of linear relation\n      model     : {'yx', 'xy', 'bi', 'orth'}\n                  BCES model with which to calculate regression. See Notes\n                  below for details.\n      bootstrap : False or int (default 5000)\n                  get the errors from bootstrap resampling instead of the\n                  analytical prescription? if bootstrap is an int, it is the\n                  number of bootstrap resamplings\n      verbose   : str (default 'normal')\n                  Verbose level. Options are {'quiet', 'normal', 'debug'}\n      full_output : bool (default True)\n                  If True, return also the covariance between the\n                  normalization and slope of the regression.\n\n    Returns\n    -------\n      a         : tuple of length 2\n                  Best-fit normalization and its uncertainty (a, da)\n      b         : tuple of length 2\n                  Best-fit slope and its uncertainty (b, db)\n\n    Optional outputs\n    ----------------\n      cov_ab    : 2x2 array of floats\n                  covariance between a and b. Returned if full_output is set to\n                  True.\n\n    Notes\n    -----\n      If verbose is normal or debug, the results from all the BCES models will\n      be printed (still, only the one selected in *model* will be returned).\n\n      the *model* parameter:\n        -'yx' stands for BCES(Y|X)\n        -'xy' stands for BCES(X|Y)\n        -'bi' stands for BCES Bisector\n        -'orth' stands for BCES Orthogonal\n\n    \"\"\"\n\n    def _bess_bootstrap(npts, x1, x2, x1err, x2err, cerr,nsim):\n        ##added by Gerrit, July 2014\n        ##Unfortunately I needed a copy of the _bess function for bootstrapping.\n        #Would be nicer if those two could be combined\n        \"\"\"\n        Do the entire regression calculation for 4 slopes:\n        OLS(Y|X), OLS(X|Y), bisector, orthogonal\n        \"\"\"\n        #calculate sigma's for datapoints using length of confidence intervals\n        sig11var = numpy.sum(x1err ** 2,axis=1,keepdims=True) / npts\n        sig22var = numpy.sum(x2err ** 2,axis=1,keepdims=True) / npts\n        sig12var = numpy.sum(cerr,axis=1,keepdims=True) / npts\n        \n        # calculate means and variances\n        x1av = numpy.mean(x1,axis=1,keepdims=True)\n        x1var = x1.var(axis=1,keepdims=True)\n        x2av = numpy.mean(x2,axis=1,keepdims=True)\n        x2var = x2.var(axis=1,keepdims=True)\n        covar_x1x2 = numpy.mean((x1-numpy.mean(x1,axis=1,keepdims=True)) * \\\n                             (x2-numpy.mean(x2,axis=1,keepdims=True)),\n                             axis=1,keepdims=True)\n        \n        # compute the regression slopes for OLS(X2|X1), OLS(X1|X2), \n        # bisector and orthogonal\n        if model == 'yx':\n            modelint = 1\n        else:\n            modelint = 4\n        b = numpy.zeros((modelint,nsim))\n        b[0] = ((covar_x1x2 - sig12var) / (x1var - sig11var)).flatten()\n        if model != 'yx':\n            b[1] = ((x2var - sig22var) / (covar_x1x2 - sig12var)).flatten()\n            b[2] = ((b[0] * b[1] - 1 + numpy.sqrt((1 + b[0] ** 2) * \\\n                   (1 + b[1] ** 2))) / (b[0] + b[1])).flatten()\n            b[3] = 0.5 * ((b[1] - 1 / b[0]) + numpy.sign(covar_x1x2).flatten()* \\\n                   numpy.sqrt(4 + (b[1] - 1 / b[0]) ** 2))\n        \n        # compute intercepts for above 4 cases:\n        a = x2av.flatten() - b * x1av.flatten()\n        \n        # set up variables to calculate standard deviations of slope and \n        # intercept\n        xi = []\n        xi.append(((x1 - x1av) * (x2 - b[0].reshape(nsim,1) * x1 - \\\n                                  a[0].reshape(nsim,1)) + \\\n                   b[0].reshape(nsim,1) * x1err ** 2) / \\\n                  (x1var - sig11var))\n        if model != 'yx':\n            xi.append(((x2 - x2av) * (x2 - b[1].reshape(nsim,1) * x1 - \\\n                                      a[1].reshape(nsim,1)) + x2err ** 2) / \\\n                      covar_x1x2)\n            xi.append((xi[0] * (1 + b[1].reshape(nsim,1) ** 2) + \\\n                       xi[1] * (1 + b[0].reshape(nsim,1) ** 2)) / \\\n                      ((b[0].reshape(nsim,1) + \\\n                       b[1].reshape(nsim,1)) * \\\n                       numpy.sqrt((1 + b[0].reshape(nsim,1) ** 2) * \\\n                               (1 + b[1].reshape(nsim,1) ** 2))))\n            xi.append((xi[0] / b[0].reshape(nsim,1) ** 2 + xi[1]) * \\\n                      b[3].reshape(nsim,1) / \\\n                      numpy.sqrt(4 + (b[1].reshape(nsim,1) - \\\n                              1 / b[0].reshape(nsim,1)) ** 2))\n        zeta = []\n        for i in xrange(modelint):\n            zeta.append(x2 - b[i].reshape(nsim,1) * x1 - x1av * xi[i])\n        \n        # calculate  variance for all a and b\n        bvar = numpy.zeros((4,nsim))\n        avar = numpy.zeros((4,nsim))\n        for i in xrange(modelint):\n            bvar[i] = xi[i].var(axis=1,keepdims=False)/ npts\n            avar[i] = zeta[i].var(axis=1,keepdims=False) / npts\n        return a, b, avar, bvar, xi, zeta\n\n    def _bess(npts, x1, x2, x1err, x2err, cerr):\n        \"\"\"\n        Do the entire regression calculation for 4 slopes:\n          OLS(Y|X), OLS(X|Y), bisector, orthogonal\n        \"\"\"\n        # calculate sigma's for datapoints using length of confidence\n        # intervals\n        sig11var = sum(x1err ** 2) / npts\n        sig22var = sum(x2err ** 2) / npts\n        sig12var = sum(cerr) / npts\n        # calculate means and variances\n        x1av = numpy.average(x1)\n        x1var = numpy.std(x1) ** 2\n        x2av = numpy.average(x2)\n        x2var = numpy.std(x2) ** 2\n        covar_x1x2 = sum((x1 - x1av) * (x2 - x2av)) / npts\n        # compute the regression slopes for OLS(X2|X1), OLS(X1|X2), \n        # bisector and orthogonal\n        b = numpy.zeros(4)\n        b[0] = (covar_x1x2 - sig12var) / (x1var - sig11var)\n        b[1] = (x2var - sig22var) / (covar_x1x2 - sig12var)\n        b[2] = (b[0] * b[1] - 1 + numpy.sqrt((1 + b[0] ** 2) * \\\n               (1 + b[1] ** 2))) / (b[0] + b[1])\n        b[3] = 0.5 * ((b[1] - 1 / b[0]) + numpy.sign(covar_x1x2) * \\\n               numpy.sqrt(4 + (b[1] - 1 / b[0]) ** 2))\n        # compute intercepts for above 4 cases:\n        a = x2av - b * x1av\n        # set up variables to calculate standard deviations of slope\n        # and intercept\n        xi = []\n        xi.append(((x1 - x1av) * \\\n                   (x2 - b[0] * x1 - a[0]) + b[0] * x1err ** 2) / \\\n                  (x1var - sig11var))\n        xi.append(((x2 - x2av) * (x2 - b[1] * x1 - a[1]) + x2err ** 2) / \\\n                  covar_x1x2)\n        xi.append((xi[0] * (1 + b[1] ** 2) + xi[1] * (1 + b[0] ** 2)) / \\\n                  ((b[0] + b[1]) * \\\n                   numpy.sqrt((1 + b[0] ** 2) * (1 + b[1] ** 2))))\n        xi.append((xi[0] / b[0] ** 2 + xi[1]) * b[3] / \\\n                  numpy.sqrt(4 + (b[1] - 1 / b[0]) ** 2))\n        zeta = []\n        for i in xrange(4):\n            zeta.append(x2 - b[i]*x1 - x1av*xi[i])\n        # calculate  variance for all a and b\n        bvar = numpy.zeros(4)\n        avar = numpy.zeros(4)\n        for i in xrange(4):\n            bvar[i] = numpy.std(xi[i]) ** 2 / npts\n            avar[i] = numpy.std(zeta[i]) ** 2 / npts\n        return a, b, avar, bvar, xi, zeta\n\n    def _bootspbec(npts, x, y, xerr, yerr, cerr):\n        \"\"\"\n        Bootstrap samples\n        \"\"\"\n        j = numpy.random.randint(npts, size = npts)\n        xboot = x[j]\n        xerrboot = xerr[j]\n        yboot = y[j]\n        yerrboot = yerr[j]\n        cerrboot = cerr[j]\n        return xboot, yboot, xerrboot, yerrboot, cerrboot\n\n    # ----  Main routine starts here  ---- #\n    # convert to numpy arrays just in case\n    x1 = numpy.array(x1)\n    x2 = numpy.array(x2)\n    x1err = numpy.array(x1err)\n    x2err = numpy.array(x2err)\n    if logify:\n        x1, x2, x1err, x2err = to_log(x1, x2, x1err, x2err)\n    cerr = numpy.array(cerr)\n    models = [['yx', 'xy', 'bi', 'orth'],\n              ['BCES(Y|X)', 'BCES(X|Y)', 'BCES Bisector', 'BCES Orthogonal']]\n    # which to return?\n    j = models[0].index(model)\n    npts = len(x1)\n    # are the errors defined?\n    if len(x1err) == 0:\n        x1err = numpy.zeros(npts)\n    if len(x2err) == 0:\n        x2err = numpy.zeros(npts)\n    if len(cerr) == 0:\n        cerr = numpy.zeros(npts)\n    if verbose == 'debug':\n        print 'x1 =', x1\n        print 'x1err =', x1err\n        print 'x2 =', x2\n        print 'x2err =', x2err\n        print 'cerr =', cerr\n        print '\\n ** Returning values for', models[1][j], '**'\n        if bootstrap is not False:\n            print '    with errors from %d bootstrap resamplings' %bootstrap\n        print ''\n\n    # calculate nominal fits\n    bessresults = _bess(npts, x1, x2, x1err, x2err, cerr)\n    (a, b, avar, bvar, xi, zeta) = bessresults\n    # covariance between normalization and slope\n    if full_output:\n        covar_ab = numpy.cov(xi[j], zeta[j])\n\n    if bootstrap is not False:\n        # make bootstrap simulated datasets, and compute averages and\n        # standard deviations of regression coefficients\n        asum = numpy.zeros(4)\n        assum = numpy.zeros(4)\n        bsum = numpy.zeros(4)\n        bssum = numpy.zeros(4)\n        sda = numpy.zeros(4)\n        sdb = numpy.zeros(4)\n        for i in xrange(bootstrap):\n            samples = _bootspbec(npts, x1, x2, x1err, x2err, cerr)\n            (x1sim, x2sim, x1errsim, x2errsim, cerrsim) = samples\n            besssim = _bess(npts, x1sim, x2sim, x1errsim, x2errsim, cerrsim)\n            (asim, bsim, avarsim, bvarsim, xi, zeta) = besssim\n            asum += asim\n            assum += asim ** 2\n            bsum += bsim\n            bssum += bsim ** 2\n\n        aavg = asum / bootstrap\n        bavg = bsum / bootstrap\n        for i in range(4):\n            sdtest = assum[i] - bootstrap * aavg[i] ** 2\n            if sdtest > 0:\n                sda[i] = numpy.sqrt(sdtest / (bootstrap - 1))\n            sdtest = bssum[i] - bootstrap * bavg[i] ** 2\n            if sdtest > 0:\n                sdb[i] = numpy.sqrt(sdtest / (bootstrap - 1))\n\n    if verbose in ('normal', 'debug'):\n        print '%s   B          err(B)' %('Fit'.ljust(19)),\n        print '         A          err(A)'\n        for i in range(4):\n            print '%s  %9.2e +/- %8.2e    %10.3e +/- %9.3e' \\\n                  %(models[1][i].ljust(16), b[i], \n                    numpy.sqrt(bvar[i]), a[i], numpy.sqrt(avar[i]))\n            if bootstrap is not False:\n                print '%s  %9.2e +/- %8.2e    %10.3e +/- %9.3e' \\\n                      %('bootstrap'.ljust(16), bavg[i],\n                        sdb[i], aavg[i], sda[i])\n            print ''\n        if verbose == 'debug':\n            print 'cov[%s] =' %models[model]\n            print covar_ab\n\n    if bootstrap is not False:\n        if full_output:\n            return (a[j], sda[j]), (b[j], sdb[j]), covar_ab\n        else:\n            return (a[j], sda[j]), (b[j], sdb[j])\n    if full_output:\n        out = ((a[j], numpy.sqrt(avar[j])),\n               (b[j], numpy.sqrt(bvar[j])),\n               covar_ab)\n    else:\n        out = ((a[j], numpy.sqrt(avar[j])),\n               (b[j], numpy.sqrt(bvar[j])))\n    return out", "response": "Returns the Bivariate Correlated Errors and intrinsic scattering of two uncertainties."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nscatter function for the BCES best fit.", "response": "def scatter(slope, zero, x1, x2, x1err=[], x2err=[]):\n    \"\"\"\n    Used mainly to measure scatter for the BCES best-fit\n\n    \"\"\"\n    n = len(x1)\n    x2pred = zero + slope * x1\n    s = sum((x2 - x2pred) ** 2) / (n - 1)\n    if len(x2err) == n:\n        s_obs = sum((x2err / x2) ** 2) / n\n        s0 = s - s_obs\n    print numpy.sqrt(s), numpy.sqrt(s_obs), numpy.sqrt(s0)\n    return numpy.sqrt(s0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef kelly(x1, x2, x1err=[], x2err=[], cerr=[], logify=True,\n          miniter=5000, maxiter=1e5, metro=True,\n          silent=True):\n    \"\"\"\n    Python wrapper for the linear regression MCMC of Kelly (2007).\n    Requires pidly (http://astronomy.sussex.ac.uk/~anthonys/pidly/) and\n    an IDL license.\n\n    Parameters\n    ----------\n      x1        : array of floats\n                  Independent variable, or observable\n      x2        : array of floats\n                  Dependent variable\n      x1err     : array of floats (optional)\n                  Uncertainties on the independent variable\n      x2err     : array of floats (optional)\n                  Uncertainties on the dependent variable\n      cerr      : array of floats (optional)\n                  Covariances of the uncertainties in the dependent and\n                  independent variables\n    \"\"\"\n    import pidly\n    \n    n = len(x1)\n    if len(x2) != n:\n        raise ValueError('x1 and x2 must have same length')\n    if len(x1err) == 0:\n        x1err = numpy.zeros(n)\n    if len(x2err) == 0:\n        x2err = numpy.zeros(n)\n    if logify:\n        x1, x2, x1err, x2err = to_log(x1, x2, x1err, x2err)\n    idl = pidly.IDL()\n    idl('x1 = %s' %list(x1))\n    idl('x2 = %s' %list(x2))\n    cmd = 'linmix_err, x1, x2, fit'\n    if len(x1err) == n:\n        idl('x1err = %s' %list(x1err))\n        cmd += ', xsig=x1err'\n    if len(x2err) == n:\n        idl('x2err = %s' %list(x2err))\n        cmd += ', ysig=x2err'\n    if len(cerr) == n:\n        idl('cerr = %s' %list(cerr))\n        cmd += ', xycov=cerr'\n    cmd += ', miniter=%d, maxiter=%d' %(miniter, maxiter)\n    if metro:\n        cmd += ', /metro'\n    if silent:\n        cmd += ', /silent'\n    idl(cmd)\n    alpha = idl.ev('fit.alpha')\n    beta = idl.ev('fit.beta')\n    sigma = numpy.sqrt(idl.ev('fit.sigsqr'))\n    return alpha, beta, sigma", "response": "Returns a new Kelly model with linear regression."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nuses emcee to find the best-fit linear relation or power law accounting for measurement uncertainties and intrinsic scatter Parameters ---------- x1 : array of floats Independent variable, or observable x2 : array of floats Dependent variable x1err : array of floats (optional) Uncertainties on the independent variable x2err : array of floats (optional) Uncertainties on the dependent variable po : tuple of 3 floats (optional) Initial guesses for zero point, slope, and intrinsic scatter. Results are not very sensitive to these values so they shouldn't matter a lot. logify : bool (default True) Whether to take the log of the measurements in order to estimate the best-fit power law instead of linear relation nsteps : int (default 5000) Number of steps each walker should take in the MCMC nwalkers : int (default 100) Number of MCMC walkers nburn : int (default 500) Number of samples to discard to give the MCMC enough time to converge. output : list of ints or 'full' (default 'full') If 'full', then return the full samples (except for burn-in section) for each parameter. Otherwise, each float corresponds to a percentile that will be returned for each parameter. Returns ------- See *output* argument above for return options.", "response": "def mcmc(x1, x2, x1err=[], x2err=[], po=(1,1,0.5), logify=True,\n         nsteps=5000, nwalkers=100, nburn=500, output='full'):\n    \"\"\"\n    Use emcee to find the best-fit linear relation or power law\n    accounting for measurement uncertainties and intrinsic scatter\n\n    Parameters\n    ----------\n      x1        : array of floats\n                  Independent variable, or observable\n      x2        : array of floats\n                  Dependent variable\n      x1err     : array of floats (optional)\n                  Uncertainties on the independent variable\n      x2err     : array of floats (optional)\n                  Uncertainties on the dependent variable\n      po        : tuple of 3 floats (optional)\n                  Initial guesses for zero point, slope, and intrinsic\n                  scatter. Results are not very sensitive to these values\n                  so they shouldn't matter a lot.\n      logify    : bool (default True)\n                  Whether to take the log of the measurements in order to\n                  estimate the best-fit power law instead of linear relation\n      nsteps    : int (default 5000)\n                  Number of steps each walker should take in the MCMC\n      nwalkers  : int (default 100)\n                  Number of MCMC walkers\n      nburn     : int (default 500)\n                  Number of samples to discard to give the MCMC enough time\n                  to converge.\n      output    : list of ints or 'full' (default 'full')\n                  If 'full', then return the full samples (except for burn-in\n                  section) for each parameter. Otherwise, each float\n                  corresponds to a percentile that will be returned for\n                  each parameter.\n\n    Returns\n    -------\n      See *output* argument above for return options.\n\n    \"\"\"\n    import emcee\n    if len(x1err) == 0:\n        x1err = numpy.ones(len(x1))\n    if len(x2err) == 0:\n        x2err = numpy.ones(len(x1))\n    def lnlike(theta, x, y, xerr, yerr):\n        a, b, s = theta\n        model = a + b*x\n        sigma = numpy.sqrt((b*xerr)**2 + yerr*2 + s**2)\n        lglk = 2 * sum(numpy.log(sigma)) + \\\n               sum(((y-model) / sigma) ** 2) + \\\n               numpy.log(len(x)) * numpy.sqrt(2*numpy.pi) / 2\n        return -lglk\n    def lnprior(theta):\n        a, b, s = theta\n        if s >= 0:\n            return 0\n        return -numpy.inf\n    def lnprob(theta, x, y, xerr, yerr):\n        lp = lnprior(theta)\n        return lp + lnlike(theta, x, y, xerr, yerr)\n    if logify:\n        x1, x2, x1err, x2err = to_log(x1, x2, x1err, x2err)\n    start = numpy.array(po)\n    ndim = len(start)\n    pos = [start + 1e-4*numpy.random.randn(ndim) for i in range(nwalkers)]\n    sampler = emcee.EnsembleSampler(nwalkers, ndim, lnprob,\n                                    args=(x1,x2,x1err,x2err))\n    sampler.run_mcmc(pos, nsteps)\n    samples = numpy.array([sampler.chain[:,nburn:,i].reshape(-1) \\\n                           for i in xrange(ndim)])\n    if logify:\n        samples[2] *= numpy.log(10)\n    if output == 'full':\n        return samples\n    else:\n        try:\n            values = [[numpy.percentile(s, o) for o in output] \n                      for s in samples]\n            return values\n        except TypeError:\n            msg = 'ERROR: wrong value for argument output in mcmc().'\n            msg += ' Must be \"full\" or list of ints.'\n            print msg\n            exit()\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mle(x1, x2, x1err=[], x2err=[], cerr=[], s_int=True,\n        po=(1,0,0.1), verbose=False, logify=True, full_output=False):\n    \"\"\"\n    Maximum Likelihood Estimation of best-fit parameters\n\n    Parameters\n    ----------\n      x1, x2    : float arrays\n                  the independent and dependent variables.\n      x1err, x2err : float arrays (optional)\n                  measurement uncertainties on independent and dependent\n                  variables. Any of the two, or both, can be supplied.\n      cerr      : float array (same size as x1)\n                  covariance on the measurement errors\n      s_int     : boolean (default True)\n                  whether to include intrinsic scatter in the MLE.\n      po        : tuple of floats\n                  initial guess for free parameters. If s_int is True, then\n                  po must have 3 elements; otherwise it can have two (for the\n                  zero point and the slope)\n      verbose   : boolean (default False)\n                  verbose?\n      logify    : boolean (default True)\n                  whether to convert the values to log10's. This is to\n                  calculate the best-fit power law. Note that the result is\n                  given for the equation log(y)=a+b*log(x) -- i.e., the\n                  zero point must be converted to 10**a if logify=True\n      full_output : boolean (default False)\n                  numpy.optimize.fmin's full_output argument\n\n    Returns\n    -------\n      a         : float\n                  Maximum Likelihood Estimate of the zero point. Note that\n                  if logify=True, the power-law intercept is 10**a\n      b         : float\n                  Maximum Likelihood Estimate of the slope\n      s         : float (optional, if s_int=True)\n                  Maximum Likelihood Estimate of the intrinsic scatter\n\n    \"\"\"\n    from scipy import optimize\n    n = len(x1)\n    if len(x2) != n:\n        raise ValueError('x1 and x2 must have same length')\n    if len(x1err) == 0:\n        x1err = numpy.ones(n)\n    if len(x2err) == 0:\n        x2err = numpy.ones(n)\n    if logify:\n        x1, x2, x1err, x2err = to_log(x1, x2, x1err, x2err)\n\n    f = lambda a, b: a + b * x1\n    if s_int:\n        w = lambda b, s: numpy.sqrt(b**2 * x1err**2 + x2err**2 + s**2)\n        loglike = lambda p: 2 * sum(numpy.log(w(p[1],p[2]))) + \\\n                            sum(((x2 - f(p[0],p[1])) / w(p[1],p[2])) ** 2) + \\\n                            numpy.log(n * numpy.sqrt(2*numpy.pi)) / 2\n    else:\n        w = lambda b: numpy.sqrt(b**2 * x1err**2 + x2err**2)\n        loglike = lambda p: sum(numpy.log(w(p[1]))) + \\\n                            sum(((x2 - f(p[0],p[1])) / w(p[1])) ** 2) / 2 + \\\n                            numpy.log(n * numpy.sqrt(2*numpy.pi)) / 2\n        po = po[:2]\n    out = optimize.fmin(loglike, po, disp=verbose, full_output=full_output)\n    return out", "response": "This function calculates the MLE of two sets of measurement uncertainties and returns the MLE of the two sets of free parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_log(x1, x2, x1err, x2err):\n    logx1 = numpy.log10(numpy.array(x1))\n    logx2 = numpy.log10(numpy.array(x2))\n    x1err = numpy.log10(numpy.array(x1)+numpy.array(x1err)) - logx1\n    x2err = numpy.log10(numpy.array(x2)+numpy.array(x2err)) - logx2\n    return logx1, logx2, x1err, x2err", "response": "Transform two linear measurements and uncertainties and transform to log values."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps all paths in quotes and join them with space in - between.", "response": "def wrap_paths(paths):\n    # type: (list[str]) -> str\n    \"\"\" Put quotes around all paths and join them with space in-between. \"\"\"\n    if isinstance(paths, string_types):\n        raise ValueError(\n            \"paths cannot be a string. \"\n            \"Use array with one element instead.\"\n        )\n    return ' '.join('\"' + path + '\"' for path in paths)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwalks a directory and returns a generator yielding all the files that match any of the patterns in include and exclude.", "response": "def filtered_walk(path, include=None, exclude=None):\n    # type: (str, List[str], List[str]) -> Generator[str]\n    \"\"\" Walk recursively starting at *path* excluding files matching *exclude*\n\n    Args:\n        path (str):\n            A starting path. This has to be an existing directory.\n        include (list[str]):\n            A white list of glob patterns. If given, only files that match those\n            globs will be yielded (filtered by exclude).\n        exclude (list[str]):\n            A list of glob string patterns to test against. If the file/path\n            matches any of those patters, it will be filtered out.\n\n    Returns:\n        Generator[str]: A generator yielding all the files that do not match any\n        pattern in ``exclude``.\n    \"\"\"\n    exclude = exclude or []\n\n    if not isdir(path):\n        raise ValueError(\"Cannot walk files, only directories\")\n\n    files = os.listdir(path)\n    for name in files:\n        filename = normpath(join(path, name))\n\n        # If excluded, completely skip it. Will not recurse into directories\n        if search_globs(filename, exclude):\n            continue\n\n        # If we have a whitelist and the pattern matches, yield it. If the\n        # pattern didn't match and it's a dir, it will still be recursively\n        # processed.\n        if include is None or match_globs(filename, include):\n            yield filename\n\n        if isdir(filename):\n            for p in filtered_walk(filename, include, exclude):\n                yield p"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntest whether the given path matches any of the given glob strings.", "response": "def match_globs(path, patterns):\n    # type: (str, List[str]) -> bool\n    \"\"\" Test whether the given *path* matches any patterns in *patterns*\n\n    Args:\n        path (str):\n            A file path to test for matches.\n        patterns (list[str]):\n            A list of glob string patterns to test against. If *path* matches\n            any of those patters, it will return True.\n\n    Returns:\n        bool: **True** if the *path* matches any pattern in *patterns*.\n    \"\"\"\n    for pattern in (p for p in patterns if p):\n        if pattern.startswith('/'):\n            regex = fnmatch.translate(pattern[1:])\n\n            temp_path = path[1:] if path.startswith('/') else path\n\n            m = re.search(regex, temp_path)\n\n            if m and m.start() == 0:\n                return True\n\n        elif fnmatch.fnmatch(path, pattern):\n                return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef search_globs(path, patterns):\n    # type: (str, List[str]) -> bool\n    \"\"\" Test whether the given *path* contains any patterns in *patterns*\n\n    Args:\n        path (str):\n            A file path to test for matches.\n        patterns (list[str]):\n            A list of glob string patterns to test against. If *path* matches\n            any of those patters, it will return True.\n\n    Returns:\n        bool: **True** if the ``path`` matches any pattern in *patterns*.\n    \"\"\"\n    for pattern in (p for p in patterns if p):\n        if pattern.startswith('/'):\n            # If pattern starts with root it means it match from root only\n            regex = fnmatch.translate(pattern[1:])\n            regex = regex.replace('\\\\Z', '')\n\n            temp_path = path[1:] if path.startswith('/') else path\n            m = re.search(regex, temp_path)\n\n            if m and m.start() == 0:\n                return True\n\n        else:\n            regex = fnmatch.translate(pattern)\n            regex = regex.replace('\\\\Z', '')\n\n            if re.search(regex, path):\n                return True\n\n    return False", "response": "Test whether the given path contains any of the given glob strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_file(path, content, mode='w'):\n    # type: (Text, Union[Text,bytes], Text) -> None\n    \"\"\" --pretend aware file writing.\n\n    You can always write files manually but you should always handle the\n    --pretend case.\n\n    Args:\n        path (str):\n        content (str):\n        mode (str):\n    \"\"\"\n    from peltak.core import context\n    from peltak.core import log\n\n    if context.get('pretend', False):\n        log.info(\"Would overwrite <34>{path}<32> with:\\n<90>{content}\",\n                 path=path,\n                 content=content)\n    else:\n        with open(path, mode) as fp:\n            fp.write(content)", "response": "Writes the content of the current node to the file at the given path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning pep8 and pylint on all project files. You can configure the linting paths using the lint.paths config variable. This should be a list of paths that will be linted. If a path to a directory is given, all files in that directory and it's subdirectories will be used. The pep8 and pylint config paths are by default stored in ops/tools/pep8.ini and ops/tools/pylint.ini. You can customise those paths in your config with lint.pep8_cfg and lint.pylint_cfg variables. **Config Example**:: \\b lint: pylint_cfg: 'ops/tools/pylint.ini' pep8_cfg: 'ops/tools/pep8.ini' paths: - 'src/mypkg' **Examples**:: \\b $ peltak lint # Run linter in default mode, skip untracked $ peltak lint --commit # Lint only files staged for commit $ peltak lint --all # Lint all files, including untracked. $ peltak lint --pretend # Print the list of files to lint $ peltak lint -e \"*.tox*\" # Don't lint files inside .tox directory", "response": "def lint_cli(ctx, exclude, skip_untracked, commit_only):\n    # type: (click.Context, List[str], bool, bool) -> None\n    \"\"\" Run pep8 and pylint on all project files.\n\n    You can configure the linting paths using the lint.paths config variable.\n    This should be a list of paths that will be linted. If a path to a directory\n    is given, all files in that directory and it's subdirectories will be\n    used.\n\n    The pep8 and pylint config paths are by default stored in ops/tools/pep8.ini\n    and ops/tools/pylint.ini. You can customise those paths in your config with\n    lint.pep8_cfg and lint.pylint_cfg variables.\n\n    **Config Example**::\n\n        \\b\n        lint:\n          pylint_cfg: 'ops/tools/pylint.ini'\n          pep8_cfg: 'ops/tools/pep8.ini'\n          paths:\n            - 'src/mypkg'\n\n    **Examples**::\n\n        \\b\n        $ peltak lint               # Run linter in default mode, skip untracked\n        $ peltak lint --commit      # Lint only files staged for commit\n        $ peltak lint --all         # Lint all files, including untracked.\n        $ peltak lint --pretend     # Print the list of files to lint\n        $ peltak lint -e \"*.tox*\"   # Don't lint files inside .tox directory\n\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    from peltak.logic import lint\n    lint.lint(exclude, skip_untracked, commit_only)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning a command using subprocess module .", "response": "def run_command(command, timeout_sec=3600.0, output=True):\n    \"\"\"Runs a command using the subprocess module\n\n    :param command: List containing the command and all args\n    :param timeout_sec (float) seconds to wait before killing\n        the command.\n    :param output (bool) True collects output, False ignores output\n    :return: Dict containing the command output and return code\n    :raises CommandError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.run_command')\n    if not isinstance(command, list):\n        msg = 'command arg must be a list'\n        log.error(msg)\n        raise CommandError(msg)\n    if output:\n        subproc_stdout = subprocess.PIPE\n        subproc_stderr = subprocess.STDOUT\n    else:\n        subproc_stdout = None\n        subproc_stderr = None\n    command = map(str, command)\n    command_str = ' '.join(command)\n    timer = None\n    log.debug('Running command: {c}'.format(c=command_str))\n    output_collector = ''\n    try:\n        log.debug('Opening subprocess...')\n        subproc = subprocess.Popen(\n            command,\n            bufsize=1,\n            stdin=open(os.devnull),\n            stdout=subproc_stdout,\n            stderr=subproc_stderr\n        )\n        log.debug('Opened subprocess wih PID: {p}'.format(p=subproc.pid))\n        log.debug('Setting up process kill timer for PID {p} at {s} sec...'.format(p=subproc.pid, s=timeout_sec))\n        kill_proc = process_killer\n        timer = Timer(timeout_sec, kill_proc, [subproc])\n        timer.start()\n        if output:\n            log.debug('Collecting and logging output...')\n            with subproc.stdout:\n                for line in iter(subproc.stdout.readline, b''):\n                    output_collector += line.rstrip() + '\\n'\n                    print(\">>> \" + line.rstrip())\n        log.debug('Waiting for process completion...')\n        subproc.wait()\n        log.debug('Collecting the exit code...')\n        code = subproc.poll()\n    except ValueError:\n        _, ex, trace = sys.exc_info()\n        msg = 'Bad command supplied: {c}\\n{e}'.format(\n            c=command_str, e=str(ex)\n        )\n        log.error(msg)\n        raise CommandError, msg, trace\n    except (OSError, IOError):\n        _, ex, trace = sys.exc_info()\n        msg = 'There was a problem running command: {c}\\n{e}'.format(\n            c=command_str, e=str(ex))\n        log.error(msg)\n        raise CommandError, msg, trace\n    except subprocess.CalledProcessError:\n        _, ex, trace = sys.exc_info()\n        msg = 'Command returned a non-zero exit code: {c}, return code: {cde}\\n{e}'.format(\n            c=command_str, cde=ex.returncode, e=ex)\n        log.error(msg)\n        raise CommandError, msg, trace\n    finally:\n        if timer is not None:\n            log.debug('Cancelling the timer...')\n            timer.cancel()\n        else:\n            log.debug('No need to cancel the timer.')\n    # Collect exit code and output for return\n    output = output_collector.strip()\n    try:\n        code = int(code)\n    except ValueError:\n        _, ex, trace = sys.exc_info()\n        msg = 'Return code {c} could not be parsed into an int\\n{e}'.format(\n            c=code, e=str(ex))\n        log.error(msg)\n        raise CommandError, msg, trace\n    else:\n        log.debug('Command executed and returned code: {c} with output:\\n{o}'.format(c=code, o=output))\n        output = {\n            'output': output,\n            'code': code\n        }\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the ip addresses from ifconfig", "response": "def get_ip_addresses():\n    \"\"\"Gets the ip addresses from ifconfig\n\n    :return: (dict) of devices and aliases with the IPv4 address\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.get_ip_addresses')\n\n    command = ['/sbin/ifconfig']\n    try:\n        result = run_command(command)\n    except CommandError:\n        raise\n    ifconfig = result['output'].strip()\n\n    # Scan the ifconfig output for IPv4 addresses\n    devices = {}\n    parts = ifconfig.split()\n    device = None\n    for part in parts:\n\n        if device is None:\n            if 'eth' in part or 'eno' in part:\n                device = part\n        else:\n            test = part.split(':', 1)\n            if len(test) == 2:\n                if test[0] == 'addr':\n                    ip_address = test[1]\n                    log.info('Found IP address %s on device %s', ip_address,\n                             device)\n                    devices[device] = ip_address\n                    device = None\n    return devices"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_mac_address(device_index=0):\n    log = logging.getLogger(mod_logger + '.get_mac_address')\n    command = ['ip', 'addr', 'show', 'eth{d}'.format(d=device_index)]\n    log.info('Attempting to find a mac address at device index: {d}'.format(d=device_index))\n    try:\n        result = run_command(command)\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        log.error('There was a problem running command, unable to determine mac address: {c}\\n{e}'.format(\n                c=command, e=str(ex)))\n        return\n    ipaddr = result['output'].split()\n    get_next = False\n    mac_address = None\n    for part in ipaddr:\n        if get_next:\n            mac_address = part\n            log.info('Found mac address: {m}'.format(m=mac_address))\n            break\n        if 'link' in part:\n            get_next = True\n    if not mac_address:\n        log.info('mac address not found for device: {d}'.format(d=device_index))\n    return mac_address", "response": "Returns the Mac Address given a device index"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nemulate bash chmod command", "response": "def chmod(path, mode, recursive=False):\n    \"\"\"Emulates bash chmod command\n\n    This method sets the file permissions to the specified mode.\n\n    :param path: (str) Full path to the file or directory\n    :param mode: (str) Mode to be set (e.g. 0755)\n    :param recursive: (bool) Set True to make a recursive call\n    :return: int exit code of the chmod command\n    :raises CommandError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.chmod')\n\n    # Validate args\n    if not isinstance(path, basestring):\n        msg = 'path argument is not a string'\n        log.error(msg)\n        raise CommandError(msg)\n    if not isinstance(mode, basestring):\n        msg = 'mode argument is not a string'\n        log.error(msg)\n        raise CommandError(msg)\n\n    # Ensure the item exists\n    if not os.path.exists(path):\n        msg = 'Item not found: {p}'.format(p=path)\n        log.error(msg)\n        raise CommandError(msg)\n\n    # Create the chmod command\n    command = ['chmod']\n    # Make it recursive if specified\n    if recursive:\n        command.append('-R')\n    command.append(mode)\n    command.append(path)\n    try:\n        result = run_command(command)\n    except CommandError:\n        raise\n    log.info('chmod command exited with code: {c}'.format(c=result['code']))\n    return result['code']"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nemulate mkdir - p in bash", "response": "def mkdir_p(path):\n    \"\"\"Emulates 'mkdir -p' in bash\n\n    :param path: (str) Path to create\n    :return: None\n    :raises CommandError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.mkdir_p')\n    if not isinstance(path, basestring):\n        msg = 'path argument is not a string'\n        log.error(msg)\n        raise CommandError(msg)\n    log.info('Attempting to create directory: %s', path)\n    try:\n        os.makedirs(path)\n    except OSError as e:\n        if e.errno == errno.EEXIST and os.path.isdir(path):\n            pass\n        else:\n            msg = 'Unable to create directory: {p}'.format(p=path)\n            log.error(msg)\n            raise CommandError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef source(script):\n    log = logging.getLogger(mod_logger + '.source')\n    if not isinstance(script, basestring):\n        msg = 'script argument must be a string'\n        log.error(msg)\n        raise CommandError(msg)\n    log.info('Attempting to source script: %s', script)\n    try:\n        pipe = subprocess.Popen(\". %s; env\" % script, stdout=subprocess.PIPE, shell=True)\n        data = pipe.communicate()[0]\n    except ValueError:\n        _, ex, trace = sys.exc_info()\n        msg = 'Invalid argument:\\n{e}'.format(e=str(ex))\n        log.error(msg)\n        raise CommandError, msg, trace\n    except OSError:\n        _, ex, trace = sys.exc_info()\n        msg = 'File not found: {s}\\n{e}'.format(s=script, e=str(ex))\n        raise CommandError, msg, trace\n    except subprocess.CalledProcessError:\n        _, ex, trace = sys.exc_info()\n        msg = 'Script {s} returned a non-zero exit code: {c}\\n{e}'.format(\n            s=script, e=str(ex), c=ex.returncode)\n        log.error(msg)\n        raise CommandError, msg, trace\n    env = {}\n    log.debug('Adding environment variables from data: {d}'.format(d=data))\n    for line in data.splitlines():\n        entry = line.split(\"=\", 1)\n        if len(entry) != 2:\n            log.warn('This property is not in prop=value format, and will be skipped: {p}'.format(p=line))\n            continue\n        try:\n            env[entry[0]] = entry[1]\n        except IndexError:\n            _, ex, trace = sys.exc_info()\n            log.warn('IndexError: There was a problem setting environment variables from line: {p}\\n{e}'.format(\n                p=line, e=str(ex)))\n            continue\n        else:\n            log.debug('Added environment variable {p}={v}'.format(p=entry[0], v=entry[1]))\n    os.environ.update(env)\n    return env", "response": "Emulates source command in bash\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef yum_update(downloadonly=False, dest_dir='/tmp'):\n    log = logging.getLogger(mod_logger + '.yum_update')\n\n    # Type checks on the args\n    if not isinstance(dest_dir, basestring):\n        msg = 'dest_dir argument must be a string'\n        log.error(msg)\n        raise CommandError(msg)\n    if not isinstance(downloadonly, bool):\n        msg = 'downloadonly argument must be a bool'\n        log.error(msg)\n        raise CommandError(msg)\n\n    # If downloadonly was True, download packages to dest_dir\n    if downloadonly:\n        # Create the destination directory if it does not exist\n        log.info('Creating directory: %s', dest_dir)\n        try:\n            mkdir_p(dest_dir)\n        except OSError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to create destination directory: {d}'.format(\n                d=dest_dir)\n            log.error(msg)\n            raise CommandError, msg, trace\n\n        # Build command string with downloadonly options specified\n        command = ['yum', '-y', 'update', '--downloadonly',\n                   '--downloaddir={d}'.format(d=dest_dir)]\n        log.info('Downloading updates from yum to %s...', dest_dir)\n    else:\n        # Build command string to update directly\n        command = ['yum', '-y', 'update']\n        log.info('Installing yum updates from RHN...')\n\n    # Run the command\n    try:\n        result = run_command(command)\n    except CommandError:\n        raise\n    log.info('Yum update completed and exit with code: {c}'.format(\n        c=result['code']))\n    return result['code']", "response": "This method runs the yum update command to update the packages in the system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef yum_install(packages, downloadonly=False, dest_dir='/tmp'):\n    log = logging.getLogger(mod_logger + '.yum_install')\n\n    # Type checks on the args\n    if not isinstance(dest_dir, basestring):\n        msg = 'dest_dir argument must be a string'\n        log.error(msg)\n        raise CommandError(msg)\n    if not isinstance(packages, list):\n        msg = 'packages argument must be a list'\n        log.error(msg)\n        raise CommandError(msg)\n    if not isinstance(downloadonly, bool):\n        msg = 'downloadonly argument must be a bool'\n        log.error(msg)\n        raise CommandError(msg)\n    if not packages:\n        msg = 'Empty list of packages provided'\n        log.error(msg)\n        raise CommandError(msg)\n    for package in packages:\n        # Ensure the package is specified as a string\n        if not isinstance(package, basestring):\n            msg = 'One of the packages was not specified as a string'\n            log.error(msg)\n            raise CommandError(msg)\n\n    # Build the yum install command string\n    command = ['yum', '-y', 'install'] + packages\n\n    # If downloadonly was True, download packages to dest_dir\n    if downloadonly:\n        log.info('yum downloadonly was specified, adding additional options...')\n\n        # Append downloadonly args to the command\n        command += ['--downloadonly', '--downloaddir={d}'.format(d=dest_dir)]\n\n        # Create the destination directory if it does not exist\n        log.info('Creating directory: %s', dest_dir)\n        try:\n            mkdir_p(dest_dir)\n        except CommandError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to create destination directory: {d}'.format(d=dest_dir)\n            log.error(msg)\n            raise CommandError, msg, trace\n        log.info('Downloading packages from yum to %s...', dest_dir)\n    else:\n        log.info('Installing yum packages from RHN...')\n\n    # Run the yum install command\n    try:\n        result = run_command(command)\n    except CommandError:\n        raise\n    log.info('Yum update completed and exit with code: {c}'.format(\n        c=result['code']))\n    return result['code']", "response": "This function installs a list of packages from yum or downloads the packages to dest_dir using the yum - y plugin."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sed(file_path, pattern, replace_str, g=0):\n    log = logging.getLogger(mod_logger + '.sed')\n\n    # Type checks on the args\n    if not isinstance(file_path, basestring):\n        msg = 'file_path argument must be a string'\n        log.error(msg)\n        raise CommandError(msg)\n    if not isinstance(pattern, basestring):\n        msg = 'pattern argument must be a string'\n        log.error(msg)\n        raise CommandError(msg)\n    if not isinstance(replace_str, basestring):\n        msg = 'replace_str argument must be a string'\n        log.error(msg)\n        raise CommandError(msg)\n\n    # Ensure the file_path file exists\n    if not os.path.isfile(file_path):\n        msg = 'File not found: {f}'.format(f=file_path)\n        log.error(msg)\n        raise CommandError(msg)\n\n    # Search for a matching pattern and replace matching patterns\n    log.info('Updating file: %s...', file_path)\n    for line in fileinput.input(file_path, inplace=True):\n        if re.search(pattern, line):\n            log.info('Updating line: %s', line)\n            new_line = re.sub(pattern, replace_str, line, count=g)\n            log.info('Replacing with line: %s', new_line)\n            sys.stdout.write(new_line)\n        else:\n            sys.stdout.write(line)", "response": "This function emulates the functionality of the bash sed command."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef zip_dir(dir_path, zip_file):\n    log = logging.getLogger(mod_logger + '.zip_dir')\n\n    # Validate args\n    if not isinstance(dir_path, basestring):\n        msg = 'dir_path argument must be a string'\n        log.error(msg)\n        raise CommandError(msg)\n    if not isinstance(zip_file, basestring):\n        msg = 'zip_file argument must be a string'\n        log.error(msg)\n        raise CommandError(msg)\n\n    # Ensure the dir_path file exists\n    if not os.path.isdir(dir_path):\n        msg = 'Directory not found: {f}'.format(f=dir_path)\n        log.error(msg)\n        raise CommandError(msg)\n\n    try:\n        with contextlib.closing(zipfile.ZipFile(zip_file, 'w', allowZip64=True)) as zip_w:\n            for root, dirs, files in os.walk(dir_path):\n                for f in files:\n                    log.debug('Adding file to zip: %s', f)\n                    strip = len(dir_path) - len(os.path.split(dir_path)[-1])\n                    file_name = os.path.join(root, f)\n                    archive_name = os.path.join(root[strip:], f)\n                    zip_w.write(file_name, archive_name)\n    except Exception:\n        _, ex, trace = sys.exc_info()\n        msg = 'Unable to create zip file: {f}\\n{e}'.format(\n            f=zip_file, e=str(ex))\n        log.error(msg)\n        raise CommandError, msg, trace\n    log.info('Successfully created zip file: %s', zip_file)", "response": "Creates a zip file of a directory tree"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the /etc/hosts file for the specified ip This method updates the /etc/hosts file for the specified IP address with the specified entry. :param ip: (str) IP address to be added or updated :param entry: (str) Hosts file entry to be added :return: None :raises CommandError", "response": "def update_hosts_file(ip, entry):\n    \"\"\"Updates the /etc/hosts file for the specified ip\n\n    This method updates the /etc/hosts file for the specified IP\n    address with the specified entry.\n\n    :param ip: (str) IP address to be added or updated\n    :param entry: (str) Hosts file entry to be added\n    :return: None\n    :raises CommandError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.update_hosts_file')\n\n    # Validate args\n    if not isinstance(ip, basestring):\n        msg = 'ip argument must be a string'\n        log.error(msg)\n        raise CommandError(msg)\n    if not isinstance(entry, basestring):\n        msg = 'entry argument must be a string'\n        log.error(msg)\n        raise CommandError(msg)\n\n    # Ensure the file_path file exists\n    hosts_file = '/etc/hosts'\n    if not os.path.isfile(hosts_file):\n        msg = 'File not found: {f}'.format(f=hosts_file)\n        log.error(msg)\n        raise CommandError(msg)\n\n    # Updating /etc/hosts file\n    log.info('Updating hosts file: {f} with IP {i} and entry: {e}'.format(f=hosts_file, i=ip, e=entry))\n    full_entry = ip + ' ' + entry.strip() + '\\n'\n    updated = False\n    for line in fileinput.input(hosts_file, inplace=True):\n        if re.search(ip, line):\n            if line.split()[0] == ip:\n                log.info('Found IP {i} in line: {li}, updating...'.format(i=ip, li=line))\n                log.info('Replacing with new line: {n}'.format(n=full_entry))\n                sys.stdout.write(full_entry)\n                updated = True\n            else:\n                log.debug('Found ip {i} in line {li} but not an exact match, adding line back to hosts file {f}...'.\n                          format(i=ip, li=line, f=hosts_file))\n                sys.stdout.write(line)\n        else:\n            log.debug('IP address {i} not found in line, adding line back to hosts file {f}: {li}'.format(\n                    i=ip, li=line, f=hosts_file))\n            sys.stdout.write(line)\n\n    # Append the entry if the hosts file was not updated\n    if updated is False:\n        with open(hosts_file, 'a') as f:\n            log.info('Appending hosts file entry to {f}: {e}'.format(f=hosts_file, e=full_entry))\n            f.write(full_entry)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset this hosts hostname This method updates /etc/sysconfig/network and calls the hostname command to set a hostname on a Linux system. :param new_hostname: (str) New hostname :param pretty_hostname: (str) new pretty hostname, set to the same as new_hostname if not provided :return (int) exit code of the hostname command :raises CommandError", "response": "def set_hostname(new_hostname, pretty_hostname=None):\n    \"\"\"Sets this hosts hostname\n\n    This method updates /etc/sysconfig/network and calls the hostname\n    command to set a hostname on a Linux system.\n\n    :param new_hostname: (str) New hostname\n    :param pretty_hostname: (str) new pretty hostname, set to the same as\n        new_hostname if not provided\n    :return (int) exit code of the hostname command\n    :raises CommandError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.set_hostname')\n\n    # Ensure the hostname is a str\n    if not isinstance(new_hostname, basestring):\n        msg = 'new_hostname argument must be a string'\n        raise CommandError(msg)\n\n    # Update the network config file\n    network_file = '/etc/sysconfig/network'\n    if os.path.isfile(network_file):\n        log.info('Updating {f} with the new hostname: {h}...'.format(f=network_file, h=new_hostname))\n        try:\n            sed(network_file, '^HOSTNAME=.*', 'HOSTNAME=' + new_hostname)\n        except CommandError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to update [{f}], produced output:\\n{e}'.format(f=network_file, e=str(ex))\n            raise CommandError, msg, trace\n    else:\n        log.info('Network file not found, will not be updated: {f}'.format(f=network_file))\n\n    # Update the hostname\n    if is_systemd():\n        hostname_file = '/etc/hostname'\n        pretty_hostname_file = '/etc/machine-info'\n        log.info('This is systemd, updating files: {h} and {p}'.format(h=hostname_file, p=pretty_hostname_file))\n\n        # Update the hostname file\n        log.info('Updating hostname file: {h}...'.format(h=hostname_file))\n        if os.path.isfile(hostname_file):\n            os.remove(hostname_file)\n        with open(hostname_file, 'w') as f:\n            f.write(new_hostname)\n        log.info('Updating pretty hostname file: {p}'.format(p=pretty_hostname_file))\n\n        # Use the same thing if pretty hostname is not provided\n        if pretty_hostname is None:\n            log.info('Pretty hostname not provided, using: {p}'.format(p=pretty_hostname))\n            pretty_hostname = new_hostname\n\n        # Update the pretty hostname file\n        if os.path.isfile(pretty_hostname_file):\n            os.remove(pretty_hostname_file)\n        with open(pretty_hostname_file, 'w') as f:\n            f.write('PRETTY_HOSTNAME={p}'.format(p=pretty_hostname))\n        return 0\n    else:\n        command = ['/bin/hostname', new_hostname]\n\n        # Run the hostname command\n        log.info('Running hostname command to set the hostname: [{c}]'.format(c=' '.join(command)))\n        try:\n            result = run_command(command)\n        except CommandError:\n            raise\n        log.info('Hostname command completed with code: {c} and output:\\n{o}'.format(\n            c=result['code'], o=result['output']))\n        return result['code']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_ntp_server(server):\n    log = logging.getLogger(mod_logger + '.set_ntp_server')\n\n    # Ensure the hostname is a str\n    if not isinstance(server, basestring):\n        msg = 'server argument must be a string'\n        log.error(msg)\n        raise CommandError(msg)\n    # Ensure the ntp.conf file exists\n    ntp_conf = '/etc/ntp.conf'\n    if not os.path.isfile(ntp_conf):\n        msg = 'File not found: {f}'.format(f=ntp_conf)\n        log.error(msg)\n        raise CommandError(msg)\n    log.info('Clearing out existing server entries from %s...', ntp_conf)\n    try:\n        sed(ntp_conf, '^server.*', '', g=0)\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        msg = 'Unable to update file: {f}\\n{e}'.format(f=ntp_conf, e=str(ex))\n        log.error(msg)\n        raise CommandError, msg, trace\n    out_str = 'server ' + server\n    log.info('Appending server: %s', out_str)\n    with open(ntp_conf, 'a') as f:\n        f.write(out_str)\n    log.info('Successfully updated file: {f}'.format(f=ntp_conf))", "response": "Sets the NTP server on Linux and returns None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy_ifcfg_file(source_interface, dest_interface):\n    log = logging.getLogger(mod_logger + '.copy_ifcfg_file')\n    # Validate args\n    if not isinstance(source_interface, basestring):\n        msg = 'source_interface argument must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n    if not isinstance(dest_interface, basestring):\n        msg = 'dest_interface argument must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n\n    network_script = '/etc/sysconfig/network-scripts/ifcfg-eth'\n    source_file = network_script + source_interface\n    dest_file = network_script + dest_interface\n    command = ['cp', '-f', source_file, dest_file]\n    try:\n        result = run_command(command)\n        code = result['code']\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        msg = 'Unable to copy the ifcfg file from interface {s} to interface {d}\\n{e}'.format(\n            s=source_interface, d=dest_interface, e=str(ex))\n        raise OSError, msg, trace\n    log.info('Copy command exited with code: {c}'.format(c=code))\n\n    if code != 0:\n        msg = 'There was a problem copying file {s} file to {d}'.format(s=source, d=dest_file)\n        log.error(msg)\n        raise OSError(msg)\n\n    # Updating the destination network script DEVICE property\n    try:\n        sed(file_path=dest_file, pattern='^DEVICE=.*',\n            replace_str='DEVICE=\"eth{i}\"'.format(i=dest_interface))\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        msg = 'Unable to update DEVICE in file: {d}\\n{e}'.format(\n            d=dest_file, e=str(ex))\n        log.error(msg)\n        raise CommandError, msg, trace\n    log.info('Successfully created file: {d}'.format(d=dest_file))\n\n    log.info('Restarting networking in 10 seconds to ensure the changes take effect...')\n    time.sleep(10)\n    retry_time = 10\n    max_retries = 10\n    for i in range(1, max_retries+2):\n        if i > max_retries:\n            msg = 'Unable to successfully start the networking service after {m} attempts'.format(m=max_retries)\n            log.error(msg)\n            raise OSError(msg)\n        log.info('Attempting to restart the networking service, attempt #{i} of {m}'.format(i=i, m=max_retries))\n        try:\n            service_network_restart()\n        except CommandError:\n            _, ex, trace = sys.exc_info()\n            log.warn('Attempted unsuccessfully to restart networking on attempt #{i} of {m}, trying again in {t} '\n                     'seconds\\n{e}'.format(i=i, m=max_retries, t=retry_time, e=str(ex)))\n            time.sleep(retry_time)\n        else:\n            log.info('Successfully restarted networking')\n            break\n    log.info('Successfully configured interface: {d}'.format(d=dest_interface))", "response": "Copies an existing ifcfg network script to another ifcfg network script"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_ifcfg_file(device_index='0'):\n    log = logging.getLogger(mod_logger + '.remove_ifcfg_file')\n    if not isinstance(device_index, basestring):\n        msg = 'device_index argument must be a string'\n        log.error(msg)\n        raise CommandError(msg)\n    network_script = '/etc/sysconfig/network-scripts/ifcfg-eth{d}'.format(d=device_index)\n    if not os.path.isfile(network_script):\n        log.info('File does not exist, nothing will be removed: {n}'.format(n=network_script))\n        return\n\n    # Remove the network config script\n    log.info('Attempting to remove file: {n}'.format(n=network_script))\n    try:\n        os.remove(network_script)\n    except(IOError, OSError):\n        _, ex, trace = sys.exc_info()\n        msg = 'There was a problem removing network script file: {n}\\n{e}'.format(n=network_script, e=str(ex))\n        log.error(msg)\n        raise OSError, msg, trace\n    else:\n        log.info('Successfully removed file: {n}'.format(n=network_script))\n\n    # Restart the network service\n    log.info('Restarting the network service...')\n    try:\n        service_network_restart()\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        msg = 'There was a problem restarting the network service\\n{e}'.format(e=str(ex))\n        log.error(msg)\n        raise OSError, msg, trace\n    else:\n        log.info('Successfully restarted the network service')", "response": "Removes the ifcfg file at the specified device index and restarts the network service if it is still running."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_nat_rule(port, source_interface, dest_interface):\n    log = logging.getLogger(mod_logger + '.add_nat_rule')\n    # Validate args\n    if not isinstance(source_interface, basestring):\n        msg = 'source_interface argument must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n    if not isinstance(dest_interface, basestring):\n        msg = 'dest_interface argument must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n\n    ip_addresses = ip_addr()\n    destination_ip = ip_addresses['eth{i}'.format(i=dest_interface)]\n    log.info('Using destination IP address: {d}'.format(d=destination_ip))\n\n    command = ['iptables', '-t', 'nat', '-A', 'PREROUTING', '-i',\n               'eth{s}'.format(s=source_interface), '-p', 'tcp',\n               '--dport', str(port), '-j', 'DNAT', '--to',\n               '{d}:{p}'.format(p=port, d=destination_ip)]\n    log.info('Running command: {c}'.format(c=command))\n    try:\n        subprocess.check_call(command)\n    except OSError:\n        _, ex, trace = sys.exc_info()\n        msg = 'There was a problem running command: {c}\\n{e}'.format(c=command, e=str(ex))\n        log.error(msg)\n        raise OSError, msg, trace\n    except subprocess.CalledProcessError:\n        _, ex, trace = sys.exc_info()\n        msg = 'Command returned a non-zero exit code: {c}\\n{e}'.format(c=command, e=str(ex))\n        log.error(msg)\n        raise OSError, msg, trace\n    else:\n        log.info('Successfully ran command: {c}'.format(c=command))\n\n    # Save the iptables with the new NAT rule\n    try:\n        save_iptables()\n    except OSError:\n        _, ex, trace = sys.exc_info()\n        msg = 'OSError: There was a problem saving iptables rules\\n{e}'.format(e=str(ex))\n        raise OSError, msg, trace\n    log.info('Successfully saved iptables rules with the NAT rule')", "response": "Adds a NAT rule to iptables\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef service_network_restart():\n    log = logging.getLogger(mod_logger + '.service_network_restart')\n    command = ['service', 'network', 'restart']\n    time.sleep(5)\n    try:\n        result = run_command(command)\n        time.sleep(5)\n        code = result['code']\n    except CommandError:\n        raise\n    log.info('Network restart produced output:\\n{o}'.format(o=result['output']))\n\n    if code != 0:\n        msg = 'Network services did not restart cleanly, exited with code: {c}'.format(c=code)\n        log.error(msg)\n        raise CommandError(msg)\n    else:\n        log.info('Successfully restarted networking!')", "response": "Restarts the linux network service on linux\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving iptables rules to the provided rules file.", "response": "def save_iptables(rules_file='/etc/sysconfig/iptables'):\n    \"\"\"Saves iptables rules to the provided rules file\n\n    :return: None\n    :raises OSError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.save_iptables')\n\n    # Run iptables-save to get the output\n    command = ['iptables-save']\n    log.debug('Running command: iptables-save')\n    try:\n        iptables_out = run_command(command, timeout_sec=20)\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        msg = 'There was a problem running iptables command: {c}\\n{e}'.format(c=' '.join(command), e=str(ex))\n        raise OSError, msg, trace\n\n    # Error if iptables-save did not exit clean\n    if int(iptables_out['code']) != 0:\n        raise OSError('Command [{g}] exited with code [{c}] and output:\\n{o}'.format(\n            g=' '.join(command), c=iptables_out['code'], o=iptables_out['output']))\n\n    # Back up the existing rules file if it exists\n    if os.path.isfile(rules_file):\n        time_now = datetime.now().strftime('%Y%m%d-%H%M%S')\n        backup_file = '{f}.{d}'.format(f=rules_file, d=time_now)\n        log.debug('Creating backup file: {f}'.format(f=backup_file))\n        shutil.copy2(rules_file, backup_file)\n\n    # Save the output to the rules file\n    log.debug('Creating file: {f}'.format(f=rules_file))\n    with open(rules_file, 'w') as f:\n        f.write(iptables_out['output'])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving the value of an environment variable of a remote host over SSH", "response": "def get_remote_host_environment_variable(host, environment_variable):\n    \"\"\"Retrieves the value of an environment variable of a\n    remote host over SSH\n\n    :param host: (str) host to query\n    :param environment_variable: (str) variable to query\n    :return: (str) value of the environment variable\n    :raises: TypeError, CommandError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.get_remote_host_environment_variable')\n    if not isinstance(host, basestring):\n        msg = 'host argument must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n    if not isinstance(environment_variable, basestring):\n        msg = 'environment_variable argument must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n    log.info('Checking host {h} for environment variable: {v}...'.format(h=host, v=environment_variable))\n    command = ['ssh', '{h}'.format(h=host), 'echo ${v}'.format(v=environment_variable)]\n    try:\n        result = run_command(command, timeout_sec=5.0)\n        code = result['code']\n    except CommandError:\n        raise\n    if code != 0:\n        msg = 'There was a problem checking the remote host {h} over SSH, return code: {c}'.format(\n                h=host, c=code)\n        log.error(msg)\n        raise CommandError(msg)\n    else:\n        value = result['output'].strip()\n        log.info('Environment variable {e} on host {h} value is: {v}'.format(\n                e=environment_variable, h=host, v=value))\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_remote_host_environment_variable(host, variable_name, variable_value, env_file='/etc/bashrc'):\n    log = logging.getLogger(mod_logger + '.set_remote_host_environment_variable')\n    if not isinstance(host, basestring):\n        msg = 'host argument must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n    if not isinstance(variable_name, basestring):\n        msg = 'variable_name argument must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n    if not isinstance(variable_value, basestring):\n        msg = 'variable_value argument must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n    if not isinstance(env_file, basestring):\n        msg = 'env_file argument must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n    log.info('Creating the environment file if it does not exist...')\n    command = ['ssh', host, 'touch {f}'.format(f=env_file)]\n    try:\n        result = run_command(command, timeout_sec=5.0)\n        code = result['code']\n        output = result['output']\n    except CommandError:\n        raise\n    if code != 0:\n        msg = 'There was a problem creating environment file {f} on remote host {h} over SSH, ' \\\n              'exit code {c} and output:\\n{o}'.format(h=host, c=code, f=env_file, o=output)\n        log.error(msg)\n        raise CommandError(msg)\n\n    log.info('Creating ensuring the environment file is executable...')\n    command = ['ssh', host, 'chmod +x {f}'.format(f=env_file)]\n    try:\n        result = run_command(command, timeout_sec=5.0)\n        code = result['code']\n        output = result['output']\n    except CommandError:\n        raise\n    if code != 0:\n        msg = 'There was a problem setting permissions on environment file {f} on remote host {h} over SSH, ' \\\n              'exit code {c} and output:\\n{o}'.format(h=host, c=code, f=env_file, o=output)\n        log.error(msg)\n        raise CommandError(msg)\n\n    log.info('Adding environment variable {v} with value {n} to file {f}...'.format(\n            v=variable_name, n=variable_value, f=env_file))\n    command = ['ssh', host, 'echo \"export {v}=\\\\\"{n}\\\\\"\" >> {f}'.format(f=env_file, v=variable_name, n=variable_value)]\n    try:\n        result = run_command(command, timeout_sec=5.0)\n        code = result['code']\n        output = result['output']\n    except CommandError:\n        raise\n    if code != 0:\n        msg = 'There was a problem adding variable {v} to environment file {f} on remote host {h} over SSH, ' \\\n              'exit code {c} and output:\\n{o}'.format(h=host, c=code, f=env_file, o=output, v=variable_name)\n        log.error(msg)\n        raise CommandError(msg)\n    else:\n        log.info('Environment variable {v} set to {n} on host {h}'.format(v=variable_name, n=variable_value, h=host))", "response": "Sets an environment variable on the remote host in the specified environment file"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a command on the specified host over SSH and returns the output of the command.", "response": "def run_remote_command(host, command, timeout_sec=5.0):\n    \"\"\"Retrieves the value of an environment variable of a\n    remote host over SSH\n\n    :param host: (str) host to query\n    :param command: (str) command\n    :param timeout_sec (float) seconds to wait before killing the command.\n    :return: (str) command output\n    :raises: TypeError, CommandError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.run_remote_command')\n    if not isinstance(host, basestring):\n        msg = 'host argument must be a string'\n        raise TypeError(msg)\n    if not isinstance(command, basestring):\n        msg = 'command argument must be a string'\n        raise TypeError(msg)\n    log.debug('Running remote command on host: {h}: {c}...'.format(h=host, c=command))\n    command = ['ssh', '{h}'.format(h=host), '{c}'.format(c=command)]\n    try:\n        result = run_command(command, timeout_sec=timeout_sec)\n        code = result['code']\n    except CommandError:\n        raise\n    if code != 0:\n        msg = 'There was a problem running command [{m}] on host {h} over SSH, return code: {c}, and ' \\\n              'produced output:\\n{o}'.format(h=host, c=code, m=' '.join(command), o=result['output'])\n        raise CommandError(msg)\n    else:\n        output_text = result['output'].strip()\n        log.debug('Running command [{m}] host {h} over SSH produced output: {o}'.format(\n            m=command, h=host, o=output_text))\n        output = {\n            'output': output_text,\n            'code': code\n        }\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nqueries a remote host to check for existence of a marker file", "response": "def check_remote_host_marker_file(host, file_path):\n    \"\"\"Queries a remote host over SSH to check for existence\n    of a marker file\n\n    :param host: (str) host to query\n    :param file_path: (str) path to the marker file\n    :return: (bool) True if the marker file exists\n    :raises: TypeError, CommandError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.check_remote_host_marker_file')\n    if not isinstance(host, basestring):\n        msg = 'host argument must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n    if not isinstance(file_path, basestring):\n        msg = 'file_path argument must be a string'\n        log.error(msg)\n        raise TypeError(msg)\n    log.debug('Checking host {h} for marker file: {f}...'.format(h=host, f=file_path))\n    command = ['ssh', '{h}'.format(h=host), 'if [ -f {f} ] ; then exit 0 ; else exit 1 ; fi'.format(f=file_path)]\n    try:\n        result = run_command(command, timeout_sec=5.0)\n        code = result['code']\n        output = result['output']\n    except CommandError:\n        raise\n    if code == 0:\n        log.debug('Marker file <{f}> was found on host {h}'.format(f=file_path, h=host))\n        return True\n    elif code == 1 and output == '':\n        log.debug('Marker file <{f}> was not found on host {h}'.format(f=file_path, h=host))\n        return False\n    else:\n        msg = 'There was a problem checking the remote host {h} over SSH for marker file {f}, ' \\\n              'command returned code {c} and produced output: {o}'.format(\n                h=host, f=file_path, c=code, o=output)\n        log.debug(msg)\n        raise CommandError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef restore_iptables(firewall_rules):\n    log = logging.getLogger(mod_logger + '.restore_iptables')\n    log.info('Restoring firewall rules from file: {f}'.format(f=firewall_rules))\n\n    # Ensure the firewall rules file exists\n    if not os.path.isfile(firewall_rules):\n        msg = 'Unable to restore iptables, file not found: {f}'.format(f=firewall_rules)\n        log.error(msg)\n        raise OSError(msg)\n\n    # Restore the firewall rules\n    log.info('Restoring iptables from file: {f}'.format(f=firewall_rules))\n    command = ['/sbin/iptables-restore', firewall_rules]\n    try:\n        result = run_command(command)\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        msg = 'Unable to restore firewall rules from file: {f}\\n{e}'.format(f=firewall_rules, e=str(ex))\n        log.error(msg)\n        raise OSError(msg)\n    log.info('Restoring iptables produced output:\\n{o}'.format(o=result['output']))\n\n    # Save iptables\n    log.info('Saving iptables...')\n    command = ['/etc/init.d/iptables', 'save']\n    try:\n        result = run_command(command)\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        msg = 'Unable to save firewall rules\\n{e}'.format(e=str(ex))\n        log.error(msg)\n        raise OSError(msg)\n    log.info('Saving iptables produced output:\\n{o}'.format(o=result['output']))", "response": "Restores and saves firewall rules from the firewall_rules file\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving default gateway from the system config file and restarts the network service if it is still running", "response": "def remove_default_gateway():\n    \"\"\"Removes Default Gateway configuration from /etc/sysconfig/network\n    and restarts networking\n    \n    :return: None\n    :raises: OSError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.remove_default_gateway')\n\n    # Ensure the network script exists\n    network_script = '/etc/sysconfig/network'\n    if not os.path.isfile(network_script):\n        log.info('Network script not found, nothing to do: {f}'.format(f=network_script))\n        return\n    log.debug('Found network script: {f}'.format(f=network_script))\n\n    # Remove settings for GATEWAY and GATEWAYDEV\n    log.info('Attempting to remove any default gateway configurations...')\n    for line in fileinput.input(network_script, inplace=True):\n        if re.search('^GATEWAY=.*', line):\n            log.info('Removing GATEWAY line: {li}'.format(li=line))\n        elif re.search('^GATEWAYDEV=.*', line):\n            log.info('Removing GATEWAYDEV line: {li}'.format(li=line))\n        else:\n            log.debug('Keeping line: {li}'.format(li=line))\n            sys.stdout.write(line)\n\n    # Restart networking for the changes to take effect\n    log.info('Restarting the network service...')\n    try:\n        service_network_restart()\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        raise OSError('{n}: Attempted unsuccessfully to restart networking\\n{e}'.format(\n            n=ex.__class__.__name__, e=str(ex)))\n    else:\n        log.info('Successfully restarted networking')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_systemd():\n    os_family = platform.system()\n    if os_family != 'Linux':\n        raise OSError('This method is only supported on Linux, found OS: {o}'.format(o=os_family))\n    linux_distro, linux_version, distro_name = platform.linux_distribution()\n\n    # Determine when to use systemd\n    systemd = False\n    if 'ubuntu' in linux_distro.lower() and '16' in linux_version:\n        systemd = True\n    elif 'red' in linux_distro.lower() and '7' in linux_version:\n        systemd = True\n    elif 'cent' in linux_distro.lower() and '7' in linux_version:\n        systemd = True\n    return systemd", "response": "Determines if this distro has a systemd version of the system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmanage a Linux service.", "response": "def manage_service(service_name, service_action='status', systemd=None, output=True):\n    \"\"\"Use to run Linux sysv or systemd service commands\n\n    :param service_name (str) name of the service to start\n    :param service_action (str) action to perform on the service\n    :param systemd (bool) True if the command should use systemd\n    :param output (bool) True to print output\n    :return: None\n    :raises: OSError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.manage_service')\n\n    # Ensure the service name is a string\n    if not isinstance(service_name, basestring):\n        raise OSError('service_name arg must be a string, found: {t}'.format(t=service_name.__class__.__name__))\n\n    # Ensure the service name is a string\n    if not isinstance(service_action, basestring):\n        raise OSError('service_action arg must be a string, found: {t}'.format(t=service_name.__class__.__name__))\n\n    # Ensure the service action is valid\n    valid_actions = ['start', 'stop', 'reload', 'restart', 'status', 'enable', 'disable']\n    service_action = service_action.lower().strip()\n    if service_action not in valid_actions:\n        raise OSError('Invalid service action requested [{a}], valid actions are: [{v}]'.format(\n            a=service_action, v=','.join(valid_actions)\n        ))\n    log.info('Attempting to [{a}] service: {s}'.format(a=service_action, s=service_name))\n\n    # If systemd was not provided, attempt to determine which method to use\n    if not systemd:\n        log.debug('Systemd not provided, attempting to determine which method to use...')\n        systemd = is_systemd()\n\n    # Create commands depending on the method\n    command_list = []\n    if systemd:\n        if not service_name.endswith('.service'):\n            service_name = '{s}.service'.format(s=service_name)\n        log.info('Attempting to manage service with systemd: {s}'.format(s=service_name))\n        command_list.append(['/usr/bin/systemctl', service_action, service_name])\n    else:\n        log.info('Attempting to manage service with sysv: {s}'.format(s=service_name))\n\n        # Determine the commands to run\n        if service_action == 'enable':\n            command_list.append(['/sbin/chkconfig', '--add', service_name])\n            command_list.append(['/sbin/chkconfig', service_name, 'on'])\n        elif service_action == 'disable':\n            command_list.append(['/sbin/chkconfig', service_name, 'off'])\n        else:\n            command_list.append(['/sbin/service', service_name, service_action])\n\n    # Run the commands in the command list\n    post_command_wait_time_sec = 3\n    for command in command_list:\n        log.info('Attempting to run command: [{c}]'.format(c=' '.join(command)))\n        try:\n            result = run_command(command, timeout_sec=30, output=output)\n        except CommandError:\n            _, ex, trace = sys.exc_info()\n            msg = 'There was a problem running a service management command\\n{e}'.format(e=str(ex))\n            raise OSError, msg, trace\n        log.info('Command exited with code: {c}'.format(c=str(result['code'])))\n        if result['code'] != 0:\n            msg = 'Command exited with a non-zero code: [{c}], and produced output:\\n{o}'.format(\n                c=str(result['code']), o=result['output'])\n            raise OSError(msg)\n        else:\n            log.info('Command returned successfully with output:\\n{o}'.format(o=result['output']))\n        log.info('Waiting {t} sec...'.format(t=str(post_command_wait_time_sec)))\n        time.sleep(post_command_wait_time_sec)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef system_reboot(wait_time_sec=20):\n    log = logging.getLogger(mod_logger + '.system_reboot')\n\n    try:\n        wait_time_sec = int(wait_time_sec)\n    except ValueError:\n        raise CommandError('wait_time_sec must be an int, or a string convertible to an int')\n\n    log.info('Waiting {t} seconds before reboot...'.format(t=str(wait_time_sec)))\n    time.sleep(wait_time_sec)\n    command = ['shutdown', '-r', 'now']\n    log.info('Shutting down with command: [{c}]'.format(c=' '.join(command)))\n    time.sleep(2)\n    log.info('Shutting down...')\n    try:\n        result = run_command(command=command, timeout_sec=60)\n    except CommandError:\n        _, ex, trace = sys.exc_info()\n        msg = 'There was a problem running shutdown command: [{c}]\\n{e}'.format(c=' '.join(command), e=str(ex))\n        raise SystemRebootError, msg, trace\n    if result['code'] != 0:\n        msg = 'Shutdown command exited with a non-zero code: [{c}], and produced output:\\n{o}'.format(\n            c=str(result['code']), o=result['output'])\n        raise SystemRebootError(msg)\n    log.info('Waiting 60 seconds to ensure the reboot completes...')\n    time.sleep(60)\n    msg = 'Reboot has not completed after 60 seconds'\n    log.error(msg)\n    raise SystemRebootTimeoutError(msg)", "response": "Reboot the system after a specified wait time."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef log_event(name: str, request: Request=None, data=None, ip=None):\n    log_data = {}\n    if not ip and request:\n        ip = get_real_ip(request)\n    if ip:\n        log_data['ip'] = ip\n    if data:\n        log_data['data'] = data\n\n    msg = 'EVENT_{}: {}'.format(name.upper(), json.dumps(log_data))\n    logger.info(msg)", "response": "Logs a consistent event for easy parsing and analysis."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef aes_b64_decrypt(value, secret, block_size=AES.block_size):\n    if value is not None:\n        iv = value[:block_size]\n        cipher = AES.new(secret[:32], AES.MODE_CFB, iv)\n        return cipher.decrypt(b64decode(\n            uniorbytes(value[block_size * 2:], bytes))).decode('utf-8')", "response": "AES decrypt the value with the given secret."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef aes_decrypt(value, secret, block_size=AES.block_size):\n    if value is not None:\n        cipher = AES.new(secret[:32], AES.MODE_CFB, value[:block_size])\n        return cipher.decrypt(uniorbytes(value[block_size * 2:], bytes))", "response": "AES decrypt the value with the given secret."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef aes_pad(s, block_size=32, padding='{'):\n    return s + (block_size - len(s) % block_size) * padding", "response": "Adds padding to get the correct block sizes for AES encryption"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompare two strings in a cryptographically safe way.", "response": "def lscmp(a, b):\n    \"\"\" Compares two strings in a cryptographically safe way:\n        Runtime is not affected by length of common prefix, so this\n        is helpful against timing attacks.\n\n        ..\n            from vital.security import lscmp\n            lscmp(\"ringo\", \"starr\")\n            # -> False\n            lscmp(\"ringo\", \"ringo\")\n            # -> True\n        ..\n    \"\"\"\n    l = len\n    return not sum(0 if x == y else 1 for x, y in zip(a, b)) and l(a) == l(b)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nencoding or decodes a signed or unsigned cookie.", "response": "def cookie(data, key_salt='', secret=None, digestmod=None):\n    \"\"\" Encodes or decodes a signed cookie.\n        @data: cookie data\n        @key_salt: HMAC key signing salt\n        @secret: HMAC signing secret key\n        @digestmod: hashing algorithm to sign with, recommended >=sha256\n\n        -> HMAC signed or unsigned cookie data\n\n        ..\n            from vital.security import cookie\n\n            cookie(\"Hello, world.\", \"saltyDog\", secret=\"alBVlwe\")\n            # -> '!YuOoKwDp8GhrwwojdjTxSCj1c2Z+7yz7r6cC7E3hBWo=?IkhlbGxvLCB3b3JsZC4i'\n            cookie(\n                \"!YuOoKwDp8GhrwwojdjTxSCj1c2Z+7yz7r6cC7E3hBWo=?IkhlbGxvLCB3b3JsZC4i\",\n                \"saltyDog\", secret=\"alBVlwe\")\n            # -> 'Hello, world.'\n        ..\n    \"\"\"\n    digestmod = digestmod or sha256\n    if not data:\n        return None\n    try:\n        # Decode signed cookie\n        assert cookie_is_encoded(data)\n        datab = uniorbytes(data, bytes)\n        sig, msg = datab.split(uniorbytes('?', bytes), 1)\n        key = (\"{}{}\").format(secret, key_salt)\n        sig_check = hmac.new(\n            key=uniorbytes(key, bytes), msg=msg, digestmod=digestmod).digest()\n        sig_check = uniorbytes(b64encode(sig_check), bytes)\n        if lscmp(sig[1:], sig_check):\n            return json.loads(uniorbytes(b64decode(msg)))\n        return None\n    except:\n        # Encode and sign a json-able object. Return a string.\n        key = (\"{}{}\").format(secret, key_salt)\n        msg = b64encode(uniorbytes(json.dumps(data), bytes))\n        sig = hmac.new(\n            key=uniorbytes(key, bytes), msg=msg,\n            digestmod=digestmod).digest()\n        sig = uniorbytes(b64encode(sig), bytes)\n        return uniorbytes('!'.encode() + sig + '?'.encode() + msg)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef strkey(val, chaffify=1, keyspace=string.ascii_letters + string.digits):\n    chaffify = chaffify or 1\n    keylen = len(keyspace)\n    try:\n        # INT TO STRING\n        if val < 0:\n            raise ValueError(\"Input value must be greater than -1.\")\n\n        # chaffify the value\n        val = val * chaffify\n\n        if val == 0:\n            return keyspace[0]\n\n        # output the new string value\n        out = []\n        out_add = out.append\n        \n        while val > 0:\n            val, digit = divmod(val, keylen)\n            out_add(keyspace[digit])\n\n        return \"\".join(out)[::-1]\n    except TypeError:\n        # STRING TO INT\n        out = 0\n        val = str(val)\n        find = str.find\n        for c in val:\n            out = out * keylen + find(keyspace, c)\n        # dechaffify the value\n        out = out // chaffify\n        return int(out)", "response": "Converts an integer to a sequence of strings and reverse."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef chars_in(bits, keyspace):\n    keyspace = len(keyspace)\n    if keyspace < 2:\n        raise ValueError(\"Keyspace size must be >1\")\n    bits_per_cycle = 512\n    if bits > bits_per_cycle:\n        chars = 0\n        bits_processed = 0\n        cycles = ceil(bits / bits_per_cycle)\n        for _ in range(int(cycles)):\n            if bits_processed + bits_per_cycle > bits:\n                bits_per_cycle = bits - bits_processed\n            chars += calc_chars_in(bits_per_cycle, keyspace)\n            bits_processed += bits_per_cycle\n    else:\n        chars = calc_chars_in(bits, keyspace)\n    return abs(chars)", "response": "Calculates the number of characters in a keyspace given the number of bits of entropy given the keyspace."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bits_in(length, keyspace):\n    keyspace = len(keyspace)\n    length_per_cycle = 64\n    if length > length_per_cycle:\n        bits = 0\n        length_processed = 0\n        cycles = ceil(length / length_per_cycle)\n        for _ in range(int(cycles)):\n            if length_processed + length_per_cycle > length:\n                length_per_cycle = length - length_processed\n            bits += calc_bits_in(length_per_cycle, keyspace)\n            length_processed += length_per_cycle\n    else:\n        bits = calc_bits_in(length, keyspace)\n    return float(abs(bits))", "response": "Calculates the number of bits of entropy in a given length of a given keyspace."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield a cryptographically secure random key of desired bits of entropy of the keyspace.", "response": "def iter_random_chars(bits,\n                      keyspace=string.ascii_letters + string.digits + '#/.',\n                      rng=None):\n    \"\"\" Yields a cryptographically secure random key of desired @bits of\n        entropy within @keyspace using :class:random.SystemRandom\n\n        @bits: (#int) minimum bits of entropy\n        @keyspace: (#str) or iterable allowed output chars\n\n        ..\n            from vital.security import iter_rand\n\n            for char in iter_rand(512):\n                do_something_with(char)\n    \"\"\"\n    if bits < 8:\n        raise ValueError('Bits cannot be <8')\n    else:\n        chars = chars_in(bits, keyspace)\n    rng = rng or random.SystemRandom()\n    for char in range(int(ceil(chars))):\n        yield rng.choice(keyspace)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a cryptographically secure random key of desired bits of entropy within a keyspace.", "response": "def randkey(bits, keyspace=string.ascii_letters + string.digits + '#/.',\n            rng=None):\n    \"\"\" Returns a cryptographically secure random key of desired @bits of\n        entropy within @keyspace using :class:random.SystemRandom\n\n        @bits: (#int) minimum bits of entropy\n        @keyspace: (#str) or iterable allowed output chars\n        @rng: the random number generator to use. Defaults to\n            :class:random.SystemRandom. Must have a |choice| method\n\n        -> (#str) random key\n\n        ..\n            from vital.security import randkey\n\n            randkey(24)\n            # -> '9qaX'\n            randkey(48)\n            # -> 'iPJ5YWs9'\n            randkey(64)\n            # - > 'C..VJ.KLdxg'\n            randkey(64, keyspace=\"abc\", rng=random)\n            # -> 'aabcccbabcaacaccccabcaabbabcacabacbbbaaab'\n        ..\n    \"\"\"\n    return \"\".join(char for char in iter_random_chars(bits, keyspace, rng))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef randstr(size, keyspace=string.ascii_letters + string.digits, rng=None):\n    rng = rng or random.SystemRandom()\n    return \"\".join(rng.choice(keyspace) for char in range(int(ceil(size))))", "response": "Returns a cryptographically secure random string of desired size within a keyspace."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_requirements(filename):\n    lineiter = (line.strip() for line in open(filename))\n    return (line for line in lineiter if line and not line.startswith(\"#\"))", "response": "load a pip requirements file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nround a floating point number x to n significant figures", "response": "def round_sig(x, n, scien_notation = False):\n    if x < 0:\n        x = x * -1\n        symbol = '-'\n    else:\n        symbol = ''\n    \n    \n    '''round floating point x to n significant figures'''\n    if type(n) is not types.IntType:\n        raise TypeError, \"n must be an integer\"\n    try:\n        x = float(x)\n    except:\n        raise TypeError, \"x must be a floating point object\"\n    form = \"%0.\" + str(n-1) + \"e\"\n    st = form % x\n    num,expo = epat.findall(st)[0]\n    expo = int(expo)\n    fs = string.split(num,'.')\n    if len(fs) < 2:\n        fs = [fs[0],\"\"]\n    if expo == 0:\n#         print 'One', num\n        return symbol + num\n    elif expo > 0:\n        if len(fs[1]) < expo:\n            fs[1] += \"0\"*(expo-len(fs[1]))\n        st = fs[0]+fs[1][0:expo]\n        if len(fs[1][expo:]) > 0:\n            st += '.'+fs[1][expo:]\n#         print 'Two', st\n        return symbol + st\n    else:\n        expo = -expo\n        if fs[0][0] == '-':\n            fs[0] = fs[0][1:]\n            sign = \"-\"\n        else:\n            sign = \"\"\n            \n        if scien_notation:\n            coso = float(sign+\"0.\"+\"0\"*(expo-1)+fs[0]+fs[1])\n            scient_format = '{:.' + str(n) + 'e}'\n            StrScientific = scient_format.format(coso)\n#             print 'three', StrScientific\n            return symbol + StrScientific\n        \n        else:\n            formated = sign+\"0.\"+\"0\"*(expo-1)+fs[0]+fs[1]\n            if len(formated) > (n+5):\n                formated = '0.' + '0' * n\n#             print 'cuantro', formated\n            return symbol + formated"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef round_sig_error(x, ex, n, paren=False):\n    '''Find ex rounded to n sig-figs and make the floating point x\n    match the number of decimals.  If [paren], the string is\n    returned as quantity(error) format'''\n    stex = round_sig(ex,n)\n    if stex.find('.') < 0:\n        extra_zeros = len(stex) - n\n        sigfigs = len(str(int(x))) - extra_zeros\n        stx = round_sig(x,sigfigs)\n    else:\n        num_after_dec = len(string.split(stex,'.')[1])\n        stx = (\"%%.%df\" % num_after_dec) % (x)\n    if paren:\n        if stex.find('.') >= 0:\n            stex = stex[stex.find('.')+1:]\n        return \"%s(%s)\" % (stx,stex)\n    return stx,stex", "response": "Find ex rounded to n sig - figs and make the floating point x\n    match the number of decimals."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nformat a table such that the errors have n significant figures.", "response": "def format_table(cols, errors, n, labels=None, headers=None, latex=False):\n    '''Format a table such that the errors have n significant\n    figures.  [cols] and [errors] should be a list of 1D arrays\n    that correspond to data and errors in columns.  [n] is the number of\n    significant figures to keep in the errors.  [labels] is an optional\n    column of strings that will be in the first column.  [headers] is\n    an optional list of column headers.  If [latex] is true, myformat\n    the table so that it can be included in a LaTeX table '''\n    if len(cols) != len(errors):\n        raise ValueError, \"Error:  cols and errors must have same length\"\n    \n    ncols = len(cols)\n    nrows = len(cols[0])\n    \n    if headers is not None:\n        if labels is not None:\n            if len(headers) == ncols:\n                headers = [\"\"] + headers\n            elif len(headers) == ncols+1:\n                pass\n            else:\n                raise ValueError, \"length of headers should be %d\" % (ncols+1)\n        else:\n            if len(headers) != ncols:\n                raise ValueError, \"length of headers should be %d\" % (ncols)\n    \n    if labels is not None:\n        if len(labels) != nrows:\n            raise ValueError, \"length of labels should be %d\" % (nrows)\n    \n    strcols = []\n    for col,error in zip(cols,errors):\n        strcols.append([])\n        strcols.append([])\n        for i in range(nrows):\n            val,err = round_sig_error(col[i], error[i], n)\n            strcols[-2].append(val)\n            strcols[-1].append(err)\n    \n    lengths = [max([len(item) for item in strcol]) for strcol in strcols]\n    myformat = \"\"\n    if labels is not None:\n        myformat += \"%%%ds \" % (max(map(len, labels)))\n        if latex:\n            myformat += \"& \"\n    for length in lengths: \n        myformat += \"%%%ds \" % (length)\n        if latex:\n            myformat += \"& \"\n    if latex:\n        myformat = myformat[:-2] + \" \\\\\\\\\"\n    output = []\n    if headers:\n        if labels:\n            hs = [headers[0]]\n            for head in headers[1:]:\n                hs.append(head)\n                hs.append('+/-')\n        else:\n            hs = []\n            for head in headers:\n                hs.append(head)\n                hs.append('+/-')\n        output.append(myformat % tuple(hs))\n    for i in range(nrows):\n        if labels is not None:\n            output.append(myformat % tuple([labels[i]] + [strcol[i] for strcol in strcols]))\n        else:\n            output.append(myformat % tuple([strcol[i] for strcol in strcols]))\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds the min max and min error and make the floating point x and max ( ex ex1 ex2 match the number of decimals.", "response": "def round_sig_error2(x, ex1, ex2, n):\n    '''Find min(ex1,ex2) rounded to n sig-figs and make the floating point x\n    and max(ex,ex2) match the number of decimals.'''\n    minerr = min(ex1,ex2)\n    minstex = round_sig(minerr,n)\n    if minstex.find('.') < 0:\n        extra_zeros = len(minstex) - n\n        sigfigs = len(str(int(x))) - extra_zeros\n        stx = round_sig(x,sigfigs)\n        maxstex = round_sig(max(ex1,ex2),sigfigs)\n    else:\n        num_after_dec = len(string.split(minstex,'.')[1])\n        stx = (\"%%.%df\" % num_after_dec) % (x)\n        maxstex = (\"%%.%df\" % num_after_dec) % (max(ex1,ex2))\n    if ex1 < ex2:\n        return stx,minstex,maxstex\n    else:\n        return stx,maxstex,minstex"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend data to all available Azure threads.", "response": "def send_to_azure_multi_threads(instance, data, nb_threads=4, replace=True, types=None, primary_key=(),\n                                sub_commit=False):\n    \"\"\"\n    data = {\n        \"table_name\" \t: 'name_of_the_azure_schema' + '.' + 'name_of_the_azure_table' #Must already exist,\n        \"columns_name\" \t: [first_column_name,second_column_name,...,last_column_name],\n        \"rows\"\t\t: [[first_raw_value,second_raw_value,...,last_raw_value],...]\n    }\n    \"\"\"\n\n    # Time initialization\n    start = datetime.datetime.now()\n\n    # Extract info\n    table_name = data[\"table_name\"]\n    columns_name = data[\"columns_name\"]\n    rows = data[\"rows\"]\n    total_len_data = len(rows)\n\n    # Create table if needed\n    if not existing_test(instance, table_name) or (types is not None) or (primary_key != ()):\n        create.create_table(instance, data, primary_key, types)\n\n    # Clean table if needed\n    if replace:\n        cleaning_function(instance, table_name)\n\n    # Define batch size\n    batch_size = int(total_len_data / nb_threads) + 1\n    if total_len_data < nb_threads:\n        batch_size = 1\n\n    # Get table info\n    table_info = get_table_info(instance, table_name)\n\n    # Split data in batches of batch_size length\n    split_data = []\n\n    # global threads_state\n    # threads_state = {}\n\n    for i in range(nb_threads):\n        batch = create_a_batch(rows, batch_size, i)\n        split_data.append(\n            {\n                \"data\":\n                    {\n                        \"table_name\": table_name,\n                        \"columns_name\": columns_name,\n                        \"rows\": batch\n                    },\n                \"instance\": instance,\n                \"thread_number\": i,\n                \"nb_threads\": nb_threads,\n                \"sub_commit\": sub_commit,\n                \"table_info\": table_info,\n            }\n        )\n        write_in_file(\"threads_state_%s\" % str(i), str({\n            \"iteration\": 0,\n            \"total\": len(batch)\n        }))\n\n    with concurrent.futures.ProcessPoolExecutor() as executor:\n        r = list(executor.map(send_to_azure_from_one_thread, split_data))\n\n    print()\n    for num_thread in range(nb_threads):\n        insert_query = \"INSERT INTO %s SELECT * FROM %s\" % (table_name, table_name + \"_\" + str(num_thread))\n        print(insert_query)\n        execute_query(instance, insert_query)\n\n    for num_thread in range(nb_threads):\n        sub_table = table_name + \"_\" + str(num_thread)\n        print(C.HEADER + \"DROP TABLE %s...\" % sub_table + C.ENDC)\n        execute_query(instance, \"DROP TABLE %s\" % sub_table)\n        print(C.HEADER + \"DROP TABLE %s...OK\" % sub_table + C.ENDC)\n\n    total_length_data = 0\n    for element in split_data:\n        total_length_data = total_length_data + len(element[\"data\"][\"rows\"])\n\n    for i in range(len(r)):\n        print(\"Thread %s : %s seconds\" % (str(i), str(r[i])))\n\n    print(\"Total rows: %s\" % str(total_length_data))\n    print(C.BOLD + \"Total time in seconds : %s\" % str((datetime.datetime.now() - start).seconds) + C.ENDC)\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends data to Azure.", "response": "def send_to_azure(instance, data, thread_number, sub_commit, table_info, nb_threads):\n    \"\"\"\n    data = {\n        \"table_name\" \t: 'name_of_the_azure_schema' + '.' + 'name_of_the_azure_table' #Must already exist,\n        \"columns_name\" \t: [first_column_name,second_column_name,...,last_column_name],\n        \"rows\"\t\t: [[first_raw_value,second_raw_value,...,last_raw_value],...]\n    }\n    \"\"\"\n\n    rows = data[\"rows\"]\n    if not rows:\n        return 0\n    columns_name = data[\"columns_name\"]\n    table_name = data[\"table_name\"] + \"_\" + str(thread_number)\n\n    print(C.HEADER + \"Create table %s...\" % table_name + C.ENDC)\n    create_table_from_info(instance, table_info, table_name)\n    print(C.OKGREEN + \"Create table %s...OK\" % table_name + C.ENDC)\n    small_batch_size = int(2099 / len(columns_name))\n\n    cnxn = connect(instance)\n    cursor = cnxn.cursor()\n\n    # Initialize counters\n    boolean = True\n    total_rows = len(rows)\n    question_mark_pattern = \"(%s)\" % \",\".join([\"?\" for i in range(len(rows[0]))])\n    counter = 0\n    while boolean:\n        temp_row = []\n        question_mark_list = []\n        for i in range(small_batch_size):\n            if rows:\n                temp_row.append(rows.pop())\n                question_mark_list.append(question_mark_pattern)\n            else:\n                boolean = False\n                continue\n        counter = counter + len(temp_row)\n        # percent = round(float(counter * 100) / total_rows)\n        threads_state = eval(read_file(\"threads_state_%s\" % str(thread_number)))\n        threads_state[\"iteration\"] = counter\n        write_in_file(\"threads_state_%s\" % str(thread_number), str(threads_state))\n\n        # print(threads_state)\n        if sub_commit:\n            suffix = \"rows sent\"\n            # print(\"Thread %s : %s %% rows sent\" % (str(thread_number), str(percent)))\n        else:\n            suffix = \"rows prepared to be sent\"\n        print_progress_bar_multi_threads(nb_threads, suffix=suffix)\n        # print(\"Thread %s : %s %% rows prepared to be sent\" % (str(thread_number), str(percent)))\n        data_values_str = ','.join(question_mark_list)\n        columns_name_str = \", \".join(columns_name)\n        inserting_request = '''INSERT INTO %s (%s) VALUES %s ;''' % (table_name, columns_name_str, data_values_str)\n\n        final_data = [y for x in temp_row for y in x]\n        if final_data:\n            cursor.execute(inserting_request, final_data)\n\n        if sub_commit:\n            commit_function(cnxn)\n    if not sub_commit:\n        commit_function(cnxn)\n    cursor.close()\n    cnxn.close()\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, items=[], taxes=[], custom_data=[]):\n        self.add_items(items)\n        self.add_taxes(taxes)\n        self.add_custom_data(custom_data)\n        return self._process('checkout-invoice/create', self._prepare_data)", "response": "Adds the items to the invoice"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef confirm(self, token=None):\n        _token = token if token else self._response.get(\"token\")\n        return self._process('checkout-invoice/confirm/' + str(_token))", "response": "Returns the status of the invoice"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_taxes(self, taxes):\n        # fixme: how to resolve duplicate tax names\n        _idx = len(self.taxes)  # current index to prevent overwriting\n        for idx, tax in enumerate(taxes):\n            tax_key = \"tax_\" + str(idx + _idx)\n            self.taxes[tax_key] = {\"name\": tax[0], \"amount\": tax[1]}", "response": "Appends the data to the taxes key in the request object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_item(self, item):\n        _idx = len(self.items)\n        self.items.update({\"item_\" + str(_idx + 1): item})", "response": "Adds an item to the list of items in the current transaction"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _prepare_data(self):\n        total_amount = self.total_amount or self.calculate_total_amt()\n        self._data = {\n            \"invoice\": {\n                \"items\": self.__encode_items(self.items),\n                \"taxes\": self.taxes,\n                \"total_amount\": total_amount,\n                \"description\": self.description,\n                \"channels\": self.channels\n            },\n            \"store\": self.store.info,\n            \"custom_data\": self.custom_data,\n            \"actions\": {\n                \"cancel_url\": self.cancel_url,\n                \"return_url\": self.return_url,\n                \"callback_url\": self.callback_url\n            }\n        }\n        return self._data", "response": "Formats the data in the current transaction for processing"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calculate_total_amt(self, items={}):\n        _items = items.items() or self.items.items()\n        return sum(float(x[1].total_price) for x in _items)", "response": "Returns the total amount of items in the current invoice"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __encode_items(self, items):\n        xs = [item._asdict() for (_key, item) in items.items()]\n        return list(map(lambda x: dict(zip(x.keys(), x.values())), xs))", "response": "Encodes the InvoiceItems into a JSON serializable format"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_deployment_home(self):\n        log = logging.getLogger(self.cls_logger + '.set_deployment_home')\n        try:\n            self.deployment_home = os.environ['DEPLOYMENT_HOME']\n        except KeyError:\n            log.warn('DEPLOYMENT_HOME environment variable is not set, attempting to set it...')\n        else:\n            log.info('Found DEPLOYMENT_HOME environment variable set to: {d}'.format(d=self.deployment_home))\n            return\n\n        if self.cons3rt_agent_run_dir is None:\n            msg = 'This is not Windows nor Linux, cannot determine DEPLOYMENT_HOME'\n            log.error(msg)\n            raise DeploymentError(msg)\n\n        # Ensure the run directory can be found\n        if not os.path.isdir(self.cons3rt_agent_run_dir):\n            msg = 'Could not find the cons3rt run directory, DEPLOYMENT_HOME cannot be set'\n            log.error(msg)\n            raise DeploymentError(msg)\n\n        run_dir_contents = os.listdir(self.cons3rt_agent_run_dir)\n        results = []\n        for item in run_dir_contents:\n            if 'Deployment' in item:\n                results.append(item)\n        if len(results) != 1:\n            msg = 'Could not find deployment home in the cons3rt run directory, deployment home cannot be set'\n            log.error(msg)\n            raise DeploymentError(msg)\n\n        # Ensure the Deployment Home is a directory\n        candidate_deployment_home = os.path.join(self.cons3rt_agent_run_dir, results[0])\n        if not os.path.isdir(candidate_deployment_home):\n            msg = 'The candidate deployment home is not a valid directory: {d}'.format(d=candidate_deployment_home)\n            log.error(msg)\n            raise DeploymentError(msg)\n\n        # Ensure the deployment properties file can be found\n        self.deployment_home = candidate_deployment_home\n        os.environ['DEPLOYMENT_HOME'] = self.deployment_home\n        log.info('Set DEPLOYMENT_HOME in the environment to: {d}'.format(d=self.deployment_home))", "response": "Sets the deployment home for the cons3rt agent run directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread the deployment properties file into the properties dictionary.", "response": "def read_deployment_properties(self):\n        \"\"\"Reads the deployment properties file\n\n        This method reads the deployment properties file into the\n        \"properties\" dictionary object.\n\n        :return: None\n        :raises: DeploymentError\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.read_deployment_properties')\n\n        # Ensure deployment properties file exists\n        self.properties_file = os.path.join(self.deployment_home, 'deployment.properties')\n        if not os.path.isfile(self.properties_file):\n            msg = 'Deployment properties file not found: {f}'.format(f=self.properties_file)\n            log.error(msg)\n            raise DeploymentError(msg)\n        log.info('Found deployment properties file: {f}'.format(f=self.properties_file))\n\n        log.info('Reading deployment properties...')\n        try:\n            f = open(self.properties_file)\n        except (IOError, OSError):\n            _, ex, trace = sys.exc_info()\n            msg = 'Could not open file {file} to read property: {prop}'.format(\n                file=self.properties_file,\n                prop=property)\n            log.error(msg)\n            raise DeploymentError, msg, trace\n\n        for line in f:\n            log.debug('Processing deployment properties file line: {l}'.format(l=line))\n            if not isinstance(line, basestring):\n                log.debug('Skipping line that is not a string: {l}'.format(l=line))\n                continue\n            elif line.startswith('#'):\n                log.debug('Skipping line that is a comment: {l}'.format(l=line))\n                continue\n            elif '=' in line:\n                split_line = line.strip().split('=', 1)\n                if len(split_line) == 2:\n                    prop_name = split_line[0].strip()\n                    prop_value = split_line[1].strip()\n                    if prop_name is None or not prop_name or prop_value is None or not prop_value:\n                        log.debug('Property name <{n}> or value <v> is none or blank, not including it'.format(\n                                n=prop_name, v=prop_value))\n                    else:\n                        log.debug('Adding property {n} with value {v}...'.format(n=prop_name, v=prop_value))\n                        self.properties[prop_name] = prop_value\n                else:\n                    log.debug('Skipping line that did not split into 2 part on an equal sign...')\n        log.info('Successfully read in deployment properties')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the name of a specific property This public method is passed a regular expression and returns the matching property name. If either the property is not found or if the passed string matches more than one property, this function will return None. :param regex: Regular expression to search on :return: (str) Property name matching the passed regex or None.", "response": "def get_property(self, regex):\n        \"\"\"Gets the name of a specific property\n\n        This public method is passed a regular expression and\n        returns the matching property name. If either the property\n        is not found or if the passed string matches more than one\n        property, this function will return None.\n\n        :param regex: Regular expression to search on\n        :return: (str) Property name matching the passed regex or None.\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.get_property')\n\n        if not isinstance(regex, basestring):\n            log.error('regex arg is not a string found type: {t}'.format(t=regex.__class__.__name__))\n            return None\n\n        log.debug('Looking up property based on regex: {r}'.format(r=regex))\n        prop_list_matched = []\n        for prop_name in self.properties.keys():\n            match = re.search(regex, prop_name)\n            if match:\n                prop_list_matched.append(prop_name)\n        if len(prop_list_matched) == 1:\n            log.debug('Found matching property: {p}'.format(p=prop_list_matched[0]))\n            return prop_list_matched[0]\n        elif len(prop_list_matched) > 1:\n            log.debug('Passed regex {r} matched more than 1 property, checking for an exact match...'.format(r=regex))\n            for matched_prop in prop_list_matched:\n                if matched_prop == regex:\n                    log.debug('Found an exact match: {p}'.format(p=matched_prop))\n                    return matched_prop\n            log.debug('Exact match not found for regex {r}, returning None'.format(r=regex))\n            return None\n        else:\n            log.debug('Passed regex did not match any deployment properties: {r}'.format(r=regex))\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of property names matching the provided regular expression", "response": "def get_matching_property_names(self, regex):\n        \"\"\"Returns a list of property names matching the provided\n        regular expression\n\n        :param regex: Regular expression to search on\n        :return: (list) of property names matching the regex\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.get_matching_property_names')\n        prop_list_matched = []\n        if not isinstance(regex, basestring):\n            log.warn('regex arg is not a string, found type: {t}'.format(t=regex.__class__.__name__))\n            return prop_list_matched\n        log.debug('Finding properties matching regex: {r}'.format(r=regex))\n        for prop_name in self.properties.keys():\n            match = re.search(regex, prop_name)\n            if match:\n                prop_list_matched.append(prop_name)\n        return prop_list_matched"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the value associated to the passed property_name or None if the property is not found.", "response": "def get_value(self, property_name):\n        \"\"\"Returns the value associated to the passed property\n\n        This public method is passed a specific property as a string\n        and returns the value of that property. If the property is not\n        found, None will be returned.\n\n        :param property_name (str) The name of the property\n        :return: (str) value for the passed property, or None.\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.get_value')\n        if not isinstance(property_name, basestring):\n            log.error('property_name arg is not a string, found type: {t}'.format(t=property_name.__class__.__name__))\n            return None\n        # Ensure a property with that name exists\n        prop = self.get_property(property_name)\n        if not prop:\n            log.debug('Property name not found matching: {n}'.format(n=property_name))\n            return None\n        value = self.properties[prop]\n        log.debug('Found value for property {n}: {v}'.format(n=property_name, v=value))\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_cons3rt_role_name(self):\n        log = logging.getLogger(self.cls_logger + '.set_cons3rt_role_name')\n        try:\n            self.cons3rt_role_name = os.environ['CONS3RT_ROLE_NAME']\n        except KeyError:\n            log.warn('CONS3RT_ROLE_NAME is not set, attempting to determine it from deployment properties...')\n\n            if platform.system() == 'Linux':\n                log.info('Attempting to determine CONS3RT_ROLE_NAME on Linux...')\n                try:\n                    self.determine_cons3rt_role_name_linux()\n                except DeploymentError:\n                    raise\n            else:\n                log.warn('Unable to determine CONS3RT_ROLE_NAME on this System')\n\n        else:\n            log.info('Found environment variable CONS3RT_ROLE_NAME: {r}'.format(r=self.cons3rt_role_name))\n            return", "response": "Set the cons3rt_role_name member for this system"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef determine_cons3rt_role_name_linux(self):\n        log = logging.getLogger(self.cls_logger + '.determine_cons3rt_role_name_linux')\n\n        # Determine IP addresses for this system\n        log.info('Determining the IPv4 addresses for this system...')\n        try:\n            ip_addresses = get_ip_addresses()\n        except CommandError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to get the IP address of this system, thus cannot determine the ' \\\n                  'CONS3RT_ROLE_NAME\\n{e}'.format(e=str(ex))\n            log.error(msg)\n            raise DeploymentError, msg, trace\n        else:\n            log.info('Found IP addresses: {a}'.format(a=ip_addresses))\n\n        log.info('Trying to determine IP address for eth0...')\n        try:\n            ip_address = ip_addresses['eth0']\n        except KeyError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Unable to determine the IP address for eth0. Found the ' \\\n                  'following IP addresses: {i}\\n{e}'.format(i=ip_addresses,\n                                                            e=str(ex))\n            log.error(msg)\n            raise DeploymentError, msg, trace\n        else:\n            log.info('Found IP address for eth0: {i}'.format(i=ip_address))\n\n        pattern = '^cons3rt\\.fap\\.deployment\\.machine.*0.internalIp=' + ip_address + '$'\n        try:\n            f = open(self.properties_file)\n        except IOError:\n            _, ex, trace = sys.exc_info()\n            msg = 'Could not open file {f}'.format(f=self.properties_file)\n            log.error(msg)\n            raise DeploymentError, msg, trace\n        prop_list_matched = []\n        log.debug('Searching for deployment properties matching pattern: {p}'.format(p=pattern))\n        for line in f:\n            log.debug('Processing deployment properties file line: {l}'.format(l=line))\n            if line.startswith('#'):\n                continue\n            elif '=' in line:\n                match = re.search(pattern, line)\n                if match:\n                    log.debug('Found matching prop: {l}'.format(l=line))\n                    prop_list_matched.append(line)\n        log.debug('Number of matching properties found: {n}'.format(n=len(prop_list_matched)))\n        if len(prop_list_matched) == 1:\n            prop_parts = prop_list_matched[0].split('.')\n            if len(prop_parts) > 5:\n                self.cons3rt_role_name = prop_parts[4]\n                log.info('Found CONS3RT_ROLE_NAME from deployment properties: {c}'.format(c=self.cons3rt_role_name))\n                log.info('Adding CONS3RT_ROLE_NAME to the current environment...')\n                os.environ['CONS3RT_ROLE_NAME'] = self.cons3rt_role_name\n                return\n            else:\n                log.error('Property found was not formatted as expected: %s',\n                          prop_parts)\n        else:\n            log.error('Did not find a unique matching deployment property')\n        msg = 'Could not determine CONS3RT_ROLE_NAME from deployment properties'\n        log.error(msg)\n        raise DeploymentError(msg)", "response": "Determines the cons3rt_role_name member for this Linux system and sets the cons3rt_role_name member for this Linux system."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the ASSET_DIR environment variable for the the current asset install.", "response": "def set_asset_dir(self):\n        \"\"\"Returns the ASSET_DIR environment variable\n\n        This method gets the ASSET_DIR environment variable for the\n        current asset install. It returns either the string value if\n        set or None if it is not set.\n\n        :return: None\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.get_asset_dir')\n        try:\n            self.asset_dir = os.environ['ASSET_DIR']\n        except KeyError:\n            log.warn('Environment variable ASSET_DIR is not set!')\n        else:\n            log.info('Found environment variable ASSET_DIR: {a}'.format(a=self.asset_dir))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npopulating the list of scenario role names in this deployment and extracts the master role name and the scenario master role name.", "response": "def set_scenario_role_names(self):\n        \"\"\"Populates the list of scenario role names in this deployment and\n        populates the scenario_master with the master role\n\n        Gets a list of deployment properties containing \"isMaster\" because\n        there is exactly one per scenario host, containing the role name\n\n        :return:\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.set_scenario_role_names')\n        is_master_props = self.get_matching_property_names('isMaster')\n        for is_master_prop in is_master_props:\n            role_name = is_master_prop.split('.')[-1]\n            log.info('Adding scenario host: {n}'.format(n=role_name))\n            self.scenario_role_names.append(role_name)\n\n            # Determine if this is the scenario master\n            is_master = self.get_value(is_master_prop).lower().strip()\n            if is_master == 'true':\n                log.info('Found master scenario host: {r}'.format(r=role_name))\n                self.scenario_master = role_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_scenario_network_info(self):\n        log = logging.getLogger(self.cls_logger + '.set_scenario_network_info')\n\n        for scenario_host in self.scenario_role_names:\n            scenario_host_network_info = {'scenario_role_name': scenario_host}\n            log.debug('Looking up network info from deployment properties for scenario host: {s}'.format(\n                s=scenario_host))\n            network_name_props = self.get_matching_property_names(\n                'cons3rt.fap.deployment.machine.*{r}.*networkName'.format(r=scenario_host)\n            )\n            log.debug('Found {n} network name props'.format(n=str(len(network_name_props))))\n\n            network_info_list = []\n            for network_name_prop in network_name_props:\n                network_info = {}\n                network_name = self.get_value(network_name_prop)\n                if not network_name:\n                    log.debug('Network name not found for prop: {n}'.format(n=network_name_prop))\n                    continue\n                log.debug('Adding info for network name: {n}'.format(n=network_name))\n                network_info['network_name'] = network_name\n                interface_name_prop = 'cons3rt.fap.deployment.machine.{r}.{n}.interfaceName'.format(\n                    r=scenario_host, n=network_name)\n                interface_name = self.get_value(interface_name_prop)\n                if interface_name:\n                    network_info['interface_name'] = interface_name\n                external_ip_prop = 'cons3rt.fap.deployment.machine.{r}.{n}.externalIp'.format(\n                    r=scenario_host, n=network_name)\n                external_ip = self.get_value(external_ip_prop)\n                if external_ip:\n                    network_info['external_ip'] = external_ip\n                internal_ip_prop = 'cons3rt.fap.deployment.machine.{r}.{n}.internalIp'.format(\n                    r=scenario_host, n=network_name)\n                internal_ip = self.get_value(internal_ip_prop)\n                if internal_ip:\n                    network_info['internal_ip'] = internal_ip\n                is_cons3rt_connection_prop = 'cons3rt.fap.deployment.machine.{r}.{n}.isCons3rtConnection'.format(\n                    r=scenario_host, n=network_name)\n                is_cons3rt_connection = self.get_value(is_cons3rt_connection_prop)\n                if is_cons3rt_connection:\n                    if is_cons3rt_connection.lower().strip() == 'true':\n                        network_info['is_cons3rt_connection'] = True\n                    else:\n                        network_info['is_cons3rt_connection'] = False\n                mac_address_prop = 'cons3rt.fap.deployment.machine.{r}.{n}.mac'.format(r=scenario_host, n=network_name)\n                mac_address = self.get_value(mac_address_prop)\n                if mac_address:\n                    # Trim the escape characters from the mac address\n                    mac_address = mac_address.replace('\\\\', '')\n                    network_info['mac_address'] = mac_address\n                log.debug('Found network info: {n}'.format(n=str(network_info)))\n                network_info_list.append(network_info)\n            scenario_host_network_info['network_info'] = network_info_list\n            self.scenario_network_info.append(scenario_host_network_info)", "response": "Populates a list of network info for each scenario host from the deployment properties\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_deployment_name(self):\n        log = logging.getLogger(self.cls_logger + '.set_deployment_name')\n        self.deployment_name = self.get_value('cons3rt.deployment.name')\n        log.info('Found deployment name: {n}'.format(n=self.deployment_name))", "response": "Sets the deployment name from deployment properties\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the deployment ID from deployment properties", "response": "def set_deployment_id(self):\n        \"\"\"Sets the deployment ID from deployment properties\n\n        :return: None\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.set_deployment_id')\n        deployment_id_val = self.get_value('cons3rt.deployment.id')\n        if not deployment_id_val:\n            log.debug('Deployment ID not found in deployment properties')\n            return\n        try:\n            deployment_id = int(deployment_id_val)\n        except ValueError:\n            log.debug('Deployment ID found was unable to convert to an int: {d}'.format(d=deployment_id_val))\n            return\n        self.deployment_id = deployment_id\n        log.info('Found deployment ID: {i}'.format(i=str(self.deployment_id)))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_deployment_run_name(self):\n        log = logging.getLogger(self.cls_logger + '.set_deployment_run_name')\n        self.deployment_run_name = self.get_value('cons3rt.deploymentRun.name')\n        log.info('Found deployment run name: {n}'.format(n=self.deployment_run_name))", "response": "Sets the deployment run name from deployment properties"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_deployment_run_id(self):\n        log = logging.getLogger(self.cls_logger + '.set_deployment_run_id')\n        deployment_run_id_val = self.get_value('cons3rt.deploymentRun.id')\n        if not deployment_run_id_val:\n            log.debug('Deployment run ID not found in deployment properties')\n            return\n        try:\n            deployment_run_id = int(deployment_run_id_val)\n        except ValueError:\n            log.debug('Deployment run ID found was unable to convert to an int: {d}'.format(d=deployment_run_id_val))\n            return\n        self.deployment_run_id = deployment_run_id\n        log.info('Found deployment run ID: {i}'.format(i=str(self.deployment_run_id)))", "response": "Sets the deployment run ID from deployment properties"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_virtualization_realm_type(self):\n        log = logging.getLogger(self.cls_logger + '.set_virtualization_realm_type')\n        self.virtualization_realm_type = self.get_value('cons3rt.deploymentRun.virtRealm.type')\n        log.info('Found virtualization realm type : {t}'.format(t=self.virtualization_realm_type))", "response": "Sets the virtualization realm type from deployment properties\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_hosts_file(self, ip, entry):\n        log = logging.getLogger(self.cls_logger + '.update_hosts_file')\n\n        if get_os() in ['Linux', 'Darwin']:\n            update_hosts_file_linux(ip=ip, entry=entry)\n        elif get_os() == 'Windows':\n            update_hosts_file_windows(ip=ip, entry=entry)\n        else:\n            log.warn('OS detected was not Windows nor Linux')", "response": "Updates the hosts file depending on the OS and the IP address."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_scenario_hosts_file(self, network_name='user-net', domain_name=None):\n        log = logging.getLogger(self.cls_logger + '.set_scenario_hosts_file')\n\n        log.info('Scanning scenario hosts to make entries in the hosts file for network: {n}'.format(n=network_name))\n        for scenario_host in self.scenario_network_info:\n            if domain_name:\n                host_file_entry = '{r}.{d} {r}'.format(r=scenario_host['scenario_role_name'], d=domain_name)\n            else:\n                host_file_entry = scenario_host['scenario_role_name']\n            for host_network_info in scenario_host['network_info']:\n                if host_network_info['network_name'] == network_name:\n                    self.update_hosts_file(ip=host_network_info['internal_ip'], entry=host_file_entry)", "response": "Adds hosts file entries for each system in the scenario_hosts file for the specified network_name and domain_name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_hosts_file_entry_for_role(self, role_name, network_name='user-net', fqdn=None, domain_name=None):\n        log = logging.getLogger(self.cls_logger + '.set_hosts_file_entry_for_role')\n\n        # Determine the host file entry portion\n        if fqdn:\n            host_file_entry = fqdn\n        else:\n            if domain_name:\n                host_file_entry = '{r}.{d} {r}'.format(r=role_name, d=domain_name)\n            else:\n                host_file_entry = role_name\n        log.info('Using hosts file entry: {e}'.format(e=host_file_entry))\n        log.info('Scanning scenario hosts for role name [{r}] and network: {n}'.format(r=role_name, n=network_name))\n        for scenario_host in self.scenario_network_info:\n            if scenario_host['scenario_role_name'] == role_name:\n                for host_network_info in scenario_host['network_info']:\n                    if host_network_info['network_name'] == network_name:\n                        self.update_hosts_file(ip=host_network_info['internal_ip'], entry=host_file_entry)", "response": "Adds an entry to the hosts file for a scenario host given a role name and network name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a network name returns the IP address on the specified network or None if no IP address is found.", "response": "def get_ip_on_network(self, network_name):\n        \"\"\"Given a network name, returns the IP address\n\n        :param network_name: (str) Name of the network to search for\n        :return: (str) IP address on the specified network or None\n        \"\"\"\n        return self.get_scenario_host_ip_on_network(\n            scenario_role_name=self.cons3rt_role_name,\n            network_name=network_name\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_scenario_host_ip_on_network(self, scenario_role_name, network_name):\n        log = logging.getLogger(self.cls_logger + '.get_scenario_host_ip_on_network')\n\n        # Determine the network info for this host based on role name\n        cons3rt_network_info = None\n        for scenario_host in self.scenario_network_info:\n            if scenario_host['scenario_role_name'] == scenario_role_name:\n                cons3rt_network_info = scenario_host['network_info']\n        if not cons3rt_network_info:\n            log.warn('Unable to find network info for this host')\n            return\n\n        # Attempt to find a matching IP for network name\n        internal_ip = None\n        for cons3rt_network in cons3rt_network_info:\n            if cons3rt_network['network_name'] == network_name:\n                internal_ip = cons3rt_network['internal_ip']\n        if not internal_ip:\n            log.warn('Unable to find an internal IP for network: {n}'.format(n=network_name))\n            return\n        log.debug('Found IP address [{i}] for network name: {n}'.format(i=internal_ip, n=network_name))\n        return internal_ip", "response": "Given a network name returns the IP address on the specified network or None if no matching IP is found."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a cons3rt network name return the network interface name on this Linux system", "response": "def get_device_for_network_linux(self, network_name):\n        \"\"\"Given a cons3rt network name, return the network interface name\n        on this Linux system\n\n        :param network_name: (str) Name of the network to search for\n        :return: (str) name of the network interface device or None\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.get_device_for_network_linux')\n\n        if get_os() not in ['Linux']:\n            log.warn('Non-linux OS detected, returning...')\n            return\n\n        # Get the IP address for the network name according to cons3rt\n        ip_address = self.get_ip_on_network(network_name=network_name)\n        if not ip_address:\n            log.warn('IP address not found for network with name: {n}'.format(n=network_name))\n            return\n\n        # Get the system device names and ip addresses\n        sys_info = ip_addr()\n\n        # Check for a matching IP address\n        device_name = None\n        for device_name, sys_ip_address in sys_info.iteritems():\n            if sys_ip_address == ip_address:\n                log.debug('Found matching system IP [{i}] for device: {d}'.format(i=ip_address, d=device_name))\n\n        if not device_name:\n            log.warn('Network device not found with IP address {i} in system network data: {d}'.format(\n                i=ip_address, d=str(sys_info)))\n            return\n        log.debug('Found device name [{d}] with IP address [{i}] for network: {n}'.format(\n            d=device_name, i=ip_address, n=network_name))\n        return device_name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef require_auth(request: Request, exceptions: bool=True) -> User:\n    if not request.user or not request.user.is_authenticated:\n        if exceptions:\n            raise NotAuthenticated()\n        return None\n    return request.user", "response": "Returns authenticated User.\n    :param request: HttpRequest\n    :param exceptions: Raise (NotAuthenticated) exception. Default is True.\n    :return: User"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef insertSaneDefaults(self):\n\t\tself.raw.insert(0, '-A OUTPUT -o lo -j NOTRACK')\n\t\tself.raw.insert(1, '-A PREROUTING -i lo -j NOTRACK')\n\t\tself.filters.insert(0, '-A INPUT -i lo -j ACCEPT')\n\t\tself.filters.insert(1, '-A OUTPUT -o lo -j ACCEPT')\n\t\tself.filters.insert(2, '-A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT')\n\t\tself.filters.insert(3, '-A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT')\n\t\treturn self", "response": "Insert sane defaults rules into the raw and filter tables."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a DROP policy at the end of the rules.", "response": "def appendDefaultDrop(self):\n\t\t\"\"\" Add a DROP policy at the end of the rules \"\"\"\n\t\tself.filters.append('-A INPUT -j DROP')\n\t\tself.filters.append('-A OUTPUT -j DROP')\n\t\tself.filters.append('-A FORWARD -j DROP')\n\t\treturn self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a rules file in iptables - restore format", "response": "def template(self):\n\t\t\"\"\"\tCreate a rules file in iptables-restore format \"\"\"\n\t\ts = Template(self._IPTABLES_TEMPLATE)\n\t\treturn s.substitute(filtertable='\\n'.join(self.filters),\n\t\t\t\t\t\t\trawtable='\\n'.join(self.raw),\n\t\t\t\t\t\t\tmangletable='\\n'.join(self.mangle),\n\t\t\t\t\t\t\tnattable='\\n'.join(self.nat),\n\t\t\t\t\t\t\tdate=datetime.today())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a template that creates a rules file in ipset -- restore format", "response": "def template(self):\n\t\t\"\"\"\tCreate a rules file in ipset --restore format \"\"\"\n\t\ts = Template(self._IPSET_TEMPLATE)\n\t\treturn s.substitute(sets='\\n'.join(self.sets),\n\t\t\t\t\t\t\tdate=datetime.today())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getUserByNumber(self, base, uidNumber):\n\t\tres = self.query(base, \"uidNumber=\"+str(uidNumber), ['uid'])\n\t\tif len(res) > 1:\n\t\t\traise InputError(uidNumber, \"Multiple users found. Expecting one.\")\n\t\treturn res[0][0], res[0][1]['uid'][0]", "response": "search for a user in LDAP and return its DN and uid"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nquery LDAP to obtain the network ACLs of a given user and return the results in a dict of the form cn = description desc = description cn = cn", "response": "def getACLs(self, base, searchstr):\n\t\t\"\"\"\n\t\t\tQuery LDAP to obtain the network ACLs of a given user,\n\t\t\tparse the ACLs, and return the results in a dict of the form\n\t\t\tacls[group][cidr] = description\n\t\t\"\"\"\n\t\tacls = dict()\n\t\tres = self.query(base, searchstr, ['cn', 'ipHostNumber'])\n\t\tfor dn,attr in res:\n\t\t\tcn = attr['cn'][0]\n\t\t\tdests = dict()\n\t\t\tif attr.has_key('ipHostNumber'):\n\t\t\t\tfor entry in attr['ipHostNumber']:\n\t\t\t\t\tdest = entry.split('#', 1)[0].replace(\" \", \"\")\n\t\t\t\t\tif len(entry.split('#', 1)) == 2:\n\t\t\t\t\t\tdesc = entry.split('#', 1)[1].strip()\n\t\t\t\t\telse:\n\t\t\t\t\t\tdesc = \"\"\n\t\t\t\t\tif not is_ip(dest):\n\t\t\t\t\t\tprint dest, desc\n\t\t\t\t\t\traise InputError(dest, \"Invalid IP format\")\n\t\t\t\t\tdests[dest] = desc\n\t\t\tacls[cn] = dests\n\t\treturn acls"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef splitValues(textStr):\n    vals = textStr.split(\",\")\n    nums = []\n    for v in vals:\n        nums.append(float(v))\n    return nums", "response": "Splits a comma - separated number sequence into a list of floats."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexpands parameters into a new list where each element is a tuple containing two items of lists and symbolic names.", "response": "def expandParameters(*args):\n    \"\"\"Expands parameters (presented as tuples of lists and symbolic names)\n    so that each is returned in a new list where each contains the same number\n    of values.\n\n    Each `arg` is a tuple containing two items: a list of values and a\n    symbolic name.\n    \"\"\"\n    count = 1\n    for arg in args:\n        count = max(len(arg[0]), count)\n    results = []\n    for arg in args:\n        results.append(expandValues(arg[0], count, args[1]))\n    return tuple(results)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the input list with the length of count.", "response": "def expandValues(inputs, count, name):\n    \"\"\"Returns the input list with the length of `count`. If the\n    list is [1] and the count is 3. [1,1,1] is returned. The list\n    must be the count length or 1. Normally called from `expandParameters()`\n    where `name` is the symbolic name of the input.\n    \"\"\"\n    if len(inputs) == count:\n        expanded = inputs\n    elif len(inputs) == 1:\n        expanded = inputs * count\n    else:\n        raise ValueError('Incompatible number of values for ' + name)\n    return expanded"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting geo IP info from ipstack. com.", "response": "def get_geo_ip(ip: str, exceptions: bool=False, timeout: int=10) -> dict:\n    \"\"\"\n    Returns geo IP info or empty dict if geoip query fails at http://ipstack.com.\n    requires settings.IPSTACK_TOKEN set as valid access token to the API.\n\n    Example replies:\n    {'country_name': 'United States', 'country_code': 'US', 'region_code': 'TX', 'region_name': 'Texas', 'ip': '76.184.236.184', 'latitude': 33.1507, 'time_zone': 'America/Chicago', 'metro_code': 623, 'city': 'Frisco', 'longitude': -96.8236, 'zip_code': '75033'}\n    {'latitude': 60.1641, 'country_name': 'Finland', 'zip_code': '02920', 'region_name': 'Uusimaa', 'city': 'Espoo', 'metro_code': 0, 'ip': '194.100.27.41', 'time_zone': 'Europe/Helsinki', 'country_code': 'FI', 'longitude': 24.7136, 'region_code': '18'}\n\n    :param ip: str\n    :param exceptions: if True raises Exception on failure\n    :param timeout: timeout in seconds\n    :return: dict\n    \"\"\"\n    import requests\n    import traceback\n    try:\n        res = requests.get('http://api.ipstack.com/{}?access_key={}&format=1'.format(ip, settings.IPSTACK_TOKEN), timeout=timeout)\n        if res.status_code != 200:\n            if exceptions:\n                raise Exception('api.ipstack.com HTTP {}'.format(res.status_code))\n            return {}\n        return res.json()\n    except Exception as e:\n        msg = 'geoip({}) failed: {}'.format(ip, traceback.format_exc())\n        logger.error(msg)\n        if exceptions:\n            raise\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the IP information from the given IP address.", "response": "def get_ip_info(ip: str, exceptions: bool=False, timeout: int=10) -> tuple:\n    \"\"\"\n    Returns (ip, country_code, host) tuple of the IP address.\n    :param ip: IP address\n    :param exceptions: Raise Exception or not\n    :param timeout: Timeout in seconds. Note that timeout only affects geo IP part, not getting host name.\n    :return: (ip, country_code, host)\n    \"\"\"\n    import traceback\n    import socket\n    if not ip:  # localhost\n        return None, '', ''\n    host = ''\n    country_code = get_geo_ip(ip, exceptions=exceptions, timeout=timeout).get('country_code', '')\n    try:\n        res = socket.gethostbyaddr(ip)\n        host = res[0][:255] if ip else ''\n    except Exception as e:\n        msg = 'socket.gethostbyaddr({}) failed: {}'.format(ip, traceback.format_exc())\n        logger.error(msg)\n        if exceptions:\n            raise e\n    return ip, country_code, host"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_aws():\n    log = logging.getLogger(mod_logger + '.is_aws')\n    log.info('Querying AWS meta data URL: {u}'.format(u=metadata_url))\n\n    # Re-try logic for checking the AWS meta data URL\n    retry_time_sec = 10\n    max_num_tries = 10\n    attempt_num = 1\n\n    while True:\n        if attempt_num > max_num_tries:\n            log.info('Unable to query the AWS meta data URL, this system is NOT running on AWS\\n{e}')\n            return False\n\n        # Query the AWS meta data URL\n        try:\n            response = urllib.urlopen(metadata_url)\n        except(IOError, OSError) as ex:\n            log.warn('Failed to query the AWS meta data URL\\n{e}'.format(e=str(ex)))\n            attempt_num += 1\n            time.sleep(retry_time_sec)\n            continue\n\n        # Check the code\n        if response.getcode() == 200:\n            log.info('AWS metadata service returned code 200, this system is running on AWS')\n            return True\n        else:\n            log.warn('AWS metadata service returned code: {c}'.format(c=response.getcode()))\n            attempt_num += 1\n            time.sleep(retry_time_sec)\n            continue", "response": "Determines if this system is running on AWS"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance_id():\n    log = logging.getLogger(mod_logger + '.get_instance_id')\n\n    # Exit if not running on AWS\n    if not is_aws():\n        log.info('This machine is not running in AWS, exiting...')\n        return\n\n    instance_id_url = metadata_url + 'instance-id'\n    try:\n        response = urllib.urlopen(instance_id_url)\n    except(IOError, OSError) as ex:\n        msg = 'Unable to query URL to get instance ID: {u}\\n{e}'. \\\n            format(u=instance_id_url, e=ex)\n        log.error(msg)\n        return\n\n    # Check the code\n    if response.getcode() != 200:\n        msg = 'There was a problem querying url: {u}, returned code: {c}, unable to get the instance-id'.format(\n                u=instance_id_url, c=response.getcode())\n        log.error(msg)\n        return\n    instance_id = response.read()\n    return instance_id", "response": "Gets the instance ID of this EC2 instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vpc_id_from_mac_address():\n    log = logging.getLogger(mod_logger + '.get_vpc_id')\n\n    # Exit if not running on AWS\n    if not is_aws():\n        log.info('This machine is not running in AWS, exiting...')\n        return\n\n    # Get the primary interface MAC address to query the meta data service\n    log.debug('Attempting to determine the primary interface MAC address...')\n    try:\n        mac_address = get_primary_mac_address()\n    except AWSMetaDataError:\n        _, ex, trace = sys.exc_info()\n        msg = '{n}: Unable to determine the mac address, cannot determine VPC ID:\\n{e}'.format(\n            n=ex.__class__.__name__, e=str(ex))\n        log.error(msg)\n        return\n\n    vpc_id_url = metadata_url + 'network/interfaces/macs/' + mac_address + '/vpc-id'\n    try:\n        response = urllib.urlopen(vpc_id_url)\n    except(IOError, OSError) as ex:\n        msg = 'Unable to query URL to get VPC ID: {u}\\n{e}'.format(u=vpc_id_url, e=ex)\n        log.error(msg)\n        return\n\n    # Check the code\n    if response.getcode() != 200:\n        msg = 'There was a problem querying url: {u}, returned code: {c}, unable to get the vpc-id'.format(\n                u=vpc_id_url, c=response.getcode())\n        log.error(msg)\n        return\n    vpc_id = response.read()\n    return vpc_id", "response": "Returns the VPC ID for this EC2 instance based on the MAC address of the primary interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_availability_zone():\n    log = logging.getLogger(mod_logger + '.get_availability_zone')\n\n    # Exit if not running on AWS\n    if not is_aws():\n        log.info('This machine is not running in AWS, exiting...')\n        return\n\n    availability_zone_url = metadata_url + 'placement/availability-zone'\n    try:\n        response = urllib.urlopen(availability_zone_url)\n    except(IOError, OSError) as ex:\n        msg = 'Unable to query URL to get Availability Zone: {u}\\n{e}'.format(u=availability_zone_url, e=ex)\n        log.error(msg)\n        return\n\n    # Check the code\n    if response.getcode() != 200:\n        msg = 'There was a problem querying url: {u}, returned code: {c}, unable to get the Availability Zone'.format(\n            u=availability_zone_url, c=response.getcode())\n        log.error(msg)\n        return\n    availability_zone = response.read()\n    return availability_zone", "response": "Returns the AWS Availability Zone ID for this system"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the AWS Region ID for this system", "response": "def get_region():\n    \"\"\"Gets the AWS Region ID for this system\n\n    :return: (str) AWS Region ID where this system lives\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.get_region')\n\n    # First get the availability zone\n    availability_zone = get_availability_zone()\n\n    if availability_zone is None:\n        msg = 'Unable to determine the Availability Zone for this system, cannot determine the AWS Region'\n        log.error(msg)\n        return\n\n    # Strip of the last character to get the region\n    region = availability_zone[:-1]\n    return region"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndetermining the MAC address to use for querying the AWSMetaData service for network related queries", "response": "def get_primary_mac_address():\n    \"\"\"Determines the MAC address to use for querying the AWS\n    meta data service for network related queries\n\n    :return: (str) MAC address for the eth0 interface\n    :raises: AWSMetaDataError\n    \"\"\"\n    log = logging.getLogger(mod_logger + '.get_primary_mac_address')\n    log.debug('Attempting to determine the MAC address for eth0...')\n    try:\n        mac_address = netifaces.ifaddresses('eth0')[netifaces.AF_LINK][0]['addr']\n    except Exception:\n        _, ex, trace = sys.exc_info()\n        msg = '{n}: Unable to determine the eth0 mac address for this system:\\n{e}'.format(\n            n=ex.__class__.__name__, e=str(ex))\n        raise AWSMetaDataError, msg, trace\n    return mac_address"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef attr_sep(self, new_sep: str) -> None:\n        self._attr_sep = new_sep\n        self._filters_tree = self._generate_filters_tree()", "response": "Set the new value for the attribute separator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompare two URLs and returns True if they point to same URI.", "response": "def url_equals(a: str, b: str) -> bool:\n    \"\"\"\n    Compares two URLs/paths and returns True if they point to same URI.\n    For example, querystring parameters can be different order but URLs are still equal.\n    :param a: URL/path\n    :param b: URL/path\n    :return: True if URLs/paths are equal\n    \"\"\"\n    from urllib.parse import urlparse, parse_qsl\n    a2 = list(urlparse(a))\n    b2 = list(urlparse(b))\n    a2[4] = dict(parse_qsl(a2[4]))\n    b2[4] = dict(parse_qsl(b2[4]))\n    return a2 == b2"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef url_mod(url: str, new_params: dict) -> str:\n    from urllib.parse import urlparse, parse_qsl, urlunparse, urlencode\n    res = urlparse(url)\n    query_params = dict(parse_qsl(res.query))\n    for k, v in new_params.items():\n        if v is None:\n            query_params[str(k)] = ''\n        else:\n            query_params[str(k)] = str(v)\n    parts = list(res)\n    parts[4] = urlencode(query_params)\n    return urlunparse(parts)", "response": "Modifies existing URL by setting or overriding specified query string parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef url_host(url: str) -> str:\n    from urllib.parse import urlparse\n    res = urlparse(url)\n    return res.netloc.split(':')[0] if res.netloc else ''", "response": "Parses hostname from URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ufloatDict_nominal(self, ufloat_dict):\n        'This gives us a dictionary of nominal values from a dictionary of uncertainties'\n        return OrderedDict(izip(ufloat_dict.keys(), map(lambda x: x.nominal_value, ufloat_dict.values())))", "response": "This gives us a dictionary of nominal values from a dictionary of uncertainties"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef docs(recreate, gen_index, run_doctests):\n    # type: (bool, bool, bool) -> None\n    \"\"\" Build the documentation for the project.\n\n    Args:\n        recreate (bool):\n            If set to **True**, the build and output directories will be cleared\n            prior to generating the docs.\n        gen_index (bool):\n            If set to **True**, it will generate top-level index file for the\n            reference documentation.\n        run_doctests (bool):\n            Set to **True** if you want to run doctests after the documentation\n            is generated.\n        pretend (bool):\n            If set to **True**, do not actually execute any shell commands, just\n            print the command that would be executed.\n    \"\"\"\n    build_dir = conf.get_path('build_dir', '.build')\n    docs_dir = conf.get_path('docs.path', 'docs')\n    refdoc_paths = conf.get('docs.reference', [])\n\n    docs_html_dir = conf.get_path('docs.out', os.path.join(docs_dir, 'html'))\n    docs_tests_dir = conf.get_path('docs.tests_out',\n                                   os.path.join(docs_dir, 'doctest'))\n    docs_build_dir = os.path.join(build_dir, 'docs')\n\n    if recreate:\n        for path in (docs_html_dir, docs_build_dir):\n            if os.path.exists(path):\n                log.info(\"<91>Deleting <94>{}\".format(path))\n                shutil.rmtree(path)\n\n    if refdoc_paths:\n        gen_ref_docs(gen_index)\n    else:\n        log.err('Not generating any reference documentation - '\n                'No docs.reference specified in config')\n\n    with conf.within_proj_dir(docs_dir):\n        log.info('Building docs')\n        shell.run('sphinx-build -b html -d {build} {docs} {out}'.format(\n            build=docs_build_dir,\n            docs=docs_dir,\n            out=docs_html_dir,\n        ))\n\n        if run_doctests:\n            log.info('Running doctests')\n            shell.run('sphinx-build -b doctest -d {build} {docs} {out}'.format(\n                build=docs_build_dir,\n                docs=docs_dir,\n                out=docs_tests_dir,\n            ))\n\n        log.info('You can view the docs by browsing to <34>file://{}'.format(\n            os.path.join(docs_html_dir, 'index.html')\n        ))", "response": "Build the documentation for the project."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates reference documentation for the project.", "response": "def gen_ref_docs(gen_index=False):\n    # type: (int, bool) -> None\n    \"\"\" Generate reference documentation for the project.\n\n    This will use **sphinx-refdoc** to generate the source .rst files for the\n    reference documentation.\n\n    Args:\n        gen_index (bool):\n            Set it to **True** if you want to generate the index file with the\n            list of top-level packages. This is set to default as in most cases\n            you only have one package per project so you can link directly to\n            that package reference (and if index were generated sphinx would\n            complain about file not included in toctree).\n    \"\"\"\n    try:\n        from refdoc import generate_docs\n    except ImportError as ex:\n        msg = (\"You need to install sphinx-refdoc if you want to generate \"\n               \"code reference docs.\")\n\n        print(msg, file=sys.stderr)\n        log.err(\"Exception: {}\".format(ex))\n        sys.exit(-1)\n\n    pretend = context.get('pretend', False)\n\n    docs_dir = conf.get_path('docs.path', 'docs')\n    docs_ref_dir = os.path.join(docs_dir, 'ref')\n    refdoc_paths = conf.get('docs.reference', [])\n\n    if os.path.exists(docs_ref_dir):\n        if not pretend:\n            log.info('Removing existing reference docs')\n            shutil.rmtree(docs_ref_dir)\n        else:\n            log.info('Would remove old reference docs')\n\n    args = {\n        'out_dir': docs_ref_dir,\n        'verbose': context.get('verbose', 0),\n    }\n\n    if gen_index:\n        args['gen_index'] = True\n\n    pkg_paths = [conf.proj_path(p) for p in refdoc_paths]\n\n    if not pretend:\n        log.info('Generating reference documentation')\n        generate_docs(pkg_paths, **args)\n    else:\n        log.info(\"Would generate reference docs with the following params\")\n        shell.cprint('<90>{}', util.yaml_dump(args).rstrip())\n        shell.cprint('<90>paths:\\n<34>{}', util.yaml_dump(pkg_paths).rstrip())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_id_name_map(sdk, reverse=False):\n\n    global_id_name_dict = {}\n    global_name_id_dict = {}\n\n    # system struct\n    system_list = []\n\n    # Global lookup dictionary for sub items\n    if_id_to_name = {}\n    global_swi_id = {}\n    global_ln_id = {}\n\n    swi_to_wan_network_dict = {}\n    swi_to_site_dict = {}\n    wan_network_to_swi_dict = {}\n    all_anynets = {}\n    all_vpns = {}\n    swi_id_name_dict = {}\n    site_swi_dict = {}\n    path_id_to_name = {}\n    vpn_id_to_anynet_id = {}\n\n    # Create xlation dicts and lists.\n\n    logger.info(\"Caching Operators..\")\n    id_operator_dict, operator_id_dict = operators_to_name_dict(sdk)\n    if id_operator_dict:\n        global_id_name_dict.update(id_operator_dict)\n    global_name_id_dict.update(operator_id_dict)\n    if operator_id_dict:\n        global_name_id_dict.update(operator_id_dict)\n\n    logger.info(\"Caching Sites..\")\n    id_site_dict, site_id_dict, site_id_list, site_info_dict = siteid_to_name_dict(sdk)\n    global_id_name_dict.update(id_site_dict)\n    global_name_id_dict.update(site_id_dict)\n\n    logger.info(\"Caching Elements..\")\n    id_element_dict, element_id_dict, element_site_dict, element_id_list = elements_to_name_dict(sdk)\n    global_id_name_dict.update(id_element_dict)\n    global_name_id_dict.update(element_id_dict)\n\n    logger.info(\"Caching WAN Networks..\")\n    id_wannetwork_dict, name_wannetwork_id_dict, wannetwork_id_list, wannetwork_type_dict = wan_network_dicts(sdk)\n    global_id_name_dict.update(id_wannetwork_dict)\n    global_name_id_dict.update(name_wannetwork_id_dict)\n\n    logger.info(\"Caching Circuit Catagories..\")\n    id_circuit_categories, name_circuit_categories = circuit_categories_dicts(sdk)\n    global_id_name_dict.update(id_circuit_categories)\n    global_name_id_dict.update(name_circuit_categories)\n\n    logger.info(\"Caching Network Contexts..\")\n    id_network_contexts, name_circuit_contexts = network_context_dicts(sdk)\n    global_id_name_dict.update(id_network_contexts)\n    global_name_id_dict.update(name_circuit_contexts)\n\n    logger.info(\"Caching Appdefs..\")\n    id_appdef_dict, name_appdef_dict, appdef_id_list = appdefs_to_name_dict(sdk)\n    global_id_name_dict.update(id_appdef_dict)\n    global_name_id_dict.update(name_appdef_dict)\n\n    logger.info(\"Caching Policysets..\")\n    id_policyset_dict, name_policyset_dict, policyset_id_list = policyset_to_name_dict(sdk)\n    global_id_name_dict.update(id_policyset_dict)\n    global_name_id_dict.update(name_policyset_dict)\n\n    logger.info(\"Caching Security Policysets..\")\n    id_securitypolicyset_dict, name_securitypolicyset_dict, \\\n        securitypolicyset_id_list = securitypolicyset_to_name_dict(sdk)\n    global_id_name_dict.update(id_securitypolicyset_dict)\n    global_name_id_dict.update(name_securitypolicyset_dict)\n\n    logger.info(\"Caching Security Zones..\")\n    id_securityzone_dict, securityzone_id_dict, securityzone_id_list = securityzone_to_name_dict(sdk)\n    global_id_name_dict.update(id_securityzone_dict)\n    global_name_id_dict.update(securityzone_id_dict)\n\n    id_interface_dict = {}\n\n    logger.info(\"Filling Network Site->Element->Interface table..\")\n\n    for site in site_id_list:\n        elements = []\n        swi_id_dict = {}\n        ln_id_dict = {}\n\n        # enumerate elements\n        for element in element_id_list:\n            # Is this element bound to a site?\n            site_in = element_site_dict.get(element, None)\n            # if it is bound, and bound to this site, add to list.\n            if site_in and site_in == site:\n                # Query interfaces\n                interfaces_list, if_id_to_name_item, if_name_to_id_item, _, \\\n                    _, if_id_data_entry = interface_query(site, element, sdk)\n                # add the element to the list\n                elements.append({\n                    'id': element,\n                    'name': id_element_dict.get(element, \"\"),\n                    'interfaces': interfaces_list\n                })\n                # add the if id name mapping to the main dict\n                if_id_to_name.update(if_id_to_name_item)\n                # update grand interface list\n                id_interface_dict.update(if_id_data_entry)\n\n\n        system_list.append({\n            'id': site,\n            'name': id_site_dict.get(site, \"\"),\n            'elements': elements\n        })\n\n        # query Site WAN Interface info\n        resp = sdk.get.waninterfaces(site)\n        swi_status = resp.cgx_status\n        swi_query = resp.cgx_content\n\n        if swi_status:\n            # iterate all the site wan interfaces\n            for current_swi in swi_query.get('items', []):\n                # get the WN bound to the SWI.\n\n                wan_network_id = current_swi.get('network_id', \"\")\n                swi_id = current_swi.get('id', \"\")\n                name = current_swi.get('name')\n\n                if name and swi_id:\n                    swi_id_name_dict[swi_id] = name\n                elif swi_id and wan_network_id:\n                    # Handle SWI with no name.\n                    wan_network_name = id_wannetwork_dict.get(wan_network_id, wan_network_id)\n                    swi_id_name_dict[swi_id] = \"Circuit to {0}\".format(wan_network_name)\n\n                if swi_id:\n                    # update SWI -> Site xlation dict\n                    swi_to_site_dict[swi_id] = site\n\n                # get the SWIs\n                if wan_network_id and swi_id:\n                    logger.debug('SWI_ID = SITE: {0} = {1}'.format(swi_id, site))\n\n                    # query existing wan_network_to_swi dict if entry exists.\n                    existing_swi_list = wan_network_to_swi_dict.get(wan_network_id, [])\n\n                    # update swi -> WN xlate dict\n                    swi_to_wan_network_dict[swi_id] = wan_network_id\n\n                    # update WN -> swi xlate dict\n                    existing_swi_list.append(swi_id)\n                    wan_network_to_swi_dict[wan_network_id] = existing_swi_list\n\n            # add to global\n            global_swi_id.update(swi_id_name_dict)\n\n        # query LAN Network info\n        resp = sdk.get.lannetworks(site)\n        ln_status = resp.cgx_status\n        ln_query = resp.cgx_content\n\n        if ln_status:\n            for ln in ln_query.get('items'):\n                ln_id = ln.get('id')\n                ln_name = ln.get('name')\n\n                if ln_id and ln_name:\n                    ln_id_dict[ln_id] = ln_name\n\n            # add to global\n            global_ln_id.update(ln_id_dict)\n\n    logger.info(\"Loading VPN topology information for {0} sites, please wait...\".format(len(site_id_list)))\n\n    # add all interface IDs\n    # note - can't reliably make reverse name to ID items here, as they are not global.\n    global_id_name_dict.update(if_id_to_name)\n    global_id_name_dict.update(global_swi_id)\n    global_id_name_dict.update(global_ln_id)\n\n    for site in site_id_list:\n        site_swi_list = []\n\n        query = {\n            \"type\": \"basenet\",\n            \"nodes\": [\n                site\n            ]\n        }\n\n        status = False\n        rest_call_retry = 0\n\n        resp = sdk.post.topology(query)\n        status = resp.cgx_status\n        topology = resp.cgx_content\n\n        if status and topology:\n            # iterate topology. We need to iterate all of the matching SWIs, and existing anynet connections (sorted).\n            logger.debug(\"TOPOLOGY: {0}\".format(json.dumps(topology, indent=4)))\n\n            for link in topology.get('links', []):\n                link_type = link.get('type', \"\")\n\n                # if an anynet link (SWI to SWI)\n                if link_type in [\"anynet\", \"public-anynet\", \"private-anynet\"]:\n                    # vpn record, check for uniqueness.\n                    # 4.4.1\n                    source_swi = link.get('source_wan_if_id')\n                    if not source_swi:\n                        # 4.3.x compatibility\n                        source_swi = link.get('source_wan_path_id')\n                        if source_swi:\n                            link['source_wan_if_id'] = source_swi\n                    # 4.4.1\n                    dest_swi = link.get('target_wan_if_id')\n                    if not dest_swi:\n                        # 4.3.x compatibility\n                        dest_swi = link.get('target_wan_path_id')\n                        if dest_swi:\n                            link['target_wan_if_id'] = dest_swi\n                    # create anynet lookup key\n                    # anynet_lookup_key = \"_\".join(sorted([source_swi, dest_swi]))\n                    # use path ID\n                    anynet_lookup_key = link.get('path_id')\n                    if not all_anynets.get(anynet_lookup_key, None):\n                        # path is not in current anynets, add\n                        all_anynets[anynet_lookup_key] = link\n                    else:\n                        # path_id already seen.\n                        pass\n\n                elif link_type in ['vpn']:\n                    vpn_lookup_key = link.get('path_id')\n                    if not all_vpns.get(vpn_lookup_key, None):\n                        # path is not in VPNs, add.\n                        all_vpns[vpn_lookup_key] = link\n        else:\n            # Bail out\n            logger.info(\"ERROR: could not query site ID {0}. Continuing.\".format(site))\n\n    # update all_anynets with site info. Can't do this above, because xlation table not finished when needed.\n    for anynet_key, link in all_anynets.items():\n        # 4.4.1\n        source_swi = link.get('source_wan_if_id')\n        if not source_swi:\n            # 4.3.x compatibility\n            source_swi = link.get('source_wan_path_id')\n        # 4.4.1\n        dest_swi = link.get('target_wan_if_id')\n        if not dest_swi:\n            # 4.3.x compatibility\n            dest_swi = link.get('target_wan_path_id')\n\n        source_site_id = swi_to_site_dict.get(source_swi, 'UNKNOWN (Unable to map SWI to Site ID)')\n        target_site_id = swi_to_site_dict.get(dest_swi, 'UNKNOWN (Unable to map SWI to Site ID)')\n        source_wan_network_name = link.get(\"source_wan_network\")\n        target_wan_network_name = link.get(\"target_wan_network\")\n\n        # update struct in case it's needed later\n        link['source_site_id'] = source_site_id\n        link['target_site_id'] = target_site_id\n\n        # get names.\n        source_site_name = id_site_dict.get(source_site_id, source_site_id)\n        target_site_name = id_site_dict.get(target_site_id, target_site_id)\n        source_swi_name = swi_id_name_dict.get(source_swi, source_swi)\n        target_swi_name = swi_id_name_dict.get(dest_swi, dest_swi)\n\n        # build text map.\n        anynet_text = \"{0} ('{1}' via '{2}') <-> ('{4}' via '{5}') {3}\".format(\n            source_site_name,\n            source_wan_network_name,\n            source_swi_name,\n            target_site_name,\n            target_wan_network_name,\n            target_swi_name,\n        )\n\n        # update pathid to name dict\n        path_id_to_name[anynet_key] = anynet_text\n\n    logger.info(\"SWI -> WN xlate ({0}): {1}\".format(len(swi_to_wan_network_dict),\n                                                    json.dumps(swi_to_wan_network_dict, indent=4)))\n    logger.info(\"All Anynets ({0}): {1}\".format(len(all_anynets),\n                                                json.dumps(all_anynets, indent=4)))\n    logger.info(\"All VPNs ({0}): {1}\".format(len(all_vpns),\n                                             json.dumps(all_vpns, indent=4)))\n    logger.info(\"Site -> SWI construct ({0}): {1}\".format(len(site_swi_dict),\n                                                          json.dumps(site_swi_dict, indent=4)))\n    logger.info(\"WN to SWI xlate ({0}): {1}\".format(len(wan_network_to_swi_dict),\n                                                    json.dumps(wan_network_to_swi_dict, indent=4)))\n    logger.info(\"SWI -> SITE xlate ({0}): {1}\".format(len(swi_to_site_dict),\n                                                      json.dumps(swi_to_site_dict, indent=4)))\n\n    # create VPN to anynet maps AND update text mappings.\n\n    for vpn_key, link in all_vpns.items():\n        anynet_link_id = link.get(\"anynet_link_id\")\n        source_element_id = link.get(\"source_node_id\")\n        target_element_id = link.get(\"target_node_id\")\n\n        # update vpn -> anynet table\n        vpn_id_to_anynet_id[vpn_key] = anynet_link_id\n\n        # get names\n        source_element_name = id_element_dict.get(source_element_id, source_element_id)\n        target_element_name = id_element_dict.get(target_element_id, target_element_id)\n        anynet_text = path_id_to_name.get(anynet_link_id, anynet_link_id)\n\n        vpn_text = \"[{0}] : {1} : [{2}]\".format(\n            source_element_name,\n            anynet_text,\n            target_element_name\n        )\n\n        # update path mapping\n        path_id_to_name[vpn_key] = vpn_text\n\n    # done, update global\n    global_id_name_dict.update(path_id_to_name)\n\n    if reverse:\n        # return both id_name and what we can get of name_id.\n        return global_id_name_dict, global_name_id_dict\n\n    return global_id_name_dict", "response": "Generate the ID - NAME map for a given CloudGenix SDK."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef revrank_dict(dict, key=lambda t: t[1], as_tuple=False):\n    sorted_list = sorted(dict.items(), key=key, reverse=True)\n    return OrderedDict(sorted_list) if not as_tuple else tuple(sorted_list)", "response": "Reverse sorts a dictionary by a given key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rank_dict(dict, key=lambda t: t[1], as_tuple=False):\n    sorted_list = sorted(dict.items(), key=key)\n    return OrderedDict(sorted_list) if not as_tuple else tuple(sorted_list)", "response": "Sort a dictionary by a given key optionally returning it as a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding a key in a dictionary via a period - delimited string name.", "response": "def getitem_in(obj, name):\n    \"\"\" Finds a key in @obj via a period-delimited string @name.\n        @obj: (#dict)\n        @name: (#str) |.|-separated keys to search @obj in\n        ..\n            obj = {'foo': {'bar': {'baz': True}}}\n            getitem_in(obj, 'foo.bar.baz')\n        ..\n        |True|\n    \"\"\"\n    for part in name.split('.'):\n        obj = obj[part]\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start(component, exact):\n    # type: (str) -> None\n    \"\"\" Create a new release.\n\n    It will bump the current version number and create a release branch called\n    `release/<version>` with one new commit (the version bump).\n\n    **Example Config**::\n\n        \\b\n        version_file: 'src/mypkg/__init__.py'\n\n    **Examples**::\n\n        \\b\n        $ peltak release start patch    # Make a new patch release\n        $ peltak release start minor    # Make a new minor release\n        $ peltak release start major    # Make a new major release\n        $ peltak release start          # same as start patch\n\n    \"\"\"\n    from peltak.extra.gitflow import logic\n    logic.release.start(component, exact)", "response": "Start a new release."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntagging the current commit with as the current version release.", "response": "def tag_release(message):\n    # type: (str, bool) -> None\n    \"\"\" Tag the current commit with as the current version release.\n\n    This should be the same commit as the one that's uploaded as the release\n    (to pypi for example).\n\n    **Example Config**::\n\n        \\b\n        version_file: 'src/mypkg/__init__.py'\n\n    Examples::\n\n        $ peltak release tag          # Tag the current commit as release\n\n    \"\"\"\n    from peltak.extra.gitflow import logic\n    logic.release.tag(message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format_full_name(first_name: str, last_name: str, max_length: int = 20):\n    # dont allow commas in limited names\n    first_name = first_name.replace(',', ' ')\n    last_name = last_name.replace(',', ' ')\n\n    # accept short full names as is\n    original_full_name = first_name + ' ' + last_name\n    if len(original_full_name) <= max_length:\n        return original_full_name\n\n    # drop middle names\n    first_name = first_name.split(' ')[0]\n    full_name = first_name + ' ' + last_name\n    if len(full_name) <= max_length:\n        return full_name\n\n    # drop latter parts of combined first names\n    first_name = re.split(r'[\\s\\-]', first_name)[0]\n    full_name = first_name + ' ' + last_name\n    if len(full_name) <= max_length:\n        return full_name\n\n    # drop latter parts of multi part last names\n    last_name = re.split(r'[\\s\\-]', last_name)[0]\n    full_name = first_name + ' ' + last_name\n    if len(full_name) <= max_length:\n        return full_name\n\n    # shorten last name to one letter\n    last_name = last_name[:1]\n\n    full_name = first_name + ' ' + last_name\n    if len(full_name) > max_length:\n        raise Exception('Failed to shorten name {}'.format(original_full_name))\n    return full_name", "response": "Takes two strings and returns a full name of the specified length."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef format_timedelta(dt: timedelta) -> str:\n    seconds = int(dt.total_seconds())\n    days, remainder = divmod(seconds, 86400)\n    hours, remainder = divmod(remainder, 3600)\n    minutes, seconds = divmod(remainder, 60)\n    s = \"\"\n    if days > 0:\n        s += str(days) + \"d\"\n    if hours > 0:\n        s += str(hours) + \"h\"\n    if minutes > 0:\n        s += str(minutes) + \"min\"\n    if s == \"\":\n        s = \"0min\"\n    return s", "response": "Formats timedelta to readable format e. g. 1h30min."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format_xml(xml_str: str, exceptions: bool=False):\n    try:\n        import xml.dom.minidom\n        return xml.dom.minidom.parseString(xml_str).toprettyxml()\n    except Exception:\n        if exceptions:\n            raise\n        return xml_str", "response": "Formats XML document as human - readable plain text."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a mail using the configured mailgun API.", "response": "def send_mail(form, from_name):\n    \"\"\"\n    Sends a mail using the configured mail server for Pulsar.  See mailgun documentation at\n    https://documentation.mailgun.com/en/latest/user_manual.html#sending-via-api for specifics.\n \n    Args:\n        form: `dict`. The mail form fields, i.e. 'to', 'from', ...\n\n    Returns: \n        `requests.models.Response` instance.\n\n    Raises: \n        `requests.exceptions.HTTPError`: The status code is not ok.\n        `Exception`: The environment variable MAILGUN_DOMAIN or MAILGUN_API_KEY isn't set. \n\n    Example::\n\n        payload = {\n            \"from\"=\"{} <mailgun@{}>\".format(from_name, pulsarpy.MAIL_DOMAIN), \n            \"subject\": \"mailgun test\", \n            \"text\": \"howdy there\",\n            \"to\": \"nathankw@stanford.edu\", \n        }\n        send_mail(payload)\n\n    \"\"\"\n    form[\"from\"] = \"{} <mailgun@{}>\".format(from_name, pulsarpy.MAIL_DOMAIN),\n    if not pulsarpy.MAIL_SERVER_URL:\n        raise Exception(\"MAILGUN_DOMAIN environment variable not set.\")\n    if not pulsarpy.MAIL_AUTH[1]:\n        raise Exception(\"MAILGUN_API_KEY environment varible not set.\")\n    res = requests.post(pulsarpy.MAIL_SERVER_URL, data=form, auth=pulsarpy.MAIL_AUTH)\n    res.raise_for_status()\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_exp_of_biosample(biosample_rec):\n    chip_exp_id = biosample_rec.chipseq_experiment_id\n    ssc_id = biosample_rec.sorting_biosample_single_cell_sorting_id\n    if chip_exp_id:\n        return {\"type\": \"chipseq_experiment\", \"record\": models.ChipseqExperiment(chip_exp_id)}\n    elif ssc_id:\n        return {\"type\": \"single_cell_sorting\", \"record\": models.SingleCellSorting(ssc_id)}\n    raise Exception(\"Biosample {} is not on an experiment.\".format(biosample_rec[\"id\"]))", "response": "Determines whether the biosample is part of a ChipseqExperiment or SingleCellSorting experiment and returns the associated model instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncleans up a multiple - line potentially multiple - paragraph text string.", "response": "def _clean_text(text):\n    \"\"\"\n    Clean up a multiple-line, potentially multiple-paragraph text\n    string.  This is used to extract the first paragraph of a string\n    and eliminate line breaks and indentation.  Lines will be joined\n    together by a single space.\n\n    :param text: The text string to clean up.  It is safe to pass\n                 ``None``.\n\n    :returns: The first paragraph, cleaned up as described above.\n    \"\"\"\n\n    desc = []\n    for line in (text or '').strip().split('\\n'):\n        # Clean up the line...\n        line = line.strip()\n\n        # We only want the first paragraph\n        if not line:\n            break\n\n        desc.append(line)\n\n    return ' '.join(desc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef usage(text):\n\n    def decorator(func):\n        adaptor = ScriptAdaptor._get_adaptor(func)\n        adaptor.usage = text\n        return func\n    return decorator", "response": "Decorator used to specify a usage string for the console script\n    help message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef epilog(text):\n\n    def decorator(func):\n        adaptor = ScriptAdaptor._get_adaptor(func)\n        adaptor.epilog = text\n        return func\n    return decorator", "response": "Decorator used to specify an epilog for the console script help\n    message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef formatter_class(klass):\n\n    def decorator(func):\n        adaptor = ScriptAdaptor._get_adaptor(func)\n        adaptor.formatter_class = klass\n        return func\n    return decorator", "response": "Decorator used to specify the formatter class for the console\n    script."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef argument_group(group, **kwargs):\n\n    def decorator(func):\n        adaptor = ScriptAdaptor._get_adaptor(func)\n        adaptor._add_group(group, 'group', kwargs)\n        return func\n    return decorator", "response": "Decorator used to specify an argument group."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _collapse_subtree(self, name, recursive=True):\n        oname = name\n        children = self._db[name][\"children\"]\n        data = self._db[name][\"data\"]\n        del_list = []\n        while (len(children) == 1) and (not data):\n            del_list.append(name)\n            name = children[0]\n            children = self._db[name][\"children\"]\n            data = self._db[name][\"data\"]\n        parent = self._db[oname][\"parent\"]\n        self._db[name][\"parent\"] = parent\n        if parent:\n            self._db[parent][\"children\"].remove(oname)\n            self._db[parent][\"children\"] = sorted(self._db[parent][\"children\"] + [name])\n        else:\n            self._root = name\n            self._root_hierarchy_length = len(\n                self.root_name.split(self._node_separator)\n            )\n        for node in del_list:\n            self._del_node(node)\n        if recursive:\n            for child in copy.copy(children):\n                self._collapse_subtree(child)", "response": "Collapse a sub - tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _create_intermediate_nodes(self, name):\n        hierarchy = self._split_node_name(name, self.root_name)\n        node_tree = [\n            self.root_name\n            + self._node_separator\n            + self._node_separator.join(hierarchy[: num + 1])\n            for num in range(len(hierarchy))\n        ]\n        iobj = [\n            (child[: child.rfind(self._node_separator)], child)\n            for child in node_tree\n            if child not in self._db\n        ]\n        for parent, child in iobj:\n            self._db[child] = {\"parent\": parent, \"children\": [], \"data\": []}\n            self._db[parent][\"children\"] = sorted(\n                self._db[parent][\"children\"] + [child]\n            )", "response": "Create intermediate nodes if hierarchy does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new tree node.", "response": "def _create_node(self, name, parent, children, data):\n        \"\"\"Create new tree node.\"\"\"\n        self._db[name] = {\"parent\": parent, \"children\": children, \"data\": data}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete subtree private method.", "response": "def _delete_subtree(self, nodes):\n        \"\"\"\n        Delete subtree private method.\n\n        No argument validation and usage of getter/setter private methods is\n        used for speed\n        \"\"\"\n        nodes = nodes if isinstance(nodes, list) else [nodes]\n        iobj = [\n            (self._db[node][\"parent\"], node)\n            for node in nodes\n            if self._node_name_in_tree(node)\n        ]\n        for parent, node in iobj:\n            # Delete link to parent (if not root node)\n            del_list = self._get_subtree(node)\n            if parent:\n                self._db[parent][\"children\"].remove(node)\n            # Delete children (sub-tree)\n            for child in del_list:\n                del self._db[child]\n            if self._empty_tree():\n                self._root = None\n                self._root_hierarchy_length = None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding common prefix between two nodes.", "response": "def _find_common_prefix(self, node1, node2):\n        \"\"\"Find common prefix between two nodes.\"\"\"\n        tokens1 = [item.strip() for item in node1.split(self.node_separator)]\n        tokens2 = [item.strip() for item in node2.split(self.node_separator)]\n        ret = []\n        for token1, token2 in zip(tokens1, tokens2):\n            if token1 == token2:\n                ret.append(token1)\n            else:\n                break\n        return self.node_separator.join(ret)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _prt(self, name, lparent, sep, pre1, pre2):\n        # pylint: disable=R0914\n        nname = name[lparent + 1 :]\n        children = self._db[name][\"children\"]\n        ncmu = len(children) - 1\n        plst1 = ncmu * [self._vertical_and_right] + [self._up_and_right]\n        plst2 = ncmu * [self._vertical] + [\" \"]\n        slist = (ncmu + 1) * [sep + pre2]\n        dmark = \" (*)\" if self._db[name][\"data\"] else \"\"\n        return \"\\n\".join(\n            [\n                u\"{sep}{connector}{name}{dmark}\".format(\n                    sep=sep, connector=pre1, name=nname, dmark=dmark\n                )\n            ]\n            + [\n                self._prt(child, len(name), sep=schar, pre1=p1, pre2=p2)\n                for child, p1, p2, schar in zip(children, plst1, plst2, slist)\n            ]\n        )", "response": "Print a row of tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrenaming a node in the cache.", "response": "def _rename_node(self, name, new_name):\n        \"\"\"\n        Rename node private method.\n\n        No argument validation and usage of getter/setter private methods is\n        used for speed\n        \"\"\"\n        # Update parent\n        if not self.is_root(name):\n            parent = self._db[name][\"parent\"]\n            self._db[parent][\"children\"].remove(name)\n            self._db[parent][\"children\"] = sorted(\n                self._db[parent][\"children\"] + [new_name]\n            )\n        # Update children\n        iobj = self._get_subtree(name) if name != self.root_name else self.nodes\n        for key in iobj:\n            new_key = key.replace(name, new_name, 1)\n            new_parent = (\n                self._db[key][\"parent\"]\n                if key == name\n                else self._db[key][\"parent\"].replace(name, new_name, 1)\n            )\n            self._db[new_key] = {\n                \"parent\": new_parent,\n                \"children\": [\n                    child.replace(name, new_name, 1)\n                    for child in self._db[key][\"children\"]\n                ],\n                \"data\": copy.deepcopy(self._db[key][\"data\"]),\n            }\n            del self._db[key]\n        if name == self.root_name:\n            self._root = new_name\n            self._root_hierarchy_length = len(\n                self.root_name.split(self._node_separator)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating NodeName pseudo - type.", "response": "def _validate_node_name(self, var_value):\n        \"\"\"Validate NodeName pseudo-type.\"\"\"\n        # pylint: disable=R0201\n        var_values = var_value if isinstance(var_value, list) else [var_value]\n        for item in var_values:\n            if (not isinstance(item, str)) or (\n                isinstance(item, str)\n                and (\n                    (\" \" in item)\n                    or any(\n                        [\n                            element.strip() == \"\"\n                            for element in item.strip().split(self._node_separator)\n                        ]\n                    )\n                )\n            ):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates NodeWithData pseudo - type.", "response": "def _validate_nodes_with_data(self, names):\n        \"\"\"Validate NodeWithData pseudo-type.\"\"\"\n        names = names if isinstance(names, list) else [names]\n        if not names:\n            raise RuntimeError(\"Argument `nodes` is not valid\")\n        for ndict in names:\n            if (not isinstance(ndict, dict)) or (\n                isinstance(ndict, dict) and (set(ndict.keys()) != set([\"name\", \"data\"]))\n            ):\n                raise RuntimeError(\"Argument `nodes` is not valid\")\n            name = ndict[\"name\"]\n            if (not isinstance(name, str)) or (\n                isinstance(name, str)\n                and (\n                    (\" \" in name)\n                    or any(\n                        [\n                            element.strip() == \"\"\n                            for element in name.strip().split(self._node_separator)\n                        ]\n                    )\n                )\n            ):\n                raise RuntimeError(\"Argument `nodes` is not valid\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncollapsing a sub - tree.", "response": "def collapse_subtree(self, name, recursive=True):  # noqa: D302\n        r\"\"\"\n        Collapse a sub-tree.\n\n        Nodes that have a single child and no data are combined with their\n        child as a single tree node\n\n        :param name: Root of the sub-tree to collapse\n        :type  name: :ref:`NodeName`\n\n        :param recursive: Flag that indicates whether the collapse operation\n                          is performed on the whole sub-tree (True) or whether\n                          it stops upon reaching the first node where the\n                          collapsing condition is not satisfied (False)\n        :type  recursive: boolean\n\n        :raises:\n         * RuntimeError (Argument \\`name\\` is not valid)\n\n         * RuntimeError (Argument \\`recursive\\` is not valid)\n\n         * RuntimeError (Node *[name]* not in tree)\n\n        Using the same example tree created in\n        :py:meth:`ptrie.Trie.add_nodes`::\n\n            >>> from __future__ import print_function\n            >>> import docs.support.ptrie_example\n            >>> tobj = docs.support.ptrie_example.create_tree()\n            >>> print(tobj)\n            root\n            \u251cbranch1 (*)\n            \u2502\u251cleaf1\n            \u2502\u2502\u2514subleaf1 (*)\n            \u2502\u2514leaf2 (*)\n            \u2502 \u2514subleaf2\n            \u2514branch2\n            >>> tobj.collapse_subtree('root.branch1')\n            >>> print(tobj)\n            root\n            \u251cbranch1 (*)\n            \u2502\u251cleaf1.subleaf1 (*)\n            \u2502\u2514leaf2 (*)\n            \u2502 \u2514subleaf2\n            \u2514branch2\n\n        ``root.branch1.leaf1`` is collapsed because it only has one child\n        (``root.branch1.leaf1.subleaf1``) and no data; ``root.branch1.leaf2``\n        is not collapsed because although it has one child\n        (``root.branch1.leaf2.subleaf2``) and this child does have data\n        associated with it, :code:`'Hello world!'`\n        \"\"\"\n        if self._validate_node_name(name):\n            raise RuntimeError(\"Argument `name` is not valid\")\n        if not isinstance(recursive, bool):\n            raise RuntimeError(\"Argument `recursive` is not valid\")\n        self._node_in_tree(name)\n        self._collapse_subtree(name, recursive)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef copy_subtree(self, source_node, dest_node):  # noqa: D302\n        if self._validate_node_name(source_node):\n            raise RuntimeError(\"Argument `source_node` is not valid\")\n        if self._validate_node_name(dest_node):\n            raise RuntimeError(\"Argument `dest_node` is not valid\")\n        if source_node not in self._db:\n            raise RuntimeError(\"Node {0} not in tree\".format(source_node))\n        if not dest_node.startswith(self.root_name + self._node_separator):\n            raise RuntimeError(\"Illegal root in destination node\")\n        for node in self._get_subtree(source_node):\n            self._db[node.replace(source_node, dest_node, 1)] = {\n                \"parent\": self._db[node][\"parent\"].replace(source_node, dest_node, 1),\n                \"children\": [\n                    child.replace(source_node, dest_node, 1)\n                    for child in self._db[node][\"children\"]\n                ],\n                \"data\": copy.deepcopy(self._db[node][\"data\"]),\n            }\n        self._create_intermediate_nodes(dest_node)\n        parent = self._node_separator.join(dest_node.split(self._node_separator)[:-1])\n        self._db[dest_node][\"parent\"] = parent\n        self._db[parent][\"children\"] = sorted(\n            self._db[parent][\"children\"] + [dest_node]\n        )", "response": "Copy a sub - tree from one node to another."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes a prefix from all nodes in the tree.", "response": "def delete_prefix(self, name):  # noqa: D302\n        r\"\"\"\n        Delete hierarchy levels from all nodes in the tree.\n\n        :param nodes: Prefix to delete\n        :type  nodes: :ref:`NodeName`\n\n        :raises:\n         * RuntimeError (Argument \\`name\\` is not a valid prefix)\n\n         * RuntimeError (Argument \\`name\\` is not valid)\n\n        For example:\n\n            >>> from __future__ import print_function\n            >>> import ptrie\n            >>> tobj = ptrie.Trie('/')\n            >>> tobj.add_nodes([\n            ...     {'name':'hello/world/root', 'data':[]},\n            ...     {'name':'hello/world/root/anode', 'data':7},\n            ...     {'name':'hello/world/root/bnode', 'data':8},\n            ...     {'name':'hello/world/root/cnode', 'data':False},\n            ...     {'name':'hello/world/root/bnode/anode', 'data':['a', 'b']},\n            ...     {'name':'hello/world/root/cnode/anode/leaf', 'data':True}\n            ... ])\n            >>> tobj.collapse_subtree('hello', recursive=False)\n            >>> print(tobj)\n            hello/world/root\n            \u251canode (*)\n            \u251cbnode (*)\n            \u2502\u2514anode (*)\n            \u2514cnode (*)\n             \u2514anode\n              \u2514leaf (*)\n            >>> tobj.delete_prefix('hello/world')\n            >>> print(tobj)\n            root\n            \u251canode (*)\n            \u251cbnode (*)\n            \u2502\u2514anode (*)\n            \u2514cnode (*)\n             \u2514anode\n              \u2514leaf (*)\n        \"\"\"\n        if self._validate_node_name(name):\n            raise RuntimeError(\"Argument `name` is not valid\")\n        if (not self.root_name.startswith(name)) or (self.root_name == name):\n            raise RuntimeError(\"Argument `name` is not a valid prefix\")\n        self._delete_prefix(name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_subtree(self, nodes):  # noqa: D302\n        if self._validate_node_name(nodes):\n            raise RuntimeError(\"Argument `nodes` is not valid\")\n        self._delete_subtree(nodes)", "response": "Delete nodes and their sub - trees from the tree."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nflattens the hierarchy node that has children and no data are merged with each child node.", "response": "def flatten_subtree(self, name):  # noqa: D302\n        r\"\"\"\n        Flatten sub-tree.\n\n        Nodes that have children and no data are merged with each child\n\n        :param name: Ending hierarchy node whose sub-trees are to be\n                     flattened\n        :type  name: :ref:`NodeName`\n\n        :raises:\n         * RuntimeError (Argument \\`name\\` is not valid)\n\n         * RuntimeError (Node *[name]* not in tree)\n\n        Using the same example tree created in\n        :py:meth:`ptrie.Trie.add_nodes`::\n\n            >>> from __future__ import print_function\n            >>> import docs.support.ptrie_example\n            >>> tobj = docs.support.ptrie_example.create_tree()\n            >>> tobj.add_nodes([\n            ...     {'name':'root.branch1.leaf1.subleaf2', 'data':[]},\n            ...     {'name':'root.branch2.leaf1', 'data':'loren ipsum'},\n            ...     {'name':'root.branch2.leaf1.another_subleaf1', 'data':[]},\n            ...     {'name':'root.branch2.leaf1.another_subleaf2', 'data':[]}\n            ... ])\n            >>> print(str(tobj))\n            root\n            \u251cbranch1 (*)\n            \u2502\u251cleaf1\n            \u2502\u2502\u251csubleaf1 (*)\n            \u2502\u2502\u2514subleaf2\n            \u2502\u2514leaf2 (*)\n            \u2502 \u2514subleaf2\n            \u2514branch2\n             \u2514leaf1 (*)\n              \u251canother_subleaf1\n              \u2514another_subleaf2\n            >>> tobj.flatten_subtree('root.branch1.leaf1')\n            >>> print(str(tobj))\n            root\n            \u251cbranch1 (*)\n            \u2502\u251cleaf1.subleaf1 (*)\n            \u2502\u251cleaf1.subleaf2\n            \u2502\u2514leaf2 (*)\n            \u2502 \u2514subleaf2\n            \u2514branch2\n             \u2514leaf1 (*)\n              \u251canother_subleaf1\n              \u2514another_subleaf2\n            >>> tobj.flatten_subtree('root.branch2.leaf1')\n            >>> print(str(tobj))\n            root\n            \u251cbranch1 (*)\n            \u2502\u251cleaf1.subleaf1 (*)\n            \u2502\u251cleaf1.subleaf2\n            \u2502\u2514leaf2 (*)\n            \u2502 \u2514subleaf2\n            \u2514branch2\n             \u2514leaf1 (*)\n              \u251canother_subleaf1\n              \u2514another_subleaf2\n        \"\"\"\n        if self._validate_node_name(name):\n            raise RuntimeError(\"Argument `name` is not valid\")\n        self._node_in_tree(name)\n        parent = self._db[name][\"parent\"]\n        if (parent) and (not self._db[name][\"data\"]):\n            children = self._db[name][\"children\"]\n            for child in children:\n                self._db[child][\"parent\"] = parent\n            self._db[parent][\"children\"].remove(name)\n            self._db[parent][\"children\"] = sorted(\n                self._db[parent][\"children\"] + children\n            )\n            del self._db[name]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_children(self, name):\n        if self._validate_node_name(name):\n            raise RuntimeError(\"Argument `name` is not valid\")\n        self._node_in_tree(name)\n        return sorted(self._db[name][\"children\"])", "response": "r Returns the children node names of a node."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_leafs(self, name):\n        if self._validate_node_name(name):\n            raise RuntimeError(\"Argument `name` is not valid\")\n        self._node_in_tree(name)\n        return [node for node in self._get_subtree(name) if self.is_leaf(node)]", "response": "r Returns the leaf nodes of the given name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_node_children(self, name):\n        if self._validate_node_name(name):\n            raise RuntimeError(\"Argument `name` is not valid\")\n        self._node_in_tree(name)\n        return [self._db[child] for child in self._db[name][\"children\"]]", "response": "r Returns the list of children structures of a node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all node names in a sub - tree.", "response": "def get_subtree(self, name):  # noqa: D302\n        r\"\"\"\n        Get all node names in a sub-tree.\n\n        :param name: Sub-tree root node name\n        :type  name: :ref:`NodeName`\n\n        :rtype: list of :ref:`NodeName`\n\n        :raises:\n         * RuntimeError (Argument \\`name\\` is not valid)\n\n         * RuntimeError (Node *[name]* not in tree)\n\n        Using the same example tree created in\n        :py:meth:`ptrie.Trie.add_nodes`::\n\n            >>> from __future__ import print_function\n            >>> import docs.support.ptrie_example, pprint\n            >>> tobj = docs.support.ptrie_example.create_tree()\n            >>> print(tobj)\n            root\n            \u251cbranch1 (*)\n            \u2502\u251cleaf1\n            \u2502\u2502\u2514subleaf1 (*)\n            \u2502\u2514leaf2 (*)\n            \u2502 \u2514subleaf2\n            \u2514branch2\n            >>> pprint.pprint(tobj.get_subtree('root.branch1'))\n            ['root.branch1',\n             'root.branch1.leaf1',\n             'root.branch1.leaf1.subleaf1',\n             'root.branch1.leaf2',\n             'root.branch1.leaf2.subleaf2']\n        \"\"\"\n        if self._validate_node_name(name):\n            raise RuntimeError(\"Argument `name` is not valid\")\n        self._node_in_tree(name)\n        return self._get_subtree(name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef in_tree(self, name):\n        if self._validate_node_name(name):\n            raise RuntimeError(\"Argument `name` is not valid\")\n        return name in self._db", "response": "r Test if a node is in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_leaf(self, name):\n        if self._validate_node_name(name):\n            raise RuntimeError(\"Argument `name` is not valid\")\n        self._node_in_tree(name)\n        return not self._db[name][\"children\"]", "response": "r Test if a node is a leaf node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake a sub - node the root node of the tree.", "response": "def make_root(self, name):  # noqa: D302\n        r\"\"\"\n        Make a sub-node the root node of the tree.\n\n        All nodes not belonging to the sub-tree are deleted\n\n        :param name: New root node name\n        :type  name: :ref:`NodeName`\n\n        :raises:\n         * RuntimeError (Argument \\`name\\` is not valid)\n\n         * RuntimeError (Node *[name]* not in tree)\n\n        Using the same example tree created in\n        :py:meth:`ptrie.Trie.add_nodes`::\n\n            >>> from __future__ import print_function\n            >>> import docs.support.ptrie_example\n            >>> tobj = docs.support.ptrie_example.create_tree()\n            >>> print(tobj)\n            root\n            \u251cbranch1 (*)\n            \u2502\u251cleaf1\n            \u2502\u2502\u2514subleaf1 (*)\n            \u2502\u2514leaf2 (*)\n            \u2502 \u2514subleaf2\n            \u2514branch2\n            >>> tobj.make_root('root.branch1')\n            >>> print(tobj)\n            root.branch1 (*)\n            \u251cleaf1\n            \u2502\u2514subleaf1 (*)\n            \u2514leaf2 (*)\n             \u2514subleaf2\n        \"\"\"\n        if self._validate_node_name(name):\n            raise RuntimeError(\"Argument `name` is not valid\")\n        if (name != self.root_name) and (self._node_in_tree(name)):\n            for key in [node for node in self.nodes if node.find(name) != 0]:\n                del self._db[key]\n            self._db[name][\"parent\"] = \"\"\n            self._root = name\n            self._root_hierarchy_length = len(\n                self.root_name.split(self._node_separator)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef print_node(self, name):  # noqa: D302\n        if self._validate_node_name(name):\n            raise RuntimeError(\"Argument `name` is not valid\")\n        self._node_in_tree(name)\n        node = self._db[name]\n        children = (\n            [self._split_node_name(child)[-1] for child in node[\"children\"]]\n            if node[\"children\"]\n            else node[\"children\"]\n        )\n        data = (\n            node[\"data\"][0]\n            if node[\"data\"] and (len(node[\"data\"]) == 1)\n            else node[\"data\"]\n        )\n        return (\n            \"Name: {node_name}\\n\"\n            \"Parent: {parent_name}\\n\"\n            \"Children: {children_list}\\n\"\n            \"Data: {node_data}\".format(\n                node_name=name,\n                parent_name=node[\"parent\"] if node[\"parent\"] else None,\n                children_list=\", \".join(children) if children else None,\n                node_data=data if data else None,\n            )\n        )", "response": "r\"\"\"\n        Print node information (parent, children and data).\n\n        :param name: Node name\n        :type  name: :ref:`NodeName`\n\n        :raises:\n         * RuntimeError (Argument \\`name\\` is not valid)\n\n         * RuntimeError (Node *[name]* not in tree)\n\n        Using the same example tree created in\n        :py:meth:`ptrie.Trie.add_nodes`::\n\n            >>> from __future__ import print_function\n            >>> import docs.support.ptrie_example\n            >>> tobj = docs.support.ptrie_example.create_tree()\n            >>> print(tobj)\n            root\n            \u251cbranch1 (*)\n            \u2502\u251cleaf1\n            \u2502\u2502\u2514subleaf1 (*)\n            \u2502\u2514leaf2 (*)\n            \u2502 \u2514subleaf2\n            \u2514branch2\n            >>> print(tobj.print_node('root.branch1'))\n            Name: root.branch1\n            Parent: root\n            Children: leaf1, leaf2\n            Data: [5, 7]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rename_node(self, name, new_name):  # noqa: D302\n        if self._validate_node_name(name):\n            raise RuntimeError(\"Argument `name` is not valid\")\n        if self._validate_node_name(new_name):\n            raise RuntimeError(\"Argument `new_name` is not valid\")\n        self._node_in_tree(name)\n        if self.in_tree(new_name) and (name != self.root_name):\n            raise RuntimeError(\"Node {0} already exists\".format(new_name))\n        sep = self._node_separator\n        if (name.split(sep)[:-1] != new_name.split(sep)[:-1]) and (\n            name != self.root_name\n        ):\n            raise RuntimeError(\"Argument `new_name` has an illegal root node\")\n        old_hierarchy_length = len(name.split(self._node_separator))\n        new_hierarchy_length = len(new_name.split(self._node_separator))\n        if (name == self.root_name) and (old_hierarchy_length < new_hierarchy_length):\n            raise RuntimeError(\"Argument `new_name` is an illegal root node name\")\n        self._rename_node(name, new_name)", "response": "This method renames a node in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch the tree for all nodes with a specific name.", "response": "def search_tree(self, name):  # noqa: D302\n        r\"\"\"\n        Search tree for all nodes with a specific name.\n\n        :param name: Node name to search for\n        :type  name: :ref:`NodeName`\n\n        :raises: RuntimeError (Argument \\`name\\` is not valid)\n\n        For example:\n\n            >>> from __future__ import print_function\n            >>> import pprint, ptrie\n            >>> tobj = ptrie.Trie('/')\n            >>> tobj.add_nodes([\n            ...     {'name':'root', 'data':[]},\n            ...     {'name':'root/anode', 'data':7},\n            ...     {'name':'root/bnode', 'data':[]},\n            ...     {'name':'root/cnode', 'data':[]},\n            ...     {'name':'root/bnode/anode', 'data':['a', 'b', 'c']},\n            ...     {'name':'root/cnode/anode/leaf', 'data':True}\n            ... ])\n            >>> print(tobj)\n            root\n            \u251canode (*)\n            \u251cbnode\n            \u2502\u2514anode (*)\n            \u2514cnode\n             \u2514anode\n              \u2514leaf (*)\n            >>> pprint.pprint(tobj.search_tree('anode'), width=40)\n            ['root/anode',\n             'root/bnode/anode',\n             'root/cnode/anode',\n             'root/cnode/anode/leaf']\n        \"\"\"\n        if self._validate_node_name(name):\n            raise RuntimeError(\"Argument `name` is not valid\")\n        return self._search_tree(name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the base directory of a file.", "response": "def find_root(filename, target='bids'):\n    \"\"\"Find base directory (root) for a filename.\n\n    Parameters\n    ----------\n    filename : instance of Path\n        search the root for this file\n    target: str\n        'bids' (the directory containing 'participants.tsv'), 'subject' (the\n        directory starting with 'sub-'), 'session' (the directory starting with\n        'ses-')\n\n    Returns\n    -------\n    Path\n        path of the target directory\n    \"\"\"\n    lg.debug(f'Searching root in {filename}')\n    if target == 'bids' and (filename / 'dataset_description.json').exists():\n        return filename\n    elif filename.is_dir():\n        pattern = target[:3] + '-'\n        if filename.stem.startswith(pattern):\n            return filename\n\n    return find_root(filename.parent, target)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_in_bids(filename, pattern=None, generator=False, upwards=False,\n                 wildcard=True, **kwargs):\n    \"\"\"Find nearest file matching some criteria.\n\n    Parameters\n    ----------\n    filename : instance of Path\n        search the root for this file\n    pattern : str\n        glob string for search criteria of the filename of interest (remember\n        to include '*'). The pattern is passed directly to rglob.\n    wildcard : bool\n        use wildcards for unspecified fields or not (if True, add \"_*_\" between\n        fields)\n    upwards : bool\n        where to keep on searching upwards\n    kwargs : dict\n\n\n    Returns\n    -------\n    Path\n        filename matching the pattern\n    \"\"\"\n    if upwards and generator:\n        raise ValueError('You cannot search upwards and have a generator')\n\n    if pattern is None:\n        pattern = _generate_pattern(wildcard, kwargs)\n\n    lg.debug(f'Searching {pattern} in {filename}')\n\n    if upwards and filename == find_root(filename):\n        raise FileNotFoundError(f'Could not find file matchting {pattern} in {filename}')\n\n    if generator:\n        return filename.rglob(pattern)\n\n    matches = list(filename.rglob(pattern))\n    if len(matches) == 1:\n        return matches[0]\n\n    elif len(matches) == 0:\n        if upwards:\n            return find_in_bids(filename.parent, pattern=pattern, upwards=upwards)\n        else:\n            raise FileNotFoundError(f'Could not find file matching {pattern} in {filename}')\n\n    else:\n        matches_str = '\"\\n\\t\"'.join(str(x) for x in matches)\n        raise FileNotFoundError(f'Multiple files matching \"{pattern}\":\\n\\t\"{matches_str}\"')", "response": "Find nearest file in the hierarchy of directories."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef define_format(self, plotStyle, plotSize):\n\n        #Default sizes for computer\n        sizing_dict = {}\n        sizing_dict['figure.figsize'] = (14, 8)\n        sizing_dict['legend.fontsize'] = 15\n        sizing_dict['axes.labelsize'] = 20\n        sizing_dict['axes.titlesize'] = 24\n        sizing_dict['xtick.labelsize'] = 14\n        sizing_dict['ytick.labelsize'] = 14\n        \n        self.colorVector = {\n        'iron':'#4c4c4c',\n        'silver':'#cccccc',                  \n        'dark blue':'#0072B2',\n        'green':'#009E73', \n        'orangish':'#D55E00',\n        'pink':'#CC79A7',\n        'yellow':'#F0E442',\n        'cyan':'#56B4E9',\n        'olive':'#bcbd22',\n        'grey':'#7f7f7f',\n        'skin':'#FFB5B8'}\n\n        #sizing_dict['text.usetex'] = True\n        \n        #--Update the colors/format\n        if plotStyle == None:\n            self.ColorVector = [None, None, None]\n        \n        elif plotStyle == 'dark':\n            plt.style.use('dark_background')\n\n        elif plotStyle == 'night':\n            \n            plt.style.use('seaborn-colorblind')\n            \n            iron_color = '#4c4c4c' #Iron: (76 76 76)\n            silver_color = '#cccccc' #Silver: (204 204 204) \n            sizing_dict['axes.facecolor']   = iron_color\n            sizing_dict['figure.facecolor'] = iron_color\n            sizing_dict['axes.edgecolor']   = silver_color\n            sizing_dict['text.color']       = silver_color\n            sizing_dict['axes.labelcolor']  = silver_color\n            sizing_dict['xtick.color']      = silver_color\n            sizing_dict['ytick.color']      = silver_color\n            sizing_dict['axes.edgecolor']   = silver_color\n\n            \n            #'plt.rc('axes', prop_cycle=(cycler('color', ['r', 'g', 'b', 'y']) + cycler('linestyle', ['-', '--', ':', '-.'])))'\n            #This should be the set up for the cycler we just need to add the colors\n            #axes.prop_cycle : cycler('color', 'bgrcmyk')\n\n        elif plotStyle == 'colorblind':\n            plt.style.use('seaborn-colorblind')\n\n        else:\n            plt.style.use(plotStyle)\n        \n        #--Load particular configuration for this plot\n        if plotSize == 'medium':            \n            rcParams.update(sizing_dict)\n        \n        elif type(plotSize) is dict:\n            sizing_dict.update(plotSize)\n            rcParams.update(sizing_dict)\n\n        '''\n        Seaborn color blind\n        #0072B2 dark blue\n        #009E73 green \n        #D55E00 orangish\n        #CC79A7 pink\n        #F0E442 yellow\n        #56B4E9 cyan\n        #bcbd22 olive #adicional\n        #7f7f7f grey\n        #FFB5B8 skin\n        '''\n \n    \n        '''\n        Matplotlib default palete\n        #17becf dark blue\n        #bcbd22 orange\n        #2ca02c green\n        #e377c2 red\n        #8c564b purple\n        #9467bd brown\n        #d62728 pink\n        #7f7f7f grey\n        #ff7f0e olive\n        #1f77b4 cyan\n        '''\n\n\n  \n        '''\n        --These are matplotlib styles\n        seaborn-darkgrid\n        seaborn-notebook\n        classic\n        seaborn-ticks\n        grayscale\n        bmh\n        seaborn-talk\n        dark_background\n        ggplot\n        fivethirtyeight\n        seaborn-colorblind\n        seaborn-deep\n        seaborn-whitegrid\n        seaborn-bright\n        seaborn-poster\n        seaborn-muted\n        seaborn-paper\n        seaborn-white\n        seaborn-pastel\n        seaborn-dark\n        seaborn\n        seaborn-dark-palette\n        '''", "response": "Define the format of the log entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget xyz coordinates for all the electrodes in the current locale.", "response": "def get_xyz(self, list_of_names=None):\n        \"\"\"Get xyz coordinates for these electrodes\n\n        Parameters\n        ----------\n        list_of_names : list of str\n            list of electrode names to use\n\n        Returns\n        -------\n        list of tuples of 3 floats (x, y, z)\n            list of xyz coordinates for all the electrodes\n\n        TODO\n        ----\n        coordinate system of electrodes\n        \"\"\"\n        if list_of_names is not None:\n            filter_lambda = lambda x: x['name'] in list_of_names\n        else:\n            filter_lambda = None\n\n        return self.electrodes.get(filter_lambda=filter_lambda,\n                                   map_lambda=lambda e: (float(e['x']),\n                                                         float(e['y']),\n                                                         float(e['z'])))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bces(y1,y1err,y2,y2err,cerr):\n\t# Arrays holding the code main results for each method:\n\t# Elements: 0-Y|X, 1-X|Y, 2-bisector, 3-orthogonal\n\ta,b,avar,bvar,covarxiz,covar_ba=numpy.zeros(4),numpy.zeros(4),numpy.zeros(4),numpy.zeros(4),numpy.zeros(4),numpy.zeros(4)\n\t# Lists holding the xi and zeta arrays for each method above\n\txi,zeta=[],[]\n\t\n\t# Calculate sigma's for datapoints using length of conf. intervals\n\tsig11var = numpy.mean( y1err**2 )\n\tsig22var = numpy.mean( y2err**2 )\n\tsig12var = numpy.mean( cerr )\n\t\n\t# Covariance of Y1 (X) and Y2 (Y)\n\tcovar_y1y2 = numpy.mean( (y1-y1.mean())*(y2-y2.mean()) )\n\n\t# Compute the regression slopes\n\ta[0] = (covar_y1y2 - sig12var)/(y1.var() - sig11var)\t# Y|X\n\ta[1] = (y2.var() - sig22var)/(covar_y1y2 - sig12var)\t# X|Y\n\ta[2] = ( a[0]*a[1] - 1.0 + numpy.sqrt((1.0 + a[0]**2)*(1.0 + a[1]**2)) ) / (a[0]+a[1])\t# bisector\n\tif covar_y1y2<0:\n\t\tsign = -1.\n\telse:\n\t\tsign = 1.\n\ta[3] = 0.5*((a[1]-(1./a[0])) + sign*numpy.sqrt(4.+(a[1]-(1./a[0]))**2))\t# orthogonal\n\t\n\t# Compute intercepts\n\tfor i in range(4):\n\t\tb[i]=y2.mean()-a[i]*y1.mean()\n\t\n\t# Set up variables to calculate standard deviations of slope/intercept \n\txi.append(\t( (y1-y1.mean()) * (y2-a[0]*y1-b[0]) + a[0]*y1err**2 ) / (y1.var()-sig11var)\t)\t# Y|X\n\txi.append(\t( (y2-y2.mean()) * (y2-a[1]*y1-b[1]) - y2err**2 ) / covar_y1y2\t)\t# X|Y\n\txi.append(\txi[0] * (1.+a[1]**2)*a[2] / ((a[0]+a[1])*numpy.sqrt((1.+a[0]**2)*(1.+a[1]**2))) + xi[1] * (1.+a[0]**2)*a[2] / ((a[0]+a[1])*numpy.sqrt((1.+a[0]**2)*(1.+a[1]**2)))\t)\t# bisector\n\txi.append(\txi[0] * a[3]/(a[0]**2*numpy.sqrt(4.+(a[1]-1./a[0])**2)) + xi[1]*a[3]/numpy.sqrt(4.+(a[1]-1./a[0])**2)\t)\t# orthogonal\n\tfor i in range(4):\n\t\tzeta.append( y2 - a[i]*y1 - y1.mean()*xi[i]\t)\n\n\tfor i in range(4):\n\t\t# Calculate variance for all a and b\n\t\tavar[i]=xi[i].var()/xi[i].size\n\t\tbvar[i]=zeta[i].var()/zeta[i].size\n\t\t\n\t\t# Sample covariance obtained from xi and zeta (paragraph after equation 15 in AB96)\n\t\tcovarxiz[i]=numpy.mean( (xi[i]-xi[i].mean()) * (zeta[i]-zeta[i].mean()) )\n\t\n\t# Covariance between a and b (equation after eq. 15 in AB96)\n\tcovar_ab=covarxiz/y1.size\n\t\n\treturn a,b,numpy.sqrt(avar),numpy.sqrt(bvar),covar_ab", "response": "This function calculates the bces regression for 4 slopes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bootstrap(v):\n\tif type(v)==list:\n\t\tvboot=[]\t# list of boostrapped arrays\n\t\tn=v[0].size\n\t\tiran=scipy.random.randint(0,n,n)\t# Array of random indexes\n\t\tfor x in v:\tvboot.append(x[iran])\n\telse:\t# if v is an array, not a list of arrays\n\t\tn=v.size\n\t\tiran=scipy.random.randint(0,n,n)\t# Array of random indexes\n\t\tvboot=v[iran]\n\t\n\treturn vboot", "response": "Constructs Monte Carlo simulated data set using the\nBootstrap algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndo the BCES with bootstrapping. Usage: >>> a,b,aerr,berr,covab=bcesboot(x,xerr,y,yerr,cov,nsim) :param x,y: data :param xerr,yerr: measurement errors affecting x and y :param cov: covariance between the measurement errors (all are arrays) :param nsim: number of Monte Carlo simulations (bootstraps) :returns: a,b -- best-fit parameters a,b of the linear regression :returns: aerr,berr -- the standard deviations in a,b :returns: covab -- the covariance between a and b (e.g. for plotting confidence bands) .. note:: this method is definitely not nearly as fast as bces_regress.f. Needs to be optimized. Maybe adapt the fortran routine using f2python? v1 Mar 2012: ported from bces_regress.f. Added covariance output. Rodrigo Nemmen, http://goo.gl/8S1Oo", "response": "def bcesboot(y1,y1err,y2,y2err,cerr,nsim=10000):\n\t\n\t\"\"\"\n\tDoes the BCES with bootstrapping.\t\n\t\n\tUsage:\n\t\n\t>>> a,b,aerr,berr,covab=bcesboot(x,xerr,y,yerr,cov,nsim)\n\t\n\t:param x,y: data\n\t:param xerr,yerr: measurement errors affecting x and y\n\t:param cov: covariance between the measurement errors (all are arrays)\n\t:param nsim: number of Monte Carlo simulations (bootstraps)\n\t\n\t:returns: a,b -- best-fit parameters a,b of the linear regression \n\t:returns: aerr,berr -- the standard deviations in a,b\n\t:returns: covab -- the covariance between a and b (e.g. for plotting confidence bands)\n\t\n\t.. note:: this method is definitely not nearly as fast as bces_regress.f. Needs to be optimized. Maybe adapt the fortran routine using f2python?\n\t\n\tv1 Mar 2012: ported from bces_regress.f. Added covariance output.\n\tRodrigo Nemmen, http://goo.gl/8S1Oo\n\t\"\"\"\n\t\n\t\n\t# Progress bar initialization\n\t\n\t\"\"\"\n\tMy convention for storing the results of the bces code below as \n\tmatrixes for processing later are as follow:\n\t\n\t      simulation\\method  y|x x|y bisector orthogonal\n\t          sim0           ...\n\tAm =      sim1           ...\n\t          sim2           ...\n\t          sim3           ...\n\t\"\"\"\n\tfor i in range(nsim):\n\t\t[y1sim,y1errsim,y2sim,y2errsim,cerrsim]=bootstrap([y1,y1err,y2,y2err,cerr])\n\t\t\n\t\tasim,bsim,errasim,errbsim,covabsim=bces(y1sim,y1errsim,y2sim,y2errsim,cerrsim)\t\n\t\t\n\t\tif i==0:\n\t\t\t# Initialize the matrixes\n\t\t\tam,bm=asim.copy(),bsim.copy()\n\t\telse: \n\t\t\tam=numpy.vstack((am,asim))\n\t\t\tbm=numpy.vstack((bm,bsim))\n\t\t\t\t\n\t\t# Progress bar\n\t\n\t# Bootstrapping results\n\ta=numpy.array([ am[:,0].mean(),am[:,1].mean(),am[:,2].mean(),am[:,3].mean() ])\n\tb=numpy.array([ bm[:,0].mean(),bm[:,1].mean(),bm[:,2].mean(),bm[:,3].mean() ])\n\n\t# Error from unbiased sample variances\n\terra,errb,covab=numpy.zeros(4),numpy.zeros(4),numpy.zeros(4)\n\tfor i in range(4):\n\t\terra[i]=numpy.sqrt( 1./(nsim-1) * ( numpy.sum(am[:,i]**2)-nsim*(am[:,i].mean())**2 ))\n\t\terrb[i]=numpy.sqrt( 1./(nsim-1) * ( numpy.sum(bm[:,i]**2)-nsim*(bm[:,i].mean())**2 ))\n\t\tcovab[i]=1./(nsim-1) * ( numpy.sum(am[:,i]*bm[:,i])-nsim*am[:,i].mean()*bm[:,i].mean() )\n\t\n\treturn a,b,erra,errb,covab"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bcesboot_backup(y1,y1err,y2,y2err,cerr,nsim=10000):\n\timport fish\n\t\n\t# Progress bar initialization\n\tpeixe = fish.ProgressFish(total=nsim)\n\tprint \"Bootstrapping progress:\"\n\t\n\t\"\"\"\n\tMy convention for storing the results of the bces code below as \n\tmatrixes for processing later are as follow:\n\t\n\t      simulation\\method  y|x x|y bisector orthogonal\n\t          sim0           ...\n\tAm =      sim1           ...\n\t          sim2           ...\n\t          sim3           ...\n\t\"\"\"\n\tfor i in range(nsim):\n\t\t[y1sim,y1errsim,y2sim,y2errsim,cerrsim]=bootstrap([y1,y1err,y2,y2err,cerr])\n\t\t\n\t\tasim,bsim,errasim,errbsim,covabsim=bces(y1sim,y1errsim,y2sim,y2errsim,cerrsim)\t\n\t\t\n\t\tif i==0:\n\t\t\t# Initialize the matrixes\n\t\t\tam,bm=asim.copy(),bsim.copy()\n\t\telse: \n\t\t\tam=numpy.vstack((am,asim))\n\t\t\tbm=numpy.vstack((bm,bsim))\n\t\t\t\t\n\t\t# Progress bar\n\t\tpeixe.animate(amount=i)\n\t\n\t# Bootstrapping results\n\ta=numpy.array([ am[:,0].mean(),am[:,1].mean(),am[:,2].mean(),am[:,3].mean() ])\n\tb=numpy.array([ bm[:,0].mean(),bm[:,1].mean(),bm[:,2].mean(),bm[:,3].mean() ])\n\n\t# Error from unbiased sample variances\n\terra,errb,covab=numpy.zeros(4),numpy.zeros(4),numpy.zeros(4)\n\tfor i in range(4):\n\t\terra[i]=numpy.sqrt( 1./(nsim-1) * ( numpy.sum(am[:,i]**2)-nsim*(am[:,i].mean())**2 ))\n\t\terrb[i]=numpy.sqrt( 1./(nsim-1) * ( numpy.sum(bm[:,i]**2)-nsim*(bm[:,i].mean())**2 ))\n\t\tcovab[i]=1./(nsim-1) * ( numpy.sum(am[:,i]*bm[:,i])-nsim*am[:,i].mean()*bm[:,i].mean() )\n\t\n\treturn a,b,erra,errb,covab", "response": "This function is used to create a backup of the BCES with bootstrapping."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bcesp(y1,y1err,y2,y2err,cerr,nsim=10000):\n\timport time\t# for benchmarking\n\timport multiprocessing\n\t\n\tprint \"BCES,\", nsim,\"trials... \",\n\ttic=time.time()\n\t\n\t# Find out number of cores available\n\tncores=multiprocessing.cpu_count()\n\t# We will divide the processing into how many parts?\n\tn=2*ncores\n\t\n\t\"\"\"\n\tMust create lists that will be distributed among the many\n\tcores with structure \n\tcore1 <- [y1,y1err,y2,y2err,cerr,nsim/n]\n\tcore2 <- [y1,y1err,y2,y2err,cerr,nsim/n]\n\tetc...\n\t\"\"\"\n\tpargs=[]\t# this is a list of lists!\n\tfor i in range(n):\n\t\tpargs.append([y1,y1err,y2,y2err,cerr,nsim/n])\n\t\n\t# Initializes the parallel engine\n\tpool = multiprocessing.Pool(processes=ncores)\t# multiprocessing package\n\t\t\t\n\t\"\"\"\n\tEach core processes ab(input)\n\t\treturn matrixes Am,Bm with the results of nsim/n\n\t\tpresult[i][0] = Am with nsim/n lines\n\t\tpresult[i][1] = Bm with nsim/n lines\n\t\"\"\"\n\tpresult=pool.map(ab, pargs)\t# multiprocessing\n\tpool.close()\t# close the parallel engine\n\t\n\t# vstack the matrixes processed from all cores\n\ti=0\n\tfor m in presult:\n\t\tif i==0:\n\t\t\t# Initialize the matrixes\n\t\t\tam,bm=m[0].copy(),m[1].copy()\n\t\telse: \n\t\t\tam=numpy.vstack((am,m[0]))\n\t\t\tbm=numpy.vstack((bm,m[1]))\n\t\ti=i+1\n\t\n\t# Computes the bootstrapping results on the stacked matrixes\n\ta=numpy.array([ am[:,0].mean(),am[:,1].mean(),am[:,2].mean(),am[:,3].mean() ])\n\tb=numpy.array([ bm[:,0].mean(),bm[:,1].mean(),bm[:,2].mean(),bm[:,3].mean() ])\n\n\t# Error from unbiased sample variances\n\terra,errb,covab=numpy.zeros(4),numpy.zeros(4),numpy.zeros(4)\n\tfor i in range(4):\n\t\terra[i]=numpy.sqrt( 1./(nsim-1) * ( numpy.sum(am[:,i]**2)-nsim*(am[:,i].mean())**2 ))\n\t\terrb[i]=numpy.sqrt( 1./(nsim-1) * ( numpy.sum(bm[:,i]**2)-nsim*(bm[:,i].mean())**2 ))\n\t\tcovab[i]=1./(nsim-1) * ( numpy.sum(am[:,i]*bm[:,i])-nsim*am[:,i].mean()*bm[:,i].mean() )\n\t\n\tprint \"%f s\" % (time.time() - tic)\t\n\t\n\treturn a,b,erra,errb,covab", "response": "This function is a parallel version of the BCES with bootstrapping. It will create a list of lists that will be distributed among the cores of the current system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the sample arithmetic mean of data.", "response": "def mean(data):\n    \"\"\"Return the sample arithmetic mean of data.\"\"\"\n    #: http://stackoverflow.com/a/27758326\n    n = len(data)\n    if n < 1:\n        raise ValueError('mean requires at least one data point')\n    return sum(data)/n"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the population standard deviation.", "response": "def pstdev(data):\n    \"\"\"Calculates the population standard deviation.\"\"\"\n    #: http://stackoverflow.com/a/27758326\n    n = len(data)\n    if n < 2:\n        raise ValueError('variance requires at least two data points')\n    ss = _ss(data)\n    pvar = ss/n  # the population variance\n    return pvar**0.5"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_email(recipients: list, subject: str, text: str, html: str='', sender: str='', files: list=[], exceptions: bool=False):\n    import sendgrid\n    from sendgrid.helpers.mail import Content, Mail, Attachment\n    from django.conf import settings\n    from base64 import b64encode\n    from os.path import basename\n    from django.utils.timezone import now\n    from jutil.logs import log_event\n\n    try:\n        # default sender to settings.DEFAULT_FROM_EMAIL\n        if not sender:\n            sender = settings.DEFAULT_FROM_EMAIL\n\n        # support multiple recipient list styles\n        if isinstance(recipients, str):  # allow single email and comma-separated list as input\n            recipients = [str(r).strip() for r in recipients.split(',')]\n\n        sg = sendgrid.SendGridAPIClient(apikey=settings.EMAIL_SENDGRID_API_KEY)\n        from_email = sendgrid.Email(sender or settings.DEFAULT_FROM_EMAIL)\n        content = Content('text/plain', text) if not html else Content('text/html', html)\n\n        attachments = []\n        for filename in files:\n            with open(filename, 'rb') as fp:\n                attachment = Attachment()\n                attachment.content = b64encode(fp.read()).decode()\n                attachment.type = \"application/octet-stream\"\n                attachment.filename = basename(filename)\n                attachment.content_id = basename(filename)\n                attachment.disposition = \"attachment\"\n                attachments.append(attachment)\n    except Exception as e:\n        logger.error(e)\n        if exceptions:\n            raise\n        return -1\n\n    status_codes = []\n    for recipient in recipients:\n        try:\n            t = now()\n\n            to_email = sendgrid.Email()\n            if isinstance(recipient, str):\n                to_email.email = recipient\n            elif (isinstance(recipient, list) or isinstance(recipient, tuple)) and len(recipient) == 2:\n                to_email.name = recipient[0]\n                to_email.email = recipient[1]\n            else:\n                raise Exception('Invalid recipient format: {}'.format(recipient))\n\n            mail = Mail(from_email=from_email, subject=subject, to_email=to_email, content=content)\n            for attachment in attachments:\n                mail.add_attachment(attachment)\n            res = sg.client.mail.send.post(request_body=mail.get())\n\n            send_dt = (now()-t).total_seconds()\n            if res.status_code == 202:\n                log_event('EMAIL_SENT', data={'time': send_dt, 'to': recipient, 'subject': subject, 'status': res.status_code})\n            else:\n                log_event('EMAIL_ERROR', data={'time': send_dt, 'to': recipient, 'subject': subject, 'status': res.status_code, 'body': res.body})\n\n            status_codes.append(res.status_code)\n        except Exception as e:\n            logger.error(e)\n            if exceptions:\n                raise\n            status_codes.append(-1)\n\n    for status in status_codes:\n        if status != 202:\n            return status\n    return 202", "response": "Sends an email to the specified recipients."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_whitespace(s):\n    ignores = {}\n    for ignore in html_ignore_whitespace_re.finditer(s):\n        name = \"{}{}{}\".format(r\"{}\", uuid.uuid4(), r\"{}\")\n        ignores[name] = ignore.group()\n        s = s.replace(ignore.group(), name)\n    s = whitespace_re(r' ', s).strip()\n    for name, val in ignores.items():\n        s = s.replace(name, val)\n    return s", "response": "Unsafely removes HTML whitespace from a string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hashtag_links(uri, s):\n    for tag, after in hashtag_re.findall(s):\n        _uri = '/' + (uri or \"\").lstrip(\"/\") + quote(tag)\n        link = '<a href=\"{}\">#{}</a>{}'.format(_uri.lower(), tag, after)\n        s = s.replace('#' + tag, link)\n    return s", "response": "Turn hashtag - like strings into HTML links"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nturn mentions - like strings into HTML links", "response": "def mentions_links(uri, s):\n    \"\"\" Turns mentions-like strings into HTML links,\n        @uri: /uri/ root for the hashtag-like\n        @s: the #str string you're looking for |@|mentions in\n\n        -> #str HTML link |<a href=\"/uri/mention\">mention</a>|\n    \"\"\"\n    for username, after in mentions_re.findall(s):\n        _uri = '/' + (uri or \"\").lstrip(\"/\") + quote(username)\n        link = '<a href=\"{}\">@{}</a>{}'.format(_uri.lower(), username, after)\n        s = s.replace('@' + username, link)\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a new filtered query.", "response": "def filter(self, query: Query):\n        \"\"\"Return a new filtered query.\n        \n        Use the tree to filter the query and return a new query \"filtered\".\n        This query can be filtered again using another tree or even a manual\n        filter.\n        To manually filter query see :\n         - https://docs.sqlalchemy.org/en/rel_1_2/orm/query.html?highlight=filter#sqlalchemy.orm.query.Query.filter\n        \"\"\"\n        entity = query.column_descriptions[0]['type']\n        new_query, filters = self._root.filter(query, entity)\n        return new_query.filter(filters)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef print_progress_bar(iteration, total, prefix='', suffix='', decimals=1, length=100, fill='\u2588'):\n    percent = (\"{0:.\" + str(decimals) + \"f}\").format(100 * (iteration / float(total)))\n    # filled_length = int(length * iteration // total)\n    # bar = fill * filled_length + '-' * (length - filled_length)\n    # print('\\r %s |%s| %s %s' % (prefix, bar, percent, suffix), end='\\r')\n    print(percent)\n    # Print New Line on Complete\n    if iteration == total:\n        print()", "response": "Print a progress bar for a given iteration and total."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting a progress bar for nb_threads threads.", "response": "def print_progress_bar_multi_threads(nb_threads, suffix='', decimals=1, length=15,\n                                     fill='\u2588'):\n    \"\"\"\n    Call in a loop to create terminal progress bar\n    @params:\n        iteration   - Required  : current iteration (Int)\n        total       - Required  : total iterations (Int)\n        prefix      - Optional  : prefix string (Str)\n        suffix      - Optional  : suffix string (Str)\n        decimals    - Optional  : positive number of decimals in percent complete (Int)\n        length      - Optional  : character length of bar (Int)\n        fill        - Optional  : bar fill character (Str)\n    \"\"\"\n    string = \"\"\n    for k in range(nb_threads):\n        try:\n            threads_state = eval(read_file(\"threads_state_%s\" % str(k)))\n        except SyntaxError:\n            time.sleep(0.001)\n            try:\n                threads_state = eval(read_file(\"threads_state_%s\" % str(k)))\n            except SyntaxError:\n                pass\n\n        iteration = threads_state[\"iteration\"]\n        total = threads_state[\"total\"]\n        percent = (\"{0:.\" + str(decimals) + \"f}\").format(100 * (iteration / float(total)))\n        # filled_length = int(length * iteration // total)\n        # bar = fill * filled_length + '-' * (length - filled_length)\n        prefix = \"Thread %s :\" % str(k)\n        string = string + '%s %s%% ' % (prefix, percent)\n\n    print(string + \" \" + suffix)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuploads the release to a pypi server.", "response": "def upload(target):\n    # type: (str) -> None\n    \"\"\" Upload the release to a pypi server.\n\n    TODO: Make sure the git directory is clean before allowing a release.\n\n    Args:\n        target (str):\n            pypi target as defined in ~/.pypirc\n    \"\"\"\n    log.info(\"Uploading to pypi server <33>{}\".format(target))\n    with conf.within_proj_dir():\n        shell.run('python setup.py sdist register -r \"{}\"'.format(target))\n        shell.run('python setup.py sdist upload -r \"{}\"'.format(target))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a new. pypirc file with the given credentials.", "response": "def gen_pypirc(username=None, password=None):\n    # type: (str, str) -> None\n    \"\"\" Generate ~/.pypirc with the given credentials.\n\n    Useful for CI builds. Can also get credentials through env variables\n    ``PYPI_USER`` and ``PYPI_PASS``.\n\n    Args:\n        username (str):\n            pypi username. If not given it will try to take it from the\n            `` PYPI_USER`` env variable.\n        password (str):\n            pypi password. If not given it will try to take it from the\n            `` PYPI_PASS`` env variable.\n    \"\"\"\n    path = join(conf.getenv('HOME'), '.pypirc')\n    username = username or conf.getenv('PYPI_USER', None)\n    password = password or conf.getenv('PYPI_PASS', None)\n\n    if username is None or password is None:\n        log.err(\"You must provide $PYPI_USER and $PYPI_PASS\")\n        sys.exit(1)\n\n    log.info(\"Generating <94>{}\".format(path))\n\n    fs.write_file(path, util.remove_indent('''\n        [distutils]\n        index-servers = pypi\n        \n        [pypi]\n        repository: https://upload.pypi.org/legacy/\n        username: {username}\n        password: {password}\n        \n    '''.format(\n        username=username,\n        password=password\n    )))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pick_sdf(filename, directory=None):\n    if directory is None:\n        directory = utils.get_undecorated_calling_module()\n        # If the 'cwd' is not '/output' (which indicates we're in a Container)\n        # then remove the CWD and the anticipated '/'\n        # from the front of the module\n        if os.getcwd() not in ['/output']:\n            directory = directory[len(os.getcwd()) + 1:]\n\n    file_path = os.path.join(directory, filename)\n    if os.path.isfile(file_path + '.sdf.gz'):\n        return file_path + '.sdf.gz'\n    elif os.path.isfile(file_path + '.sdf'):\n        return file_path + '.sdf'\n    # Couldn't find a suitable SDF file\n    return None", "response": "Returns a full path to the chosen SDF file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the text attribute of the payload of the message Taxonomy object.", "response": "def set_text(self, text):\n        \"\"\"Sets the text attribute of the payload\n\n        :param text: (str) Text of the message\n        :return: None\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.set_text')\n        if not isinstance(text, basestring):\n            msg = 'text arg must be a string'\n            log.error(msg)\n            raise ValueError(msg)\n        self.payload['text'] = text\n        log.debug('Set message text to: {t}'.format(t=text))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the icon_url for the message", "response": "def set_icon(self, icon_url):\n        \"\"\"Sets the icon_url for the message\n\n        :param icon_url: (str) Icon URL\n        :return: None\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.set_icon')\n        if not isinstance(icon_url, basestring):\n            msg = 'icon_url arg must be a string'\n            log.error(msg)\n            raise ValueError(msg)\n        self.payload['icon_url'] = icon_url\n        log.debug('Set Icon URL to: {u}'.format(u=icon_url))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd an attachment to the payload", "response": "def add_attachment(self, attachment):\n        \"\"\"Adds an attachment to the SlackMessage payload\n\n        This public method adds a slack message to the attachment\n        list.\n\n        :param attachment: SlackAttachment object\n        :return: None\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.add_attachment')\n        if not isinstance(attachment, SlackAttachment):\n            msg = 'attachment must be of type: SlackAttachment'\n            log.error(msg)\n            raise ValueError(msg)\n        self.attachments.append(attachment.attachment)\n        log.debug('Added attachment: {a}'.format(a=attachment))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends the Slack message along with any availabe attachments.", "response": "def send(self):\n        \"\"\"Sends the Slack message\n\n        This public method sends the Slack message along with any\n        attachments, then clears the attachments array.\n\n        :return: None\n        :raises: OSError\n        \"\"\"\n        log = logging.getLogger(self.cls_logger + '.send')\n\n        if self.attachments:\n            self.payload['attachments'] = self.attachments\n\n        # Encode payload in JSON\n        log.debug('Using payload: %s', self.payload)\n        try:\n            json_payload = json.JSONEncoder().encode(self.payload)\n        except(TypeError, ValueError, OverflowError):\n            _, ex, trace = sys.exc_info()\n            msg = 'There was a problem encoding the JSON payload\\n{e}'.format(e=str(ex))\n            raise OSError, msg, trace\n        else:\n            log.debug('JSON payload: %s', json_payload)\n\n        # Post to Slack!\n        log.debug('Posting message to Slack...')\n        try:\n            result = requests.post(url=self.webhook_url, data=json_payload)\n        except requests.exceptions.ConnectionError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a problem posting to Slack\\n{e}'.format(n=ex.__class__.__name__, e=str(ex))\n            raise OSError, msg, trace\n\n        # Check return code\n        if result.status_code != 200:\n            log.error('Slack post to url {u} failed with code: {c}'.format(c=result.status_code, u=self.webhook_url))\n        else:\n            log.debug('Posted message to Slack successfully.')\n\n        # Clear out attachments after sending\n        self.attachments = []\n        self.payload.pop('attachments', None)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_cons3rt_agent_logs(self):\n        log = logging.getLogger(self.cls_logger + '.send_cons3rt_agent_logs')\n\n        log.debug('Searching for log files in directory: {d}'.format(d=self.dep.cons3rt_agent_log_dir))\n        for item in os.listdir(self.dep.cons3rt_agent_log_dir):\n            item_path = os.path.join(self.dep.cons3rt_agent_log_dir, item)\n            if os.path.isfile(item_path):\n                log.debug('Adding slack attachment with cons3rt agent log file: {f}'.format(f=item_path))\n                try:\n                    with open(item_path, 'r') as f:\n                        file_text = f.read()\n                except (IOError, OSError) as e:\n                    log.warn('There was a problem opening file: {f}\\n{e}'.format(f=item_path, e=e))\n                    continue\n\n                # Take the last 7000 characters\n                file_text_trimmed = file_text[-7000:]\n                attachment = SlackAttachment(fallback=file_text_trimmed, text=file_text_trimmed, color='#9400D3')\n                self.add_attachment(attachment)\n        self.send()", "response": "Sends a Slack message with an attachment for each cons3rt agent log file"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_text_file(self, text_file):\n        log = logging.getLogger(self.cls_logger + '.send_text_file')\n\n        if not isinstance(text_file, basestring):\n            msg = 'arg text_file must be a string, found type: {t}'.format(t=text_file.__class__.__name__)\n            raise Cons3rtSlackerError(msg)\n\n        if not os.path.isfile(text_file):\n            msg = 'The provided text_file was not found or is not a file: {f}'.format(f=text_file)\n            raise Cons3rtSlackerError(msg)\n\n        log.debug('Attempting to send a Slack message with the contents of file: {f}'.format(f=text_file))\n        try:\n            with open(text_file, 'r') as f:\n                file_text = f.read()\n        except (IOError, OSError):\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a problem opening file: {f}\\n{e}'.format(\n                n=ex.__class__.__name__, f=text_file, e=str(ex))\n            raise Cons3rtSlackerError, msg, trace\n\n        # Take the last 7000 characters\n        file_text_trimmed = file_text[-7000:]\n        attachment = SlackAttachment(fallback=file_text_trimmed, text=file_text_trimmed, color='#9400D3')\n        self.add_attachment(attachment)\n        self.send()", "response": "Sends a Slack message with the contents of a text file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeploying the app to the target environment.", "response": "def deploy(project, version, promote, quiet):\n    \"\"\" Deploy the app to the target environment.\n\n    The target environments can be configured using the ENVIRONMENTS conf\n    variable. This will also collect all static files and compile translation\n    messages\n    \"\"\"\n    from . import logic\n\n    logic.deploy(project, version, promote, quiet)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef call_plugins(self, step):\n        '''\n        For each plugins, check if a \"step\" method exist on it, and call it\n\n        Args:\n            step (str): The method to search and call on each plugin\n        '''\n        for plugin in self.plugins:\n            try:\n                getattr(plugin, step)()\n            except AttributeError:\n                self.logger.debug(\"{} doesn't exist on plugin {}\".format(step, plugin))\n            except TypeError:\n                self.logger.debug(\"{} on plugin {} is not callable\".format(step, plugin))", "response": "Calls the step method on each plugin in the list of plugins."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pretend_option(fn):\n    # type: (FunctionType) -> FunctionType\n    \"\"\" Decorator to add a --pretend option to any click command.\n\n    The value won't be passed down to the command, but rather handled in the\n    callback. The value will be accessible through `peltak.core.context` under\n    'pretend' if the command needs it. To get the current value you can do:\n\n        >>> from peltak.commands import click, root_cli\n        >>> from peltak.core import context\n        >>>\n        >>> @root_cli.command('my-command')\n        >>> @pretend_option\n        >>> def my_command():\n        ...     pretend = context.get('pretend', False)\n\n    This value will be accessible from anywhere in the code.\n    \"\"\"\n\n    def set_pretend(ctx, param, value):     # pylint: disable=missing-docstring\n        # type: (click.Context, str, Any) -> None\n        from peltak.core import context\n        from peltak.core import shell\n\n        context.set('pretend', value or False)\n        if value:\n            shell.cprint('<90>{}', _pretend_msg())\n\n    return click.option(\n        '--pretend',\n        is_flag=True,\n        help=(\"Do not actually do anything, just print shell commands that\"\n              \"would be executed.\"),\n        expose_value=False,\n        callback=set_pretend\n    )(fn)", "response": "Decorator to add a pretend option to any click command."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef verbose_option(fn):\n\n    def set_verbose(ctx, param, value):     # pylint: disable=missing-docstring\n        # type: (click.Context, str, Any) -> None\n        from peltak.core import context\n        context.set('verbose', value or 0)\n\n    return click.option(\n        '-v', '--verbose',\n        is_flag=True,\n        expose_value=False,\n        callback=set_verbose,\n        help=\"Be verbose. Can specify multiple times for more verbosity.\",\n    )(fn)", "response": "Decorator to add a verbose option to any click command."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef changelog():\n    # type: () -> str\n    \"\"\" Print change log since last release. \"\"\"\n    # Skip 'v' prefix\n    versions = [x for x in git.tags() if versioning.is_valid(x[1:])]\n\n    cmd = 'git log --format=%H'\n    if versions:\n        cmd += ' {}..HEAD'.format(versions[-1])\n\n    hashes = shell.run(cmd, capture=True).stdout.strip().splitlines()\n    commits = [git.CommitDetails.get(h) for h in hashes]\n\n    tags = conf.get('changelog.tags', [\n        {'header': 'Features', 'tag': 'feature'},\n        {'header': 'Changes', 'tag': 'change'},\n        {'header': 'Fixes', 'tag': 'fix'},\n    ])\n\n    results = OrderedDict((\n        (x['header'], []) for x in tags\n    ))\n\n    for commit in commits:\n        commit_items = extract_changelog_items(commit.desc, tags)\n        for header, items in commit_items.items():\n            results[header] += items\n\n    lines = [\n        '<35>v{}<0>'.format(versioning.current()),\n        '',\n    ]\n    for header, items in results.items():\n        if items:\n            lines += [\n                '',\n                '<32>{}<0>'.format(header),\n                '<32>{}<0>'.format('-' * len(header)),\n                '',\n            ]\n            for item_text in items:\n                item_lines = textwrap.wrap(item_text, 77)\n                lines += ['- {}'.format('\\n  '.join(item_lines))]\n\n            lines += ['']\n\n    return '\\n'.join(lines)", "response": "Print the changelog since last release."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extract_changelog_items(text, tags):\n    # type: (str) -> Dict[str, List[str]]\n    \"\"\" Extract all tagged items from text.\n\n    Args:\n        text (str):\n            Text to extract the tagged items from. Each tagged item is a\n            paragraph that starts with a tag. It can also be a text list item.\n\n    Returns:\n        tuple[list[str], list[str], list[str]]:\n            A tuple of `(features, changes, fixes)` extracted from the given\n            text.\n\n    The tagged items are usually features/changes/fixes but it can be configured\n    through `pelconf.yaml`.\n    \"\"\"\n\n    patterns = {x['header']: tag_re(x['tag']) for x in tags}\n    items = {x['header']: [] for x in tags}\n    curr_tag = None\n    curr_text = ''\n\n    for line in text.splitlines():\n        if not line.strip():\n            if curr_tag is not None:\n                items[curr_tag].append(curr_text)\n                curr_text = ''\n            curr_tag = None\n\n        for tag in tags:\n            m = patterns[tag['header']].match(line)\n            if m:\n                if curr_tag is not None:\n                    items[curr_tag].append(curr_text)\n                    curr_text = ''\n\n                curr_tag = tag['header']\n                line = m.group('text')\n                break\n\n        if curr_tag is not None:\n            curr_text = '{} {}'.format(curr_text.strip(), line.strip()).strip()\n\n    if curr_tag is not None:\n        items[curr_tag].append(curr_text)\n\n    return items", "response": "Extracts all tagged items from a given text list item."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _(mcs, cls_name=\"Object\", with_meta=None):\n        if with_meta is not None:\n            class EXType(with_meta, mcs):\n                _cls_name = cls_name\n                _base_classes = []\n                _generated_class = None\n        else:\n            class EXType(mcs):\n                _cls_name = cls_name\n                _base_classes = []\n                _generated_class = None\n\n        return EXType", "response": "Method to generate real metaclass to be used"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the class that will be used to gether logic of all available extensions of the current object.", "response": "def get_class(mcs):\n        \"\"\" Generates new class to gether logic of all available extensions\n            ::\n\n                mc = ExtensibleType._(\"MyClass\")\n                @six.add_metaclass(mc)\n                class MyClassBase(object):\n                    pass\n\n                # get class with all extensions enabled\n                MyClass = mc.get_class()\n\n        \"\"\"\n        if mcs._generated_class is None:\n            mcs._generated_class = type(\n                mcs._cls_name,\n                tuple(mcs._base_classes),\n                {'_generated': True})\n        return mcs._generated_class"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _add_base_class(mcs, cls):\n        # Do all magic only if subclass had defined required attributes\n        if getattr(mcs, '_base_classes_hash', None) is not None:\n            meta = getattr(cls, 'Meta', None)\n            _hash = getattr(meta, mcs._hashattr, None)\n            if _hash is None and cls not in mcs._get_base_classes():\n                mcs._base_classes.insert(0, cls)\n                mcs._generated_class = {}  # Cleanup all caches\n            elif _hash is not None and cls not in mcs._get_base_classes(_hash):\n                mcs._base_classes_hash[_hash].insert(0, cls)\n                mcs._generated_class[_hash] = None", "response": "Adds new class cls to base classes\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _(mcs, cls_name='Object', with_meta=None, hashattr='_name'):\n        extype = super(ExtensibleByHashType, mcs)._(cls_name=cls_name,\n                                                    with_meta=with_meta)\n\n        class EXHType(extype):\n            _hashattr = hashattr\n            _base_classes_hash = collections.defaultdict(list)\n\n            # Override it by dict to store diferent\n            # base generated class for each hash\n            _generated_class = {}\n\n        return EXHType", "response": "Method to generate real metaclass for the base class of the extended class."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the class for the given key.", "response": "def get_class(mcs, name, default=False):\n        \"\"\" Generates new class to gether logic of all available extensions\n            ::\n\n                # Create metaclass *mc*\n                mc = ExtensibleByHashType._(\"MyClass\", hashattr='name')\n\n                # Use metaclass *mc* to create base class for extensions\n                @six.add_metaclass(mc)\n                class MyClassBase(object):\n                    pass\n\n                # Create extension\n                class MyClassX1(MyClassBase):\n                    class Meta:\n                        name = 'X1'\n\n                # get default class\n                MyClass = mc.get_class(None, default=True)\n\n                # get specific class\n                MyX1 = mc.get_class('X1')\n\n            :param name: key to get class for\n            :param bool default: if set to True will generate default class for\n                                 if there no special class defined for such key\n            :return: generated class for requested type\n        \"\"\"\n        if default is False and name not in mcs._base_classes_hash:\n            raise ValueError(\n                \"There is no class registered for key '%s'\" % name)\n        if mcs._generated_class.get(name, None) is None:\n            cls = type(\n                mcs._cls_name,\n                tuple(mcs._get_base_classes(name)),\n                {'_generated': True})\n            mcs._generated_class[name] = cls\n        return mcs._generated_class[name]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_registered_names(mcs):\n        return [k for k, v in six.iteritems(mcs._base_classes_hash) if v]", "response": "Return s list of names registered in this tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the day number of the last day of the month", "response": "def get_last_day_of_month(t: datetime) -> int:\n    \"\"\"\n    Returns day number of the last day of the month\n    :param t: datetime\n    :return: int\n    \"\"\"\n    tn = t + timedelta(days=32)\n    tn = datetime(year=tn.year, month=tn.month, day=1)\n    tt = tn - timedelta(hours=1)\n    return tt.day"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlocalize the given time range. Uses pytz. utc if None provided.", "response": "def localize_time_range(begin: datetime, end: datetime, tz=None) -> (datetime, datetime):\n    \"\"\"\n    Localizes time range. Uses pytz.utc if None provided.\n    :param begin: Begin datetime\n    :param end: End datetime\n    :param tz: pytz timezone or None (default UTC)\n    :return: begin, end\n    \"\"\"\n    if not tz:\n        tz = pytz.utc\n    return tz.localize(begin), tz.localize(end)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef this_week(today: datetime=None, tz=None):\n    if today is None:\n        today = datetime.utcnow()\n    begin = today - timedelta(days=today.weekday())\n    begin = datetime(year=begin.year, month=begin.month, day=begin.day)\n    return localize_time_range(begin, begin + timedelta(days=7), tz)", "response": "Returns this week begin and end."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the current month begin and end.", "response": "def this_month(today: datetime=None, tz=None):\n    \"\"\"\n    Returns current month begin (inclusive) and end (exclusive).\n    :param today: Some date in the month (defaults current datetime)\n    :param tz: Timezone (defaults pytz UTC)\n    :return: begin (inclusive), end (exclusive)\n    \"\"\"\n    if today is None:\n        today = datetime.utcnow()\n    begin = datetime(day=1, month=today.month, year=today.year)\n    end = begin + timedelta(days=32)\n    end = datetime(day=1, month=end.month, year=end.year)\n    return localize_time_range(begin, end, tz)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn next month begin and end.", "response": "def next_month(today: datetime=None, tz=None):\n    \"\"\"\n    Returns next month begin (inclusive) and end (exclusive).\n    :param today: Some date in the month (defaults current datetime)\n    :param tz: Timezone (defaults pytz UTC)\n    :return: begin (inclusive), end (exclusive)\n    \"\"\"\n    if today is None:\n        today = datetime.utcnow()\n    begin = datetime(day=1, month=today.month, year=today.year)\n    next_mo = begin + timedelta(days=32)\n    begin = datetime(day=1, month=next_mo.month, year=next_mo.year)\n    following_mo = begin + timedelta(days=32)\n    end = datetime(day=1, month=following_mo.month, year=following_mo.year)\n    return localize_time_range(begin, end, tz)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning last year begin and end.", "response": "def last_year(today: datetime=None, tz=None):\n    \"\"\"\n    Returns last year begin (inclusive) and end (exclusive).\n    :param today: Some date (defaults current datetime)\n    :param tz: Timezone (defaults pytz UTC)\n    :return: begin (inclusive), end (exclusive)\n    \"\"\"\n    if today is None:\n        today = datetime.utcnow()\n    end = datetime(day=1, month=1, year=today.year)\n    end_incl = end - timedelta(seconds=1)\n    begin = datetime(day=1, month=1, year=end_incl.year)\n    return localize_time_range(begin, end, tz)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd + - n months to datetime.", "response": "def add_month(t: datetime, n: int=1) -> datetime:\n    \"\"\"\n    Adds +- n months to datetime.\n    Clamps to number of days in given month.\n    :param t: datetime\n    :param n: count\n    :return: datetime\n    \"\"\"\n    t2 = t\n    for count in range(abs(n)):\n        if n > 0:\n            t2 = datetime(year=t2.year, month=t2.month, day=1) + timedelta(days=32)\n        else:\n            t2 = datetime(year=t2.year, month=t2.month, day=1) - timedelta(days=2)\n        try:\n            t2 = t.replace(year=t2.year, month=t2.month)\n        except Exception:\n            first, last = monthrange(t2.year, t2.month)\n            t2 = t.replace(year=t2.year, month=t2.month, day=last)\n    return t2"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\niterate over time range in steps specified in delta.", "response": "def per_delta(start: datetime, end: datetime, delta: timedelta):\n    \"\"\"\n    Iterates over time range in steps specified in delta.\n\n    :param start: Start of time range (inclusive)\n    :param end: End of time range (exclusive)\n    :param delta: Step interval\n\n    :return: Iterable collection of [(start+td*0, start+td*1), (start+td*1, start+td*2), ..., end)\n    \"\"\"\n    curr = start\n    while curr < end:\n        curr_end = curr + delta\n        yield curr, curr_end\n        curr = curr_end"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef per_month(start: datetime, end: datetime, n: int=1):\n    curr = start.replace(day=1, hour=0, minute=0, second=0, microsecond=0)\n    while curr < end:\n        curr_end = add_month(curr, n)\n        yield curr, curr_end\n        curr = curr_end", "response": "Iterate over time range in one month steps."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the requirements as a list of string.", "response": "def get_requirements() -> List[str]:\n    \"\"\"Return the requirements as a list of string.\"\"\"\n    requirements_path = os.path.join(\n        os.path.dirname(__file__), 'requirements.txt'\n    )\n    with open(requirements_path) as f:\n        return f.read().split()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting requirements for peltak commands configured for the project.", "response": "def project_dev_requirements():\n    \"\"\" List requirements for peltak commands configured for the project.\n\n    This list is dynamic and depends on the commands you have configured in\n    your project's pelconf.yaml. This will be the combined list of packages\n    needed to be installed in order for all the configured commands to work.\n    \"\"\"\n    from peltak.core import conf\n    from peltak.core import shell\n\n    for dep in sorted(conf.requirements):\n        shell.cprint(dep)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_func_params(method, called_params):\n    insp = inspect.getfullargspec(method)\n    if not isinstance(called_params, dict):\n        raise UserWarning()\n    _called_params = called_params.copy()\n    params = {}\n    arg_count = len(insp.args)\n    arg_def_count = len(insp.defaults) if insp.defaults is not None else 0\n    for i in range(arg_count):\n        arg = insp.args[i]\n        if i == 0 and isinstance(method, types.MethodType):\n            continue  # skip self argument\n        if arg in _called_params:\n            params[arg] = _called_params.pop(arg)\n        elif i - arg_count + arg_def_count >= 0:\n            params[arg] = insp.defaults[i - arg_count + arg_def_count]\n        else:\n            raise TypeError('Argument \"%s\" not given' % arg)\n    for kwarg in insp.kwonlyargs:\n        if kwarg in _called_params:\n            params[kwarg] = _called_params.pop(kwarg)\n        elif kwarg in insp.kwonlydefaults:\n            params[kwarg] = insp.kwonlydefaults[kwarg]\n        else:\n            raise TypeError('Argument \"%s\" not given' % kwarg)\n    if insp.varkw is None:\n        if len(_called_params) > 0:\n            raise TypeError('Got unexpected parameter(s): %s'\n                            '' % (\", \".join(_called_params)))\n    else:\n        params.update(_called_params)\n    return params", "response": "Get the parameters of a function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_images():\n    # type: () -> None\n    \"\"\" Build all docker images for the project. \"\"\"\n    registry = conf.get('docker.registry')\n    docker_images = conf.get('docker.images', [])\n\n    for image in docker_images:\n        build_image(registry, image)", "response": "Builds all docker images for the project."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npushes all project docker images to a remote registry.", "response": "def push_images():\n    # type: () -> None\n    \"\"\" Push all project docker images to a remote registry. \"\"\"\n    registry = conf.get('docker.registry')\n    docker_images = conf.get('docker.images', [])\n\n    if registry is None:\n        log.err(\"You must define docker.registry conf variable to push images\")\n        sys.exit(-1)\n\n    for image in docker_images:\n        push_image(registry, image)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists docker images stored in the remote registry.", "response": "def docker_list(registry_pass):\n    # type: (str) -> None\n    \"\"\" List docker images stored in the remote registry.\n\n    Args:\n        registry_pass (str):\n            Remote docker registry password.\n    \"\"\"\n    registry = conf.get('docker.registry', None)\n\n    if registry is None:\n        log.err(\"You must define docker.registry conf variable to list images\")\n        sys.exit(-1)\n\n    registry_user = conf.get('docker.registry_user', None)\n\n    if registry_user is None:\n        registry_user = click.prompt(\"Username\")\n\n    rc = client.RegistryClient(registry, registry_user, registry_pass)\n    images = {x: rc.list_tags(x) for x in rc.list_images()}\n\n    shell.cprint(\"<32>Images in <34>{} <32>registry:\", registry)\n    for image, tags in images.items():\n        shell.cprint('  <92>{}', image)\n        for tag in tags:\n            shell.cprint('      <90>{}:<35>{}', image, tag)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_image(registry, image):\n    # type: (str, Dict[str, Any]) -> None\n    \"\"\" Build docker image.\n\n    Args:\n        registry (str):\n            The name of the registry this image belongs to. If not given, the\n            resulting image will have a name without the registry.\n        image (dict[str, Any]):\n            The dict containing the information about the built image. This is\n            the same dictionary as defined in DOCKER_IMAGES variable.\n    \"\"\"\n    if ':' in image['name']:\n        _, tag = image['name'].split(':', 1)\n    else:\n        _, tag = image['name'], None\n\n    values = {\n        'registry': '' if registry is None else registry + '/',\n        'image': image['name'],\n        'tag': tag,\n    }\n\n    if tag is None:\n        args = [\n            '-t {registry}{image}'.format(**values),\n            '-t {registry}{image}:{version}'.format(\n                version=versioning.current(),\n                **values\n            ),\n        ]\n    else:\n        args = ['-t {registry}{image}'.format(**values)]\n\n    if 'file' in image:\n        args.append('-f {}'.format(conf.proj_path(image['file'])))\n\n    with conf.within_proj_dir(image.get('path', '.')):\n        log.info(\"Building <33>{registry}<35>/{image}\", **values)\n        shell.run('docker build {args} .'.format(args=' '.join(args)))", "response": "Builds a docker image."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef push_image(registry, image):\n    # type: (str, Dict[str, Any]) -> None\n    \"\"\" Push the given image to selected repository.\n\n    Args:\n        registry (str):\n            The name of the registry we're pushing to. This is the address of\n            the repository without the protocol specification (no http(s)://)\n        image (dict[str, Any]):\n            The dict containing the information about the image. This is the\n            same dictionary as defined in DOCKER_IMAGES variable.\n    \"\"\"\n    values = {\n        'registry': registry,\n        'image': image['name'],\n    }\n\n    log.info(\"Pushing <33>{registry}<35>/{image}\".format(**values))\n    shell.run('docker push {registry}/{image}'.format(**values))", "response": "Push the given image to the given registry."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _build_opr_data(self, data, store):\n        return {\n            \"invoice_data\": {\n                \"invoice\": {\n                    \"total_amount\": data.get(\"total_amount\"),\n                    \"description\": data.get(\"description\")\n                },\n                \"store\": store.info\n            },\n            \"opr_data\": {\n                \"account_alias\": data.get(\"account_alias\")\n            }\n        }", "response": "Builds a well formatted OPR data dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate an OPR token.", "response": "def create(self, data={}, store=None):\n        \"\"\"Initiazes an OPR\n\n        First step in the OPR process is to create the OPR request.\n        Returns the OPR token\n        \"\"\"\n        _store = store or self.store\n        _data = self._build_opr_data(data, _store) if data else self._opr_data\n        return self._process('opr/create', _data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nseconds stage of an OPR request", "response": "def charge(self, data):\n        \"\"\"Second stage of an OPR request\"\"\"\n        token = data.get(\"token\", self._response[\"token\"])\n        data = {\n            \"token\": token,\n            \"confirm_token\": data.get(\"confirm_token\")\n        }\n        return self._process('opr/charge', data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nasks user the user to provide the value for the specified field.", "response": "def get_value(self, field, quick):\n        # type: (Field, bool) -> Any\n        \"\"\" Ask user the question represented by this instance.\n\n        Args:\n            field (Field):\n                The field we're asking the user to provide the value for.\n            quick (bool):\n                Enable quick mode. In quick mode, the form will reduce the\n                number of question asked by using defaults wherever possible.\n                This can greatly reduce the number of interactions required on\n                the user part, but will obviously limit the user choices. This\n                should probably be enabled only by a specific user action\n                (like passing a ``--quick`` flag etc.).\n\n        Returns:\n            The user response converted to a python type using the\n            :py:attr:`cliform.core.Field.type` converter.\n        \"\"\"\n        if callable(field.default):\n            default = field.default(self)\n        else:\n            default = field.default\n\n        if quick and default is not None:\n            return default\n\n        shell.cprint('<90>{}', field.help)\n\n        while True:\n            try:\n                answer = click.prompt(field.pretty_prompt, default=default)\n                return field.type(answer)\n            except ValueError:\n                shell.cprint(\"<31>Unsupported value\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_image(self, ami_id, instance_id):\n        log = logging.getLogger(self.cls_logger + '.update_image')\n        if not isinstance(ami_id, basestring):\n            msg = 'Arg ami_id must be of type basestring, found: {t}'.format(t=ami_id.__class__.__name__)\n            raise ImageUtilError(msg)\n        if not isinstance(instance_id, basestring):\n            msg = 'Arg instance_id must be of type basestring, found: {t}'.format(t=instance_id.__class__.__name__)\n            raise ImageUtilError(msg)\n        if ami_id is None or instance_id is None:\n            raise ImageUtilError('The provided args ami_id and instance_id must not be None')\n\n        log.info('Removing AMI ID: {a}, and replacing with an image for Instance ID: {i}'.format(\n            a=ami_id, i=instance_id))\n\n        # Get the current AMI info\n        try:\n            ami_info = self.ec2.describe_images(DryRun=False, ImageIds=[ami_id], Owners=[self.owner_id])\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: Unable to describe image ID: {a}.\\n{e}'.format(n=ex.__class__.__name__, a=ami_id, e=str(ex))\n            raise AWSAPIError, msg, trace\n        log.debug('Found AMI info: {a}'.format(a=ami_info))\n\n        # Grab the current cons3rtuuid tag data\n        cons3rt_uuid = None\n        try:\n            image_tags = ami_info['Images'][0]['Tags']\n            for image_tag in image_tags:\n                if image_tag['Key'] == 'cons3rtuuid':\n                    cons3rt_uuid = image_tag['Value']\n        except KeyError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: Unable to find image tags for AMI ID: {a}\\n{e}'.format(\n                a=ami_id, n=ex.__class__.__name__, e=str(ex))\n            raise ImageUtilError, msg, trace\n        if cons3rt_uuid is None:\n            raise ImageUtilError('AMI tag cons3rtuuid not found on image ID: {a}'.format(a=ami_id))\n        log.info('Found image tag for cons3rtuuid: {u}'.format(u=cons3rt_uuid))\n        log.debug('Found image tags: {t}'.format(t=image_tags))\n\n        # Grab the Snapshot ID\n        try:\n            snapshot_id = ami_info['Images'][0]['BlockDeviceMappings'][0]['Ebs']['SnapshotId']\n        except KeyError:\n            _, ex, trace = sys.exc_info()\n            raise ImageUtilError('{n}: Unable to determine Snapshot ID for AMI ID {a}\\n{e}'.format(\n                n=ex.__class__.__name__, a=ami_id, e=str(ex)))\n        log.info('Found Snapshot ID of the current image: {s}'.format(s=snapshot_id))\n\n        # Grab the Image name\n        try:\n            image_name = ami_info['Images'][0]['Name']\n        except KeyError:\n            _, ex, trace = sys.exc_info()\n            raise ImageUtilError('{n}: Unable to determine Image name for AMI ID {a}\\n{e}'.format(\n                n=ex.__class__.__name__, a=ami_id, e=str(ex)))\n        log.info('Found name of the current image: {n}'.format(n=image_name))\n\n        # Grab the Image description\n        try:\n            image_description = ami_info['Images'][0]['Description']\n        except KeyError:\n            _, ex, trace = sys.exc_info()\n            log.warn('{n}: Unable to determine Image description for AMI ID {a}\\n{e}'.format(\n                n=ex.__class__.__name__, a=ami_id, e=str(ex)))\n            image_description = 'CONS3RT OS Template'\n        log.info('Using description of the current image: {d}'.format(d=image_description))\n\n        # Deregister the image\n        log.debug('De-registering image ID: {a}...'.format(a=ami_id))\n        try:\n            self.ec2.deregister_image(DryRun=False, ImageId=ami_id)\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: Unable to de-register AMI ID: {a}\\n{e}'.format(n=ex.__class__.__name__, a=ami_id, e=str(ex))\n            raise ImageUtilError, msg, trace\n        log.info('De-registered image ID: {a}'.format(a=ami_id))\n\n        # Wait 20 seconds\n        log.info('Waiting 20 seconds for the image to de-register...')\n        time.sleep(20)\n\n        # Create the new image\n        log.info('Creating new image from instance ID: {i}'.format(i=instance_id))\n        try:\n            create_res = self.ec2.create_image(\n                DryRun=False,\n                InstanceId=instance_id,\n                Name=image_name,\n                Description=image_description,\n                NoReboot=False\n            )\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a problem creating an image named [{m}] for image ID: {i}\\n{e}'.format(\n                n=ex.__class__.__name__, m=image_name, i=instance_id, e=str(ex))\n            raise ImageUtilError, msg, trace\n\n        # Get the new Image ID\n        try:\n            new_ami_id = create_res['ImageId']\n        except KeyError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: Image ID not found in the image creation response for instance ID: {i}\\n{e}'.format(\n                n=ex.__class__.__name__, i=instance_id, e=str(ex))\n            raise ImageUtilError, msg, trace\n        log.info('Created new image ID: {w}'.format(w=new_ami_id))\n\n        # Wait 20 seconds\n        log.info('Waiting 20 seconds for the image ID {w} to become available...'.format(w=new_ami_id))\n        time.sleep(20)\n\n        # Add tags to the new AMI\n        try:\n            self.ec2.create_tags(DryRun=False, Resources=[new_ami_id], Tags=image_tags)\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a problem adding tags to the new image ID: {i}\\n\\nTags: {t}\\n{e}'.format(\n                n=ex.__class__.__name__, i=new_ami_id, t=image_tags, e=str(ex))\n            raise ImageUtilError, msg, trace\n        log.info('Successfully added tags to the new image ID: {w}\\nTags: {t}'.format(w=new_ami_id, t=image_tags))\n\n        # Delete the Snapshot ID\n        log.debug('Deleting snapshot for the old image with ID: {s}'.format(s=snapshot_id))\n        try:\n            self.ec2.delete_snapshot(DryRun=False, SnapshotId=snapshot_id)\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: Unable to delete snapshot ID: {s}\\n{e}'.format(\n                n=ex.__class__.__name__, s=snapshot_id, e=str(ex))\n            raise ImageUtilError, msg, trace", "response": "This method deletes an existing AMI ID and replaces an existing AMI with an image created from the provided instance ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_cons3rt_template(self, instance_id, name, description='CONS3RT OS template'):\n        log = logging.getLogger(self.cls_logger + '.create_cons3rt_template')\n        if not isinstance(instance_id, basestring):\n            msg = 'Arg instance_id must be of type basestring, found: {t}'.format(t=instance_id.__class__.__name__)\n            raise ImageUtilError(msg)\n        if not isinstance(name, basestring):\n            msg = 'Arg name must be of type basestring, found: {t}'.format(t=instance_id.__class__.__name__)\n            raise ImageUtilError(msg)\n        if instance_id is None or name is None:\n            raise ImageUtilError('The provided args instance_id or name must not be None')\n\n        # Create the new image\n        log.info('Creating new image from instance ID: {i}'.format(i=instance_id))\n        try:\n            create_res = self.ec2.create_image(\n                DryRun=False,\n                InstanceId=instance_id,\n                Name=name,\n                Description=description,\n                NoReboot=False\n            )\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a problem creating an image named [{m}] for image ID: {i}\\n{e}'.format(\n                n=ex.__class__.__name__, m=name, i=instance_id, e=str(ex))\n            raise ImageUtilError, msg, trace\n\n        # Get the new Image ID\n        try:\n            new_ami_id = create_res['ImageId']\n        except KeyError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: Image ID not found in the image creation response for instance ID: {i}\\n{e}'.format(\n                n=ex.__class__.__name__, i=instance_id, e=str(ex))\n            raise ImageUtilError, msg, trace\n        log.info('Created new image ID: {w}'.format(w=new_ami_id))\n\n        # Wait 20 seconds\n        log.info('Waiting 20 seconds for the image ID {w} to become available...'.format(w=new_ami_id))\n        time.sleep(20)\n\n        # Add tags to the new AMI\n        try:\n            self.ec2.create_tags(DryRun=False, Resources=[new_ami_id], Tags=default_image_tags)\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: There was a problem adding tags to the new image ID: {i}\\n\\nTags: {t}\\n{e}'.format(\n                n=ex.__class__.__name__, i=new_ami_id, t=default_image_tags, e=str(ex))\n            raise ImageUtilError, msg, trace\n        log.info('Successfully added tags to the new image ID: {w}\\nTags: {t}'.format(\n            w=new_ami_id, t=default_image_tags))", "response": "Create a CONS3RT - ready template from an instance ID"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef copy_cons3rt_template(self, ami_id):\n        log = logging.getLogger(self.cls_logger + '.copy_cons3rt_template')\n\n        # Get the current AMI info\n        try:\n            ami_info = self.ec2.describe_images(DryRun=False, ImageIds=[ami_id], Owners=[self.owner_id])\n        except ClientError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: Unable to describe image ID: {a}.\\n{e}'.format(n=ex.__class__.__name__, a=ami_id, e=str(ex))\n            raise AWSAPIError, msg, trace\n        log.debug('Found AMI info: {a}'.format(a=ami_info))\n\n        # Grab the current cons3rtuuid tag data\n        cons3rt_uuid = None\n        try:\n            image_tags = ami_info['Images'][0]['Tags']\n            for image_tag in image_tags:\n                if image_tag['Key'] == 'cons3rtuuid':\n                    cons3rt_uuid = image_tag['Value']\n        except KeyError:\n            _, ex, trace = sys.exc_info()\n            msg = '{n}: Unable to find image tags for AMI ID: {a}\\n{e}'.format(\n                a=ami_id, n=ex.__class__.__name__, e=str(ex))\n            raise ImageUtilError, msg, trace\n        if cons3rt_uuid is None:\n            raise ImageUtilError('AMI tag cons3rtuuid not found on image ID: {a}'.format(a=ami_id))\n        log.info('Found image tag for cons3rtuuid: {u}'.format(u=cons3rt_uuid))\n        log.debug('Found image tags: {t}'.format(t=image_tags))", "response": "Copy the cons3rt template from the AMI to the new AMI."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef uniorbytes(s, result=str, enc=\"utf-8\", err=\"strict\"):\n    if isinstance(s, result):\n        # the input is the desired one, return as is\n        return s\n\n    if isinstance(s, (bytes, str)):\n        # the input is either a byte or a string, convert to desired\n        # result (result=bytes or str)\n        if isinstance(s, bytes) and result == str:\n            return s.decode(enc, err)\n        elif isinstance(s, str) and result == bytes:\n            return s.encode(enc)\n        else:\n            return str(s or (\"\" if s is None else s), enc)\n    elif isinstance(s, (float, int, decimal.Decimal)):\n        return uniorbytes(str(s), result, enc, err)\n    elif isinstance(s, dict):\n        # the input is a dict {}\n        for k, item in list(s.items()):\n            s[k] = uniorbytes(item, result=result, enc=enc, err=err)\n        return s\n    elif hasattr(s, '__iter__'):\n        # the input is iterable\n        for i, item in enumerate(s):\n            s[i] = uniorbytes(item, result=result, enc=enc, err=err)\n        return s\n    return s", "response": "This function will convert a string or bytes object into a base64 - encoded version of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef recode_unicode(s, encoding='utf-8'):\n    if isinstance(s, str):\n        return s.encode().decode(encoding)\n    return s", "response": "Recode unicode strings to unicode"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fix_bad_unicode(text):\n    if not isinstance(text, str):\n        return text\n\n    if len(text) == 0:\n        return text\n\n    maxord = max(ord(char) for char in text)\n    tried_fixing = []\n    if maxord < 128:\n        # Hooray! It's ASCII!\n        return text\n    else:\n        attempts = [(text, text_badness(text) + len(text))]\n        if maxord < 256:\n            tried_fixing = reinterpret_latin1_as_utf8(text)\n            tried_fixing2 = reinterpret_latin1_as_windows1252(text)\n            attempts.append((tried_fixing, text_cost(tried_fixing)))\n            attempts.append((tried_fixing2, text_cost(tried_fixing2)))\n        elif all(ord(char) in WINDOWS_1252_CODEPOINTS for char in text):\n            tried_fixing = reinterpret_windows1252_as_utf8(text)\n            attempts.append((tried_fixing, text_cost(tried_fixing)))\n        else:\n            # We can't imagine how this would be anything but valid text.\n            return text\n\n        # Sort the results by badness\n        attempts.sort(key=lambda x: x[1])\n        goodtext = attempts[0][0]\n        if goodtext == text:\n            return goodtext\n        else:\n            return fix_bad_unicode(goodtext)", "response": "This function fixes the Unicode character that is not in the correct Unicode format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef text_badness(text):\n    u'''\n    Look for red flags that text is encoded incorrectly:\n\n    Obvious problems:\n    - The replacement character \\ufffd, indicating a decoding error\n    - Unassigned or private-use Unicode characters\n\n    Very weird things:\n    - Adjacent letters from two different scripts\n    - Letters in scripts that are very rarely used on computers (and\n      therefore, someone who is using them will probably get Unicode right)\n    - Improbable control characters, such as 0x81\n\n    Moderately weird things:\n    - Improbable single-byte characters, such as \u0192 or \u00ac\n    - Letters in somewhat rare scripts\n    '''\n    assert isinstance(text, str)\n    errors = 0\n    very_weird_things = 0\n    weird_things = 0\n    prev_letter_script = None\n    unicodedata_name = unicodedata.name\n    unicodedata_category = unicodedata.category\n    for char in text:\n        index = ord(char)\n        if index < 256:\n            # Deal quickly with the first 256 characters.\n            weird_things += SINGLE_BYTE_WEIRDNESS[index]\n            if SINGLE_BYTE_LETTERS[index]:\n                prev_letter_script = 'latin'\n            else:\n                prev_letter_script = None\n        else:\n            category = unicodedata_category(char)\n            if category == 'Co':\n                # Unassigned or private use\n                errors += 1\n            elif index == 0xfffd:\n                # Replacement character\n                errors += 1\n            elif index in WINDOWS_1252_GREMLINS:\n                lowchar = char.encode('WINDOWS_1252').decode('latin-1')\n                weird_things += SINGLE_BYTE_WEIRDNESS[ord(lowchar)] - 0.5\n\n            if category[0] == 'L':\n                # It's a letter. What kind of letter? This is typically found\n                # in the first word of the letter's Unicode name.\n                name = unicodedata_name(char)\n                scriptname = name.split()[0]\n                freq, script = SCRIPT_TABLE.get(scriptname, (0, 'other'))\n                if prev_letter_script:\n                    if script != prev_letter_script:\n                        very_weird_things += 1\n                    if freq == 1:\n                        weird_things += 2\n                    elif freq == 0:\n                        very_weird_things += 1\n                prev_letter_script = script\n            else:\n                prev_letter_script = None\n\n    return 100 * errors + 10 * very_weird_things + weird_things", "response": "u Given a string text returns a list of badness values."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the full path to the pycons3rt home directory based on OS", "response": "def get_pycons3rt_home_dir():\n    \"\"\"Returns the pycons3rt home directory based on OS\n\n    :return: (str) Full path to pycons3rt home\n    :raises: OSError\n    \"\"\"\n    if platform.system() == 'Linux':\n        return os.path.join(os.path.sep, 'etc', 'pycons3rt')\n    elif platform.system() == 'Windows':\n        return os.path.join('C:', os.path.sep, 'pycons3rt')\n    elif platform.system() == 'Darwin':\n        return os.path.join(os.path.expanduser('~'), '.pycons3rt')\n    else:\n        raise OSError('Unsupported Operating System')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the pycons3rt directories", "response": "def initialize_pycons3rt_dirs():\n    \"\"\"Initializes the pycons3rt directories\n\n    :return: None\n    :raises: OSError\n    \"\"\"\n    for pycons3rt_dir in [get_pycons3rt_home_dir(),\n                          get_pycons3rt_user_dir(),\n                          get_pycons3rt_conf_dir(),\n                          get_pycons3rt_log_dir(),\n                          get_pycons3rt_src_dir()]:\n        if os.path.isdir(pycons3rt_dir):\n            continue\n        try:\n            os.makedirs(pycons3rt_dir)\n        except OSError as e:\n            if e.errno == errno.EEXIST and os.path.isdir(pycons3rt_dir):\n                pass\n            else:\n                msg = 'Unable to create directory: {d}'.format(d=pycons3rt_dir)\n                raise OSError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main():\n    # Create the pycons3rt directories\n    try:\n        initialize_pycons3rt_dirs()\n    except OSError as ex:\n        traceback.print_exc()\n        return 1\n\n\n\n    # Replace log directory paths\n    log_dir_path = get_pycons3rt_log_dir() + os.path.sep\n    conf_contents = default_logging_conf_file_contents.replace(replace_str, log_dir_path)\n\n    # Create the logging config file\n    logging_config_file_dest = os.path.join(get_pycons3rt_conf_dir(), 'pycons3rt-logging.conf')\n    with open(logging_config_file_dest, 'w') as f:\n        f.write(conf_contents)\n    \"\"\"\n    \n    for line in fileinput.input(logging_config_file_dest, inplace=True):\n        if re.search(replace_str, line):\n            new_line = re.sub(replace_str, log_dir_path, line, count=0)\n            sys.stdout.write(new_line)\n        else:\n            sys.stdout.write(line)\n    \"\"\"\n    return 0", "response": "Main function for the pycons3rt - logging."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_hooks():\n    # type: () -> None\n    \"\"\" Add git hooks for commit and push to run linting and tests. \"\"\"\n\n    # Detect virtualenv the hooks should use\n\n    # Detect virtualenv\n    virtual_env = conf.getenv('VIRTUAL_ENV')\n    if virtual_env is None:\n        log.err(\"You are not inside a virtualenv\")\n        confirm_msg = (\n            \"Are you sure you want to use global python installation \"\n            \"to run your git hooks? [y/N] \"\n        )\n        click.prompt(confirm_msg, default=False)\n        if not click.confirm(confirm_msg):\n            log.info(\"Cancelling\")\n            return\n\n        load_venv = ''\n    else:\n        load_venv = 'source \"{}/bin/activate\"'.format(virtual_env)\n\n    commit_hook = conf.proj_path('.git/hooks/pre-commit')\n    push_hook = conf.proj_path('.git/hooks/pre-push')\n\n    # Write pre-commit hook\n    log.info(\"Adding pre-commit hook <33>{}\", commit_hook)\n    fs.write_file(commit_hook, util.remove_indent('''\n        #!/bin/bash\n        PATH=\"/opt/local/libexec/gnubin:$PATH\"\n        \n        {load_venv}\n        \n        peltak lint --commit\n        \n    '''.format(load_venv=load_venv)))\n\n    # Write pre-push hook\n    log.info(\"Adding pre-push hook: <33>{}\", push_hook)\n    fs.write_file(push_hook, util.remove_indent('''\n        #!/bin/bash\n        PATH=\"/opt/local/libexec/gnubin:$PATH\"\n        \n        {load_venv}\n        \n        peltak test --allow-empty\n        \n    '''.format(load_venv=load_venv)))\n\n    log.info(\"Making hooks executable\")\n    if not context.get('pretend', False):\n        os.chmod(conf.proj_path('.git/hooks/pre-commit'), 0o755)\n        os.chmod(conf.proj_path('.git/hooks/pre-push'), 0o755)", "response": "Add git hooks for commit and push to run linting and tests."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start(name):\n    # type: (str) -> None\n    \"\"\" Start working on a new feature by branching off develop.\n\n    This will create a new branch off develop called feature/<name>.\n\n    Args:\n        name (str):\n            The name of the new feature.\n    \"\"\"\n    feature_name = 'feature/' + common.to_branch_name(name)\n    develop = conf.get('git.devel_branch', 'develop')\n\n    common.assert_on_branch(develop)\n    common.git_checkout(feature_name, create=True)", "response": "Starts working on a new feature by branching off develop."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update():\n    # type: () -> None\n    \"\"\" Update the feature with updates committed to develop.\n\n    This will merge current develop into the current branch.\n    \"\"\"\n    branch = git.current_branch(refresh=True)\n    develop = conf.get('git.devel_branch', 'develop')\n\n    common.assert_branch_type('feature')\n    common.git_checkout(develop)\n    common.git_pull(develop)\n    common.git_checkout(branch.name)\n    common.git_merge(branch.name, develop)", "response": "Update the feature with updates committed to develop."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove all unnecessary files in the current project.", "response": "def clean(exclude):\n    # type: (bool, List[str]) -> None\n    \"\"\" Remove all unnecessary files.\n\n    Args:\n        pretend (bool):\n            If set to **True**, do not delete any files, just show what would be\n            deleted.\n        exclude (list[str]):\n            A list of path patterns to exclude from deletion.\n    \"\"\"\n    pretend = context.get('pretend', False)\n    exclude = list(exclude) + conf.get('clean.exclude', [])\n    clean_patterns = conf.get('clean.patterns', [\n        '*__pycache__*',\n        '*.py[cod]',\n        '*.swp',\n    ])\n\n    num_files = 0\n    with util.timed_block() as t:\n        files = fs.filtered_walk(conf.proj_path(), clean_patterns, exclude)\n        for path in files:\n            try:\n                num_files += 1\n\n                if not isdir(path):\n                    log.info('  <91>[file] <90>{}', path)\n                    not pretend and os.remove(path)\n                else:\n                    log.info('  <91>[dir]  <90>{}', path)\n                    not pretend and rmtree(path)\n\n            except OSError:\n                log.info(\"<33>Failed to remove <90>{}\", path)\n\n    if pretend:\n        msg = \"Would delete <33>{}<32> files. Took <33>{}<32>s\"\n    else:\n        msg = \"Deleted <33>{}<32> files in <33>{}<32>s\"\n\n    log.info(msg.format(num_files, t.elapsed_s))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an empty pelconf. yaml from template", "response": "def init(quick):\n    # type: () -> None\n    \"\"\" Create an empty pelconf.yaml from template \"\"\"\n    config_file = 'pelconf.yaml'\n    prompt = \"-- <35>{} <32>already exists. Wipe it?<0>\".format(config_file)\n\n    if exists(config_file) and not click.confirm(shell.fmt(prompt)):\n        log.info(\"Canceled\")\n        return\n\n    form = InitForm().run(quick=quick)\n\n    log.info('Writing <35>{}'.format(config_file))\n    pelconf_template = conf.load_template('pelconf.yaml')\n    fs.write_file(config_file, pelconf_template.format(**form.values))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tracebacks_from_file(fileobj, reverse=False):\n\n    if reverse:\n        lines = deque()\n\n        for line in BackwardsReader(fileobj):\n            lines.appendleft(line)\n            if tb_head in line:\n                yield next(tracebacks_from_lines(lines))\n                lines.clear()\n    else:\n        for traceback in tracebacks_from_lines(fileobj):\n            yield traceback", "response": "Generator that yields tracebacks found in a file object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef BackwardsReader(file, BLKSIZE = 4096):\n\n    buf = \"\"\n\n    file.seek(0, 2)\n    lastchar = file.read(1)\n    trailing_newline = (lastchar == \"\\n\")\n\n    while 1:\n        newline_pos = buf.rfind(\"\\n\")\n        pos = file.tell()\n        if newline_pos != -1:\n            # Found a newline\n            line = buf[newline_pos+1:]\n            buf = buf[:newline_pos]\n            if pos or newline_pos or trailing_newline:\n                line += \"\\n\"\n            yield line\n        elif pos:\n            # Need to fill buffer\n            toread = min(BLKSIZE, pos)\n            file.seek(pos-toread, 0)\n            buf = file.read(toread) + buf\n            file.seek(pos-toread, 0)\n            if pos == toread:\n                buf = \"\\n\" + buf\n        else:\n            # Start-of-file\n            return", "response": "Read a file line by line backwards."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef inversefunc(func,\n                y_values=None,\n                domain=None,\n                image=None,\n                open_domain=None,\n                args=(),\n                accuracy=2):\n    r\"\"\"Obtain the inverse of a function.\n\n    Returns the numerical inverse of the function `f`. It may return a callable\n    that can be used to calculate the inverse, or the inverse of certain points\n    depending on the `y_values` argument.\n    In order for the numerical inverse to exist in its domain, the\n    input function must have, continuous, strictly monotonic behavior i.e. be\n    purely decreasing or purely increasing in that domain. By default the\n    domain interval spans all the real numbers, however it can be restricted\n    with the `domain` and `open_domain` arguments. The image of the function\n    in the interval may be provided, for cases where the function is non\n    continuous right at the end of an open interval.\n\n    Parameters\n    ----------\n    func : callable\n        Callable representing the function to be inverted, able to take a\n        ndarray or an scalar and return an object of the same kind with the\n        evaluation of the function.  If `func` takes many arguments, it is\n        inverted along the axis corresponding to the first argument.\n        The function must not diverge and have a continuous strictly monotonic\n        behavior in the chosen interval.\n    y_values : float, ndarray, optional\n        Values for which calculate the inverse function. If set to None, then\n        a callable that can be used to calculate the inverse of values is\n        returned. Default None.\n    domain : float, ndarray, optional\n        Boundaries of the domain (`domain[0]`, `domain[1]`).\n        `domain[1]` must be larger than `domain[0]`.\n        None values are assumed to be no boundary in that direction.\n        A single scalar value will set it to [`domain`, None].\n        Default None (-Inf, Inf).\n    open_domain : bool, ndarray, optional\n        Whether the domain is an open interval at each of the ends.\n        A single scalar boolean will set it to [`open_domain`, `open_domain`].\n        Default None [False, False].\n    image : float, ndarray, optional\n        Image of the function in the domain (`image[0]`, `image[1]`).\n        `image[1]` must be larger than `image[0]`.\n        None values are assumed to be no boundary in that direction.\n        Default None, this is (-Inf, Inf) if domain is None, or the limits\n        set by func(domain[0]) and func(domain[1]).\n    args : tuple, optional\n        Extra arguments to pass to `func`. Default ().\n    accuracy : int, optional\n        Number of digits for the desired accuracy. It will give a warning\n        if the accuracy is worse than this.\n        Default 2.\n\n    Returns\n    -------\n    callable or ndarray\n        Inverse function of `func`. It can take scalars or ndarrays, and return\n        objects of the same kind with the calculated inverse values.\n\n    Notes\n    -----\n\n    .. versionadded:: 0.19.0\n\n    Examples\n    --------\n    >>> from pynverse import inversefunc\n    >>> import numpy as np\n    >>> cube = (lambda x: x**3)\n    >>> invcube = inversefunc(cube)\n    >>> invcube(27) # Should give 3\n    array(3.0000000063797567)\n    >>> invsquare = inversefunc(np.power, args=(2), domain=0)\n    >>> invsquare([4, 16, 64]) # Should give [2, 4, 8]\n    array([ 2.,  4.,  8.])\n    >>> inversefunc(np.log10, y_values=-2, # Should give 0.01\n    ...             domain=0, open_domain=True)\n    array(0.0099999999882423)\n    >>> inversefunc(np.cos, y_values=[1, 0, -1], # Should give [0, pi / 2, pi]\n    ...             domain=[0, np.pi])\n    array([ 0.        ,  1.57079632,  3.14159265])\n    >>> invtan = inversefunc(np.tan,\n    ...                      domain=[-np.pi / 2, np.pi / 2],\n    ...                      open_domain=True)\n    >>> invtan([1, 0, -1]) # Should give [pi / 4, 0, -pi / 4]\n    array([  7.85398163e-01,   1.29246971e-26,  -7.85398163e-01])\n\n    \"\"\"\n\n    domain, image, open_domain, args = _normparams_inversefunc(domain,\n                                                               image,\n                                                               open_domain,\n                                                               args)\n\n    ymin, ymax = image\n    xmin, xmax = domain\n    xmin_open, xmax_open = open_domain\n\n    # Calculating if the function is increasing or decreasing, using ref points\n    # anywhere in the valid range (Function has to be strictly monotonic)\n    ref1, ref2 = _get_valid_refpoints(xmin, xmax)\n    trend = np.sign(func(ref2, *args) - func(ref1, *args))\n\n    if trend == 0:\n        raise ValueError(\"Function is not strictly monotonic\")\n\n    # Calculating the image by default\n    if ymin is None:\n        ymin = _auto_ymin(func, args, xmin, xmax, trend)\n    if ymax is None:\n        ymax = _auto_ymax(func, args, xmin, xmax, trend)\n\n    # Creating bounded function\n    def bounded_f(x):\n        if xmin is not None and (x < xmin or (x == xmin and xmin_open)):\n                val = -1 * np.inf * trend\n        elif xmax is not None and (x > xmax or (x == xmax and xmax_open)):\n                val = np.inf * trend\n        else:\n            val = func(x, *args)\n        return val\n\n    min_kwargs = {}\n    min_kwargs['bracket'] = (ref1, ref2)\n    min_kwargs['tol'] = 1.48e-08\n    min_kwargs['method'] = 'Brent'\n\n    def inv(yin):\n        yin = np.asarray(yin, dtype=np.float64)\n        shapein = yin.shape\n        yin = yin.flatten()\n        if ymin is not None:\n            if (xmin_open and trend == 1) or (xmax_open and trend == -1):\n                mask = yin <= ymin\n            else:\n                mask = yin < ymin\n            if yin[mask].size > 0:\n                raise ValueError(\"Requested values %s lower than the\"\n                                 \" lower limit %g of the image\" %\n                                 (yin[mask], ymin))\n        if ymax is not None:\n            if (xmax_open and trend == 1) or (xmin_open and trend == -1):\n                mask = yin >= ymax\n            else:\n                mask = yin > ymax\n            if yin[mask].size > 0:\n                raise ValueError(\"Requested values %s higher than the\"\n                                 \" higher limit %g of the image\" %\n                                 (yin[mask], ymax))\n\n        results = yin.copy() * np.nan\n        resultsmask = np.zeros(yin.shape, dtype=np.bool)\n\n        for j in range(yin.size):\n            if xmax is not None:\n                if bounded_f(xmax) == yin[j]:\n                    results[j] = xmax\n                    resultsmask[j] = True\n                    continue\n            if xmin is not None:\n                if bounded_f(xmin) == yin[j]:\n                    results[j] = xmin\n                    resultsmask[j] = True\n                    continue\n\n            optimizer = (lambda x, j=j,\n                         bounded_f=bounded_f: (((bounded_f(x) - yin[j]))**2))\n            try:\n                with warnings.catch_warnings(record=True):\n                    result = minimize_scalar(optimizer, **min_kwargs)\n                results[j] = result.x\n                resultsmask[j] = result.success\n            except:\n                resultsmask[j] = False\n        if any(~resultsmask):\n            warnings.warn(\"Trouble calculating inverse for values: \"\n                          \"%s\" % str(yin[~resultsmask]), RuntimeWarning)\n\n        try:\n            np.testing.assert_array_almost_equal(yin, func(results, *args),\n                                                 decimal=accuracy)\n        except AssertionError:\n            warnings.warn(\"Results obtained with less than %g \"\n                          \"decimal digits of accuracy\"\n                          % accuracy, RuntimeWarning)\n\n        return results.reshape(shapein)\n\n    if y_values is None:\n        return inv\n    else:\n        return inv(y_values)", "response": "r Returns the numerical inverse of a function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrendering a progressed. io like progress bar", "response": "def progressed_bar(count, total=100, status=None, suffix=None, bar_len=10):\n    \"\"\"render a progressed.io like progress bar\"\"\"\n    status = status or ''\n    suffix = suffix or '%'\n    assert isinstance(count, int)\n    count_normalized = count if count <= total else total\n    filled_len = int(round(bar_len * count_normalized / float(total)))\n    percents = 100.0 * count / float(total)\n    color = '#5cb85c'\n    if percents < 30.0:\n        color = '#d9534f'\n    if percents < 70.0:\n        color = '#f0ad4e'\n    text_color = colors.fg(color)\n    bar_color = text_color + colors.bg(color)\n    nc_color = colors.dark_gray\n    progressbar = (colors.bg('#428bca') | status) if status else ''\n    progressbar += (bar_color | ('\u2588' * filled_len))\n    progressbar += (nc_color | ('\u2588' * (bar_len - filled_len)))\n    progressbar += (text_color | (str(count) + suffix))\n    return progressbar"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprettifies a string with markup emoji and progressbars.", "response": "def prettify(string):\n    \"\"\"\n    replace markup emoji and progressbars with actual things\n\n    # Example\n    ```python\n    from habitipy.util import prettify\n    print(prettify('Write thesis :book: ![progress](http://progressed.io/bar/0 \"progress\")'))\n    ```\n    ```\n    Write thesis \ud83d\udcd6 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u25880%\n    ```\n    \"\"\"\n    string = emojize(string, use_aliases=True) if emojize else string\n    string = progressed(string)\n    return string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if a file is stored securely", "response": "def assert_secure_file(file):\n    \"\"\"checks if a file is stored securely\"\"\"\n    if not is_secure_file(file):\n        msg = \"\"\"\n        File {0} can be read by other users.\n        This is not secure. Please run 'chmod 600 \"{0}\"'\"\"\"\n        raise SecurityError(dedent(msg).replace('\\n', ' ').format(file))\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_translation_for(package_name: str) -> gettext.NullTranslations:\n    localedir = None\n    for localedir in pkg_resources.resource_filename(package_name, 'i18n'), None:\n        localefile = gettext.find(package_name, localedir)  # type: ignore\n        if localefile:\n            break\n    else:\n        pass\n    return gettext.translation(package_name, localedir=localedir, fallback=True)", "response": "find and return gettext translation for package"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_translation_functions(package_name: str, names: Tuple[str, ...] = ('gettext',)):\n    translation = get_translation_for(package_name)\n    return [getattr(translation, x) for x in names]", "response": "finds and installs translation functions for package"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef escape_keywords(arr):\n    for i in arr:\n        i = i if i not in kwlist else i + '_'\n        i = i if '-' not in i else i.replace('-', '_')\n        yield i", "response": "append _ to all python keywords"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndownloading API documentation from Habitica s repo on Github", "response": "def download_api(branch=None) -> str:\n    \"\"\"download API documentation from _branch_ of Habitica\\'s repo on Github\"\"\"\n    habitica_github_api = 'https://api.github.com/repos/HabitRPG/habitica'\n    if not branch:\n        branch = requests.get(habitica_github_api + '/releases/latest').json()['tag_name']\n    curl = local['curl']['-sL', habitica_github_api + '/tarball/{}'.format(branch)]\n    tar = local['tar'][\n        'axzf', '-', '--wildcards', '*/website/server/controllers/api-v3/*', '--to-stdout']\n    grep = local['grep']['@api']\n    sed = local['sed']['-e', 's/^[ */]*//g', '-e', 's/  / /g', '-']\n    return (curl | tar | grep | sed)()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save_apidoc(text: str) -> None:\n    apidoc_local = local.path(APIDOC_LOCAL_FILE)\n    if not apidoc_local.dirname.exists():\n        apidoc_local.dirname.mkdir()\n    with open(apidoc_local, 'w') as f:\n        f.write(text)", "response": "save text to apidoc cache"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread file and parse apiDoc lines", "response": "def parse_apidoc(\n    file_or_branch,\n    from_github=False,\n    save_github_version=True\n) -> List['ApiEndpoint']:\n    \"\"\"read file and parse apiDoc lines\"\"\"\n    apis = []  # type: List[ApiEndpoint]\n    regex = r'(?P<group>\\([^)]*\\)){0,1} *(?P<type_>{[^}]*}){0,1} *'\n    regex += r'(?P<field>[^ ]*) *(?P<description>.*)$'\n    param_regex = re.compile(r'^@apiParam {1,}' + regex)\n    success_regex = re.compile(r'^@apiSuccess {1,}' + regex)\n    if from_github:\n        text = download_api(file_or_branch)\n        if save_github_version:\n            save_apidoc(text)\n    else:\n        with open(file_or_branch) as f:\n            text = f.read()\n    for line in text.split('\\n'):\n        line = line.replace('\\n', '')\n        if line.startswith('@api '):\n            if apis:\n                if not apis[-1].retcode:\n                    apis[-1].retcode = 200\n            split_line = line.split(' ')\n            assert len(split_line) >= 3\n            method = split_line[1]\n            uri = split_line[2]\n            assert method[0] == '{'\n            assert method[-1] == '}'\n            method = method[1:-1]\n            if not uri.startswith(API_URI_BASE):\n                warnings.warn(_(\"Wrong api url: {}\").format(uri))  # noqa: Q000\n            title = ' '.join(split_line[3:])\n            apis.append(ApiEndpoint(method, uri, title))\n        elif line.startswith('@apiParam '):\n            res = next(param_regex.finditer(line)).groupdict()\n            apis[-1].add_param(**res)\n        elif line.startswith('@apiSuccess '):\n            res = next(success_regex.finditer(line)).groupdict()\n            apis[-1].add_success(**res)\n    if apis:\n        if not apis[-1].retcode:\n            apis[-1].retcode = 200\n    return apis"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting another leaf node with name val if possible", "response": "def into(self, val: str) -> Union['ApiNode', 'ApiEndpoint']:\n        \"\"\"Get another leaf node with name `val` if possible\"\"\"\n        if val in self.paths:\n            return self.paths[val]\n        if self.param:\n            return self.param\n        raise IndexError(_(\"Value {} is missing from api\").format(val))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetermining if the node with name val can be inserted into this node.", "response": "def can_into(self, val: str) -> bool:\n        \"\"\"Determine if there is a leaf node with name `val`\"\"\"\n        return val in self.paths or (self.param and self.param_name == val)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nplace a leaf node", "response": "def place(self, part: str, val: Union['ApiNode', 'ApiEndpoint']):\n        \"\"\"place a leaf node\"\"\"\n        if part.startswith(':'):\n            if self.param and self.param != part:\n                err = \"\"\"Cannot place param '{}' as '{self.param_name}' exist on node already!\"\"\"\n                raise ParamAlreadyExist(err.format(part, self=self))\n            self.param = val\n            self.param_name = part\n            return val\n        self.paths[part] = val\n        return val"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning all possible paths one can take from this ApiNode", "response": "def keys(self) -> Iterator[str]:\n        \"\"\"return all possible paths one can take from this ApiNode\"\"\"\n        if self.param:\n            yield self.param_name\n        yield from self.paths.keys()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses and append a param", "response": "def add_param(self, group=None, type_='', field='', description=''):\n        \"\"\"parse and append a param\"\"\"\n        group = group or '(Parameter)'\n        group = group.lower()[1:-1]\n        p = Param(type_, field, description)\n        self.params[group][p.field] = p"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing and append a success data param", "response": "def add_success(self, group=None, type_='', field='', description=''):\n        \"\"\"parse and append a success data param\"\"\"\n        group = group or '(200)'\n        group = int(group.lower()[1:-1])\n        self.retcode = self.retcode or group\n        if group != self.retcode:\n            raise ValueError('Two or more retcodes!')\n        type_ = type_ or '{String}'\n        p = Param(type_, field, description)\n        self.params['responce'][p.field] = p"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render_docstring(self):\n        res = '{{{self.method}}} {self.uri} {self.title}\\n'.format(self=self)\n        if self.params:\n            for group, params in self.params.items():\n                res += '\\n' + group + ' params:\\n'\n                for param in params.values():\n                    res += param.render_docstring()\n        return res", "response": "make a nice docstring for ipython"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if obj has this api param", "response": "def validate(self, obj):\n        \"\"\"check if obj has this api param\"\"\"\n        if self.path:\n            for i in self.path:\n                obj = obj[i]\n        obj = obj[self.field]\n\n        raise NotImplementedError('Validation is not implemented yet')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_docstring(self):\n        default = (' = ' + str(self.default)) if self.default else ''\n        opt = 'optional' if self.is_optional else ''\n        can_be = ' '.join(self.possible_values) if self.possible_values else ''\n        can_be = 'one of [{}]'.format(can_be) if can_be else ''\n        type_ = 'of type \"' + str(self.type) + '\"'\n        res = ' '.join([opt, '\"' + self.field + '\"', default, type_, can_be, '\\n'])\n        return res.replace('  ', ' ').lstrip()", "response": "make a nice docstring for ipython"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_uuid(u):\n    if isinstance(u, str) and u.replace('-', '') == uuid.UUID(u).hex:\n        return u\n    return False", "response": "validator for plumbum prompt"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_conf(configfile, config=None):\n    default_login = 'your-login-for-api-here'\n    default_password = 'your-password-for-api-here'\n    config = config or {}\n    configfile = local.path(configfile)\n    if not configfile.exists():\n        configfile.dirname.mkdir()\n    else:\n        assert_secure_file(configfile)\n    with secure_filestore(), cli.Config(configfile) as conf:\n        config['url'] = conf.get('habitipy.url', 'https://habitica.com')\n        config['login'] = conf.get('habitipy.login', default_login)\n        config['password'] = conf.get('habitipy.password', default_password)\n        if config['login'] == default_login or config['password'] == default_password:\n            if cli.terminal.ask(\n                    _(\"\"\"Your creditentials are invalid. Do you want to enter them now?\"\"\"),\n                    default=True):\n                msg = _(\"\"\"\n                You can get your login information at\n                https://habitica.com/#/options/settings/api\n                Both your user id and API token should look like this:\n                xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n                where 'x' is a number between 0-9 or a character a-f.\n                \"\"\")\n                print(dedent(msg))\n                msg = _(\"\"\"Please enter your login (user ID)\"\"\")\n                config['login'] = cli.terminal.prompt(msg, validator=is_uuid)\n                msg = _(\"\"\"Please enter your password (API token)\"\"\")\n                config['password'] = cli.terminal.prompt(msg, validator=is_uuid)\n                conf.set('habitipy.login', config['login'])\n                conf.set('habitipy.password', config['password'])\n                print(dedent(_(\"\"\"\n                Your creditentials are securely stored in\n                {configfile}\n                You can edit that file later if you need.\n                \"\"\")).format(configfile=configfile))\n        config['show_numbers'] = conf.get('habitipy.show_numbers', 'y')\n        config['show_numbers'] = config['show_numbers'] in YES_ANSWERS\n        config['show_style'] = conf.get('habitipy.show_style', 'wide')\n        if config['show_style'] not in CHECK_MARK_STYLES:\n            config['show_style'] = 'wide'\n    return config", "response": "Load the AUTH_CONF file and return the config dict."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_content(api, rebuild_cache=False):\n    if hasattr(get_content, 'cache') and not rebuild_cache:\n        return get_content.cache\n    if not os.path.exists(CONTENT_JSON) or rebuild_cache:\n        import locale\n        content_endpoint = api.content.get\n        # pylint: disable=protected-access\n        try_langs = []\n        try:\n            lang = get_translation_for('habitipy').info()['language']\n            try_langs.append(lang)\n        except KeyError:\n            pass\n        try:\n            loc = locale.getdefaultlocale()[0]\n            if loc:\n                try_langs.append(loc)\n                try_langs.append(loc[:2])\n        except IndexError:\n            pass\n        server_lang = content_endpoint._node.params['query']['language']\n        # handle something like 'ru_RU' not available - only 'ru'\n        for lang in try_langs:\n            if lang in server_lang.possible_values:\n                loc = {'language': lang}\n                break\n        else:\n            loc = {}\n        get_content.cache = content = content_endpoint(**loc)\n        with open(CONTENT_JSON, 'w') as f:\n            json.dump(content, f)\n        return content\n    try:\n        with open(CONTENT_JSON) as f:\n            get_content.cache = content = json.load(f)\n        return content\n    except JSONDecodeError:\n        return get_content(api, rebuild_cache=True)", "response": "get content from server or cache"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_additional_rewards(api):\n    c = get_content(api)\n    tasks = [c[i] for i in ['potion', 'armoire']]\n    tasks.extend(api.user.inventory.buy.get())\n    for task in tasks:\n        task['id'] = task['alias'] = task['key']\n    return tasks", "response": "returns list of non - user rewards"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef augment_init_method(cls):\n\n    orig_init = cls.__init__\n\n    def new_init(self, *args, **kwargs):\n        super(CustomGenerator, self).__init__()  # TODO: does this behave correctly with longer inheritance chains?\n\n        orig_init(self, *args, **kwargs)\n\n        self.orig_args = args\n        self.orig_kwargs = kwargs\n\n        self.ns_gen_templates = TohuNamespace()\n        self.ns_gen_templates.update_from_dict(self.__class__.__dict__)\n        self.ns_gen_templates.update_from_dict(self.__dict__)\n        self.ns_gen_templates.set_owner(self.__class__)\n        self._mark_field_generator_templates()\n\n        self.ns_gens = self.ns_gen_templates.spawn()\n        self.ns_gens.set_owner(self)\n\n        self._update_namespace_with_field_generators()\n        self._set_field_names()\n        self._set_tohu_items_name()\n        self._set_tohu_items_cls()\n\n    cls.__init__ = new_init", "response": "Augment the existing cls. __init__ method with a new one which also initialises the field generators and similar bookkeeping."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding all tohu. BaseGenerator occurring in the given object s class & instance namespaces.", "response": "def find_field_generators(obj):\n    \"\"\"\n    Return dictionary with the names and instances of\n    all tohu.BaseGenerator occurring in the given\n    object's class & instance namespaces.\n    \"\"\"\n\n    cls_dict = obj.__class__.__dict__\n    obj_dict = obj.__dict__\n    #debug_print_dict(cls_dict, 'cls_dict')\n    #debug_print_dict(obj_dict, 'obj_dict')\n\n    field_gens = {}\n    add_field_generators(field_gens, cls_dict)\n    add_field_generators(field_gens, obj_dict)\n\n    return field_gens"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the class name of the items produced by this custom generator.", "response": "def set_item_class_name(cls_obj):\n    \"\"\"\n    Return the first part of the class name of this custom generator.\n    This will be used for the class name of the items produced by this\n    generator.\n\n    Examples:\n        FoobarGenerator -> Foobar\n        QuuxGenerator   -> Quux\n    \"\"\"\n    if '__tohu__items__name__' in cls_obj.__dict__:\n        logger.debug(f\"Using item class name '{cls_obj.__tohu_items_name__}' (derived from attribute '__tohu_items_name__')\")\n    else:\n        m = re.match('^(.*)Generator$', cls_obj.__name__)\n        if m is not None:\n            cls_obj.__tohu_items_name__ = m.group(1)\n            logger.debug(f\"Using item class name '{cls_obj.__tohu_items_name__}' (derived from custom generator name)\")\n        else:\n            raise ValueError(\"Cannot derive class name for items to be produced by custom generator. \"\n                             \"Please set '__tohu_items_name__' at the top of the custom generator's \"\n                             \"definition or change its name so that it ends in '...Generator'\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_item_class_for_custom_generator(obj):\n    clsname = obj.__tohu_items_name__\n    attr_names = obj.field_gens.keys()\n    return make_item_class(clsname, attr_names)", "response": "Returns the class name for the item class for the given custom generator instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_new_init_method(obj):\n\n    orig_init = obj.__init__\n\n    def new_init(self, *args, **kwargs):\n        logger.debug(f\"Initialising new {self}\")\n\n        # Call original __init__ function to ensure we pick up\n        # any tohu generators that are defined there.\n        orig_init(self, *args, **kwargs)\n\n        #\n        # Find field generator templates and attach spawned copies\n        #\n        field_gens_templates = find_field_generators(self)\n        logger.debug(f'Found {len(field_gens_templates)} field generator template(s):')\n        debug_print_dict(field_gens_templates)\n\n        def find_orig_parent(dep_gen, origs):\n            \"\"\"\n            Find name and instance of the parent of the dependent\n            generator `dep_gen` amongst the generators in `origs`.\n            \"\"\"\n            for parent_name, parent in origs.items():\n                if dep_gen.parent is parent:\n                    return parent_name, parent\n            raise RuntimeError(f\"Parent of dependent generator {dep_gen} not defined in the same custom generator\")\n\n\n        logger.debug('Spawning field generator templates...')\n        origs = {}\n        spawned = {}\n        for name, gen in field_gens_templates.items():\n            if isinstance(gen, IndependentGenerator) and gen in origs.values():\n                logger.debug(f'Cloning generator {name}={gen} because it is an alias for an existing generator')\n                gen = gen.clone()\n\n            if isinstance(gen, IndependentGenerator):\n                origs[name] = gen\n                spawned[name] = gen._spawn()\n                logger.debug(f'Spawning generator {gen}. New spawn: {spawned[name]}')\n            elif isinstance(gen, DependentGenerator):\n                orig_parent_name, orig_parent = find_orig_parent(gen, origs)\n                new_parent = spawned[orig_parent_name]\n                #spawned[name] = new_parent.clone()\n                spawned[name] = gen._spawn_and_reattach_parent(new_parent)\n            else:\n                pass\n\n        self.field_gens = spawned\n        self.__dict__.update(self.field_gens)\n\n        logger.debug(f'Field generators attached to custom generator instance:')\n        debug_print_dict(self.field_gens)\n\n        #\n        # Add seed generator\n        #\n        self.seed_generator = SeedGenerator()\n\n        #\n        # Create class for the items produced by this generator\n        #\n        self.__class__.item_cls = make_item_class_for_custom_generator(self)\n\n    obj.__init__ = new_init", "response": "Add a new init method to obj."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a new reset method to obj which resets the internal internal", "response": "def add_new_reset_method(obj):\n    \"\"\"\n    Attach a new `reset()` method to `obj` which resets the internal\n    seed generator of `obj` and then resets each of its constituent\n    field generators found in `obj.field_gens`.\n    \"\"\"\n\n    #\n    # Create and assign automatically generated reset() method\n    #\n\n\n    def new_reset(self, seed=None):\n        logger.debug(f'[EEE] Inside automatically generated reset() method for {self} (seed={seed})')\n\n        if seed is not None:\n            self.seed_generator.reset(seed)\n            for name, gen in self.field_gens.items():\n                next_seed = next(self.seed_generator)\n                gen.reset(next_seed)\n\n            # TODO: the following should be covered by the newly added\n            # reset() method in IndependentGeneratorMeta. However, for\n            # some reason we can't call this via the usual `orig_reset()`\n            # pattern, so we have to duplicate this here. Not ideal...\n            for c in self._dependent_generators:\n                c.reset_dependent_generator(seed)\n\n        return self\n\n    obj.reset = new_reset"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_new_next_method(obj):\n\n    def new_next(self):\n        field_values = [next(g) for g in self.field_gens.values()]\n        return self.item_cls(*field_values)\n\n    obj.__next__ = new_next", "response": "Add a method to obj that returns the next item in the hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_new_spawn_method(obj):\n\n    def new_spawn(self):\n        # TODO/FIXME: Check that this does the right thing:\n        # (i) the spawned generator is independent of the original one (i.e. they can be reset independently without altering the other's behaviour)\n        # (ii) ensure that it also works if this custom generator's __init__ requires additional arguments\n        new_instance = self.__class__()\n        return new_instance\n\n    obj._spawn = new_spawn", "response": "Add a new spawn method to the object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_that_operator_can_be_applied_to_produces_items(op, g1, g2):\n    g1_tmp_copy = g1.spawn()\n    g2_tmp_copy = g2.spawn()\n    sample_item_1 = next(g1_tmp_copy)\n    sample_item_2 = next(g2_tmp_copy)\n    try:\n        op(sample_item_1, sample_item_2)\n    except TypeError:\n        raise TypeError(f\"Operator '{op.__name__}' cannot be applied to items produced by {g1} and {g2} \"\n                        f\"(which have type {type(sample_item_1)} and {type(sample_item_2)}, respectively)\")", "response": "Helper function to check that the operator op can be applied to items produced by g1 and g2."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_new_init_method(cls):\n\n    orig_init = cls.__init__\n\n    def new_init(self, *args, **kwargs):\n        self._dependent_generators = []\n        orig_init(self, *args, **kwargs)\n\n    cls.__init__ = new_init", "response": "Add a new init method to the class."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds default __repr__ method in case no user - defined one is present.", "response": "def add_new_repr_method(cls):\n    \"\"\"\n    Add default __repr__ method in case no user-defined one is present.\n    \"\"\"\n\n    if isinstance(cls.__repr__, WrapperDescriptorType):\n        cls.__repr__ = lambda self: f\"<{self.__class__.__name__}, id={hex(id(self))}>\"\n    else:\n        # Keep the user-defined __repr__ method\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_new_reset_method(cls):\n    orig_reset = cls.reset\n\n    def new_reset(self, seed=None):\n        logger.debug(f\"Calling reset() on {self} (seed={seed})\")\n        orig_reset(self, seed)\n        for c in self._dependent_generators:\n            c.reset_dependent_generator(seed)\n        return self\n\n    cls.reset = new_reset", "response": "Add a new reset method to the class which also replaces existing cls. reset method with a new one which also adds a new reset method which also adds a new reset method to any clones."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate(self, N, *, seed=None, progressbar=False):\n        if seed is not None:\n            self.reset(seed)\n        items = islice(self, N)\n        if progressbar:\n            items = tqdm(items, total=N)\n\n        item_list = [x for x in items]\n\n        #logger.warning(\"TODO: initialise ItemList with random seed!\")\n        return ItemList(item_list, N)", "response": "Generate a sequence of N elements from the current generator."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tohu_id(self):\n        myhash = hashlib.md5(str(id(self)).encode()).hexdigest()\n        return myhash[:12]", "response": "Return the tohu id of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the item class for which to generate the item.", "response": "def _set_item_class(self):\n        \"\"\"\n        cls:\n            The custom generator class for which to create an item-class\n        \"\"\"\n        clsname = self.__tohu_items_name__\n        self.item_cls = make_item_class(clsname, self.field_names)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _find_field_generator_templates(self):\n        field_gen_templates = {}\n\n        # Extract field generators from class dict\n        for name, g in self.__class__.__dict__.items():\n            if isinstance(g, TohuBaseGenerator):\n                field_gen_templates[name] = g.set_tohu_name(f'{name} (TPL)')\n\n        # Extract field generators from instance dict\n        for name, g in self.__dict__.items():\n            if isinstance(g, TohuBaseGenerator):\n                field_gen_templates[name] = g.set_tohu_name(f'{name} (TPL)')\n\n        return field_gen_templates", "response": "Find all tohu generators defined in the class and instance namespace\n        and return a dictionary of the form {name : field_generator containing\n        all tohu generators defined in the class and instance namespace\n       ."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextract schema and table from a given table name.", "response": "def _extract_schema_if_given(table_name):\n    \"\"\"\n    Return a pair (schema, table) derived from the given `table_name`\n    (anything before the first '.' if the name contains one; otherwise\n    the return value of `schema` is None).\n\n    Examples:\n\n        >>> _extract_schema_if_given('some_schema.my_table')\n        ('some_schema', 'my_table')\n\n        >>> _extract_schema_if_given('my_awesome_table')\n        (None, 'my_awesome_table')\n    \"\"\"\n    pattern = '^(([^.]+)\\.)?(.+)$'\n    m = re.match(pattern, table_name)\n    schema, table_name = m.group(2), m.group(3)\n    return schema, table_name"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexport items as rows in a pandas dataframe table.", "response": "def to_df(self, fields=None):\n        \"\"\"\n        Export items as rows in a pandas dataframe table.\n\n        Parameters\n        ----------\n\n        fields: list or dict\n            List of field names to export, or dictionary mapping output column names\n            to attribute names of the generators.\n\n            Examples:\n               fields=['field_name_1', 'field_name_2']\n               fields={'COL1': 'field_name_1', 'COL2': 'field_name_2'}\n        \"\"\"\n        if isinstance(fields, (list, tuple)):\n            fields = {name: name for name in fields}\n\n        if fields is None:\n            # New version (much faster!, but needs cleaning up)\n            import attr\n            colnames = list(self.items[0].as_dict().keys())  # hack! the field names should perhaps be passed in during initialisation?\n            return pd.DataFrame([attr.astuple(x) for x in self.items], columns=colnames)\n            # Old version:\n            #return pd.DataFrame([x.to_series() for x in self.items])\n        else:\n            # New version (much faster!)\n            colnames = list(fields.keys())\n            attr_getters = [attrgetter(attr_name) for attr_name in fields.values()]\n            return pd.DataFrame([tuple(func(x) for func in attr_getters) for x in self.items], columns=colnames)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexporting the current state of the object to a CSV file.", "response": "def to_csv(self, filename=None, *, fields=None, append=False, header=True, header_prefix='', sep=',', newline='\\n'):\n        \"\"\"\n        Parameters\n        ----------\n        filename: str or None\n            The file to which output will be written. By default, any existing content is\n            overwritten. Use `append=True` to open the file in append mode instead.\n            If filename is None, the generated CSV output is returned instead of written\n            to a file.\n        fields: list or dict\n            List of field names to export, or dictionary mapping output column names\n            to attribute names of the generators.\n\n            Examples:\n               fields=['field_name_1', 'field_name_2']\n               fields={'COL1': 'field_name_1', 'COL2': 'field_name_2'}\n        append: bool\n            If `True`, open the file in 'append' mode to avoid overwriting existing content.\n            Default is `False`, i.e. any existing content will be overwritten.\n            This argument only has an effect if `filename` is given (i.e. if output happens\n            to a file instead of returning a CSV string).\n        header: bool or str or None\n            If `header=False` or `header=None` then no header line will be written.\n            If `header` is a string then this string will be used as the header line.\n            If `header=True` then a header line will be automatically generated from\n            the field names of the custom generator.\n        header_prefix: str\n            If `header=True` then the auto-generated header line will be prefixed\n            with `header_prefix` (otherwise this argument has no effect). For example,\n            set `header_prefix='#'` to make the header line start with '#'. Default: ''\n        sep: str\n            Field separator to use in the output. Default: ','\n        newline: str\n            Line terminator to use in the output. Default: '\\n'\n\n        Returns\n        -------\n        The return value depends on the value of `filename`.\n        If `filename` is given, writes the output to the file and returns `None`.\n        If `filename` is `None`, returns a string containing the CSV output.\n        \"\"\"\n        assert isinstance(append, bool)\n\n        if fields is None:\n            raise NotImplementedError(\"TODO: derive field names automatically from the generator which produced this item list\")\n\n        if isinstance(fields, (list, tuple)):\n            fields = {name: name for name in fields}\n\n        header_line = _generate_csv_header_line(header=header, header_prefix=header_prefix, header_names=fields.keys(), sep=sep, newline=newline)\n\n        if filename is not None:\n            # ensure parent directory of output file exits\n            dirname = os.path.dirname(os.path.abspath(filename))\n            if not os.path.exists(dirname):\n                os.makedirs(dirname)\n        file_or_string = open(filename, 'a' if append else 'w') if (filename is not None) else io.StringIO()\n\n        retval = None\n        attr_getters = [attrgetter(attr_name) for attr_name in fields.values()]\n        try:\n\n            file_or_string.write(header_line)\n\n            for x in self.items:\n                line = sep.join([format(func(x)) for func in attr_getters]) + newline\n                file_or_string.write(line)\n\n            if filename is None:\n                retval = file_or_string.getvalue()\n\n        finally:\n            file_or_string.close()\n\n        return retval"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a fresh spawn of g unless g is already there.", "response": "def spawn_generator(self, g):\n        \"\"\"\n        Return a fresh spawn of g unless g is already\n        contained in this SpawnMapping, in which case\n        return the previously spawned generator.\n        \"\"\"\n        try:\n            return self.mapping[g]\n        except KeyError:\n            return g._spawn(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef spawn(self, spawn_mapping=None):\n        spawn_mapping = spawn_mapping or SpawnMapping()\n\n        if self.parent is not None:\n            if self.parent in spawn_mapping:\n                # Return new clone of the mapped parent\n                return spawn_mapping[self.parent].clone()\n            else:\n                raise TohuCloneError(\"Cannot spawn a cloned generator without being able to map its parent.\")\n        else:\n            new_obj = spawn_mapping.spawn_generator(self)\n            return new_obj", "response": "Spawn a new generator which behaves the same way as this one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an exact copy of this generator which behaves the same way returns the same copy and which is the same elements in the same order as the original generator.", "response": "def clone(self, spawn_mapping=None):\n        \"\"\"\n        Return an exact copy of this generator which behaves the same way\n        (i.e., produces the same elements in the same order) and which is\n        automatically reset whenever the original generator is reset.\n        \"\"\"\n        c = self.spawn(spawn_mapping)\n        self.register_clone(c)\n        c.register_parent(self)\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef all_generators(self):\n        for arg_gen in self.arg_gens:\n            yield arg_gen\n\n        for kwarg_gen in self.kwarg_gens.values():\n            yield kwarg_gen", "response": "Iterate over all generators in the context."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef Split(g, *, maxbuffer=10, tuple_len=None):\n    if tuple_len is None:\n        try:\n            tuple_len = g.tuple_len\n        except AttributeError:\n            raise ValueError(\"Argument 'tuple_len' must be given since generator is not of type TupleGenerator.\")\n\n    g_buffered = BufferedTuple(g, maxbuffer=maxbuffer, tuple_len=tuple_len)\n\n    return tuple(NthElementBuffered(g_buffered, i) for i in range(tuple_len))", "response": "Splits a generator into individual generators."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tuple_len(self):\n        try:\n            return self._tuple_len\n        except AttributeError:\n            raise NotImplementedError(\"Class {} does not implement attribute 'tuple_len'.\".format(self.__class__.__name__))", "response": "Returns the length of the tuple produced by this generator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning all valid and active faults ordered by ID.", "response": "def show_faults():\n    \"\"\"\n    Return all valid/active faults ordered by ID to allow the user to pick and choose.\n\n    :return:  List of Tuples where the Tuple elements are:  (fault id, fault template)\n    \"\"\"\n    cursor = CONN.cursor()\n\n    query = \"select fau_id, fault from surfaults where fau_is_valid = 'y' order by fau_id asc\"\n    cursor.execute(query)\n    result = cursor.fetchall()\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_sentences():\n    cursor = CONN.cursor()\n\n    query = \"select sen_id, sentence from sursentences where sen_is_valid = 'y' order by sen_id asc\"\n    cursor.execute(query)\n    result = cursor.fetchall()\n\n    response_dict = {}\n\n    for row in result:\n        response_dict[row[0]] = row[1]\n\n    return response_dict", "response": "Return all valid and active sentences ordered by ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves a randomly - generated error message as a unicode string.", "response": "def get_fault(fault_id=None):\n    \"\"\"Retrieve a randomly-generated error message as a unicode string.\n    \n    :param fault_id:\n        \n        Allows you to optionally specify an integer representing the fault_id \n        from the database table.  This allows you to retrieve a specific fault\n        each time, albeit with different keywords.\"\"\"\n\n    counts = __get_table_limits()\n    result = None\n    id_ = 0\n\n    try:\n        if isinstance(fault_id, int):\n            id_ = fault_id\n        elif isinstance(fault_id, float):\n            print(\"\"\"ValueError:  Floating point number detected.\n                  Rounding number to 0 decimal places.\"\"\")\n            id_ = round(fault_id)\n        else:\n            id_ = random.randint(1, counts['max_fau'])\n\n    except ValueError:\n        print(\"ValueError:  Incorrect parameter type detected.\")\n\n    if id_ <= counts['max_fau']:\n        fault = __get_fault(counts, fault_id=id_)\n    else:\n        print(\"\"\"ValueError:  Parameter integer is too high.\n              Maximum permitted value is {0}.\"\"\".format(str(counts['max_fau'])))\n        id_ = counts['max_fau']\n        fault = __get_fault(counts, fault_id=id_)\n\n    if fault is not None:\n        while fault[0] == 'n':\n            if id_ is not None:\n                fault = __get_fault(counts, None)\n            else:\n                fault = __get_fault(counts, id_)\n        if fault[0] == 'y':\n            result = __process_sentence(fault, counts)\n        return result\n    else:\n        print('ValueError: _fault cannot be None.')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_sentence(sentence_id=None):\n\n    counts = __get_table_limits()\n    result = None\n    id_ = 0\n\n    try:\n        if isinstance(sentence_id, int):\n            id_ = sentence_id\n        elif isinstance(sentence_id, float):\n            print(\"\"\"ValueError:  Floating point number detected.\n                  Rounding number to 0 decimal places.\"\"\")\n            id_ = round(sentence_id)\n        else:\n            id_ = random.randint(1, counts['max_sen'])\n\n    except ValueError:\n        print(\"ValueError:  Incorrect parameter type detected.\")\n\n    if id_ <= counts['max_sen']:\n        sentence = __get_sentence(counts, sentence_id=id_)\n    else:\n        print(\"\"\"ValueError:  Parameter integer is too high.\n              Maximum permitted value is {0}.\"\"\".format(str(counts['max_sen'])))\n        id_ = counts['max_sen']\n        sentence = __get_sentence(counts, sentence_id=id_)\n\n    if sentence is not None:\n        while sentence[0] == 'n':\n            if id_ is not None:\n                # here we delibrately pass 'None' to __getsentence__ as it will\n                sentence = __get_sentence(counts, None)\n            else:\n                sentence = __get_sentence(counts, id_)\n        if sentence[0] == 'y':\n            result = __process_sentence(sentence, counts)\n        return result\n    else:\n        print('ValueError: _sentence cannot be None.')", "response": "Retrieves a randomly - generated sentence from the database table."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __get_sentence(counts, sentence_id=None):\n\n    # First of all we need a cursor and a query to retrieve our ID's\n    cursor = CONN.cursor()\n    check_query = \"select sen_id from sursentences\"\n\n    # Now we fetch the result of the query and save it into check_result\n    cursor.execute(check_query)\n    check_result = cursor.fetchall()\n\n    # declare an empty list to be populated below\n    id_list = []\n    id_to_fetch = None\n\n    # Populate the id_list variable with all of the ID's we retrieved from the database query.\n    for row in check_result:\n        id_list.append(row[0])\n\n    if sentence_id is not None:\n        if type(sentence_id) is int:\n            id_to_fetch = sentence_id\n    else:\n        id_to_fetch = random.randint(1, counts['max_sen'])\n\n        while id_to_fetch not in id_list:\n            id_to_fetch = random.randint(1, counts['max_sen'])\n\n    query = (\"select * from sursentences where sen_id = {0}\".format(id_to_fetch))\n    cursor.execute(query)\n    result = cursor.fetchone()\n    # cursor.close()\n\n    return result", "response": "Let s fetch a random sentence that we then need to substitute bits of..."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __get_verb(counts):\n\n    cursor = CONN.cursor()\n    check_query = \"select verb_id from surverbs\"\n\n    cursor.execute(check_query)\n    check_result = cursor.fetchall()\n\n    id_list = []\n    for row in check_result:\n        id_list.append(row[0])\n\n    rand = random.randint(1, counts['max_verb'])\n\n    while rand not in id_list:\n        rand = random.randint(1, counts['max_verb'])\n\n    query = \"select * from surverbs where verb_id = {0}\".format(rand)\n    cursor.execute(query)\n    result = cursor.fetchone()\n    # cursor.close()\n\n    return result[1]", "response": "Let s fetch a VERB by random number"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __get_table_limits():\n\n    table_counts = {\n        'max_adjectives': None,\n        'max_names': None,\n        'max_nouns': None,\n        'max_sentences': None,\n        'max_faults': None,\n        'max_verbs': None\n    }\n\n    cursor = CONN.cursor()\n\n    cursor.execute('SELECT count(*) FROM suradjs')\n    table_counts['max_adjectives'] = cursor.fetchone()\n    table_counts['max_adjectives'] = table_counts['max_adjectives'][0]\n\n    cursor.execute('SELECT count(*) FROM surnames')\n    table_counts['max_names'] = cursor.fetchone()\n    table_counts['max_names'] = table_counts['max_names'][0]\n\n    cursor.execute('SELECT count(*) FROM surnouns')\n    table_counts['max_nouns'] = cursor.fetchone()\n    table_counts['max_nouns'] = table_counts['max_nouns'][0]\n\n    cursor.execute('SELECT count(*) FROM sursentences')\n    table_counts['max_sen'] = cursor.fetchone()\n    table_counts['max_sen'] = table_counts['max_sen'][0]\n\n    cursor.execute('SELECT count(*) FROM surfaults')\n    table_counts['max_fau'] = cursor.fetchone()\n    table_counts['max_fau'] = table_counts['max_fau'][0]\n\n    cursor.execute('SELECT count(*) FROM surverbs')\n    table_counts['max_verb'] = cursor.fetchone()\n    table_counts['max_verb'] = table_counts['max_verb'][0]\n\n    return table_counts", "response": "This function takes a count of each of the database tables so we know our max_adjectives max_names max_nouns max_sentences max_faults max_verbs and max_verb to the calling function..."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __process_sentence(sentence_tuple, counts):\n\n    sentence = sentence_tuple[2]\n\n    # now we start replacing words one type at a time...\n    sentence = __replace_verbs(sentence, counts)\n\n    sentence = __replace_nouns(sentence, counts)\n\n    sentence = ___replace_adjective_maybe(sentence, counts)\n\n    sentence = __replace_adjective(sentence, counts)\n\n    sentence = __replace_names(sentence, counts)\n\n    # here we perform a check to see if we need to use A or AN depending on the \n    # first letter of the following word...\n    sentence = __replace_an(sentence)\n\n    # replace the new repeating segments\n    sentence = __replace_repeat(sentence)\n\n    # now we will read, choose and substitute each of the RANDOM sentence tuples\n    sentence = __replace_random(sentence)\n\n    # now we are going to choose whether to capitalize words/sentences or not\n    sentence = __replace_capitalise(sentence)\n\n    # here we will choose whether to capitalize all words in the sentence\n    sentence = __replace_capall(sentence)\n\n    # check for appropriate spaces in the correct places.\n    sentence = __check_spaces(sentence)\n\n    return sentence", "response": "process a single sentence from the tuple"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nletting find and replace all instances of verbs with the same value", "response": "def __replace_verbs(sentence, counts):\n    \"\"\"Lets find and replace all instances of #VERB\n    :param _sentence:\n    :param counts:\n    \"\"\"\n\n    if sentence is not None:\n        while sentence.find('#VERB') != -1:\n            sentence = sentence.replace('#VERB', str(__get_verb(counts)), 1)\n\n            if sentence.find('#VERB') == -1:\n                return sentence\n        return sentence\n    else:\n        return sentence"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __replace_nouns(sentence, counts):\n\n    if sentence is not None:\n        while sentence.find('#NOUN') != -1:\n            sentence = sentence.replace('#NOUN', str(__get_noun(counts)), 1)\n\n            if sentence.find('#NOUN') == -1:\n                return sentence\n\n        return sentence\n    else:\n        return sentence", "response": "Lets find and replace all instances of NOUN with the corresponding number"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ___replace_adjective_maybe(sentence, counts):\n\n    random_decision = random.randint(0, 1)\n\n    if sentence is not None:\n\n        while sentence.find('#ADJECTIVE_MAYBE') != -1:\n\n            if random_decision % 2 == 0:\n                sentence = sentence.replace('#ADJECTIVE_MAYBE',\n                                              ' ' + str(__get_adjective(counts)), 1)\n            elif random_decision % 2 != 0:\n                sentence = sentence.replace('#ADJECTIVE_MAYBE', '', 1)\n\n            if sentence.find('#ADJECTIVE_MAYBE') == -1:\n                return sentence\n        return sentence\n    else:\n        return sentence", "response": "Lets find and replace all instances of ADJECTIVE_MAYBE and ADJECTIVE_MAYBE with the appropriate value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nletting find and replace all instances of ADJECTIVE and get the correct ID", "response": "def __replace_adjective(sentence, counts):\n    \"\"\"Lets find and replace all instances of #ADJECTIVE\n    :param _sentence:\n    :param counts:\n    \"\"\"\n\n    if sentence is not None:\n\n        while sentence.find('#ADJECTIVE') != -1:\n            sentence = sentence.replace('#ADJECTIVE',\n                                          str(__get_adjective(counts)), 1)\n\n            if sentence.find('#ADJECTIVE') == -1:\n                return sentence\n        return sentence\n    else:\n        return sentence"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlet find and replace all instances of NAME with the corresponding names.", "response": "def __replace_names(sentence, counts):\n    \"\"\"Lets find and replace all instances of #NAME\n    :param _sentence:\n    :param counts:\n    \"\"\"\n\n    if sentence is not None:\n\n        while sentence.find('#NAME') != -1:\n            sentence = sentence.replace('#NAME', str(__get_name(counts)), 1)\n\n            if sentence.find('#NAME') == -1:\n                return sentence\n        return sentence\n    else:\n        return sentence"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlets find and replace all instances of an in the next A sequence.", "response": "def __replace_an(sentence):\n    \"\"\"Lets find and replace all instances of #AN\n    This is a little different, as this depends on whether the next\n    word starts with a vowel or a consonant.\n\n    :param _sentence:\n    \"\"\"\n\n    if sentence is not None:\n        while sentence.find('#AN') != -1:\n            an_index = sentence.find('#AN')\n\n            if an_index > -1:\n                an_index += 4\n\n                if sentence[an_index] in 'aeiouAEIOU':\n                    sentence = sentence.replace('#AN', str('an'), 1)\n                else:\n                    sentence = sentence.replace('#AN', str('a'), 1)\n\n            if sentence.find('#AN') == -1:\n                return sentence\n        return sentence\n    else:\n        return sentence"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlets find and replace all instances of RANDOM with a random one.", "response": "def __replace_random(sentence):\n    \"\"\"Lets find and replace all instances of #RANDOM\n    :param _sentence:\n    \"\"\"\n\n    sub_list = None\n    choice = None\n\n    if sentence is not None:\n\n        while sentence.find('#RANDOM') != -1:\n\n            random_index = sentence.find('#RANDOM')\n            start_index = sentence.find('#RANDOM') + 8\n            end_index = sentence.find(']')\n\n            if sentence.find('#RANDOM') is not None:\n                sub_list = sentence[start_index:end_index].split(',')\n\n                choice = random.randint(1, int(sub_list[0]))\n                # _sub_list[_choice]\n\n            to_be_replaced = sentence[random_index:end_index + 1]\n            sentence = sentence.replace(to_be_replaced, sub_list[choice], 1)\n\n            if sentence.find('#RANDOM') == -1:\n                return sentence\n\n        return sentence\n    else:\n        return sentence"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __replace_repeat(sentence):\n\n    ######### USE SENTENCE_ID 47 for testing!\n\n    repeat_dict = {}\n\n    if sentence is not None:\n\n        while sentence.find('#DEFINE_REPEAT') != -1:\n            begin_index = sentence.find('#DEFINE_REPEAT')\n            start_index = begin_index + 15\n            end_index = sentence.find(']')\n\n            if sentence.find('#DEFINE_REPEAT') is not None:\n                sub_list = sentence[start_index:end_index].split(',')\n                choice = sub_list[0]\n                repeat_text = sub_list[1]\n                repeat_dict[choice] = repeat_text\n                sentence = sentence.replace(sentence[begin_index:end_index + 1], '', 1)\n\n        while sentence.find('#REPEAT') != -1:\n            if sentence.find('#REPEAT') is not None:\n                repeat_begin_index = sentence.find('#REPEAT')\n                repeat_start_index = repeat_begin_index + 8\n                # by searching from repeat_index below we don't encounter dodgy bracket-matching errors.\n                repeat_end_index = sentence.find(']', repeat_start_index)\n                repeat_index = sentence[repeat_start_index:repeat_end_index]\n\n                if repeat_index in repeat_dict:\n                    sentence = sentence.replace(sentence[repeat_begin_index:repeat_end_index + 1],\n                                                  str(repeat_dict[repeat_index]))\n\n        if sentence.find('#REPEAT') == -1:\n            return sentence\n        return sentence\n    else:\n        return sentence", "response": "Replaces repeating random elements in a word sentence."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __replace_capitalise(sentence):\n\n    if sentence is not None:\n        while sentence.find('#CAPITALISE') != -1:\n\n            cap_index = _sentence.find('#CAPITALISE')\n            part1 = sentence[:cap_index]\n            part2 = sentence[cap_index + 12:cap_index + 13]\n            part3 = sentence[cap_index + 13:]\n\n            if part2 in \"abcdefghijklmnopqrstuvwxyz\":\n                sentence = part1 + part2.capitalize() + part3\n            else:\n                sentence = part1 + part2 + part3\n\n        if sentence.find('#CAPITALISE') == -1:\n            return sentence\n    else:\n        return sentence", "response": "This function replaces all instances of the uppercase and cap the next word in the sentence."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __replace_capall(sentence):\n\n    # print \"\\nReplacing CAPITALISE:  \"\n\n    if sentence is not None:\n        while sentence.find('#CAPALL') != -1:\n            # _cap_index = _sentence.find('#CAPALL')\n            sentence = sentence.upper()\n            sentence = sentence.replace('#CAPALL ', '', 1)\n\n        if sentence.find('#CAPALL') == -1:\n            return sentence\n    else:\n        return sentence", "response": "replace all CAPALL with uppercase"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive a dataframe with certain columns that contain lists return another dataframe where the elements in each list are \"exploded\" into individual rows.", "response": "def explode_columns(df, colnames):\n    \"\"\"\n    Given a dataframe with certain columns that contain lists,\n    return another dataframe where the elements in each list\n    are \"exploded\" into individual rows.\n\n    Example:\n\n    >>> df\n       col1 col2             col3          col4\n    0   foo   11  [DDD, AAA, CCC]  [dd, aa, cc]\n    1   bar   22            [FFF]          [ff]\n    2  quux   33       [EEE, BBB]      [ee, bb]\n\n    >>> explode_columns(df, ['col3'])\n       col1 col2 col3 col4\n    0   foo   11  DDD   dd\n    1   foo   11  AAA   aa\n    2   foo   11  CCC   cc\n    3   bar   22  FFF   ff\n    4  quux   33  EEE   ee\n    5  quux   33  BBB   bb\n\n    >>> explode_columns(df, {'col3_exploded': 'col3'})\n       col1 col2 col3_exploded col4\n    0   foo   11           DDD   dd\n    1   foo   11           AAA   aa\n    2   foo   11           CCC   cc\n    3   bar   22           FFF   ff\n    4  quux   33           EEE   ee\n    5  quux   33           BBB   bb\n    \"\"\"\n    if isinstance(colnames, (list, tuple)):\n        colnames = {name: name for name in colnames}\n\n    remaining_columns = list(df.columns.difference(colnames.values()))\n    df2 = df.set_index(remaining_columns)\n    df3 = pd.concat((make_exploded_column(df2, col_new, col_old) for col_new, col_old in colnames.items()), axis=1)\n    levels_to_reset = list(range(len(remaining_columns)))\n    df4 = df3.reset_index(level=levels_to_reset).reset_index(drop=True)\n    return df4"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef print_generated_sequence(gen, num, *, sep=\", \", fmt='', seed=None):\n    if seed:\n       gen.reset(seed)\n\n    elems = [format(next(gen), fmt) for _ in range(num)]\n    sep_initial = \"\\n\\n\" if '\\n' in sep else \" \"\n    print(\"Generated sequence:{}{}\".format(sep_initial, sep.join(elems)))", "response": "Helper function which prints a sequence of num items produced by the random generator gen."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nensures input represents a valid date and return the corresponding datetime. date object.", "response": "def ensure_is_date_object(x):\n    \"\"\"\n    Ensure input represents a valid date and return the corresponding `datetime.date` object.\n\n    Valid inputs:\n\n      - string of the form \"YYYY-MM-DD\"\n      - dt.date object\n      - pd.Timestamp of the form \"YYYY-MM-DD 00:00:00\" with freq='D' (as is generated by pd.date_range())\n    \"\"\"\n    error_msg = f\"Cannot convert input to date object: {x} (type: {type(x)})\"\n\n    if isinstance(x, dt.date):\n        if isinstance(x, pd.Timestamp):\n            if x.freq != 'D':\n                raise TohuDateError(\"Pandas Timestamp must have freq='D' set. Got: freq={x.freq!r}\")\n            elif pd.Timestamp(x.date()) == x:\n                return x.date()\n            else:\n                raise TohuDateError(error_msg)\n        elif isinstance(x, dt.datetime):\n            raise TohuDateError(error_msg)\n        else:\n            return x\n    elif isinstance(x, str):\n        return parse_date_string(x)\n    else:\n        raise TohuDateError(error_msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef all_independent_generators(self):\n        return {g: name for g, name in self._ns.items() if not is_clone(g)}", "response": "Return all generators in this namespace which are not clones."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new class which can be used to create a tohu items class.", "response": "def make_tohu_items_class(clsname, attr_names):\n    \"\"\"\n    Parameters\n    ----------\n    clsname: string\n        Name of the class to be created\n\n    attr_names: list of strings\n        Names of the attributes of the class to be created\n    \"\"\"\n\n    item_cls = attr.make_class(clsname, {name: attr.ib() for name in attr_names}, repr=False, cmp=True, frozen=True)\n\n    def new_repr(self):\n        all_fields = ', '.join([f'{name}={repr(value)}' for name, value in attr.asdict(self).items()])\n        return f'{clsname}({all_fields})'\n\n    orig_eq = item_cls.__eq__\n\n    def new_eq(self, other):\n        \"\"\"\n        Custom __eq__() method which also allows comparisons with\n        tuples and dictionaries. This is mostly for convenience\n        during testing.\n        \"\"\"\n\n        if isinstance(other, self.__class__):\n            return orig_eq(self, other)\n        else:\n            if isinstance(other, tuple):\n                return attr.astuple(self) == other\n            elif isinstance(other, dict):\n                return attr.asdict(self) == other\n            else:\n                return NotImplemented\n\n    item_cls.__repr__ = new_repr\n    item_cls.__eq__ = new_eq\n    item_cls.keys = lambda self: attr_names\n    item_cls.__getitem__ = lambda self, key: getattr(self, key)\n    item_cls.as_dict = lambda self: attr.asdict(self)\n    item_cls.to_series = lambda self: pd.Series(attr.asdict(self))\n\n    return item_cls"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_tohu_items_name(cls):\n    assert issubclass(cls, TohuBaseGenerator)\n\n    try:\n        tohu_items_name = cls.__dict__['__tohu_items_name__']\n        logger.debug(f\"Using item class name '{tohu_items_name}' (derived from attribute '__tohu_items_name__')\")\n    except KeyError:\n        m = re.match('^(.*)Generator$', cls.__name__)\n        if m is not None:\n            tohu_items_name = m.group(1)\n            logger.debug(f\"Using item class name '{tohu_items_name}' (derived from custom generator name)\")\n        else:\n            msg = (\n                \"Cannot derive class name for items to be produced by custom generator. \"\n                \"Please set '__tohu_items_name__' at the top of the custom generator's \"\n                \"definition or change its name so that it ends in '...Generator'\"\n            )\n            raise ValueError(msg)\n\n    return tohu_items_name", "response": "Returns a string which defines the name of the class which will be used by the custom generator."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _init_randgen(self):\n        if self.p is None:\n            self.randgen = Random()\n            self.func_random_choice = self.randgen.choice\n        else:\n            self.randgen = np.random.RandomState()\n            self.func_random_choice = partial(self.randgen.choice, p=self.p)", "response": "Initializes the random generator to be used for picking elements from the input sequence."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _set_random_state_from(self, other):\n        try:\n            # this works if randgen is an instance of random.Random()\n            self.randgen.setstate(other.randgen.getstate())\n        except AttributeError:\n            # this works if randgen is an instance of numpy.random.RandomState()\n            self.randgen.set_state(other.randgen.get_state())\n\n        return self", "response": "Transfer the internal state from other to self."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _init_randgen(self):\n        if self.p is None:\n            self.randgen = Random()\n            self.func_random_choice = partial(self.randgen.choices, k=self.num)\n        else:\n            self.randgen = np.random.RandomState()\n            self.func_random_choice = partial(self.randgen.choice, p=self.p, k=self.num)", "response": "Initializes the random generator to be used for picking elements from the input sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_with_tohu_generators(field_gens, adict):\n    for name, gen in adict.items():\n        if isinstance(gen, TohuUltraBaseGenerator):\n            field_gens[name] = gen", "response": "Helper function which updates the dict field_gens with any items in the dict adict that are instances of TohuUltraBaseGenerator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind all tohu. BaseGenerator templates occurring in the given object.", "response": "def find_field_generator_templates(obj):\n    \"\"\"\n    Return dictionary with the names and instances of\n    all tohu.BaseGenerator occurring in the given\n    object's class & instance namespaces.\n    \"\"\"\n\n    cls_dict = obj.__class__.__dict__\n    obj_dict = obj.__dict__\n    #debug_print_dict(cls_dict, 'cls_dict')\n    #debug_print_dict(obj_dict, 'obj_dict')\n\n    field_gens = {}\n    update_with_tohu_generators(field_gens, cls_dict)\n    update_with_tohu_generators(field_gens, obj_dict)\n\n    return field_gens"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_item_class_name_on_custom_generator_class(cls):\n    if '__tohu__items__name__' in cls.__dict__:\n        logger.debug(\n            f\"Using item class name '{cls.__tohu_items_name__}' (derived from attribute '__tohu_items_name__')\")\n    else:\n        m = re.match('^(.*)Generator$', cls.__name__)\n        if m is not None:\n            cls.__tohu_items_name__ = m.group(1)\n            logger.debug(f\"Using item class name '{cls.__tohu_items_name__}' (derived from custom generator name)\")\n        else:\n            raise ValueError(\"Cannot derive class name for items to be produced by custom generator. \"\n                             \"Please set '__tohu_items_name__' at the top of the custom generator's \"\n                             \"definition or change its name so that it ends in '...Generator'\")", "response": "Set the class name of the items to be produced by the custom generator class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_item_class_for_custom_generator_class(cls):\n    clsname = cls.__tohu_items_name__\n    attr_names = cls.field_gens.keys()\n    return make_item_class(clsname, attr_names)", "response": "Returns the class that is used to create the item class for the given custom generator class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _add_new_init_method(cls):\n\n    orig_init = cls.__init__\n\n    def new_init_method(self, *args, **kwargs):\n        logger.debug(f\"Initialising new {self} (type: {type(self)})\")\n\n        # Call original __init__ function to ensure we pick up\n        # any tohu generators that are defined there.\n        #\n        logger.debug(f\"    orig_init: {orig_init}\")\n        orig_init(self, *args, **kwargs)\n\n        #\n        # Find field generator templates and spawn them to create\n        # field generators for the new custom generator instance.\n        #\n        field_gens_templates = find_field_generator_templates(self)\n        logger.debug(f'Found {len(field_gens_templates)} field generator template(s):')\n        debug_print_dict(field_gens_templates)\n\n        logger.debug('Spawning field generator templates...')\n        origs = {}\n        spawned = {}\n        dependency_mapping = {}\n        for (name, gen) in field_gens_templates.items():\n            origs[name] = gen\n            spawned[name] = gen.spawn(dependency_mapping)\n            logger.debug(f'Adding dependency mapping: {gen} -> {spawned[name]}')\n\n        self.field_gens = spawned\n        self.__dict__.update(self.field_gens)\n\n        logger.debug(f'Spawned field generators attached to custom generator instance:')\n        debug_print_dict(self.field_gens)\n\n        # Add seed generator\n        #\n        #self.seed_generator = SeedGenerator()\n\n        # Create class for the items produced by this generator\n        #\n        self.__class__.item_cls = make_item_class_for_custom_generator_class(self)\n\n    cls.__init__ = new_init_method", "response": "Add a new init method to the class."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a new next method to the class.", "response": "def _add_new_next_method(cls):\n    \"\"\"\n    TODO\n    \"\"\"\n\n    def new_next(self):\n        field_values = [next(g) for g in self.field_gens.values()]\n        return self.item_cls(*field_values)\n\n    cls.__next__ = new_next"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a new reset method to cls which resets the internal internal", "response": "def _add_new_reset_method(cls):\n    \"\"\"\n    Attach a new `reset()` method to `cls` which resets the internal\n    seed generator of `cls` and then resets each of its constituent\n    field generators found in `cls.field_gens`.\n    \"\"\"\n\n    #\n    # Create and assign automatically generated reset() method\n    #\n\n\n    def new_reset_method(self, seed=None):\n        logger.debug(f'[EEE] Inside automatically generated reset() method for {self} (seed={seed})')\n\n        if seed is not None:\n            self.seed_generator.reset(seed)\n            for name, gen in self.field_gens.items():\n                next_seed = next(self.seed_generator)\n                gen.reset(next_seed)\n\n            # TODO: the following should be covered by the newly added\n            # reset() method in IndependentGeneratorMeta. However, for\n            # some reason we can't call this via the usual `orig_reset()`\n            # pattern, so we have to duplicate this here. Not ideal...\n            for c in self._clones:\n                c.reset_clone(seed)\n\n        return self\n\n    cls.reset = new_reset_method"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _add_new_spawn_method(cls):\n\n    def new_spawn_method(self, dependency_mapping):\n        # TODO/FIXME: Check that this does the right thing:\n        # (i) the spawned generator is independent of the original one (i.e. they can be reset independently without altering the other's behaviour)\n        # (ii) ensure that it also works if this custom generator's __init__ requires additional arguments\n        #new_instance = self.__class__()\n        #\n        # FIXME: It would be good to explicitly spawn the field generators of `self`\n        #        here because this would ensure that the internal random generators\n        #        of the spawned versions are in the same state as the ones in `self`.\n        #        This would guarantee that the spawned custom generator produces the\n        #        same elements as `self` even before reset() is called explicitly.\n        new_instance = cls()\n        return new_instance\n\n    cls.spawn = new_spawn_method", "response": "Add a new spawn method to the class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset_input_generators(self, seed):\n        seed_generator = SeedGenerator().reset(seed=seed)\n\n        for gen in self.input_generators:\n            gen.reset(next(seed_generator))\n            try:\n                # In case `gen` is itself a derived generator,\n                # recursively reset its own input generators.\n                gen.reset_input_generators(next(seed_generator))\n            except AttributeError:\n                pass", "response": "Reset all input generators to the derived generator."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _spot_check_that_elements_produced_by_this_generator_have_attribute(self, name):\n        g_tmp = self.values_gen.spawn()\n        sample_element = next(g_tmp)[0]\n        try:\n            getattr(sample_element, name)\n        except AttributeError:\n            raise AttributeError(f\"Items produced by {self} do not have the attribute '{name}'\")", "response": "Helper function to spot - check that the items produces by this generator have the attribute name."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexports items as rows in a pandas dataframe table.", "response": "def to_df(self, fields=None, fields_to_explode=None):\n        \"\"\"\n        Export items as rows in a pandas dataframe table.\n\n        Parameters\n        ----------\n\n        fields: list or dict\n            List of field names to export, or dictionary mapping output column names\n            to attribute names of the generators.\n\n            Examples:\n               fields=['field_name_1', 'field_name_2']\n               fields={'COL1': 'field_name_1', 'COL2': 'field_name_2'}\n\n        fields_to_explode: list or None\n            Optional list of field names where each entry (which must itself be a sequence)\n            is to be \"exploded\" into separate rows.\n\n        \"\"\"\n        if isinstance(fields, (list, tuple)):\n            fields = {name: name for name in fields}\n\n        assert fields_to_explode is None or isinstance(fields_to_explode, (list, tuple))\n        if fields_to_explode is None:\n            fields_to_explode = []\n\n        if fields is None:\n            colnames_to_export = list(self.items[0].as_dict().keys())  # hack! the field names should perhaps be passed in during initialisation?\n        else:\n            colnames_to_export = list(fields.keys())\n\n        if not set(fields_to_explode).issubset(colnames_to_export):\n            raise ValueError(\n                \"All fields to explode must occur as column names. \"\n                f\"Got field names: {fields_to_explode}. Column names: {list(fields.keys())}\"\n            )\n\n        if fields is None:\n            # New version (much faster!, but needs cleaning up)\n            import attr\n            df = pd.DataFrame([attr.astuple(x) for x in self.items], columns=colnames_to_export)\n            # Old version:\n            #return pd.DataFrame([x.to_series() for x in self.items])\n        else:\n            # New version (much faster!)\n\n            def make_attrgetter(attr_name_new, attr_name, fields_to_explode):\n                # TODO: this needs cleaning up!\n                if attr_name_new in fields_to_explode and '.' in attr_name:\n                    attr_name_first_part, attr_name_rest = attr_name.split('.', maxsplit=1)\n\n                    def func(row):\n                        foo_items = attrgetter(attr_name_first_part)(row)\n                        return [attrgetter(attr_name_rest)(x) for x in foo_items]\n\n                    return func\n                else:\n                    return attrgetter(attr_name)\n\n            attr_getters = [make_attrgetter(attr_name_new, attr_name, fields_to_explode) for attr_name_new, attr_name in fields.items()]\n            try:\n                df = pd.DataFrame([tuple(func(x) for func in attr_getters) for x in self.items], columns=colnames_to_export)\n            except AttributeError as exc:\n                msg = (\n                    \"Could not export to dataframe. Did you forget to pass any fields \"\n                    \"which contain sequences within the 'fields_to_explode' argument?. \"\n                    f\"The original error message was: \\\"{exc}\\\"\"\n                )\n                raise AttributeError(msg)\n\n        if fields_to_explode != []:\n            # TODO: add sanity checks to avoid unwanted behaviour (e.g. that all columns\n            # to be exploded must have the same number of elements in each entry?)\n            df = explode_columns(df, fields_to_explode)\n\n        return df"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_csv(self, output_file=None, *, fields=None, fields_to_explode=None, append=False, header=True, header_prefix='', sep=',', newline='\\n'):\n        assert isinstance(append, bool)\n\n        if fields is None:\n            raise NotImplementedError(\"TODO: derive field names automatically from the generator which produced this item list\")\n\n        if fields_to_explode is not None:\n            raise NotImplementedError(\"TODO: the 'fields_to_explode' argument is not supported for CSV export yet.\")\n\n        if isinstance(fields, (list, tuple)):\n            fields = {name: name for name in fields}\n\n        header_line = _generate_csv_header_line(header=header, header_prefix=header_prefix, header_names=fields.keys(), sep=sep, newline=newline)\n\n        if output_file is None:\n            file_or_string = io.StringIO()\n        elif isinstance(output_file, str):\n            mode = 'a' if append else 'w'\n            file_or_string = open(output_file, mode)\n\n            # ensure parent directory of output file exits\n            dirname = os.path.dirname(os.path.abspath(output_file))\n            if not os.path.exists(dirname):\n                logger.debug(f\"Creating parent directory of output file '{output_file}'\")\n                os.makedirs(dirname)\n\n        elif isinstance(output_file, io.IOBase):\n            file_or_string = output_file\n        else:\n            raise TypeError(f\"Invalid output file: {output_file} (type: {type(output_file)})\")\n\n        retval = None\n        attr_getters = [attrgetter(attr_name) for attr_name in fields.values()]\n        try:\n            # TODO: quick-and-dirty solution to enable writing to gzip files; tidy this up!\n            # (Note that for regular file output we don't want to encode each line to a bytes\n            # object because this seems to be ca. 2x slower).\n            if isinstance(file_or_string, gzip.GzipFile):\n                file_or_string.write(header_line.encode())\n                for x in self.items:\n                    line = sep.join([format(func(x)) for func in attr_getters]) + newline\n                    file_or_string.write(line.encode())\n\n            else:\n                file_or_string.write(header_line)\n                for x in self.items:\n                    line = sep.join([format(func(x)) for func in attr_getters]) + newline\n                    file_or_string.write(line)\n\n            if output_file is None:\n                retval = file_or_string.getvalue()\n\n        finally:\n            file_or_string.close()\n\n        return retval", "response": "Exports the current state of the entry to a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_sql(self, url, table_name, *, schema=None, fields=None, fields_to_explode=None, if_exists=\"fail\", dtype=None):\n        if schema is None:\n            schema, table_name = _extract_schema_if_given(table_name)\n\n        engine = create_engine(url)\n        ins = inspect(engine)\n\n        if schema is not None and schema not in ins.get_schema_names():\n            logger.debug(f\"Creating non-existing schema: '{schema}'\")\n            engine.execute(CreateSchema(schema))\n\n        if table_name in ins.get_table_names(schema=schema) and if_exists == 'do_nothing':\n            logger.debug(\"Table already exists (use if_exists='replace' or if_exists='append' to modify it).\")\n            return\n\n        if if_exists == 'do_nothing':\n            # we handled the 'do nothing' case above; change to an option that pandas will understand\n            if_exists = 'fail'\n\n        with engine.begin() as conn:\n            self.to_df(fields=fields, fields_to_explode=fields_to_explode).to_sql(\n                table_name, conn, schema=schema, index=False, if_exists=if_exists, dtype=dtype)", "response": "Export items in a PostgreSQL table."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset(self, seed):\n        logger.debug(f'Resetting {self} (seed={seed})')\n        self.seed_generator.reset(seed)\n\n        for c in self.clones:\n            c.reset(seed)", "response": "Reset this generator s seed generator and any clones."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _load_config(initial_namespace=None, defaults=None):\n    # type: (Optional[str], Optional[str]) -> ConfigLoader\n    \"\"\"\n    Kwargs:\n        initial_namespace:\n        defaults:\n    \"\"\"\n    # load defaults\n    if defaults:\n        config = ConfigLoader()\n        config.update_from_object(defaults)\n\n    namespace = getattr(config, 'CONFIG_NAMESPACE', initial_namespace)\n    app_config = getattr(config, 'APP_CONFIG', None)\n\n    # load customised config\n    if app_config:\n        if namespace is None:\n            config.update_from_object(app_config)\n        else:\n            _temp = ConfigLoader()\n            _temp.update_from_object(app_config, lambda key: key.startswith(namespace))\n            config.update(_temp.namespace(namespace))\n\n    return config", "response": "Load the config from the object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef override_environment(settings, **kwargs):\n    # type: (Settings, **str) -> Generator\n    \"\"\"\n    Override env vars and reload the Settings object\n\n    NOTE:\n    Obviously this context has to be in place before you import any\n    module which reads env values at import time.\n\n    NOTE:\n    The values in `kwargs` must be strings else you will get a cryptic:\n\n        TypeError: execve() arg 3 contains a non-string value\n    \"\"\"\n    old_env = os.environ.copy()\n    os.environ.update(kwargs)\n\n    settings._reload()\n\n    try:\n        yield\n    except Exception:\n        raise\n    finally:\n        for key in kwargs.keys():\n            del os.environ[key]\n        os.environ.update(old_env)\n\n        settings._reload()", "response": "Override environment vars and reload the Settings object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _import_yaml(config_file_path):\n    try:\n        logger.info('Importing config %s...', config_file_path)\n        with open(config_file_path) as config_file:\n            return yaml.safe_load(config_file.read())\n    except IOError as ex:\n        raise RepexError('{0}: {1} ({2})'.format(\n            ERRORS['config_file_not_found'], config_file_path, ex))\n    except (yaml.parser.ParserError, yaml.scanner.ScannerError) as ex:\n        raise RepexError('{0} ({1})'.format(ERRORS['invalid_yaml'], ex))", "response": "Imports a YAML file into a configuration object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_all_files(filename_regex,\n                   path,\n                   base_dir,\n                   excluded_paths=None,\n                   excluded_filename_regex=None):\n    \"\"\"Get all files for processing.\n\n    This starts iterating from `base_dir` and checks for all files\n    that look like `filename_regex` under `path` regex excluding\n    all paths under the `excluded_paths` list, whether they are files\n    or folders. `excluded_paths` are explicit paths, not regex.\n    `excluded_filename_regex` are files to be excluded as well.\n    \"\"\"\n    # For windows\n    def replace_backslashes(string):\n        return string.replace('\\\\', '/')\n\n    excluded_paths = _normalize_excluded_paths(base_dir, excluded_paths)\n    if excluded_paths:\n        logger.info('Excluding paths: %s', excluded_paths)\n\n    logger.info('Looking for %s under %s...',\n                filename_regex, os.path.join(base_dir, path))\n    if excluded_filename_regex:\n        logger.info('Excluding file names: %s', excluded_filename_regex)\n\n    path_expression = re.compile(replace_backslashes(path))\n\n    target_files = []\n\n    for root, _, files in os.walk(base_dir):\n        if not root.startswith(tuple(excluded_paths)) \\\n                and path_expression.search(replace_backslashes(root)):\n            for filename in files:\n                filepath = os.path.join(root, filename)\n                is_file, matched, excluded_filename, excluded_path = \\\n                    _set_match_parameters(\n                        filename,\n                        filepath,\n                        filename_regex,\n                        excluded_filename_regex,\n                        excluded_paths)\n                if is_file and matched and not excluded_filename \\\n                        and not excluded_path:\n                    logger.debug('%s is a match. Appending to list...',\n                                 filepath)\n                    target_files.append(filepath)\n    return target_files", "response": "Get all files under base_dir that match filename_regex."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _match_tags(repex_tags, path_tags):\n    if 'any' in repex_tags or (not repex_tags and not path_tags):\n        return True\n    elif set(repex_tags) & set(path_tags):\n        return True\n    return False", "response": "Check if the user provided tags match the tags set in the config."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\niterate over all paths in config_file_path and process each.", "response": "def iterate(config_file_path=None,\n            config=None,\n            variables=None,\n            tags=None,\n            validate=True,\n            validate_only=False,\n            with_diff=False):\n    \"\"\"Iterate over all paths in `config_file_path`\n\n    :param string config_file_path: a path to a repex config file\n    :param dict config: a dictionary representing a repex config\n    :param dict variables: a dict of variables (can be None)\n    :param list tags: a list of tags to check for\n    :param bool validate: whether to perform schema validation on the config\n    :param bool validate_only: only perform validation without running\n    :param bool with_diff: whether to write a diff of all changes to a file\n    \"\"\"\n    # TODO: Check if tags can be a tuple instead of a list\n    if not isinstance(variables or {}, dict):\n        raise TypeError(ERRORS['variables_not_dict'])\n    if not isinstance(tags or [], list):\n        raise TypeError(ERRORS['tags_not_list'])\n\n    config = _get_config(config_file_path, config)\n    if validate or validate_only:\n        _validate_config_schema(config)\n    if validate_only:\n        logger.info('Config file validation completed successfully!')\n        sys.exit(0)\n\n    repex_vars = _merge_variables(config['variables'], variables or {})\n    repex_tags = tags or []\n    logger.debug('Chosen tags: %s', repex_tags)\n\n    for path in config['paths']:\n        _process_path(path, repex_tags, repex_vars, with_diff)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle a path in a single or multiple files in a single archive.", "response": "def handle_path(pathobj, variables=None, diff=False):\n    \"\"\"Iterate over all chosen files in a path\n\n    :param dict pathobj: a dict of a specific path in the config\n    :param dict variables: a dict of variables (can be None)\n    \"\"\"\n    logger.info('Handling path with description: %s',\n                pathobj.get('description'))\n\n    variables = variables or {}\n    variable_expander = _VariablesHandler()\n    pathobj = variable_expander.expand(variables, pathobj)\n\n    pathobj = _set_path_defaults(pathobj)\n\n    path_to_handle = os.path.join(pathobj['base_directory'], pathobj['path'])\n    logger.debug('Path to process: %s', path_to_handle)\n\n    validate = 'validator' in pathobj\n    if validate:\n        validator_config = pathobj['validator']\n        validator = _Validator(validator_config)\n        validator_type = validator_config.get('type', 'per_type')\n\n    rpx = Repex(pathobj)\n\n    if not pathobj.get('type'):\n        _handle_single_file(\n            rpx=rpx,\n            path_to_handle=path_to_handle,\n            pathobj=pathobj,\n            validate=validate,\n            diff=diff,\n            validator=validator if validate else None)\n    else:\n        _handle_multiple_files(\n            rpx=rpx,\n            path_to_handle=path_to_handle,\n            pathobj=pathobj,\n            validate=validate,\n            diff=diff,\n            validator=validator if validate else None,\n            validator_type=validator_type if validate else None)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild a dictionary of variables that can be used to create a new node.", "response": "def _build_vars_dict(vars_file='', variables=None):\n    \"\"\"Merge variables into a single dictionary\n\n    Applies to CLI provided variables only\n    \"\"\"\n    repex_vars = {}\n    if vars_file:\n        with open(vars_file) as varsfile:\n            repex_vars = yaml.safe_load(varsfile.read())\n    for var in variables:\n        key, value = var.split('=')\n        repex_vars.update({str(key): str(value)})\n    return repex_vars"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main(verbose, **kwargs):\n    config = kwargs['config']\n\n    if not config and not kwargs['regex_path']:\n        click.echo('Must either provide a path or a viable repex config file.')\n        sys.exit(1)\n\n    if verbose:\n        set_verbose()\n\n    if config:\n        repex_vars = _build_vars_dict(kwargs['vars_file'], kwargs['var'])\n        try:\n            iterate(\n                config_file_path=config,\n                variables=repex_vars,\n                tags=list(kwargs['tag']),\n                validate=kwargs['validate'],\n                validate_only=kwargs['validate_only'],\n                with_diff=kwargs['diff'])\n        except (RepexError, IOError, OSError) as ex:\n            sys.exit(str(ex))\n    else:\n        pathobj = _construct_path_object(**kwargs)\n        try:\n            handle_path(pathobj)\n        except (RepexError, IOError, OSError) as ex:\n            sys.exit(str(ex))", "response": "This function is used to run the repex command line interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef expand(self, repex_vars, fields):\n        logger.debug('Expanding variables...')\n\n        unexpanded_instances = set()\n\n        # Expand variables in variables\n        # TODO: This should be done in the global scope.\n        # _VariableHandler is called per path, which makes this redundant\n        # as variables are declared globally per config.\n        for k, v in repex_vars.items():\n            repex_vars[k] = self._expand_var(v, repex_vars)\n            instances = self._get_instances(repex_vars[k])\n            unexpanded_instances.update(instances)\n\n        # TODO: Consolidate variable expansion code into single logic\n        # Expand variables in path objects\n        for key in fields.keys():\n            field = fields[key]\n            if isinstance(field, str):\n                fields[key] = self._expand_var(field, repex_vars)\n                instances = self._get_instances(fields[key])\n                unexpanded_instances.update(instances)\n            elif isinstance(field, dict):\n                for k, v in field.items():\n                    fields[key][k] = self._expand_var(v, repex_vars)\n                    instances = self._get_instances(fields[key][k])\n                    unexpanded_instances.update(instances)\n            elif isinstance(field, list):\n                for index, item in enumerate(field):\n                    fields[key][index] = self._expand_var(item, repex_vars)\n                    instances = self._get_instances(fields[key][index])\n                    unexpanded_instances.update(instances)\n\n        if unexpanded_instances:\n            raise RepexError(\n                'Variables failed to expand: {0}\\n'\n                'Please make sure to provide all necessary variables '.format(\n                    list(unexpanded_instances)))\n\n        return fields", "response": "This function expands a variable in a file and returns a dict with the expanded variables."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexpands variable to its corresponding value in_string", "response": "def _expand_var(self, in_string, available_variables):\n        \"\"\"Expand variable to its corresponding value in_string\n\n        :param string variable: variable name\n        :param value: value to replace with\n        :param string in_string: the string to replace in\n        \"\"\"\n        instances = self._get_instances(in_string)\n        for instance in instances:\n            for name, value in available_variables.items():\n                variable_string = self._get_variable_string(name)\n                if instance == variable_string:\n                    in_string = in_string.replace(variable_string, value)\n        return in_string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nverify that all required strings are in the file_to_handle and that all required strings are in the file_to_handle.", "response": "def validate_before(self, content, file_to_handle):\n        \"\"\"Verify that all required strings are in the file\n        \"\"\"\n        logger.debug('Looking for required strings: %s', self.must_include)\n        included = True\n        for string in self.must_include:\n            if not re.search(r'{0}'.format(string), content):\n                logger.error('Required string `%s` not found in %s',\n                             string, file_to_handle)\n                included = False\n        if not included:\n            logger.debug('Required strings not found')\n            return False\n        logger.debug('Required strings found')\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind all matches of an expression in a file", "response": "def find_matches(self, content, file_to_handle):\n        \"\"\"Find all matches of an expression in a file\n        \"\"\"\n        # look for all match groups in the content\n        groups = [match.groupdict() for match in\n                  self.match_expression.finditer(content)]\n        # filter out content not in the matchgroup\n        matches = [group['matchgroup'] for group in groups\n                   if group.get('matchgroup')]\n\n        logger.info('Found %s matches in %s', len(matches), file_to_handle)\n        # We only need the unique strings found as we'll be replacing each\n        # of them. No need to replace the ones already replaced.\n        return list(set(matches))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreplace all occurences of the regex in all matches from a file with a specific value.", "response": "def replace(self, match, content):\n        \"\"\"Replace all occurences of the regex in all matches\n        from a file with a specific value.\n        \"\"\"\n        new_string = self.replace_expression.sub(self.replace_with, match)\n        logger.info('Replacing: [ %s ] --> [ %s ]', match, new_string)\n        new_content = content.replace(match, new_string)\n        return new_content"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_exit_events(self, no_workers=None, idle=None, reload=None, sig_term=None):\n        self._set('die-on-no-workers', no_workers, cast=bool)\n        self._set('exit-on-reload', reload, cast=bool)\n        self._set('die-on-term', sig_term, cast=bool)\n        self.set_idle_params(exit=idle)\n\n        return self._section", "response": "Set exit events on certain events."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset exception handling related params.", "response": "def set_exception_handling_params(self, handler=None, catch=None, no_write_exception=None):\n        \"\"\"Exception handling related params.\n\n        :param str|unicode|list[str|unicode] handler: Register one or more exception handling C-functions.\n\n        :param bool catch: Catch exceptions and report them as http output (including stack trace and env params).\n\n            .. warning:: Use only for testing purposes.\n\n        :param bool no_write_exception: Disable exception generation on write()/writev().\n\n            .. note:: This can be combined with ``logging.set_filters(write_errors=False, sigpipe=False)``.\n\n            .. note: Currently available for Python.\n\n        \"\"\"\n        self._set('exception-handler', handler, multi=True)\n        self._set('catch-exceptions', catch, cast=bool)\n        self._set('disable-write-exception', no_write_exception, cast=bool)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nactivates idle mode - put uWSGI in cheap mode after inactivity timeout in seconds. exit - shutdown uWSGI when idle.", "response": "def set_idle_params(self, timeout=None, exit=None):\n        \"\"\"Activate idle mode - put uWSGI in cheap mode after inactivity timeout.\n\n        :param int timeout: Inactivity timeout in seconds.\n\n        :param bool exit: Shutdown uWSGI when idle.\n\n        \"\"\"\n        self._set('idle', timeout)\n        self._set('die-on-idle', exit, cast=bool)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_reload_params(self, mercy=None, exit=None):\n        self._set('reload-mercy', mercy)\n        self.set_exit_events(reload=exit)\n\n        return self._section", "response": "Set reload related params."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a cron task to the schedule.", "response": "def add_cron_task(\n            self, command, weekday=None, month=None, day=None, hour=None, minute=None,\n            legion=None, unique=None, harakiri=None):\n        \"\"\"Adds a cron task running the given command on the given schedule.\n        http://uwsgi.readthedocs.io/en/latest/Cron.html\n\n        HINTS:\n            * Use negative values to say `every`:\n                hour=-3  stands for `every 3 hours`\n\n            * Use - (minus) to make interval:\n                minute='13-18'  stands for `from minute 13 to 18`\n\n        .. note:: We use cron2 option available since 1.9.11.\n\n        :param str|unicode command: Command to execute on schedule (with or without path).\n\n        :param int|str|unicode weekday: Day of a the week number. Defaults to `each`.\n            0 - Sunday  1 - Monday  2 - Tuesday  3 - Wednesday\n            4 - Thursday  5 - Friday  6 - Saturday\n\n        :param int|str|unicode month: Month number 1-12. Defaults to `each`.\n\n        :param int|str|unicode day: Day of the month number 1-31. Defaults to `each`.\n\n        :param int|str|unicode hour: Hour 0-23. Defaults to `each`.\n\n        :param int|str|unicode minute: Minute 0-59. Defaults to `each`.\n\n        :param str|unicode legion: Set legion (cluster) name to use this cron command against.\n            Such commands are only executed by legion lord node.\n\n        :param bool unique: Marks command as unique. Default to not unique.\n            Some commands can take a long time to finish or just hang doing their thing.\n            Sometimes this is okay, but there are also cases when running multiple instances\n            of the same command can be dangerous.\n\n        :param int harakiri: Enforce a time limit (in seconds) on executed commands.\n            If a command is taking longer it will be killed.\n\n        \"\"\"\n        rule = KeyValue(\n            locals(),\n            keys=['weekday', 'month', 'day', 'hour', 'minute', 'harakiri', 'legion', 'unique'],\n            aliases={'weekday': 'week'},\n            bool_keys=['unique'],\n        )\n\n        self._set('cron2', ('%s %s' % (rule, command)).strip(), multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nattaching a command or pid to the master process optionally managed by a pidfile.", "response": "def attach_process_classic(self, command_or_pid_path, background, control=False, for_legion=False):\n        \"\"\"Attaches a command/daemon to the master process optionally managed by a pidfile.\n\n        This will allow the uWSGI master to control/monitor/respawn this process.\n\n        .. note:: This uses old classic uWSGI means of process attaching\n            To have more control use ``.attach_process()`` method (requires  uWSGI 2.0+)\n\n        http://uwsgi-docs.readthedocs.io/en/latest/AttachingDaemons.html\n\n        :param str|unicode command_or_pid_path:\n\n        :param bool background: Must indicate whether process is in background.\n\n        :param bool control: Consider this process a control: when the daemon dies, the master exits.\n\n            .. note:: pidfile managed processed not supported.\n\n        :param bool for_legion: Legion daemons will be executed only on the legion lord node,\n            so there will always be a single daemon instance running in each legion.\n            Once the lord dies a daemon will be spawned on another node.\n\n            .. note:: uWSGI 1.9.9+ required.\n\n        \"\"\"\n        prefix = 'legion-' if for_legion else ''\n\n        if '.pid' in command_or_pid_path:\n\n            if background:\n                # Attach a command/daemon to the master process managed by a pidfile (the command must daemonize)\n                self._set(prefix + 'smart-attach-daemon', command_or_pid_path, multi=True)\n\n            else:\n                # Attach a command/daemon to the master process managed by a pidfile (the command must NOT daemonize)\n                self._set(prefix + 'smart-attach-daemon2', command_or_pid_path, multi=True)\n\n        else:\n            if background:\n                raise ConfigurationError('Background flag is only supported for pid-governed commands')\n\n            if control:\n                # todo needs check\n                self._set('attach-control-daemon', command_or_pid_path, multi=True)\n\n            else:\n                # Attach a command/daemon to the master process (the command has to remain in foreground)\n                self._set(prefix + 'attach-daemon', command_or_pid_path, multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef attach_process(\n            self, command, for_legion=False, broken_counter=None, pidfile=None, control=None, daemonize=None,\n            touch_reload=None, signal_stop=None, signal_reload=None, honour_stdin=None,\n            uid=None, gid=None, new_pid_ns=None, change_dir=None):\n        \"\"\"Attaches a command/daemon to the master process.\n\n        This will allow the uWSGI master to control/monitor/respawn this process.\n\n        http://uwsgi-docs.readthedocs.io/en/latest/AttachingDaemons.html\n\n        :param str|unicode command: The command line to execute.\n\n        :param bool for_legion: Legion daemons will be executed only on the legion lord node,\n            so there will always be a single daemon instance running in each legion.\n            Once the lord dies a daemon will be spawned on another node.\n\n        :param int broken_counter: Maximum attempts before considering a daemon \"broken\".\n\n        :param str|unicode pidfile: The pidfile path to check (enable smart mode).\n\n        :param bool control: If True, the daemon becomes a `control` one:\n            if it dies the whole uWSGI instance dies.\n\n        :param bool daemonize: Daemonize the process (enable smart2 mode).\n\n        :param list|str|unicode touch_reload: List of files to check:\n            whenever they are 'touched', the daemon is restarted\n\n        :param int signal_stop: The signal number to send to the daemon when uWSGI is stopped.\n\n        :param int signal_reload: The signal number to send to the daemon when uWSGI is reloaded.\n\n        :param bool honour_stdin: The signal number to send to the daemon when uWSGI is reloaded.\n\n        :param str|unicode|int uid: Drop privileges to the specified uid.\n\n            .. note:: Requires master running as root.\n\n        :param str|unicode|int gid: Drop privileges to the specified gid.\n\n            .. note:: Requires master running as root.\n\n        :param bool new_pid_ns: Spawn the process in a new pid namespace.\n\n            .. note:: Requires master running as root.\n\n            .. note:: Linux only.\n\n        :param str|unicode change_dir: Use chdir() to the specified directory\n            before running the command.\n\n        \"\"\"\n        rule = KeyValue(\n            locals(),\n            keys=[\n                'command', 'broken_counter', 'pidfile', 'control', 'daemonize', 'touch_reload',\n                'signal_stop', 'signal_reload', 'honour_stdin',\n                'uid', 'gid', 'new_pid_ns', 'change_dir',\n            ],\n            aliases={\n                'command': 'cmd',\n                'broken_counter': 'freq',\n                'touch_reload': 'touch',\n                'signal_stop': 'stopsignal',\n                'signal_reload': 'reloadsignal',\n                'honour_stdin': 'stdin',\n                'new_pid_ns': 'ns_pid',\n                'change_dir': 'chdir',\n            },\n            bool_keys=['control', 'daemonize', 'honour_stdin'],\n            list_keys=['touch_reload'],\n        )\n\n        prefix = 'legion-' if for_legion else ''\n\n        self._set(prefix + 'attach-daemon2', rule, multi=True)\n\n        return self._section", "response": "Attaches a command to a daemon process."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets basic parameters for ChEMERGENCY and CLEAR.", "response": "def set_basic_params(\n            self, check_interval_busy=None,\n            busy_max=None, busy_min=None,\n            idle_cycles_max=None, idle_cycles_penalty=None,\n            verbose=None):\n        \"\"\"\n        :param int check_interval_busy: Interval (sec) to check worker busyness.\n\n        :param int busy_max: Maximum busyness (percents). Every time the calculated busyness\n            is higher than this value, uWSGI will spawn new workers. Default: 50.\n\n        :param int busy_min: Minimum busyness (percents). If busyness is below this value,\n            the app is considered in an \"idle cycle\" and uWSGI will start counting them.\n            Once we reach needed number of idle cycles uWSGI will kill one worker. Default: 25.\n\n        :param int idle_cycles_max: This option tells uWSGI how many idle cycles are allowed\n            before stopping a worker.\n\n        :param int idle_cycles_penalty: Number of idle cycles to add to ``idle_cycles_max``\n            in case worker spawned too early. Default is 1.\n\n        :param bool verbose: Enables debug logs for this algo.\n\n        \"\"\"\n        self._set('cheaper-overload', check_interval_busy)\n        self._set('cheaper-busyness-max', busy_max)\n        self._set('cheaper-busyness-min', busy_min)\n        self._set('cheaper-busyness-multiplier', idle_cycles_max)\n        self._set('cheaper-busyness-penalty', idle_cycles_penalty)\n        self._set('cheaper-busyness-verbose', verbose, cast=bool)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset busyness algorithm emergency workers related params.", "response": "def set_emergency_params(\n            self, workers_step=None, idle_cycles_max=None, queue_size=None, queue_nonzero_delay=None):\n        \"\"\"Sets busyness algorithm emergency workers related params.\n\n        Emergency workers could be spawned depending upon uWSGI backlog state.\n\n        .. note:: These options are Linux only.\n\n        :param int workers_step: Number of emergency workers to spawn. Default: 1.\n\n        :param int idle_cycles_max: Idle cycles to reach before stopping an emergency worker. Default: 3.\n\n        :param int queue_size: Listen queue (backlog) max size to spawn an emergency worker. Default: 33.\n\n        :param int queue_nonzero_delay: If the request listen queue is > 0 for more than given amount of seconds\n            new emergency workers will be spawned. Default: 60.\n\n        \"\"\"\n        self._set('cheaper-busyness-backlog-step', workers_step)\n        self._set('cheaper-busyness-backlog-multiplier', idle_cycles_max)\n        self._set('cheaper-busyness-backlog-alert', queue_size)\n        self._set('cheaper-busyness-backlog-nonzero', queue_nonzero_delay)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_basic_params(\n            self, spawn_on_request=None,\n            cheaper_algo=None, workers_min=None, workers_startup=None, workers_step=None):\n        \"\"\"\n        :param bool spawn_on_request: Spawn workers only after the first request.\n\n        :param Algo cheaper_algo: The algorithm object to be used used for adaptive process spawning.\n            Default: ``spare``. See ``.algorithms``.\n\n        :param int workers_min: Minimal workers count. Enables cheaper mode (adaptive process spawning).\n\n            .. note:: Must be lower than max workers count.\n\n        :param int workers_startup: The number of workers to be started when starting the application.\n            After the app is started the algorithm can stop or start workers if needed.\n\n        :param int workers_step: Number of additional processes to spawn at a time if they are needed,\n\n        \"\"\"\n        self._set('cheap', spawn_on_request, cast=bool)\n\n        if cheaper_algo:\n            self._set('cheaper-algo', cheaper_algo.name)\n\n            if cheaper_algo.plugin:\n                self._section.set_plugins_params(plugins=cheaper_algo.plugin)\n\n            cheaper_algo._contribute_to_opts(self)\n\n        self._set('cheaper', workers_min)\n        self._set('cheaper-initial', workers_startup)\n        self._set('cheaper-step', workers_step)\n\n        return self._section", "response": "Sets basic parameters for the application."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_memory_limits(self, rss_soft=None, rss_hard=None):\n        self._set('cheaper-rss-limit-soft', rss_soft)           \n        self._set('cheaper-rss-limit-hard', rss_hard)\n\n        return self._section", "response": "Sets worker memory limits for cheapening."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn uWSGI version string or tuple.", "response": "def get_version(self, as_tuple=False):\n        \"\"\"Returns uWSGI version string or tuple.\n\n        :param bool as_tuple:\n\n        :rtype: str|tuple\n        \"\"\"\n        if as_tuple:\n            return uwsgi.version_info\n\n        return decode(uwsgi.version)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nregisters a routing rule.", "response": "def register_route(self, route_rules, label=None):\n        \"\"\"Registers a routing rule.\n\n        :param RouteRule|list[RouteRule] route_rules:\n\n        :param str|unicode label: Label to mark the given set of rules.\n            This can be used in conjunction with ``do_goto`` rule action.\n\n            * http://uwsgi.readthedocs.io/en/latest/InternalRouting.html#goto\n\n        \"\"\"\n        route_rules = listify(route_rules)\n\n        if route_rules and label:\n            self._set(route_rules[0].command_label, label, multi=True)\n\n        for route_rules in route_rules:\n            self._set(route_rules.command, route_rules.value, multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding an error page for managed 403 404 500 response.", "response": "def set_error_page(self, status, html_fpath):\n        \"\"\"Add an error page (html) for managed 403, 404, 500 response.\n\n        :param int status: HTTP status code.\n\n        :param str|unicode html_fpath: HTML page file path.\n\n        \"\"\"\n        statuses = [403, 404, 500]\n\n        status = int(status)\n\n        if status not in statuses:\n            raise ConfigurationError(\n                'Code `%s` for `routing.set_error_page()` is unsupported. Supported: %s' %\n                (status, ', '.join(map(str, statuses))))\n\n        self._set('error-page-%s' % status, html_fpath, multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_error_pages(self, codes_map=None, common_prefix=None):\n        statuses = [403, 404, 500]\n\n        if common_prefix:\n            if not codes_map:\n                codes_map = {code: '%s.html' % code for code in statuses}\n\n            for code, filename in codes_map.items():\n                codes_map[code] = os.path.join(common_prefix, filename)\n\n        for code, filepath in codes_map.items():\n            self.set_error_page(code, filepath)\n\n        return self._section", "response": "Add an error page for all HTTP status codes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_geoip_params(self, db_country=None, db_city=None):\n        self._set('geoip-country', db_country, plugin='geoip')\n        self._set('geoip-city', db_city, plugin='geoip')\n\n        return self._section", "response": "Sets GeoIP parameters.\n\n        * http://uwsgi.readthedocs.io/en/latest/GeoIP.html\n\n        :param str|unicode db_country: Country database file path.\n\n        :param str|unicode db_city: City database file path. Example: ``GeoLiteCity.dat``."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef header_collect(self, name, target_var, pull=False):\n        self._set(\n            'pull-header' if pull else 'collect-header',\n            '%s %s' % (name, target_var), multi=True)\n\n        return self._section", "response": "Store the specified response header in a request var\n       ."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nallows mapping mountpoint to a static file or file.", "response": "def register_static_map(self, mountpoint, target, retain_resource_path=False, safe_target=False):\n        \"\"\"Allows mapping mountpoint to a static directory (or file).\n\n        * http://uwsgi.readthedocs.io/en/latest/StaticFiles.html#mode-3-using-static-file-mount-points\n\n        :param str|unicode mountpoint:\n\n        :param str|unicode target:\n\n        :param bool retain_resource_path: Append the requested resource to the docroot.\n\n            Example: if ``/images`` maps to ``/var/www/img`` requested ``/images/logo.png`` will be served from:\n\n            * ``True``: ``/var/www/img/images/logo.png``\n\n            * ``False``: ``/var/www/img/logo.png``\n\n        :param bool safe_target: Skip security checks if the file is under the specified path.\n\n            Whether to consider resolved (real) target a safe one to serve from.\n\n            * http://uwsgi.readthedocs.io/en/latest/StaticFiles.html#security\n\n        \"\"\"\n        command = 'static-map'\n\n        if retain_resource_path:\n\n            command += '2'\n\n        self._set(command, '%s=%s' % (mountpoint, target), multi=True)\n\n        if safe_target:\n            self._set('static-safe', target, multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_expiration_rule(self, criterion, value, timeout, use_mod_time=False):\n        command = 'static-expires'\n        separator = ' '\n\n        if criterion != self.expiration_criteria.FILENAME:\n\n            command += '-%s' % criterion\n\n        if criterion == self.expiration_criteria.MIME_TYPE:\n\n            separator = '='\n\n        if use_mod_time:\n\n            command += '-mtime'\n\n        for value in listify(value):\n            self._set(command, '%s%s%s' % (value, separator, timeout), multi=True)\n\n        return self._section", "response": "Adds a statics expiration rule based on a criterion."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_paths_caching_params(self, timeout=None, cache_name=None):\n        self._set('static-cache-paths', timeout)\n        self._set('static-cache-paths-name', cache_name)\n\n        return self._section", "response": "Sets the static - cache - paths and static - cache - paths - name parameters for the uWSGI cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset common socket params.", "response": "def set_socket_params(\n            self, send_timeout=None, keep_alive=None, no_defer_accept=None,\n            buffer_send=None, buffer_receive=None):\n        \"\"\"Sets common socket params.\n\n        :param int send_timeout: Send (write) timeout in seconds.\n\n        :param bool keep_alive: Enable TCP KEEPALIVEs.\n\n        :param bool no_defer_accept: Disable deferred ``accept()`` on sockets\n            by default (where available) uWSGI will defer the accept() of requests until some data\n            is sent by the client (this is a security/performance measure).\n            If you want to disable this feature for some reason, specify this option.\n\n        :param int buffer_send: Set SO_SNDBUF (bytes).\n\n        :param int buffer_receive: Set SO_RCVBUF (bytes).\n\n        \"\"\"\n        self._set('so-send-timeout', send_timeout)\n        self._set('so-keepalive', keep_alive, cast=bool)\n        self._set('no-defer-accept', no_defer_accept, cast=bool)\n        self._set('socket-sndbuf', buffer_send)\n        self._set('socket-rcvbuf', buffer_receive)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the Unix - socket related params.", "response": "def set_unix_socket_params(self, abstract=None, permissions=None, owner=None, umask=None):\n        \"\"\"Sets Unix-socket related params.\n\n        :param bool abstract: Force UNIX socket into abstract mode (Linux only).\n\n        :param str permissions: UNIX sockets are filesystem objects that obey\n            UNIX permissions like any other filesystem object.\n\n            You can set the UNIX sockets' permissions with this option if your webserver\n            would otherwise have no access to the uWSGI socket. When used without a parameter,\n            the permissions will be set to 666. Otherwise the specified chmod value will be used.\n\n        :param str|unicode owner: Chown UNIX sockets.\n\n        :param str|unicode umask: Set UNIX socket umask.\n\n        \"\"\"\n        self._set('abstract-socket', abstract, cast=bool)\n        self._set('chmod-socket', permissions)\n        self._set('chown-socket', owner)\n        self._set('umask', umask)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting BSD - socket related params.", "response": "def set_bsd_socket_params(self, port_reuse=None):\n        \"\"\"Sets BSD-sockets related params.\n\n        :param bool port_reuse: Enable REUSE_PORT flag on socket to allow multiple\n            instances binding on the same address (BSD only).\n\n        \"\"\"\n        self._set('reuse-port', port_reuse, cast=bool)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering the given socket for further use.", "response": "def register_socket(self, socket):\n        \"\"\"Registers the given socket(s) for further use.\n\n        :param Socket|list[Socket] socket: Socket type object. See ``.sockets``.\n\n        \"\"\"\n        sockets = self._sockets\n\n        for socket in listify(socket):\n\n            uses_shared = isinstance(socket.address, SocketShared)\n\n            if uses_shared:\n                # Handling shared sockets involves socket index resolution.\n\n                shared_socket = socket.address  # type: SocketShared\n\n                if shared_socket not in sockets:\n                    self.register_socket(shared_socket)\n\n                socket.address = self._get_shared_socket_idx(shared_socket)\n\n            socket.address = self._section.replace_placeholders(socket.address)\n            self._set(socket.name, socket, multi=True)\n\n            socket._contribute_to_opts(self)\n\n            bound_workers = socket.bound_workers\n\n            if bound_workers:\n                self._set(\n                    'map-socket', '%s:%s' % (len(sockets), ','.join(map(str, bound_workers))),\n                    multi=True)\n\n            if not uses_shared:\n                sockets.append(socket)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nallowing setting server name identification params.", "response": "def set_sni_params(self, name, cert, key, ciphers=None, client_ca=None, wildcard=False):\n        \"\"\"Allows setting Server Name Identification (virtual hosting for SSL nodes) params.\n\n        * http://uwsgi.readthedocs.io/en/latest/SNI.html\n\n        :param str|unicode name: Node/server/host name.\n\n        :param str|unicode cert: Certificate file.\n\n        :param str|unicode key: Private key file.\n\n        :param str|unicode ciphers: Ciphers [alias] string.\n\n            Example:\n                * DEFAULT\n                * HIGH\n                * DHE, EDH\n\n            * https://www.openssl.org/docs/man1.1.0/apps/ciphers.html\n\n        :param str|unicode client_ca: Client CA file for client-based auth.\n\n            .. note: You can prepend ! (exclamation mark) to make client certificate\n                authentication mandatory.\n\n        :param bool wildcard: Allow regular expressions in ``name`` (used for wildcard certificates).\n\n        \"\"\"\n        command = 'sni'\n\n        if wildcard:\n            command += '-regexp'\n\n        args = [item for item in (cert, key, ciphers, client_ca) if item is not None]\n\n        self._set(command, '%s %s' % (name, ','.join(args)))\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nenable checking for cert key client ca file in the specified directory and create a sni ssl context on demand.", "response": "def set_sni_dir_params(self, dir, ciphers=None):\n        \"\"\"Enable checking for cert/key/client_ca file in the specified directory\n        and create a sni/ssl context on demand.\n\n        Expected filenames:\n            * <sni-name>.crt\n            * <sni-name>.key\n            * <sni-name>.ca - this file is optional\n\n        * http://uwsgi.readthedocs.io/en/latest/SNI.html#massive-sni-hosting\n\n        :param str|unicode dir:\n\n        :param str|unicode ciphers: Ciphers [alias] string.\n\n            Example:\n                * DEFAULT\n                * HIGH\n                * DHE, EDH\n\n            * https://www.openssl.org/docs/man1.1.0/apps/ciphers.html\n\n        \"\"\"\n        self._set('sni-dir', dir)\n        self._set('sni-dir-ciphers', ciphers)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nenables the shared queue of the given size.", "response": "def enable(self, size, block_size=None, store=None, store_sync_interval=None):\n        \"\"\"Enables shared queue of the given size.\n\n        :param int size: Queue size.\n\n        :param int block_size: Block size in bytes. Default: 8 KiB.\n\n        :param str|unicode store: Persist the queue into file.\n\n        :param int store_sync_interval: Store sync interval in master cycles (usually seconds).\n\n        \"\"\"\n        self._set('queue', size)\n        self._set('queue-blocksize', block_size)\n        self._set('queue-store', store)\n        self._set('queue-store-sync', store_sync_interval)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting basic parameters for the resource store.", "response": "def set_basic_params(self, count=None, thunder_lock=None, lock_engine=None):\n        \"\"\"\n        :param int count: Create the specified number of shared locks.\n\n        :param bool thunder_lock: Serialize accept() usage (if possible)\n            Could improve performance on Linux with robust pthread mutexes.\n\n            http://uwsgi.readthedocs.io/en/latest/articles/SerializingAccept.html\n\n        :param str|unicode lock_engine: Set the lock engine.\n\n            Example:\n                - ipcsem\n\n        \"\"\"\n        self._set('thunder-lock', thunder_lock, cast=bool)\n        self._set('lock-engine', lock_engine)\n        self._set('locks', count)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_ipcsem_params(self, ftok=None, persistent=None):\n        self._set('ftok', ftok)\n        self._set('persistent-ipcsem', persistent, cast=bool)\n\n        return self._section", "response": "Sets the ipcsem lock engine params."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef lock_file(self, fpath, after_setup=False, wait=False):\n        command = 'flock-wait' if wait else 'flock'\n\n        if after_setup:\n            command = '%s2' % command\n\n        self._set(command, fpath)\n\n        return self._section", "response": "Locks the specified file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_rpc(name=None):\n    def wrapper(func):\n        func_name = func.__name__\n        rpc_name = name or func_name\n\n        uwsgi.register_rpc(rpc_name, func)\n\n        _LOG.debug(\"Registering '%s' for RPC under '%s' alias ...\", func_name, rpc_name)\n\n        return func\n\n    return wrapper", "response": "Decorator. Allows registering a function for RPC."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_rpc_call(func_name, args=None, remote=None):\n    args = args or []\n    args = [encode(str(arg)) for arg in args]\n\n    if remote:\n        result = uwsgi.rpc(remote, func_name, *args)\n    else:\n        result = uwsgi.call(func_name, *args)\n\n    return decode(result)", "response": "Performs an RPC function call with the given arguments."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_emperor_command_params(\n            self, command_socket=None,\n            wait_for_command=None, wait_for_command_exclude=None):\n        \"\"\"Emperor commands related parameters.\n\n        * http://uwsgi-docs.readthedocs.io/en/latest/tutorials/EmperorSubscriptions.html\n\n        :param str|unicode command_socket: Enable the Emperor command socket.\n            It is a channel allowing external process to govern vassals.\n\n        :param bool wait_for_command: Always wait for a 'spawn' Emperor command before starting a vassal.\n\n        :param str|unicode|list[str|unicode] wait_for_command_exclude: Vassals that will ignore ``wait_for_command``.\n\n        \"\"\"\n        self._set('emperor-command-socket', command_socket)\n        self._set('emperor-wait-for-command', wait_for_command, cast=bool)\n        self._set('emperor-wait-for-command-ignore', wait_for_command_exclude, multi=True)\n\n        return self._section", "response": "Sets the Emperor command related parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the emperor - wrapper and emperor - wrapper - overrides parameters for vassals.", "response": "def set_vassals_wrapper_params(self, wrapper=None, overrides=None, fallbacks=None):\n        \"\"\"Binary wrapper for vassals parameters.\n\n        :param str|unicode wrapper: Set a binary wrapper for vassals.\n\n        :param str|unicode|list[str|unicode] overrides: Set a binary wrapper for vassals to try before the default one\n\n        :param str|unicode|list[str|unicode] fallbacks: Set a binary wrapper for vassals to try as a last resort.\n            Allows you to specify an alternative binary to execute when running a vassal\n            and the default binary_path is not found (or returns an error).\n\n        \"\"\"\n        self._set('emperor-wrapper', wrapper)\n        self._set('emperor-wrapper-override', overrides, multi=True)\n        self._set('emperor-wrapper-fallback', fallbacks, multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_throttle_params(self, level=None, level_max=None):\n        self._set('emperor-throttle', level)\n        self._set('emperor-max-throttle', level_max)\n\n        return self._section", "response": "Throttling options.\n\n        * http://uwsgi-docs.readthedocs.io/en/latest/Emperor.html#throttling\n        * http://uwsgi-docs.readthedocs.io/en/latest/Emperor.html#loyalty\n\n        :param int level: Set throttling level (in milliseconds) for bad behaving vassals. Default: 1000.\n\n        :param int level_max: Set maximum throttling level (in milliseconds)\n            for bad behaving vassals. Default: 3 minutes."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the emperor - tyrant - nofollow and emperor - tyrant - initgroups attributes.", "response": "def set_mode_tyrant_params(self, enable=None, links_no_follow=None, use_initgroups=None):\n        \"\"\"Tyrant mode (secure multi-user hosting).\n\n        In Tyrant mode the Emperor will run the vassal using the UID/GID of the vassal\n        configuration file.\n\n        * http://uwsgi-docs.readthedocs.io/en/latest/Emperor.html#tyrant-mode-secure-multi-user-hosting\n\n        :param enable: Puts the Emperor in Tyrant mode.\n\n        :param bool links_no_follow: Do not follow symlinks when checking for uid/gid in Tyrant mode.\n\n        :param bool use_initgroups: Add additional groups set via initgroups() in Tyrant mode.\n\n        \"\"\"\n        self._set('emperor-tyrant', enable, cast=bool)\n        self._set('emperor-tyrant-nofollow', links_no_follow, cast=bool)\n        self._set('emperor-tyrant-initgroups', use_initgroups, cast=bool)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the mode to Broodlord.", "response": "def set_mode_broodlord_params(\n            self, zerg_count=None,\n            vassal_overload_sos_interval=None, vassal_queue_items_sos=None):\n        \"\"\"This mode is a way for a vassal to ask for reinforcements to the Emperor.\n\n        Reinforcements are new vassals spawned on demand generally bound on the same socket.\n\n        .. warning:: If you are looking for a way to dynamically adapt the number\n            of workers of an instance, check the Cheaper subsystem - adaptive process spawning mode.\n\n            *Broodlord mode is for spawning totally new instances.*\n\n        :param int zerg_count: Maximum number of zergs to spawn.\n\n        :param int vassal_overload_sos_interval: Ask emperor for reinforcement when overloaded.\n            Accepts the number of seconds to wait between asking for a new reinforcements.\n\n        :param int vassal_queue_items_sos: Ask emperor for sos if listen queue (backlog) has more\n            items than the value specified\n\n        \"\"\"\n        self._set('emperor-broodlord', zerg_count)\n        self._set('vassal-sos', vassal_overload_sos_interval)\n        self._set('vassal-sos-backlog', vassal_queue_items_sos)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_command_as_worker(self, command, after_post_fork_hook=False):\n        self._set('worker-exec2' if after_post_fork_hook else 'worker-exec', command, multi=True)\n\n        return self._section", "response": "Run the specified command as worker."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the count of available workers by default sets it to detected number of available cores.", "response": "def set_count_auto(self, count=None):\n        \"\"\"Sets workers count.\n\n        By default sets it to detected number of available cores\n\n        :param int count:\n        \"\"\"\n        count = count or self._section.vars.CPU_CORES\n\n        self._set('workers', count)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the threads related params.", "response": "def set_thread_params(\n            self, enable=None, count=None, count_offload=None, stack_size=None, no_wait=None):\n        \"\"\"Sets threads related params.\n\n        :param bool enable: Enable threads in the embedded languages.\n            This will allow to spawn threads in your app.\n\n            .. warning:: Threads will simply *not work* if this option is not enabled.\n                There will likely be no error, just no execution of your thread code.\n\n        :param int count: Run each worker in prethreaded mode with the specified number\n            of threads per worker.\n\n            .. warning:: Do not use with ``gevent``.\n\n            .. note:: Enables threads automatically.\n\n        :param int count_offload: Set the number of threads (per-worker) to spawn\n            for offloading. Default: 0.\n\n            These threads run such tasks in a non-blocking/evented way allowing\n            for a huge amount of concurrency. Various components of the uWSGI stack\n            are offload-friendly.\n\n            .. note:: Try to set it to the number of CPU cores to take advantage of SMP.\n\n            * http://uwsgi-docs.readthedocs.io/en/latest/OffloadSubsystem.html\n\n        :param int stack_size: Set threads stacksize.\n\n        :param bool no_wait: Do not wait for threads cancellation on quit/reload.\n\n        \"\"\"\n        self._set('enable-threads', enable, cast=bool)\n        self._set('no-threads-wait', no_wait, cast=bool)\n        self._set('threads', count)\n        self._set('offload-threads', count_offload)\n\n        if count:\n            self._section.print_out('Threads per worker: %s' % count)\n\n        self._set('threads-stacksize', stack_size)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the mules related params.", "response": "def set_mules_params(\n            self, mules=None, touch_reload=None, harakiri_timeout=None, farms=None, reload_mercy=None,\n            msg_buffer=None, msg_buffer_recv=None):\n        \"\"\"Sets mules related params.\n\n        http://uwsgi.readthedocs.io/en/latest/Mules.html\n\n        Mules are worker processes living in the uWSGI stack but not reachable via socket connections,\n        that can be used as a generic subsystem to offload tasks.\n\n        :param int|list mules: Add the specified mules or number of mules.\n\n        :param str|list touch_reload: Reload mules if the specified file is modified/touched.\n\n        :param int harakiri_timeout: Set harakiri timeout for mule tasks.\n\n        :param list[MuleFarm] farms: Mule farms list.\n\n            Examples:\n                * cls_mule_farm('first', 2)\n                * cls_mule_farm('first', [4, 5])\n\n        :param int reload_mercy: Set the maximum time (in seconds) a mule can take\n            to reload/shutdown. Default: 60.\n\n        :param int msg_buffer: Set mule message buffer size (bytes) given\n            for mule message queue.\n\n        :param int msg_buffer: Set mule message recv buffer size (bytes).\n\n        \"\"\"\n        farms = farms or []\n\n        next_mule_number = 1\n        farm_mules_count = 0\n\n        for farm in farms:\n\n            if isinstance(farm.mule_numbers, int):\n                farm.mule_numbers = list(range(next_mule_number, next_mule_number + farm.mule_numbers))\n                next_mule_number = farm.mule_numbers[-1] + 1\n\n            farm_mules_count += len(farm.mule_numbers)\n\n            self._set('farm', farm, multi=True)\n\n        if mules is None and farm_mules_count:\n            mules = farm_mules_count\n\n        if isinstance(mules, int):\n            self._set('mules', mules)\n\n        elif isinstance(mules, list):\n\n            for mule in mules:\n                self._set('mule', mule, multi=True)\n\n        self._set('touch-mules-reload', touch_reload, multi=True)\n\n        self._set('mule-harakiri', harakiri_timeout)\n        self._set('mule-reload-mercy', reload_mercy)\n\n        self._set('mule-msg-size', msg_buffer)\n        self._set('mule-msg-recv-size', msg_buffer_recv)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the reload parameters for the specified worker.", "response": "def set_reload_params(\n            self, min_lifetime=None, max_lifetime=None,\n            max_requests=None, max_requests_delta=None,\n            max_addr_space=None, max_rss=None, max_uss=None, max_pss=None,\n            max_addr_space_forced=None, max_rss_forced=None, watch_interval_forced=None,\n            mercy=None):\n        \"\"\"Sets workers reload parameters.\n\n        :param int min_lifetime: A worker cannot be destroyed/reloaded unless it has been alive\n            for N seconds (default 60). This is an anti-fork-bomb measure.\n            Since 1.9\n\n        :param int max_lifetime: Reload workers after this many seconds. Disabled by default.\n            Since 1.9\n\n        :param int max_requests: Reload workers after the specified amount of managed\n            requests (avoid memory leaks).\n            When a worker reaches this number of requests it will get recycled (killed and restarted).\n            You can use this option to \"dumb fight\" memory leaks.\n\n            Also take a look at the ``reload-on-as`` and ``reload-on-rss`` options\n            as they are more useful for memory leaks.\n\n            .. warning:: The default min-worker-lifetime 60 seconds takes priority over `max-requests`.\n\n            Do not use with benchmarking as you'll get stalls\n            such as `worker respawning too fast !!! i have to sleep a bit (2 seconds)...`\n\n        :param int max_requests_delta: Add (worker_id * delta) to the max_requests value of each worker.\n\n        :param int max_addr_space: Reload a worker if its address space usage is higher\n            than the specified value in megabytes.\n\n        :param int max_rss: Reload a worker if its physical unshared memory (resident set size) is higher\n            than the specified value (in megabytes).\n\n        :param int max_uss: Reload a worker if Unique Set Size is higher\n            than the specified value in megabytes.\n\n            .. note:: Linux only.\n\n        :param int max_pss: Reload a worker if Proportional Set Size is higher\n            than the specified value in megabytes.\n\n            .. note:: Linux only.\n\n        :param int max_addr_space_forced: Force the master to reload a worker if its address space is higher\n            than specified megabytes (in megabytes).\n\n        :param int max_rss_forced: Force the master to reload a worker\n            if its resident set size memory is higher than specified in megabytes.\n\n        :param int watch_interval_forced: The memory collector [per-worker] thread memeory watch\n            interval (seconds) used for forced reloads. Default: 3.\n\n        :param int mercy: Set the maximum time (in seconds) a worker can take\n            before reload/shutdown. Default: 60.\n\n        \"\"\"\n        self._set('max-requests', max_requests)\n        self._set('max-requests-delta', max_requests_delta)\n\n        self._set('min-worker-lifetime', min_lifetime)\n        self._set('max-worker-lifetime', max_lifetime)\n\n        self._set('reload-on-as', max_addr_space)\n        self._set('reload-on-rss', max_rss)\n        self._set('reload-on-uss', max_uss)\n        self._set('reload-on-pss', max_pss)\n\n        self._set('evil-reload-on-as', max_addr_space_forced)\n        self._set('evil-reload-on-rss', max_rss_forced)\n        self._set('mem-collector-freq', watch_interval_forced)\n\n        self._set('worker-reload-mercy', mercy)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the reload - on - exception parameters.", "response": "def set_reload_on_exception_params(self, do_reload=None, etype=None, evalue=None, erepr=None):\n        \"\"\"Sets workers reload on exceptions parameters.\n\n        :param bool do_reload: Reload a worker when an exception is raised.\n\n        :param str etype: Reload a worker when a specific exception type is raised.\n\n        :param str evalue: Reload a worker when a specific exception value is raised.\n\n        :param str erepr: Reload a worker when a specific exception type+value (language-specific) is raised.\n\n        \"\"\"\n        self._set('reload-on-exception', do_reload, cast=bool)\n        self._set('reload-on-exception-type', etype)\n        self._set('reload-on-exception-value', evalue)\n        self._set('reload-on-exception-repr', erepr)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_harakiri_params(self, timeout=None, verbose=None, disable_for_arh=None):\n        self._set('harakiri', timeout)\n        self._set('harakiri-verbose', verbose, cast=bool)\n        self._set('harakiri-no-arh', disable_for_arh, cast=bool)\n\n        return self._section", "response": "Sets the worker harakiri parameters."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_zerg_server_params(self, socket, clients_socket_pool=None):\n        if clients_socket_pool:\n            self._set('zergpool', '%s:%s' % (socket, ','.join(listify(clients_socket_pool))), multi=True)\n\n        else:\n            self._set('zerg-server', socket)\n\n        return self._section", "response": "Sets the Zerg server params."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the zerg client parameters.", "response": "def set_zerg_client_params(self, server_sockets, use_fallback_socket=None):\n        \"\"\"Zerg mode. Zergs params.\n\n        :param str|unicode|list[str|unicode] server_sockets: Attaches zerg to a zerg server.\n\n        :param bool use_fallback_socket: Fallback to normal sockets if the zerg server is not available\n\n        \"\"\"\n        self._set('zerg', server_sockets, multi=True)\n\n        if use_fallback_socket is not None:\n            self._set('zerg-fallback', use_fallback_socket, cast=bool)\n\n            for socket in listify(server_sockets):\n                self._section.networking.register_socket(self._section.networking.sockets.default(socket))\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_print_text(text, color_fg=None, color_bg=None):\n    from .config import Section\n\n    color_fg = {\n\n        'black': '30',\n        'red': '31',\n        'reder': '91',\n        'green': '32',\n        'greener': '92',\n        'yellow': '33',\n        'yellower': '93',\n        'blue': '34',\n        'bluer': '94',\n        'magenta': '35',\n        'magenter': '95',\n        'cyan': '36',\n        'cyaner': '96',\n        'gray': '37',\n        'grayer': '90',\n        'white': '97',\n\n    }.get(color_fg, '39')\n\n    color_bg = {\n\n        'black': '40',\n        'red': '41',\n        'reder': '101',\n        'green': '42',\n        'greener': '102',\n        'yellow': '43',\n        'yellower': '103',\n        'blue': '44',\n        'bluer': '104',\n        'magenta': '45',\n        'magenter': '105',\n        'cyan': '46',\n        'cyaner': '106',\n        'gray': '47',\n        'grayer': '100',\n        'white': '107',\n\n    }.get(color_bg, '49')\n\n    mod = ';'.join([color_fg, color_bg])\n\n    text = '%(esc)s[%(mod)sm%(value)s%(end)s' % {\n        'esc': Section.vars.FORMAT_ESCAPE,\n        'end': Section.vars.FORMAT_END,\n        'mod': mod,\n        'value': text,\n    }\n\n    return text", "response": "Format given text using ANSI formatting escape sequences."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef iter_options(self):\n        for section in self.sections:\n            name = str(section)\n            for key, value in section._get_options():\n                yield name, key, value", "response": "Iterates over the options of the configuration sections groups options."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets memory related parameters.", "response": "def set_memory_params(self, ksm_interval=None, no_swap=None):\n        \"\"\"Set memory related parameters.\n\n        :param int ksm_interval: Kernel Samepage Merging frequency option, that can reduce memory usage.\n            Accepts a number of requests (or master process cycles) to run page scanner after.\n\n            .. note:: Linux only.\n\n            * http://uwsgi.readthedocs.io/en/latest/KSM.html\n\n        :param bool no_swap: Lock all memory pages avoiding swapping.\n\n        \"\"\"\n        self._set('ksm', ksm_interval)\n        self._set('never_swap', no_swap, cast=bool)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nchange the directory of the cache entry.", "response": "def change_dir(self, to, after_app_loading=False):\n        \"\"\"Chdir to specified directory before or after apps loading.\n\n        :param str|unicode to: Target directory.\n\n        :param bool after_app_loading:\n                *True* - after load\n                *False* - before load\n\n        \"\"\"\n        self._set('chdir2' if after_app_loading else 'chdir', to)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_owner_params(self, uid=None, gid=None, add_gids=None, set_asap=False):\n        prefix = 'immediate-' if set_asap else ''\n\n        self._set(prefix + 'uid', uid)\n        self._set(prefix + 'gid', gid)\n        self._set('add-gid', add_gids, multi=True)\n\n        # This may be wrong for subsequent method calls.\n        self.owner = [uid, gid]\n\n        return self._section", "response": "Set process owner params."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_owner(self, default=True):\n        uid, gid = self.owner\n\n        if not uid and default:\n            uid = os.getuid()\n\n        if not gid and default:\n            gid = os.getgid()\n\n        return uid, gid", "response": "Return the owner and group IDs of the current user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nallowing setting hooks for various uWSGI phases.", "response": "def set_hook(self, phase, action):\n        \"\"\"Allows setting hooks (attaching actions) for various uWSGI phases.\n\n        :param str|unicode phase: See constants in ``.phases``.\n\n        :param str|unicode|list|HookAction|list[HookAction] action:\n\n        \"\"\"\n        self._set('hook-%s' % phase, action, multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_hook_touch(self, fpath, action):\n        self._set('hook-touch', '%s %s' % (fpath, action), multi=True)\n\n        return self._section", "response": "Allows running certain action when the specified file is touched."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_hook_after_request(self, func):\n        self._set('after-request-hook', func, multi=True)\n\n        return self._section", "response": "Set the function to be run after each request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_on_exit_params(self, skip_hooks=None, skip_teardown=None):\n        self._set('skip-atexit', skip_hooks, cast=bool)\n        self._set('skip-atexit-teardown', skip_teardown, cast=bool)\n\n        return self._section", "response": "Sets the params related to process exit procedure."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun a given command on a given phase.", "response": "def run_command_on_event(self, command, phase=phases.ASAP):\n        \"\"\"Run the given command on a given phase.\n\n        :param str|unicode command:\n\n        :param str|unicode phase: See constants in ``Phases`` class.\n\n        \"\"\"\n        self._set('exec-%s' % phase, command, multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun command when the specified file is modified or touched.", "response": "def run_command_on_touch(self, command, target):\n        \"\"\"Run command when the specified file is modified/touched.\n\n        :param str|unicode command:\n\n        :param str|unicode target: File path.\n\n        \"\"\"\n        self._set('touch-exec', '%s %s' % (target, command), multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a pidfile before or after privileges drop.", "response": "def set_pid_file(self, fpath, before_priv_drop=True, safe=False):\n        \"\"\"Creates pidfile before or after privileges drop.\n\n        :param str|unicode fpath: File path.\n\n        :param bool before_priv_drop: Whether to create pidfile before privileges are dropped.\n\n            .. note:: Vacuum is made after privileges drop, so it may not be able\n                to delete PID file if it was created before dropping.\n\n        :param bool safe: The safe-pidfile works similar to pidfile\n            but performs the write a little later in the loading process.\n            This avoids overwriting the value when app loading fails,\n            with the consequent loss of a valid PID number.\n\n        \"\"\"\n        command = 'pidfile'\n\n        if not before_priv_drop:\n            command += '2'\n\n        if safe:\n            command = 'safe-' + command\n\n        self._set(command, fpath)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_naming_params(self, autonaming=None, prefix=None, suffix=None, name=None):\n        self._set('auto-procname', autonaming, cast=bool)\n        self._set('procname-prefix%s' % ('-spaced' if prefix and prefix.endswith(' ') else ''), prefix)\n        self._set('procname-append', suffix)\n        self._set('procname', name)\n\n        return self._section", "response": "Sets the processes naming parameters."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef errorprint():\n    try:\n        yield\n\n    except ConfigurationError as e:\n        click.secho('%s' % e, err=True, fg='red')\n        sys.exit(1)", "response": "Print out descriptions from ConfigurationError."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(conf, only):\n    with errorprint():\n        config = ConfModule(conf)\n        spawned = config.spawn_uwsgi(only)\n\n        for alias, pid in spawned:\n            click.secho(\"Spawned uWSGI for configuration aliased '%s'. PID %s\" % (alias, pid), fg='green')", "response": "Runs uWSGI passing to it using the default or another uwsgiconf configuration module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncompiling classic uWSGI configuration file using the default or given uwsgiconf configuration module.", "response": "def compile(conf):\n    \"\"\"Compiles classic uWSGI configuration file using the default\n    or given `uwsgiconf` configuration module.\n\n    \"\"\"\n    with errorprint():\n        config = ConfModule(conf)\n        for conf in config.configurations:\n            conf.format(do_print=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sysinit(systype, conf, project):\n\n    click.secho(get_config(\n        systype,\n        conf=ConfModule(conf).configurations[0],\n        conf_path=conf,\n        project_name=project,\n    ))", "response": "Outputs configuration for system initialization subsystem."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef probe_plugins():\n    plugins = UwsgiRunner().get_plugins()\n\n    for plugin in sorted(plugins.generic):\n        click.secho(plugin)\n\n    click.secho('')\n\n    for plugin in sorted(plugins.request):\n        click.secho(plugin)", "response": "Runs uWSGI to determine what plugins are available."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add(self, work_dir, external=False):\n        command = 'spooler'\n\n        if external:\n            command += '-external'\n\n        self._set(command, self._section.replace_placeholders(work_dir), multi=True)\n\n        return self._section", "response": "Run a spooler on the specified directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconfigure broodlord mode and returns emperor and zerg sections.", "response": "def configure(self):\n        \"\"\"Configures broodlord mode and returns emperor and zerg sections.\n\n        :rtype: tuple\n        \"\"\"\n        section_emperor = self.section_emperor\n        section_zerg = self.section_zerg\n\n        socket = self.socket\n\n        section_emperor.workers.set_zerg_server_params(socket=socket)\n        section_emperor.empire.set_emperor_params(vassals_home=self.vassals_home)\n        section_emperor.empire.set_mode_broodlord_params(**self.broodlord_params)\n\n        section_zerg.name = 'zerg'\n        section_zerg.workers.set_zerg_client_params(server_sockets=socket)\n\n        if self.die_on_idle:\n            section_zerg.master_process.set_idle_params(timeout=30, exit=True)\n\n        return section_emperor, section_zerg"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_log_format_default(self):\n        vars = self.logging.vars\n\n        format_default = (\n            '[pid: %s|app: %s|req: %s/%s] %s (%s) {%s vars in %s bytes} [%s] %s %s => '\n            'generated %s bytes in %s %s%s(%s %s) %s headers in %s bytes (%s switches on core %s)' % (\n\n                vars.WORKER_PID,\n                '-',  # app id\n                '-',  # app req count\n                '-',  # worker req count\n                vars.REQ_REMOTE_ADDR,\n                vars.REQ_REMOTE_USER,\n                vars.REQ_COUNT_VARS_CGI,\n                vars.SIZE_PACKET_UWSGI,\n                vars.REQ_START_CTIME,\n                vars.REQ_METHOD,\n                vars.REQ_URI,\n                vars.RESP_SIZE_BODY,\n                vars.RESP_TIME_MS,  # or RESP_TIME_US,\n                '-',  # tsize\n                '-',  # via sendfile/route/offload\n                vars.REQ_SERVER_PROTOCOL,\n                vars.RESP_STATUS,\n                vars.RESP_COUNT_HEADERS,\n                vars.RESP_SIZE_HEADERS,\n                vars.ASYNC_SWITCHES,\n                vars.CORE,\n        ))\n\n        return format_default", "response": "Returns default log message format."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef configure_owner(self, owner='www-data'):\n        if owner is not None:\n            self.main_process.set_owner_params(uid=owner, gid=owner)\n\n        return self", "response": "Shortcut to set process owner data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_basic_params(self, msg_size=None, cheap=None, anti_loop_timeout=None):\n        self._set('alarm-msg-size', msg_size)\n        self._set('alarm-cheap', cheap, cast=bool)\n        self._set('alarm-freq', anti_loop_timeout)\n\n        return self._section", "response": "Set basic alarm parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nregisters (create) an alarm. :param AlarmType|list[AlarmType] alarm: Alarm.", "response": "def register_alarm(self, alarm):\n        \"\"\"Register (create) an alarm.\n\n        :param AlarmType|list[AlarmType] alarm: Alarm.\n\n        \"\"\"\n        for alarm in listify(alarm):\n            if alarm not in self._alarms:\n                self._set('alarm', alarm, multi=True)\n                self._alarms.append(alarm)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef alarm_on_log(self, alarm, matcher, skip=False):\n        self.register_alarm(alarm)\n\n        value = '%s %s' % (\n            ','.join(map(attrgetter('alias'), listify(alarm))),\n            matcher)\n\n        self._set('not-alarm-log' if skip else 'alarm-log', value)\n\n        return self._section", "response": "Raise or skip the specified alarm when a log line matches the specified regexp."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef alarm_on_fd_ready(self, alarm, fd, message, byte_count=None):\n        self.register_alarm(alarm)\n\n        value = fd\n\n        if byte_count:\n            value += ':%s' % byte_count\n\n        value += ' %s' % message\n\n        for alarm in listify(alarm):\n            self._set('alarm-fd', '%s %s' % (alarm.alias, value), multi=True)\n\n        return self._section", "response": "Triggers the alarm when the specified file descriptor is ready for read."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef alarm_on_segfault(self, alarm):\n        self.register_alarm(alarm)\n\n        for alarm in listify(alarm):\n            self._set('alarm-segfault', alarm.alias, multi=True)\n\n        return self._section", "response": "Raise the specified alarm when segmentation fault handler is executed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_config(systype, conf, conf_path, runner=None, project_name=None):\n    runner = runner or ('%s run' % Finder.uwsgiconf())\n    conf_path = abspath(conf_path)\n\n    if isinstance(conf, Configuration):\n        conf = conf.sections[0]  # todo Maybe something more intelligent.\n\n    tpl = dedent(TEMPLATES.get(systype)(conf=conf))\n\n    formatted = tpl.strip().format(\n        project=project_name or conf.project_name or basename(dirname(conf_path)),\n        command='%s %s' % (runner, conf_path),\n    )\n\n    return formatted", "response": "Returns the contents of a configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef app_2(env, start_response):\n\n    import random\n\n    start_response('200 OK', [('Content-Type','text/html')])\n\n    data = [\n        '<h1>uwsgiconf demo: one file second app</h1>',\n\n        '<div>Some random number for you: %s</div>' % random.randint(1, 99999),\n    ]\n\n    return encode(data)", "response": "This is another simple WSGI application that will be served by uWSGI."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef configure():\n    import os\n    from uwsgiconf.presets.nice import PythonSection\n\n    FILE = os.path.abspath(__file__)\n    port = 8000\n\n    configurations = []\n\n    for idx in range(2):\n\n        alias = 'app_%s' % (idx + 1)\n\n        section = PythonSection(\n            # Automatically reload uWSGI if this file is changed.\n            touch_reload=FILE,\n\n            # To differentiate easily.\n            process_prefix=alias,\n\n            # Serve WSGI application (see above) from this very file.\n            wsgi_module=FILE,\n\n            # Custom WSGI callable for second app.\n            wsgi_callable=alias,\n\n            # One is just enough, no use in worker on every core\n            # for this demo.\n            workers=1,\n\n        ).networking.register_socket(\n            PythonSection.networking.sockets.http('127.0.0.1:%s' % port)\n        )\n\n        port += 1\n\n        configurations.append(\n            # We give alias for configuration to prevent clashes.\n            section.as_configuration(alias=alias))\n\n    return configurations", "response": "Configure uWSGI.\n\n    This returns several configuration objects, which will be used\n    to spawn several uWSGI processes.\n\n    Applications are on 127.0.0.1 on ports starting from 8000."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef headers_raw_to_dict(headers_raw):\n\n    if headers_raw is None:\n        return None\n    headers = headers_raw.splitlines()\n    headers_tuples = [header.split(b':', 1) for header in headers]\n\n    result_dict = {}\n    for header_item in headers_tuples:\n        if not len(header_item) == 2:\n            continue\n\n        item_key = header_item[0].strip()\n        item_value = header_item[1].strip()\n        result_dict[item_key] = item_value\n\n    return result_dict", "response": "r Convert raw headers to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlog the current state of the entry into the specified target.", "response": "def log_into(self, target, before_priv_drop=True):\n        \"\"\"Simple file or UDP logging.\n\n        .. note:: This doesn't require any Logger plugin and can be used\n            if no log routing is required.\n\n        :param str|unicode target: Filepath or UDP address.\n\n        :param bool before_priv_drop: Whether to log data before or after privileges drop.\n\n        \"\"\"\n        command = 'logto'\n\n        if not before_priv_drop:\n            command += '2'\n\n        self._set(command, target)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_file_params(\n            self, reopen_on_reload=None, trucate_on_statup=None, max_size=None, rotation_fname=None,\n            touch_reopen=None, touch_rotate=None, owner=None, mode=None):\n        \"\"\"Set various parameters related to file logging.\n\n        :param bool reopen_on_reload: Reopen log after reload.\n\n        :param bool trucate_on_statup: Truncate log on startup.\n\n        :param int max_size: Set maximum logfile size in bytes after which log should be rotated.\n\n        :param str|unicode rotation_fname: Set log file name after rotation.\n\n        :param str|unicode|list touch_reopen: Trigger log reopen if the specified file\n            is modified/touched.\n\n            .. note:: This can be set to a file touched by ``postrotate`` script of ``logrotate``\n                to implement rotation.\n\n        :param str|unicode|list touch_rotate: Trigger log rotation if the specified file\n            is modified/touched.\n\n        :param str|unicode owner: Set owner chown() for logs.\n        \n        :param str|unicode mode: Set mode chmod() for logs.\n\n        \"\"\"\n        self._set('log-reopen', reopen_on_reload, cast=bool)\n        self._set('log-truncate', trucate_on_statup, cast=bool)\n        self._set('log-maxsize', max_size)\n        self._set('log-backupname', rotation_fname)\n\n        self._set('touch-logreopen', touch_reopen, multi=True)\n        self._set('touch-logrotate', touch_rotate, multi=True)\n\n        self._set('logfile-chown', owner)\n        self._set('logfile-chmod', mode)\n\n        return self._section", "response": "Set various parameters related to file logging."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting various log data filters.", "response": "def set_filters(self, include=None, exclude=None, write_errors=None, write_errors_tolerance=None, sigpipe=None):\n        \"\"\"Set various log data filters.\n\n        :param str|unicode|list include: Show only log lines matching the specified regexp.\n\n            .. note:: Requires enabled PCRE support.\n\n        :param str|unicode|list exclude: Do not show log lines matching the specified regexp.\n\n            .. note:: Requires enabled PCRE support.\n\n        :param bool write_errors: Log (annoying) write()/writev() errors. Default: ``True``.\n\n            .. note:: If both this and ``sigpipe`` set to ``False``, it's the same\n               as setting ``write-errors-exception-only`` uWSGI option.\n\n        :param int write_errors_tolerance: Set the maximum number of allowed write errors before exception\n            is raised. Default: no tolerance.\n\n            .. note:: Available for Python, Perl, PHP.\n\n        :param bool sigpipe: Log (annoying) SIGPIPE. Default: ``True``.\n\n            .. note:: If both this and ``write_errors`` set to ``False``, it's the same\n               as setting ``write-errors-exception-only`` uWSGI option.\n\n        \"\"\"\n        if write_errors is not None:\n            self._set('ignore-write-errors', not write_errors, cast=bool)\n\n        if sigpipe is not None:\n            self._set('ignore-sigpipe', not sigpipe, cast=bool)\n\n        self._set('write-errors-tolerance', write_errors_tolerance)\n\n        for line in listify(include):\n            self._set('log-filter', line, multi=True)\n\n        for line in listify(exclude):\n            self._set('log-drain', line, multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_requests_filters(\n            self, slower=None, bigger=None, status_4xx=None, status_5xx=None,\n            no_body=None, sendfile=None, io_errors=None):\n        \"\"\"Set various log data filters.\n\n        :param int slower: Log requests slower than the specified number of milliseconds.\n\n        :param int bigger: Log requests bigger than the specified size in bytes.\n\n        :param status_4xx: Log requests with a 4xx response.\n\n        :param status_5xx: Log requests with a 5xx response.\n\n        :param bool no_body: Log responses without body.\n\n        :param bool sendfile: Log sendfile requests.\n\n        :param bool io_errors: Log requests with io errors.\n\n        \"\"\"\n        self._set('log-slow', slower)\n        self._set('log-big', bigger)\n        self._set('log-4xx', status_4xx, cast=bool)\n        self._set('log-5xx', status_5xx, cast=bool)\n        self._set('log-zero', no_body, cast=bool)\n        self._set('log-sendfile', sendfile, cast=bool)\n        self._set('log-ioerror', io_errors, cast=bool)\n\n        return self._section", "response": "Set various log data filters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting logging params for delegating logging to master process.", "response": "def set_master_logging_params(\n            self, enable=None, dedicate_thread=None, buffer=None,\n            sock_stream=None, sock_stream_requests_only=None):\n        \"\"\"Sets logging params for delegating logging to master process.\n\n        :param bool enable: Delegate logging to master process.\n            Delegate the write of the logs to the master process\n            (this will put all of the logging I/O to a single process).\n            Useful for system with advanced I/O schedulers/elevators.\n\n        :param bool dedicate_thread: Delegate log writing to a thread.\n\n            As error situations could cause the master to block while writing\n            a log line to a remote server, it may be a good idea to use this option and delegate\n            writes to a secondary thread.\n\n        :param int buffer: Set the buffer size for the master logger in bytes.\n            Bigger log messages will be truncated.\n\n        :param bool|tuple sock_stream: Create the master logpipe as SOCK_STREAM.\n\n        :param bool|tuple sock_stream_requests_only: Create the master requests logpipe as SOCK_STREAM.\n\n        \"\"\"\n        self._set('log-master', enable, cast=bool)\n        self._set('threaded-logger', dedicate_thread, cast=bool)\n        self._set('log-master-bufsize', buffer)\n\n        self._set('log-master-stream', sock_stream, cast=bool)\n\n        if sock_stream_requests_only:\n            self._set('log-master-req-stream', sock_stream_requests_only, cast=bool)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset or add a common logger or a request requests only.", "response": "def add_logger(self, logger, requests_only=False, for_single_worker=False):\n        \"\"\"Set/add a common logger or a request requests only.\n\n        :param str|unicode|list|Logger|list[Logger] logger:\n\n        :param bool requests_only: Logger used only for requests information messages.\n\n        :param bool for_single_worker: Logger to be used in single-worker setup.\n\n\n        \"\"\"\n        if for_single_worker:\n            command = 'worker-logger-req' if requests_only else 'worker-logger'\n        else:\n            command = 'req-logger' if requests_only else 'logger'\n\n        for logger in listify(logger):\n            self._set(command, logger, multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlogging to the specified named logger if regexp applied on log item matches.", "response": "def add_logger_route(self, logger, matcher, requests_only=False):\n        \"\"\"Log to the specified named logger if regexp applied on log item matches.\n\n        :param str|unicode|list|Logger|list[Logger] logger: Logger to associate route with.\n\n        :param str|unicode matcher: Regular expression to apply to log item.\n\n        :param bool requests_only: Matching should be used only for requests information messages.\n\n        \"\"\"\n        command = 'log-req-route' if requests_only else 'log-route'\n\n        for logger in listify(logger):\n            self._set(command, '%s %s' % (logger, matcher), multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_logger_encoder(self, encoder, logger=None, requests_only=False, for_single_worker=False):\n        if for_single_worker:\n            command = 'worker-log-req-encoder' if requests_only else 'worker-log-encoder'\n        else:\n            command = 'log-req-encoder' if requests_only else 'log-encoder'\n\n        for encoder in listify(encoder):\n\n            value = '%s' % encoder\n\n            if logger:\n                if isinstance(logger, Logger):\n                    logger = logger.alias\n\n                value += ':%s' % logger\n\n            self._set(command, value, multi=True)\n\n        return self._section", "response": "Add an item to the log encoder or request encoder chain."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the compiler type from distutils.", "response": "def _compiler_type():\r\n    \"\"\"\r\n    Gets the compiler type from distutils. On Windows with MSVC it will be\r\n    \"msvc\". On macOS and linux it is \"unix\".\r\n\r\n    Borrowed from https://github.com/pyca/cryptography/blob\\\r\n        /05b34433fccdc2fec0bb014c3668068169d769fd/src/_cffi_src/utils.py#L78\r\n    \"\"\"\r\n    dist = distutils.dist.Distribution()\r\n    dist.parse_config_files()\r\n    cmd = dist.get_command_obj('build')\r\n    cmd.ensure_finalized()\r\n    compiler = distutils.ccompiler.new_compiler(compiler=cmd.compiler)\r\n    return compiler.compiler_type"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_metrics_params(self, enable=None, store_dir=None, restore=None, no_cores=None):\n        self._set('enable-metrics', enable, cast=bool)\n        self._set('metrics-dir', self._section.replace_placeholders(store_dir))\n        self._set('metrics-dir-restore', restore, cast=bool)\n        self._set('metrics-no-cores', no_cores, cast=bool)\n\n        return self._section", "response": "Sets basic Metrics subsystem params."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the metric threshold parameter.", "response": "def set_metrics_threshold(self, name, value, check_interval=None, reset_to=None, alarm=None, alarm_message=None):\n        \"\"\"Sets metric threshold parameters.\n\n        :param str|unicode name: Metric name.\n\n        :param int value: Threshold value.\n\n        :param int reset_to: Reset value to when threshold is reached.\n\n        :param int check_interval: Threshold check interval in seconds.\n\n        :param str|unicode|AlarmType alarm: Alarm to trigger when threshold is reached.\n\n        :param str|unicode alarm_message: Message to pass to alarm. If not set metrics name is passed.\n\n        \"\"\"\n        if alarm is not None and isinstance(alarm, AlarmType):\n            self._section.alarms.register_alarm(alarm)\n            alarm = alarm.alias\n\n        value = KeyValue(\n            locals(),\n            aliases={\n                'name': 'key',\n                'reset_to': 'reset',\n                'check_interval': 'rate',\n                'alarm_message': 'msg',\n            },\n        )\n\n        self._set('metric-threshold', value, multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_stats_params(\n            self, address=None, enable_http=None,\n            minify=None, no_cores=None, no_metrics=None, push_interval=None):\n        \"\"\"Enables stats server on the specified address.\n\n        * http://uwsgi.readthedocs.io/en/latest/StatsServer.html\n\n        :param str|unicode address: Address/socket to make stats available on.\n\n            Examples:\n                * 127.0.0.1:1717\n                * /tmp/statsock\n                * :5050\n\n        :param bool enable_http: Server stats over HTTP.\n            Prefixes stats server json output with http headers.\n\n        :param bool minify: Minify statistics json output.\n\n        :param bool no_cores: Disable generation of cores-related stats.\n\n        :param bool no_metrics: Do not include metrics in stats output.\n\n        :param int push_interval: Set the default frequency of stats pushers in seconds/\n\n        \"\"\"\n        self._set('stats-server', address)\n        self._set('stats-http', enable_http, cast=bool)\n        self._set('stats-minified', minify, cast=bool)\n        self._set('stats-no-cores', no_cores, cast=bool)\n        self._set('stats-no-metrics', no_metrics, cast=bool)\n        self._set('stats-pusher-default-freq', push_interval)\n\n        return self._section", "response": "Enables stats server on the specified address."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a pusher to be used for pushing statistics to various remotes / locals.", "response": "def register_stats_pusher(self, pusher):\n        \"\"\"Registers a pusher to be used for pushing statistics to various remotes/locals.\n\n        :param Pusher|list[Pusher] pusher:\n\n        \"\"\"\n        for pusher in listify(pusher):\n            self._set('stats-push', pusher, multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef enable_snmp(self, address, community_string):\n        self._set('snmp', address)\n        self._set('snmp-community', community_string)\n\n        return self._section", "response": "Enables SNMP.\n\n        uWSGI server embeds a tiny SNMP server that you can use to integrate\n        your web apps with your monitoring infrastructure.\n\n        * http://uwsgi.readthedocs.io/en/latest/SNMP.html\n\n        .. note:: SNMP server is started in the master process after dropping the privileges.\n            If you want it to listen on a privileged port, you can either use Capabilities on Linux,\n            or use the ``as-root`` option to run the master process as root.\n\n        :param str|unicode address: UDP address to bind to.\n\n            Examples:\n\n                * 192.168.1.1:2222\n\n        :param str|unicode community_string: SNMP instance identifier to address it."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmounts application under mountpoint.", "response": "def mount(self, mountpoint, app, into_worker=False):\n        \"\"\"Load application under mountpoint.\n\n        Example:\n            * .mount('', 'app0.py') -- Root URL part\n            * .mount('/app1', 'app1.py') -- URL part\n            * .mount('/pinax/here', '/var/www/pinax/deploy/pinax.wsgi')\n            * .mount('the_app3', 'app3.py')  -- Variable value: application alias (can be set by ``UWSGI_APPID``)\n            * .mount('example.com', 'app2.py')  -- Variable value: Hostname (variable set in nginx)\n\n        * http://uwsgi-docs.readthedocs.io/en/latest/Nginx.html#hosting-multiple-apps-in-the-same-process-aka-managing-script-name-and-path-info\n\n        :param str|unicode mountpoint: URL part, or variable value.\n\n            .. note:: In case of URL part you may also want to set ``manage_script_name`` basic param to ``True``.\n\n            .. warning:: In case of URL part a trailing slash may case problems in some cases\n                (e.g. with Django based projects).\n\n        :param str|unicode app: App module/file.\n\n        :param bool into_worker: Load application under mountpoint\n            in the specified worker or after workers spawn.\n\n        \"\"\"\n        # todo check worker mount -- uwsgi_init_worker_mount_app() expects worker://\n        self._set('worker-mount' if into_worker else 'mount', '%s=%s' % (mountpoint, app), multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef switch_into_lazy_mode(self, affect_master=None):\n        self._set('lazy' if affect_master else 'lazy-apps', True, cast=bool)\n\n        return self._section", "response": "Switches uWSGI to lazy mode."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_basic_params(\n            self, workers=None, zerg_server=None, fallback_node=None, concurrent_events=None,\n            cheap_mode=None, stats_server=None, quiet=None, buffer_size=None,\n            keepalive=None, resubscribe_addresses=None):\n        \"\"\"\n        :param int workers: Number of worker processes to spawn.\n\n        :param str|unicode zerg_server: Attach the router to a zerg server.\n\n        :param str|unicode fallback_node: Fallback to the specified node in case of error.\n\n        :param int concurrent_events: Set the maximum number of concurrent events router can manage.\n\n            Default: system dependent.\n\n        :param bool cheap_mode: Enables cheap mode. When the router is in cheap mode,\n            it will not respond to requests until a node is available.\n            This means that when there are no nodes subscribed, only your local app (if any) will respond.\n            When all of the nodes go down, the router will return in cheap mode.\n\n        :param str|unicode stats_server: Router stats server address to run at.\n\n        :param bool quiet: Do not report failed connections to instances.\n\n        :param int buffer_size: Set internal buffer size in bytes. Default: page size.\n\n        :param int keepalive: Allows holding the connection open even if the request has a body.\n\n            * http://uwsgi.readthedocs.io/en/latest/HTTP.html#http-keep-alive\n\n            .. note:: See http11 socket type for an alternative.\n\n        :param str|unicode|list[str|unicode] resubscribe_addresses: Forward subscriptions\n            to the specified subscription server.\n\n\n        \"\"\"\n        super(RouterHttp, self).set_basic_params(**filter_locals(locals(), drop=[\n            'keepalive',\n            'resubscribe_addresses',\n        ]))\n\n        self._set_aliased('keepalive', keepalive)\n        self._set_aliased('resubscribe', resubscribe_addresses, multi=True)\n\n        return self", "response": "Sets basic HTTP parameters for the router."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_connections_params(\n            self, harakiri=None, timeout_socket=None, retry_delay=None, timeout_headers=None, timeout_backend=None):\n        \"\"\"Sets connection-related parameters.\n\n        :param int harakiri: Set gateway harakiri timeout (seconds).\n\n        :param int timeout_socket: Node socket timeout (seconds).\n            Used to set the SPDY timeout. This is the maximum amount of inactivity after\n            the SPDY connection is closed.\n\n            Default: 60.\n\n        :param int retry_delay: Retry connections to dead static nodes after the specified\n            amount of seconds. Default: 30.\n\n        :param int timeout_headers: Defines the timeout (seconds) while waiting for http headers.\n\n            Default: `socket_timeout`.\n\n        :param int timeout_backend: Defines the timeout (seconds) when connecting to backend instances.\n\n            Default: `socket_timeout`.\n\n        \"\"\"\n\n        super(RouterHttp, self).set_connections_params(\n            **filter_locals(locals(), ['timeout_headers', 'timeout_backend']))\n\n        self._set_aliased('headers-timeout', timeout_headers)\n        self._set_aliased('connect-timeout', timeout_backend)\n\n        return self", "response": "Sets connection - related parameters."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_manage_params(\n            self, chunked_input=None, chunked_output=None, gzip=None, websockets=None, source_method=None,\n            rtsp=None, proxy_protocol=None):\n        \"\"\"Allows enabling various automatic management mechanics.\n\n        * http://uwsgi.readthedocs.io/en/latest/Changelog-1.9.html#http-router-keepalive-auto-chunking-auto-gzip-and-transparent-websockets\n\n        :param bool chunked_input: Automatically detect chunked input requests and put the session in raw mode.\n\n        :param bool chunked_output: Automatically transform output to chunked encoding\n            during HTTP 1.1 keepalive (if needed).\n\n        :param bool gzip: Automatically gzip content if uWSGI-Encoding header is set to gzip,\n            but content size (Content-Length/Transfer-Encoding) and Content-Encoding are not specified.\n\n        :param bool websockets: Automatically detect websockets connections and put the session in raw mode.\n\n        :param bool source_method: Automatically put the session in raw mode for `SOURCE` HTTP method.\n\n            * http://uwsgi.readthedocs.io/en/latest/Changelog-2.0.5.html#icecast2-protocol-helpers\n\n        :param bool rtsp: Allow the HTTP router to detect RTSP and chunked requests automatically.\n\n        :param bool proxy_protocol: Allows the HTTP router to manage PROXY1 protocol requests,\n            such as those made by Haproxy or Amazon Elastic Load Balancer (ELB).\n\n        \"\"\"\n        self._set_aliased('chunked-input', chunked_input, cast=bool)\n        self._set_aliased('auto-chunked', chunked_output, cast=bool)\n        self._set_aliased('auto-gzip', gzip, cast=bool)\n        self._set_aliased('websockets', websockets, cast=bool)\n        self._set_aliased('manage-source', source_method, cast=bool)\n        self._set_aliased('manage-rtsp', rtsp, cast=bool)\n        self._set_aliased('enable-proxy-protocol', proxy_protocol, cast=bool)\n\n        return self", "response": "Allows enabling automatic management mechanics."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_owner_params(self, uid=None, gid=None):\n        self._set_aliased('uid', uid)\n        self._set_aliased('gid', gid)\n\n        return self", "response": "Drop http router privileges to specified user and group."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_connections_params(self, harakiri=None, timeout_socket=None, retry_delay=None, retry_max=None):\n        super(RouterSsl, self).set_connections_params(**filter_locals(locals(), ['retry_max']))\n\n        self._set_aliased('max-retries', retry_max)\n\n        return self", "response": "Sets connection - related parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_basic_params(\n            self, workers=None, zerg_server=None, fallback_node=None, concurrent_events=None,\n            cheap_mode=None, stats_server=None, quiet=None, buffer_size=None,\n            fallback_nokey=None, subscription_key=None, emperor_command_socket=None):\n        \"\"\"\n        :param int workers: Number of worker processes to spawn.\n\n        :param str|unicode zerg_server: Attach the router to a zerg server.\n\n        :param str|unicode fallback_node: Fallback to the specified node in case of error.\n\n        :param int concurrent_events: Set the maximum number of concurrent events router can manage.\n\n            Default: system dependent.\n\n        :param bool cheap_mode: Enables cheap mode. When the router is in cheap mode,\n            it will not respond to requests until a node is available.\n            This means that when there are no nodes subscribed, only your local app (if any) will respond.\n            When all of the nodes go down, the router will return in cheap mode.\n\n        :param str|unicode stats_server: Router stats server address to run at.\n\n        :param bool quiet: Do not report failed connections to instances.\n\n        :param int buffer_size: Set internal buffer size in bytes. Default: page size.\n\n        :param bool fallback_nokey: Move to fallback node even if a subscription key is not found.\n\n        :param str|unicode subscription_key: Skip uwsgi parsing and directly set a key.\n\n        :param str|unicode emperor_command_socket: Set the emperor command socket that will receive spawn commands.\n\n            See `.empire.set_emperor_command_params()`.\n\n        \"\"\"\n        super(RouterFast, self).set_basic_params(**filter_locals(locals(), [\n            'fallback_nokey',\n            'subscription_key',\n            'emperor_command_socket',\n        ]))\n\n        self._set_aliased('fallback-on-no-key', fallback_nokey, cast=bool)\n        self._set_aliased('force-key', subscription_key)\n        self._set_aliased('emperor-socket', emperor_command_socket)\n\n        return self", "response": "Set basic parameters for router."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_resubscription_params(self, addresses=None, bind_to=None):\n        self._set_aliased('resubscribe', addresses, multi=True)\n        self._set_aliased('resubscribe-bind', bind_to)\n\n        return self", "response": "Set the parameters for the subscription server to be forwarded to."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_connections_params(self, harakiri=None, timeout_socket=None, retry_delay=None, retry_max=None, defer=None):\n        super(RouterFast, self).set_connections_params(**filter_locals(locals(), ['retry_max', 'defer']))\n\n        self._set_aliased('max-retries', retry_max)\n        self._set_aliased('defer-connect-timeout', defer)\n\n        return self", "response": "Sets connection - related parameters."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the post - buffering params for the current HTTP request.", "response": "def set_postbuffering_params(self, size=None, store_dir=None):\n        \"\"\"Sets buffering params.\n\n        Web-proxies like nginx are \"buffered\", so they wait til the whole request (and its body)\n        has been read, and then it sends it to the backends.\n\n        :param int size: The size (in bytes) of the request body after which the body will\n            be stored to disk (as a temporary file) instead of memory.\n\n        :param str|unicode store_dir: Put buffered files to the specified directory. Default: TMPDIR, /tmp/\n\n        \"\"\"\n        self._set_aliased('post-buffering', size)\n        self._set_aliased('post-buffering-dir', store_dir)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset connection - related parameters.", "response": "def set_connections_params(\n            self, harakiri=None, timeout_socket=None, retry_delay=None, retry_max=None, use_xclient=None):\n        \"\"\"Sets connection-related parameters.\n\n        :param int harakiri:  Set gateway harakiri timeout (seconds).\n\n        :param int timeout_socket: Node socket timeout (seconds). Default: 60.\n\n        :param int retry_delay: Retry connections to dead static nodes after the specified\n            amount of seconds. Default: 30.\n\n        :param int retry_max: Maximum number of retries/fallbacks to other nodes. Default: 3.\n\n        :param bool use_xclient: Use the xclient protocol to pass the client address.\n\n        \"\"\"\n        super(RouterRaw, self).set_connections_params(**filter_locals(locals(), ['retry_max', 'use_xclient']))\n\n        self._set_aliased('max-retries', retry_max)\n        self._set_aliased('xclient', use_xclient)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_connections_params(self, harakiri=None, timeout_socket=None):\n        self._set_aliased('harakiri', harakiri)\n        self._set_aliased('timeout', timeout_socket)\n\n        return self", "response": "Sets connection - related parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets pty window params.", "response": "def set_window_params(self, cols=None, rows=None):\n        \"\"\"Sets pty window params.\n\n        :param int cols:\n        :param int rows:\n\n        \"\"\"\n        self._set_aliased('cols', cols)\n        self._set_aliased('rows', rows)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_basic_params(self, use_credentials=None, stats_server=None):\n        self._set_aliased('use-credentials', use_credentials)\n        self._set_aliased('router-stats', stats_server)\n\n        return self", "response": "Set basic parameters for the current session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_route(self, src, dst, gateway):\n        self._set_aliased('router-route', ' '.join((src, dst, gateway)), multi=True)\n\n        return self", "response": "Adds a routing rule to the tuntap router."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a tuntap device rule.", "response": "def device_add_rule(self, direction, action, src, dst, target=None):\n        \"\"\"Adds a tuntap device rule.\n\n        To be used in a vassal.\n\n        :param str|unicode direction: Direction:\n\n            * in\n            * out.\n\n        :param str|unicode action: Action:\n\n            * allow\n            * deny\n            * route\n            * gateway.\n\n        :param str|unicode src: Source/mask.\n\n        :param str|unicode dst: Destination/mask.\n\n        :param str|unicode target: Depends on action.\n\n            * Route / Gateway: Accept addr:port\n\n        \"\"\"\n        value = [direction, src, dst, action]\n\n        if target:\n            value.append(target)\n\n        self._set_aliased('device-rule', ' '.join(value), multi=True)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_firewall_rule(self, direction, action, src=None, dst=None):\n        value = [action]\n\n        if src:\n            value.extend((src, dst))\n\n        self._set_aliased('router-firewall-%s' % direction.lower(), ' '.join(value), multi=True)\n\n        return self", "response": "Adds a firewall rule to the router."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nallowing configuring uWSGI using a function which returns a list of Configuration objects.", "response": "def configure_uwsgi(configurator_func):\n    \"\"\"Allows configuring uWSGI using Configuration objects returned\n    by the given configuration function.\n\n    .. code-block: python\n\n        # In configuration module, e.g `uwsgicfg.py`\n\n        from uwsgiconf.config import configure_uwsgi\n\n        configure_uwsgi(get_configurations)\n\n\n    :param callable configurator_func: Function which return a list on configurations.\n\n    :rtype: list|None\n\n    :returns: A list with detected configurations or\n        ``None`` if called from within uWSGI (e.g. when trying to load WSGI application).\n\n    :raises ConfigurationError:\n\n    \"\"\"\n    from .settings import ENV_CONF_READY, ENV_CONF_ALIAS, CONFIGS_MODULE_ATTR\n\n    if os.environ.get(ENV_CONF_READY):\n        # This call is from uWSGI trying to load an application.\n\n        # We prevent unnecessary configuration\n        # for setups where application is located in the same\n        # file as configuration.\n\n        del os.environ[ENV_CONF_READY]  # Drop it support consecutive reconfiguration.\n\n        return None\n\n    configurations = configurator_func()\n    registry = OrderedDict()\n\n    if not isinstance(configurations, (list, tuple)):\n        configurations = [configurations]\n\n    for conf_candidate in configurations:\n        if not isinstance(conf_candidate, (Section, Configuration)):\n            continue\n\n        if isinstance(conf_candidate, Section):\n            conf_candidate = conf_candidate.as_configuration()\n\n        alias = conf_candidate.alias\n\n        if alias in registry:\n            raise ConfigurationError(\n                \"Configuration alias '%s' clashes with another configuration. \"\n                \"Please change the alias.\" % alias)\n\n        registry[alias] = conf_candidate\n\n    if not registry:\n        raise ConfigurationError(\n            \"Callable passed into 'configure_uwsgi' must return 'Section' or 'Configuration' objects.\")\n\n    # Try to get configuration alias from env with fall back\n    # to --conf argument (as passed by UwsgiRunner.spawn()).\n    target_alias = os.environ.get(ENV_CONF_ALIAS)\n\n    if not target_alias:\n        last = sys.argv[-2:]\n        if len(last) == 2 and last[0] == '--conf':\n            target_alias = last[1]\n\n    conf_list = list(registry.values())\n\n    if target_alias:\n        # This call is [presumably] from uWSGI configuration read procedure.\n        config = registry.get(target_alias)\n\n        if config:\n            section = config.sections[0]  # type: Section\n            # Set ready marker which is checked above.\n            os.environ[ENV_CONF_READY] = '1'\n\n            # Placeholder for runtime introspection.\n            section.set_placeholder('config-alias', target_alias)\n\n            # Print out\n            config.print_ini()\n\n    else:\n        # This call is from module containing uWSGI configurations.\n        import inspect\n\n        # Set module attribute automatically.\n        config_module = inspect.currentframe().f_back\n        config_module.f_locals[CONFIGS_MODULE_ATTR] = conf_list\n\n    return conf_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef replace_placeholders(self, value):\n        if not value:\n            return value\n\n        is_list = isinstance(value, list)\n        values = []\n\n        for value in listify(value):\n            runtime_dir = self.get_runtime_dir()\n            project_name = self.project_name\n\n            value = value.replace('{runtime_dir}', runtime_dir)\n            value = value.replace('{project_name}', project_name)\n            value = value.replace('{project_runtime_dir}', os.path.join(runtime_dir, project_name))\n\n            values.append(value)\n\n        value = values if is_list else values.pop()\n\n        return value", "response": "Replaces placeholders that can be used e. g. in filepaths.\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_runtime_dir(self, default=True):\n        dir_ = self._runtime_dir\n\n        if not dir_ and default:\n            uid = self.main_process.get_owner()[0]\n            dir_ = '/run/user/%s/' % uid if uid else '/run/'\n\n        return dir_", "response": "Returns the directory where the runtime files are stored."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef print_stamp(self):\n        from . import VERSION\n\n        print_out = partial(self.print_out, format_options='red')\n        print_out('This configuration was automatically generated using')\n        print_out('uwsgiconf v%s on %s' % ('.'.join(map(str, VERSION)), datetime.now().isoformat(' ')))\n\n        return self", "response": "Prints out a stamp containing useful information such as what and when has generated this configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints out the given value.", "response": "def print_out(self, value, indent=None, format_options=None, asap=False):\n        \"\"\"Prints out the given value.\n\n        :param value:\n\n        :param str|unicode indent:\n\n        :param dict|str|unicode format_options: text color\n\n        :param bool asap: Print as soon as possible.\n\n        \"\"\"\n        if indent is None:\n            indent = '>   '\n\n        text = indent + str(value)\n\n        if format_options is None:\n            format_options = 'gray'\n\n        if self._style_prints and format_options:\n\n            if not isinstance(format_options, dict):\n                format_options = {'color_fg': format_options}\n\n            text = format_print_text(text, **format_options)\n\n        command = 'iprint' if asap else 'print'\n        self._set(command, text, multi=True)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef print_variables(self):\n        print_out = partial(self.print_out, format_options='green')\n\n        print_out('===== variables =====')\n\n        for var, hint in self.vars.get_descriptions().items():\n            print_out('    %' + var + ' = ' + var + ' = ' + hint.replace('%', '%%'))\n\n        print_out('=====================')\n\n        return self", "response": "Prints out magic variables available in config files\n        alongside with their values and descriptions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting plugin - related parameters.", "response": "def set_plugins_params(self, plugins=None, search_dirs=None, autoload=None, required=False):\n        \"\"\"Sets plugin-related parameters.\n\n        :param list|str|unicode|OptionsGroup|list[OptionsGroup] plugins: uWSGI plugins to load\n\n        :param list|str|unicode search_dirs: Directories to search for uWSGI plugins.\n\n        :param bool autoload: Try to automatically load plugins when unknown options are found.\n\n        :param bool required: Load uWSGI plugins and exit on error.\n\n        \"\"\"\n        plugins = plugins or []\n\n        command = 'need-plugin' if required else 'plugin'\n\n        for plugin in listify(plugins):\n\n            if plugin not in self._plugins:\n                self._set(command, plugin, multi=True)\n                self._plugins.append(plugin)\n\n        self._set('plugins-dir', search_dirs, multi=True, priority=0)\n        self._set('autoload', autoload, cast=bool)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_fallback(self, target):\n        if isinstance(target, Section):\n            target = ':' + target.name\n\n        self._set('fallback-config', target)\n\n        return self", "response": "Sets a fallback configuration for section."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets a placeholder for the current locale.", "response": "def set_placeholder(self, key, value):\n        \"\"\"Placeholders are custom magic variables defined during configuration\n        time.\n\n        .. note:: These are accessible, like any uWSGI option, in your application code via\n            ``.runtime.environ.uwsgi_env.config``.\n\n        :param str|unicode key:\n\n        :param str|unicode value:\n\n        \"\"\"\n        self._set('set-placeholder', '%s=%s' % (key, value), multi=True)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef env(self, key, value=None, unset=False, asap=False):\n        if unset:\n            self._set('unenv', key, multi=True)\n        else:\n            if value is None:\n                value = os.environ.get(key)\n\n            self._set('%senv' % ('i' if asap else ''), '%s=%s' % (key, value), multi=True)\n\n        return self", "response": "Processes (sets/unsets) environment variable.\n\n        If is not given in `set` mode value will be taken from current env.\n\n        :param str|unicode key:\n\n        :param value:\n\n        :param bool unset: Whether to unset this variable.\n\n        :param bool asap: If True env variable will be set as soon as possible."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef include(self, target):\n        for target_ in listify(target):\n            if isinstance(target_, Section):\n                target_ = ':' + target_.name\n\n            self._set('ini', target_, multi=True)\n\n        return self", "response": "Includes target contents into config."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef derive_from(cls, section, name=None):\n        new_section = deepcopy(section)\n\n        if name:\n            new_section.name = name\n\n        return new_section", "response": "Create a new section based on the given section."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate sections types and uniqueness.", "response": "def _validate_sections(cls, sections):\n        \"\"\"Validates sections types and uniqueness.\"\"\"\n        names = []\n        for section in sections:\n\n            if not hasattr(section, 'name'):\n                raise ConfigurationError('`sections` attribute requires a list of Section')\n\n            name = section.name\n            if name in names:\n                raise ConfigurationError('`%s` section name must be unique' % name)\n\n            names.append(name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\napplies formatting to configuration.", "response": "def format(self, do_print=False, stamp=True):\n        \"\"\"Applies formatting to configuration.\n\n        *Currently formats to .ini*\n\n        :param bool do_print: Whether to print out formatted config.\n        :param bool stamp: Whether to add stamp data to the first configuration section.\n        :rtype: str|unicode\n        \"\"\"\n        if stamp and self.sections:\n            self.sections[0].print_stamp()\n\n        formatted = IniFormatter(self.sections).format()\n\n        if do_print:\n            print(formatted)\n\n        return formatted"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tofile(self, filepath=None):\n        if filepath is None:\n            with NamedTemporaryFile(prefix='%s_' % self.alias, suffix='.ini', delete=False) as f:\n                filepath = f.name\n\n        else:\n            filepath = os.path.abspath(filepath)\n\n            if os.path.isdir(filepath):\n                filepath = os.path.join(filepath, '%s.ini' % self.alias)\n\n        with open(filepath, 'w') as target_file:\n            target_file.write(self.format())\n            target_file.flush()\n\n        return filepath", "response": "Saves the current configuration into a file and returns its path."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the name of the object.", "response": "def _set_name(self, version=AUTO):\n        \"\"\"Returns plugin name.\"\"\"\n\n        name = 'python'\n\n        if version:\n            if version is AUTO:\n                version = sys.version_info[0]\n\n                if version == 2:\n                    version = ''\n\n            name = '%s%s' % (name, version)\n\n        self.name = name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting sys. argv for python apps.", "response": "def set_app_args(self, *args):\n        \"\"\"Sets ``sys.argv`` for python apps.\n\n        Examples:\n            * pyargv=\"one two three\" will set ``sys.argv`` to ``('one', 'two', 'three')``.\n\n        :param args:\n        \"\"\"\n        if args:\n            self._set('pyargv', ' '.join(args))\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the wsgi related parameters.", "response": "def set_wsgi_params(self, module=None, callable_name=None, env_strategy=None):\n        \"\"\"Set wsgi related parameters.\n\n        :param str|unicode module:\n            * load .wsgi file as the Python application\n            * load a WSGI module as the application.\n\n            .. note:: The module (sans ``.py``) must be importable, ie. be in ``PYTHONPATH``.\n\n            Examples:\n                * mypackage.my_wsgi_module -- read from `application` attr of mypackage/my_wsgi_module.py\n                * mypackage.my_wsgi_module:my_app -- read from `my_app` attr of mypackage/my_wsgi_module.py\n\n        :param str|unicode callable_name: Set WSGI callable name. Default: application.\n\n        :param str|unicode env_strategy: Strategy for allocating/deallocating\n            the WSGI env, can be:\n\n            * ``cheat`` - preallocates the env dictionary on uWSGI startup and clears it\n                after each request. Default behaviour for uWSGI <= 2.0.x\n\n            * ``holy`` - creates and destroys the environ dictionary at each request.\n                Default behaviour for uWSGI >= 2.1\n\n        \"\"\"\n        module = module or ''\n\n        if '/' in module:\n            self._set('wsgi-file', module, condition=module)\n\n        else:\n            self._set('wsgi', module, condition=module)\n\n        self._set('callable', callable_name)\n        self._set('wsgi-env-behaviour', env_strategy)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_autoreload_params(self, scan_interval=None, ignore_modules=None):\n        self._set('py-auto-reload', scan_interval)\n        self._set('py-auto-reload-ignore', ignore_modules, multi=True)\n\n        return self._section", "response": "Sets autoreload related parameters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd an alias for a module.", "response": "def register_module_alias(self, alias, module_path, after_init=False):\n        \"\"\"Adds an alias for a module.\n\n        http://uwsgi-docs.readthedocs.io/en/latest/PythonModuleAlias.html\n\n        :param str|unicode alias:\n        :param str|unicode module_path:\n        :param bool after_init: add a python module alias after uwsgi module initialization\n        \"\"\"\n        command = 'post-pymodule-alias' if after_init else 'pymodule-alias'\n        self._set(command, '%s=%s' % (alias, module_path), multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef import_module(self, modules, shared=False, into_spooler=False):\n        if all((shared, into_spooler)):\n            raise ConfigurationError('Unable to set both `shared` and `into_spooler` flags')\n\n        if into_spooler:\n            command = 'spooler-python-import'\n        else:\n            command = 'shared-python-import' if shared else 'python-import'\n\n        self._set(command, modules, multi=True)\n\n        return self._section", "response": "Imports a python module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_server_params(\n            self, client_notify_address=None, mountpoints_depth=None, require_vassal=None,\n            tolerance=None, tolerance_inactive=None, key_dot_split=None):\n        \"\"\"Sets subscription server related params.\n\n        :param str|unicode client_notify_address: Set the notification socket for subscriptions.\n            When you subscribe to a server, you can ask it to \"acknowledge\" the acceptance of your request.\n            pointing address (Unix socket or UDP), on which your instance will bind and\n            the subscription server will send acknowledgements to.\n\n        :param int mountpoints_depth: Enable support of mountpoints of certain depth for subscription system.\n\n            * http://uwsgi-docs.readthedocs.io/en/latest/SubscriptionServer.html#mountpoints-uwsgi-2-1\n\n        :param bool require_vassal: Require a vassal field (see ``subscribe``) from each subscription.\n\n        :param int tolerance: Subscription reclaim tolerance (seconds).\n\n        :param int tolerance_inactive: Subscription inactivity tolerance (seconds).\n\n        :param bool key_dot_split: Try to fallback to the next part in (dot based) subscription key.\n            Used, for example, in SNI.\n\n        \"\"\"\n        # todo notify-socket (fallback) relation\n        self._set('subscription-notify-socket', client_notify_address)\n        self._set('subscription-mountpoint', mountpoints_depth)\n        self._set('subscription-vassal-required', require_vassal, cast=bool)\n        self._set('subscription-tolerance', tolerance)\n        self._set('subscription-tolerance-inactive', tolerance_inactive)\n        self._set('subscription-dotsplit', key_dot_split, cast=bool)\n\n        return self._section", "response": "Sets the server related params for the subscription server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting peer verification params for subscription server.", "response": "def set_server_verification_params(\n            self, digest_algo=None, dir_cert=None, tolerance=None, no_check_uid=None,\n            dir_credentials=None, pass_unix_credentials=None):\n        \"\"\"Sets peer verification params for subscription server.\n\n        These are for secured subscriptions.\n\n        :param str|unicode digest_algo: Digest algorithm. Example: SHA1\n\n            .. note:: Also requires ``dir_cert`` to be set.\n\n        :param str|unicode dir_cert: Certificate directory.\n\n            .. note:: Also requires ``digest_algo`` to be set.\n\n        :param int tolerance: Maximum tolerance (in seconds) of clock skew for secured subscription system.\n            Default: 24h.\n\n        :param str|unicode|int|list[str|unicode|int] no_check_uid: Skip signature check for the specified uids\n            when using unix sockets credentials.\n\n        :param str|unicode|list[str|unicode] dir_credentials: Directories to search for subscriptions\n            key credentials.\n\n        :param bool pass_unix_credentials: Enable management of SCM_CREDENTIALS in subscriptions UNIX sockets.\n\n        \"\"\"\n        if digest_algo and dir_cert:\n            self._set('subscriptions-sign-check', '%s:%s' % (digest_algo, dir_cert))\n\n        self._set('subscriptions-sign-check-tolerance', tolerance)\n        self._set('subscriptions-sign-skip-uid', no_check_uid, multi=True)\n        self._set('subscriptions-credentials-check', dir_credentials, multi=True)\n        self._set('subscriptions-use-credentials', pass_unix_credentials, cast=bool)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_client_params(\n            self, start_unsubscribed=None, clear_on_exit=None, unsubscribe_on_reload=None,\n            announce_interval=None):\n        \"\"\"Sets subscribers related params.\n\n        :param bool start_unsubscribed: Configure subscriptions but do not send them.\n            .. note:: Useful with master FIFO.\n\n        :param bool clear_on_exit: Force clear instead of unsubscribe during shutdown.\n\n        :param bool unsubscribe_on_reload: Force unsubscribe request even during graceful reload.\n\n        :param int announce_interval: Send subscription announce at the specified interval. Default: 10 master cycles.\n\n        \"\"\"\n        self._set('start-unsubscribed', start_unsubscribed, cast=bool)\n        self._set('subscription-clear-on-shutdown', clear_on_exit, cast=bool)\n        self._set('unsubscribe-on-graceful-reload', unsubscribe_on_reload, cast=bool)\n        self._set('subscribe-freq', announce_interval)\n\n        return self._section", "response": "Sets the client related params."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef subscribe(\n            self, server=None, key=None, address=None, address_vassal=None,\n            balancing_weight=None, balancing_algo=None, modifier=None, signing=None, check_file=None, protocol=None,\n            sni_cert=None, sni_key=None, sni_client_ca=None):\n        \"\"\"Registers a subscription intent.\n\n        :param str|unicode server: Subscription server address (UDP or UNIX socket).\n\n            Examples:\n                * 127.0.0.1:7171\n\n        :param str|unicode key: Key to subscribe. Generally the domain name (+ optional '/< mountpoint>').\n            Examples:\n                * mydomain.it/foo\n                * mydomain.it/foo/bar (requires ``mountpoints_depth=2``)\n                * mydomain.it\n                * ubuntu64.local:9090\n\n        :param str|unicode|int address: Address to subscribe (the value for the key)\n            or zero-based internal socket number (integer).\n\n        :param str|unicode address: Vassal node address.\n\n        :param int balancing_weight: Load balancing value. Default: 1.\n\n        :param balancing_algo: Load balancing algorithm to use. See ``balancing_algorithms``\n            .. note:: Since 2.1\n\n        :param Modifier modifier: Routing modifier object. See ``.routing.modifiers``\n\n        :param list|tuple signing:  Signing basics, expects two elements list/tuple:\n            (signing_algorithm, key).\n\n            Examples:\n                * SHA1:idlessh001\n\n        :param str|unicode check_file: If this file exists the subscription packet is sent,\n            otherwise it is skipped.\n\n        :param str|unicode protocol: the protocol to use, by default it is ``uwsgi``.\n            See ``.networking.socket_types``.\n\n            .. note:: Since 2.1\n\n        :param str|unicode sni_cert: Certificate file to use for SNI proxy management.\n            * http://uwsgi.readthedocs.io/en/latest/SNI.html#subscription-system-and-sni\n\n        :param str|unicode sni_key: sni_key Key file to use for SNI proxy management.\n            * http://uwsgi.readthedocs.io/en/latest/SNI.html#subscription-system-and-sni\n\n        :param str|unicode sni_client_ca: Ca file to use for SNI proxy management.\n            * http://uwsgi.readthedocs.io/en/latest/SNI.html#subscription-system-and-sni\n\n        \"\"\"\n        # todo params: inactive (inactive slot activation)\n\n        if not any((server, key)):\n            raise ConfigurationError('Subscription requires `server` or `key` to be set.')\n\n        address_key = 'addr'\n        if isinstance(address, int):\n            address_key = 'socket'\n\n        if balancing_algo:\n            backup = getattr(balancing_algo, 'backup_level', None)\n\n        if signing:\n            signing = ':'.join(signing)\n\n        if modifier:\n            modifier1 = modifier\n            if modifier.submod:\n                modifier2 = modifier.submod\n\n        rule = KeyValue(\n            filter_locals(locals(), drop=['address_key', 'modifier']),\n            aliases={\n                'address': address_key,\n                'address_vassal': 'vassal',\n                'signing': 'sign',\n                'check_file': 'check',\n                'balancing_weight': 'weight',\n                'balancing_algo': 'algo',\n                'protocol': 'proto',\n                'sni_cert': 'sni_crt',\n                'sni_client_ca': 'sni_ca',\n            },\n        )\n\n        self._set('subscribe2', rule)\n\n        return self._section", "response": "Registers a new subscription intent."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_project_dir():\n    frame = inspect.currentframe()\n\n    while True:\n        frame = frame.f_back\n        fname = frame.f_globals['__file__']\n\n        if os.path.basename(fname) == 'manage.py':\n            break\n\n    return os.path.dirname(fname)", "response": "Runs up the stack to find the location of manage. py\n    which will be considered a project base path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning uWSGI using the given section configuration.", "response": "def run_uwsgi(config_section, compile_only=False):\n    \"\"\"Runs uWSGI using the given section configuration.\n\n    :param Section config_section:\n    :param bool compile_only: Do not run, only compile and output configuration file for run.\n\n    \"\"\"\n    config = config_section.as_configuration()\n\n    if compile_only:\n        config.print_ini()\n        return\n\n    config_path = config.tofile()\n    os.execvp('uwsgi', ['uwsgi', '--ini=%s' % config_path])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_section_existing(self, name_module, name_project):\n        from importlib import import_module\n\n        from uwsgiconf.settings import CONFIGS_MODULE_ATTR\n\n        config = getattr(\n            import_module(os.path.splitext(name_module)[0], package=name_project),\n            CONFIGS_MODULE_ATTR)[0]\n\n        return config.sections[0]", "response": "Loads config section from existing configuration file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new section with default settings.", "response": "def _get_section_new(cls, dir_base):\n        \"\"\"Creates a new section with default settings.\n\n        :param str|unicode dir_base:\n        :rtype: Section\n\n        \"\"\"\n        from uwsgiconf.presets.nice import PythonSection\n        from django.conf import settings\n\n        wsgi_app = settings.WSGI_APPLICATION\n\n        path_wsgi, filename, _, = wsgi_app.split('.')\n        path_wsgi = os.path.join(dir_base, path_wsgi, '%s.py' %filename)\n\n        section = PythonSection(\n            wsgi_module=path_wsgi,\n\n        ).networking.register_socket(\n            PythonSection.networking.sockets.http('127.0.0.1:8000')\n\n        ).main_process.change_dir(dir_base)\n\n        return section"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef contribute_static(self):\n\n        options = self.options\n        if options['compile'] or not options['use_static_handler']:\n            return\n\n        from django.core.management import call_command\n\n        settings = self.settings\n        statics = self.section.statics\n        statics.register_static_map(settings.STATIC_URL, settings.STATIC_ROOT)\n        statics.register_static_map(settings.MEDIA_URL, settings.MEDIA_ROOT)\n\n        call_command('collectstatic', clear=True, interactive=False)", "response": "Contributes static and media file serving settings to an existing section."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncontributing generic static error massage pages to an existing section.", "response": "def contribute_error_pages(self):\n        \"\"\"Contributes generic static error massage pages to an existing section.\"\"\"\n\n        static_dir = self.settings.STATIC_ROOT\n\n        if not static_dir:\n            # Source static directory is not configured. Use temporary.\n            import tempfile\n            static_dir = os.path.join(tempfile.gettempdir(), self.project_name)\n            self.settings.STATIC_ROOT = static_dir\n\n        self.section.routing.set_error_pages(\n            common_prefix=os.path.join(static_dir, 'uwsgify'))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmapping a specific file or directory modification event to a signal.", "response": "def register_file_monitor(filename, target=None):\n    \"\"\"Maps a specific file/directory modification event to a signal.\n\n    :param str|unicode filename: File or a directory to watch for its modification.\n\n    :param int|Signal|str|unicode target: Existing signal to raise\n        or Signal Target to register signal implicitly.\n\n        Available targets:\n\n            * ``workers``  - run the signal handler on all the workers\n            * ``workerN`` - run the signal handler only on worker N\n            * ``worker``/``worker0`` - run the signal handler on the first available worker\n            * ``active-workers`` - run the signal handlers on all the active [non-cheaped] workers\n\n            * ``mules`` - run the signal handler on all of the mules\n            * ``muleN`` - run the signal handler on mule N\n            * ``mule``/``mule0`` - run the signal handler on the first available mule\n\n            * ``spooler`` - run the signal on the first available spooler\n            * ``farmN/farm_XXX``  - run the signal handler in the mule farm N or named XXX\n\n    :raises ValueError: If unable to register monitor.\n    \"\"\"\n    return _automate_signal(target, func=lambda sig: uwsgi.add_file_monitor(int(sig), filename))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set(self, value, mode=None):\n        if mode == 'max':\n            func = uwsgi.metric_set_max\n\n        elif mode == 'min':\n            func = uwsgi.metric_set_min\n\n        else:\n            func = uwsgi.metric_set\n\n        return func(self.name, value)", "response": "Sets the value of the current metric."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_message(cls, signals=True, farms=False, buffer_size=65536, timeout=-1):\n        return decode(uwsgi.mule_get_msg(signals, farms, buffer_size, timeout))", "response": "Block until a mule message is received and return it."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nregenerates header files for cmark under. generated.", "response": "def regenerate(session):\r\n    \"\"\"Regenerates header files for cmark under ./generated.\"\"\"\r\n    if platform.system() == 'Windows':\r\n        output_dir = '../generated/windows'\r\n    else:\r\n        output_dir = '../generated/unix'\r\n\r\n    session.run(shutil.rmtree, 'build', ignore_errors=True)\r\n    session.run(os.makedirs, 'build')\r\n    session.chdir('build')\r\n    session.run('cmake', '../third_party/cmark')\r\n    session.run(shutil.copy, 'src/cmark-gfm_export.h', output_dir)\r\n    session.run(shutil.copy, 'src/cmark-gfm_version.h', output_dir)\r\n    session.run(shutil.copy, 'src/config.h', output_dir)\r\n    session.run(shutil.copy, 'extensions/cmark-gfm-extensions_export.h', output_dir)\r\n    session.chdir('..')\r\n    session.run(shutil.rmtree, 'build')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter_locals(locals_dict, drop=None, include=None):\n    drop = drop or []\n    drop.extend([\n        'self',\n        '__class__',  # py3\n    ])\n\n    include = include or locals_dict.keys()\n\n    relevant_keys = [key for key in include if key not in drop]\n\n    locals_dict = {k: v for k, v in locals_dict.items() if k in relevant_keys}\n\n    return locals_dict", "response": "Filters a dictionary produced by locals."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning a command and returns its output.", "response": "def get_output(cmd, args):\n    \"\"\"Runs a command and returns its output (stdout + stderr).\n\n    :param str|unicode cmd:\n    :param str|unicode|list[str|unicode] args:\n\n    :rtype: str|unicode\n\n    \"\"\"\n    from subprocess import Popen, STDOUT, PIPE\n\n    command = [cmd]\n    command.extend(listify(args))\n\n    process = Popen(command, stdout=PIPE, stderr=STDOUT)\n    out, _ = process.communicate()\n\n    return out.decode('utf-8')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_command_plugins_output(out):\n    out = out.split('--- end of plugins list ---')[0]\n    out = out.partition('plugins ***')[2]\n    out = out.splitlines()\n\n    current_slot = 0\n\n    plugins = EmbeddedPlugins([], [])\n\n    for line in out:\n        line = line.strip()\n\n        if not line:\n            continue\n\n        if line.startswith('***'):\n            current_slot += 1\n            continue\n\n        if current_slot is not None:\n            plugins[current_slot].append(line)\n\n    plugins = plugins._replace(request=[plugin.partition(' ')[2] for plugin in plugins.request])\n\n    return plugins", "response": "Parses uWSGI\n    and returns object containing lists of embedded plugin names."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_uwsgi_stub_attrs_diff():\n\n    try:\n        import uwsgi\n\n    except ImportError:\n        from uwsgiconf.exceptions import UwsgiconfException\n\n        raise UwsgiconfException(\n            '`uwsgi` module is unavailable. Calling `get_attrs_diff` in such environment makes no sense.')\n\n    from . import uwsgi_stub\n\n    def get_attrs(src):\n        return set(attr for attr in dir(src) if not attr.startswith('_'))\n\n    attrs_uwsgi = get_attrs(uwsgi)\n    attrs_stub = get_attrs(uwsgi_stub)\n\n    from_uwsgi = sorted(attrs_uwsgi.difference(attrs_stub))\n    from_stub = sorted(attrs_stub.difference(attrs_uwsgi))\n\n    return from_uwsgi, from_stub", "response": "Returns attributes difference two elements tuple between uwsgi module and uwsgi stub module."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef spawn_uwsgi(self, only=None):\n        spawned = []\n        configs = self.configurations\n\n        if len(configs) == 1:\n\n            alias = configs[0].alias\n            UwsgiRunner().spawn(self.fpath, alias, replace=True)\n            spawned.append((alias, os.getpid()))\n\n        else:\n            for config in configs:  # type: Configuration\n                alias = config.alias\n\n                if only is None or alias == only:\n                    pid = UwsgiRunner().spawn(self.fpath, alias)\n                    spawned.append((alias, pid))\n\n        return spawned", "response": "Spawns uWSGI processes which will use configuration from the module."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload a module and returns its object.", "response": "def load(cls, fpath):\n        \"\"\"Loads a module and returns its object.\n\n        :param str|unicode fpath:\n        :rtype: module\n        \"\"\"\n        module_name = os.path.splitext(os.path.basename(fpath))[0]\n\n        sys.path.insert(0, os.path.dirname(fpath))\n        try:\n            module = import_module(module_name)\n\n        finally:\n            sys.path = sys.path[1:]\n\n        return module"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_log(self, reopen=False, rotate=False):\n        cmd = b''\n\n        if reopen:\n            cmd += b'l'\n\n        if rotate:\n            cmd += b'L'\n\n        return self.send_command(cmd)", "response": "Allows managing of uWSGI log related stuff."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreloading uWSGI master process.", "response": "def cmd_reload(self, force=False, workers_only=False, workers_chain=False):\n        \"\"\"Reloads uWSGI master process, workers.\n\n        :param bool force: Use forced (brutal) reload instead of a graceful one.\n        :param bool workers_only: Reload only workers.\n        :param bool workers_chain: Run chained workers reload (one after another,\n            instead of destroying all of them in bulk).\n\n        \"\"\"\n        if workers_chain:\n            return self.send_command(b'c')\n\n        if workers_only:\n            return self.send_command(b'R' if force else b'r')\n\n        return self.send_command(b'R' if force else b'r')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending a generic command into the FIFO.", "response": "def send_command(self, cmd):\n        \"\"\"Sends a generic command into FIFO.\n\n        :param bytes cmd: Command chars to send into FIFO.\n\n        \"\"\"\n        if not cmd:\n            return\n\n        with open(self.fifo, 'wb') as f:\n            f.write(cmd)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_env_path(cls):\n        return os.path.dirname(Finder.python()) + os.pathsep + os.environ['PATH']", "response": "Returns the PATH environment variable updated to run uwsgiconf in\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prepare_env(cls):\n        os.environ['PATH'] = cls.get_env_path()\n        return os.path.basename(Finder.python())", "response": "Prepares current environment and returns Python binary name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef spawn(self, filepath, configuration_alias, replace=False):\n        # Pass --conf as an argument to have a chance to use\n        # touch reloading form .py configuration file change.\n        args = ['uwsgi', '--ini', 'exec://%s %s --conf %s' % (self.binary_python, filepath, configuration_alias)]\n\n        if replace:\n            return os.execvp('uwsgi', args)\n\n        return os.spawnvp(os.P_NOWAIT, 'uwsgi', args)", "response": "Spawns uWSGI using the given configuration module."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a value from the cache.", "response": "def get(self, key, default=None, as_int=False, setter=None):\n        \"\"\"Gets a value from the cache.\n\n        :param str|unicode key: The cache key to get value for.\n\n        :param default: Value to return if none found in cache.\n\n        :param bool as_int: Return 64bit number instead of str.\n\n        :param callable setter: Setter callable to automatically set cache\n            value if not already cached. Required to accept a key and return\n            a value that will be cached.\n\n        :rtype: str|unicode|int\n\n        \"\"\"\n        if as_int:\n            val = uwsgi.cache_num(key, self.name)\n        else:\n            val = decode(uwsgi.cache_get(key, self.name))\n\n        if val is None:\n\n            if setter is None:\n                return default\n\n            val = setter(key)\n\n            if val is None:\n                return default\n\n            self.set(key, val)\n\n        return val"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set(self, key, value):\n        return uwsgi.cache_set(key, value, self.timeout, self.name)", "response": "Sets the specified key value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nincrementing the specified key value by the specified value.", "response": "def incr(self, key, delta=1):\n        \"\"\"Increments the specified key value by the specified value.\n       \n        :param str|unicode key:\n    \n        :param int delta:\n\n        :rtype: bool\n        \"\"\"\n        return uwsgi.cache_inc(key, delta, self.timeout, self.name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mul(self, key, value=2):\n        return uwsgi.cache_mul(key, value, self.timeout, self.name)", "response": "Multiplies the specified key value by the specified value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndividing the specified key value by the specified value.", "response": "def div(self, key, value=2):\n        \"\"\"Divides the specified key value by the specified value.\n\n        :param str|unicode key:\n\n        :param int value:\n\n        :rtype: bool\n        \"\"\"\n        return uwsgi.cache_mul(key, value, self.timeout, self.name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreceives data from the websocket.", "response": "def recv(request_context=None, non_blocking=False):\n    \"\"\"Receives data from websocket.\n\n    :param request_context:\n\n    :param bool non_blocking:\n\n    :rtype: bytes|str\n\n    :raises IOError: If unable to receive a message.\n    \"\"\"\n\n    if non_blocking:\n        result = uwsgi.websocket_recv_nb(request_context)\n\n    else:\n        result = uwsgi.websocket_recv(request_context)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send(message, request_context=None, binary=False):\n    if binary:\n        return uwsgi.websocket_send_binary(message, request_context)\n\n    return uwsgi.websocket_send(message, request_context)", "response": "Sends a message to the current websocket."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef markdown_to_html(text, options=0):\r\n    encoded_text = text.encode('utf-8')\r\n    raw_result = _cmark.lib.cmark_markdown_to_html(\r\n        encoded_text, len(encoded_text), options)\r\n    return _cmark.ffi.string(raw_result).decode('utf-8')", "response": "Render the given text to HTML."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrender the given text to HTML using the given extensions.", "response": "def markdown_to_html_with_extensions(text, options=0, extensions=None):\r\n    \"\"\"Render the given text to Markdown, using extensions.\r\n\r\n    This is a high-level wrapper over the various functions needed to enable\r\n    extensions, attach them to a parser, and render html.\r\n\r\n    Args:\r\n        text (str): The text to render to Markdown.\r\n        options (int): The cmark options.\r\n        extensions (Sequence[str]): The list of extension names to use.\r\n\r\n    Returns:\r\n        str: The rendered markdown.\r\n    \"\"\"\r\n    if extensions is None:\r\n        extensions = []\r\n\r\n    core_extensions_ensure_registered()\r\n\r\n    cmark_extensions = []\r\n    for extension_name in extensions:\r\n        extension = find_syntax_extension(extension_name)\r\n        if extension is None:\r\n            raise ValueError('Unknown extension {}'.format(extension_name))\r\n        cmark_extensions.append(extension)\r\n\r\n    parser = parser_new(options=options)\r\n\r\n    try:\r\n        for extension in cmark_extensions:\r\n            parser_attach_syntax_extension(parser, extension)\r\n\r\n        parser_feed(parser, text)\r\n\r\n        root = parser_finish(parser)\r\n\r\n        if _cmark.lib.cmark_node_get_type(root) == _cmark.lib.CMARK_NODE_NONE:\r\n            raise ValueError('Error parsing markdown!')\r\n\r\n        extensions_ll = parser_get_syntax_extensions(parser)\r\n\r\n        output = render_html(root, options=options, extensions=extensions_ll)\r\n\r\n    finally:\r\n        parser_free(parser)\r\n\r\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a text string and return the root node of the parsed syntax tree.", "response": "def parse_document(text, options=0):\r\n    \"\"\"Parse a document and return the root node.\r\n\r\n    Args:\r\n        text (str): The text to parse.\r\n        options (int): The cmark options.\r\n\r\n    Returns:\r\n        Any: Opaque reference to the root node of the parsed syntax tree.\r\n    \"\"\"\r\n    encoded_text = text.encode('utf-8')\r\n    return _cmark.lib.cmark_parse_document(\r\n        encoded_text, len(encoded_text), options)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndirect wrapper over cmark_parser_feed.", "response": "def parser_feed(parser, text):\r\n    \"\"\"Direct wrapper over cmark_parser_feed.\"\"\"\r\n    encoded_text = text.encode('utf-8')\r\n    return _cmark.lib.cmark_parser_feed(\r\n        parser, encoded_text, len(encoded_text))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render_html(root, options=0, extensions=None):\r\n    if extensions is None:\r\n        extensions = _cmark.ffi.NULL\r\n\r\n    raw_result = _cmark.lib.cmark_render_html(\r\n        root, options, extensions)\r\n\r\n    return _cmark.ffi.string(raw_result).decode('utf-8')", "response": "Render a given syntax tree as HTML."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndirects wrapper over cmark_find_syntax_extension.", "response": "def find_syntax_extension(name):\r\n    \"\"\"Direct wrapper over cmark_find_syntax_extension.\"\"\"\r\n    encoded_name = name.encode('utf-8')\r\n    extension = _cmark.lib.cmark_find_syntax_extension(encoded_name)\r\n\r\n    if extension == _cmark.ffi.NULL:\r\n        return None\r\n    else:\r\n        return extension"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset basic parameters for the cache item expiration command.", "response": "def set_basic_params(self, no_expire=None, expire_scan_interval=None, report_freed=None):\n        \"\"\"\n        :param bool no_expire: Disable auto sweep of expired items.\n            Since uWSGI 1.2, cache item expiration is managed by a thread in the master process,\n            to reduce the risk of deadlock. This thread can be disabled\n            (making item expiry a no-op) with the this option.\n\n        :param int expire_scan_interval: Set the frequency (in seconds) of cache sweeper scans. Default: 3.\n\n        :param bool report_freed: Constantly report the cache item freed by the sweeper.\n\n            .. warning:: Use only for debug.\n\n        \"\"\"\n        self._set('cache-no-expire', no_expire, cast=bool)\n        self._set('cache-report-freed-items', report_freed, cast=bool)\n        self._set('cache-expire-freq', expire_scan_interval)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd an item into the given cache.", "response": "def add_item(self, key, value, cache_name=None):\n        \"\"\"Add an item into the given cache.\n\n        This is a commodity option (mainly useful for testing) allowing you\n        to store an item in a uWSGI cache during startup.\n\n        :param str|unicode key:\n\n        :param value:\n\n        :param str|unicode cache_name: If not set, default will be used.\n\n        \"\"\"\n        cache_name = cache_name or ''\n        value = '%s %s=%s' % (cache_name, key, value)\n\n        self._set('add-cache-item', value.strip(), multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_file(self, filepath, gzip=False, cache_name=None):\n        command = 'load-file-in-cache'\n\n        if gzip:\n            command += '-gzip'\n\n        cache_name = cache_name or ''\n        value = '%s %s' % (cache_name, filepath)\n\n        self._set(command, value.strip(), multi=True)\n\n        return self._section", "response": "Add a static file to the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new cache.", "response": "def add_cache(\n            self, name, max_items, expires=None, store=None, store_sync_interval=None, store_delete=None,\n            hash_algo=None, hash_size=None, key_size=None, udp_clients=None, udp_servers=None,\n            block_size=None, block_count=None, sync_from=None, mode_bitmap=None, use_lastmod=None,\n            full_silent=None, full_purge_lru=None):\n        \"\"\"Creates cache. Default mode: single block.\n\n        .. note:: This uses new generation ``cache2`` option available since uWSGI 1.9.\n\n        .. note:: When at least one cache is configured without ``full_purge_lru``\n            and the master is enabled a thread named \"the cache sweeper\" is started.\n            Its main purpose is deleting expired keys from the cache.\n            If you want auto-expiring you need to enable the master.\n\n        :param str|unicode name: Set the name of the cache. Must be unique in an instance.\n\n        :param int max_items: Set the maximum number of cache items.\n\n            .. note:: Effective number of items is **max_items - 1** -\n                the first item of the cache is always internally used as \"NULL/None/undef\".\n\n        :param int expires: The number of seconds after the object is no more valid\n            (and will be removed by the cache sweeper when ``full_purge_lru`` is not set.\n\n        :param str|unicode store: Set the filename for the persistent storage.\n            If it doesn't exist, the system assumes an empty cache and the file will be created.\n\n        :param int store_sync_interval: Set the number of seconds after which msync() is called\n            to flush memory cache on disk when in persistent mode.\n            By default it is disabled leaving the decision-making to the kernel.\n\n        :param bool store_delete: uWSGI, by default, will not start if a cache file exists\n            and the store file does not match the configured items/blocksize.\n            Setting this option will make uWSGI delete the existing file upon mismatch\n            and create a new one.\n\n        :param str|unicode hash_algo: Set the hash algorithm used in the hash table. Current options are:\n\n            * djb33x (default)\n            * murmur2\n\n        :param int hash_size: This is the size of the hash table in bytes.\n            Generally 65536 (the default) is a good value.\n\n            .. note:: Change it only if you know what you are doing\n                or if you have a lot of collisions in your cache.\n\n        :param int key_size: Set the maximum size of a key, in bytes. Default: 2048.\n\n        :param str|unicode|list udp_clients: List of UDP servers which will receive UDP cache updates.\n\n        :param str|unicode |list udp_servers: List of UDP addresses on which to bind the cache\n            to wait for UDP updates.\n\n        :param int block_size: Set the size (in bytes) of a single block.\n\n            .. note:: It's a good idea to use a multiple of 4096 (common memory page size).\n\n        :param int block_count: Set the number of blocks in the cache. Useful only in bitmap mode,\n            otherwise the number of blocks is equal to the maximum number of items.\n\n        :param str|unicode|list sync_from: List of uWSGI addresses which the cache subsystem will connect to\n            for getting a full dump of the cache. It can be used for initial cache synchronization.\n            The first node sending a valid dump will stop the procedure.\n            \n        :param bool mode_bitmap: Enable (more versatile but relatively slower) bitmap mode.\n\n            http://uwsgi-docs.readthedocs.io/en/latest/Caching.html#single-block-faster-vs-bitmaps-slower\n\n            .. warning:: Considered production ready only from uWSGI 2.0.2.\n\n        :param bool use_lastmod: Enabling will update last_modified_at timestamp of each cache\n            on every cache item modification. Enable it if you want to track this value\n            or if other features depend on it. This value will then be accessible via the stats socket.\n\n        :param bool full_silent: By default uWSGI will print warning message on every cache set operation\n            if the cache is full. To disable this warning set this option.\n\n            .. note:: Available since 2.0.4.\n\n        :param bool full_purge_lru: Allows the caching framework to evict Least Recently Used (LRU)\n            item when you try to add new item to cache storage that is full.\n\n            .. note:: ``expires`` argument will be ignored.\n\n        \"\"\"\n        value = KeyValue(\n            locals(),\n            keys=[\n                'name', 'max_items', 'expires', 'store', 'store_sync_interval', 'store_delete',\n                'hash_algo', 'hash_size', 'key_size', 'udp_clients', 'udp_servers',\n                'block_size', 'block_count', 'sync_from', 'mode_bitmap', 'use_lastmod',\n                'full_silent', 'full_purge_lru',\n            ],\n            aliases={\n                'max_items': 'maxitems',\n                'store_sync_interval': 'storesync',\n                'hash_algo': 'hash',\n                'udp_clients': 'nodes',\n                'block_size': 'blocksize',\n                'block_count': 'blocks',\n                'sync_from': 'sync',\n                'mode_bitmap': 'bitmap',\n                'use_lastmod': 'lastmod',\n                'full_silent': 'ignore_full',\n                'full_purge_lru': 'purge_lru',\n            },\n            bool_keys=['store_delete', 'mode_bitmap', 'use_lastmod', 'full_silent', 'full_purge_lru'],\n            list_keys=['udp_clients', 'udp_servers', 'sync_from'],\n        )\n\n        self._set('cache2', value, multi=True)\n\n        return self._section"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_timer(period, target=None):\n    return _automate_signal(target, func=lambda sig: uwsgi.add_timer(int(sig), period))", "response": "Register a timer that will repeat the current time period seconds."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a red - black timer based on black - red tree.", "response": "def register_timer_rb(period, repeat=None, target=None):\n    \"\"\"Add a red-black timer (based on black-red tree).\n\n        .. code-block:: python\n\n            @register_timer_rb(3)\n            def repeat():\n                do()\n\n    :param int period: The interval (seconds) at which the signal is raised.\n\n    :param int repeat: How many times to repeat. Default: None - infinitely.\n\n    :param int|Signal|str|unicode target: Existing signal to raise\n        or Signal Target to register signal implicitly.\n\n        Available targets:\n\n            * ``workers``  - run the signal handler on all the workers\n            * ``workerN`` - run the signal handler only on worker N\n            * ``worker``/``worker0`` - run the signal handler on the first available worker\n            * ``active-workers`` - run the signal handlers on all the active [non-cheaped] workers\n\n            * ``mules`` - run the signal handler on all of the mules\n            * ``muleN`` - run the signal handler on mule N\n            * ``mule``/``mule0`` - run the signal handler on the first available mule\n\n            * ``spooler`` - run the signal on the first available spooler\n            * ``farmN/farm_XXX``  - run the signal handler in the mule farm N or named XXX\n\n    :rtype: bool|callable\n\n    :raises ValueError: If unable to add timer.\n    \"\"\"\n    return _automate_signal(target, func=lambda sig: uwsgi.add_rb_timer(int(sig), period, repeat or 0))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_cron(weekday=None, month=None, day=None, hour=None, minute=None, target=None):\n    task_args_initial = {name: val for name, val in locals().items() if val is not None and name != 'target'}\n    task_args_casted = {}\n\n    def skip_task(check_funcs):\n        now = datetime.now()\n        allright = all((func(now) for func in check_funcs))\n        return not allright\n\n    def check_date(now, attr, target_range):\n        attr = getattr(now, attr)\n\n        if callable(attr):  # E.g. weekday.\n            attr = attr()\n\n        return attr in target_range\n\n    check_date_funcs = []\n\n    for name, val in task_args_initial.items():\n\n        # uWSGI won't accept strings, so we emulate ranges here.\n        if isinstance(val, string_types):\n\n            # Rules like 10-18/2 (from 10 till 18 every 2 hours).\n            val, _, step = val.partition('/')\n            step = int(step) if step else 1\n            start, _, end = val.partition('-')\n\n            if not (start and end):\n                raise RuntimeConfigurationError(\n                    'String cron rule without a range is not supported. Use integer notation.')\n\n            start = int(start)\n            end = int(end)\n\n            now_attr_name = name\n\n            period_range = set(range(start, end+1, step))\n\n            if name == 'weekday':\n                # Special case for weekday indexes: swap uWSGI Sunday 0 for ISO Sunday 7.\n                now_attr_name = 'isoweekday'\n\n                if 0 in period_range:\n                    period_range.discard(0)\n                    period_range.add(7)\n\n            # Gather date checking functions in one place.\n            check_date_funcs.append(partial(check_date, attr=now_attr_name, target_range=period_range))\n\n            # Use minimal duration (-1).\n            val = None\n\n        task_args_casted[name] = val\n\n    if not check_date_funcs:\n        # No special handling of periods, quit early.\n        args = [(-1 if arg is None else arg) for arg in (minute, hour, day, month, weekday)]\n        return _automate_signal(target, func=lambda sig: uwsgi.add_cron(int(sig), *args))\n\n    skip_task = partial(skip_task, check_date_funcs)\n\n    def decor(func_action):\n        \"\"\"Decorator wrapping.\"\"\"\n\n        @wraps(func_action)\n        def func_action_wrapper(*args, **kwargs):\n            \"\"\"Action function wrapper to handle periods in rules.\"\"\"\n\n            if skip_task():\n                # todo Maybe allow user defined value for this return.\n                return None\n\n            return func_action(*args, **kwargs)\n\n        args = []\n        for arg_name in ['minute', 'hour', 'day', 'month', 'weekday']:\n            arg = task_args_casted.get(arg_name, None)\n            args.append(-1 if arg is None else arg)\n\n        return _automate_signal(target, func=lambda sig: uwsgi.add_cron(int(sig), *args))(func_action_wrapper)\n\n    return decor", "response": "Register a cron for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntruncates a line to the specified length followed by... unless it s shorter than length already.", "response": "def truncate_ellipsis(line, length=30):\n    \"\"\"Truncate a line to the specified length followed by ``...`` unless its shorter than length already.\"\"\"\n\n    l = len(line)\n    return line if l < length else line[:length - 3] + \"...\""}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pyle_evaluate(expressions=None, modules=(), inplace=False, files=None, print_traceback=False):\n\n    eval_globals = {}\n\n    eval_globals.update(STANDARD_MODULES)\n\n    for module_arg in modules or ():\n        for module in module_arg.strip().split(\",\"):\n            module = module.strip()\n            if module:\n                eval_globals[module] = __import__(module)\n\n    if not expressions:\n        # Default 'do nothing' program\n        expressions = ['line']\n\n    files = files or ['-']\n    eval_locals = {}\n    for file in files:\n        if file == '-':\n            file = sys.stdin\n\n        out_buf = sys.stdout if not inplace else StringIO.StringIO()\n\n        out_line = None\n        with (open(file, 'rb') if not hasattr(file, 'read') else file) as in_file:\n            for num, line in enumerate(in_file.readlines()):\n                was_whole_line = False\n                if line[-1] == '\\n':\n                    was_whole_line = True\n                    line = line[:-1]\n\n                expr = \"\"\n                try:\n                    for expr in expressions:\n                        words = [word.strip()\n                                 for word in re.split(r'\\s+', line)\n                                 if word]\n                        eval_locals.update({\n                            'line': line, 'words': words,\n                            'filename': in_file.name, 'num': num\n                            })\n\n                        out_line = eval(expr, eval_globals, eval_locals)\n\n                        if out_line is None:\n                            continue\n\n                        # If the result is something list-like or iterable,\n                        # output each item space separated.\n                        if not isinstance(out_line, str) and not isinstance(out_line, unicode):\n                            try:\n                                out_line = u' '.join(unicode(part)\n                                                     for part in out_line)\n                            except:\n                                # Guess it wasn't a list after all.\n                                out_line = unicode(out_line)\n\n                        line = out_line\n                except Exception as e:\n                    sys.stdout.flush()\n                    sys.stderr.write(\"At %s:%d ('%s'): `%s`: %s\\n\" % (\n                        in_file.name, num, truncate_ellipsis(line), expr, e))\n                    if print_traceback:\n                        traceback.print_exc(None, sys.stderr)\n                else:\n                    if out_line is None:\n                        continue\n\n                    out_line = out_line or u''\n                    out_buf.write(out_line)\n                    if was_whole_line:\n                        out_buf.write('\\n')\n        if inplace:\n            with open(file, 'wb') as out_file:\n                out_file.write(out_buf.getvalue())\n            out_buf.close()", "response": "The main method of pyle."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute pyle with the specified arguments or sys. argv if no arguments specified.", "response": "def pyle(argv=None):\n    \"\"\"Execute pyle with the specified arguments, or sys.argv if no arguments specified.\"\"\"\n\n    parser = argparse.ArgumentParser(description=__doc__)\n\n    parser.add_argument(\"-m\", \"--modules\", dest=\"modules\", action='append',\n        help=\"import MODULE before evaluation. May be specified more than once.\")\n    parser.add_argument(\"-i\", \"--inplace\", dest=\"inplace\", action='store_true', default=False,\n        help=\"edit files in place. When used with file name arguments, the files will be replaced by the output of the evaluation\")\n    parser.add_argument(\"-e\", \"--expression\", action=\"append\",\n        dest=\"expressions\", help=\"an expression to evaluate for each line\")\n    parser.add_argument('files', nargs='*',\n        help=\"files to read as input. If used with --inplace, the files will be replaced with the output\")\n    parser.add_argument(\"--traceback\", action=\"store_true\", default=False,\n        help=\"print a traceback on stderr when an expression fails for a line\")\n\n    args = parser.parse_args() if not argv else parser.parse_args(argv)\n\n    pyle_evaluate(args.expressions, args.modules, args.inplace, args.files,\n                  args.traceback)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert the arpabet to the international phonetic alphabet.", "response": "def convert_to_international_phonetic_alphabet(self, arpabet):\n        '''\n        \u8f6c\u6362\u6210\u56fd\u9645\u97f3\u6807\n        :param arpabet:\n        :return:\n        '''\n\n        word = self._convert_to_word(arpabet=arpabet)\n\n        if not word:\n            return None\n\n        return word.translate_to_international_phonetic_alphabet()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convert_to_american_phonetic_alphabet(self, arpabet):\n        '''\n        \u8f6c\u6362\u6210\u7f8e\u97f3\n        :param arpabet:\n        :return:\n        '''\n\n        word = self._convert_to_word(arpabet=arpabet)\n\n        if not word:\n            return None\n\n        return word.translate_to_american_phonetic_alphabet()", "response": "Convert the arpabet to a list of american phonetic alphabets."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convert_to_english_phonetic_alphabet(self, arpabet):\n        '''\n        \u8f6c\u6362\u6210\u82f1\u97f3\n        :param arpabet:\n        :return:\n        '''\n\n        word = self._convert_to_word(arpabet=arpabet)\n\n        if not word:\n            return None\n\n        return word.translate_to_english_phonetic_alphabet()", "response": "Convert the arpabet to a non - English alphabet."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef translate_to_arpabet(self):\n        '''\n        \u8f6c\u6362\u6210arpabet\n        :return:\n        '''\n\n        translations = []\n\n        for phoneme in self._phoneme_list:\n            if phoneme.is_vowel:\n                translations.append(phoneme.arpabet + self.stress.mark_arpabet())\n            else:\n                translations.append(phoneme.arpabet)\n\n        return \" \".join(translations)", "response": "Translate the list of phonemes to the ARPabet."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntranslate the list of phonemes to a list of AMerican letters.", "response": "def translate_to_american_phonetic_alphabet(self, hide_stress_mark=False):\n        '''\n        \u8f6c\u6362\u6210\u7f8e\u97f3\u97f3\u3002\u53ea\u8981\u4e00\u4e2a\u5143\u97f3\u7684\u65f6\u5019\u9700\u8981\u9690\u85cf\u91cd\u97f3\u6807\u8bc6\n        :param hide_stress_mark:\n        :return:\n\n        '''\n\n        translations = self.stress.mark_ipa() if (not hide_stress_mark) and self.have_vowel else \"\"\n\n        for phoneme in self._phoneme_list:\n            translations += phoneme.american\n\n        return translations"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef translate_to_english_phonetic_alphabet(self, hide_stress_mark=False):\n        '''\n        \u8f6c\u6362\u6210\u82f1\u97f3\u3002\u53ea\u8981\u4e00\u4e2a\u5143\u97f3\u7684\u65f6\u5019\u9700\u8981\u9690\u85cf\u91cd\u97f3\u6807\u8bc6\n        :param hide_stress_mark:\n        :return:\n        '''\n\n        translations = self.stress.mark_ipa() if (not hide_stress_mark) and self.have_vowel else \"\"\n\n        for phoneme in self._phoneme_list:\n            translations += phoneme.english\n\n        return translations", "response": "Translate the list of phonemes to their English alphabet."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntranslates to international phonetic alphabet.", "response": "def translate_to_international_phonetic_alphabet(self, hide_stress_mark=False):\n        '''\n        \u8f6c\u6362\u6210\u56fd\u9645\u97f3\u6807\u3002\u53ea\u8981\u4e00\u4e2a\u5143\u97f3\u7684\u65f6\u5019\u9700\u8981\u9690\u85cf\u91cd\u97f3\u6807\u8bc6\n        :param hide_stress_mark:\n        :return:\n        '''\n\n        translations = self.stress.mark_ipa() if (not hide_stress_mark) and self.have_vowel else \"\"\n\n        for phoneme in self._phoneme_list:\n            translations += phoneme.ipa\n\n        return translations"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes and returns the login form component", "response": "def get_login_form_component(self):\n        \"\"\"Initializes and returns the login form component\n\n        @rtype: LoginForm\n        @return: Initialized component\n        \"\"\"\n        self.dw.wait_until(\n            lambda: self.dw.is_present(LoginForm.locators.form),\n            failure_message='login form was never present so could not get the model '\n                            'upload form component'\n        )\n\n        self.login_form = LoginForm(\n            parent_page=self,\n            element=self.dw.find(LoginForm.locators.form),\n        )\n        return self.login_form"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef objectify(dictionary, name='Object'):\n    o = namedtuple(name, dictionary.keys())(*dictionary.values())\n\n    return o", "response": "Converts a dictionary into a named tuple"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_directory(directory):\n    try:\n        os.makedirs(directory)\n    except OSError, e:\n        if e.errno == errno.EEXIST and os.path.isdir(directory):\n            pass\n\n    return directory", "response": "Creates a directory if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __add_query_comment(sql):\n        # Inspect the call stack for the originating call\n        file_name = ''\n        line_number = ''\n        caller_frames = inspect.getouterframes(inspect.currentframe())\n        for frame in caller_frames:\n            if \"ShapewaysDb\" not in frame[1]:\n                file_name = frame[1]\n                line_number = str(frame[2])\n                break\n\n        comment = \"/*COYOTE: Q_SRC: {file}:{line} */\\n\".format(file=file_name, line=line_number)\n        return comment + sql,", "response": "Adds a comment line to the query to be executed containing the line number of the calling\n        function."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an instance of class_type populated with attributes from the DB record ; throws an error if no records are found", "response": "def get_single_instance(sql, class_type, *args, **kwargs):\n        \"\"\"Returns an instance of class_type populated with attributes from the DB record; throws an error if no\n        records are found\n\n        @param sql: Sql statement to execute\n        @param class_type: The type of class to instantiate and populate with DB record\n        @return: Return an instance with attributes set to values from DB\n        \"\"\"\n        record = CoyoteDb.get_single_record(sql, *args, **kwargs)\n        try:\n            instance = CoyoteDb.get_object_from_dictionary_representation(dictionary=record, class_type=class_type)\n        except AttributeError:\n            raise NoRecordsFoundException('No records found for {class_type} with sql run on {host}: \\n {sql}'.format(\n                sql=sql,\n                host=DatabaseConfig().get('mysql_host'),\n                class_type=class_type\n            ))\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_all_instances(sql, class_type, *args, **kwargs):\n        records = CoyoteDb.get_all_records(sql, *args, **kwargs)\n        instances = [CoyoteDb.get_object_from_dictionary_representation(\n            dictionary=record, class_type=class_type) for record in records]\n        for instance in instances:\n            instance._query = sql\n        return instances", "response": "Returns a list of instances of class_type populated with attributes from the DB record\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nescape dictionary values with keys as column names and values column names and values column values", "response": "def escape_dictionary(dictionary, datetime_format='%Y-%m-%d %H:%M:%S'):\n        \"\"\"Escape dictionary values with keys as column names and values column values\n\n        @type dictionary: dict\n        @param dictionary: Key-values\n        \"\"\"\n        for k, v in dictionary.iteritems():\n            if isinstance(v, datetime.datetime):\n                v = v.strftime(datetime_format)\n\n            if isinstance(v, basestring):\n                v = CoyoteDb.db_escape(str(v))\n                v = '\"{}\"'.format(v)\n\n            if v is True:\n                v = 1\n\n            if v is False:\n                v = 0\n\n            if v is None:\n                v = 'NULL'\n\n            dictionary[k] = v"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_insert_fields_and_values_from_dict(dictionary, datetime_format='%Y-%m-%d %H:%M:%S', db_escape=True):\n        if db_escape:\n            CoyoteDb.escape_dictionary(dictionary, datetime_format=datetime_format)\n\n        fields = get_delimited_string_from_list(dictionary.keys(), delimiter=',')  # keys have no quotes\n        vals = get_delimited_string_from_list(dictionary.values(), delimiter=',')  # strings get quotes\n\n        return fields, vals", "response": "Formats a dictionary to strings of fields and values for insert statements\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_kwargs(**kwargs):\n        d = dict()\n        for k, v in kwargs.iteritems():\n            if v is not NOTSET:\n                d[k] = v\n        return d", "response": "This method should be used in query functions where user can query on any number of fields\n            >>>"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_update_clause_from_dict(dictionary, datetime_format='%Y-%m-%d %H:%M:%S'):\n        items = []\n\n        CoyoteDb.escape_dictionary(dictionary, datetime_format=datetime_format)\n        for k,v in dictionary.iteritems():\n            item = '{k} = {v}'.format(k=k, v=v)\n            items.append(item)\n        clause = ', '.join(item for item in items)\n        return clause", "response": "Builds an update values clause based on the dictionary representation of an an\n        instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds a where clause from a dictionary", "response": "def get_where_clause_from_dict(dictionary, join_operator='AND'):\n        \"\"\"Builds a where clause from a dictionary\n        \"\"\"\n        CoyoteDb.escape_dictionary(dictionary)\n        clause = join_operator.join(\n            (' {k} is {v} ' if str(v).lower() == 'null' else ' {k} = {v} ').format(k=k, v=v)  # IS should be the operator for null values\n            for k, v in dictionary.iteritems())\n        return clause"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_dictionary_representation_of_object_attributes(obj, omit_null_fields=False):\n        obj_dictionary = obj.__dict__\n\n        obj_dictionary_temp = obj_dictionary.copy()\n        for k, v in obj_dictionary.iteritems():\n            if omit_null_fields:\n                if v is None:\n                    obj_dictionary_temp.pop(k, None)\n            if k.startswith('_'):\n                obj_dictionary_temp.pop(k, None)\n\n        return obj_dictionary_temp", "response": "Returns a dictionary of the object s attributes ignoring methods\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_object_from_dictionary_representation(dictionary, class_type):\n        assert inspect.isclass(class_type), 'Cannot instantiate an object that is not a class'\n\n        instance = class_type()\n\n        CoyoteDb.update_object_from_dictionary_representation(dictionary, instance)\n\n        return instance", "response": "Instantiates a new class that takes a dictionary representation and populates its attributes with a dictionary\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconstructs the where clause based on a dictionary of mappings", "response": "def build_where_clause(mappings, operator='AND'):\n        \"\"\"Constructs the where clause based on a dictionary of values\n\n        >>> build_where_clause({'id': 456, 'name': 'myrecord'}, operator='OR')\n        >>> 'WHERE id = 456 OR name = \"myrecord\" '\n\n        \"\"\"\n        where_clause_mappings = {}\n        where_clause_mappings.update(mappings)\n\n        where_clause = 'WHERE ' + ' {} '.format(operator).join(\n            '{k} = {v}'.format(k=k, v='\"{}\"'.format(v) if isinstance(v, basestring) else v)\n            for k, v in where_clause_mappings.iteritems()\n        )\n        return where_clause"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes the sql statement but does not commit. Returns the cursor to commit", "response": "def execute(*args, **kwargs):\n        \"\"\"Executes the sql statement, but does not commit. Returns the cursor to commit\n\n        @return: DB and cursor instance following sql execution\n        \"\"\"\n\n        # Inspect the call stack for the originating call\n        args = CoyoteDb.__add_query_comment(args[0])\n        db = CoyoteDb.__get_db_write_instance(target_database=kwargs.pop('target_database', None))\n        filtered_kwargs = {k: v for k, v in kwargs.iteritems() if k != 'target_database'}\n\n        # Execute the query\n        cursor = db.cursor()\n        try:\n            cursor.execute(*args, **filtered_kwargs)\n        except OperationalError, e:\n            raise OperationalError('{} when executing: {}'.format(e.args, args[0]))\n        return db, cursor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute the sql statement but does not commit. Returns the cursor to commit", "response": "def execute_read_only(*args, **kwargs):\n        # TODO: consolidate with execute\n        \"\"\"Executes the sql statement, but does not commit. Returns the cursor to commit\n\n        @return: DB and cursor instance following sql execution\n        \"\"\"\n\n        # Inspect the call stack for the originating call\n        args = CoyoteDb.__add_query_comment(args[0])\n\n        # Execute the query\n        db = CoyoteDb.__get_db_read_instance()\n        cursor = db.cursor()\n        try:\n            cursor.execute(*args, **kwargs)\n        except OperationalError, e:\n            raise OperationalError('{} when executing: {}'.format(e.args, args[0]))\n        return db, cursor"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute the sql statement and commits the sql statement", "response": "def execute_and_commit(*args, **kwargs):\n        \"\"\"Executes and commits the sql statement\n\n        @return: None\n        \"\"\"\n        db, cursor = CoyoteDb.execute(*args, **kwargs)\n        db.commit()\n        return cursor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate and commits with an insert sql statement returns the record", "response": "def update(sql, *args, **kwargs):\n        \"\"\"Updates and commits with an insert sql statement, returns the record, but with a small chance of a race\n        condition\n\n        @param sql: sql to execute\n        @return: The last row inserted\n        \"\"\"\n        assert \"update\" in sql.lower(), 'This function requires an update statement, provided: {}'.format(sql)\n        cursor = CoyoteDb.execute_and_commit(sql, *args, **kwargs)\n\n        # now get that id\n        last_row_id = cursor.lastrowid\n\n        return last_row_id"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting and commits with an insert sql statement", "response": "def delete(sql, *args, **kwargs):\n        \"\"\"Deletes and commits with an insert sql statement\"\"\"\n        assert \"delete\" in sql.lower(), 'This function requires a delete statement, provided: {}'.format(sql)\n        CoyoteDb.execute_and_commit(sql, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a dictionary and an object instance will set all object attributes equal to the dictionary s keys and values.", "response": "def update_object_from_dictionary_representation(dictionary, instance):\n        \"\"\"Given a dictionary and an object instance, will set all object attributes equal to the dictionary's keys and\n        values. Assumes dictionary does not have any keys for which object does not have attributes\n\n        @type dictionary: dict\n        @param dictionary: Dictionary representation of the object\n        @param instance: Object instance to populate\n        @return: None\n        \"\"\"\n        for key, value in dictionary.iteritems():\n            if hasattr(instance, key):\n                setattr(instance, key, value)\n\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat a time to be Shapeways database - compatible with the spec.", "response": "def format_time(time):\n        \"\"\"Formats a time to be Shapeways database-compatible\n\n        @param time: Datetime or string object to format\n        @rtype: str\n        @return: Time formatted as a string\n        \"\"\"\n        # Handle time typing\n        try:\n            time = time.isoformat()\n        except AttributeError:  # Not a datetime object\n            time = str(time)\n\n        time = parser.parse(time).strftime('%Y-%m-%d %H:%M:%S')\n        return time"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat a date to be Shapeways database - compatible with the spec.", "response": "def format_date(date):\n        \"\"\"Formats a date to be Shapeways database-compatible\n\n        @param date: Datetime or string object to format\n        @rtype: str\n        @return: Date formatted as a string\n        \"\"\"\n        # Handle time typing\n        try:\n            date = date.isoformat()\n        except AttributeError:  # Not a datetime object\n            date = str(date)\n\n        date = parser.parse(date).strftime('%Y-%m-%d')\n        return date"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_alert_present(self):\n        current_frame = None\n        try:\n            current_frame = self.driver.current_window_handle\n            a = self.driver.switch_to_alert()\n            a.text\n        except NoAlertPresentException:\n            # No alert\n            return False\n        except UnexpectedAlertPresentException:\n            # Alert exists\n            return True\n        finally:\n            if current_frame:\n                self.driver.switch_to_window(current_frame)\n        return True", "response": "Tests if an alert is present\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find(self, locator, find_all=False, search_object=None, force_find=False, exclude_invisible=False):\n        search_object = self.driver if search_object is None else search_object\n        attempts = 0\n\n        while attempts < self.find_attempts + 1:\n            if bool(force_find):\n                js_locator = self.locator_handler.parse_locator(locator)\n\n                if js_locator.By != 'css selector':\n                    raise ValueError(\n                        'You must use a css locator in order to force find an element; this was \"{}\"'.format(\n                            js_locator))\n\n                elements = self.js_executor.execute_template_and_return_result(\n                    'getElementsTemplate.js', variables={'selector': js_locator.value})\n            else:\n                elements = self.locator_handler.find_by_locator(search_object, locator, True)\n\n            # Save original elements found before applying filters to the list\n            all_elements = elements\n\n            # Check for only visible elements\n            visible_elements = elements\n            if exclude_invisible:\n                visible_elements = [element for element in all_elements if element.is_displayed()]\n                elements = visible_elements\n\n            if len(elements) > 0:\n                if find_all is True:\n                    # return list of wrapped elements\n                    for index in range(len(elements)):\n                        elements[index] = WebElementWrapper.WebElementWrapper(self, locator, elements[index],\n                                                                              search_object=search_object)\n\n                    return elements\n\n                elif find_all is False:\n                    # return first element\n                    return WebElementWrapper.WebElementWrapper(self, locator, elements[0], search_object=search_object)\n\n            else:\n                if attempts >= self.find_attempts:\n                    if find_all is True:  # returns an empty list if finding all elements\n                        return []\n                    else:  # raise exception if attempting to find one element\n                        error_message = \"Unable to find element after {0} attempts with locator: {1}\".format(\n                            attempts,\n                            locator\n                        )\n\n                        # Check if filters limited the results\n                        if exclude_invisible and len(visible_elements) == 0 and len(all_elements) > 0:\n                            error_message = \"Elements found using locator {}, but none were visible\".format(locator)\n\n                        raise WebDriverWrapperException.WebDriverWrapperException(self, error_message)\n                else:\n                    attempts += 1", "response": "Find an element by the given locator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nattempting to find elements on the page without waiting .", "response": "def _find_immediately(self, locator, search_object=None):\n        '''\n        Attempts to immediately find elements on the page without waiting\n\n        @type locator:          webdriverwrapper.support.locator.Locator\n        @param locator:         Locator object describing\n        @type search_object:    webdriverwrapper.WebElementWrapper\n        @param search_object:   Optional WebElement to start search with.  If null, search will be on self.driver\n\n\n        @return:                Single WebElemetnWrapper if find_all is False,\n                                list of WebElementWrappers if find_all is True\n        '''\n        search_object = self.driver if search_object is None else search_object\n        elements = self.locator_handler.find_by_locator(search_object, locator, True)\n        return [WebElementWrapper.WebElementWrapper(self, locator, element) for element in elements]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_all(self, locator, search_object=None, force_find=False):\n        '''\n        Find all elements matching locator\n\n        @type locator:          webdriverwrapper.support.locator.Locator\n        @param locator:         Locator object describing\n\n        @rtype:                 list[WebElementWrapper]\n        @return:                list of WebElementWrappers\n        '''\n        return self.find(locator=locator, find_all=True, search_object=search_object, force_find=force_find)", "response": "Find all elements matching locator"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_by_dynamic_locator(self, template_locator, variables, find_all=False, search_object=None):\n        '''\n        Find with dynamic locator\n\n        @type template_locator:         webdriverwrapper.support.locator.Locator\n        @param template_locator:        Template locator w/ formatting bits to insert\n        @type variables:                dict\n        @param variables:               Dictionary of variable substitutions\n        @type find_all:                 bool\n        @param find_all:                True to find all elements immediately, False for find single element only\n        @type search_object:            webdriverwrapper.WebElementWrapper\n        @param search_object:           Optional WebElement to start search with.\n                                        If null, search will be on self.driver\n\n        @rtype:                         webdriverwrapper.WebElementWrapper or list()\n        @return:                        Single WebElemetnWrapper if find_all is False,\n                                        list of WebElementWrappers if find_all is True\n        '''\n        template_variable_character = '%'\n        # raise an exception if user passed non-dictionary variables\n        if not isinstance(variables, dict):\n            raise TypeError('You must use a dictionary to populate locator variables')\n\n        # replace all variables that match the keys in 'variables' dict\n        locator = \"\"\n        for key in variables.keys():\n            locator = template_locator.replace(template_variable_character + key, variables[key])\n\n        return self.find(locator, find_all, search_object)", "response": "Find with dynamic locator."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetermines if an element is present on the page retrying once if unable to locate", "response": "def is_present(self, locator, search_object=None):\n        \"\"\"\n        Determines whether an element is present on the page, retrying once if unable to locate\n\n        @type locator:                  webdriverwrapper.support.locator.Locator\n        @param locator:                 the locator or css string used to query the element\n        @type search_object:            webdriverwrapper.WebElementWrapper\n        @param search_object:           Optional WebElement to start search with.\n                                        If null, search will be on self.driver\n        \"\"\"\n        all_elements = self._find_immediately(locator, search_object=search_object)\n\n        if all_elements is not None and len(all_elements) > 0:\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines whether an element is present on the page with no wait.", "response": "def is_present_no_wait(self, locator):\n        \"\"\"\n        Determines whether an element is present on the page with no wait\n\n        @type locator:  webdriverwrapper.support.locator.Locator\n        @param locator: the locator or css string used to query the element\n        \"\"\"\n\n        # first attempt to locate the element\n\n        def execute():\n            '''\n            Generic function to execute wait\n            '''\n            return True if len(self.locator_handler.find_by_locator(self.driver, locator, True)) < 0 else False\n\n        return self.execute_and_handle_webdriver_exceptions(\n            execute, timeout=0, locator=locator, failure_message='Error running webdriver.find_all.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wait_until(self, wait_function, failure_message=None, timeout=None):\n        timeout = timeout if timeout is not None else self.timeout\n        failure_message = failure_message if failure_message is not None else \\\n            'Timeout waiting for custom function to return True'\n\n        def wait():\n            '''\n            Wait function passed to executor\n            '''\n            return WebDriverWait(self, timeout).until(lambda dw: wait_function())\n\n        return self.execute_and_handle_webdriver_exceptions(wait, timeout, None, failure_message)", "response": "Base wait method that executes wait_function and returns True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wait_until_present(self, locator, timeout=None, failure_message='Timeout waiting for element to be present'):\n        timeout = timeout if timeout is not None else self.timeout\n\n        def wait():\n            '''\n            Wait function passed to executor\n            '''\n            element = WebDriverWait(self.driver, timeout).until(EC.presence_of_element_located(\n                (self.locator_handler.parse_locator(locator).By, self.locator_handler.parse_locator(locator).value)))\n            return WebElementWrapper.WebElementWrapper(self, locator, element)\n\n        return self.execute_and_handle_webdriver_exceptions(\n            wait, timeout, locator, failure_message=failure_message)", "response": "Waits until an element is present"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wait_until_not_present(self, locator, timeout=None):\n        # TODO: rethink about neg case with is_present and waiting too long\n        timeout = timeout if timeout is not None else self.timeout\n        this = self  # for passing WebDriverWrapperReference to WebDriverWait\n\n        def wait():\n            '''\n            Wait function pasted to executor\n            '''\n            return WebDriverWait(self.driver, timeout).until(lambda d: not this.is_present(locator))\n\n        return self.execute_and_handle_webdriver_exceptions(\n            wait, timeout, locator, 'Timeout waiting for element not to be present')", "response": "Wait until an element with the given locator is not present."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwait until an element is invisible", "response": "def wait_until_invisibility_of(self, locator, timeout=None):\n        \"\"\"\n        Waits for an element to be invisible\n\n        @type locator:  webdriverwrapper.support.locator.Locator\n        @param locator: the locator or css string to search for the element\n        @type timeout:  int\n        @param timeout:  the maximum number of seconds the driver will wait before timing out\n\n        @rtype:                 webdriverwrapper.WebElementWrapper\n        @return:                Returns the element found\n        \"\"\"\n        timeout = timeout if timeout is not None else self.timeout\n\n        def wait():\n            '''\n            Wait function passed to executor\n            '''\n            element = WebDriverWait(self.driver, timeout).until(EC.invisibility_of_element_located(\n                (self.locator_handler.parse_locator(locator).By, self.locator_handler.parse_locator(locator).value)))\n            return WebElementWrapper.WebElementWrapper(self, locator, element)\n\n        return self.execute_and_handle_webdriver_exceptions(\n            wait, timeout, locator, 'Timeout waiting for element to be invisible')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwaiting for an element to be clickable", "response": "def wait_until_clickable(self, locator, timeout=None):\n        \"\"\"\n        Waits for an element to be clickable\n\n        @type locator:  webdriverwrapper.support.locator.Locator\n        @param locator: the locator or css string to search for the element\n        @type timeout:  int\n        @param timeout:  the maximum number of seconds the driver will wait before timing out\n\n        @rtype:                 webdriverwrapper.WebElementWrapper\n        @return:                Returns the element found\n        \"\"\"\n        timeout = timeout if timeout is not None else self.timeout\n\n        def wait():\n            '''\n            Wait function passed to executor\n            '''\n            element = WebDriverWait(self.driver, timeout).until(EC.element_to_be_clickable(\n                (self.locator_handler.parse_locator(locator).By, self.locator_handler.parse_locator(locator).value)))\n\n            return WebElementWrapper.WebElementWrapper(self, locator, element)\n\n        return self.execute_and_handle_webdriver_exceptions(\n            wait, timeout, locator, 'Timeout waiting for element to be clickable')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef wait_until_stale(self, locator, timeout=None):\n        timeout = timeout if timeout is not None else self.timeout\n\n        def wait():\n            '''\n            Wait function passed to executor\n            '''\n            element = WebDriverWait(self.driver, timeout).until(EC.staleness_of(\n                (self.locator_handler.parse_locator(locator).By, self.locator_handler.parse_locator(locator).value)))\n\n            return WebElementWrapper.WebElementWrapper(self, locator, element)\n\n        return self.execute_and_handle_webdriver_exceptions(\n            wait, timeout, locator, 'Timeout waiting for element to become stale')", "response": "Waits until an element is found in the DOM and returns the element found\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wait_until_title_contains(self, partial_title, timeout=None):\n        timeout = timeout if timeout is not None else self.timeout\n\n        def wait():\n            '''\n            Wait function passed to executor\n            '''\n            return WebDriverWait(self.driver, timeout).until(EC.title_contains(partial_title))\n\n        return self.execute_and_handle_webdriver_exceptions(\n            wait, timeout, partial_title, 'Timeout waiting for title to contain: ' + str(partial_title))", "response": "Waits until the title contains the partial_title"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wait_until_title_is(self, title, timeout=None):\n        timeout = timeout if timeout is not None else self.timeout\n\n        def wait():\n            '''\n            Wait function passed to executor\n            '''\n            return WebDriverWait(self.driver, timeout).until(EC.title_is(title))\n\n        return self.execute_and_handle_webdriver_exceptions(\n            wait, timeout, title, 'Timeout waiting for title to be: ' + str(title))", "response": "Waits until the title is exactly the given one."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wait_until_alert_is_present(self, timeout=None):\n        timeout = timeout if timeout is not None else self.timeout\n        locator = None\n\n        def wait():\n            '''\n            Wait function passed to executor\n            '''\n            return WebDriverWait(self.driver, timeout).until(EC.alert_is_present())\n\n        return self.execute_and_handle_webdriver_exceptions(\n            wait, timeout, locator, 'Timeout waiting for alert to be present')", "response": "Waits until an alert is present in the element"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwaits for an element s text to contain text", "response": "def wait_until_text_contains(self, locator, text, timeout=None):\n        \"\"\"\n        Waits for an element's text to contain <text>\n\n        @type locator:          webdriverwrapper.support.locator.Locator\n        @param locator:         locator used to find element\n        @type text:             str\n        @param text:            the text to search for\n        @type timeout:          int\n        @param timeout:         the maximum number of seconds the driver will wait before timing out\n\n        @rtype:                 webdriverwrapper.WebElementWrapper\n        @return:                Returns the element found\n        \"\"\"\n        timeout = timeout if timeout is not None else self.timeout\n        this = self\n\n        self.wait_for(locator) # first check that element exists\n\n        def wait():\n            '''\n            Wait function passed to executor\n            '''\n            WebDriverWait(self.driver, timeout).until(lambda d: text in this.find(locator).text())\n            return this.find(locator)\n\n        return self.execute_and_handle_webdriver_exceptions(\n            wait, timeout, locator, 'Timeout waiting for text to contain: ' + str(text))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwaiting for an element s text to not be empty", "response": "def wait_until_text_is_not_empty(self, locator, timeout=None):\n        \"\"\"\n        Waits for an element's text to not be empty\n\n        @type locator:          webdriverwrapper.support.locator.Locator\n        @param locator:         locator used to find element\n        @type timeout:          int\n        @param timeout:         the maximum number of seconds the driver will wait before timing out\n\n        @rtype:                 webdriverwrapper.WebElementWrapper\n        @return:                Returns the element found\n        \"\"\"\n        timeout = timeout if timeout is not None else self.timeout\n\n        self.wait_for(locator) # first check that element exists\n\n        def wait():\n            '''\n            Wait function passed to executor\n            '''\n            WebDriverWait(self.driver, timeout).until(lambda d: len(self.find(locator).text()) > 0)\n            return self.find(locator)\n\n        return self.execute_and_handle_webdriver_exceptions(\n            wait, timeout, locator, 'Timeout waiting for element to contain some text')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwait until the page source contains the given text.", "response": "def wait_until_page_source_contains(self, text, timeout=None):\n        \"\"\"\n        Waits for the page source to contain <text>\n\n        @type text:             str\n        @param text:            the text to search for\n        @type timeout:          int\n        @param timeout:         the maximum number of seconds the driver will wait before timing out\n\n        @rtype:                 webdriverwrapper.WebElementWrapper\n        @return:                Returns the element found\n        \"\"\"\n        timeout = timeout if timeout is not None else self.timeout\n\n        def wait():\n            '''\n            Wait function passed to executor\n            '''\n            WebDriverWait(self.driver, timeout).until(lambda d: text in self.page_source())\n            return self.page_source()\n\n        return self.execute_and_handle_webdriver_exceptions(\n            wait, timeout, text, 'Timeout waiting for source to contain: {}'.format(text))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wait_until_jquery_requests_are_closed(self, timeout=None):\n        timeout = timeout if timeout is not None else self.timeout\n\n        def wait():\n            '''\n            Wait function passed to executor\n            '''\n            WebDriverWait(self.driver, timeout).until(\n                lambda d: self.js_executor.execute_template('isJqueryAjaxComplete', {}))\n            return True\n\n        return self.execute_and_handle_webdriver_exceptions(\n            wait, timeout, None, 'Timeout waiting for all jQuery AJAX requests to close')", "response": "Waits until all jQuery AJAX requests are closed"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef execute_and_handle_webdriver_exceptions(self, function_to_execute, timeout=None, locator=None, failure_message=None):\n        logger = logging.getLogger(__name__)\n        try:\n            val = function_to_execute()\n            for cb in self.action_callbacks:\n                cb.__call__(self)\n            return val\n\n        except TimeoutException:\n            raise WebDriverTimeoutException.WebDriverTimeoutException(self, timeout, locator, failure_message)\n\n        except httplib.BadStatusLine, e:\n            logger.error('BadStatusLine error raised on WebDriver action (line: {}, args:{}, message: {})'.format(\n                e.line,\n                e.args,\n                e.message\n            ))\n            raise\n        \n        except httplib.CannotSendRequest:\n            logger.error('CannotSendRequest error raised on WebDriver action')\n            raise\n\n        except UnexpectedAlertPresentException:\n            # NOTE: handling alerts in this way expects that WebDriver does not dismiss unexpected alerts. That\n            # setting can be changed by modifying the unexpectedAlertBehaviour setting\n            msg = '<failed to parse message from alert>'\n            try:\n                a = self.driver.switch_to_alert()\n                msg = a.text\n            except Exception, e:\n                msg = '<error parsing alert due to {} (note: parsing ' \\\n                      'alert text expects \"unexpectedAlertBehaviour\" to be set to \"ignore\")>'.format(e)\n                logger.critical(msg)\n            finally:\n                logger.error('Unexpected alert raised on a WebDriver action; alert message was: {}'.format(msg))\n                raise UnexpectedAlertPresentException('Unexpected alert on page, alert message was: \"{}\"'.format(msg))", "response": "Execute a function and handle any exceptions raised by the action callbacks."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pause_and_wait_for_user(self, timeout=None, prompt_text='Click to resume (WebDriver is paused)'):\n        timeout = timeout if timeout is not None else self.user_wait_timeout\n        # Set the browser state paused\n        self.paused = True\n\n        def check_user_ready(driver):\n            \"\"\"Polls for the user to be \"ready\" (meaning they checked the checkbox) and the driver to be unpaused.\n            If the checkbox is not displayed (e.g. user navigates the page), it will re-insert it into the page\n\n            @type driver: WebDriverWrapper\n            @param driver: Driver to execute\n            @return: True if user is ready, false if not\n            \"\"\"\n            if driver.paused:\n                if driver.is_user_ready():\n                    # User indicated they are ready; free the browser lock\n                    driver.paused = False\n                    return True\n                else:\n                    if not driver.is_present(Locator('css', '#webdriver-resume-radio', 'radio to unpause webdriver')):\n                        # Display the prompt\n                        pause_html = staticreader.read_html_file('webdriverpaused.html')\\\n                            .replace('\\n', '')\\\n                            .replace('PROMPT_TEXT', prompt_text)\n                        webdriver_style = staticreader.read_css_file('webdriverstyle.css').replace('\\n', '')\n\n\n                        # Insert the webdriver style\n                        driver.js_executor.execute_template_and_return_result(\n                            'injectCssTemplate.js',\n                            {'css': webdriver_style})\n\n                        # Insert the paused html\n                        driver.js_executor.execute_template_and_return_result(\n                            'injectHtmlTemplate.js',\n                            {'selector': 'body', 'html': pause_html})\n            return False\n\n        self.wait_until(\n            lambda: check_user_ready(self),\n            timeout=timeout,\n            failure_message='Webdriver actions were paused but did not receive the command to continue. '\n                            'You must click the on-screen message to resume.'\n        )\n\n        # Remove all injected elements\n        self.js_executor.execute_template_and_return_result(\n            'deleteElementsTemplate.js',\n            {'selector': '.webdriver-injected'}\n        )", "response": "Injects a radio button into the page and waits for the user to click it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_browser_log(self, levels=None):\n        logs = self.driver.get_log('browser')\n        self.browser_logs += logs\n        if levels is not None:\n            logs = [entry for entry in logs if entry.get(u'level') in levels]\n        return logs", "response": "Gets the console log of the browser"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncloses driver and kill all associated displays", "response": "def quit(self):\n        \"\"\"Close driver and kill all associated displays\n\n        \"\"\"\n        # Kill the driver\n\n        def _quit():\n            try:\n                self.driver.quit()\n            except Exception, err_driver:\n                os.kill(self.driver_pid, signal.SIGKILL)\n                raise\n            finally:\n                # Kill the display for this driver window\n                try:\n                    if self.display:\n                        self.display.stop()\n                except Exception, err_display:\n                    os.kill(self.display_pid, signal.SIGKILL)\n                    raise\n        return self.execute_and_handle_webdriver_exceptions(_quit)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvisit the url checking for rr errors in the response", "response": "def visit(self, url=''):\n        \"\"\"Visit the url, checking for rr errors in the response\n\n        @param url: URL\n        @return: Visit result\n        \"\"\"\n        result = super(CoyoteDriver, self).visit(url)\n        source = self.page_source()\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_config_vars(target_config, source_config):\n    # Overwrite all attributes in config with new config\n    for attr in dir(source_config):\n        # skip all private class attrs\n        if attr.startswith('_'):\n            continue\n        val = getattr(source_config, attr)\n        if val is not None:\n            setattr(target_config, attr, val)", "response": "Loads all attributes from source config into target config"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread all available config files and return a dict of all the config files.", "response": "def _readall(self):\n        \"\"\"Read configs from all available configs. It will read files in the following order:\n\n            1.) Read all default settings:\n\n                These are located under: `<project_root>/config/*/default.cfg`\n\n            2.) Read the user's config settings:\n\n                This is located on the path: `~/.aftrc`\n\n            3.) Read all config files specified by the config string in the environment variable TEST_RUN_SETTING_CONFIG\n\n                A config string such as \"browser.headless,scripts.no_ssh\" will read paths:\n\n                    `<project_root>/config/browser/headless.cfg`\n                    `<project_root>/config/scripts/no_ssh.cfg`\n\n                OR a config string such as \"<project_root>/config/browser/headless.cfg\" will load that path directly\n        \"\"\"\n        # First priority -- read all default configs\n        config_path = os.path.dirname(__file__)\n        config_defaults = [os.path.join(dirpath, f)\n                           for dirpath, dirnames, files in os.walk(config_path)\n                           for f in fnmatch.filter(files, 'default.cfg')]\n\n        # Second priority -- read the user overrides\n        user_config = os.path.expanduser('~/.aftrc')\n\n        # Third priority -- read the environment variable overrides\n        override_filenames = []\n        if TEST_RUN_SETTING_CONFIG in os.environ:\n            for test_config in os.environ[TEST_RUN_SETTING_CONFIG].split(','):\n                if os.path.exists(test_config):             #is this a file path\n                   override_filenames.append(test_config)\n                elif \".\" in test_config and not test_config.endswith('.cfg'):                    #else it might be in xxxx.yyyy format\n                    config_parts = test_config.split('.')\n                    config_parts[-1]+='.cfg' #add file ext to last part, which should be file\n                    filename = os.path.join(config_path, *config_parts)\n                    override_filenames.append(filename)\n                else:                                       #else unknown, might throw exception here\n                    pass\n\n\n        all_configs = config_defaults + [user_config] + override_filenames\n        return self.parser.read(all_configs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run_parallel(*functions):\n    def target(fn):\n        def wrapped(results_queue, error_queue, index):\n            result = None\n            try:\n                result = fn()\n            except Exception, e:  # Swallow errors or else the process will hang\n                error_queue.put(e)\n                warnings.warn('Exception raised in parallel threads: {}'.format(e))\n            results_queue.put((index, result))\n        return wrapped\n\n    errors = Queue()\n    queue = Queue()\n\n    jobs = list()\n    for i, function in enumerate(functions):\n        jobs.append(Process(target=target(function), args=(queue, errors, i)))\n\n    [job.start() for job in jobs]\n    [job.join() for job in jobs]\n\n    # Get the results in the queue and put them back in the order in which the function was specified in the args\n    results = [queue.get() for _ in jobs]\n    results = sorted(results, key=lambda x: x[0])\n\n    if not errors.empty():\n        error_list = list()\n        while not errors.empty():\n            error_list.append(errors.get())\n        raise ErrorInProcessException('Exceptions raised in parallel threads: {}'.format(error_list), errors=error_list)\n    return [r[1] for r in results]", "response": "Runs a series of functions in parallel."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an updated copy of the dictionary without modifying the original", "response": "def copy_and_update(dictionary, update):\n    \"\"\"Returns an updated copy of the dictionary without modifying the original\"\"\"\n    newdict = dictionary.copy()\n    newdict.update(update)\n    return newdict"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_static_directory():\n    directory = templates_dir = os.path.join(os.path.dirname(__file__), 'static')\n    return directory", "response": "Retrieves the full path of the static directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads the contents of an html file in the css directory", "response": "def read_html_file(filename):\n    \"\"\"Reads the contents of an html file in the css directory\n\n    @return: Contents of the specified file\n    \"\"\"\n    with open(os.path.join(get_static_directory(), 'html/{filename}'.format(filename=filename))) as f:\n        contents = f.read()\n    return contents"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_locator(locator):\n\n        # handle backwards compatibility to support new Locator class\n        if isinstance(locator, loc.Locator):\n            locator = '{by}={locator}'.format(by=locator.by, locator=locator.locator)\n\n        locator_tuple = namedtuple('Locator', 'By value')\n\n        if locator.count('=') > 0 and locator.count('css=') < 1:\n            by = locator[:locator.find('=')].replace('_', ' ')\n            value = locator[locator.find('=')+1:]\n            return locator_tuple(by, value)\n        else:  # assume default is css selector\n            value = locator[locator.find('=')+1:]\n            return locator_tuple('css selector', value)", "response": "Parses a valid selenium By and value from a locator ; returns as a named tuple with properties By and Value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_by_locator(webdriver_or_element, locator, find_all_elements=False):\n        # handle backwards compatibility to support new Locator class\n        if isinstance(locator, loc.Locator):\n            locator = '{by}={locator}'.format(by=locator.by, locator=locator.locator)\n\n        # use the appropriate find method given the locator type;\n        # locators should follow the convention \"css=.class\" or \"xpath=//div\"\n        # if locator type is unspecified, it will default to css\n        if (locator.count('css=') > 0  or locator.count('css_selector=')) and len(locator.split('=', 1)) > 1:\n            if find_all_elements:\n                return webdriver_or_element.find_elements_by_css_selector(locator.split('=', 1)[-1])\n            else:\n                return webdriver_or_element.find_element_by_css_selector(locator.split('=', 1)[-1])\n\n        elif locator.count('id=') > 0 and len(locator.split('=')) > 1:\n            if find_all_elements:\n                return webdriver_or_element.find_elements_by_id(locator.split('=', 1)[-1])\n            else:\n                return webdriver_or_element.find_element_by_id(locator.split('=', 1)[-1])\n\n        elif locator.count('xpath=') > 0 and len(locator.split('=')) > 1:\n            if find_all_elements:\n                return webdriver_or_element.find_elements_by_xpath(locator.split('=', 1)[-1])\n            else:\n                return webdriver_or_element.find_element_by_xpath(locator.split('=', 1)[-1])\n\n        elif locator.count('class_name=') > 0 and len(locator.split('=')) > 1:\n            if find_all_elements:\n                return webdriver_or_element.find_elements_by_class_name(locator.split('=', 1)[-1])\n            else:\n                return webdriver_or_element.find_element_by_class_name(locator.split('=', 1)[-1])\n\n        elif locator.count('link_text=') > 0 and len(locator.split('=')) > 1:\n            if find_all_elements:\n                return webdriver_or_element.find_elements_by_link_text(locator.split('=', 1)[-1])\n            else:\n                return webdriver_or_element.find_element_by_link_text(locator.split('=', 1)[-1])\n\n        elif locator.count('partial_link_text=') > 0 and len(locator.split('=')) > 1:\n            if find_all_elements:\n                return webdriver_or_element.find_elements_by_partial_link_text(locator.split('=', 1)[-1])\n            else:\n                return webdriver_or_element.find_element_by_partial_link_text(locator.split('=', 1)[-1])\n\n        elif locator.count('name=') > 0 and len(locator.split('=')) > 1:\n            if find_all_elements:\n                return webdriver_or_element.find_elements_by_name(locator.split('=', 1)[-1])\n            else:\n                return webdriver_or_element.find_element_by_name(locator.split('=', 1)[-1])\n\n        elif locator.count('tag_name=') > 0 and len(locator.split('=')) > 1:\n            if find_all_elements:\n                return webdriver_or_element.find_elements_by_tag_name(locator.split('=', 1)[-1])\n            else:\n                return webdriver_or_element.find_element_by_tag_name(locator.split('=', 1)[-1])\n\n        else:   # default to css\n            if find_all_elements:\n                return webdriver_or_element.find_elements_by_css_selector(locator)\n            else:\n                return webdriver_or_element.find_element_by_css_selector(locator)", "response": "Locate an element using a given locator"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nspin a given assertion function until it returns True.", "response": "def spin_assert(self, assertion, failure_message='Failed Assertion', timeout=None):\n        \"\"\"\n        Asserts that assertion function passed to it will return True,\n        trying every 'step' seconds until 'timeout' seconds have passed.\n        \"\"\"\n        timeout = self.timeout if timeout is None else timeout\n        time_spent = 0\n        while time_spent < timeout:\n            try:\n                assert assertion() is True\n                return True\n            except AssertionError:\n                pass\n            sleep(self.step)\n            time_spent += 1\n        raise WebDriverAssertionException.WebDriverAssertionException(self.driver_wrapper, failure_message)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef webdriver_assert(self, assertion, failure_message='Failed Assertion'):\n        try:\n            assert assertion() is True\n        except AssertionError:\n            raise WebDriverAssertionException.WebDriverAssertionException(self.driver_wrapper, failure_message)\n\n        return True", "response": "Assert the assertion and throw a WebDriverAssertionException"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntesting that a value is true for the current language.", "response": "def assert_true(self, value, failure_message='Expected value to be True, was: {}'):\n        \"\"\"\n        Asserts that a value is true\n\n        @type value:    bool\n        @param value:   value to test for True\n        \"\"\"\n        assertion = lambda: bool(value)\n        self.webdriver_assert(assertion, unicode(failure_message).format(value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef assert_equals(self, actual_val, expected_val, failure_message='Expected values to be equal: \"{}\" and \"{}\"'):\n        assertion = lambda: expected_val == actual_val\n        self.webdriver_assert(assertion, unicode(failure_message).format(actual_val, expected_val))", "response": "Calls smart_assert but creates a closure that calls it with the expected and provided values with the == operator."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest that two numbers are within an allowed delta of each other.", "response": "def assert_numbers_almost_equal(self, actual_val, expected_val, allowed_delta=0.0001,\n                                    failure_message='Expected numbers to be within {} of each other: \"{}\" and \"{}\"'):\n        \"\"\"\n        Asserts that two numbers are within an allowed delta of each other\n        \"\"\"\n        assertion = lambda: abs(expected_val - actual_val) <= allowed_delta\n        self.webdriver_assert(assertion, unicode(failure_message).format(allowed_delta, actual_val, expected_val))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling smart_assert but creates a closure that does not compare the expected and provided values.", "response": "def assert_not_equal(self, actual_val, unexpected_val, failure_message='Expected values to differ: \"{}\" and \"{}\"'):\n        \"\"\"\n        Calls smart_assert, but creates its own assertion closure using\n        the expected and provided values with the '!=' operator\n        \"\"\"\n        assertion = lambda: unexpected_val != actual_val\n        self.webdriver_assert(assertion, unicode(failure_message).format(actual_val, unexpected_val))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef assert_is(self, actual_val, expected_type, failure_message='Expected type to be \"{1},\" but was \"{0}\"'):\n        assertion = lambda: expected_type is actual_val\n        self.webdriver_assert(assertion, unicode(failure_message).format(actual_val, expected_type))", "response": "Calls smart_assert but creates a closure that calls it with the expected and provided values with the is operator."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall smart_assert but creates a closure that calls it with the expected and provided values with the is not operator.", "response": "def assert_is_not(self, actual_val, unexpected_type,\n                      failure_message='Expected type not to be \"{1},\" but was \"{0}\"'):\n        \"\"\"\n        Calls smart_assert, but creates its own assertion closure using\n        the expected and provided values with the 'is not' operator\n        \"\"\"\n        assertion = lambda: unexpected_type is not actual_val\n        self.webdriver_assert(assertion, unicode(failure_message).format(actual_val, unexpected_type))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef assert_in(self, actual_collection_or_string, expected_value, failure_message='Expected \"{1}\" to be in \"{0}\"'):\n        assertion = lambda: expected_value in actual_collection_or_string\n        self.webdriver_assert(assertion, unicode(failure_message).format(actual_collection_or_string, expected_value))", "response": "Calls smart_assert but creates a closure that calls smart_assert with the expected and provided values with the in operator"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling smart_assert but creates a closure that calls smart_assert with the expected and provided values with the not in operator", "response": "def assert_not_in(self, actual_collection_or_string, unexpected_value,\n                      failure_message='Expected \"{1}\" not to be in \"{0}\"'):\n        \"\"\"\n        Calls smart_assert, but creates its own assertion closure using\n        the expected and provided values with the 'not in' operator\n        \"\"\"\n        assertion = lambda: unexpected_value not in actual_collection_or_string\n        self.webdriver_assert(assertion, unicode(failure_message).format(actual_collection_or_string, unexpected_value))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntest that the page source contains the string passed in expected_value", "response": "def assert_page_source_contains(self, expected_value, failure_message='Expected page source to contain: \"{}\"'):\n        \"\"\"\n        Asserts that the page source contains the string passed in expected_value\n        \"\"\"\n        assertion = lambda: expected_value in self.driver_wrapper.page_source()\n        self.webdriver_assert(assertion, unicode(failure_message).format(expected_value))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef assert_union(self, collection1, collection2,\n                     failure_message='Expected overlap between collections: \"{}\" and \"{}\"'):\n        \"\"\"\n        Asserts that the union of two sets has at least one member (collections share at least one member)\n        \"\"\"\n        assertion = lambda: len(collection1 or collection2) > 0\n        failure_message = unicode(failure_message).format(collection1, collection2)\n        self.webdriver_assert(assertion, failure_message)", "response": "Assert that the union of two collections is not empty"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef assert_no_union(self, collection1, collection2,\n                        failure_message='Expected no overlap between collections: \"{}\" and \"{}\"'):\n        \"\"\"\n        Asserts that the union of two sets is empty (collections are unique)\n        \"\"\"\n        assertion = lambda: len(set(collection1).intersection(set(collection2))) == 0\n        failure_message = unicode(failure_message).format(collection1, collection2)\n        self.webdriver_assert(assertion, failure_message)", "response": "Assert that the union of two collections is empty"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef assert_subset(self, subset, superset, failure_message='Expected collection \"{}\" to be a subset of \"{}'):\n        assertion = lambda: set(subset).issubset(set(superset))\n        failure_message = unicode(failure_message).format(superset, subset)\n        self.webdriver_assert(assertion, failure_message)", "response": "Assert that a superset contains all elements of a subset of a set"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clear(self):\n        def clear_element():\n            \"\"\"\n            Wrapper to clear element\n            \"\"\"\n            return self.element.clear()\n        self.execute_and_handle_webelement_exceptions(clear_element, 'clear')\n        return self", "response": "Clears the field represented by this element and returns itself."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_content(self, max_chars=100):\n        def delete_content_element():\n            chars_deleted = 0\n            while len(self.get_attribute('value')) > 0 and chars_deleted < max_chars:\n                self.click()\n                self.send_keys(Keys.HOME)\n                self.send_keys(Keys.DELETE)\n                chars_deleted += 1\n\n        self.execute_and_handle_webelement_exceptions(delete_content_element, 'delete input contents')\n        return self", "response": "Deletes content in the input field by repeatedly typing HOME then DELETE."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclick the element using javascript", "response": "def click(self, force_click=False):\n        \"\"\"\n        Clicks the element\n\n        @type force_click:  bool\n        @param force_click: force a click on the element using javascript, skipping webdriver\n\n        @rtype:             WebElementWrapper\n        @return:            Returns itself\n        \"\"\"\n        js_executor = self.driver_wrapper.js_executor\n\n        def click_element():\n            \"\"\"\n            Wrapper to call click\n            \"\"\"\n            return self.element.click()\n\n        def force_click_element():\n            \"\"\"\n            Javascript wrapper to force_click the element\n            \"\"\"\n            js_executor.execute_template('clickElementTemplate', {}, self.element)\n            return True\n\n        if force_click:\n            self.execute_and_handle_webelement_exceptions(force_click_element, 'click element by javascript')\n        else:\n            self.execute_and_handle_webelement_exceptions(click_element, 'click')\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_value(self):\n        def get_element_value():\n            if self.tag_name() == 'input':\n                return self.get_attribute('value')\n            elif self.tag_name() == 'select':\n                selected_options = self.element.all_selected_options\n                if len(selected_options) > 1:\n                    raise ValueError(\n                        'Select {} has multiple selected options, only one selected '\n                        'option is valid for this method'.format(self)\n                    )\n                return selected_options[0].get_attribute('value')\n            else:\n                raise ValueError('Can not get the value of elements or type \"{}\"'.format(self.tag_name()))\n\n        return self.execute_and_handle_webelement_exceptions(get_element_value, name_of_action='get value')", "response": "Gets the value of the element with the specified name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_attribute(self, name):\n        def get_attribute_element():\n            \"\"\"\n            Wrapper to retrieve element\n            \"\"\"\n            return self.element.get_attribute(name)\n        return self.execute_and_handle_webelement_exceptions(get_attribute_element, 'get attribute \"' + str(name) + '\"')", "response": "Retrieves specified attribute from WebElement\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_on_screen(self):\n        width = self.get_width()\n        height = self.get_height()\n        loc = self.location()\n        el_x_left = loc['x']\n        el_x_right = el_x_left + width\n        el_y_top = loc['y']\n        el_y_bottom = el_y_top + height\n\n        screen_size = self.driver_wrapper.get_window_size()\n        screen_x = screen_size['width']\n        screen_y = screen_size['height']\n\n        if (((el_x_left > 0 and el_x_right < screen_x) or (el_x_right > 0 and el_x_right <screen_x)) and\n            ((el_y_top > 0 and el_y_top < screen_y) or (el_y_bottom > 0 and el_y_bottom > screen_y))\n        ):\n            return True\n        return False", "response": "Tests if the element is on the screen."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend special keys such as enter delete or delete.", "response": "def send_special_keys(self, value):\n        \"\"\"\n        Send special keys such as <enter> or <delete>\n\n        @rtype:     WebElementWrapper\n        @return:    Self\n        \"\"\"\n        def send_keys_element():\n            \"\"\"\n            Wrapper to send keys\n            \"\"\"\n            return self.element.send_keys(value)\n        self.execute_and_handle_webelement_exceptions(send_keys_element, 'send keys')\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting an input with a specified value.", "response": "def set(self, val, force_set=False):\n        \"\"\"\n        Sets an input with a specified value; if force_set=True, will set through javascript if webdriver fails\n        NOTE: if val is None, this function will interpret this to be an empty string\n\n        @type val:          str\n        @param val:         string to send to element\n        @type force_set:    bool\n        @param force_set:   Use javascript if True, webdriver if False\n        \"\"\"\n\n        if val is None:\n            val = \"\"\n\n        self.click(force_click=True if force_set else False)\n        self.clear()\n        self.send_keys(val)\n        actual = self.get_attribute('value')\n        if val != actual:\n            if force_set:\n                js_executor = self.driver_wrapper.js_executor\n\n                def force_set_element():\n                    \"\"\"\n                    Wrapper to force_set element via javascript if needed\n                    \"\"\"\n                    js_executor.execute_template('setValueTemplate', {'value': val}, self.element)\n                    return True\n                self.execute_and_handle_webelement_exceptions(force_set_element, 'set element by javascript')\n            else:\n                self.driver_wrapper.assertion.fail(\n                    'Setting text field failed because final text did not match input value: \"{}\" != \"{}\"'.format(\n                        actual,\n                        val\n                    )\n                )\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef submit(self):\n        def submit_element():\n            \"\"\"\n            Wrapper to submit element\n            \"\"\"\n            return self.element.submit()\n        self.execute_and_handle_webelement_exceptions(submit_element, 'send keys')\n        return self", "response": "Submit a webe element and return the self."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef value_of_css_property(self, property_name):\n        def value_of_css_property_element():\n            \"\"\"\n            Wrapper to get css property\n            \"\"\"\n            return self.element.value_of_css_property(property_name)\n        return self.execute_and_handle_webelement_exceptions(value_of_css_property_element, 'get css property \"' +\n                                                                                           str(property_name) + '\"')", "response": "Gets the value of a CSS property for the element"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntests if an element has a specific classname ; cannot contain spaces", "response": "def has_class(self, classname):\n        \"\"\"Test if an element has a specific classname\n\n        @type classname: str\n        @param classname: Classname to test for; cannot contain spaces\n        @rtype: bool\n        @return: True if classname exists; false otherwise\n        \"\"\"\n        def element_has_class():\n            \"\"\"Wrapper to test if element has a class\"\"\"\n            pattern = re.compile('(\\s|^){classname}(\\s|$)'.format(classname=classname))\n            classes = self.element.get_attribute('class')\n            matches = re.search(pattern, classes)\n\n            if matches is not None:\n                return True\n            return False\n\n        return self.execute_and_handle_webelement_exceptions(\n            element_has_class,\n            'check for element class \"{}\"'.format(classname)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parent(self):\n        def parent_element():\n            \"\"\"\n            Wrapper to retrieve parent element\n            \"\"\"\n            return WebElementWrapper(self.driver_wrapper, self.locator, self.element.parent)\n        return self.execute_and_handle_webelement_exceptions(parent_element, 'get parent')", "response": "Get the parent of the element"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parent_element(self):\n        def parent_element():\n            \"\"\"\n            Wrapper to get parent element\n            \"\"\"\n            parent = self.driver_wrapper.execute_script('return arguments[0].parentNode;', self.element)\n            wrapped_parent = WebElementWrapper(self.driver_wrapper, '', parent)\n            return wrapped_parent\n\n        return self.execute_and_handle_webelement_exceptions(parent_element, 'get parent element')", "response": "Get the parent of the element"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef text(self, force_get=False):\n        def text_element():\n            \"\"\"\n            Wrapper to get text of element\n            \"\"\"\n            return self.element.text\n\n        def force_text_element():\n            \"\"\"Get text by javascript\"\"\"\n            return self.driver_wrapper.js_executor.execute_template_and_return_result(\n                'getElementText.js', {}, self.element\n            )\n\n        if force_get:\n            return self.execute_and_handle_webelement_exceptions(force_text_element, 'get text by javascript')\n        else:\n            return self.execute_and_handle_webelement_exceptions(text_element, 'get text')", "response": "Get the text of the element"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef highlight(self):\n        js_executor = self.driver_wrapper.js_executor\n        def highlight_element():\n            \"\"\"\n            Wrapper to highlight elements\n            \"\"\"\n            location = self.element.location\n            size = self.element.size\n            js_executor.execute_template('elementHighlighterTemplate', {\n                'x': str(location['x']),\n                'y': str(location['y']),\n                'width': str(size['width']),\n                'height': str(size['height'])})\n            return True\n        self.execute_and_handle_webelement_exceptions(highlight_element, 'highlight')\n        return self", "response": "Highlights the elements in the element using javascript"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_attribute(self, name, value):\n        js_executor = self.driver_wrapper.js_executor\n        def set_attribute_element():\n            \"\"\"\n            Wrapper to set attribute\n            \"\"\"\n            js_executor.execute_template('setAttributeTemplate', {\n                'attribute_name': str(name),\n                'attribute_value': str(value)}, self.element)\n            return True\n        self.execute_and_handle_webelement_exceptions(set_attribute_element,\n                                                      'set attribute \"' + str(name) + '\" to \"' + str(value) + '\"')\n        return self", "response": "Sets the attribute of the element to a specified value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nselects an option by value text or index.", "response": "def select_option(self, value=None, text=None, index=None):\n        \"\"\"\n        Selects an option by value, text, or index. You must name the parameter\n\n        @type value:    str\n        @param value:   the value of the option\n        @type text:     str\n        @param text:    the option's visible text\n        @type index:    int\n        @param index:   the zero-based index of the option\n\n        @rtype:     WebElementWrapper\n        @return:    self\n        \"\"\"\n        def do_select():\n            \"\"\"\n            Perform selection\n            \"\"\"\n            return self.set_select('select', value, text, index)\n        return self.execute_and_handle_webelement_exceptions(do_select, 'select option')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_select(self, select_or_deselect = 'select', value=None, text=None, index=None):\n        # TODO: raise exception if element is not select element\n\n        if select_or_deselect is 'select':\n            if value is not None:\n                Select(self.element).select_by_value(value)\n            elif text is not None:\n                Select(self.element).select_by_visible_text(text)\n            elif index is not None:\n                Select(self.element).select_by_index(index)\n\n        elif select_or_deselect is 'deselect':\n            if value is not None:\n                Select(self.element).deselect_by_value(value)\n            elif text is not None:\n                Select(self.element).deselect_by_visible_text(text)\n            elif index is not None:\n                Select(self.element).deselect_by_index(index)\n\n        elif select_or_deselect is 'deselect all':\n            Select(self.element).deselect_all()\n\n        return self", "response": "Private method used by select methods."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef checkbox_check(self, force_check=False):\n        if not self.get_attribute('checked'):\n            self.click(force_click=force_check)", "response": "Wrapper to check a checkbox"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef checkbox_uncheck(self, force_check=False):\n        if self.get_attribute('checked'):\n            self.click(force_click=force_check)", "response": "Wrapper to uncheck a checkbox"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding wrapper invokes webDriverWrapper. find with the current element as the search object", "response": "def find(self, locator, find_all=False, search_object=None, exclude_invisible=None, *args, **kwargs):\n        \"\"\"\n        Find wrapper, invokes webDriverWrapper find with the current element as the search object\n\n        @type locator:          webdriverwrapper.support.locator.Locator\n        @param locator:         locator used in search\n        @type find_all:         bool\n        @param find_all:        should I find all elements, or just one?\n        @type search_object:    WebElementWrapper\n        @param search_object:   Used to override the starting point of the driver search\n\n        @rtype:                 WebElementWrapper or list[WebElementWrapper]\n        @return:                Either a single WebElementWrapper, or a list of WebElementWrappers\n        \"\"\"\n        search_object = self.element if search_object is None else search_object\n        return self.driver_wrapper.find(\n            locator,\n            find_all,\n            search_object=search_object,\n            exclude_invisible=exclude_invisible\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind a single element in the page", "response": "def find_once(self, locator):\n        \"\"\"\n        Find wrapper to run a single find\n\n        @type locator:          webdriverwrapper.support.locator.Locator\n        @param locator:         locator used in search\n        @type find_all:         bool\n        @param find_all:        should I find all elements, or just one?\n\n        @rtype:                 WebElementWrapper or list[WebElementWrapper]\n        @return:                Either a single WebElementWrapper, or a list of WebElementWrappers\n        \"\"\"\n        params = []\n        params.append(self.driver_wrapper.find_attempts)\n        params.append(self.driver_wrapper.implicit_wait)\n\n        self.driver_wrapper.find_attempts = 1\n        self.driver_wrapper.implicit_wait = 0\n\n        result = self.driver_wrapper._find_immediately(locator, self.element)\n\n        # restore the original params\n        self.driver_wrapper.implicit_wait = params.pop()\n        self.driver_wrapper.find_attempts = params.pop()\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_all(self, locator):\n        return self.driver_wrapper.find(locator, True, self.element)", "response": "Find wrapper finds all elements with the given locator"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntests to see if an element is present in the page", "response": "def is_present(self, locator):\n        \"\"\"\n        Tests to see if an element is present\n\n        @type locator:          webdriverwrapper.support.locator.Locator\n        @param locator:         locator used in search\n\n        @rtype:                 bool\n        @return:                True if present, False if not present\n        \"\"\"\n        return self.driver_wrapper.is_present(locator, search_object=self.element)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wait_until_stale(self, timeout=None):\n        timeout = timeout if timeout is not None else self.driver_wrapper.timeout\n\n        def wait():\n            \"\"\"\n            Wrapper to wait for element to be stale\n            \"\"\"\n            WebDriverWait(self.driver, timeout).until(EC.staleness_of(self.element))\n            return self\n\n        return self.execute_and_handle_webelement_exceptions(wait, 'wait for staleness')", "response": "Waits until the element is stale in the DOM"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute a function and handles any common WebDriverExceptions or throw an exception.", "response": "def execute_and_handle_webelement_exceptions(self, function_to_execute, name_of_action):\n        \"\"\"\n        Private method to be called by other methods to handle common WebDriverExceptions or throw\n        a custom exception\n\n        @type function_to_execute:      types.FunctionType\n        @param function_to_execute:     A function containing some webdriver calls\n        @type name_of_action:           str\n        @param name_of_action:          The name of the action you are trying to perform for building the error message\n        \"\"\"\n        if self.element is not None:\n            attempts = 0\n            while attempts < self.driver_wrapper.find_attempts+1:\n                try:\n                    attempts = attempts + 1\n                    val = function_to_execute()\n                    for cb in self.driver_wrapper.action_callbacks:\n                        cb.__call__(self.driver_wrapper)\n                    return val\n                except StaleElementReferenceException:\n                    self.element = self.driver_wrapper.find(self.locator, search_object=self.search_object).element\n                except ElementNotVisibleException:\n                    raise WebElementNotVisibleException.WebElementNotVisibleException(self,\n                        'WebElement with locator: {} was not visible, so could not {}'.format(\n                            self.locator, name_of_action))\n                except MoveTargetOutOfBoundsException:\n                    raise WebElementNotVisibleException.WebElementNotVisibleException(self,\n                        'WebElement with locator: {} was out of window, so could not {}'.format(\n                            self.locator, name_of_action))\n                except TimeoutException:\n                    raise WebDriverTimeoutException.WebDriverTimeoutException(\n                        self.driver_wrapper, timeout=self.driver_wrapper.timeout, locator=self.locator,\n                        msg='Timeout on action: {}'.format(name_of_action))\n                except UnexpectedAlertPresentException:\n                    msg = 'failed to parse message from alert'\n                    try:\n                        a = self.driver.switch_to_alert()\n                        msg = a.text\n                    finally:\n                        raise UnexpectedAlertPresentException('Unexpected alert on page: {}'.format(msg))\n                except BadStatusLine, e:\n                    logging.getLogger(__name__).error('{} error raised on action: {} (line: {}, args:{}, message: {})'.format(\n                        BadStatusLine.__class__.__name__,\n                        name_of_action,\n                        e.line,\n                        e.args,\n                        e.message\n                    ))\n                    raise\n\n            raise StaleWebElementException.StaleWebElementException(self,\n                'Cannot {} element with locator: {}; the reference to the WebElement was stale ({} attempts)'\n                .format(name_of_action, self.locator, self.driver_wrapper.find_attempts))\n        else:\n            raise WebElementDoesNotExist.WebElementDoesNotExist(self,\n                'Cannot {} element with locator: {}; it does not exist'.format(name_of_action, self.locator))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef request(self, uri, method=GET, headers=None, cookies=None, params=None, data=None, post_files=None,**kwargs):\n\n        coyote_args = {\n            'headers': headers,\n            'cookies': cookies,\n            'params': params,\n            'files': post_files,\n            'data': data,\n            'verify': self.verify_certificates,\n\n        }\n\n        coyote_args.update(kwargs)\n\n        if method == self.POST:\n            response = self.session.post(uri, **coyote_args)\n\n        elif method == self.PUT:\n            response = self.session.put(uri, **coyote_args)\n\n        elif method == self.PATCH:\n            response = self.session.patch(uri, **coyote_args)\n\n        elif method == self.DELETE:\n            response = self.session.delete(uri, **coyote_args)\n\n        else:  # Default to GET\n            response = self.session.get(uri, **coyote_args)\n\n        self.responses.append(response)\n\n        while len(self.responses) > self.max_response_history:\n            self.responses.popleft()\n\n        return response", "response": "Makes a request using requests. Session."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_last_response_to_file(self, filename):\n        response = self.get_last_response()\n        return self.save_response_to_file(response, filename)", "response": "Saves the last response to a file"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves the body of the last response to a file", "response": "def save_response_to_file(self, response, filename):\n        \"\"\"Saves the body of the last response to a file\n\n        @param filename: Filename to save to\n        @return: Returns False if there is an OS error, True if successful\n        \"\"\"\n        try:\n            last_response = self.get_last_response()\n            with open(filename, 'w') as f:\n                f.write(last_response.content)\n        except OSError, e:\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate_url(url, allowed_response_codes=None):\n    allowed_response_codes = [200] if allowed_response_codes is None else allowed_response_codes\n\n    # link calls a js function, do not try to open\n    if str(url).startswith('javascript:'):\n        return True\n\n    try:\n        response = urllib2.urlopen(urllib2.Request(url))\n    except urllib2.URLError:\n        raise AssertionError('Url was invalid and could not be opened: {url}'.format(url=url))\n\n    if response.code not in allowed_response_codes:\n        raise AssertionError('Invalid response code {response_code} from url: {url}'\n                             .format(response_code=response.code, url=url))\n    return True", "response": "Validates that the url can be opened and responds with an allowed response code."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate that a list of urls can be opened and each responds with an allowed response code", "response": "def validate_urls(urls, allowed_response_codes=None):\n    \"\"\"Validates that a list of urls can be opened and each responds with an allowed response code\n\n    urls -- the list of urls to ping\n    allowed_response_codes -- a list of response codes that the validator will ignore\n    \"\"\"\n\n    for url in urls:\n        validate_url(url, allowed_response_codes=allowed_response_codes)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild a URL for the follow page.", "response": "def build_follow_url(host=None, **params):\n        \"\"\"\n        Build a URL for the /follow page\n        \"\"\"\n\n        # template = '?{params}'\n        config = ExampleConfig()\n        template = '/follow?{params}'\n\n        if not host:\n            host = config.get('example_web_hostname')\n\n        return ExampleUrlBuilder.build(\n            template=template,\n            host=host,\n            params=ExampleUrlBuilder.encode_params(**params)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nencodes all the string keys and values in a collection with specified encoding", "response": "def encode_collection(collection, encoding='utf-8'):\n    \"\"\"Encodes all the string keys and values in a collection with specified encoding\"\"\"\n\n    if isinstance(collection, dict):\n        return dict((encode_collection(key), encode_collection(value)) for key, value in collection.iteritems())\n    elif isinstance(collection, list):\n        return [encode_collection(element) for element in input]\n    elif isinstance(collection, unicode):\n        return collection.encode(encoding)\n    else:\n        return collection"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive a list returns a string representation of that list with specified delimiter and optional string chars", "response": "def get_delimited_string_from_list(_list, delimiter=', ', wrap_values_with_char=None, wrap_strings_with_char=None):\n    \"\"\"Given a list, returns a string representation of that list with specified delimiter and optional string chars\n\n    _list -- the list or tuple to stringify\n    delimiter -- the the character to seperate all values\n    wrap_values_with_char -- if specified, will wrap all values in list with this character in the representation\n    wrap_strings_with_char -- if specified, will wrap only values of type str with this character in the representation\n    \"\"\"\n\n    if wrap_values_with_char is not None:\n        return delimiter.join('{wrapper}{val}{wrapper}'.format(\n            val=v,\n            wrapper=wrap_values_with_char\n        ) for v in _list)\n    elif wrap_strings_with_char is not None:\n        return delimiter.join(str(v) if not isinstance(v, str) else '{wrapper}{val}{wrapper}'.format(\n            val=v,\n            wrapper=wrap_strings_with_char\n        ) for v in _list)\n    else:\n        return delimiter.join(str(v) for v in _list)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute_script(self, string, args=None):\n        result = None\n\n        try:\n            result = self.driver_wrapper.driver.execute_script(string, args)\n            return result\n        except WebDriverException:\n            if result is not None:\n                message = 'Returned: ' + str(result)\n            else:\n                message = \"No message. Check your Javascript source: {}\".format(string)\n\n        raise WebDriverJavascriptException.WebDriverJavascriptException(self.driver_wrapper, message)", "response": "Execute a script in the browser"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef execute_template(self, template_name, variables, args=None):\n        js_text = self.build_js_from_template(template_name, variables)\n        try:\n            self.execute_script(js_text, args)\n        except WebDriverException:\n            return False\n        return True", "response": "Execute a script from a template"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute a script from a template and return the result", "response": "def execute_template_and_return_result(self, template_name, variables, args=None):\n        \"\"\"\n        Execute script from a template and return result\n\n        @type template_name:    str\n        @value template_name:   Script template to implement\n        @type variables:        dict\n        @value variables:       Dictionary representing template construction args\n        @type args:             dict\n        @value args:            Dictionary representing command line args\n\n        @rtype:                 int\n        @rtype:                 exit code\n        \"\"\"\n        js_text = self.build_js_from_template(template_name, variables)\n        return self.execute_script(js_text, args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild a javascript script from a template and args.", "response": "def build_js_from_template(self, template_file, variables):\n        \"\"\"\n        Build a JS script from a template and args\n\n        @type template_file:    str\n        @param template_file:   Script template to implement; can be the name of a built-in script or full filepath to\n                                a js file that contains the script. E.g. 'clickElementTemplate.js',\n                                'clickElementTemplate', and '/path/to/custom/template/script.js' are all acceptable\n        @type variables:        dict\n        @param variables:       Dictionary representing template construction args\n\n        @rtype:                 int\n        @rtype:                 exit code\n        \"\"\"\n        template_variable_character = '%'\n\n        # raise an exception if user passed non-dictionary variables\n        if not isinstance(variables, dict):\n            raise TypeError('You must use a dictionary to populate variables in a javascript template')\n\n        # This filename is not a full file, attempt to locate the file in built-in templates\n        if not os.path.isfile(template_file):\n            # append the .js extension if not included\n            if '.js' not in template_file:\n                template_file += '.js'\n\n            # find the template and read the text into a string variable\n            templates_dir = os.path.join(os.path.dirname(__file__), 'jsTemplates')\n            template_full_path = os.path.join(templates_dir, template_file)\n        # The filename specified should be the full path\n        else:\n            template_full_path = template_file\n\n        # Ensure that the file exists\n        if not os.path.isfile(template_full_path):\n            raise ValueError('File \"{}\" was not found; you must specify the name of a built-in javascript template '\n                             'or the full filepath of a custom template'.format(template_full_path))\n\n        try:\n            js_text = open(template_full_path).read()\n        except IOError:\n            raise IOError('The template was not found or did not have read permissions: {}'.format(template_full_path))\n\n        # replace all variables that match the keys in 'variables' dict\n        for key in variables.keys():\n            # double escape single and double quotes after variable replacement\n            if hasattr(variables[key], 'replace'):\n                variables[key] = variables[key].replace(\"'\", \"\\\\'\")\n                variables[key] = variables[key].replace('\"', '\\\\\"')\n            else: # variable is not a string\n                variables[key] = str(variables[key])\n\n            js_text = js_text.replace(template_variable_character + key, variables[key])\n\n        return js_text"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds a url with a string template and template variables ; absolute path if host is None abs otherwise.", "response": "def build(template='/', host=None, scheme=None, port=None, **template_vars):\n        \"\"\"Builds a url with a string template and template variables; relative path if host is None, abs otherwise:\n            template format: \"/staticendpoint/{dynamic_endpoint}?{params}\"\n        \"\"\"\n        # TODO: refactor to build_absolute and build_relative instead of handling based on params\n        parsed_host = urlparse.urlparse(host if host is not None else '')\n        host_has_scheme = bool(parsed_host.scheme)\n\n        if host_has_scheme:\n            host = parsed_host.netloc\n            # Prioritize scheme parameter, but if not specified, use scheme implied from host\n            scheme = parsed_host.scheme if scheme is None else scheme\n\n        port = port or parsed_host.port  # Default to port override\n\n        unparsed_path = urlparse.urlparse(template.format(**template_vars)).geturl()\n\n        # If a host was specified, try to return a full url\n        if host:\n            if not scheme:\n                raise ValueError('No scheme supplied and scheme could not be inferred from the host: {}'.format(host))\n            if port:\n                host_no_port = host.partition(':')[0]  # Extract the host with no port supplied\n                host = '{host_no_port}:{port}'.format(host_no_port=host_no_port, port=port)\n            constructed_url = '//' + host + unparsed_path\n            url = urlparse.urlparse(constructed_url, scheme=scheme).geturl()\n        else:\n            url = unparsed_path\n\n        # Remove trailing parameter characters\n        url = url[:-1] if url[-1] == '?' else url\n        url = url[:-1] if url[-1] == '&' else url\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall the function until bool ( return value ) is truthy.", "response": "def poll(function, step=0.5, timeout=3, ignore_exceptions=(), exception_message='', message_builder=None,\n         args=(), kwargs=None, ontimeout=()):\n    \"\"\"Calls the function until bool(return value) is truthy\n\n    @param step: Wait time between each function call\n    @param timeout: Max amount of time that will elapse. If the function is in progress when timeout has passed, the\n    function will be allowed to complete.\n    @type ignore_exceptions: tuple\n    @param ignore_exceptions: A tuple of exceptions that will be ignored if they are raised\n    @param exception_message: The message that will be raised as an AssertionError if the function never\n    returns bool(True)\n    @param ontimeout: On timeout, execute the functions in order, but do not fail if execution fails\n    @return: True\n    \"\"\"\n    # Validate usage\n    try:\n        iter(ontimeout)\n    except TypeError:\n        raise ValueError('Please specify an iterable of callable functions for ontimeout')\n\n    kwargs = kwargs or dict()\n\n    end_time = time.time() + timeout\n    while True:\n        try:\n            value = function(*args, **kwargs)\n            if bool(value):\n                return value\n        except ignore_exceptions:\n            pass\n        time.sleep(step)\n        if time.time() > end_time:\n            break\n\n    # Execute the callbacks\n    for fn in ontimeout:\n        try:\n            fn(),\n        except:\n            continue\n\n    if message_builder:\n        exception_message = message_builder(*args, **kwargs)\n\n    raise AssertionError(exception_message)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nformat the locator with specified parameters", "response": "def build(self, **variables):\n        \"\"\"Formats the locator with specified parameters\"\"\"\n        return Locator(self.by, self.locator.format(**variables), self.description)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a random words string", "response": "def random_words_string(count=1, maxchars=None, sep=''):\n    \"\"\"Gets a\n    \"\"\"\n    nouns = sep.join([random_word() for x in xrange(0, count)])\n\n    if maxchars is not None and nouns > maxchars:\n        nouns = nouns[0:maxchars-1]\n\n    return nouns"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest if a hostname is a subdomain of a reference hostname e. g. www. domain. com is subdomain of reference hostname", "response": "def is_subdomain(domain, reference):\n    \"\"\"Tests if a hostname is a subdomain of a reference hostname\n    e.g. www.domain.com is subdomain of reference\n\n    @param domain: Domain to test if it is a subdomain\n    @param reference: Reference \"parent\" domain\n    \"\"\"\n    index_of_reference = domain.find(reference)\n    if index_of_reference > 0 and domain[index_of_reference:] == reference:\n        return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndumps all cookies in the requestdriver session into the WebdriverWrapper.", "response": "def dump_requestdriver_cookies_into_webdriver(requestdriver, webdriverwrapper, handle_sub_domain=True):\n    \"\"\"Adds all cookies in the RequestDriver session to Webdriver\n\n    @type requestdriver: RequestDriver\n    @param requestdriver: RequestDriver with cookies\n    @type webdriverwrapper: WebDriverWrapper\n    @param webdriverwrapper: WebDriverWrapper to receive cookies\n    @param handle_sub_domain: If True, will check driver url and change cookies with subdomains of that domain to match\n    the current driver domain in order to avoid cross-domain cookie errors\n    @rtype: None\n    @return: None\n    \"\"\"\n    driver_hostname = urlparse(webdriverwrapper.current_url()).netloc\n\n    for cookie in requestdriver.session.cookies:\n\n        # Check if there will be a cross-domain violation and handle if necessary\n        cookiedomain = cookie.domain\n        if handle_sub_domain:\n            if is_subdomain(cookiedomain, driver_hostname):\n                # Cookies of requestdriver are subdomain cookies of webdriver; make them the base domain\n                cookiedomain = driver_hostname\n\n        try:\n            webdriverwrapper.add_cookie({\n                'name': cookie.name,\n                'value': cookie.value,\n                'domain': cookiedomain,\n                'path': cookie.path\n            })\n        except WebDriverException, e:\n            raise WebDriverException(\n                msg='Cannot set cookie \"{name}\" with domain \"{domain}\" on url \"{url}\" {override}: {message}'.format(\n                    name=cookie.name,\n                    domain=cookiedomain,\n                    url=webdriverwrapper.current_url(),\n                    override='(Note that subdomain override is set!)' if handle_sub_domain else '',\n                    message=e.message),\n                screen=e.screen,\n                stacktrace=e.stacktrace\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dump_webdriver_cookies_into_requestdriver(requestdriver, webdriverwrapper):\n\n    for cookie in webdriverwrapper.get_cookies():\n        # Wedbriver uses \"expiry\"; requests uses \"expires\", adjust for this\n        expires = cookie.pop('expiry', {'expiry': None})\n        cookie.update({'expires': expires})\n\n        requestdriver.session.cookies.set(**cookie)", "response": "Adds all cookies in the Webdriver session to the requestdriver."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the firefox binary", "response": "def get_firefox_binary():\n    \"\"\"Gets the firefox binary\n\n    @rtype: FirefoxBinary\n    \"\"\"\n    browser_config = BrowserConfig()\n    constants_config = ConstantsConfig()\n    log_dir = os.path.join(constants_config.get('logs_dir'), 'firefox')\n    create_directory(log_dir)\n\n    log_path = os.path.join(log_dir, '{}_{}.log'.format(datetime.datetime.now().isoformat('_'), words.random_word()))\n    log_file = open(log_path, 'w')\n    log('Firefox log file: {}'.format(log_path))\n\n    binary = FirefoxBinary(log_file=log_file)\n\n    return binary"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nraises an assertion error if the page has severe console errors", "response": "def _log_fail_callback(driver, *args, **kwargs):\n    \"\"\"Raises an assertion error if the page has severe console errors\n\n    @param driver: ShapewaysDriver\n    @return: None\n    \"\"\"\n\n    try:\n        logs = driver.get_browser_log(levels=[BROWSER_LOG_LEVEL_SEVERE])\n        failure_message = 'There were severe console errors on this page: {}'.format(logs)\n        failure_message = failure_message.replace('{', '{{').replace('}', '}}')  # Escape braces for error message\n        driver.assertion.assert_false(\n            logs,\n            failure_message=failure_message\n        )\n    except (urllib2.URLError, socket.error, WebDriverException):\n        # The session has ended, don't check the logs\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clone_and_update(self, **kwargs):\n        cloned = self.clone()\n        cloned.update(**kwargs)\n        return cloned", "response": "Clones the object and updates the args\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef message(self):\n        template_name = self.template_name() if \\\n            callable(self.template_name) \\\n            else self.template_name\n        return loader.render_to_string(\n            template_name, self.get_context(), request=self.request\n        )", "response": "Render the body of the message to a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrenders the subject of the message to a string.", "response": "def subject(self):\n        \"\"\"\n        Render the subject of the message to a string.\n\n        \"\"\"\n        template_name = self.subject_template_name() if \\\n            callable(self.subject_template_name) \\\n            else self.subject_template_name\n        subject = loader.render_to_string(\n            template_name, self.get_context(), request=self.request\n        )\n        return ''.join(subject.splitlines())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the context used to render the templates for the email.", "response": "def get_context(self):\n        \"\"\"\n        Return the context used to render the templates for the email\n        subject and body.\n\n        By default, this context includes:\n\n        * All of the validated values in the form, as variables of the\n          same names as their fields.\n\n        * The current ``Site`` object, as the variable ``site``.\n\n        * Any additional variables added by context processors (this\n          will be a ``RequestContext``).\n\n        \"\"\"\n        if not self.is_valid():\n            raise ValueError(\n                \"Cannot generate Context from invalid contact form\"\n            )\n        return dict(self.cleaned_data, site=get_current_site(self.request))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_message_dict(self):\n        if not self.is_valid():\n            raise ValueError(\n                \"Message cannot be sent from invalid contact form\"\n            )\n        message_dict = {}\n        for message_part in ('from_email', 'message',\n                             'recipient_list', 'subject'):\n            attr = getattr(self, message_part)\n            message_dict[message_part] = attr() if callable(attr) else attr\n        return message_dict", "response": "Generates the various parts of the message and return them in a dictionary suitable for passing directly as keyword arguments to django. core. mail. send_mail."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef initialise_shopify_session():\n    if not settings.SHOPIFY_APP_API_KEY or not settings.SHOPIFY_APP_API_SECRET:\n        raise ImproperlyConfigured(\"SHOPIFY_APP_API_KEY and SHOPIFY_APP_API_SECRET must be set in settings\")\n    shopify.Session.setup(api_key=settings.SHOPIFY_APP_API_KEY, secret=settings.SHOPIFY_APP_API_SECRET)", "response": "Initialises the Shopify session with the Shopify App s API credentials."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_user(self, myshopify_domain, password=None):\n        if not myshopify_domain:\n            raise ValueError('ShopUsers must have a myshopify domain')\n\n        user = self.model(myshopify_domain=myshopify_domain)\n\n        # Never want to be able to log on externally.\n        # Authentication will be taken care of by Shopify OAuth.\n        user.set_unusable_password()\n        user.save(using=self._db)\n        return user", "response": "Creates and saves a ShopUser with the given domain and password."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_query_parameters_to_url(url, query_parameters):\n    # Parse the given URL into parts.\n    url_parts = urllib.parse.urlparse(url)\n\n    # Parse existing parameters and add new parameters.\n    qs_args = urllib.parse.parse_qs(url_parts[4])\n    qs_args.update(query_parameters)\n\n    # Sort parameters to ensure consistent order.\n    sorted_qs_args = OrderedDict()\n    for k in sorted(qs_args.keys()):\n        sorted_qs_args[k] = qs_args[k]\n\n    # Encode the new parameters and return the updated URL.\n    new_qs = urllib.parse.urlencode(sorted_qs_args, True)\n    return urllib.parse.urlunparse(list(url_parts[0:4]) + [new_qs] + list(url_parts[5:]))", "response": "Merge a dictionary of query parameters into the given URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbinds an event to a callback", "response": "def bind(self, event_name, callback, *args, **kwargs):\n        \"\"\"Bind an event to a callback\n\n        :param event_name: The name of the event to bind to.\n        :type event_name: str\n\n        :param callback: The callback to notify of this event.\n        \"\"\"\n        self.event_callbacks[event_name].append((callback, args, kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_event(self, event_name, data, channel_name=None):\n        event = {'event': event_name, 'data': data}\n        if channel_name:\n            event['channel'] = channel_name\n\n        self.logger.info(\"Connection: Sending event - %s\" % event)\n        try:\n            self.socket.send(json.dumps(event))\n        except Exception as e:\n            self.logger.error(\"Failed send event: %s\" % e)", "response": "Send an event to the Pusher server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef trigger(self, event_name, data):\n        if self.connection:\n            if event_name.startswith(\"client-\"):\n                if self.name.startswith(\"private-\") or self.name.startswith(\"presence-\"):\n                    self.connection.send_event(event_name, data, channel_name=self.name)", "response": "Trigger an event on this channel. Only available for private or presence channels."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef subscribe(self, channel_name, auth=None):\n        data = {'channel': channel_name}\n        if auth is None:\n            if channel_name.startswith('presence-'):\n                data['auth'] = self._generate_presence_token(channel_name)\n                data['channel_data'] = json.dumps(self.user_data)\n            elif channel_name.startswith('private-'):\n                data['auth'] = self._generate_auth_token(channel_name)\n        else:\n            data['auth'] = auth\n\n        self.connection.send_event('pusher:subscribe', data)\n\n        self.channels[channel_name] = Channel(channel_name, self.connection)\n\n        return self.channels[channel_name]", "response": "Subscribe to a channel."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unsubscribe(self, channel_name):\n        if channel_name in self.channels:\n            self.connection.send_event(\n                'pusher:unsubscribe', {\n                    'channel': channel_name,\n                }\n            )\n            del self.channels[channel_name]", "response": "Unsubscribe from a channel."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _connection_handler(self, event_name, data, channel_name):\n        if channel_name in self.channels:\n            self.channels[channel_name]._handle_event(event_name, data)", "response": "Handle incoming data.\n\n        :param str event_name: Name of the event.\n        :param Any data: Data received.\n        :param str channel_name: Name of the channel this event and data belongs to."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _generate_auth_token(self, channel_name):\n        subject = \"{}:{}\".format(self.connection.socket_id, channel_name)\n        h = hmac.new(self.secret_as_bytes, subject.encode('utf-8'), hashlib.sha256)\n        auth_key = \"{}:{}\".format(self.key, h.hexdigest())\n\n        return auth_key", "response": "Generate a token for authentication with the given channel."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a presence token.", "response": "def _generate_presence_token(self, channel_name):\n        \"\"\"Generate a presence token.\n\n        :param str channel_name: Name of the channel to generate a signature for.\n        :rtype: str\n        \"\"\"\n        subject = \"{}:{}:{}\".format(self.connection.socket_id, channel_name, json.dumps(self.user_data))\n        h = hmac.new(self.secret_as_bytes, subject.encode('utf-8'), hashlib.sha256)\n        auth_key = \"{}:{}\".format(self.key, h.hexdigest())\n\n        return auth_key"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pos(self, element = None):\n\t\t''' Tries to decide about the part of speech. '''\n\n\t\ttags = []\n\t\tif element:\n\t\t\tif element.startswith(('de ', 'het ', 'het/de', 'de/het')) and not re.search('\\[[\\w|\\s][\\w|\\s]+\\]', element.split('\\r\\n')[0], re.U):\n\t\t\t\ttags.append('NN')\n\t\t\tif re.search('[\\w|\\s|/]+ \\| [\\w|\\s|/]+ - [\\w|\\s|/]+', element, re.U):\n\t\t\t\ttags.append('VB')\n\t\t\tif re.search('[\\w|\\s]+ \\| [\\w|\\s]+', element, re.U):\n\t\t\t\ttags.append('JJ')\n\t\t\treturn tags\n\t\telse:\n\t\t\tfor element in self.elements:\n\t\t\t\tif self.word in unicode(element):\n\t\t\t\t\ttag = self.pos(element)\n\t\t\t\t\tif tag:\n\t\t\t\t\t\treturn tag", "response": "Tries to decide about the part of speech."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntry to scrape the correct articles for singular and plural from uitmuntend. nl.", "response": "def articles(self):\n\t\t''' Tries to scrape the correct articles for singular and plural from uitmuntend.nl. '''\n\n\t\tresult = [None, None]\n\t\telement = self._first('NN')\n\t\tif element:\n\t\t\telement = element.split('\\r\\n')[0]\n\t\t\tif ' | ' in element:\n\t\t\t\t# This means there is a plural\n\t\t\t\tsingular, plural = element.split(' | ')\n\t\t\t\tsingular, plural = singular.strip(), plural.strip()\n\t\t\telse:\n\t\t\t\t# This means there is no plural\n\t\t\t\tsingular, plural = element.strip(), ''\n\t\t\t\tresult[1] = ''\n\t\t\tif singular:\n\t\t\t\tresult[0] = singular.split(' ')[0].split('/')\n\t\t\tif plural:\n\t\t\t\tresult[1] = plural.split(' ')[0].split('/')\n\t\treturn result"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntries to scrape the plural version from uitmuntend. nl.", "response": "def plural(self):\n\t\t''' Tries to scrape the plural version from uitmuntend.nl. '''\n\n\t\telement = self._first('NN')\n\t\tif element:\n\t\t\telement = element.split('\\r\\n')[0]\n\t\t\tif ' | ' in element:\n\t\t\t\t# This means there is a plural\n\t\t\t\tsingular, plural = element.split(' | ')\n\t\t\t\treturn [plural.split(' ')[1]]\n\t\t\telse:\n\t\t\t\t# This means there is no plural\n\t\t\t\treturn ['']\n\t\treturn [None]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download(url, filename, overwrite = False):\n\t''' Downloads a file via HTTP. '''\n\n\tfrom requests import get\n\tfrom os.path import exists\n\n\tdebug('Downloading ' + unicode(url) + '...')\n\tdata = get(url)\n\tif data.status_code == 200:\n\t\tif not exists(filename) or overwrite:\n\t\t\tf = open(filename, 'wb')\n\t\t\tf.write(data.content)\n\t\t\tf.close()\n\t\treturn True\n\treturn False", "response": "Downloads a file via HTTP."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting a message if warning mode is enabled.", "response": "def warning(message):\n\t''' Prints a message if warning mode is enabled. '''\n\n\timport lltk.config as config\n\tif config['warnings']:\n\n\t\ttry:\n\t\t\tfrom termcolor import colored\n\t\texcept ImportError:\n\t\t\tdef colored(message, color):\n\t\t\t\treturn message\n\n\t\tprint colored('@LLTK-WARNING: ' + message, 'red')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef trace(f, *args, **kwargs):\n\t''' Decorator used to trace function calls for debugging purposes. '''\n\n\tprint 'Calling %s() with args %s, %s ' % (f.__name__, args, kwargs)\n\treturn f(*args,**kwargs)", "response": "Decorator used to trace function calls for debugging purposes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef articles(self):\n\t\t''' Tries to scrape the correct articles for singular and plural from vandale.nl. '''\n\n\t\tresult = [None, None]\n\t\telement = self._first('NN')\n\t\tif element:\n\t\t\tif re.search('(de|het/?de|het);', element, re.U):\n\t\t\t\tresult[0] = re.findall('(de|het/?de|het);', element, re.U)[0].split('/')\n\t\t\tif re.search('meervoud: (\\w+)', element, re.U):\n\t\t\t\t# It's a noun with a plural form\n\t\t\t\tresult[1] = ['de']\n\t\t\telse:\n\t\t\t\t# It's a noun without a plural form\n\t\t\t\tresult[1] = ['']\n\t\treturn result", "response": "Tries to scrape the correct articles for singular and plural from vandale. nl."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef plural(self):\n\t\t''' Tries to scrape the plural version from vandale.nl. '''\n\n\t\telement = self._first('NN')\n\t\tif element:\n\t\t\tif re.search('meervoud: ([\\w|\\s|\\'|\\-|,]+)', element, re.U):\n\t\t\t\tresults = re.search('meervoud: ([\\w|\\s|\\'|\\-|,]+)', element, re.U).groups()[0].split(', ')\n\t\t\t\tresults = [x.replace('ook ', '').strip() for x in results]\n\t\t\t\treturn results\n\t\t\telse:\n\t\t\t\t# There is no plural form\n\t\t\t\treturn ['']\n\t\treturn [None]", "response": "Tries to scrape the plural version from vandale. nl."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntry to scrape the miniaturized version from vandale. nl.", "response": "def miniaturize(self):\n\t\t''' Tries to scrape the miniaturized version from vandale.nl. '''\n\n\t\telement = self._first('NN')\n\t\tif element:\n\t\t\tif re.search('verkleinwoord: (\\w+)', element, re.U):\n\t\t\t\treturn re.findall('verkleinwoord: (\\w+)', element, re.U)\n\t\t\telse:\n\t\t\t\treturn ['']\n\t\treturn [None]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a sanitized string.", "response": "def _normalize(self, string):\n\t\t''' Returns a sanitized string. '''\n\n\t\tstring = super(VerbixDe, self)._normalize(string)\n\t\tstring = string.replace('sie; Sie', 'sie')\n\t\tstring = string.strip()\n\t\treturn string"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nattempt to decide about the part of speech.", "response": "def pos(self):\n\t\t''' Tries to decide about the part of speech. '''\n\n\t\ttags = []\n\t\tif self.tree.xpath('//div[@class=\"grad733100\"]/h2[@class=\"inline\"]//text()'):\n\t\t\tinfo = self.tree.xpath('//div[@class=\"grad733100\"]/h2[@class=\"inline\"]')[0].text_content()\n\t\t\tinfo = info.strip('I ')\n\t\t\tif info.startswith(('de', 'het')):\n\t\t\t\ttags.append('NN')\n\t\t\tif not info.startswith(('de', 'het')) and info.endswith('en'):\n\t\t\t\ttags.append('VB')\n\t\t\tif not info.startswith(('de', 'het')) and not info.endswith('en'):\n\t\t\t\ttags.append('JJ')\n\t\treturn tags"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _normalize(self, string):\n\t\t''' Returns a sanitized string. '''\n\n\t\tstring = super(VerbixFr, self)._normalize(string)\n\t\tstring = string.replace('il; elle', 'il/elle')\n\t\tstring = string.replace('ils; elles', 'ils/elles')\n\t\tstring = string.strip()\n\t\treturn string", "response": "Returns a sanitized string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pos(self, element = None):\n\t\t''' Tries to decide about the part of speech. '''\n\n\t\ttags = []\n\t\tif element:\n\t\t\tif re.search('[\\w|\\s]+ [m|f]\\.', element, re.U):\n\t\t\t\ttags.append('NN')\n\t\t\tif '[VERB]' in element:\n\t\t\t\ttags.append('VB')\n\t\t\tif 'adj.' in element and re.search('([\\w|\\s]+, [\\w|\\s]+)', element, re.U):\n\t\t\t\ttags.append('JJ')\n\t\telse:\n\t\t\tfor element in self.elements:\n\t\t\t\tif element.startswith(self.word):\n\t\t\t\t\ttags += self.pos(element)\n\t\treturn list(set(tags))", "response": "Tries to decide about the part of speech."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntrying to scrape the gender for a given noun from leo. org.", "response": "def gender(self):\n\t\t''' Tries to scrape the gender for a given noun from leo.org. '''\n\n\t\telement = self._first('NN')\n\t\tif element:\n\t\t\tif re.search('([m|f|n)])\\.', element, re.U):\n\t\t\t\tgenus = re.findall('([m|f|n)])\\.', element, re.U)[0]\n\t\t\t\treturn genus"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isempty(result):\n\t''' Finds out if a scraping result should be considered empty. '''\n\n\tif isinstance(result, list):\n\t\tfor element in result:\n\t\t\tif isinstance(element, list):\n\t\t\t\tif not isempty(element):\n\t\t\t\t\treturn False\n\t\t\telse:\n\t\t\t\tif element is not None:\n\t\t\t\t\treturn False\n\telse:\n\t\tif result is not None:\n\t\t\treturn False\n\treturn True", "response": "Finds out if a scraping result should be considered empty."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef method2pos(method):\n\t''' Returns a list of valid POS-tags for a given method. '''\n\n\tif method in ('articles', 'plural', 'miniaturize', 'gender'):\n\t\tpos = ['NN']\n\telif method in ('conjugate',):\n\t\tpos = ['VB']\n\telif method in ('comparative, superlative'):\n\t\tpos = ['JJ']\n\telse:\n\t\tpos = ['*']\n\treturn pos", "response": "Returns a list of valid POS - tags for a given method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register(scraper):\n\t''' Registers a scraper to make it available for the generic scraping interface. '''\n\n\tglobal scrapers\n\tlanguage = scraper('').language\n\tif not language:\n\t\traise Exception('No language specified for your scraper.')\n\tif scrapers.has_key(language):\n\t\tscrapers[language].append(scraper)\n\telse:\n\t\tscrapers[language] = [scraper]", "response": "Registers a scraper to make it available for the generic scraping interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef discover(language):\n\t''' Discovers all registered scrapers to be used for the generic scraping interface. '''\n\n\tdebug('Discovering scrapers for \\'%s\\'...' % (language,))\n\tglobal scrapers, discovered\n\tfor language in scrapers.iterkeys():\n\t\tdiscovered[language] = {}\n\t\tfor scraper in scrapers[language]:\n\t\t\tblacklist = ['download', 'isdownloaded', 'getelements']\n\t\t\tmethods = [method for method in dir(scraper) if method not in blacklist and not method.startswith('_') and callable(getattr(scraper, method))]\n\t\t\tfor method in methods:\n\t\t\t\tif discovered[language].has_key(method):\n\t\t\t\t\tdiscovered[language][method].append(scraper)\n\t\t\t\telse:\n\t\t\t\t\tdiscovered[language][method] = [scraper]\n\tdebug('%d scrapers with %d methods (overall) registered for \\'%s\\'.' % (len(scrapers[language]), len(discovered[language].keys()), language))", "response": "Discovers all registered scrapers for the given language."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nusing custom scrapers and calls provided method.", "response": "def scrape(language, method, word, *args, **kwargs):\n\t''' Uses custom scrapers and calls provided method. '''\n\n\tscraper = Scrape(language, word)\n\tif hasattr(scraper, method):\n\t\tfunction = getattr(scraper, method)\n\t\tif callable(function):\n\t\t\treturn function(*args, **kwargs)\n\telse:\n\t\traise NotImplementedError('The method ' + method + '() is not implemented so far.')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef iterscrapers(self, method, mode = None):\n\t\t''' Iterates over all available scrapers. '''\n\n\t\tglobal discovered\n\t\tif discovered.has_key(self.language) and discovered[self.language].has_key(method):\n\t\t\tfor Scraper in discovered[self.language][method]:\n\t\t\t\tyield Scraper", "response": "Iterate over all available scrapers for a given method."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef merge(self, elements):\n\t\t''' Merges all scraping results to a list sorted by frequency of occurrence. '''\n\n\t\tfrom collections import Counter\n\t\tfrom lltk.utils import list2tuple, tuple2list\n\t\t# The list2tuple conversion is necessary because mutable objects (e.g. lists) are not hashable\n\t\tmerged = tuple2list([value for value, count in Counter(list2tuple(list(elements))).most_common()])\n\t\treturn merged", "response": "Merges all scraping results to a list sorted by frequency of occurrence."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clean(self, elements):\n\t\t''' Removes empty or incomplete answers. '''\n\n\t\tcleanelements = []\n\t\tfor i in xrange(len(elements)):\n\t\t\tif isempty(elements[i]):\n\t\t\t\treturn []\n\t\t\tnext = elements[i]\n\t\t\tif isinstance(elements[i], (list, tuple)):\n\t\t\t\tnext = self.clean(elements[i])\n\t\t\tif next:\n\t\t\t\tcleanelements.append(elements[i])\n\t\treturn cleanelements", "response": "Removes empty or incomplete answers."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndownloads HTML from url.", "response": "def download(self):\n\t\t''' Downloads HTML from url. '''\n\n\t\tself.page = requests.get(self.url)\n\t\tself.tree = html.fromstring(self.page.text)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _needs_elements(self, f):\n\t\t''' Decorator used to make sure that there are elements prior to running the task. '''\n\n\t\t@wraps(f)\n\t\tdef wrapper(self, *args, **kwargs):\n\t\t\tif self.elements == None:\n\t\t\t\tself.getelements()\n\t\t\treturn f(self, *args, **kwargs)\n\t\treturn wrapper", "response": "Decorator used to make sure that there are elements prior to running the task."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the first element with required POS - tag.", "response": "def _first(self, tag):\n\t\t''' Returns the first element with required POS-tag. '''\n\n\t\tself.getelements()\n\t\tfor element in self.elements:\n\t\t\tif tag in self.pos(element):\n\t\t\t\treturn element\n\t\treturn None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a sanitized string.", "response": "def _normalize(self, string):\n\t\t''' Returns a sanitized string. '''\n\n\t\tstring = string.replace(u'\\xb7', '')\n\t\tstring = string.replace(u'\\u0331', '')\n\t\tstring = string.replace(u'\\u0323', '')\n\t\tstring = string.strip(' \\n\\rI.')\n\t\treturn string"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nattempts to decide about the part of speech.", "response": "def pos(self, element = None):\n\t\t''' Tries to decide about the part of speech. '''\n\n\t\ttags = []\n\t\tif element:\n\t\t\tif element.startswith(('der', 'die', 'das')):\n\t\t\t\ttags.append('NN')\n\t\t\tif ' VERB' in element:\n\t\t\t\ttags.append('VB')\n\t\t\tif ' ADJ' in element:\n\t\t\t\ttags.append('JJ')\n\t\telse:\n\t\t\tfor element in self.elements:\n\t\t\t\tif self.word in unicode(element):\n\t\t\t\t\treturn self.pos(element)\n\t\treturn tags"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef articles(self):\n\t\t''' Tries to scrape the correct articles for singular and plural from de.pons.eu. '''\n\n\t\tresult = [None, None]\n\t\telement = self._first('NN')\n\t\tif element:\n\t\t\tresult[0] = [element.split(' ')[0].replace('(die)', '').strip()]\n\t\t\tif 'kein Plur' in element:\n\t\t\t\t# There is no plural\n\t\t\t\tresult[1] = ['']\n\t\t\telse:\n\t\t\t\t# If a plural form exists, there is only one possibility\n\t\t\t\tresult[1] = ['die']\n\t\treturn result", "response": "Tries to scrape the correct articles for singular and plural from de. pons. eu."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntrying to scrape the plural version from pons. eu.", "response": "def plural(self):\n\t\t''' Tries to scrape the plural version from pons.eu. '''\n\n\t\telement = self._first('NN')\n\t\tif element:\n\t\t\tif 'kein Plur' in element:\n\t\t\t\t# There is no plural\n\t\t\t\treturn ['']\n\t\t\tif re.search(', ([\\w|\\s|/]+)>', element, re.U):\n\t\t\t\t# Plural form is provided\n\t\t\t\treturn re.findall(', ([\\w|\\s|/]+)>', element, re.U)[0].split('/')\n\t\t\tif re.search(', -(\\w+)>', element, re.U):\n\t\t\t\t# Suffix is provided\n\t\t\t\tsuffix = re.findall(', -(\\w+)>', element, re.U)[0]\n\t\t\t\treturn [self.word + suffix]\n\t\t\tif element.endswith('->'):\n\t\t\t\t# Plural is the same as singular\n\t\t\t\treturn [self.word]\n\t\treturn [None]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reference(language, word):\n\t''' Returns the articles (singular and plural) combined with singular and plural for a given noun. '''\n\n\tsg, pl, art = word, '/'.join(plural(language, word)  or ['-']), [[''], ['']]\n\tart[0], art[1] = articles(language, word) or (['-'], ['-'])\n\tresult = ['%s %s' % ('/'.join(art[0]), sg), '%s %s' % ('/'.join(art[1]), pl)]\n\tresult = [None if x == '- -' else x for x in result]\n\treturn result", "response": "Returns the articles that are used for a given noun."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef translate(src, dest, word):\n\t''' Translates a word using Google Translate. '''\n\n\tresults = []\n\n\ttry:\n\t\tfrom textblob import TextBlob\n\t\tresults.append(TextBlob(word).translate(from_lang = src, to = dest).string)\n\texcept ImportError:\n\t\tpass\n\n\tif not results:\n\t\treturn [None]\n\treturn results", "response": "Translate a word using Google Translate."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef audiosamples(language, word, key = ''):\n\t''' Returns a list of URLs to suitable audiosamples for a given word. '''\n\n\tfrom lltk.audiosamples import forvo, google\n\n\turls = []\n\turls += forvo(language, word, key)\n\turls += google(language, word)\n\treturn urls", "response": "Returns a list of URLs to suitable audiosamples for a given word."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef images(language, word, n = 20, *args, **kwargs):\n\t''' Returns a list of URLs to suitable images for a given word.'''\n\n\tfrom lltk.images import google\n\treturn google(language, word, n, *args, **kwargs)", "response": "Returns a list of URLs to suitable images for a given word."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the articles for a given noun.", "response": "def articles(word):\n\t''' Returns the articles (singular and plural) for a given noun. '''\n\n\tfrom pattern.it import article\n\n\tresult = [[None], [None]]\n\tgenus = gender(word) or 'f'\n\tresult[0] = [article(word, function = 'definite', gender = genus)]\n\tresult[1] = [article(plural(word)[0], function = 'definite', gender = (genus, 'p'))]\n\treturn result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndownload suitable images for a given word from Google Images.", "response": "def google(language, word, n = 8, *args, **kwargs):\n\t''' Downloads suitable images for a given word from Google Images. '''\n\n\tif not kwargs.has_key('start'):\n\t\tkwargs['start'] = 0\n\tif not kwargs.has_key('itype'):\n\t\tkwargs['itype'] = 'photo|clipart|lineart'\n\tif not kwargs.has_key('isize'):\n\t\tkwargs['isize'] = 'small|medium|large|xlarge'\n\tif not kwargs.has_key('filetype'):\n\t\tkwargs['filetype'] = 'jpg'\n\n\tinfo = {'q' : word, 'hl' : language, 'start' : str(kwargs['start']), 'as_filetype' : kwargs['filetype'], 'imgsz' : kwargs['isize'], 'imgtype' : kwargs['itype'], 'rsz' : '8', 'safe' : 'active'}\n\tquery = '&'.join([x[0] + '=' + x[1] for x in info.items()])\n\turl = 'https://ajax.googleapis.com/ajax/services/search/images?v=1.0&' + query\n\n\tdebug('Loading ' + unicode(url) + '...')\n\tpage = requests.get(url)\n\tdata = json.loads(page.text)\n\timages = []\n\n\tif data and data.has_key('responseData') and data['responseData']:\n\t\titems = data['responseData']['results']\n\t\tif items:\n\t\t\timages += [item['url'] for item in items]\n\t\t\tif len(images) < int(n):\n\t\t\t\tkwargs['start'] += 8\n\t\t\t\timages += google(language, word, n, *args, **kwargs)\n\treturn images[:int(n)]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _normalize(self, string):\n\t\t''' Returns a sanitized string. '''\n\n\t\tstring = string.replace(u'\\xa0', '')\n\t\tstring = string.strip()\n\t\treturn string", "response": "Returns a sanitized string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _extract(self, identifier):\n\t\t''' Extracts data from conjugation table. '''\n\n\t\tconjugation = []\n\t\tif self.tree.xpath('//p/b[normalize-space(text()) = \"' + identifier.decode('utf-8') + '\"]'):\n\t\t\tp = self.tree.xpath('//p/b[normalize-space(text()) = \"' + identifier.decode('utf-8') + '\"]')[0].getparent()\n\t\t\tfor font in p.iterfind('font'):\n\t\t\t\ttext = self._normalize(font.text_content())\n\t\t\t\tnext = font.getnext()\n\t\t\t\ttext += ' ' + self._normalize(next.text_content())\n\t\t\t\twhile True:\n\t\t\t\t\tnext = next.getnext()\n\t\t\t\t\tif next.tag != 'span':\n\t\t\t\t\t\tbreak\n\t\t\t\t\ttext += '/' + self._normalize(next.text_content())\n\t\t\t\tconjugation.append(text)\n\t\treturn conjugation", "response": "Extracts data from conjugation table."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of the conjugate tenses.", "response": "def conjugate(self, tense = 'present'):\n\t\t''' Tries to conjugate a given verb using verbix.com.'''\n\n\t\tif self.tenses.has_key(tense):\n\t\t\treturn self._extract(self.tenses[tense])\n\t\telif self.tenses.has_key(tense.title()):\n\t\t\treturn self._extract(self.tenses[tense.title()])\n\t\treturn [None]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load(self, filename, replace = False):\n\t\t''' Loads a configuration file (JSON). '''\n\n\t\timport os, json, re\n\t\tif os.path.exists(filename):\n\t\t\tf = open(filename, 'r')\n\t\t\tcontent = f.read()\n\t\t\tcontent = re.sub('[\\t ]*?[#].*?\\n', '', content)\n\t\t\ttry:\n\t\t\t\tsettings = json.loads(content)\n\t\t\texcept ValueError:\n\t\t\t\t# This means that the configuration file is not a valid JSON document\n\t\t\t\tfrom lltk.exceptions import ConfigurationError\n\t\t\t\traise ConfigurationError('\\'' + filename + '\\' is not a valid JSON document.')\n\t\t\tf.close()\n\t\t\tif replace:\n\t\t\t\tself.settings = settings\n\t\t\telse:\n\t\t\t\tself.settings.update(settings)\n\t\telse:\n\t\t\tlltkfilename = self.settings['module-path'] + '/' + self.settings['lltk-config-path'] + filename\n\t\t\tif os.path.exists(lltkfilename):\n\t\t\t\t# This means that filename was provided relative to the lltk module path\n\t\t\t\treturn self.load(lltkfilename)\n\t\t\tfrom lltk.exceptions import ConfigurationError\n\t\t\traise ConfigurationError('\\'' + filename + '\\' seems to be non-existent.')", "response": "Loads a configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves the current configuration to a JSON file.", "response": "def save(self, filename):\n\t\t''' Saves the current configuration to file 'filename' (JSON). '''\n\n\t\timport json\n\t\tf = open(filename, 'w')\n\t\tjson.dump(self.settings, f, indent = 4)\n\t\tf.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef forvo(language, word, key):\n\t''' Returns a list of suitable audiosamples for a given word from Forvo.com. '''\n\n\tfrom requests import get\n\n\turl = 'http://apifree.forvo.com/action/word-pronunciations/format/json/word/%s/language/%s/key/%s/' % (word, language, key)\n\turls = []\n\n\tpage = get(url)\n\tif page.status_code == 200:\n\t\tif 'incorrect' in page.text:\n\t\t\tfrom lltk.exceptions import IncorrectForvoAPIKey\n\t\t\traise IncorrectForvoAPIKey('Your Forvi API key seems to be wrong. Please check on http://api.forvo.com.')\n\t\tdata = page.json()\n\t\tif data == ['Limit/day reached.']:\n\t\t\tfrom lltk.exceptions import DailyForvoLimitExceeded\n\t\t\traise DailyForvoLimitExceeded('You have exceeded your daily Forvo API limit.')\n\t\tif data.has_key('items') and len(data['items']):\n\t\t\titems = sorted(data['items'], key = lambda x: int(x['num_votes']), reverse = True)\n\t\t\tfor item in items:\n\t\t\t\turls.append(item['pathmp3'])\n\treturn urls", "response": "Returns a list of suitable audiosamples for a given word from Forvo."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a sanitized string.", "response": "def _normalize(self, string):\n\t\t''' Returns a sanitized string. '''\n\n\t\tstring = string.replace(u'\\xb7', '')\n\t\tstring = string.replace(u'\\xa0', ' ')\n\t\tstring = string.replace('selten: ', '')\n\t\tstring = string.replace('Alte Rechtschreibung', '')\n\t\tstring = string.strip()\n\t\treturn string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nattempting to decide about the part of speech.", "response": "def pos(self):\n\t\t''' Tries to decide about the part of speech. '''\n\n\t\ttags = []\n\t\tif self.tree.xpath('//div[@id=\"mw-content-text\"]//a[@title=\"Hilfe:Wortart\"]/text()'):\n\t\t\tinfo = self.tree.xpath('//div[@id=\"mw-content-text\"]//a[@title=\"Hilfe:Wortart\"]/text()')[0]\n\t\t\tif info == 'Substantiv':\n\t\t\t\ttags.append('NN')\n\t\t\tif info == 'Verb':\n\t\t\t\ttags.append('VB')\n\t\t\tif info == 'Adjektiv':\n\t\t\t\ttags.append('JJ')\n\t\treturn tags"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef language(l):\n\t''' Use this as a decorator (implicitly or explicitly). '''\n\n\t# Usage: @language('en') or function = language('en')(function)\n\n\tdef decorator(f):\n\t\t''' Decorator used to prepend the language as an argument. '''\n\n\t\t@wraps(f)\n\t\tdef wrapper(*args, **kwargs):\n\t\t\treturn f(l, *args, **kwargs)\n\t\treturn wrapper\n\n\treturn decorator", "response": "Decorator used to prepend the language as an argument."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of suitable textsamples for a given word using Tatoeba. org.", "response": "def tatoeba(language, word, minlength = 10, maxlength = 100):\n\t''' Returns a list of suitable textsamples for a given word using Tatoeba.org. '''\n\n\tword, sentences = unicode(word), []\n\tpage = requests.get('http://tatoeba.org/deu/sentences/search?query=%s&from=%s&to=und' % (word, lltk.locale.iso639_1to3(language)))\n\ttree = html.fromstring(page.text)\n\tfor sentence in tree.xpath('//div[contains(concat(\" \", normalize-space(@class), \" \"), \" mainSentence \")]/div/a/text()'):\n\t\tsentence = sentence.strip(u' \"\u201e\u201c').replace(u'\u201c \u201e', u' \u2013 ').replace('\" \"', u' \u2013 ')\n\t\tif word in sentence and len(sentence) < maxlength and len(sentence) > minlength:\n\t\t\tsentences.append(sentence)\n\treturn sentences"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntries to scrape the correct gender for a given word from wordreference. com", "response": "def gender(self):\n\t\t''' Tries to scrape the correct gender for a given word from wordreference.com '''\n\n\t\telements = self.tree.xpath('//table[@class=\"WRD\"]')\n\t\tif len(elements):\n\t\t\telements = self.tree.xpath('//table[@class=\"WRD\"]')[0]\n\t\t\tif len(elements):\n\t\t\t\tif '/iten/' in self.page.url:\n\t\t\t\t\telements = elements.xpath('//td[@class=\"FrWrd\"]/em[@class=\"POS2\"]/text()')\n\t\t\t\telif '/enit/' in self.page.url:\n\t\t\t\t\telements = elements.xpath('//td[@class=\"ToWrd\"]/em[@class=\"POS2\"]/text()')\n\t\t\t\telse:\n\t\t\t\t\treturn [None]\n\t\t\t\telement = [element[1:] for element in elements if element in ['nm', 'nf']]\n\t\t\t\tcounter = Counter(element)\n\t\t\t\tif len(counter.most_common(1)):\n\t\t\t\t\tresult = counter.most_common(1)[0][0]\n\t\t\t\t\treturn [result]\n\t\treturn [None]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting ISO639 language identifier to the corresponding human readable language name.", "response": "def humanize(iso639):\n\t''' Converts ISO639 language identifier to the corresponding (human readable) language name. '''\n\n\tfor i, element in enumerate(LANGUAGES):\n\t\tif element[1] == iso639 or element[2] == iso639:\n\t\t\treturn element[0]\n\treturn None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_host(self, host_id=None, host='localhost', port=6379,\n                 unix_socket_path=None, db=0, password=None,\n                 ssl=False, ssl_options=None):\n        \"\"\"Adds a new host to the cluster.  This is only really useful for\n        unittests as normally hosts are added through the constructor and\n        changes after the cluster has been used for the first time are\n        unlikely to make sense.\n        \"\"\"\n        if host_id is None:\n            raise RuntimeError('Host ID is required')\n        elif not isinstance(host_id, (int, long)):\n            raise ValueError('The host ID has to be an integer')\n        host_id = int(host_id)\n        with self._lock:\n            if host_id in self.hosts:\n                raise TypeError('Two hosts share the same host id (%r)' %\n                                (host_id,))\n            self.hosts[host_id] = HostInfo(host_id=host_id, host=host,\n                                           port=port, db=db,\n                                           unix_socket_path=unix_socket_path,\n                                           password=password, ssl=ssl,\n                                           ssl_options=ssl_options)\n            self._hosts_age += 1", "response": "Adds a new host to the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove a host from the client.", "response": "def remove_host(self, host_id):\n        \"\"\"Removes a host from the client.  This only really useful for\n        unittests.\n        \"\"\"\n        with self._lock:\n            rv = self._hosts.pop(host_id, None) is not None\n            pool = self._pools.pop(host_id, None)\n            if pool is not None:\n                pool.disconnect()\n            self._hosts_age += 1\n            return rv"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisconnect all connections from the internal pools.", "response": "def disconnect_pools(self):\n        \"\"\"Disconnects all connections from the internal pools.\"\"\"\n        with self._lock:\n            for pool in self._pools.itervalues():\n                pool.disconnect()\n            self._pools.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_router(self):\n        cached_router = self._router\n        ref_age = self._hosts_age\n\n        if cached_router is not None:\n            router, router_age = cached_router\n            if router_age == ref_age:\n                return router\n\n        with self._lock:\n            router = self.router_cls(self, **(self.router_options or {}))\n            self._router = (router, ref_age)\n            return router", "response": "Returns the router for the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_pool_for_host(self, host_id):\n        if isinstance(host_id, HostInfo):\n            host_info = host_id\n            host_id = host_info.host_id\n        else:\n            host_info = self.hosts.get(host_id)\n            if host_info is None:\n                raise LookupError('Host %r does not exist' % (host_id,))\n\n        rv = self._pools.get(host_id)\n        if rv is not None:\n            return rv\n        with self._lock:\n            rv = self._pools.get(host_id)\n            if rv is None:\n                opts = dict(self.pool_options or ())\n                opts['db'] = host_info.db\n                opts['password'] = host_info.password\n                if host_info.unix_socket_path is not None:\n                    opts['path'] = host_info.unix_socket_path\n                    opts['connection_class'] = UnixDomainSocketConnection\n                    if host_info.ssl:\n                        raise TypeError('SSL is not supported for unix '\n                                        'domain sockets.')\n                else:\n                    opts['host'] = host_info.host\n                    opts['port'] = host_info.port\n                    if host_info.ssl:\n                        if SSLConnection is None:\n                            raise TypeError('This version of py-redis does '\n                                            'not support SSL connections.')\n                        opts['connection_class'] = SSLConnection\n                        opts.update(('ssl_' + k, v) for k, v in\n                                    (host_info.ssl_options or {}).iteritems())\n                rv = self.pool_cls(**opts)\n                self._pools[host_id] = rv\n            return rv", "response": "Returns the connection pool for the given host."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef all(self, timeout=None, max_concurrency=64, auto_batch=True):\n        return self.fanout('all', timeout=timeout,\n                           max_concurrency=max_concurrency,\n                           auto_batch=auto_batch)", "response": "Fanout to all hosts."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute a sequence of commands on a Redis cluster and return a new mapping.", "response": "def execute_commands(self, mapping, *args, **kwargs):\n        \"\"\"Concurrently executes a sequence of commands on a Redis cluster that\n        are associated with a routing key, returning a new mapping where\n        values are a list of results that correspond to the command in the same\n        position. For example::\n\n            >>> cluster.execute_commands({\n            ...   'foo': [\n            ...     ('PING',),\n            ...     ('TIME',),\n            ...   ],\n            ...   'bar': [\n            ...     ('CLIENT', 'GETNAME'),\n            ...   ],\n            ... })\n            {'bar': [<Promise None>],\n             'foo': [<Promise True>, <Promise (1454446079, 418404)>]}\n\n        Commands that are instances of :class:`redis.client.Script` will first\n        be checked for their existence on the target nodes then loaded on the\n        targets before executing and can be interleaved with other commands::\n\n            >>> from redis.client import Script\n            >>> TestScript = Script(None, 'return {KEYS, ARGV}')\n            >>> cluster.execute_commands({\n            ...   'foo': [\n            ...     (TestScript, ('key:1', 'key:2'), range(0, 3)),\n            ...   ],\n            ...   'bar': [\n            ...     (TestScript, ('key:3', 'key:4'), range(3, 6)),\n            ...   ],\n            ... })\n            {'bar': [<Promise [['key:3', 'key:4'], ['3', '4', '5']]>],\n             'foo': [<Promise [['key:1', 'key:2'], ['0', '1', '2']]>]}\n\n        Internally, :class:`FanoutClient` is used for issuing commands.\n        \"\"\"\n        def is_script_command(command):\n            return isinstance(command[0], Script)\n\n        def check_script_load_result(script, result):\n            if script.sha != result:\n                raise AssertionError(\n                    'Hash mismatch loading {!r}: expected {!r}, got {!r}'.format(\n                        script,\n                        script.sha,\n                        result,\n                    )\n                )\n\n        # Run through all the commands and check to see if there are any\n        # scripts, and whether or not they have been loaded onto the target\n        # hosts.\n        exists = {}\n        with self.fanout(*args, **kwargs) as client:\n            for key, commands in mapping.items():\n                targeted = client.target_key(key)\n                for command in filter(is_script_command, commands):\n                    script = command[0]\n\n                    # Set the script hash if it hasn't already been set.\n                    if not script.sha:\n                        script.sha = sha1(script.script).hexdigest()\n\n                    # Check if the script has been loaded on each host that it\n                    # will be executed on.\n                    for host in targeted._target_hosts:\n                        if script not in exists.setdefault(host, {}):\n                            exists[host][script] = targeted.execute_command('SCRIPT EXISTS', script.sha)\n\n        # Execute the pending commands, loading scripts onto servers where they\n        # do not already exist.\n        results = {}\n        with self.fanout(*args, **kwargs) as client:\n            for key, commands in mapping.items():\n                results[key] = []\n                targeted = client.target_key(key)\n                for command in commands:\n                    # If this command is a script, we need to check and see if\n                    # it needs to be loaded before execution.\n                    if is_script_command(command):\n                        script = command[0]\n                        for host in targeted._target_hosts:\n                            if script in exists[host]:\n                                result = exists[host].pop(script)\n                                if not result.value[0]:\n                                    targeted.execute_command('SCRIPT LOAD', script.script).done(\n                                        on_success=functools.partial(check_script_load_result, script)\n                                    )\n                        keys, arguments = command[1:]\n                        parameters = list(keys) + list(arguments)\n                        results[key].append(targeted.execute_command('EVALSHA', script.sha, len(keys), *parameters))\n                    else:\n                        results[key].append(targeted.execute_command(*command))\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef auto_batch_commands(commands):\n    pending_batch = None\n\n    for command_name, args, options, promise in commands:\n        # This command cannot be batched, return it as such.\n        if command_name not in AUTO_BATCH_COMMANDS:\n            if pending_batch:\n                yield merge_batch(*pending_batch)\n                pending_batch = None\n            yield command_name, args, options, promise\n            continue\n\n        assert not options, 'batch commands cannot merge options'\n        if pending_batch and pending_batch[0] == command_name:\n            pending_batch[1].append((args, promise))\n        else:\n            if pending_batch:\n                yield merge_batch(*pending_batch)\n            pending_batch = (command_name, [(args, promise)])\n\n    if pending_batch:\n        yield merge_batch(*pending_batch)", "response": "Given a pipeline of commands this attempts to merge the commands into more efficient ones if that is possible."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend all pending requests into the socket.", "response": "def send_pending_requests(self):\n        \"\"\"Sends all pending requests into the connection.  The default is\n        to only send pending data that fits into the socket without blocking.\n        This returns `True` if all data was sent or `False` if pending data\n        is left over.\n        \"\"\"\n        assert_open(self)\n\n        unsent_commands = self.commands\n        if unsent_commands:\n            self.commands = []\n\n            if self.auto_batch:\n                unsent_commands = auto_batch_commands(unsent_commands)\n\n            buf = []\n            for command_name, args, options, promise in unsent_commands:\n                buf.append((command_name,) + tuple(args))\n                self.pending_responses.append((command_name, options, promise))\n\n            cmds = self.connection.pack_commands(buf)\n            self._send_buf.extend(cmds)\n\n        if not self._send_buf:\n            return True\n\n        self.send_buffer()\n        return not self._send_buf"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwaiting for all responses to come back and resolves the eventual results.", "response": "def wait_for_responses(self, client):\n        \"\"\"Waits for all responses to come back and resolves the\n        eventual results.\n        \"\"\"\n        assert_open(self)\n\n        if self.has_pending_requests:\n            raise RuntimeError('Cannot wait for responses if there are '\n                               'pending requests outstanding.  You need '\n                               'to wait for pending requests to be sent '\n                               'first.')\n\n        pending = self.pending_responses\n        self.pending_responses = []\n        for command_name, options, promise in pending:\n            value = client.parse_response(\n                self.connection, command_name, **options)\n            promise.resolve(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_command_buffer(self, host_id, command_name):\n        buf = self._cb_poll.get(host_id)\n        if buf is not None:\n            return buf\n\n        if self._max_concurrency is not None:\n            while len(self._cb_poll) >= self._max_concurrency:\n                self.join(timeout=1.0)\n\n        def connect():\n            return self.connection_pool.get_connection(\n                command_name, shard_hint=host_id)\n        buf = CommandBuffer(host_id, connect, self.auto_batch)\n        self._cb_poll.register(host_id, buf)\n        return buf", "response": "Returns the command buffer for the given command and arguments."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _release_command_buffer(self, command_buffer):\n        if command_buffer.closed:\n            return\n\n        self._cb_poll.unregister(command_buffer.host_id)\n        self.connection_pool.release(command_buffer.connection)\n        command_buffer.connection = None", "response": "This is called by the command buffer when it closes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwait for all outstanding responses to come back or the timeout to be hit.", "response": "def join(self, timeout=None):\n        \"\"\"Waits for all outstanding responses to come back or the timeout\n        to be hit.\n        \"\"\"\n        remaining = timeout\n\n        while self._cb_poll and (remaining is None or remaining > 0):\n            now = time.time()\n            rv = self._cb_poll.poll(remaining)\n            if remaining is not None:\n                remaining -= (time.time() - now)\n\n            for command_buffer, event in rv:\n                # This command buffer still has pending requests which\n                # means we have to send them out first before we can read\n                # all the data from it.\n                if command_buffer.has_pending_requests:\n                    if event == 'close':\n                        self._try_reconnect(command_buffer)\n                    elif event == 'write':\n                        self._send_or_reconnect(command_buffer)\n\n                # The general assumption is that all response is available\n                # or this might block.  On reading we do not use async\n                # receiving.  This generally works because latency in the\n                # network is low and redis is super quick in sending.  It\n                # does not make a lot of sense to complicate things here.\n                elif event in ('read', 'close'):\n                    try:\n                        command_buffer.wait_for_responses(self)\n                    finally:\n                        self._release_command_buffer(command_buffer)\n\n        if self._cb_poll and timeout is not None:\n            raise TimeoutError('Did not receive all data in time.')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef target(self, hosts):\n        if self.__is_retargeted:\n            raise TypeError('Cannot use target more than once.')\n        rv = FanoutClient(hosts, connection_pool=self.connection_pool,\n                          max_concurrency=self._max_concurrency)\n        rv._cb_poll = self._cb_poll\n        rv.__is_retargeted = True\n        return rv", "response": "Temporarily retarget the client for one call."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_mapping_client(self, max_concurrency=64, auto_batch=None):\n        if auto_batch is None:\n            auto_batch = self.auto_batch\n        return MappingClient(connection_pool=self.connection_pool,\n                             max_concurrency=max_concurrency,\n                             auto_batch=auto_batch)", "response": "Returns a thread unsafe mapping client."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an instance of thread unsafe fanout client.", "response": "def get_fanout_client(self, hosts, max_concurrency=64,\n                          auto_batch=None):\n        \"\"\"Returns a thread unsafe fanout client.\n\n        Returns an instance of :class:`FanoutClient`.\n        \"\"\"\n        if auto_batch is None:\n            auto_batch = self.auto_batch\n        return FanoutClient(hosts, connection_pool=self.connection_pool,\n                            max_concurrency=max_concurrency,\n                            auto_batch=auto_batch)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a context manager that runs a map operation.", "response": "def map(self, timeout=None, max_concurrency=64, auto_batch=None):\n        \"\"\"Returns a context manager for a map operation.  This runs\n        multiple queries in parallel and then joins in the end to collect\n        all results.\n\n        In the context manager the client available is a\n        :class:`MappingClient`.  Example usage::\n\n            results = {}\n            with cluster.map() as client:\n                for key in keys_to_fetch:\n                    results[key] = client.get(key)\n            for key, promise in results.iteritems():\n                print '%s => %s' % (key, promise.value)\n        \"\"\"\n        return MapManager(self.get_mapping_client(max_concurrency, auto_batch),\n                          timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a context manager that fans out to the specified hosts.", "response": "def fanout(self, hosts=None, timeout=None, max_concurrency=64,\n               auto_batch=None):\n        \"\"\"Returns a context manager for a map operation that fans out to\n        manually specified hosts instead of using the routing system.  This\n        can for instance be used to empty the database on all hosts.  The\n        context manager returns a :class:`FanoutClient`.  Example usage::\n\n            with cluster.fanout(hosts=[0, 1, 2, 3]) as client:\n                results = client.info()\n            for host_id, info in results.value.iteritems():\n                print '%s -> %s' % (host_id, info['is'])\n\n        The promise returned accumulates all results in a dictionary keyed\n        by the `host_id`.\n\n        The `hosts` parameter is a list of `host_id`\\s or alternatively the\n        string ``'all'`` to send the commands to all hosts.\n\n        The fanout APi needs to be used with a lot of care as it can cause\n        a lot of damage when keys are written to hosts that do not expect\n        them.\n        \"\"\"\n        return MapManager(self.get_fanout_client(hosts, max_concurrency,\n                                                 auto_batch),\n                          timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resolved(value):\n        p = Promise()\n        p._state = 'resolved'\n        p.value = value\n        return p", "response": "Creates a promise object resolved with a certain value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a promise object rejected with a certain value.", "response": "def rejected(reason):\n        \"\"\"Creates a promise object rejected with a certain value.\"\"\"\n        p = Promise()\n        p._state = 'rejected'\n        p.reason = reason\n        return p"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resolve(self, value):\n        if self is value:\n            raise TypeError('Cannot resolve promise with itself.')\n\n        if isinstance(value, Promise):\n            value.done(self.resolve, self.reject)\n            return\n\n        if self._state != 'pending':\n            raise RuntimeError('Promise is no longer pending.')\n\n        self.value = value\n        self._state = 'resolved'\n        callbacks = self._callbacks\n        self._callbacks = None\n        for callback in callbacks:\n            callback(value)", "response": "Resolves the promise with the given value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reject(self, reason):\n        if self._state != 'pending':\n            raise RuntimeError('Promise is no longer pending.')\n\n        self.reason = reason\n        self._state = 'rejected'\n        errbacks = self._errbacks\n        self._errbacks = None\n        for errback in errbacks:\n            errback(reason)", "response": "Rejects the promise with the given reason."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef done(self, on_success=None, on_failure=None):\n        if on_success is not None:\n            if self._state == 'pending':\n                self._callbacks.append(on_success)\n            elif self._state == 'resolved':\n                on_success(self.value)\n        if on_failure is not None:\n            if self._state == 'pending':\n                self._errbacks.append(on_failure)\n            elif self._state == 'rejected':\n                on_failure(self.reason)\n        return self", "response": "Attaches some callbacks to the promise and returns the promise."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_key(self, command, args):\n        spec = COMMANDS.get(command.upper())\n\n        if spec is None:\n            raise UnroutableCommand('The command \"%r\" is unknown to the '\n                                    'router and cannot be handled as a '\n                                    'result.' % command)\n\n        if 'movablekeys' in spec['flags']:\n            raise UnroutableCommand('The keys for \"%r\" are movable and '\n                                    'as such cannot be routed to a single '\n                                    'host.')\n\n        keys = extract_keys(args, spec['key_spec'])\n        if len(keys) == 1:\n            return keys[0]\n        elif not keys:\n            raise UnroutableCommand(\n                'The command \"%r\" does not operate on a key which means '\n                'that no suitable host could be determined.  Consider '\n                'using a fanout instead.')\n\n        raise UnroutableCommand(\n            'The command \"%r\" operates on multiple keys (%d passed) which is '\n            'something that is not supported.' % (command, len(keys)))", "response": "Returns the key a command operates on."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_host_for_command(self, command, args):\n        return self.get_host_for_key(self.get_key(command, args))", "response": "Returns the host this command should be executed against."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _rebuild_circle(self):\n        self._hashring = {}\n        self._sorted_keys = []\n        total_weight = 0\n        for node in self._nodes:\n            total_weight += self._weights.get(node, 1)\n\n        for node in self._nodes:\n            weight = self._weights.get(node, 1)\n\n            ks = math.floor((40 * len(self._nodes) * weight) / total_weight)\n\n            for i in xrange(0, int(ks)):\n                k = md5_bytes('%s-%s-salt' % (node, i))\n\n                for l in xrange(0, 4):\n                    key = ((k[3 + l * 4] << 24) | (k[2 + l * 4] << 16) |\n                           (k[1 + l * 4] << 8) | k[l * 4])\n                    self._hashring[key] = node\n                    self._sorted_keys.append(key)\n\n        self._sorted_keys.sort()", "response": "Updates the hash ring with the new ones."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_node_pos(self, key):\n        if not self._hashring:\n            return\n\n        k = md5_bytes(key)\n        key = (k[3] << 24) | (k[2] << 16) | (k[1] << 8) | k[0]\n\n        nodes = self._sorted_keys\n        pos = bisect(nodes, key)\n\n        if pos == len(nodes):\n            return 0\n        return pos", "response": "Return the node position for a given key or None."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove node from circle and rebuild it.", "response": "def remove_node(self, node):\n        \"\"\"Removes node from circle and rebuild it.\"\"\"\n        try:\n            self._nodes.remove(node)\n            del self._weights[node]\n        except (KeyError, ValueError):\n            pass\n        self._rebuild_circle()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_node(self, node, weight=1):\n        self._nodes.add(node)\n        self._weights[node] = weight\n        self._rebuild_circle()", "response": "Adds a node to the circle and rebuilds it."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning node for a given key. If no node exists return None.", "response": "def get_node(self, key):\n        \"\"\"Return node for a given key. Else return None.\"\"\"\n        pos = self._get_node_pos(key)\n        if pos is None:\n            return None\n        return self._hashring[self._sorted_keys[pos]]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking in dd string and convert to dms", "response": "def ddtodms(self, dd):\n        \"\"\"Take in dd string and convert to dms\"\"\"\n        negative = dd < 0\n        dd = abs(dd)\n        minutes,seconds = divmod(dd*3600,60)\n        degrees,minutes = divmod(minutes,60)\n        if negative:\n            if degrees > 0:\n                degrees = -degrees\n            elif minutes > 0:\n                minutes = -minutes\n            else:\n                seconds = -seconds\n        return (degrees,minutes,seconds)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a string to dd", "response": "def dmstodd(self, dms):\n        \"\"\" convert dms to dd\"\"\"\n        size = len(dms)\n        letters = 'WENS'\n        is_annotated = False\n\n        try:\n            float(dms)\n        except ValueError:\n            for letter in letters:\n                if letter in dms.upper():\n                    is_annotated = True\n                    break\n            if not is_annotated:\n                raise core.RTreeError(\"unable to parse '%s' to decimal degrees\" % dms)\n        is_negative = False\n        if is_annotated:\n            dms_upper = dms.upper()\n            if 'W' in dms_upper or 'S' in dms_upper:\n                is_negative = True\n        else:\n            if dms < 0:\n                is_negative = True\n\n        if is_annotated:\n            bletters = letters.encode(encoding='utf-8')\n            bdms = dms.encode(encoding = 'utf-8')\n            dms = bdms.translate(None, bletters).decode('ascii')\n\n            # bletters = bytes(letters, encoding='utf-8')\n            # bdms = bytes(dms, encoding='utf-8')\n            # dms = bdms.translate(None, bletters).decode('ascii')\n\n            # dms = dms.translate(None, letters) # Python 2.x version\n\n        pieces = dms.split(\".\")\n        D = 0.0\n        M = 0.0\n        S = 0.0\n        divisor = 3600.0\n        if len(pieces) == 1:\n            S = dms[-2:]\n            M = dms[-4:-2]\n            D = dms[:-4]\n        else:\n            S = '{0:s}.{1:s}'.format (pieces[0][-2:], pieces[1])\n            M = pieces[0][-4:-2]\n            D = pieces[0][:-4]\n\n        DD = float(D) + float(M)/60.0 + float(S)/divisor\n        if is_negative:\n            DD = DD * -1.0\n        return DD"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_fobj(fname, mode='w+'):\n    if is_string_like(fname):\n        fobj = open(fname, mode)\n        close = True\n    elif hasattr(fname, 'write'):\n        # fname is a file-like object, perhaps a StringIO (for example)\n        fobj = fname\n        close = False\n    else:\n        # assume it is a file descriptor\n        fobj = os.fdopen(fname, mode)\n        close = False\n    return fobj, close", "response": "Obtain a proper file object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef graph_from_dot_file(path):\n\n    fd = open(path, 'rb')\n    data = fd.read()\n    fd.close()\n\n    return graph_from_dot_data(data)", "response": "Load a graph from a DOT file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef graph_from_edges(edge_list, node_prefix='', directed=False):\n    if edge_list is None:\n        edge_list = []\n\n    graph_type = \"digraph\" if directed else \"graph\"\n    with_prefix = functools.partial(\"{0}{1}\".format, node_prefix)\n\n    graph = Dot(graph_type=graph_type)\n\n    for src, dst in edge_list:\n        src = with_prefix(src)\n        dst = with_prefix(dst)\n\n        graph.add_edge(Edge(src, dst))\n\n    return graph", "response": "Creates a basic graph out of an edge list."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a basic graph out of an adjacency matrix.", "response": "def graph_from_adjacency_matrix(matrix, node_prefix='', directed=False):\n    \"\"\"Creates a basic graph out of an adjacency matrix.\n\n    The matrix has to be a list of rows of values\n    representing an adjacency matrix.\n    The values can be anything: bool, int, float, as long\n    as they can evaluate to True or False.\n    \"\"\"\n\n    node_orig = 1\n\n    if directed:\n        graph = Dot(graph_type='digraph')\n    else:\n        graph = Dot(graph_type='graph')\n\n    for row in matrix:\n        if not directed:\n            skip = matrix.index(row)\n            r = row[skip:]\n        else:\n            skip = 0\n            r = row\n        node_dest = skip + 1\n\n        for e in r:\n            if e:\n                graph.add_edge(\n                    Edge(\n                        node_prefix + node_orig,\n                        node_prefix + node_dest))\n            node_dest += 1\n        node_orig += 1\n\n    return graph"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a basic graph out of an incidence matrix.", "response": "def graph_from_incidence_matrix(matrix, node_prefix='', directed=False):\n    \"\"\"Creates a basic graph out of an incidence matrix.\n\n    The matrix has to be a list of rows of values\n    representing an incidence matrix.\n    The values can be anything: bool, int, float, as long\n    as they can evaluate to True or False.\n    \"\"\"\n\n    if directed:\n        graph = Dot(graph_type='digraph')\n    else:\n        graph = Dot(graph_type='graph')\n\n    for row in matrix:\n        nodes = []\n        c = 1\n\n        for node in row:\n            if node:\n                nodes.append(c * node)\n            c += 1\n\n        nodes.sort()\n\n        if len(nodes) == 2:\n            graph.add_edge(\n                Edge(\n                    node_prefix + abs(nodes[0]),\n                    node_prefix + nodes[1]))\n\n    if not directed:\n        graph.set_simplify(True)\n\n    return graph"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __find_executables(path):\n\n    success = False\n    progs = {\n        \"dot\": \"\",\n        \"twopi\": \"\",\n        \"neato\": \"\",\n        \"circo\": \"\",\n        \"fdp\": \"\",\n        \"sfdp\": \"\",\n    }\n\n    was_quoted = False\n    path = path.strip()\n    if path.startswith('\"') and path.endswith('\"'):\n        path = path[1:-1]\n        was_quoted = True\n\n    if not os.path.isdir(path):\n        return None\n\n    for prg in progs:\n        if progs[prg]:\n            continue\n\n        prg_path = os.path.join(path, prg)\n        prg_exe_path = prg_path + \".exe\"\n\n        if os.path.exists(prg_path):\n            if was_quoted:\n                prg_path = \"\\\"{}\\\"\".format(prg_path)\n            progs[prg] = prg_path\n            success = True\n\n        elif os.path.exists(prg_exe_path):\n            if was_quoted:\n                prg_exe_path = \"\\\"{}\\\"\".format(prg_exe_path)\n            progs[prg] = prg_exe_path\n            success = True\n\n    if success:\n        return progs\n\n    return None", "response": "Used by find_graphviz\n    path - single directory as a string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlocating the Graphviz executables in the system.", "response": "def find_graphviz():\n    \"\"\"Locate Graphviz's executables in the system.\n\n    Tries three methods:\n\n    First: Windows Registry (Windows only)\n    This requires Mark Hammond's pywin32 is installed.\n\n    Secondly: Search the path\n    It will look for 'dot', 'twopi' and 'neato' in all the directories\n    specified in the PATH environment variable.\n\n    Thirdly: Default install location (Windows only)\n    It will look for 'dot', 'twopi' and 'neato' in the default install\n    location under the \"Program Files\" directory.\n\n    It will return a dictionary containing the program names as keys\n    and their paths as values.\n\n    If this fails, it returns None.\n    \"\"\"\n\n    # Method 1 (Windows only)\n    if os.sys.platform == 'win32':\n\n        HKEY_LOCAL_MACHINE = 0x80000002\n        KEY_QUERY_VALUE = 0x0001\n\n        RegOpenKeyEx = None\n        RegQueryValueEx = None\n        RegCloseKey = None\n\n        try:\n            import win32api\n            RegOpenKeyEx = win32api.RegOpenKeyEx\n            RegQueryValueEx = win32api.RegQueryValueEx\n            RegCloseKey = win32api.RegCloseKey\n\n        except ImportError:\n            # Print a messaged suggesting they install these?\n            pass\n\n        try:\n            import ctypes\n\n            def RegOpenKeyEx(key, subkey, opt, sam):\n                result = ctypes.c_uint(0)\n                ctypes.windll.advapi32.RegOpenKeyExA(key, subkey, opt, sam,\n                                                     ctypes.byref(result))\n                return result.value\n\n            def RegQueryValueEx(hkey, valuename):\n                data_type = ctypes.c_uint(0)\n                data_len = ctypes.c_uint(1024)\n                data = ctypes.create_string_buffer(1024)\n\n                # this has a return value, which we should probably check\n                ctypes.windll.advapi32.RegQueryValueExA(\n                    hkey, valuename, 0, ctypes.byref(data_type),\n                    data, ctypes.byref(data_len))\n\n                return data.value\n\n            RegCloseKey = ctypes.windll.advapi32.RegCloseKey\n\n        except ImportError:\n            # Print a messaged suggesting they install these?\n            pass\n\n        if RegOpenKeyEx is not None:\n            # Get the GraphViz install path from the registry\n            hkey = None\n            potentialKeys = [\n                \"SOFTWARE\\\\ATT\\\\Graphviz\",\n                \"SOFTWARE\\\\AT&T Research Labs\\\\Graphviz\"]\n            for potentialKey in potentialKeys:\n\n                try:\n                    hkey = RegOpenKeyEx(\n                        HKEY_LOCAL_MACHINE,\n                        potentialKey, 0, KEY_QUERY_VALUE)\n\n                    if hkey is not None:\n                        path = RegQueryValueEx(hkey, \"InstallPath\")\n                        RegCloseKey(hkey)\n\n                        # The regitry variable might exist, left by\n                        # old installations but with no value, in those cases\n                        # we keep searching...\n                        if not path:\n                            continue\n\n                        # Now append the \"bin\" subdirectory:\n                        path = os.path.join(path, \"bin\")\n                        progs = __find_executables(path)\n                        if progs is not None:\n                            return progs\n\n                except Exception:\n                    pass\n                else:\n                    break\n\n    # Method 2 (Linux, Windows etc)\n    if 'PATH' in os.environ:\n        for path in os.environ['PATH'].split(os.pathsep):\n            progs = __find_executables(path)\n            if progs is not None:\n                return progs\n\n    # Method 3 (Windows only)\n    if os.sys.platform == 'win32':\n\n        # Try and work out the equivalent of \"C:\\Program Files\" on this\n        # machine (might be on drive D:, or in a different language)\n        if 'PROGRAMFILES' in os.environ:\n            # Note, we could also use the win32api to get this\n            # information, but win32api may not be installed.\n            path = os.path.join(os.environ['PROGRAMFILES'], 'ATT',\n                                'GraphViz', 'bin')\n        else:\n            # Just in case, try the default...\n            path = r\"C:\\Program Files\\att\\Graphviz\\bin\"\n\n        progs = __find_executables(path)\n\n        if progs is not None:\n            return progs\n\n    for path in (\n            '/usr/bin', '/usr/local/bin',\n            '/opt/local/bin',\n            '/opt/bin', '/sw/bin', '/usr/share',\n            '/Applications/Graphviz.app/Contents/MacOS/'):\n\n        progs = __find_executables(path)\n        if progs is not None:\n            return progs\n\n    # Failed to find GraphViz\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_node_list(self):\n        node_objs = list()\n\n        for obj_dict_list in self.obj_dict['nodes'].values():\n            node_objs.extend([\n                Node(obj_dict=obj_d)\n                for obj_d\n                in obj_dict_list])\n\n        return node_objs", "response": "Get the list of Node instances. This method returns the list of Node instances."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete an edge from the graph.", "response": "def del_edge(self, src_or_list, dst=None, index=None):\n        \"\"\"Delete an edge from the graph.\n\n        Given an edge's (source, destination) node names all\n        matching edges(s) will be deleted if 'index' is not\n        specified or set to None.\n        If there are several matching edges and 'index' is\n        given, only the edge in that position will be deleted.\n\n        'index' should be an integer specifying the position\n        of the edge to delete. If index is larger than the\n        number of matching edges, no action is taken.\n\n        If edges are deleted it returns True. If no action\n        is taken it returns False.\n        \"\"\"\n\n        if isinstance(src_or_list, (list, tuple)):\n            if dst is not None and isinstance(dst, (int, long)):\n                index = dst\n            src, dst = src_or_list\n        else:\n            src, dst = src_or_list, dst\n\n        if isinstance(src, Node):\n            src = src.get_name()\n\n        if isinstance(dst, Node):\n            dst = dst.get_name()\n\n        if (src, dst) in self.obj_dict['edges']:\n            if (index is not None and index <\n                    len(self.obj_dict['edges'][(src, dst)])):\n                del self.obj_dict['edges'][(src, dst)][index]\n                return True\n            else:\n                del self.obj_dict['edges'][(src, dst)]\n                return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the list of Edge instances. This method returns the list of Edge instances.", "response": "def get_edge_list(self):\n        \"\"\"Get the list of Edge instances.\n\n        This method returns the list of Edge instances\n        composing the graph.\n        \"\"\"\n        edge_objs = list()\n\n        for obj_dict_list in self.obj_dict['edges'].values():\n            edge_objs.extend([\n                Edge(obj_dict=obj_d)\n                for obj_d\n                in obj_dict_list])\n\n        return edge_objs"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a string representation of the object in dot language.", "response": "def to_string(self):\n        \"\"\"Returns a string representation of the graph in dot language.\n\n        It will return the graph and all its subelements in string from.\n        \"\"\"\n\n        graph = list()\n\n        if self.obj_dict.get('strict', None) is not None:\n            if self == self.get_parent_graph() and self.obj_dict['strict']:\n                graph.append('strict ')\n\n        if self.obj_dict['name'] == '':\n            if ('show_keyword' in self.obj_dict and\n                    self.obj_dict['show_keyword']):\n                graph.append('subgraph {\\n')\n            else:\n                graph.append('{\\n')\n        else:\n            graph.append('%s %s {\\n' % (self.obj_dict['type'],\n                                        self.obj_dict['name']))\n\n        for attr, value in sorted(self.obj_dict['attributes'].items(),\n                                  key=itemgetter(0)):\n            if value is not None:\n                graph.append('%s=%s' % (attr, quote_if_necessary(value)))\n            else:\n                graph.append(attr)\n\n            graph.append(';\\n')\n\n        edges_done = set()\n\n        edge_obj_dicts = list()\n        for e in self.obj_dict['edges'].values():\n            edge_obj_dicts.extend(e)\n\n        if edge_obj_dicts:\n            edge_src_set, edge_dst_set = list(\n                zip(*[obj['points'] for obj in edge_obj_dicts]))\n            edge_src_set, edge_dst_set = set(edge_src_set), set(edge_dst_set)\n        else:\n            edge_src_set, edge_dst_set = set(), set()\n\n        node_obj_dicts = list()\n        for e in self.obj_dict['nodes'].values():\n            node_obj_dicts.extend(e)\n\n        sgraph_obj_dicts = list()\n        for sg in self.obj_dict['subgraphs'].values():\n            sgraph_obj_dicts.extend(sg)\n\n        obj_list = sorted([\n            (obj['sequence'], obj)\n            for obj\n            in (edge_obj_dicts + node_obj_dicts + sgraph_obj_dicts)])\n\n        for _idx, obj in obj_list:\n            if obj['type'] == 'node':\n                node = Node(obj_dict=obj)\n\n                if self.obj_dict.get('suppress_disconnected', False):\n                    if (node.get_name() not in edge_src_set and\n                            node.get_name() not in edge_dst_set):\n                        continue\n\n                graph.append(node.to_string() + '\\n')\n\n            elif obj['type'] == 'edge':\n                edge = Edge(obj_dict=obj)\n\n                if self.obj_dict.get('simplify', False) and edge in edges_done:\n                    continue\n\n                graph.append(edge.to_string() + '\\n')\n                edges_done.add(edge)\n            else:\n                sgraph = Subgraph(obj_dict=obj)\n                graph.append(sgraph.to_string() + '\\n')\n\n        graph.append('}\\n')\n\n        return ''.join(graph)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite the graph to file in specified format.", "response": "def write(self, path, prog=None, format='raw'):\n        \"\"\"Write graph to file in selected format.\n\n        Given a filename 'path' it will open/create and truncate\n        such file and write on it a representation of the graph\n        defined by the dot object and in the format specified by\n        'format'. 'path' can also be an open file-like object, such as\n        a StringIO instance.\n\n        The format 'raw' is used to dump the string representation\n        of the Dot object, without further processing.\n        The output can be processed by any of graphviz tools, defined\n        in 'prog', which defaults to 'dot'\n        Returns True or False according to the success of the write\n        operation.\n\n        There's also the preferred possibility of using:\n\n            write_'format'(path, prog='program')\n\n        which are automatically defined for all the supported formats.\n        [write_ps(), write_gif(), write_dia(), ...]\n\n        \"\"\"\n        if prog is None:\n            prog = self.prog\n\n        fobj, close = get_fobj(path, 'w+b')\n        try:\n            if format == 'raw':\n                data = self.to_string()\n                if isinstance(data, basestring):\n                    if not isinstance(data, unicode):\n                        try:\n                            data = unicode(data, 'utf-8')\n                        except Exception:\n                            pass\n\n                try:\n                    charset = self.get_charset()\n                    if not PY3 or not charset:\n                        charset = 'utf-8'\n                    data = data.encode(charset)\n                except Exception:\n                    if PY3:\n                        data = data.encode('utf-8')\n                    pass\n\n                fobj.write(data)\n\n            else:\n                fobj.write(self.create(prog, format))\n        finally:\n            if close:\n                fobj.close()\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_crumbs(self):\n        crumbs = []\n        for cls in reversed(type(self).__mro__[1:]):\n            crumbs.extend(getattr(cls, 'crumbs', ()))\n        crumbs.extend(list(self.crumbs))\n        return tuple(crumbs)", "response": "Get crumbs for navigation links."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, request, *args, **kwargs):\n        context = self.get_context_data(**kwargs)\n        context.update(self.extra_context)\n        context['crumbs'] = self.get_crumbs()\n        context['title'] = self.title\n        context['suit'] = 'suit' in settings.INSTALLED_APPS\n        if context.get('dashboard_grid', None) is None and self.grid:\n            context['dashboard_grid'] = self.grid\n        return self.render_to_response(context)", "response": "This function is called by the get view function. It returns a Django response with the context data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a widget as real - time.", "response": "def realtime(widget, url_name=None, url_regex=None, time_interval=None):\n    \"\"\"\n    Return a widget as real-time.\n\n    Args:\n        widget (Widget): the widget to register and return as real-time.\n        url_name (str): the URL name to call to get updated content.\n        url_regex (regex): the URL regex to be matched.\n        time_interval (int): the interval of refreshment in milliseconds.\n\n    Returns:\n        Widget: the \"real-timed\" widget.\n    \"\"\"\n    if not hasattr(widget, 'get_updated_content'):\n        raise AttributeError('Widget %s must implement get_updated_content '\n                             'method.' % widget)\n    elif not callable(widget.get_updated_content):\n        raise ValueError('get_updated_content in widget %s is not callable'\n                         % widget)\n\n    if url_name is None:\n        if getattr(widget, 'url_name', None) is not None:\n            url_name = widget.url_name\n        else:\n            url_name = widget.__class__.__name__\n\n    if url_name in [w.url_name for w in REALTIME_WIDGETS]:\n        raise ValueError('URL name %s is already used by another '\n                         'real time widget.' % url_name)\n\n    if url_regex is None:\n        if getattr(widget, 'url_regex', None) is not None:\n            url_regex = widget.url_regex\n        else:\n            url_regex = sha256(url_name.encode('utf-8'))\n            url_regex = url_regex.hexdigest()[:32]\n            url_regex = 'realtime/' + url_regex\n\n    if url_regex in [w.url_regex for w in REALTIME_WIDGETS]:\n        raise ValueError('URL regex %s is already used by another '\n                         'real time widget.' % url_regex)\n\n    if time_interval is None:\n        if getattr(widget, 'time_interval', None) is not None:\n            time_interval = widget.time_interval\n        else:\n            time_interval = app_settings.default_time_interval\n\n    from django.views.generic import View\n    from braces.views import AjaxResponseMixin, JSONResponseMixin\n\n    # pylama:ignore=C0111,R0201\n    class PartialResponse(JSONResponseMixin, AjaxResponseMixin, View):\n        def get_data(self):\n            return widget.get_updated_content()\n\n        def get(self, request, *args, **kwargs):\n            return self.get_ajax(request, *args, **kwargs)\n\n        def get_ajax(self, request, *args, **kwargs):\n            return self.render_json_response(self.get_data())\n\n    PartialResponse.url_name = url_name\n    PartialResponse.url_regex = url_regex\n    PartialResponse.time_interval = time_interval\n\n    REALTIME_WIDGETS.append(PartialResponse)\n\n    if not hasattr(widget, 'url_name'):\n        widget.url_name = url_name\n    if not hasattr(widget, 'url_regex'):\n        widget.url_regex = url_regex\n    if not hasattr(widget, 'time_interval'):\n        widget.time_interval = time_interval\n\n    return widget"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_realtime_urls(admin_view_func=lambda x: x):\n    from .widgets import REALTIME_WIDGETS\n    return [url(w.url_regex, admin_view_func(w.as_view()), name=w.url_name)\n            for w in REALTIME_WIDGETS]", "response": "Get the URL for real - time widgets."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setup_db(connection_string):\n    global DB_Session, engine\n    new_database = False\n    if connection_string == 'sqlite://' or not database_exists(connection_string):\n        new_database = True\n    engine = create_engine(connection_string, connect_args={'timeout': 20})\n    entities.Base.metadata.create_all(engine)\n    DB_Session = sessionmaker(bind=engine)\n    db_path = os.path.dirname(__file__)\n\n    if new_database:\n        # bootstrapping the db with classifications types.\n        json_file = open(os.path.join(db_path, 'bootstrap.json'))\n        data = json.load(json_file)\n        session = get_session()\n        session.execute('PRAGMA user_version = {0}'.format(beeswarm.server.db.DATABASE_VERSION))\n        for entry in data['classifications']:\n            c = session.query(Classification).filter(Classification.type == entry['type']).first()\n            if not c:\n                classification = Classification(type=entry['type'], description_short=entry['description_short'],\n                                                description_long=entry['description_long'])\n                session.add(classification)\n            else:\n                c.description_short = entry['description_short']\n                c.description_long = entry['description_long']\n        for username in data['bait_users']:\n            u = session.query(BaitUser).filter(BaitUser.username == username).first()\n            if not u:\n                logger.debug('Creating default BaitUser: {}'.format(username))\n                password = data['bait_users'][username]\n                bait_user = BaitUser(username=username, password=password)\n                session.add(bait_user)\n        session.commit()\n    else:\n        result = engine.execute(\"PRAGMA user_version;\")\n        version = result.fetchone()[0]\n        result.close()\n        logger.info('Database is at version {0}.'.format(version))\n        if version != beeswarm.server.db.DATABASE_VERSION:\n            logger.error('Incompatible database version detected. This version of Beeswarm is compatible with '\n                         'database version {0}, but {1} was found. Please delete the database, restart the Beeswarm '\n                         'server and reconnect the drones.'.format(beeswarm.server.db.DATABASE_VERSION,\n                                                                   version))\n            sys.exit(1)", "response": "Sets up the database schema and adds defaults."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstarts a PTY - intended to run it a ( green ) thread.", "response": "def start_pty_request(self, channel, term, modes):\n        \"\"\"Start a PTY - intended to run it a (green)thread.\"\"\"\n        request = self.dummy_request()\n        request._sock = channel\n        request.modes = modes\n        request.term = term\n        request.username = self.username\n\n        # This should block until the user quits the pty\n        self.pty_handler(request, self.client_address, self.tcp_server, self.vfs, self.session)\n\n        # Shutdown the entire session\n        self.transport.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_time(self):\n\n        poll = self.config['timecheck']['poll']\n        ntp_poll = self.config['timecheck']['ntp_pool']\n        while True:\n            clnt = ntplib.NTPClient()\n            try:\n                response = clnt.request(ntp_poll, version=3)\n                diff = response.offset\n                if abs(diff) >= 15:\n                    logger.error('Timings found to be far off, shutting down drone ({0})'.format(diff))\n                    sys.exit(1)\n                else:\n                    logger.debug('Polled ntp server and found that drone has {0} seconds offset.'.format(diff))\n            except (ntplib.NTPException, _socket.error) as ex:\n                logger.warning('Error while polling ntp server: {0}'.format(ex))\n            gevent.sleep(poll * 60 * 60)", "response": "Check if our Honeypot time is consistent and not too far off\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stop(self):\n\n        for s in self._servers:\n            s.stop()\n\n        for g in self._server_greenlets:\n            g.kill()\n\n        logger.info('All workers stopped.')", "response": "Stops all services and greenlets"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprepares the environment for the Honeypot.", "response": "def prepare_environment(work_dir):\n        \"\"\"\n            Performs a few maintenance tasks before the Honeypot is run. Copies the data directory,\n            and the config file to the cwd. The config file copied here is overwritten if\n            the __init__ method is called with a configuration URL.\n\n        :param work_dir: The directory to copy files to.\n        \"\"\"\n        package_directory = os.path.dirname(os.path.abspath(beeswarm.__file__))\n\n        logger.info('Copying data files to workdir.')\n        shutil.copytree(os.path.join(package_directory, 'drones/honeypot/data'), os.path.join(work_dir, 'data/'),\n                        ignore=Honeypot._ignore_copy_files)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlaunching a new HTTP client session on the server taken from the self. options dict.", "response": "def start(self):\n\n        \"\"\"\n            Launches a new HTTP client session on the server taken from the `self.options` dict.\n\n        :param my_ip: IP of this Client itself\n        \"\"\"\n        username = self.options['username']\n        password = self.options['password']\n        server_host = self.options['server']\n        server_port = self.options['port']\n        honeypot_id = self.options['honeypot_id']\n\n        session = self.create_session(server_host, server_port, honeypot_id)\n\n        self.sessions[session.id] = session\n\n        logger.debug(\n            'Sending {0} bait session to {1}:{2}. (bait id: {3})'.format('http', server_host, server_port, session.id))\n\n        try:\n            url = self._make_url(server_host, '/index.html', server_port)\n            response = self.client.get(url, auth=HTTPBasicAuth(username, password), verify=False)\n            session.did_connect = True\n            if response.status_code == 200:\n                session.add_auth_attempt('plaintext', True, username=username, password=password)\n                session.did_login = True\n            else:\n                session.add_auth_attempt('plaintext', False, username=username, password=password)\n\n            links = self._get_links(response)\n            while self.sent_requests <= self.max_requests and links:\n                url = random.choice(links)\n                response = self.client.get(url, auth=HTTPBasicAuth(username, password), verify=False)\n                links = self._get_links(response)\n\n            session.did_complete = True\n        except Exception as err:\n            logger.debug('Caught exception: {0} ({1})'.format(err, str(type(err))))\n        finally:\n            session.alldone = True\n            session.end_session()\n            self.client.close()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_links(self, response):\n        html_text = response.text.encode('utf-8')\n        doc = document_fromstring(html_text)\n        links = []\n        for e in doc.cssselect('a'):\n            links.append(e.get('href'))", "response": "Parses the response text and returns all the links in it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbootstrap the server and a honeypot.", "response": "def bootstrap(server_workdir, drone_workdir):\n    \"\"\"Bootstraps localhost configurations for a Beeswarm server and a honeypot.\n\n    :param server_workdir: Output directory for the server configuration file.\n    :param drone_workdir: Output directory for the drone configuration file.\n    \"\"\"\n    root_logger = logging.getLogger()\n    root_logger.setLevel(logging.DEBUG)\n\n    formatter = logging.Formatter('%(asctime)-15s (%(name)s) %(message)s')\n\n    console_log = logging.StreamHandler()\n    console_log.setLevel(logging.INFO)\n    console_log.setFormatter(formatter)\n    root_logger.addHandler(console_log)\n\n    server_workdir_absolute = os.path.abspath(server_workdir)\n    old_cwd = os.getcwd()\n    os.chdir(server_workdir)\n    server = Server(server_workdir_absolute, None, start_webui=False, customize=False, reset_password=False,\n                    max_sessions=0, server_hostname='127.0.0.1')\n    logger.info('Server config has been written to {0}'.format(os.path.join(server_workdir, 'beeswarmcfg.json')))\n    gevent.spawn(server.start, False)\n    # waiting game to ensure actors has started.\n    gevent.sleep(2)\n    os.chdir(old_cwd)\n\n    # setting up socket to communicate with ZMQ actor.\n    context = beeswarm.shared.zmq_context\n    database_actor = context.socket(zmq.REQ)\n    database_actor.connect(SocketNames.DATABASE_REQUESTS.value)\n\n    db_session = database_setup.get_session()\n    drone = Honeypot()\n\n    protocol_config = (\n        ('ftp', 21, {\n            'max_attempts': 3,\n            'banner': 'Microsoft FTP Server',\n            'syst_type': 'Windows-NT'\n        }),\n        ('telnet', 23, {\n            'max_attempts': 3\n        }),\n        ('pop3', 110, {\n            'max_attempts': 3\n        }),\n        ('pop3s', 993, {\n            'max_attempts': 3\n        }),\n        ('ssh', 22, {}),\n        ('http', 80, {\n            'banner': 'Microsoft-IIS/5.0'\n        }),\n        ('https', 443, {\n            'banner': 'Microsoft-IIS/5.0'\n        }),\n        ('smtp', 25, {\n            'banner': 'Microsoft ESMTP MAIL service ready'\n        }),\n        ('vnc', 5900, {})\n    )\n\n    for protocol, port, protocol_specific_data in protocol_config:\n        drone.add_capability(protocol, port, protocol_specific_data)\n\n    drone.cert_common_name = '*'\n    drone.cert_country = 'US'\n    drone.cert_state = 'None'\n    drone.cert_locality = 'None'\n    drone.cert_organization = 'None'\n    drone.cert_organization_unit = ''\n\n    db_session.add(drone)\n    db_session.commit()\n    drone_config = send_zmq_request_socket(database_actor, '{0} {1}'.format(Messages.DRONE_CONFIG.value, drone.id))\n\n    with open(os.path.join(drone_workdir, 'beeswarmcfg.json'), 'w') as drone_config_file:\n        drone_config_file.write(json.dumps(drone_config, indent=4))\n    logger.info('Drone config has been written to {0}'.format(os.path.join(server_workdir, 'beeswarmcfg.json')))\n\n    server.stop()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if a database exists on the server.", "response": "def database_exists(url):\n    \"\"\"Check if a database exists.\n\n    :param url: A SQLAlchemy engine URL.\n\n    Performs backend-specific testing to quickly determine if a database\n    exists on the server. ::\n\n        database_exists('postgres://postgres@localhost/name')  #=> False\n        create_database('postgres://postgres@localhost/name')\n        database_exists('postgres://postgres@localhost/name')  #=> True\n\n    Supports checking against a constructed URL as well. ::\n\n        engine = create_engine('postgres://postgres@localhost/name')\n        database_exists(engine.url)  #=> False\n        create_database(engine.url)\n        database_exists(engine.url)  #=> True\n\n    \"\"\"\n\n    url = copy(make_url(url))\n    database = url.database\n    if url.drivername.startswith('postgresql'):\n        url.database = 'template1'\n    else:\n        url.database = None\n\n    engine = sa.create_engine(url)\n\n    if engine.dialect.name == 'postgresql':\n        text = \"SELECT 1 FROM pg_database WHERE datname='%s'\" % database\n        return bool(engine.execute(text).scalar())\n\n    elif engine.dialect.name == 'mysql':\n        text = (\"SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA \"\n                \"WHERE SCHEMA_NAME = '%s'\" % database)\n        return bool(engine.execute(text).scalar())\n\n    elif engine.dialect.name == 'sqlite':\n        return database == ':memory:' or os.path.exists(database)\n\n    else:\n        text = 'SELECT 1'\n        try:\n            url.database = database\n            engine = sa.create_engine(url)\n            engine.execute(text)\n            return True\n\n        except (ProgrammingError, OperationalError):\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a socket that connects to the drones and connects it to the messages.", "response": "def message_proxy(self, work_dir):\n        \"\"\"\n        drone_data_inboud   is for data comming from drones\n        drone_data_outbound is for commands to the drones, topic must either be a drone ID or all for sending\n                            a broadcast message to all drones\n        \"\"\"\n        public_keys_dir = os.path.join(work_dir, 'certificates', 'public_keys')\n        secret_keys_dir = os.path.join(work_dir, 'certificates', 'private_keys')\n\n        # start and configure auth worker\n        auth = IOLoopAuthenticator()\n        auth.start()\n        auth.allow('127.0.0.1')\n        auth.configure_curve(domain='*', location=public_keys_dir)\n\n        # external interfaces for communicating with drones\n        server_secret_file = os.path.join(secret_keys_dir, 'beeswarm_server.pri')\n        server_public, server_secret = load_certificate(server_secret_file)\n        drone_data_inbound = beeswarm.shared.zmq_context.socket(zmq.PULL)\n        drone_data_inbound.curve_secretkey = server_secret\n        drone_data_inbound.curve_publickey = server_public\n        drone_data_inbound.curve_server = True\n        drone_data_inbound.bind('tcp://*:{0}'.format(self.config['network']['zmq_port']))\n\n        drone_data_outbound = beeswarm.shared.zmq_context.socket(zmq.PUB)\n        drone_data_outbound.curve_secretkey = server_secret\n        drone_data_outbound.curve_publickey = server_public\n        drone_data_outbound.curve_server = True\n        drone_data_outbound.bind('tcp://*:{0}'.format(self.config['network']['zmq_command_port']))\n\n        # internal interfaces\n        # all inbound session data from drones will be replayed on this socket\n        drone_data_socket = beeswarm.shared.zmq_context.socket(zmq.PUB)\n        drone_data_socket.bind(SocketNames.DRONE_DATA.value)\n\n        # all commands received on this will be published on the external interface\n        drone_command_socket = beeswarm.shared.zmq_context.socket(zmq.PULL)\n        drone_command_socket.bind(SocketNames.DRONE_COMMANDS.value)\n\n        poller = zmq.Poller()\n        poller.register(drone_data_inbound, zmq.POLLIN)\n        poller.register(drone_command_socket, zmq.POLLIN)\n        while True:\n            # .recv() gives no context switch - why not? using poller with timeout instead\n            socks = dict(poller.poll(100))\n            gevent.sleep()\n\n            if drone_command_socket in socks and socks[drone_command_socket] == zmq.POLLIN:\n                data = drone_command_socket.recv()\n                drone_id, _ = data.split(' ', 1)\n                logger.debug(\"Sending drone command to: {0}\".format(drone_id))\n                # pub socket takes care of filtering\n                drone_data_outbound.send(data)\n            elif drone_data_inbound in socks and socks[drone_data_inbound] == zmq.POLLIN:\n                raw_msg = drone_data_inbound.recv()\n                split_data = raw_msg.split(' ', 2)\n                if len(split_data) == 3:\n                    topic, drone_id, data = split_data\n                else:\n                    data = None\n                    topic, drone_id, = split_data\n                logger.debug(\"Received {0} message from {1}.\".format(topic, drone_id))\n                # relay message on internal socket\n                drone_data_socket.send(raw_msg)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef start(self):\n        self.started = True\n        if self.app:\n            web_port = self.config['network']['web_port']\n            logger.info('Starting server listening on port {0}'.format(web_port))\n            key_file = os.path.join(self.work_dir, 'server.key')\n            cert_file = os.path.join(self.work_dir, 'server.crt')\n            http_server = WSGIServer(('', web_port), self.app, keyfile=key_file, certfile=cert_file)\n            http_server_greenlet = gevent.spawn(http_server.serve_forever)\n            self.greenlets.append(http_server_greenlet)\n\n        stop_if_not_write_workdir(self.work_dir)\n        logger.info('Server started.')\n        gevent.joinall(self.greenlets)", "response": "Starts the BeeSwarm server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload the configuration from the JSON file and returns it.", "response": "def get_config(self, configfile):\n        \"\"\"\n            Loads the configuration from the JSON file, and returns it.\n        :param configfile: Path to the configuration file\n        \"\"\"\n        with open(configfile) as config_file:\n            config = json.load(config_file)\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn true if current time is in the active range", "response": "def time_in_range(self):\n        \"\"\"Return true if current time is in the active range\"\"\"\n        curr = datetime.datetime.now().time()\n        if self.start_time <= self.end_time:\n            return self.start_time <= curr <= self.end_time\n        else:\n            return self.start_time <= curr or curr <= self.end_time"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start(self):\n        password = self.options['password']\n        server_host = self.options['server']\n        server_port = self.options['port']\n        honeypot_id = self.options['honeypot_id']\n\n        session = self.create_session(server_host, server_port, honeypot_id)\n        self.sessions[session.id] = session\n\n        logger.debug(\n            'Sending {0} bait session to {1}:{2}. (bait id: {3})'.format('vnc', server_host, server_port, session.id))\n        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            client_socket.connect((server_host, int(server_port)))\n            session.source_port = client_socket.getsockname()[1]\n\n        except socket.error as e:\n            logger.debug('Caught exception: {0} ({1})'.format(e, str(type(e))))\n        else:\n            session.did_connect = True\n            protocol_version = client_socket.recv(1024)\n            client_socket.send(RFB_VERSION)\n            supported_auth_methods = client_socket.recv(1024)\n\n            # \\x02 implies that VNC authentication method is to be used\n            # Refer to http://tools.ietf.org/html/rfc6143#section-7.1.2 for more info.\n            if '\\x02' in supported_auth_methods:\n                client_socket.send(VNC_AUTH)\n            challenge = client_socket.recv(1024)\n\n            # password limit for vnc in 8 chars\n            aligned_password = (password + '\\0' * 8)[:8]\n            des = RFBDes(aligned_password)\n            response = des.encrypt(challenge)\n\n            client_socket.send(response)\n            auth_status = client_socket.recv(1024)\n            if auth_status == AUTH_SUCCESSFUL:\n                session.add_auth_attempt('des_challenge', True, password=aligned_password)\n                session.did_login = True\n            else:\n                session.add_auth_attempt('des_challenge', False, password=aligned_password)\n                session.did_login = False\n            session.did_complete = True\n\n        finally:\n            session.alldone = True\n            session.end_session()\n            if client_socket:\n                client_socket.close()", "response": "Launches a new Telnet client session on the server taken from the self. options dict."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_session(self, server_host, server_port, honeypot_id):\n        protocol = self.__class__.__name__.lower()\n        session = BaitSession(protocol, server_host, server_port, honeypot_id)\n        self.sessions[session.id] = session\n        return session", "response": "Creates a new session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlaunching a new FTP client session on the server taken from the self. options dict.", "response": "def start(self):\n\n        \"\"\"\n            Launches a new FTP client session on the server taken from the `self.options` dict.\n\n        :param my_ip: IP of this Client itself\n        \"\"\"\n        username = self.options['username']\n        password = self.options['password']\n        server_host = self.options['server']\n        server_port = self.options['port']\n        honeypot_id = self.options['honeypot_id']\n        command_limit = random.randint(6, 11)\n\n        session = self.create_session(server_host, server_port, honeypot_id)\n\n        self.sessions[session.id] = session\n        logger.debug(\n            'Sending {0} bait session to {1}:{2}. (bait id: {3})'.format('ftp', server_host, server_port, session.id))\n\n        self.file_list = []\n        try:\n            self.connect()\n            session.did_connect = True\n\n            # TODO: Catch login failure\n            self.login(username, password)\n            session.add_auth_attempt('plaintext', True, username=username, password=password)\n\n            session.did_login = True\n            session.timestamp = datetime.utcnow()\n        except ftplib.error_perm as err:\n            logger.debug('Caught exception: {0} ({1})'.format(err, str(type(err))))\n        except socket.error as err:\n            logger.debug('Error while communicating: {0} ({1})'.format(err, str(type(err))))\n        else:\n            command_count = 0\n            while command_count <= command_limit:\n                command_count += 1\n                try:\n                    self.sense()\n                    cmd, param = self.decide()\n                    self.act(cmd, param)\n                    gevent.sleep(random.uniform(0, 3))\n                except IndexError:  # This means we hit an empty folder, or a folder with only files.\n                    continue\n            session.did_complete = True\n        finally:\n            if self.client.sock is not None:\n                # will close socket\n                self.client.quit()\n            session.alldone = True\n        session.end_session()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sense(self):\n        cmd_name = random.choice(self.senses)\n        command = getattr(self, cmd_name)\n        self.state['last_command'] = cmd_name\n        command()", "response": "Launches a few sensing commands such as ls or pwd."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decide(self):\n        next_command_name = random.choice(self.COMMAND_MAP[self.state['last_command']])\n        param = ''\n        if next_command_name == 'retrieve':\n            param = random.choice(self.state['file_list'])\n        elif next_command_name == 'cwd':\n            param = random.choice(self.state['dir_list'])\n        return next_command_name, param", "response": "Decides the next command to be launched based on the current state."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the command with the parameters.", "response": "def act(self, cmd_name, param):\n        \"\"\"\n            Run the command with the parameters.\n\n        :param cmd_name: The name of command to run\n        :param param: Params for the command\n        \"\"\"\n        command = getattr(self, cmd_name)\n        if param:\n            command(param)\n        else:\n            command()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending the LIST command to the server.", "response": "def list(self):\n        \"\"\"\n            Run the FTP LIST command, and update the state.\n        \"\"\"\n        logger.debug('Sending FTP list command.')\n        self.state['file_list'] = []\n        self.state['dir_list'] = []\n        self.client.retrlines('LIST', self._process_list)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun the FTP RETR command and download the file", "response": "def retrieve(self, filename):\n        \"\"\"\n            Run the FTP RETR command, and download the file\n\n        :param filename: Name of the file to download\n        \"\"\"\n        logger.debug('Sending FTP retr command. Filename: {}'.format(filename))\n        self.client.retrbinary('RETR {}'.format(filename), self._save_file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cwd(self, newdir):\n        logger.debug('Sending FTP cwd command. New Workding Directory: {}'.format(newdir))\n        self.client.cwd(newdir)\n        self.state['current_dir'] = self.client.pwd()", "response": "Send the FTP CWD command to change the current working directory"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _process_list(self, list_line):\n        # -rw-r--r-- 1 ftp ftp 68\t May 09 19:37 testftp.txt\n        \"\"\"\n            Processes a line of 'ls -l' output, and updates state accordingly.\n\n        :param list_line: Line to process\n        \"\"\"\n        res = list_line.split(' ', 8)\n        if res[0].startswith('-'):\n            self.state['file_list'].append(res[-1])\n        if res[0].startswith('d'):\n            self.state['dir_list'].append(res[-1])", "response": "Processes a line of ls - l output and updates state accordingly."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate_time_range(form, field):\n\n    string = field.data\n    try:\n        begin, end = string.split('-')\n        begin = begin.strip()\n        end = end.strip()\n        begin_hours, begin_min = begin.split(':')\n        end_hours, end_min = end.split(':')\n        assert 0 <= int(begin_hours) <= 23\n        assert 0 <= int(end_hours) <= 23\n        assert 0 <= int(begin_min) <= 59\n        assert 0 <= int(end_min) <= 59\n        assert begin_hours <= end_hours\n        if begin_hours == end_hours:\n            assert begin_min < end_min\n    except (ValueError, AssertionError):\n        raise ValidationError('Make sure the time is in correct format: \"hh:mm - hh:mm\"')", "response": "Make sure the form data is in the correct format and the start time is less than end time."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef start(self):\n        logger.info('Starting client.')\n\n        self.dispatcher_greenlets = []\n\n        for _, entry in self.config['baits'].items():\n            for b in clientbase.ClientBase.__subclasses__():\n                bait_name = b.__name__.lower()\n                # if the bait has a entry in the config we consider the bait enabled\n                if bait_name in entry:\n                    bait_options = entry[bait_name]\n                    dispatcher = BaitDispatcher(b, bait_options)\n                    dispatcher.start()\n                    self.dispatcher_greenlets.append(dispatcher)\n                    logger.info('Adding {0} bait'.format(bait_name))\n                    logger.debug('Bait added with options: {0}'.format(bait_options))\n\n        gevent.joinall(self.dispatcher_greenlets)", "response": "Starts sending bait to the configured Honeypot."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start(self):\n\n        username = self.options['username']\n        password = self.options['password']\n        server_host = self.options['server']\n        server_port = self.options['port']\n        honeypot_id = self.options['honeypot_id']\n\n        session = self.create_session(server_host, server_port, honeypot_id)\n\n        try:\n            logger.debug(\n                'Sending {0} bait session to {1}:{2}. (bait id: {3})'.format('pop3', server_host, server_port,\n                                                                             session.id))\n            conn = poplib.POP3_SSL(server_host, server_port)\n            session.source_port = conn.sock.getsockname()[1]\n\n            banner = conn.getwelcome()\n            session.protocol_data['banner'] = banner\n            session.did_connect = True\n\n            conn.user(username)\n            conn.pass_(password)\n            # TODO: Handle failed login\n            session.add_auth_attempt('plaintext', True, username=username, password=password)\n            session.did_login = True\n            session.timestamp = datetime.utcnow()\n        except Exception as err:\n            logger.debug('Caught exception: {0} ({1})'.format(err, str(type(err))))\n        else:\n            list_entries = conn.list()[1]\n            for entry in list_entries:\n                index, _ = entry.split(' ')\n                conn.retr(index)\n                conn.dele(index)\n            logger.debug('Found and deleted {0} messages on {1}'.format(len(list_entries), server_host))\n            conn.quit()\n            session.did_complete = True\n        finally:\n            session.alldone = True\n            session.end_session()", "response": "Launches a new POP3 client session on the server taken from the self. options dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntrying to match a session with it s counterpart.", "response": "def get_matching_session(self, session, db_session, timediff=5):\n        \"\"\"\n        Tries to match a session with it's counterpart. For bait session it will try to match it with honeypot sessions\n        and the other way around.\n\n        :param session: session object which will be used as base for query.\n        :param timediff: +/- allowed time difference between a session and a potential matching session.\n        \"\"\"\n        db_session = db_session\n        min_datetime = session.timestamp - timedelta(seconds=timediff)\n        max_datetime = session.timestamp + timedelta(seconds=timediff)\n        # default return value\n        match = None\n        classification = db_session.query(Classification).filter(\n            Classification.type == 'pending').one()\n        # get all sessions that match basic properties.\n        sessions = db_session.query(Session).options(joinedload(Session.authentication)) \\\n            .filter(Session.protocol == session.protocol) \\\n            .filter(Session.honeypot == session.honeypot) \\\n            .filter(Session.timestamp >= min_datetime) \\\n            .filter(Session.timestamp <= max_datetime) \\\n            .filter(Session.id != session.id) \\\n            .filter(Session.classification == classification)\n\n        # identify the correct session by comparing authentication.\n        # this could properly also be done using some fancy ORM/SQL construct.\n        for potential_match in sessions:\n            if potential_match.discriminator == session.discriminator:\n                continue\n            assert potential_match.id != session.id\n            for honey_auth in session.authentication:\n                for session_auth in potential_match.authentication:\n                    if session_auth.username == honey_auth.username and \\\n                            session_auth.password == honey_auth.password and \\\n                            session_auth.successful == honey_auth.successful:\n                        assert potential_match.id != session.id\n                        match = potential_match\n                        break\n\n        return match"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclassifies all unclassified sessions as malicious activity.", "response": "def _classify_malicious_sessions(self):\n        \"\"\"\n        Will classify all unclassified sessions as malicious activity.\n\n        :param delay_seconds: no sessions newer than (now - delay_seconds) will be processed.\n        \"\"\"\n        min_datetime = datetime.utcnow() - timedelta(seconds=self.delay_seconds)\n\n        db_session = database_setup.get_session()\n\n        # find and process bait sessions that did not get classified during\n        # persistence.\n        bait_sessions = db_session.query(BaitSession).options(joinedload(BaitSession.authentication)) \\\n            .filter(BaitSession.classification_id == 'pending') \\\n            .filter(BaitSession.did_complete == True) \\\n            .filter(BaitSession.received < min_datetime).all()\n\n        for bait_session in bait_sessions:\n            logger.debug(\n                'Classifying bait session with id {0} as MITM'.format(bait_session.id))\n            bait_session.classification = db_session.query(\n                Classification).filter(Classification.type == 'mitm').one()\n            db_session.commit()\n\n        # find and process honeypot sessions that did not get classified during\n        # persistence.\n        sessions = db_session.query(Session, Drone.name).filter(Session.discriminator == None) \\\n            .filter(Session.timestamp <= min_datetime) \\\n            .filter(Session.classification_id == 'pending') \\\n            .all()\n\n        for entry in sessions:\n            # Check if the attack used credentials leaked by beeswarm drones\n            session = entry[0]\n            bait_match = None\n            for a in session.authentication:\n                bait_match = db_session.query(BaitSession) \\\n                    .filter(BaitSession.authentication.any(username=a.username, password=a.password)).first()\n                if bait_match:\n                    break\n\n            if bait_match:\n                logger.debug('Classifying session with id {0} as attack which involved the reuse '\n                             'of previously transmitted credentials.'.format(session.id))\n                session.classification = db_session.query(Classification).filter(\n                    Classification.type == 'credentials_reuse').one()\n            elif len(session.authentication) == 0:\n                logger.debug(\n                    'Classifying session with id {0} as probe.'.format(session.id))\n                session.classification = db_session.query(\n                    Classification).filter(Classification.type == 'probe').one()\n            else:\n                # we have never transmitted this username/password combo\n                logger.debug(\n                    'Classifying session with id {0} as bruteforce attempt.'.format(session.id))\n                session.classification = db_session.query(Classification).filter(\n                    Classification.type == 'bruteforce').one()\n            db_session.commit()\n            session.name = entry[1]\n            self.processedSessionsPublisher.send(\n                '{0} {1}'.format(Messages.SESSION.value, json.dumps(session.to_dict())))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlaunching a new SSH client session on the server taken from the self. options dict.", "response": "def start(self):\n        \"\"\"\n            Launches a new SSH client session on the server taken from the `self.options` dict.\n\n        :param my_ip: IP of this Client itself\n        \"\"\"\n        username = self.options['username']\n        password = self.options['password']\n        server_host = self.options['server']\n        server_port = self.options['port']\n        honeypot_id = self.options['honeypot_id']\n\n        session = self.create_session(server_host, server_port, honeypot_id)\n\n        self.sessions[session.id] = session\n        logger.debug(\n            'Sending ssh bait session to {0}:{1}. (bait id: {2})'.format(server_host, server_port, session.id))\n        try:\n            self.connect_login()\n            session.did_connect = True\n            # TODO: Handle failed login\n            session.add_auth_attempt('plaintext', True, username=username, password=password)\n            session.did_login = True\n        except (SSHException, AuthenticationFailed) as err:\n            logger.debug('Caught exception: {0} ({1})'.format(err, str(type(err))))\n        else:\n            command_count = 0\n            command_limit = random.randint(6, 11)\n            while command_count < command_limit:\n                command_count += 1\n                self.sense()\n                comm, param = self.decide()\n                self.act(comm, param)\n                gevent.sleep(random.uniform(0.4, 5.6))\n            self.logout()\n            session.did_complete = True\n        finally:\n            session.alldone = True\n            session.end_session()\n            self.comm_chan.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a command to the remote SSH server.", "response": "def send_command(self, cmd):\n        \"\"\"\n            Send a command to the remote SSH server.\n\n        :param cmd: The command to send\n        \"\"\"\n        logger.debug('Sending {0} command.'.format(cmd))\n        self.comm_chan.sendall(cmd + '\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the response from the server.", "response": "def get_response(self):\n        \"\"\"\n            Get the response from the server. *This may not return the full response*\n\n        :return: Response data\n        \"\"\"\n        while not self.comm_chan.recv_ready():\n            time.sleep(0.5)\n        return self.comm_chan.recv(2048)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect_login(self):\n        self.client.connect(self.options['server'], self.options['port'], self.options['username'],\n                            self.options['password'])\n        self.comm_chan = self.client.invoke_shell()\n        time.sleep(1)  # Let the server take some time to get ready.\n        while not self.comm_chan.recv_ready():\n            time.sleep(0.5)\n        login_response = self.comm_chan.recv(2048)\n        if not login_response.endswith('$ '):\n            raise AuthenticationFailed\n        return login_response", "response": "Connect to the Remote SSH Server and login to the Remote SSH Server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list2dict(list_of_options):\n    d = {}\n    for key, value in list_of_options:\n        d[key] = value\n    return d", "response": "Transforms a list of 2 element tuples to a dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting an absolute path to an entry resembling the output of the ls command on most UNIX systems.", "response": "def path_to_ls(fn):\n    \"\"\" Converts an absolute path to an entry resembling the output of\n        the ls command on most UNIX systems.\"\"\"\n    st = os.stat(fn)\n    full_mode = 'rwxrwxrwx'\n    mode = ''\n    file_time = ''\n    d = ''\n    for i in range(9):\n        # Incrementally builds up the 9 character string, using characters from the\n        # fullmode (defined above) and mode bits from the stat() system call.\n        mode += ((st.st_mode >> (8 - i)) & 1) and full_mode[i] or '-'\n        d = (os.path.isdir(fn)) and 'd' or '-'\n        file_time = time.strftime(' %b %d %H:%M ', time.gmtime(st.st_mtime))\n    list_format = '{0}{1} 1 ftp ftp {2}\\t{3}{4}'.format(d, mode, str(st.st_size), file_time, os.path.basename(fn))\n    return list_format"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrestarts the drone and starts it", "response": "def _start_drone(self):\n        \"\"\"\n        Restarts the drone\n        \"\"\"\n\n        with open(self.config_file, 'r') as config_file:\n            self.config = json.load(config_file, object_hook=asciify)\n\n        mode = None\n        if self.config['general']['mode'] == '' or self.config['general']['mode'] is None:\n            logger.info('Drone has not been configured, awaiting configuration from Beeswarm server.')\n        elif self.config['general']['mode'] == 'honeypot':\n            mode = Honeypot\n        elif self.config['general']['mode'] == 'client':\n            mode = Client\n\n        if mode:\n            self.drone = mode(self.work_dir, self.config)\n            self.drone_greenlet = gevent.spawn(self.drone.start)\n            self.drone_greenlet.link_exception(self.on_exception)\n            logger.info('Drone configured and running. ({0})'.format(self.id))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stop(self):\n        logging.debug('Stopping drone, hang on.')\n        if self.drone is not None:\n            self.drone_greenlet.unlink(self.on_exception)\n            self.drone.stop()\n            self.drone_greenlet.kill()\n            self.drone = None\n        # just some time for the drone to powerdown to be nice.\n        gevent.sleep(2)\n        if self.drone_greenlet is not None:\n            self.drone_greenlet.kill(timeout=5)", "response": "Stops the drone and kills the drone_greenlet."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlaunching a new SMTP client session on the server taken from the self. options dict.", "response": "def start(self):\n        \"\"\"\n            Launches a new SMTP client session on the server taken from the `self.options` dict.\n\n        :param my_ip: IP of this Client itself\n        \"\"\"\n\n        username = self.options['username']\n        password = self.options['password']\n        server_host = self.options['server']\n        server_port = self.options['port']\n        honeypot_id = self.options['honeypot_id']\n\n        session = self.create_session(server_host, server_port, honeypot_id)\n\n        logger.debug(\n            'Sending {0} bait session to {1}:{2}. (bait id: {3})'.format('smtp', server_host, server_port, session.id))\n\n        try:\n            self.connect()\n            session.did_connect = True\n            session.source_port = self.client.sock.getsockname()[1]\n            self.login(username, password)\n\n            # TODO: Handle failed login\n            # TODO: password='' is sillly fix, this needs to be fixed server side...\n            session.add_auth_attempt('plaintext', True, username=username, password='')\n            session.did_login = True\n\n        except smtplib.SMTPException as error:\n            logger.debug('Caught exception: {0} ({1})'.format(error, str(type(error))))\n        else:\n            while self.sent_mails <= self.max_mails:\n                from_addr, to_addr, mail_body = self.get_one_mail()\n                try:\n                    if from_addr and to_addr and isinstance(mail_body, str):\n                        self.client.sendmail(from_addr, to_addr, mail_body)\n                    else:\n                        continue\n                except TypeError as e:\n                    logger.debug('Malformed email in mbox archive, skipping.')\n                    continue\n                else:\n                    self.sent_mails += 1\n                    logger.debug('Sent mail from ({0}) to ({1})'.format(from_addr, to_addr))\n                time.sleep(1)\n            self.client.quit()\n            session.did_complete = True\n        finally:\n            logger.debug('SMTP Session complete.')\n            session.alldone = True\n            session.end_session()\n            self.client.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nchoose and return a random email from the mail archive.", "response": "def get_one_mail(self):\n        \"\"\"\n            Choose and return a random email from the mail archive.\n\n        :return: Tuple containing From Address, To Address and the mail body.\n        \"\"\"\n\n        while True:\n            mail_key = random.choice(self.mailbox.keys())\n            mail = self.mailbox[mail_key]\n            from_addr = mail.get_from()\n            to_addr = mail['To']\n            mail_body = mail.get_payload()\n            if not from_addr or not to_addr:\n                continue\n            return from_addr, to_addr, mail_body"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connect(self):\n        # TODO: local_hostname should be configurable\n        self.client = smtplib.SMTP(self.options['server'], self.options['port'],\n                                   local_hostname='local.domain', timeout=15)", "response": "Connect to the SMTP server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle(self):\n        \"The actual service to which the user has connected.\"\n        if not self.authentication_ok():\n            return\n        if self.DOECHO:\n            self.writeline(self.WELCOME)\n        self.session_start()\n        while self.RUNSHELL:\n            read_line = self.readline(prompt=self.PROMPT).strip('\\r\\n')\n            if read_line:\n                self.session.transcript_incoming(read_line)\n            self.input = self.input_reader(self, read_line)\n            self.raw_input = self.input.raw\n            if self.input.cmd:\n                # TODO: Command should not be converted to upper\n                # looks funny in error messages.\n                cmd = self.input.cmd.upper()\n                params = self.input.params\n                if cmd in self.COMMANDS:\n                    try:\n                        self.COMMANDS[cmd](params)\n                    except:\n                        logger.exception('Error calling {0}.'.format(cmd))\n                        (t, p, tb) = sys.exc_info()\n                        if self.handleException(t, p, tb):\n                            break\n                else:\n                    self.writeline('-bash: {0}: command not found'.format(cmd))\n                    logger.error(\"Unknown command '{0}'\".format(cmd))\n        logger.debug(\"Exiting handler\")", "response": "The actual service to which the user has connected."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert list items into Ascii - fies list values", "response": "def _asciify_list(data):\n    \"\"\" Ascii-fies list values \"\"\"\n    ret = []\n    for item in data:\n        if isinstance(item, unicode):\n            item = _remove_accents(item)\n            item = item.encode('utf-8')\n        elif isinstance(item, list):\n            item = _asciify_list(item)\n        elif isinstance(item, dict):\n            item = _asciify_dict(item)\n        ret.append(item)\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts dict keys and values into Ascii - fies dict keys and values", "response": "def _asciify_dict(data):\n    \"\"\" Ascii-fies dict keys and values \"\"\"\n    ret = {}\n    for key, value in data.iteritems():\n        if isinstance(key, unicode):\n            key = _remove_accents(key)\n            key = key.encode('utf-8')\n            # # note new if\n        if isinstance(value, unicode):\n            value = _remove_accents(value)\n            value = value.encode('utf-8')\n        elif isinstance(value, list):\n            value = _asciify_list(value)\n        elif isinstance(value, dict):\n            value = _asciify_dict(value)\n        ret[key] = value\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_human(self, buffer_):\n\n        if self.IAC in buffer_:\n            buffer_ = buffer_.replace(self.IAC, self.IAC + self.IAC)\n        self.msg(\"send %r\", buffer_)\n        for char in buffer_:\n            delta = random.gauss(80, 20)\n            self.sock.sendall(char)\n            time.sleep(delta / 1000.0)", "response": "Emulates human typing speed"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start(self):\n\n        login = self.options['username']\n        password = self.options['password']\n        server_host = self.options['server']\n        server_port = self.options['port']\n        honeypot_id = self.options['honeypot_id']\n        command_limit = random.randint(6, 11)\n\n        session = self.create_session(server_host, server_port, honeypot_id)\n        self.sessions[session.id] = session\n        logger.debug(\n            'Sending telnet bait session to {0}:{1}. (bait id: {2})'.format(server_host, server_port, session.id))\n\n        try:\n            self.connect()\n            self.login(login, password)\n\n            session.add_auth_attempt('plaintext', True, username=login, password=password)\n\n            session.did_connect = True\n            session.source_port = self.client.sock.getsockname()[1]\n            session.did_login = True\n        except InvalidLogin:\n            logger.debug('Telnet session could not login. ({0})'.format(session.id))\n            session.did_login = False\n        except Exception as err:\n            logger.debug('Caught exception: {0} {1}'.format(err, str(err), exc_info=True))\n        else:\n            command_count = 0\n            while command_count < command_limit:\n                command_count += 1\n                self.sense()\n                comm, param = self.decide()\n                self.act(comm, param)\n                gevent.sleep(random.uniform(0.4, 5.6))\n            self.act('logout')\n            session.did_complete = True\n        finally:\n            session.alldone = True\n            session.end_session()\n            if self.client:\n                self.client.close()", "response": "Launches a new Telnet client session on the server taken from the self. options dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(self):\n        self.client = BaitTelnetClient(self.options['server'], self.options['port'])\n        self.client.set_option_negotiation_callback(self.process_options)", "response": "Open a new telnet session on the remote server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef login(self, login, password):\n        self.client.read_until('Username: ')\n        self.client.write(login + '\\r\\n')\n        self.client.read_until('Password: ')\n        self.client.write(password + '\\r\\n')\n        current_data = self.client.read_until('$ ', 10)\n        if not current_data.endswith('$ '):\n            raise InvalidLogin", "response": "Log in to the remote telnet server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an auth attempt to the log.", "response": "def add_auth_attempt(self, auth_type, successful, **kwargs):\n        \"\"\"\n        :param username:\n        :param password:\n        :param auth_type: possible values:\n                                plain: plaintext username/password\n        :return:\n        \"\"\"\n\n        entry = {'timestamp': datetime.utcnow(),\n                 'auth': auth_type,\n                 'id': uuid.uuid4(),\n                 'successful': successful}\n\n        log_string = ''\n        for key, value in kwargs.iteritems():\n            if key == 'challenge' or key == 'response':\n                entry[key] = repr(value)\n            else:\n                entry[key] = value\n                log_string += '{0}:{1}, '.format(key, value)\n\n        self.login_attempts.append(entry)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sense(self):\n\n        cmd_name = random.choice(self.senses)\n        param = ''\n        if cmd_name == 'ls':\n            if random.randint(0, 1):\n                param = '-l'\n        elif cmd_name == 'uname':\n            # Choose options from predefined ones\n            opts = 'asnrvmpio'\n            start = random.randint(0, len(opts) - 2)\n            end = random.randint(start + 1, len(opts) - 1)\n            param = '-{}'.format(opts[start:end])\n        command = getattr(self, cmd_name)\n        command(param)", "response": "Launch a command in the sense list and update the current state."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nchoose the next command to execute and its parameters based on the current state.", "response": "def decide(self):\n        \"\"\" Choose the next command to execute, and its parameters, based on the current\n            state.\n        \"\"\"\n\n        next_command_name = random.choice(self.COMMAND_MAP[self.state['last_command']])\n        param = ''\n        if next_command_name == 'cd':\n            try:\n                param = random.choice(self.state['dir_list'])\n            except IndexError:\n                next_command_name = 'ls'\n\n        elif next_command_name == 'uname':\n            opts = 'asnrvmpio'\n            start = random.randint(0, len(opts) - 2)\n            end = random.randint(start + 1, len(opts) - 1)\n            param = '-{}'.format(opts[start:end])\n        elif next_command_name == 'ls':\n            if random.randint(0, 1):\n                param = '-l'\n        elif next_command_name == 'cat':\n            try:\n                param = random.choice(self.state['file_list'])\n            except IndexError:\n                param = ''.join(random.choice(string.lowercase) for x in range(3))\n        elif next_command_name == 'echo':\n            param = random.choice([\n                '$http_proxy',\n                '$https_proxy',\n                '$ftp_proxy',\n                '$BROWSER',\n                '$EDITOR',\n                '$SHELL',\n                '$PAGER'\n            ])\n        elif next_command_name == 'sudo':\n            param = random.choice([\n                'pm-hibernate',\n                'shutdown -h',\n                'vim /etc/httpd.conf',\n                'vim /etc/resolve.conf',\n                'service network restart',\n                '/etc/init.d/network-manager restart',\n            ])\n        return next_command_name, param"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun the specified command with its parameters.", "response": "def act(self, cmd_name, params=None):\n        \"\"\" Run the specified command with its parameters.\"\"\"\n\n        command = getattr(self, cmd_name)\n        if params:\n            command(params)\n        else:\n            command()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprepares a JSON payload which will be logged.", "response": "def json_record(self, message, extra, record):\n        \"\"\"Prepares a JSON payload which will be logged.\n\n        Override this method to change JSON log format.\n\n        :param message: Log message, e.g., `logger.info(msg='Sign up')`.\n        :param extra: Dictionary that was passed as `extra` param\n            `logger.info('Sign up', extra={'referral_code': '52d6ce'})`.\n        :param record: `LogRecord` we got from `JSONFormatter.format()`.\n        :return: Dictionary which will be passed to JSON lib.\n\n        \"\"\"\n        extra['message'] = message\n        if 'time' not in extra:\n            extra['time'] = datetime.utcnow()\n\n        if record.exc_info:\n            extra['exc_info'] = self.formatException(record.exc_info)\n\n        return extra"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\noverrides it to convert fields of json_record to needed types.", "response": "def mutate_json_record(self, json_record):\n        \"\"\"Override it to convert fields of `json_record` to needed types.\n\n        Default implementation converts `datetime` to string in ISO8601 format.\n\n        \"\"\"\n        for attr_name in json_record:\n            attr = json_record[attr_name]\n            if isinstance(attr, datetime):\n                json_record[attr_name] = attr.isoformat()\n        return json_record"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(self):\n        channel = self._ssh_client.get_transport().open_session()\n        self._channel = channel\n        channel.exec_command(\"gerrit stream-events\")\n        stdout = channel.makefile()\n        stderr = channel.makefile_stderr()\n        while not self._stop.is_set():\n            try:\n                if channel.exit_status_ready():\n                    if channel.recv_stderr_ready():\n                        error = stderr.readline().strip()\n                    else:\n                        error = \"Remote server connection closed\"\n                    self._error_event(error)\n                    self._stop.set()\n                else:\n                    data = stdout.readline()\n                    self._gerrit.put_event(data)\n            except Exception as e:  # pylint: disable=W0703\n                self._error_event(repr(e))\n                self._stop.set()", "response": "Listen to the stream and send events to the client."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_command(self, command):\n        if not isinstance(command, basestring):\n            raise ValueError(\"command must be a string\")\n        return self._ssh_client.run_gerrit_command(command)", "response": "Run a command.\n\n        :arg str command: The command to run.\n\n        :Return: The result as a string.\n\n        :Raises: `ValueError` if `command` is not a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef query(self, term):\n        results = []\n        command = [\"query\", \"--current-patch-set\", \"--all-approvals\",\n                   \"--format JSON\", \"--commit-message\"]\n\n        if not isinstance(term, basestring):\n            raise ValueError(\"term must be a string\")\n\n        command.append(escape_string(term))\n        result = self._ssh_client.run_gerrit_command(\" \".join(command))\n        decoder = JSONDecoder()\n        for line in result.stdout.read().splitlines():\n            # Gerrit's response to the query command contains one or more\n            # lines of JSON-encoded strings.  The last one is a status\n            # dictionary containing the key \"type\" whose value indicates\n            # whether or not the operation was successful.\n            # According to http://goo.gl/h13HD it should be safe to use the\n            # presence of the \"type\" key to determine whether the dictionary\n            # represents a change or if it's the query status indicator.\n            try:\n                data = decoder.decode(line)\n            except ValueError as err:\n                raise GerritError(\"Query returned invalid data: %s\", err)\n            if \"type\" in data and data[\"type\"] == \"error\":\n                raise GerritError(\"Query error: %s\" % data[\"message\"])\n            elif \"project\" in data:\n                results.append(Change(data))\n        return results", "response": "Run a query on the current patch set."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start_event_stream(self):\n        if not self._stream:\n            self._stream = GerritStream(self, ssh_client=self._ssh_client)\n            self._stream.start()", "response": "Start streaming events from gerrit stream - events."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stop_event_stream(self):\n        if self._stream:\n            self._stream.stop()\n            self._stream.join()\n            self._stream = None\n            with self._events.mutex:\n                self._events.queue.clear()", "response": "Stop streaming events from gerrit stream - events."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_event(self, block=True, timeout=None):\n        try:\n            return self._events.get(block, timeout)\n        except Empty:\n            return None", "response": "Get the next event from the queue."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef put_event(self, data):\n        try:\n            event = self._factory.create(data)\n            self._events.put(event)\n        except Full:\n            raise GerritError(\"Unable to add event: queue is full\")", "response": "Add an event to the queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _extract_version(version_string, pattern):\n    if version_string:\n        match = pattern.match(version_string.strip())\n        if match:\n            return match.group(1)\n    return \"\"", "response": "Extract the version from version_string using pattern."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _configure(self):\n        configfile = expanduser(\"~/.ssh/config\")\n        if not isfile(configfile):\n            raise GerritError(\"ssh config file '%s' does not exist\" %\n                              configfile)\n\n        config = SSHConfig()\n        config.parse(open(configfile))\n        data = config.lookup(self.hostname)\n        if not data:\n            raise GerritError(\"No ssh config for host %s\" % self.hostname)\n        if 'hostname' not in data or 'port' not in data or 'user' not in data:\n            raise GerritError(\"Missing configuration data in %s\" % configfile)\n        self.hostname = data['hostname']\n        self.username = data['user']\n        if 'identityfile' in data:\n            key_filename = abspath(expanduser(data['identityfile'][0]))\n            if not isfile(key_filename):\n                raise GerritError(\"Identity file '%s' does not exist\" %\n                                  key_filename)\n            self.key_filename = key_filename\n        try:\n            self.port = int(data['port'])\n        except ValueError:\n            raise GerritError(\"Invalid port: %s\" % data['port'])\n        if 'proxycommand' in data:\n            self.proxy = ProxyCommand(data['proxycommand'])", "response": "Configure the ssh parameters from the config file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _do_connect(self):\n        self.load_system_host_keys()\n        if self.username is None or self.port is None:\n            self._configure()\n        try:\n            self.connect(hostname=self.hostname,\n                         port=self.port,\n                         username=self.username,\n                         key_filename=self.key_filename,\n                         sock=self.proxy)\n        except socket.error as e:\n            raise GerritError(\"Failed to connect to server: %s\" % e)\n\n        try:\n            version_string = self._transport.remote_version\n            pattern = re.compile(r'^.*GerritCodeReview_([a-z0-9-\\.]*) .*$')\n            self.remote_version = _extract_version(version_string, pattern)\n        except AttributeError:\n            self.remote_version = None", "response": "Connect to the remote server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _connect(self):\n        if not self.connected.is_set():\n            try:\n                self.lock.acquire()\n                # Another thread may have connected while we were\n                # waiting to acquire the lock\n                if not self.connected.is_set():\n                    self._do_connect()\n                    if self.keepalive:\n                        self._transport.set_keepalive(self.keepalive)\n                    self.connected.set()\n            except GerritError:\n                raise\n            finally:\n                self.lock.release()", "response": "Connect to the remote if not already connected."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_remote_version(self):\n        if self.remote_version is None:\n            result = self.run_gerrit_command(\"version\")\n            version_string = result.stdout.read()\n            pattern = re.compile(r'^gerrit version (.*)$')\n            self.remote_version = _extract_version(version_string, pattern)\n        return self.remote_version", "response": "Return the version of the remote Gerrit server."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_gerrit_command(self, command):\n        if not isinstance(command, basestring):\n            raise ValueError(\"command must be a string\")\n        gerrit_command = \"gerrit \" + command\n\n        # are we sending non-ascii data?\n        try:\n            gerrit_command.encode('ascii')\n        except UnicodeEncodeError:\n            gerrit_command = gerrit_command.encode('utf-8')\n\n        self._connect()\n        try:\n            stdin, stdout, stderr = self.exec_command(gerrit_command,\n                                                      bufsize=1,\n                                                      timeout=None,\n                                                      get_pty=False)\n        except SSHException as err:\n            raise GerritError(\"Command execution error: %s\" % err)\n        return GerritSSHCommandResult(command, stdin, stdout, stderr)", "response": "Run a gerrit command and return the output as a GerritSSHCommandResult."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register(cls, name):\n\n        def decorate(klazz):\n            \"\"\" Decorator. \"\"\"\n            if name in cls._events:\n                raise GerritError(\"Duplicate event: %s\" % name)\n            cls._events[name] = [klazz.__module__, klazz.__name__]\n            klazz.name = name\n            return klazz\n        return decorate", "response": "Decorator to register an event identified by name."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new event instance.", "response": "def create(cls, data):\n        \"\"\" Create a new event instance.\n\n        Return an instance of the `GerritEvent` subclass after converting\n        `data` to json.\n\n        Raise GerritError if json parsed from `data` does not contain a `type`\n        key.\n\n        \"\"\"\n        try:\n            json_data = json.loads(data)\n        except ValueError as err:\n            logging.debug(\"Failed to load json data: %s: [%s]\", str(err), data)\n            json_data = json.loads(ErrorEvent.error_json(err))\n\n        if \"type\" not in json_data:\n            raise GerritError(\"`type` not in json_data\")\n        name = json_data[\"type\"]\n        if name not in cls._events:\n            name = 'unhandled-event'\n        event = cls._events[name]\n        module_name = event[0]\n        class_name = event[1]\n        module = __import__(module_name, fromlist=[module_name])\n        klazz = getattr(module, class_name)\n        return klazz(json_data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstripping off Gerrit s magic prefix and decode a response.", "response": "def _decode_response(response):\n    \"\"\" Strip off Gerrit's magic prefix and decode a response.\n\n    :returns:\n        Decoded JSON content as a dict, or raw text if content could not be\n        decoded as JSON.\n\n    :raises:\n        requests.HTTPError if the response contains an HTTP error status code.\n\n    \"\"\"\n    content = response.content.strip()\n    logging.debug(content[:512])\n    response.raise_for_status()\n    if content.startswith(GERRIT_MAGIC_JSON_PREFIX):\n        content = content[len(GERRIT_MAGIC_JSON_PREFIX):]\n    try:\n        return json.loads(content)\n    except ValueError:\n        logging.error('Invalid json content: %s' % content)\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend HTTP PUT to the endpoint.", "response": "def put(self, endpoint, **kwargs):\n        \"\"\" Send HTTP PUT to the endpoint.\n\n        :arg str endpoint: The endpoint to send to.\n\n        :returns:\n            JSON decoded result.\n\n        :raises:\n            requests.RequestException on timeout or connection error.\n\n        \"\"\"\n        kwargs.update(self.kwargs.copy())\n        if \"data\" in kwargs:\n            kwargs[\"headers\"].update(\n                {\"Content-Type\": \"application/json;charset=UTF-8\"})\n        response = requests.put(self.make_url(endpoint), **kwargs)\n        return _decode_response(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete(self, endpoint, **kwargs):\n        kwargs.update(self.kwargs.copy())\n        response = requests.delete(self.make_url(endpoint), **kwargs)\n        return _decode_response(response)", "response": "Send HTTP DELETE to the endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef review(self, change_id, revision, review):\n\n        endpoint = \"changes/%s/revisions/%s/review\" % (change_id, revision)\n        self.post(endpoint, data=str(review))", "response": "Submit a review.\n\n        :arg str change_id: The change ID.\n        :arg str revision: The revision.\n        :arg str review: The review details as a :class:`GerritReview`.\n\n        :returns:\n            JSON decoded result.\n\n        :raises:\n            requests.RequestException on timeout or connection error."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding inline comments to the comments list.", "response": "def add_comments(self, comments):\n        \"\"\" Add inline comments.\n\n        :arg dict comments: Comments to add.\n\n        Usage::\n\n            add_comments([{'filename': 'Makefile',\n                           'line': 10,\n                           'message': 'inline message'}])\n\n            add_comments([{'filename': 'Makefile',\n                           'range': {'start_line': 0,\n                                     'start_character': 1,\n                                     'end_line': 0,\n                                     'end_character': 5},\n                           'message': 'inline message'}])\n\n        \"\"\"\n        for comment in comments:\n            if 'filename' and 'message' in comment.keys():\n                msg = {}\n                if 'range' in comment.keys():\n                    msg = {\"range\": comment['range'],\n                           \"message\": comment['message']}\n                elif 'line' in comment.keys():\n                    msg = {\"line\": comment['line'],\n                           \"message\": comment['message']}\n                else:\n                    continue\n                file_comment = {comment['filename']: [msg]}\n                if self.comments:\n                    if comment['filename'] in self.comments.keys():\n                        self.comments[comment['filename']].append(msg)\n                    else:\n                        self.comments.update(file_comment)\n                else:\n                    self.comments.update(file_comment)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef connection_made(self, transport):\n        '''\n        override asyncio.Protocol\n        '''\n\n        self._connected = True\n        self.transport = transport\n\n        self.remote_ip, self.port = transport.get_extra_info('peername')[:2]\n\n        logging.debug(\n            'Connection made (address: {} port: {})'\n            .format(self.remote_ip, self.port))\n\n        self.auth_future = self.send_package(protomap.CPROTO_REQ_AUTH,\n                                             data=(self._username,\n                                                   self._password,\n                                                   self._dbname),\n                                             timeout=10)\n\n        self._password = None\n        self.on_connection_made()", "response": "Called by asyncio when a connection is made."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connection_lost(self, exc):\n        '''\n        override asyncio.Protocol\n        '''\n        self._connected = False\n\n        logging.debug(\n            'Connection lost (address: {} port: {})'\n            .format(self.remote_ip, self.port))\n\n        for pid, (future, task) in self._requests.items():\n            task.cancel()\n            if future.cancelled():\n                continue\n            future.set_exception(ConnectionError(\n                'Connection is lost before we had an answer on package id: {}.'\n                .format(pid)))\n\n        self.on_connection_lost(exc)", "response": "Called when the connection is lost."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef data_received(self, data):\n        '''\n        override asyncio.Protocol\n        '''\n        self._buffered_data.extend(data)\n        while self._buffered_data:\n            size = len(self._buffered_data)\n            if self._data_package is None:\n                if size < DataPackage.struct_datapackage.size:\n                    return None\n                self._data_package = DataPackage(self._buffered_data)\n            if size < self._data_package.length:\n                return None\n            try:\n                self._data_package.extract_data_from(self._buffered_data)\n            except KeyError as e:\n                logging.error('Unsupported package received: {}'.format(e))\n            except Exception as e:\n                logging.exception(e)\n                # empty the byte-array to recover from this error\n                self._buffered_data.clear()\n            else:\n                self._on_package_received()\n            self._data_package = None", "response": "This method is called when data is received from the server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _register_server(self, server, timeout=30):\n        '''Register a new SiriDB Server.\n\n        This method is used by the SiriDB manage tool and should not be used\n        otherwise. Full access rights are required for this request.\n        '''\n        result = self._loop.run_until_complete(\n            self._protocol.send_package(CPROTO_REQ_REGISTER_SERVER,\n                                        data=server,\n                                        timeout=timeout))\n        return result", "response": "Register a new SiriDB Server."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrequests a SiriDB configuration file.", "response": "def _get_file(self, fn, timeout=30):\n        '''Request a SiriDB configuration file.\n\n        This method is used by the SiriDB manage tool and should not be used\n        otherwise. Full access rights are required for this request.\n        '''\n        msg = FILE_MAP.get(fn, None)\n        if msg is None:\n            raise FileNotFoundError('Cannot get file {!r}. Available file '\n                                    'requests are: {}'\n                                    .format(fn, ', '.join(FILE_MAP.keys())))\n        result = self._loop.run_until_complete(\n            self._protocol.send_package(msg, timeout=timeout))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert GeoHash bits to a float.", "response": "def _bits_to_float(bits, lower=-90.0, middle=0.0, upper=90.0):\n  \"\"\"Convert GeoHash bits to a float.\"\"\"\n  for i in bits:\n    if i:\n      lower = middle\n    else:\n      upper = middle\n    middle = (upper + lower) / 2\n  return middle"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _float_to_bits(value, lower=-90.0, middle=0.0, upper=90.0, length=15):\n  ret = []\n  for i in range(length):\n    if value >= middle:\n      lower = middle\n      ret.append(1)\n    else:\n      upper = middle\n      ret.append(0)\n    middle = (upper + lower) / 2\n  return ret", "response": "Convert a float to a list of GeoHash bits."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _geohash_to_bits(value):\n  b = map(BASE32MAP.get, value)\n  ret = []\n  for i in b:\n    out = []\n    for z in range(5):\n      out.append(i & 0b1)\n      i = i >> 1\n    ret += out[::-1]\n  return ret", "response": "Convert a GeoHash to a list of GeoHash bits."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _bits_to_geohash(value):\n  ret = []\n  # Get 5 bits at a time\n  for i in (value[i:i+5] for i in xrange(0, len(value), 5)):\n    # Convert binary to integer\n    # Note: reverse here, the slice above doesn't work quite right in reverse.\n    total = sum([(bit*2**count) for count,bit in enumerate(i[::-1])])\n    ret.append(BASE32MAPR[total])\n  # Join the string and return\n  return \"\".join(ret)", "response": "Convert a list of GeoHash bits to a GeoHash."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef decode(value):\n  assert value, \"Invalid geohash: %s\"%value\n  # Get the GeoHash bits\n  bits = _geohash_to_bits(value)\n  # Unzip the GeoHash bits.\n  lon = bits[0::2]\n  lat = bits[1::2]\n  # Convert to lat/lon\n  return (\n    _bits_to_float(lon, lower=-180.0, upper=180.0),\n    _bits_to_float(lat)\n  )", "response": "Decode a geohash. Returns a ( lon lat ) pair."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef encode(lonlat, length=12):\n  assert len(lonlat) == 2, \"Invalid lon/lat: %s\"%lonlat\n  # Half the length for each component.\n  length /= 2\n  lon = _float_to_bits(lonlat[0], lower=-180.0, upper=180.0, length=length*5)\n  lat = _float_to_bits(lonlat[1], lower=-90.0, upper=90.0, length=length*5)\n  # Zip the GeoHash bits.\n  ret = []\n  for a,b in zip(lon,lat):\n    ret.append(a)\n    ret.append(b)\n  return _bits_to_geohash(ret)", "response": "Encode a ( lon lat ) pair to a GeoHash."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef adjacent(geohash, direction):\n  # Based on an MIT licensed implementation by Chris Veness from:\n  #   http://www.movable-type.co.uk/scripts/geohash.html\n  assert direction in 'nsew', \"Invalid direction: %s\"%direction\n  assert geohash, \"Invalid geohash: %s\"%geohash\n  neighbor = {\n    'n': [ 'p0r21436x8zb9dcf5h7kjnmqesgutwvy', 'bc01fg45238967deuvhjyznpkmstqrwx' ],\n    's': [ '14365h7k9dcfesgujnmqp0r2twvyx8zb', '238967debc01fg45kmstqrwxuvhjyznp' ],\n    'e': [ 'bc01fg45238967deuvhjyznpkmstqrwx', 'p0r21436x8zb9dcf5h7kjnmqesgutwvy' ],\n    'w': [ '238967debc01fg45kmstqrwxuvhjyznp', '14365h7k9dcfesgujnmqp0r2twvyx8zb' ]\n  }\n  border = {\n    'n': [ 'prxz',     'bcfguvyz' ],\n    's': [ '028b',     '0145hjnp' ],\n    'e': [ 'bcfguvyz', 'prxz'     ],\n    'w': [ '0145hjnp', '028b'     ]\n  }\n  last = geohash[-1]\n  parent = geohash[0:-1]\n  t = len(geohash) % 2\n  # Check for edge cases\n  if (last in border[direction][t]) and (parent):\n    parent = adjacent(parent, direction)\n  return parent + BASESEQUENCE[neighbor[direction][t].index(last)]", "response": "Return the adjacent geohash for a given direction."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef neighbors(geohash):\n  return {\n    'n':  adjacent(geohash, 'n'),\n    'ne': adjacent(adjacent(geohash, 'n'), 'e'),\n    'e':  adjacent(geohash, 'e'),\n    'se': adjacent(adjacent(geohash, 's'), 'e'),\n    's':  adjacent(geohash, 's'),\n    'sw': adjacent(adjacent(geohash, 's'), 'w'),\n    'w':  adjacent(geohash, 'w'),\n    'nw': adjacent(adjacent(geohash, 'n'), 'w'),\n    'c':  geohash\n  }", "response": "Return all neighboring geohashes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef thunkify(thread_name=None, daemon=True, default_func=None):\n    '''Make a function immediately return a function of no args which, when called,\n    waits for the result, which will start being processed in another thread.\n    Taken from https://wiki.python.org/moin/PythonDecoratorLibrary.\n    '''\n    def actual_decorator(f):\n        @functools.wraps(f)\n        def thunked(*args, **kwargs):\n            result = [None]\n            exc = [False, None]  # has exception?, exception info\n#             wait_event = threading.Event()\n\n            def worker_func():\n                try:\n                    func_result = f(*args, **kwargs)\n                    result[0] = func_result\n                except Exception:\n                    exc[0] = True\n                    exc[1] = sys.exc_info()\n                    logging.error(\"%s has thrown an exception:\\n%s\", thread_name, traceback.format_exc())\n#                 finally:\n#                     wait_event.set()\n\n            worker_thread = Thread(target=worker_func, name=thread_name if thread_name else None)\n            worker_thread.daemon = daemon\n\n            def thunk(timeout=None):\n                # avoid blocking MainThread\n                start_time = time()\n                while True:\n                    worker_thread.join(timeout=0.1)\n                    if (timeout and timeout < time() - start_time) or not worker_thread.is_alive():\n                        break\n#                 worker_thread.join(timeout=timeout)\n#                 wait_event.wait()\n                if worker_thread.is_alive():\n                    if default_func is None:\n                        return\n                    else:\n                        return default_func()\n                if exc[0]:\n                    raise exc[1][0], exc[1][1], exc[1][2]\n                return result[0]\n\n            worker_thread.start()\n#             threading.Thread(target=worker_func, name=thread_name if thread_name else None).start()\n            return thunk\n        return thunked\n    return actual_decorator", "response": "A decorator which returns a function immediately return a function of no args which will be processed in another thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_event_when_keyboard_interrupt(_lambda):\n    '''Decorator function that sets Threading.Event() when keyboard interrupt (Ctrl+C) was raised\n\n    Parameters\n    ----------\n    _lambda : function\n        Lambda function that points to Threading.Event() object\n\n    Returns\n    -------\n    wrapper : function\n\n    Examples\n    --------\n    @set_event_when_keyboard_interrupt(lambda x: x.stop_thread_event)\n    def scan(self, **kwargs):\n        # some code\n\n    Note\n    ----\n    Decorated functions cannot be derived.\n    '''\n    def wrapper(f):\n        @wraps(f)\n        def wrapped_f(self, *f_args, **f_kwargs):\n            try:\n                f(self, *f_args, **f_kwargs)\n            except KeyboardInterrupt:\n                _lambda(self).set()\n#                 logging.info('Keyboard interrupt: setting %s' % _lambda(self).__name__)\n        return wrapped_f\n    return wrapper", "response": "Decorator function that sets Threading. Event when keyboard interrupt was raised."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_id(self):\n        '''Run name without whitespace\n        '''\n        s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', self.__class__.__name__)\n        return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "response": "Run name without whitespace\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef conf(self):\n        '''Configuration (namedtuple)\n        '''\n        conf = namedtuple('conf', field_names=self._conf.keys())\n        return conf(**self._conf)", "response": "Return a named tuple containing the current configuration."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun configuration of the current session", "response": "def run_conf(self):\n        '''Run configuration (namedtuple)\n        '''\n        run_conf = namedtuple('run_conf', field_names=self._run_conf.keys())\n        return run_conf(**self._run_conf)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndefault run configuration (namedtuple)", "response": "def default_run_conf(self):\n        '''Default run configuration (namedtuple)\n        '''\n        default_run_conf = namedtuple('default_run_conf', field_names=self._default_run_conf.keys())\n        return default_run_conf(**self._default_run_conf)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init(self, run_conf, run_number=None):\n        '''Initialization before a new run.\n        '''\n        self.stop_run.clear()\n        self.abort_run.clear()\n        self._run_status = run_status.running\n        self._write_run_number(run_number)\n        self._init_run_conf(run_conf)", "response": "Initialize before a new run."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect_cancel(self, functions):\n        '''Run given functions when a run is cancelled.\n        '''\n        self._cancel_functions = []\n        for func in functions:\n            if isinstance(func, basestring) and hasattr(self, func) and callable(getattr(self, func)):\n                self._cancel_functions.append(getattr(self, func))\n            elif callable(func):\n                self._cancel_functions.append(func)\n            else:\n                raise ValueError(\"Unknown function %s\" % str(func))", "response": "Connect given functions when a run is cancelled."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstop a run. Control for loops. Gentle stop and abort.", "response": "def stop(self, msg=None):\n        '''Stopping a run. Control for loops. Gentle stop/abort.\n\n        This event should provide a more gentle abort. The run should stop ASAP but the run is still considered complete.\n        '''\n        if not self.stop_run.is_set():\n            if msg:\n                logging.info('%s%s Stopping run...', msg, ('' if msg[-1] in punctuation else '.'))\n            else:\n                logging.info('Stopping run...')\n        self.stop_run.set()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\naborts a run. Control for loops. Immediate stop and abort.", "response": "def abort(self, msg=None):\n        '''Aborting a run. Control for loops. Immediate stop/abort.\n\n        The implementation should stop a run ASAP when this event is set. The run is considered incomplete.\n        '''\n        if not self.abort_run.is_set():\n            if msg:\n                logging.error('%s%s Aborting run...', msg, ('' if msg[-1] in punctuation else '.'))\n            else:\n                logging.error('Aborting run...')\n        self.abort_run.set()\n        self.stop_run.set()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning a run in another thread. Non - blocking.", "response": "def run_run(self, run, conf=None, run_conf=None, use_thread=False, catch_exception=True):\n        '''Runs a run in another thread. Non-blocking.\n\n        Parameters\n        ----------\n        run : class, object\n            Run class or object.\n        run_conf : str, dict, file\n            Specific configuration for the run.\n        use_thread : bool\n            If True, run run in thread and returns blocking function.\n\n        Returns\n        -------\n        If use_thread is True, returns function, which blocks until thread terminates, and which itself returns run status.\n        If use_thread is False, returns run status.\n        '''\n        if isinstance(conf, basestring) and os.path.isfile(conf):\n            logging.info('Updating configuration from file %s', os.path.abspath(conf))\n        elif conf is not None:\n            logging.info('Updating configuration')\n        conf = self.open_conf(conf)\n        self._conf.update(conf)\n\n        if isclass(run):\n            # instantiate the class\n            run = run(conf=self._conf)\n\n        local_run_conf = {}\n        # general parameters from conf\n        if 'run_conf' in self._conf:\n            logging.info('Updating run configuration using run_conf key from configuration')\n            local_run_conf.update(self._conf['run_conf'])\n        # check for class name, scan specific parameters from conf\n        if run.__class__.__name__ in self._conf:\n            logging.info('Updating run configuration using %s key from configuration' % (run.__class__.__name__,))\n            local_run_conf.update(self._conf[run.__class__.__name__])\n\n        if isinstance(run_conf, basestring) and os.path.isfile(run_conf):\n            logging.info('Updating run configuration from file %s', os.path.abspath(run_conf))\n        elif run_conf is not None:\n            logging.info('Updating run configuration')\n        run_conf = self.open_conf(run_conf)\n        # check for class name, scan specific parameters from conf\n        if run.__class__.__name__ in run_conf:\n            run_conf = run_conf[run.__class__.__name__]\n        # run_conf parameter has highest priority, updated last\n        local_run_conf.update(run_conf)\n\n        if use_thread:\n            self.current_run = run\n\n            @thunkify(thread_name='RunThread', daemon=True, default_func=self.current_run.get_run_status)\n            def run_run_in_thread():\n                return run.run(run_conf=local_run_conf)\n\n            signal.signal(signal.SIGINT, self._signal_handler)\n            logging.info('Press Ctrl-C to stop run')\n\n            return run_run_in_thread()\n        else:\n            self.current_run = run\n            status = run.run(run_conf=local_run_conf)\n            if not catch_exception and status != run_status.finished:\n                raise RuntimeError('Exception occurred. Please read the log.')\n            return status"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns runs from a primlist.", "response": "def run_primlist(self, primlist, skip_remaining=False):\n        '''Runs runs from a primlist.\n\n        Parameters\n        ----------\n        primlist : string\n            Filename of primlist.\n        skip_remaining : bool\n            If True, skip remaining runs, if a run does not exit with status FINISHED.\n\n        Note\n        ----\n        Primlist is a text file of the following format (comment line by adding '#'):\n        <module name (containing class) or class (in either case use dot notation)>; <scan parameter>=<value>; <another scan parameter>=<another value>\n        '''\n        runlist = self.open_primlist(primlist)\n        for index, run in enumerate(runlist):\n            logging.info('Progressing with run %i out of %i...', index + 1, len(runlist))\n            join = self.run_run(run, use_thread=True)\n            status = join()\n            if skip_remaining and not status == run_status.finished:\n                logging.error('Exited run %i with status %s: Skipping all remaining runs.', run.run_number, status)\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef analyze_beam_spot(scan_base, combine_n_readouts=1000, chunk_size=10000000, plot_occupancy_hists=False, output_pdf=None, output_file=None):\n    ''' Determines the mean x and y beam spot position as a function of time. Therefore the data of a fixed number of read outs are combined ('combine_n_readouts'). The occupancy is determined\n    for the given combined events and stored into a pdf file. At the end the beam x and y is plotted into a scatter plot with absolute positions in um.\n\n     Parameters\n    ----------\n    scan_base: list of str\n        scan base names (e.g.:  ['//data//SCC_50_fei4_self_trigger_scan_390', ]\n    combine_n_readouts: int\n        the number of read outs to combine (e.g. 1000)\n    max_chunk_size: int\n        the maximum chunk size used during read, if too big memory error occurs, if too small analysis takes longer\n    output_pdf: PdfPages\n        PdfPages file object, if none the plot is printed to screen\n    '''\n    time_stamp = []\n    x = []\n    y = []\n\n    for data_file in scan_base:\n        with tb.open_file(data_file + '_interpreted.h5', mode=\"r+\") as in_hit_file_h5:\n            # get data and data pointer\n            meta_data_array = in_hit_file_h5.root.meta_data[:]\n            hit_table = in_hit_file_h5.root.Hits\n\n            # determine the event ranges to analyze (timestamp_start, start_event_number, stop_event_number)\n            parameter_ranges = np.column_stack((analysis_utils.get_ranges_from_array(meta_data_array['timestamp_start'][::combine_n_readouts]), analysis_utils.get_ranges_from_array(meta_data_array['event_number'][::combine_n_readouts])))\n\n            # create a event_numer index (important)\n            analysis_utils.index_event_number(hit_table)\n\n            # initialize the analysis and set settings\n            analyze_data = AnalyzeRawData()\n            analyze_data.create_tot_hist = False\n            analyze_data.create_bcid_hist = False\n            analyze_data.histogram.set_no_scan_parameter()\n\n            # variables for read speed up\n            index = 0  # index where to start the read out, 0 at the beginning, increased during looping\n            best_chunk_size = chunk_size\n\n            progress_bar = progressbar.ProgressBar(widgets=['', progressbar.Percentage(), ' ', progressbar.Bar(marker='*', left='|', right='|'), ' ', progressbar.AdaptiveETA()], maxval=hit_table.shape[0], term_width=80)\n            progress_bar.start()\n\n            # loop over the selected events\n            for parameter_index, parameter_range in enumerate(parameter_ranges):\n                logging.debug('Analyze time stamp ' + str(parameter_range[0]) + ' and data from events = [' + str(parameter_range[2]) + ',' + str(parameter_range[3]) + '[ ' + str(int(float(float(parameter_index) / float(len(parameter_ranges)) * 100.0))) + '%')\n                analyze_data.reset()  # resets the data of the last analysis\n\n                # loop over the hits in the actual selected events with optimizations: determine best chunk size, start word index given\n                readout_hit_len = 0  # variable to calculate a optimal chunk size value from the number of hits for speed up\n                for hits, index in analysis_utils.data_aligned_at_events(hit_table, start_event_number=parameter_range[2], stop_event_number=parameter_range[3], start_index=index, chunk_size=best_chunk_size):\n                    analyze_data.analyze_hits(hits)  # analyze the selected hits in chunks\n                    readout_hit_len += hits.shape[0]\n                    progress_bar.update(index)\n                best_chunk_size = int(1.5 * readout_hit_len) if int(1.05 * readout_hit_len) < chunk_size else chunk_size  # to increase the readout speed, estimated the number of hits for one read instruction\n\n                # get and store results\n                occupancy_array = analyze_data.histogram.get_occupancy()\n                projection_x = np.sum(occupancy_array, axis=0).ravel()\n                projection_y = np.sum(occupancy_array, axis=1).ravel()\n                x.append(analysis_utils.get_mean_from_histogram(projection_x, bin_positions=range(0, 80)))\n                y.append(analysis_utils.get_mean_from_histogram(projection_y, bin_positions=range(0, 336)))\n                time_stamp.append(parameter_range[0])\n                if plot_occupancy_hists:\n                    plotting.plot_occupancy(occupancy_array[:, :, 0], title='Occupancy for events between ' + time.strftime('%H:%M:%S', time.localtime(parameter_range[0])) + ' and ' + time.strftime('%H:%M:%S', time.localtime(parameter_range[1])), filename=output_pdf)\n            progress_bar.finish()\n    plotting.plot_scatter([i * 250 for i in x], [i * 50 for i in y], title='Mean beam position', x_label='x [um]', y_label='y [um]', marker_style='-o', filename=output_pdf)\n    if output_file:\n        with tb.open_file(output_file, mode=\"a\") as out_file_h5:\n            rec_array = np.array(zip(time_stamp, x, y), dtype=[('time_stamp', float), ('x', float), ('y', float)])\n            try:\n                beam_spot_table = out_file_h5.create_table(out_file_h5.root, name='Beamspot', description=rec_array, title='Beam spot position', filters=tb.Filters(complib='blosc', complevel=5, fletcher32=False))\n                beam_spot_table[:] = rec_array\n            except tb.exceptions.NodeError:\n                logging.warning(output_file + ' has already a Beamspot note, do not overwrite existing.')\n    return time_stamp, x, y", "response": "Analyzes the mean x and y of a beam spot."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nanalyzing the number of events as a function of time.", "response": "def analyze_event_rate(scan_base, combine_n_readouts=1000, time_line_absolute=True, output_pdf=None, output_file=None):\n    ''' Determines the number of events as a function of time. Therefore the data of a fixed number of read outs are combined ('combine_n_readouts'). The number of events is taken from the meta data info\n    and stored into a pdf file.\n\n    Parameters\n    ----------\n    scan_base: list of str\n        scan base names (e.g.:  ['//data//SCC_50_fei4_self_trigger_scan_390', ]\n    combine_n_readouts: int\n        the number of read outs to combine (e.g. 1000)\n    time_line_absolute: bool\n        if true the analysis uses absolute time stamps\n    output_pdf: PdfPages\n        PdfPages file object, if none the plot is printed to screen\n    '''\n    time_stamp = []\n    rate = []\n\n    start_time_set = False\n\n    for data_file in scan_base:\n        with tb.open_file(data_file + '_interpreted.h5', mode=\"r\") as in_file_h5:\n            meta_data_array = in_file_h5.root.meta_data[:]\n            parameter_ranges = np.column_stack((analysis_utils.get_ranges_from_array(meta_data_array['timestamp_start'][::combine_n_readouts]), analysis_utils.get_ranges_from_array(meta_data_array['event_number'][::combine_n_readouts])))\n\n            if time_line_absolute:\n                time_stamp.extend(parameter_ranges[:-1, 0])\n            else:\n                if not start_time_set:\n                    start_time = parameter_ranges[0, 0]\n                    start_time_set = True\n                time_stamp.extend((parameter_ranges[:-1, 0] - start_time) / 60.0)\n            rate.extend((parameter_ranges[:-1, 3] - parameter_ranges[:-1, 2]) / (parameter_ranges[:-1, 1] - parameter_ranges[:-1, 0]))  # d#Events / dt\n    if time_line_absolute:\n        plotting.plot_scatter_time(time_stamp, rate, title='Event rate [Hz]', marker_style='o', filename=output_pdf)\n    else:\n        plotting.plot_scatter(time_stamp, rate, title='Events per time', x_label='Progressed time [min.]', y_label='Events rate [Hz]', marker_style='o', filename=output_pdf)\n    if output_file:\n        with tb.open_file(output_file, mode=\"a\") as out_file_h5:\n            rec_array = np.array(zip(time_stamp, rate), dtype=[('time_stamp', float), ('rate', float)]).view(np.recarray)\n            try:\n                rate_table = out_file_h5.create_table(out_file_h5.root, name='Eventrate', description=rec_array, title='Event rate', filters=tb.Filters(complib='blosc', complevel=5, fletcher32=False))\n                rate_table[:] = rec_array\n            except tb.exceptions.NodeError:\n                logging.warning(output_file + ' has already a Eventrate note, do not overwrite existing.')\n    return time_stamp, rate"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef analyse_n_cluster_per_event(scan_base, include_no_cluster=False, time_line_absolute=True, combine_n_readouts=1000, chunk_size=10000000, plot_n_cluster_hists=False, output_pdf=None, output_file=None):\n    ''' Determines the number of cluster per event as a function of time. Therefore the data of a fixed number of read outs are combined ('combine_n_readouts').\n\n    Parameters\n    ----------\n    scan_base: list of str\n        scan base names (e.g.:  ['//data//SCC_50_fei4_self_trigger_scan_390', ]\n    include_no_cluster: bool\n        Set to true to also consider all events without any hit.\n    combine_n_readouts: int\n        the number of read outs to combine (e.g. 1000)\n    max_chunk_size: int\n        the maximum chunk size used during read, if too big memory error occurs, if too small analysis takes longer\n    output_pdf: PdfPages\n        PdfPages file object, if none the plot is printed to screen\n    '''\n\n    time_stamp = []\n    n_cluster = []\n\n    start_time_set = False\n\n    for data_file in scan_base:\n        with tb.open_file(data_file + '_interpreted.h5', mode=\"r+\") as in_cluster_file_h5:\n            # get data and data pointer\n            meta_data_array = in_cluster_file_h5.root.meta_data[:]\n            cluster_table = in_cluster_file_h5.root.Cluster\n\n            # determine the event ranges to analyze (timestamp_start, start_event_number, stop_event_number)\n            parameter_ranges = np.column_stack((analysis_utils.get_ranges_from_array(meta_data_array['timestamp_start'][::combine_n_readouts]), analysis_utils.get_ranges_from_array(meta_data_array['event_number'][::combine_n_readouts])))\n\n            # create a event_numer index (important for speed)\n            analysis_utils.index_event_number(cluster_table)\n\n            # initialize the analysis and set settings\n            analyze_data = AnalyzeRawData()\n            analyze_data.create_tot_hist = False\n            analyze_data.create_bcid_hist = False\n\n            # variables for read speed up\n            index = 0  # index where to start the read out, 0 at the beginning, increased during looping\n            best_chunk_size = chunk_size\n\n            total_cluster = cluster_table.shape[0]\n\n            progress_bar = progressbar.ProgressBar(widgets=['', progressbar.Percentage(), ' ', progressbar.Bar(marker='*', left='|', right='|'), ' ', progressbar.AdaptiveETA()], maxval=total_cluster, term_width=80)\n            progress_bar.start()\n\n            # loop over the selected events\n            for parameter_index, parameter_range in enumerate(parameter_ranges):\n                logging.debug('Analyze time stamp ' + str(parameter_range[0]) + ' and data from events = [' + str(parameter_range[2]) + ',' + str(parameter_range[3]) + '[ ' + str(int(float(float(parameter_index) / float(len(parameter_ranges)) * 100.0))) + '%')\n                analyze_data.reset()  # resets the data of the last analysis\n\n                # loop over the cluster in the actual selected events with optimizations: determine best chunk size, start word index given\n                readout_cluster_len = 0  # variable to calculate a optimal chunk size value from the number of hits for speed up\n                hist = None\n                for clusters, index in analysis_utils.data_aligned_at_events(cluster_table, start_event_number=parameter_range[2], stop_event_number=parameter_range[3], start_index=index, chunk_size=best_chunk_size):\n                    n_cluster_per_event = analysis_utils.get_n_cluster_in_events(clusters['event_number'])[:, 1]  # array with the number of cluster per event, cluster per event are at least 1\n                    if hist is None:\n                        hist = np.histogram(n_cluster_per_event, bins=10, range=(0, 10))[0]\n                    else:\n                        hist = np.add(hist, np.histogram(n_cluster_per_event, bins=10, range=(0, 10))[0])\n                    if include_no_cluster and parameter_range[3] is not None:  # happend for the last readout\n                        hist[0] = (parameter_range[3] - parameter_range[2]) - len(n_cluster_per_event)  # add the events without any cluster\n                    readout_cluster_len += clusters.shape[0]\n                    total_cluster -= len(clusters)\n                    progress_bar.update(index)\n                best_chunk_size = int(1.5 * readout_cluster_len) if int(1.05 * readout_cluster_len) < chunk_size else chunk_size  # to increase the readout speed, estimated the number of hits for one read instruction\n\n                if plot_n_cluster_hists:\n                    plotting.plot_1d_hist(hist, title='Number of cluster per event at ' + str(parameter_range[0]), x_axis_title='Number of cluster', y_axis_title='#', log_y=True, filename=output_pdf)\n                hist = hist.astype('f4') / np.sum(hist)  # calculate fraction from total numbers\n\n                if time_line_absolute:\n                    time_stamp.append(parameter_range[0])\n                else:\n                    if not start_time_set:\n                        start_time = parameter_ranges[0, 0]\n                        start_time_set = True\n                    time_stamp.append((parameter_range[0] - start_time) / 60.0)\n                n_cluster.append(hist)\n            progress_bar.finish()\n            if total_cluster != 0:\n                logging.warning('Not all clusters were selected during analysis. Analysis is therefore not exact')\n\n    if time_line_absolute:\n        plotting.plot_scatter_time(time_stamp, n_cluster, title='Number of cluster per event as a function of time', marker_style='o', filename=output_pdf, legend=('0 cluster', '1 cluster', '2 cluster', '3 cluster') if include_no_cluster else ('0 cluster not plotted', '1 cluster', '2 cluster', '3 cluster'))\n    else:\n        plotting.plot_scatter(time_stamp, n_cluster, title='Number of cluster per event as a function of time', x_label='time [min.]', marker_style='o', filename=output_pdf, legend=('0 cluster', '1 cluster', '2 cluster', '3 cluster') if include_no_cluster else ('0 cluster not plotted', '1 cluster', '2 cluster', '3 cluster'))\n    if output_file:\n        with tb.open_file(output_file, mode=\"a\") as out_file_h5:\n            cluster_array = np.array(n_cluster)\n            rec_array = np.array(zip(time_stamp, cluster_array[:, 0], cluster_array[:, 1], cluster_array[:, 2], cluster_array[:, 3], cluster_array[:, 4], cluster_array[:, 5]), dtype=[('time_stamp', float), ('cluster_0', float), ('cluster_1', float), ('cluster_2', float), ('cluster_3', float), ('cluster_4', float), ('cluster_5', float)]).view(np.recarray)\n            try:\n                n_cluster_table = out_file_h5.create_table(out_file_h5.root, name='n_cluster', description=rec_array, title='Cluster per event', filters=tb.Filters(complib='blosc', complevel=5, fletcher32=False))\n                n_cluster_table[:] = rec_array\n            except tb.exceptions.NodeError:\n                logging.warning(output_file + ' has already a Beamspot note, do not overwrite existing.')\n    return time_stamp, n_cluster", "response": "Analyse the number of cluster per event."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef select_hits_from_cluster_info(input_file_hits, output_file_hits, cluster_size_condition, n_cluster_condition, chunk_size=4000000):\n    ''' Takes a hit table and stores only selected hits into a new table. The selection is done on an event base and events are selected if they have a certain number of cluster or cluster size.\n    To increase the analysis speed a event index for the input hit file is created first. Since a cluster hit table can be created to this way of hit selection is\n    not needed anymore.\n\n     Parameters\n    ----------\n    input_file_hits: str\n        the input file name with hits\n    output_file_hits: str\n        the output file name for the hits\n    cluster_size_condition: str\n        the cluster size condition to select events (e.g.: 'cluster_size_condition <= 2')\n    n_cluster_condition: str\n        the number of cluster in a event ((e.g.: 'n_cluster_condition == 1')\n    '''\n    logging.info('Write hits of events from ' + str(input_file_hits) + ' with ' + cluster_size_condition + ' and ' + n_cluster_condition + ' into ' + str(output_file_hits))\n    with tb.open_file(input_file_hits, mode=\"r+\") as in_hit_file_h5:\n        analysis_utils.index_event_number(in_hit_file_h5.root.Hits)\n        analysis_utils.index_event_number(in_hit_file_h5.root.Cluster)\n        with tb.open_file(output_file_hits, mode=\"w\") as out_hit_file_h5:\n            hit_table_out = out_hit_file_h5.create_table(out_hit_file_h5.root, name='Hits', description=data_struct.HitInfoTable, title='hit_data', filters=tb.Filters(complib='blosc', complevel=5, fletcher32=False))\n            cluster_table = in_hit_file_h5.root.Cluster\n            last_word_number = 0\n            progress_bar = progressbar.ProgressBar(widgets=['', progressbar.Percentage(), ' ', progressbar.Bar(marker='*', left='|', right='|'), ' ', progressbar.AdaptiveETA()], maxval=cluster_table.shape[0], term_width=80)\n            progress_bar.start()\n            for data, index in analysis_utils.data_aligned_at_events(cluster_table, chunk_size=chunk_size):\n                selected_events_1 = analysis_utils.get_events_with_cluster_size(event_number=data['event_number'], cluster_size=data['size'], condition=cluster_size_condition)  # select the events with clusters of a certain size\n                selected_events_2 = analysis_utils.get_events_with_n_cluster(event_number=data['event_number'], condition=n_cluster_condition)  # select the events with a certain cluster number\n                selected_events = analysis_utils.get_events_in_both_arrays(selected_events_1, selected_events_2)  # select events with both conditions above\n                logging.debug('Selected ' + str(len(selected_events)) + ' events with ' + n_cluster_condition + ' and ' + cluster_size_condition)\n                last_word_number = analysis_utils.write_hits_in_events(hit_table_in=in_hit_file_h5.root.Hits, hit_table_out=hit_table_out, events=selected_events, start_hit_word=last_word_number)  # write the hits of the selected events into a new table\n                progress_bar.update(index)\n            progress_bar.finish()\n            in_hit_file_h5.root.meta_data.copy(out_hit_file_h5.root)", "response": "Takes a hit table and stores only selected hits into a new table."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nselecting hits from the given file and stores only those that satisfy the given condition.", "response": "def select_hits(input_file_hits, output_file_hits, condition=None, cluster_size_condition=None, n_cluster_condition=None, chunk_size=5000000):\n    ''' Takes a hit table and stores only selected hits into a new table. The selection of hits is done with a numexp string. Only if\n    this expression evaluates to true the hit is taken. One can also select hits from cluster conditions. This selection is done\n    on an event basis, meaning events are selected where the cluster condition is true and then hits of these events are taken.\n\n     Parameters\n    ----------\n    input_file_hits: str\n        the input file name with hits\n    output_file_hits: str\n        the output file name for the hits\n    condition: str\n        Numexpr string to select hits (e.g.: '(relative_BCID == 6) & (column == row)')\n        All hit infos can be used (column, row, ...)\n    cluster_size_condition: int\n        Hit of events with the given cluster size are selected.\n    n_cluster_condition: int\n        Hit of events with the given cluster number are selected.\n    '''\n    logging.info('Write hits with ' + condition + ' into ' + str(output_file_hits))\n    if cluster_size_condition is None and n_cluster_condition is None:  # no cluster cuts are done\n        with tb.open_file(input_file_hits, mode=\"r+\") as in_hit_file_h5:\n            analysis_utils.index_event_number(in_hit_file_h5.root.Hits)  # create event index for faster selection\n            with tb.open_file(output_file_hits, mode=\"w\") as out_hit_file_h5:\n                hit_table_out = out_hit_file_h5.create_table(out_hit_file_h5.root, name='Hits', description=data_struct.HitInfoTable, title='hit_data', filters=tb.Filters(complib='blosc', complevel=5, fletcher32=False))\n                analysis_utils.write_hits_in_event_range(hit_table_in=in_hit_file_h5.root.Hits, hit_table_out=hit_table_out, condition=condition)  # write the hits of the selected events into a new table\n                in_hit_file_h5.root.meta_data.copy(out_hit_file_h5.root)  # copy meta_data note to new file\n    else:\n        with tb.open_file(input_file_hits, mode=\"r+\") as in_hit_file_h5:  # open file with hit/cluster data with r+ to be able to create index\n            analysis_utils.index_event_number(in_hit_file_h5.root.Hits)  # create event index for faster selection\n            analysis_utils.index_event_number(in_hit_file_h5.root.Cluster)  # create event index for faster selection\n            with tb.open_file(output_file_hits, mode=\"w\") as out_hit_file_h5:\n                hit_table_out = out_hit_file_h5.create_table(out_hit_file_h5.root, name='Hits', description=data_struct.HitInfoTable, title='hit_data', filters=tb.Filters(complib='blosc', complevel=5, fletcher32=False))\n                cluster_table = in_hit_file_h5.root.Cluster\n                last_word_number = 0\n                progress_bar = progressbar.ProgressBar(widgets=['', progressbar.Percentage(), ' ', progressbar.Bar(marker='*', left='|', right='|'), ' ', progressbar.AdaptiveETA()], maxval=cluster_table.shape[0], term_width=80)\n                progress_bar.start()\n                for data, index in analysis_utils.data_aligned_at_events(cluster_table, chunk_size=chunk_size):\n                    if cluster_size_condition is not None:\n                        selected_events = analysis_utils.get_events_with_cluster_size(event_number=data['event_number'], cluster_size=data['size'], condition='cluster_size == ' + str(cluster_size_condition))  # select the events with only 1 hit cluster\n                        if n_cluster_condition is not None:\n                            selected_events_2 = analysis_utils.get_events_with_n_cluster(event_number=data['event_number'], condition='n_cluster == ' + str(n_cluster_condition))  # select the events with only 1 cluster\n                            selected_events = selected_events[analysis_utils.in1d_events(selected_events, selected_events_2)]  # select events with the first two conditions above\n                    elif n_cluster_condition is not None:\n                        selected_events = analysis_utils.get_events_with_n_cluster(event_number=data['event_number'], condition='n_cluster == ' + str(n_cluster_condition))\n                    else:\n                        raise RuntimeError('Cannot understand cluster selection criterion')\n                    last_word_number = analysis_utils.write_hits_in_events(hit_table_in=in_hit_file_h5.root.Hits, hit_table_out=hit_table_out, events=selected_events, start_hit_word=last_word_number, condition=condition, chunk_size=chunk_size)  # write the hits of the selected events into a new table\n                    progress_bar.update(index)\n                progress_bar.finish()\n                in_hit_file_h5.root.meta_data.copy(out_hit_file_h5.root)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef histogram_cluster_table(analyzed_data_file, output_file, chunk_size=10000000):\n    '''Reads in the cluster info table in chunks and histograms the seed pixels into one occupancy array.\n    The 3rd dimension of the occupancy array is the number of different scan parameters used\n\n    Parameters\n    ----------\n    analyzed_data_file : string\n        HDF5 filename of the file containing the cluster table. If a scan parameter is given in the meta data, the occupancy histogramming is done per scan parameter step.\n\n    Returns\n    -------\n    occupancy_array: numpy.array with dimensions (col, row, #scan_parameter)\n    '''\n\n    with tb.open_file(analyzed_data_file, mode=\"r\") as in_file_h5:\n        with tb.open_file(output_file, mode=\"w\") as out_file_h5:\n            histogram = PyDataHistograming()\n            histogram.create_occupancy_hist(True)\n            scan_parameters = None\n            event_number_indices = None\n            scan_parameter_indices = None\n            try:\n                meta_data = in_file_h5.root.meta_data[:]\n                scan_parameters = analysis_utils.get_unique_scan_parameter_combinations(meta_data)\n                if scan_parameters is not None:\n                    scan_parameter_indices = np.array(range(0, len(scan_parameters)), dtype='u4')\n                    event_number_indices = np.ascontiguousarray(scan_parameters['event_number']).astype(np.uint64)\n                    histogram.add_meta_event_index(event_number_indices, array_length=len(scan_parameters['event_number']))\n                    histogram.add_scan_parameter(scan_parameter_indices)\n                    logging.info(\"Add %d different scan parameter(s) for analysis\", len(scan_parameters))\n                else:\n                    logging.info(\"No scan parameter data provided\")\n                    histogram.set_no_scan_parameter()\n            except tb.exceptions.NoSuchNodeError:\n                logging.info(\"No meta data provided, use no scan parameter\")\n                histogram.set_no_scan_parameter()\n\n            logging.info('Histogram cluster seeds...')\n            progress_bar = progressbar.ProgressBar(widgets=['', progressbar.Percentage(), ' ', progressbar.Bar(marker='*', left='|', right='|'), ' ', progressbar.AdaptiveETA()], maxval=in_file_h5.root.Cluster.shape[0], term_width=80)\n            progress_bar.start()\n            total_cluster = 0  # to check analysis\n            for cluster, index in analysis_utils.data_aligned_at_events(in_file_h5.root.Cluster, chunk_size=chunk_size):\n                total_cluster += len(cluster)\n                histogram.add_cluster_seed_hits(cluster, len(cluster))\n                progress_bar.update(index)\n            progress_bar.finish()\n\n            filter_table = tb.Filters(complib='blosc', complevel=5, fletcher32=False)  # compression of the written data\n            occupancy_array = histogram.get_occupancy().T\n            occupancy_array_table = out_file_h5.create_carray(out_file_h5.root, name='HistOcc', title='Occupancy Histogram', atom=tb.Atom.from_dtype(occupancy_array.dtype), shape=occupancy_array.shape, filters=filter_table)\n            occupancy_array_table[:] = occupancy_array\n\n            if total_cluster != np.sum(occupancy_array):\n                logging.warning('Analysis shows inconsistent number of cluster used. Check needed!')\n            in_file_h5.root.meta_data.copy(out_file_h5.root)", "response": "Reads in the cluster info table in chunks and histograms the seed pixels into one occupancy array."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef analyze_hits_per_scan_parameter(analyze_data, scan_parameters=None, chunk_size=50000):\n    '''Takes the hit table and analyzes the hits per scan parameter\n\n    Parameters\n    ----------\n    analyze_data : analysis.analyze_raw_data.AnalyzeRawData object with an opened hit file (AnalyzeRawData.out_file_h5) or a\n    file name with the hit data given (AnalyzeRawData._analyzed_data_file)\n    scan_parameters : list of strings:\n        The names of the scan parameters to use\n    chunk_size : int:\n        The chunk size of one hit table read. The bigger the faster. Too big causes memory errors.\n    Returns\n    -------\n    yields the analysis.analyze_raw_data.AnalyzeRawData for each scan parameter\n    '''\n\n    if analyze_data.out_file_h5 is None or analyze_data.out_file_h5.isopen == 0:\n        in_hit_file_h5 = tb.open_file(analyze_data._analyzed_data_file, 'r+')\n        close_file = True\n    else:\n        in_hit_file_h5 = analyze_data.out_file_h5\n        close_file = False\n\n    meta_data = in_hit_file_h5.root.meta_data[:]  # get the meta data table\n    try:\n        hit_table = in_hit_file_h5.root.Hits  # get the hit table\n    except tb.NoSuchNodeError:\n        logging.error('analyze_hits_per_scan_parameter needs a hit table, but no hit table found.')\n        return\n\n    meta_data_table_at_scan_parameter = analysis_utils.get_unique_scan_parameter_combinations(meta_data, scan_parameters=scan_parameters)\n    parameter_values = analysis_utils.get_scan_parameters_table_from_meta_data(meta_data_table_at_scan_parameter, scan_parameters)\n    event_number_ranges = analysis_utils.get_ranges_from_array(meta_data_table_at_scan_parameter['event_number'])  # get the event number ranges for the different scan parameter settings\n\n    analysis_utils.index_event_number(hit_table)  # create a event_numer index to select the hits by their event number fast, no needed but important for speed up\n\n    # variables for read speed up\n    index = 0  # index where to start the read out of the hit table, 0 at the beginning, increased during looping\n    best_chunk_size = chunk_size  # number of hits to copy to RAM during looping, the optimal chunk size is determined during looping\n\n    # loop over the selected events\n    for parameter_index, (start_event_number, stop_event_number) in enumerate(event_number_ranges):\n        logging.info('Analyze hits for ' + str(scan_parameters) + ' = ' + str(parameter_values[parameter_index]))\n        analyze_data.reset()  # resets the front end data of the last analysis step but not the options\n        readout_hit_len = 0  # variable to calculate a optimal chunk size value from the number of hits for speed up\n        # loop over the hits in the actual selected events with optimizations: determine best chunk size, start word index given\n        for hits, index in analysis_utils.data_aligned_at_events(hit_table, start_event_number=start_event_number, stop_event_number=stop_event_number, start_index=index, chunk_size=best_chunk_size):\n            analyze_data.analyze_hits(hits, scan_parameter=False)  # analyze the selected hits in chunks\n            readout_hit_len += hits.shape[0]\n        best_chunk_size = int(1.5 * readout_hit_len) if int(1.05 * readout_hit_len) < chunk_size and int(1.05 * readout_hit_len) > 1e3 else chunk_size  # to increase the readout speed, estimated the number of hits for one read instruction\n        file_name = \" \".join(re.findall(\"[a-zA-Z0-9]+\", str(scan_parameters))) + '_' + \" \".join(re.findall(\"[a-zA-Z0-9]+\", str(parameter_values[parameter_index])))\n        analyze_data._create_additional_hit_data(safe_to_file=False)\n        analyze_data._create_additional_cluster_data(safe_to_file=False)\n        yield analyze_data, file_name\n\n    if close_file:\n        in_hit_file_h5.close()", "response": "Takes the hit table and analyzes the hits per scan parameter"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef interpret_data_from_tektronix(preamble, data):\n    ''' Interprets raw data from Tektronix\n    returns: lists of x, y values in seconds/volt'''\n    # Y mode (\"WFMPRE:PT_FMT\"):\n    # Xn = XZEro + XINcr (n - PT_Off)\n    # Yn = YZEro + YMUlt (yn - YOFf)\n    voltage = np.array(data, dtype=np.float)\n    meta_data = preamble.split(',')[5].split(';')\n    time_unit = meta_data[3][1:-1]\n    XZEro = float(meta_data[5])\n    XINcr = float(meta_data[4])\n    PT_Off = float(meta_data[6])\n    voltage_unit = meta_data[7][1:-1]\n    YZEro = float(meta_data[10])\n    YMUlt = float(meta_data[8])\n    YOFf = float(meta_data[9])\n    time = XZEro + XINcr * (np.arange(0, voltage.size) - PT_Off)\n    voltage = YZEro + YMUlt * (voltage - YOFf)\n    return time, voltage, time_unit, voltage_unit", "response": "Interprets raw data from Tektronix and returns time voltage time_unit and voltage_unit"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads the Chip S and N from the specified address.", "response": "def read_chip_sn(self):\r\n    '''Reading Chip S/N\r\n\r\n    Note\r\n    ----\r\n    Bits [MSB-LSB] | [15]       | [14-6]       | [5-0]\r\n    Content        | reserved   | wafer number | chip number\r\n    '''\r\n    commands = []\r\n    commands.extend(self.register.get_commands(\"ConfMode\"))\r\n    self.register_utils.send_commands(commands)\r\n    with self.readout(fill_buffer=True, callback=None, errback=None):\r\n        if self.register.fei4b:\r\n            commands = []\r\n            self.register.set_global_register_value('Efuse_Sense', 1)\r\n            commands.extend(self.register.get_commands(\"WrRegister\", name=['Efuse_Sense']))\r\n            commands.extend(self.register.get_commands(\"GlobalPulse\", Width=0))\r\n            self.register.set_global_register_value('Efuse_Sense', 0)\r\n            commands.extend(self.register.get_commands(\"WrRegister\", name=['Efuse_Sense']))\r\n            self.register_utils.send_commands(commands)\r\n        commands = []\r\n        self.register.set_global_register_value('Conf_AddrEnable', 1)\r\n        commands.extend(self.register.get_commands(\"WrRegister\", name=['Conf_AddrEnable']))\r\n        chip_sn_address = self.register.get_global_register_attributes(\"addresses\", name=\"Chip_SN\")\r\n        commands.extend(self.register.get_commands(\"RdRegister\", addresses=chip_sn_address))\r\n        self.register_utils.send_commands(commands)\r\n    data = self.read_data()\r\n\r\n    if data.shape[0] == 0:\r\n        logging.error('Chip S/N: No data')\r\n        return\r\n    read_values = []\r\n    for index, word in enumerate(np.nditer(data)):\r\n        fei4_data_word = FEI4Record(word, self.register.chip_flavor)\r\n        if fei4_data_word == 'AR':\r\n            fei4_next_data_word = FEI4Record(data[index + 1], self.register.chip_flavor)\r\n            if fei4_next_data_word == 'VR':\r\n                read_value = fei4_next_data_word['value']\r\n                read_values.append(read_value)\r\n\r\n#     commands = []\r\n#     commands.extend(self.register.get_commands(\"RunMode\"))\r\n#     self.register_utils.send_commands(commands)\r\n\r\n    if len(read_values) == 0:\r\n        logging.error('No Chip S/N was found')\r\n    elif len(read_values) == 1:\r\n        logging.info('Chip S/N: %d', read_values[0])\r\n    else:\r\n        logging.warning('Ambiguous Chip S/N: %s', read_values)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_global_register(self, name, overwrite_config=False):\r\n    '''The function reads the global register, interprets the data and returns the register value.\r\n\r\n    Parameters\r\n    ----------\r\n    name : register name\r\n    overwrite_config : bool\r\n        The read values overwrite the config in RAM if true.\r\n\r\n    Returns\r\n    -------\r\n    register value\r\n    '''\r\n    self.register_utils.send_commands(self.register.get_commands(\"ConfMode\"))\r\n\r\n    with self.readout(fill_buffer=True, callback=None, errback=None):\r\n        commands = []\r\n        commands.extend(self.register.get_commands(\"RdRegister\", name=name))\r\n        self.register_utils.send_commands(commands)\r\n    data = self.read_data()\r\n\r\n    register_object = self.register.get_global_register_objects(name=[name])[0]\r\n    value = BitLogic(register_object['addresses'] * 16)\r\n    index = 0\r\n    vr_count = 0\r\n    for word in np.nditer(data):\r\n        fei4_data_word = FEI4Record(word, self.register.chip_flavor)\r\n        if fei4_data_word == 'AR':\r\n            address_value = fei4_data_word['address']\r\n            if address_value != register_object['address'] + index:\r\n                raise Exception('Unexpected address from Address Record: read: %d, expected: %d' % (address_value, register_object['address'] + index))\r\n        elif fei4_data_word == 'VR':\r\n            vr_count += 1\r\n            if vr_count >= 2:\r\n                raise RuntimeError(\"Read more than 2 value records\")\r\n            read_value = BitLogic.from_value(fei4_data_word['value'], size=16)\r\n            if register_object['register_littleendian']:\r\n                read_value.reverse()\r\n            value[index * 16 + 15:index * 16] = read_value\r\n            index += 1\r\n    value = value[register_object['bitlength'] + register_object['offset'] - 1:register_object['offset']]\r\n    if register_object['littleendian']:\r\n        value.reverse()\r\n    value = value.tovalue()\r\n    if overwrite_config:\r\n        self.register.set_global_register(name, value)\r\n    return value", "response": "Reads the global register and returns the register value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_pixel_register(self, pix_regs=None, dcs=range(40), overwrite_config=False):\r\n    '''The function reads the pixel register, interprets the data and returns a masked numpy arrays with the data for the chosen pixel register.\r\n    Pixels without any data are masked.\r\n\r\n    Parameters\r\n    ----------\r\n    pix_regs : iterable, string\r\n        List of pixel register to read (e.g. Enable, C_High, ...).\r\n        If None all are read: \"EnableDigInj\", \"Imon\", \"Enable\", \"C_High\", \"C_Low\", \"TDAC\", \"FDAC\"\r\n    dcs : iterable, int\r\n        List of double columns to read.\r\n    overwrite_config : bool\r\n        The read values overwrite the config in RAM if true.\r\n\r\n    Returns\r\n    -------\r\n    list of masked numpy.ndarrays\r\n    '''\r\n    if pix_regs is None:\r\n        pix_regs = [\"EnableDigInj\", \"Imon\", \"Enable\", \"C_High\", \"C_Low\", \"TDAC\", \"FDAC\"]\r\n\r\n    self.register_utils.send_commands(self.register.get_commands(\"ConfMode\"))\r\n\r\n    result = []\r\n    for pix_reg in pix_regs:\r\n        pixel_data = np.ma.masked_array(np.zeros(shape=(80, 336), dtype=np.uint32), mask=True)  # the result pixel array, only pixel with data are not masked\r\n        for dc in dcs:\r\n            with self.readout(fill_buffer=True, callback=None, errback=None):\r\n                self.register_utils.send_commands(self.register.get_commands(\"RdFrontEnd\", name=[pix_reg], dcs=[dc]))\r\n            data = self.read_data()\r\n\r\n            interpret_pixel_data(data, dc, pixel_data, invert=False if pix_reg == \"EnableDigInj\" else True)\r\n        if overwrite_config:\r\n            self.register.set_pixel_register(pix_reg, pixel_data.data)\r\n        result.append(pixel_data)\r\n    return result", "response": "Reads the specified pixel register and returns a list of masked numpy arrays with the data for the chosen pixel register."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_fe_ready(self):\r\n    '''Get FEI4 status of module.\r\n\r\n    If FEI4 is not ready, resetting service records is necessary to bring the FEI4 to a defined state.\r\n\r\n    Returns\r\n    -------\r\n    value : bool\r\n        True if FEI4 is ready, False if the FEI4 was powered up recently and is not ready.\r\n    '''\r\n    with self.readout(fill_buffer=True, callback=None, errback=None):\r\n        commands = []\r\n        commands.extend(self.register.get_commands(\"ConfMode\"))\r\n        commands.extend(self.register.get_commands(\"RdRegister\", address=[1]))\r\n#         commands.extend(self.register.get_commands(\"RunMode\"))\r\n        self.register_utils.send_commands(commands)\r\n    data = self.read_data()\r\n\r\n    if len(data) != 0:\r\n        return True if FEI4Record(data[-1], self.register.chip_flavor) == 'VR' else False\r\n    else:\r\n        return False", "response": "Get FEI4 status of module."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef invert_pixel_mask(mask):\r\n    '''Invert pixel mask (0->1, 1(and greater)->0).\r\n\r\n    Parameters\r\n    ----------\r\n    mask : array-like\r\n        Mask.\r\n\r\n    Returns\r\n    -------\r\n    inverted_mask : array-like\r\n        Inverted Mask.\r\n    '''\r\n    inverted_mask = np.ones(shape=(80, 336), dtype=np.dtype('>u1'))\r\n    inverted_mask[mask >= 1] = 0\r\n    return inverted_mask", "response": "Invert a pixel mask."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a mask array for each of the specified steps.", "response": "def make_pixel_mask(steps, shift, default=0, value=1, enable_columns=None, mask=None):\r\n    '''Generate pixel mask.\r\n\r\n    Parameters\r\n    ----------\r\n    steps : int\r\n        Number of mask steps, e.g. steps=3 (every third pixel is enabled), steps=336 (one pixel per column), steps=672 (one pixel per double column).\r\n    shift : int\r\n        Shift mask by given value to the bottom (towards higher row numbers). From 0 to (steps - 1).\r\n    default : int\r\n        Value of pixels that are not selected by the mask.\r\n    value : int\r\n        Value of pixels that are selected by the mask.\r\n    enable_columns : list\r\n        List of columns where the shift mask will be applied. List elements can range from 1 to 80.\r\n    mask : array_like\r\n        Additional mask. Must be convertible to an array of booleans with the same shape as mask array. True indicates a masked (i.e. invalid) data. Masked pixels will be set to default value.\r\n\r\n    Returns\r\n    -------\r\n    mask_array : numpy.ndarray\r\n        Mask array.\r\n\r\n    Usage\r\n    -----\r\n    shift_mask = 'enable'\r\n    steps = 3 # three step mask\r\n    for mask_step in range(steps):\r\n        commands = []\r\n        commands.extend(self.register.get_commands(\"ConfMode\"))\r\n        mask_array = make_pixel_mask(steps=steps, step=mask_step)\r\n        self.register.set_pixel_register_value(shift_mask, mask_array)\r\n        commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=True, name=shift_mask))\r\n        self.register_utils.send_commands(commands)\r\n        # do something here\r\n    '''\r\n    shape = (80, 336)\r\n    # value = np.zeros(dimension, dtype = np.uint8)\r\n    mask_array = np.full(shape, default, dtype=np.uint8)\r\n    # FE columns and rows are starting from 1\r\n    if enable_columns:\r\n        odd_columns = [odd - 1 for odd in enable_columns if odd % 2 != 0]\r\n        even_columns = [even - 1 for even in enable_columns if even % 2 == 0]\r\n    else:\r\n        odd_columns = range(0, 80, 2)\r\n        even_columns = range(1, 80, 2)\r\n    odd_rows = np.arange(shift % steps, 336, steps)\r\n    even_row_offset = ((steps // 2) + shift) % steps  # // integer devision\r\n    even_rows = np.arange(even_row_offset, 336, steps)\r\n    if odd_columns:\r\n        odd_col_rows = itertools.product(odd_columns, odd_rows)  # get any combination of column and row, no for loop needed\r\n        for odd_col_row in odd_col_rows:\r\n            mask_array[odd_col_row[0], odd_col_row[1]] = value  # advanced indexing\r\n    if even_columns:\r\n        even_col_rows = itertools.product(even_columns, even_rows)\r\n        for even_col_row in even_col_rows:\r\n            mask_array[even_col_row[0], even_col_row[1]] = value\r\n    if mask is not None:\r\n        mask_array = np.ma.array(mask_array, mask=mask, fill_value=default)\r\n        mask_array = mask_array.filled()\r\n    return mask_array"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a mask from column and row lists.", "response": "def make_pixel_mask_from_col_row(column, row, default=0, value=1):\r\n    '''Generate mask from column and row lists\r\n\r\n    Parameters\r\n    ----------\r\n    column : iterable, int\r\n        List of colums values.\r\n    row : iterable, int\r\n        List of row values.\r\n    default : int\r\n        Value of pixels that are not selected by the mask.\r\n    value : int\r\n        Value of pixels that are selected by the mask.\r\n\r\n    Returns\r\n    -------\r\n    mask : numpy.ndarray\r\n    '''\r\n    # FE columns and rows start from 1\r\n    col_array = np.array(column) - 1\r\n    row_array = np.array(row) - 1\r\n    if np.any(col_array >= 80) or np.any(col_array < 0) or np.any(row_array >= 336) or np.any(row_array < 0):\r\n        raise ValueError('Column and/or row out of range')\r\n    shape = (80, 336)\r\n    mask = np.full(shape, default, dtype=np.uint8)\r\n    mask[col_array, row_array] = value  # advanced indexing\r\n    return mask"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a box shaped mask from column and row lists. Takes the minimum and maximum value from each list.", "response": "def make_box_pixel_mask_from_col_row(column, row, default=0, value=1):\r\n    '''Generate box shaped mask from column and row lists. Takes the minimum and maximum value from each list.\r\n\r\n    Parameters\r\n    ----------\r\n    column : iterable, int\r\n        List of colums values.\r\n    row : iterable, int\r\n        List of row values.\r\n    default : int\r\n        Value of pixels that are not selected by the mask.\r\n    value : int\r\n        Value of pixels that are selected by the mask.\r\n\r\n    Returns\r\n    -------\r\n    numpy.ndarray\r\n    '''\r\n    # FE columns and rows start from 1\r\n    col_array = np.array(column) - 1\r\n    row_array = np.array(row) - 1\r\n    if np.any(col_array >= 80) or np.any(col_array < 0) or np.any(row_array >= 336) or np.any(row_array < 0):\r\n        raise ValueError('Column and/or row out of range')\r\n    shape = (80, 336)\r\n    mask = np.full(shape, default, dtype=np.uint8)\r\n    if column and row:\r\n        mask[col_array.min():col_array.max() + 1, row_array.min():row_array.max() + 1] = value  # advanced indexing\r\n    return mask"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_xtalk_mask(mask):\r\n    col, row = mask.nonzero()\r\n    row_plus_one = row + 1\r\n    del_index = np.where(row_plus_one > 335)\r\n    row_plus_one = np.delete(row_plus_one, del_index)\r\n    col_plus_one = np.delete(col.copy(), del_index)\r\n    row_minus_one = row - 1\r\n    del_index = np.where(row_minus_one > 335)\r\n    row_minus_one = np.delete(row_minus_one, del_index)\r\n    col_minus_one = np.delete(col.copy(), del_index)\r\n    col = np.concatenate((col_plus_one, col_minus_one))\r\n    row = np.concatenate((row_plus_one, row_minus_one))\r\n    return make_pixel_mask_from_col_row(col + 1, row + 1)", "response": "Generate an extended mask that is the same size as the pixel mask."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a Chessboard mask for a given column and row.", "response": "def make_checkerboard_mask(column_distance, row_distance, column_offset=0, row_offset=0, default=0, value=1):\r\n    \"\"\"\r\n    Generate chessboard/checkerboard mask.\r\n\r\n    Parameters\r\n    ----------\r\n    column_distance : int\r\n        Column distance of the enabled pixels.\r\n    row_distance : int\r\n        Row distance of the enabled pixels.\r\n    column_offset : int\r\n        Additional column offset which shifts the columns by the given amount.\r\n    column_offset : int\r\n        Additional row offset which shifts the rows by the given amount.\r\n\r\n    Returns\r\n    -------\r\n    ndarray\r\n        Chessboard mask.\r\n\r\n    Example\r\n    -------\r\n    Input:\r\n    column_distance : 6\r\n    row_distance : 2\r\n\r\n    Output:\r\n    [[1 0 0 0 0 0 1 0 0 0 ... 0 0 0 0 1 0 0 0 0 0]\r\n     [0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0]\r\n     [0 0 0 1 0 0 0 0 0 1 ... 0 1 0 0 0 0 0 1 0 0]\r\n     ...\r\n     [0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0]\r\n     [0 0 0 1 0 0 0 0 0 1 ... 0 1 0 0 0 0 0 1 0 0]\r\n     [0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0]]\r\n    \"\"\"\r\n    col_shape = (336,)\r\n    col = np.full(col_shape, fill_value=default, dtype=np.uint8)\r\n    col[::row_distance] = value\r\n    shape = (80, 336)\r\n    chessboard_mask = np.full(shape, fill_value=default, dtype=np.uint8)\r\n    chessboard_mask[column_offset::column_distance * 2] = np.roll(col, row_offset)\r\n    chessboard_mask[column_distance + column_offset::column_distance * 2] = np.roll(col, row_distance / 2 + row_offset)\r\n    return chessboard_mask"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef scan_loop(self, command, repeat_command=100, use_delay=True, additional_delay=0, mask_steps=3, enable_mask_steps=None, enable_double_columns=None, same_mask_for_all_dc=False, fast_dc_loop=True, bol_function=None, eol_function=None, digital_injection=False, enable_shift_masks=None, disable_shift_masks=None, restore_shift_masks=True, mask=None, double_column_correction=False):\r\n    '''Implementation of the scan loops (mask shifting, loop over double columns, repeatedly sending any arbitrary command).\r\n\r\n    Parameters\r\n    ----------\r\n    command : BitVector\r\n        (FEI4) command that will be sent out serially.\r\n    repeat_command : int\r\n        The number of repetitions command will be sent out each mask step.\r\n    use_delay : bool\r\n        Add additional delay to the command (append zeros). This helps to avoid FE data errors because of sending to many commands to the FE chip.\r\n    additional_delay: int\r\n        Additional delay to increase the command-to-command delay (in number of clock cycles / 25ns).\r\n    mask_steps : int\r\n        Number of mask steps (from 1 to 672).\r\n    enable_mask_steps : list, tuple\r\n        List of mask steps which will be applied. Default is all mask steps. From 0 to (mask-1). A value equal None or empty list will select all mask steps.\r\n    enable_double_columns : list, tuple\r\n        List of double columns which will be enabled during scan. Default is all double columns. From 0 to 39 (double columns counted from zero). A value equal None or empty list will select all double columns.\r\n    same_mask_for_all_dc : bool\r\n        Use same mask for all double columns. This will only affect all shift masks (see enable_shift_masks). Enabling this is in general a good idea since all double columns will have the same configuration and the scan speed can increased by an order of magnitude.\r\n    fast_dc_loop : bool\r\n        If True, optimize double column (DC) loop to save time. Note that bol_function and eol_function cannot do register operations, if True.\r\n    bol_function : function\r\n        Begin of loop function that will be called each time before sending command. Argument is a function pointer (without braces) or functor.\r\n    eol_function : function\r\n        End of loop function that will be called each time after sending command. Argument is a function pointer (without braces) or functor.\r\n    digital_injection : bool\r\n        Enables digital injection. C_High and C_Low will be disabled.\r\n    enable_shift_masks : list, tuple\r\n        List of enable pixel masks which will be shifted during scan. Mask set to 1 for selected pixels else 0. None will select \"Enable\", \"C_High\", \"C_Low\".\r\n    disable_shift_masks : list, tuple\r\n        List of disable pixel masks which will be shifted during scan. Mask set to 0 for selected pixels else 1. None will disable no mask.\r\n    restore_shift_masks : bool\r\n        Writing the initial (restored) FE pixel configuration into FE after finishing the scan loop.\r\n    mask : array-like\r\n        Additional mask. Must be convertible to an array of booleans with the same shape as mask array. True indicates a masked pixel. Masked pixels will be disabled during shifting of the enable shift masks, and enabled during shifting disable shift mask.\r\n    double_column_correction : str, bool, list, tuple\r\n        Enables double column PlsrDAC correction. If value is a filename (string) or list/tuple, the default PlsrDAC correction will be overwritten. First line of the file must be a Python list ([0, 0, ...])\r\n    '''\r\n    if not isinstance(command, bitarray):\r\n        raise TypeError\r\n\r\n    if enable_shift_masks is None:\r\n        enable_shift_masks = [\"Enable\", \"C_High\", \"C_Low\"]\r\n\r\n    if disable_shift_masks is None:\r\n        disable_shift_masks = []\r\n\r\n    # get PlsrDAC correction\r\n    if isinstance(double_column_correction, basestring):  # from file\r\n        with open(double_column_correction) as fp:\r\n            plsr_dac_correction = list(literal_eval(fp.readline().strip()))\r\n    elif isinstance(double_column_correction, (list, tuple)):  # from list/tuple\r\n        plsr_dac_correction = list(double_column_correction)\r\n    else:  # default\r\n        if \"C_High\".lower() in map(lambda x: x.lower(), enable_shift_masks) and \"C_Low\".lower() in map(lambda x: x.lower(), enable_shift_masks):\r\n            plsr_dac_correction = self.register.calibration_parameters['Pulser_Corr_C_Inj_High']\r\n        elif \"C_High\".lower() in map(lambda x: x.lower(), enable_shift_masks):\r\n            plsr_dac_correction = self.register.calibration_parameters['Pulser_Corr_C_Inj_Med']\r\n        elif \"C_Low\".lower() in map(lambda x: x.lower(), enable_shift_masks):\r\n            plsr_dac_correction = self.register.calibration_parameters['Pulser_Corr_C_Inj_Low']\r\n    # initial PlsrDAC value for PlsrDAC correction\r\n    initial_plsr_dac = self.register.get_global_register_value(\"PlsrDAC\")\r\n    # create restore point\r\n    restore_point_name = str(self.run_number) + '_' + self.run_id + '_scan_loop'\r\n    with self.register.restored(name=restore_point_name):\r\n        # pre-calculate often used commands\r\n        conf_mode_command = self.register.get_commands(\"ConfMode\")[0]\r\n        run_mode_command = self.register.get_commands(\"RunMode\")[0]\r\n        if use_delay:\r\n            delay = self.register.get_commands(\"zeros\", length=additional_delay + calculate_wait_cycles(mask_steps))[0]\r\n            scan_loop_command = command + delay\r\n        else:\r\n            scan_loop_command = command\r\n\r\n        def enable_columns(dc):\r\n            if digital_injection:\r\n                return [dc * 2 + 1, dc * 2 + 2]\r\n            else:  # analog injection\r\n                if dc == 0:\r\n                    return [1]\r\n                elif dc == 39:\r\n                    return [78, 79, 80]\r\n                else:\r\n                    return [dc * 2, dc * 2 + 1]\r\n\r\n        def write_double_columns(dc):\r\n            if digital_injection:\r\n                return [dc]\r\n            else:  # analog injection\r\n                if dc == 0:\r\n                    return [0]\r\n                elif dc == 39:\r\n                    return [38, 39]\r\n                else:\r\n                    return [dc - 1, dc]\r\n\r\n        def get_dc_address_command(dc):\r\n            commands = []\r\n            commands.append(conf_mode_command)\r\n            self.register.set_global_register_value(\"Colpr_Addr\", dc)\r\n            commands.append(self.register.get_commands(\"WrRegister\", name=[\"Colpr_Addr\"])[0])\r\n            if double_column_correction:\r\n                self.register.set_global_register_value(\"PlsrDAC\", initial_plsr_dac + int(round(plsr_dac_correction[dc])))\r\n                commands.append(self.register.get_commands(\"WrRegister\", name=[\"PlsrDAC\"])[0])\r\n            commands.append(run_mode_command)\r\n            return self.register_utils.concatenate_commands(commands, byte_padding=True)\r\n\r\n        if not enable_mask_steps:\r\n            enable_mask_steps = range(mask_steps)\r\n\r\n        if not enable_double_columns:\r\n            enable_double_columns = range(40)\r\n\r\n        # preparing for scan\r\n        commands = []\r\n        commands.append(conf_mode_command)\r\n        if digital_injection is True:\r\n            # check if C_High and/or C_Low is in enable_shift_mask and/or disable_shift_mask\r\n            if \"C_High\".lower() in map(lambda x: x.lower(), enable_shift_masks) or \"C_High\".lower() in map(lambda x: x.lower(), disable_shift_masks):\r\n                raise ValueError('C_High must not be shift mask when using digital injection')\r\n            if \"C_Low\".lower() in map(lambda x: x.lower(), enable_shift_masks) or \"C_Low\".lower() in map(lambda x: x.lower(), disable_shift_masks):\r\n                raise ValueError('C_Low must not be shift mask when using digital injection')\r\n            # turn off all injection capacitors by default\r\n            self.register.set_pixel_register_value(\"C_High\", 0)\r\n            self.register.set_pixel_register_value(\"C_Low\", 0)\r\n            commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=True, name=[\"C_Low\", \"C_High\"], joint_write=True))\r\n            self.register.set_global_register_value(\"DIGHITIN_SEL\", 1)\r\n    # self.register.set_global_register_value(\"CalEn\", 1)  # for GlobalPulse instead Cal-Command\r\n        else:\r\n            self.register.set_global_register_value(\"DIGHITIN_SEL\", 0)\r\n            # setting EnableDigInj to 0 not necessary since DIGHITIN_SEL is turned off\r\n    #             self.register.set_pixel_register_value(\"EnableDigInj\", 0)\r\n\r\n    # plotting registers\r\n    #     plt.clf()\r\n    #     plt.imshow(curr_en_mask.T, interpolation='nearest', aspect=\"auto\")\r\n    #     plt.pcolor(curr_en_mask.T)\r\n    #     plt.colorbar()\r\n    #     plt.savefig('mask_step' + str(mask_step) + '.pdf')\r\n\r\n        commands.extend(self.register.get_commands(\"WrRegister\", name=[\"DIGHITIN_SEL\"]))\r\n        self.register_utils.send_commands(commands)\r\n\r\n        for mask_step in enable_mask_steps:\r\n            if self.abort_run.is_set():\r\n                break\r\n            commands = []\r\n            commands.append(conf_mode_command)\r\n            if same_mask_for_all_dc:  # generate and write first mask step\r\n                if disable_shift_masks:\r\n                    curr_dis_mask = make_pixel_mask(steps=mask_steps, shift=mask_step, default=1, value=0, mask=mask)\r\n                    map(lambda mask_name: self.register.set_pixel_register_value(mask_name, curr_dis_mask), disable_shift_masks)\r\n                    commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=False if mask is not None else True, name=disable_shift_masks, joint_write=True))\r\n                if enable_shift_masks:\r\n                    curr_en_mask = make_pixel_mask(steps=mask_steps, shift=mask_step, mask=mask)\r\n                    map(lambda mask_name: self.register.set_pixel_register_value(mask_name, curr_en_mask), enable_shift_masks)\r\n                    commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=False if mask is not None else True, name=enable_shift_masks, joint_write=True))\r\n                if digital_injection is True:  # write EnableDigInj last\r\n                    # write DIGHITIN_SEL since after mask writing it is disabled\r\n                    self.register.set_global_register_value(\"DIGHITIN_SEL\", 1)\r\n                    commands.extend(self.register.get_commands(\"WrRegister\", name=[\"DIGHITIN_SEL\"]))\r\n            else:  # set masks to default values\r\n                if disable_shift_masks:\r\n                    map(lambda mask_name: self.register.set_pixel_register_value(mask_name, 1), disable_shift_masks)\r\n                    commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=True, name=disable_shift_masks, joint_write=True))\r\n                if enable_shift_masks:\r\n                    map(lambda mask_name: self.register.set_pixel_register_value(mask_name, 0), enable_shift_masks)\r\n                    commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=True, name=enable_shift_masks, joint_write=True))\r\n                if digital_injection is True:  # write EnableDigInj last\r\n                    # write DIGHITIN_SEL since after mask writing it is disabled\r\n                    self.register.set_global_register_value(\"DIGHITIN_SEL\", 1)\r\n                    commands.extend(self.register.get_commands(\"WrRegister\", name=[\"DIGHITIN_SEL\"]))\r\n            self.register_utils.send_commands(commands)\r\n            logging.info('%d injection(s): mask step %d %s', repeat_command, mask_step, ('[%d - %d]' % (enable_mask_steps[0], enable_mask_steps[-1])) if len(enable_mask_steps) > 1 else ('[%d]' % enable_mask_steps[0]))\r\n\r\n            if same_mask_for_all_dc:\r\n                if fast_dc_loop:  # fast DC loop with optimized pixel register writing\r\n                    # set repeat, should be 1 by default when arriving here\r\n                    self.dut['TX']['CMD_REPEAT'] = repeat_command\r\n\r\n                    # get DC command for the first DC in the list, DC command is byte padded\r\n                    # fill CMD memory with DC command and scan loop command, inside the loop only overwrite DC command\r\n                    dc_address_command = get_dc_address_command(enable_double_columns[0])\r\n                    self.dut['TX']['START_SEQUENCE_LENGTH'] = len(dc_address_command)\r\n                    self.register_utils.set_command(command=self.register_utils.concatenate_commands((dc_address_command, scan_loop_command), byte_padding=False))\r\n\r\n                    for index, dc in enumerate(enable_double_columns):\r\n                        if self.abort_run.is_set():\r\n                            break\r\n                        if index != 0:  # full command is already set before loop\r\n                            # get DC command before wait to save some time\r\n                            dc_address_command = get_dc_address_command(dc)\r\n                            self.register_utils.wait_for_command()\r\n                            if eol_function:\r\n                                eol_function()  # do this after command has finished\r\n                            # only set command after FPGA is ready\r\n                            # overwrite only the DC command in CMD memory\r\n                            self.register_utils.set_command(dc_address_command, set_length=False)  # do not set length here, because it was already set up before the loop\r\n\r\n                        if bol_function:\r\n                            bol_function()\r\n\r\n                        self.dut['TX']['START']\r\n\r\n                    # wait here before we go on because we just jumped out of the loop\r\n                    self.register_utils.wait_for_command()\r\n                    if eol_function:\r\n                        eol_function()\r\n                    self.dut['TX']['START_SEQUENCE_LENGTH'] = 0\r\n\r\n                else:  # the slow DC loop allows writing commands inside bol and eol functions\r\n                    for index, dc in enumerate(enable_double_columns):\r\n                        if self.abort_run.is_set():\r\n                            break\r\n                        dc_address_command = get_dc_address_command(dc)\r\n                        self.register_utils.send_command(dc_address_command)\r\n\r\n                        if bol_function:\r\n                            bol_function()\r\n\r\n                        self.register_utils.send_command(scan_loop_command, repeat=repeat_command)\r\n\r\n                        if eol_function:\r\n                            eol_function()\r\n\r\n            else:\r\n                if fast_dc_loop:  # fast DC loop with optimized pixel register writing\r\n                    dc = enable_double_columns[0]\r\n                    ec = enable_columns(dc)\r\n                    dcs = write_double_columns(dc)\r\n                    commands = []\r\n                    commands.append(conf_mode_command)\r\n                    if disable_shift_masks:\r\n                        curr_dis_mask = make_pixel_mask(steps=mask_steps, shift=mask_step, default=1, value=0, enable_columns=ec, mask=mask)\r\n                        map(lambda mask_name: self.register.set_pixel_register_value(mask_name, curr_dis_mask), disable_shift_masks)\r\n                        commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=False, dcs=dcs, name=disable_shift_masks, joint_write=True))\r\n                    if enable_shift_masks:\r\n                        curr_en_mask = make_pixel_mask(steps=mask_steps, shift=mask_step, enable_columns=ec, mask=mask)\r\n                        map(lambda mask_name: self.register.set_pixel_register_value(mask_name, curr_en_mask), enable_shift_masks)\r\n                        commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=False, dcs=dcs, name=enable_shift_masks, joint_write=True))\r\n                    if digital_injection is True:\r\n                        self.register.set_global_register_value(\"DIGHITIN_SEL\", 1)\r\n                        commands.extend(self.register.get_commands(\"WrRegister\", name=[\"DIGHITIN_SEL\"]))\r\n                    self.register_utils.send_commands(commands)\r\n\r\n                    dc_address_command = get_dc_address_command(dc)\r\n                    self.dut['TX']['START_SEQUENCE_LENGTH'] = len(dc_address_command)\r\n                    self.dut['TX']['CMD_REPEAT'] = repeat_command\r\n                    self.register_utils.set_command(command=self.register_utils.concatenate_commands((dc_address_command, scan_loop_command), byte_padding=False))\r\n\r\n                    for index, dc in enumerate(enable_double_columns):\r\n                        if self.abort_run.is_set():\r\n                            break\r\n                        if index != 0:  # full command is already set before loop\r\n                            ec = enable_columns(dc)\r\n                            dcs = write_double_columns(dc)\r\n                            dcs.extend(write_double_columns(enable_double_columns[index - 1]))\r\n                            commands = []\r\n                            commands.append(conf_mode_command)\r\n                            if disable_shift_masks:\r\n                                curr_dis_mask = make_pixel_mask(steps=mask_steps, shift=mask_step, default=1, value=0, enable_columns=ec, mask=mask)\r\n                                map(lambda mask_name: self.register.set_pixel_register_value(mask_name, curr_dis_mask), disable_shift_masks)\r\n                                commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=False, dcs=dcs, name=disable_shift_masks, joint_write=True))\r\n                            if enable_shift_masks:\r\n                                curr_en_mask = make_pixel_mask(steps=mask_steps, shift=mask_step, enable_columns=ec, mask=mask)\r\n                                map(lambda mask_name: self.register.set_pixel_register_value(mask_name, curr_en_mask), enable_shift_masks)\r\n                                commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=False, dcs=dcs, name=enable_shift_masks, joint_write=True))\r\n                            if digital_injection is True:\r\n                                self.register.set_global_register_value(\"DIGHITIN_SEL\", 1)\r\n                                commands.extend(self.register.get_commands(\"WrRegister\", name=[\"DIGHITIN_SEL\"]))\r\n                            dc_address_command = get_dc_address_command(dc)\r\n\r\n                            self.register_utils.wait_for_command()\r\n                            if eol_function:\r\n                                eol_function()  # do this after command has finished\r\n                            self.register_utils.send_commands(commands)\r\n\r\n                            self.dut['TX']['START_SEQUENCE_LENGTH'] = len(dc_address_command)\r\n                            self.dut['TX']['CMD_REPEAT'] = repeat_command\r\n                            self.register_utils.set_command(command=self.register_utils.concatenate_commands((dc_address_command, scan_loop_command), byte_padding=False))\r\n\r\n                        if bol_function:\r\n                            bol_function()\r\n\r\n                        self.dut['TX']['START']\r\n\r\n                    self.register_utils.wait_for_command()\r\n                    if eol_function:\r\n                        eol_function()\r\n                    self.dut['TX']['START_SEQUENCE_LENGTH'] = 0\r\n\r\n                else:\r\n                    for index, dc in enumerate(enable_double_columns):\r\n                        if self.abort_run.is_set():\r\n                            break\r\n                        ec = enable_columns(dc)\r\n                        dcs = write_double_columns(dc)\r\n                        if index != 0:\r\n                            dcs.extend(write_double_columns(enable_double_columns[index - 1]))\r\n                        commands = []\r\n                        commands.append(conf_mode_command)\r\n                        if disable_shift_masks:\r\n                            curr_dis_mask = make_pixel_mask(steps=mask_steps, shift=mask_step, default=1, value=0, enable_columns=ec, mask=mask)\r\n                            map(lambda mask_name: self.register.set_pixel_register_value(mask_name, curr_dis_mask), disable_shift_masks)\r\n                            commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=False, dcs=dcs, name=disable_shift_masks, joint_write=True))\r\n                        if enable_shift_masks:\r\n                            curr_en_mask = make_pixel_mask(steps=mask_steps, shift=mask_step, enable_columns=ec, mask=mask)\r\n                            map(lambda mask_name: self.register.set_pixel_register_value(mask_name, curr_en_mask), enable_shift_masks)\r\n                            commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=False, dcs=dcs, name=enable_shift_masks, joint_write=True))\r\n                        if digital_injection is True:\r\n                            self.register.set_global_register_value(\"DIGHITIN_SEL\", 1)\r\n                            commands.extend(self.register.get_commands(\"WrRegister\", name=[\"DIGHITIN_SEL\"]))\r\n                        self.register_utils.send_commands(commands)\r\n\r\n                        dc_address_command = get_dc_address_command(dc)\r\n                        self.register_utils.send_command(dc_address_command)\r\n\r\n                        if bol_function:\r\n                            bol_function()\r\n\r\n                        self.register_utils.send_command(scan_loop_command, repeat=repeat_command)\r\n\r\n                        if eol_function:\r\n                            eol_function()\r\n\r\n    commands = []\r\n    commands.extend(self.register.get_commands(\"ConfMode\"))\r\n    # write registers that were changed in scan_loop()\r\n    commands.extend(self.register.get_commands(\"WrRegister\", name=[\"DIGHITIN_SEL\", \"Colpr_Addr\", \"PlsrDAC\"]))\r\n    if restore_shift_masks:\r\n        commands = []\r\n        commands.extend(self.register.get_commands(\"ConfMode\"))\r\n        commands.extend(self.register.get_commands(\"WrRegister\", name=[\"DIGHITIN_SEL\", \"Colpr_Addr\", \"PlsrDAC\"]))\r\n        commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=False, name=disable_shift_masks))\r\n        commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=False, name=enable_shift_masks))\r\n        commands.extend(self.register.get_commands(\"WrFrontEnd\", same_mask_for_all_dc=False, name=\"EnableDigInj\"))\r\n#     commands.extend(self.register.get_commands(\"RunMode\"))\r\n    self.register_utils.send_commands(commands)", "response": "Implementation of the mask shifting loop over double columns."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reset_service_records(self):\r\n        '''Resetting Service Records\r\n\r\n        This will reset Service Record counters. This will also bring back alive some FE where the output FIFO is stuck (no data is coming out in run mode).\r\n        This should be only issued after power up and in the case of a stuck FIFO, otherwise the BCID counter starts jumping.\r\n        '''\r\n        logging.info('Resetting Service Records')\r\n        commands = []\r\n        commands.extend(self.register.get_commands(\"ConfMode\"))\r\n        self.register.set_global_register_value('ReadErrorReq', 1)\r\n        commands.extend(self.register.get_commands(\"WrRegister\", name=['ReadErrorReq']))\r\n        commands.extend(self.register.get_commands(\"GlobalPulse\", Width=0))\r\n        self.register.set_global_register_value('ReadErrorReq', 0)\r\n        commands.extend(self.register.get_commands(\"WrRegister\", name=['ReadErrorReq']))\r\n        commands.extend(self.register.get_commands(\"RunMode\"))\r\n        commands.extend(self.register.get_commands(\"ConfMode\"))\r\n        self.send_commands(commands)", "response": "Reset all the Service Records in the current thread."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reset_bunch_counter(self):\r\n        '''Resetting Bunch Counter\r\n        '''\r\n        logging.info('Resetting Bunch Counter')\r\n        commands = []\r\n        commands.extend(self.register.get_commands(\"RunMode\"))\r\n        commands.extend(self.register.get_commands(\"BCR\"))\r\n        self.send_commands(commands)\r\n        time.sleep(0.1)\r\n        commands = []\r\n        commands.extend(self.register.get_commands(\"ConfMode\"))\r\n        self.send_commands(commands)", "response": "Reset the Bunch Counter"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_threshold_mask(hist):\n    '''Masking array elements when equal 0.0 or greater than 10 times the median\n\n    Parameters\n    ----------\n    hist : array_like\n        Input data.\n\n    Returns\n    -------\n    masked array\n        Returns copy of the array with masked elements.\n    '''\n    masked_array = np.ma.masked_values(hist, 0)\n    masked_array = np.ma.masked_greater(masked_array, 10 * np.ma.median(hist))\n    logging.info('Masking %d pixel(s)', np.ma.count_masked(masked_array))\n    return np.ma.getmaskarray(masked_array)", "response": "Mask array elements when equal 0. 0 or greater than 10 times the median\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unique_row(array, use_columns=None, selected_columns_only=False):\n    '''Takes a numpy array and returns the array reduced to unique rows. If columns are defined only these columns are taken to define a unique row.\n    The returned array can have all columns of the original array or only the columns defined in use_columns.\n    Parameters\n    ----------\n    array : numpy.ndarray\n    use_columns : list\n        Index of columns to be used to define a unique row\n    selected_columns_only : bool\n        If true only the columns defined in use_columns are returned\n\n    Returns\n    -------\n    numpy.ndarray\n    '''\n    if array.dtype.names is None:  # normal array has no named dtype\n        if use_columns is not None:\n            a_cut = array[:, use_columns]\n        else:\n            a_cut = array\n        if len(use_columns) > 1:\n            b = np.ascontiguousarray(a_cut).view(np.dtype((np.void, a_cut.dtype.itemsize * a_cut.shape[1])))\n        else:\n            b = np.ascontiguousarray(a_cut)\n        _, index = np.unique(b, return_index=True)\n        if not selected_columns_only:\n            return array[np.sort(index)]  # sort to preserve order\n        else:\n            return a_cut[np.sort(index)]  # sort to preserve order\n    else:  # names for dtype founnd --> array is recarray\n        names = list(array.dtype.names)\n        if use_columns is not None:\n            new_names = [names[i] for i in use_columns]\n        else:\n            new_names = names\n        a_cut, index = np.unique(array[new_names], return_index=True)\n        if not selected_columns_only:\n            return array[np.sort(index)]  # sort to preserve order\n        else:\n            return array[np.sort(index)][new_names]", "response": "Takes a numpy array and returns the array reduced to unique rows."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_ranges_from_array(arr, append_last=True):\n    '''Takes an array and calculates ranges [start, stop[. The last range end is none to keep the same length.\n\n    Parameters\n    ----------\n    arr : array like\n    append_last: bool\n        If True, append item with a pair of last array item and None.\n\n    Returns\n    -------\n    numpy.array\n        The array formed by pairs of values by the given array.\n\n    Example\n    -------\n    >>> a = np.array((1,2,3,4))\n    >>> get_ranges_from_array(a, append_last=True)\n    array([[1, 2],\n           [2, 3],\n           [3, 4],\n           [4, None]])\n    >>> get_ranges_from_array(a, append_last=False)\n    array([[1, 2],\n           [2, 3],\n           [3, 4]])\n    '''\n    right = arr[1:]\n    if append_last:\n        left = arr[:]\n        right = np.append(right, None)\n    else:\n        left = arr[:-1]\n    return np.column_stack((left, right))", "response": "Takes an array and calculates ranges [ start stop ]."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn true if ar1 and ar2 are in 1 - dimensional order.", "response": "def in1d_sorted(ar1, ar2):\n    \"\"\"\n    Does the same than np.in1d but uses the fact that ar1 and ar2 are sorted. Is therefore much faster.\n\n    \"\"\"\n    if ar1.shape[0] == 0 or ar2.shape[0] == 0:  # check for empty arrays to avoid crash\n        return []\n    inds = ar2.searchsorted(ar1)\n    inds[inds == len(ar2)] = 0\n    return ar2[inds] == ar1"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef central_difference(x, y):\n    '''Returns the dy/dx(x) via central difference method\n\n    Parameters\n    ----------\n    x : array like\n    y : array like\n\n    Returns\n    -------\n    dy/dx : array like\n    '''\n    if (len(x) != len(y)):\n        raise ValueError(\"x, y must have the same length\")\n    z1 = np.hstack((y[0], y[:-1]))\n    z2 = np.hstack((y[1:], y[-1]))\n    dx1 = np.hstack((0, np.diff(x)))\n    dx2 = np.hstack((np.diff(x), 0))\n    return (z2 - z1) / (dx2 + dx1)", "response": "Returns the dy and dx of the central difference of x and y."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake 2D point data x and y and creates a profile histogram similar to the TProfile in ROOT.", "response": "def get_profile_histogram(x, y, n_bins=100):\n    '''Takes 2D point data (x,y) and creates a profile histogram similar to the TProfile in ROOT. It calculates\n    the y mean for every bin at the bin center and gives the y mean error as error bars.\n\n    Parameters\n    ----------\n    x : array like\n        data x positions\n    y : array like\n        data y positions\n    n_bins : int\n        the number of bins used to create the histogram\n    '''\n    if len(x) != len(y):\n        raise ValueError('x and y dimensions have to be the same')\n    y = y.astype(np.float32)\n    n, bin_edges = np.histogram(x, bins=n_bins)  # needed to calculate the number of points per bin\n    sy = np.histogram(x, bins=n_bins, weights=y)[0]  # the sum of the bin values\n    sy2 = np.histogram(x, bins=n_bins, weights=y * y)[0]  # the quadratic sum of the bin values\n    bin_centers = (bin_edges[1:] + bin_edges[:-1]) / 2  # calculate the bin center for all bins\n    mean = sy / n  # calculate the mean of all bins\n    std = np.sqrt((sy2 / n - mean * mean))  # TODO: not understood, need check if this is really the standard deviation\n    std_mean = std / np.sqrt((n - 1))\n    mean[np.isnan(mean)] = 0.\n    std_mean[np.isnan(std_mean)] = 0.\n    return bin_centers, mean, std_mean"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_rate_normalization(hit_file, parameter, reference='event', cluster_file=None, plot=False, chunk_size=500000):\n    ''' Takes different hit files (hit_files), extracts the number of events or the scan time (reference) per scan parameter (parameter)\n    and returns an array with a normalization factor. This normalization factor has the length of the number of different parameters.\n    If a cluster_file is specified also the number of cluster per event are used to create the normalization factor.\n\n    Parameters\n    ----------\n    hit_files : string\n    parameter : string\n    reference : string\n    plot : bool\n\n    Returns\n    -------\n    numpy.ndarray\n    '''\n\n    logging.info('Calculate the rate normalization')\n    with tb.open_file(hit_file, mode=\"r+\") as in_hit_file_h5:  # open the hit file\n        meta_data = in_hit_file_h5.root.meta_data[:]\n        scan_parameter = get_scan_parameter(meta_data)[parameter]\n        event_numbers = get_meta_data_at_scan_parameter(meta_data, parameter)['event_number']  # get the event numbers in meta_data where the scan parameter changes\n        event_range = get_ranges_from_array(event_numbers)\n        normalization_rate = []\n        normalization_multiplicity = []\n        try:\n            event_range[-1, 1] = in_hit_file_h5.root.Hits[-1]['event_number'] + 1\n        except tb.NoSuchNodeError:\n            logging.error('Cannot find hits table')\n            return\n\n        # calculate rate normalization from the event rate for triggered data / measurement time for self triggered data for each scan parameter\n        if reference == 'event':\n            n_events = event_range[:, 1] - event_range[:, 0]  # number of events for every parameter setting\n            normalization_rate.extend(n_events)\n        elif reference == 'time':\n            time_start = get_meta_data_at_scan_parameter(meta_data, parameter)['timestamp_start']\n            time_spend = np.diff(time_start)\n            time_spend = np.append(time_spend, meta_data[-1]['timestamp_stop'] - time_start[-1])  # TODO: needs check, add last missing entry\n            normalization_rate.extend(time_spend)\n        else:\n            raise NotImplementedError('The normalization reference ' + reference + ' is not implemented')\n\n        if cluster_file:  # calculate the rate normalization from the mean number of hits per event per scan parameter, needed for beam data since a beam since the multiplicity is rarely constant\n            cluster_table = in_hit_file_h5.root.Cluster\n            index_event_number(cluster_table)\n            index = 0  # index where to start the read out, 0 at the beginning, increased during looping, variable for read speed up\n            best_chunk_size = chunk_size  # variable for read speed up\n            total_cluster = 0\n            progress_bar = progressbar.ProgressBar(widgets=['', progressbar.Percentage(), ' ', progressbar.Bar(marker='*', left='|', right='|'), ' ', progressbar.AdaptiveETA()], maxval=cluster_table.shape[0], term_width=80)\n            progress_bar.start()\n            for start_event, stop_event in event_range:  # loop over the selected events\n                readout_cluster_len = 0  # variable to calculate a optimal chunk size value from the number of hits for speed up\n                n_cluster_per_event = None\n                for clusters, index in data_aligned_at_events(cluster_table, start_event_number=start_event, stop_event_number=stop_event, start_index=index, chunk_size=best_chunk_size):\n                    if n_cluster_per_event is None:\n                        n_cluster_per_event = analysis_utils.get_n_cluster_in_events(clusters['event_number'])[:, 1]  # array with the number of cluster per event, cluster per event are at least 1\n                    else:\n                        n_cluster_per_event = np.append(n_cluster_per_event, analysis_utils.get_n_cluster_in_events(clusters['event_number'])[:, 1])\n                    readout_cluster_len += clusters.shape[0]\n                    total_cluster += clusters.shape[0]\n                    progress_bar.update(index)\n                best_chunk_size = int(1.5 * readout_cluster_len) if int(1.05 * readout_cluster_len) < chunk_size else chunk_size  # to increase the readout speed, estimated the number of hits for one read instruction\n                normalization_multiplicity.append(np.mean(n_cluster_per_event))\n            progress_bar.finish()\n            if total_cluster != cluster_table.shape[0]:\n                logging.warning('Analysis shows inconsistent number of cluster (%d != %d). Check needed!', total_cluster, cluster_table.shape[0])\n\n    if plot:\n        x = scan_parameter\n        if reference == 'event':\n            plotting.plot_scatter(x, normalization_rate, title='Events per ' + parameter + ' setting', x_label=parameter, y_label='# events', log_x=True, filename=os.path.splitext(hit_file)[0] + '_n_event_normalization.pdf')\n        elif reference == 'time':\n            plotting.plot_scatter(x, normalization_rate, title='Measuring time per GDAC setting', x_label=parameter, y_label='time [s]', log_x=True, filename=os.path.splitext(hit_file)[0] + '_time_normalization.pdf')\n        if cluster_file:\n            plotting.plot_scatter(x, normalization_multiplicity, title='Mean number of particles per event', x_label=parameter, y_label='number of hits per event', log_x=True, filename=os.path.splitext(hit_file)[0] + '_n_particles_normalization.pdf')\n    if cluster_file:\n        normalization_rate = np.array(normalization_rate)\n        normalization_multiplicity = np.array(normalization_multiplicity)\n        return np.amax(normalization_rate * normalization_multiplicity).astype('f16') / (normalization_rate * normalization_multiplicity)\n    return np.amax(np.array(normalization_rate)).astype('f16') / np.array(normalization_rate)", "response": "Calculates the rate normalization factor for each hit in the hit file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntake a list of files and searches for the parameter name in the file name and returns a dict with the file name Insights and the corresponding parameter value in the second dimension.", "response": "def get_parameter_value_from_file_names(files, parameters=None, unique=False, sort=True):\n    \"\"\"\n    Takes a list of files, searches for the parameter name in the file name and returns a ordered dict with the file name\n    in the first dimension and the corresponding parameter value in the second.\n    The file names can be sorted by the parameter value, otherwise the order is kept. If unique is true every parameter is unique and\n    mapped to the file name that occurred last in the files list.\n\n    Parameters\n    ----------\n    files : list of strings\n    parameter : string or list of strings\n    unique : bool\n    sort : bool\n\n    Returns\n    -------\n    collections.OrderedDict\n\n    \"\"\"\n#     unique=False\n    logging.debug('Get the parameter: ' + str(parameters) + ' values from the file names of ' + str(len(files)) + ' files')\n    files_dict = collections.OrderedDict()\n    if parameters is None:  # special case, no parameter defined\n        return files_dict\n    if isinstance(parameters, basestring):\n        parameters = (parameters, )\n    search_string = '_'.join(parameters)\n    for _ in parameters:\n        search_string += r'_(-?\\d+)'\n    result = {}\n    for one_file in files:\n        parameter_values = re.findall(search_string, one_file)\n        if parameter_values:\n            if isinstance(parameter_values[0], tuple):\n                parameter_values = list(reduce(lambda t1, t2: t1 + t2, parameter_values))\n            parameter_values = [[int(i), ] for i in parameter_values]  # convert string value to list with int\n            files_dict[one_file] = dict(zip(parameters, parameter_values))\n            if unique:  # reduce to the files with different scan parameters\n                for key, value in files_dict.items():\n                    if value not in result.values():\n                        result[key] = value\n            else:\n                result[one_file] = files_dict[one_file]\n    return collections.OrderedDict(sorted(result.iteritems(), key=itemgetter(1)) if sort else files_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_data_file_names_from_scan_base(scan_base, filter_str=['_analyzed.h5', '_interpreted.h5', '_cut.h5', '_result.h5', '_hists.h5'], sort_by_time=True, meta_data_v2=True):\n    data_files = []\n    if scan_base is None:\n        return data_files\n    if isinstance(scan_base, basestring):\n        scan_base = [scan_base]\n    for scan_base_str in scan_base:\n        if '.h5' == os.path.splitext(scan_base_str)[1]:\n            data_files.append(scan_base_str)\n        else:\n            data_files.extend(glob.glob(scan_base_str + '*.h5'))\n\n    if filter_str:\n        if isinstance(filter_str, basestring):\n            filter_str = [filter_str]\n        data_files = filter(lambda data_file: not any([(True if x in data_file else False) for x in filter_str]), data_files)\n    if sort_by_time and len(data_files) > 1:\n        f_list = {}\n        for data_file in data_files:\n            with tb.open_file(data_file, mode=\"r\") as h5_file:\n                try:\n                    meta_data = h5_file.root.meta_data\n                except tb.NoSuchNodeError:\n                    logging.warning(\"File %s is missing meta_data\" % h5_file.filename)\n                else:\n                    try:\n                        if meta_data_v2:\n                            timestamp = meta_data[0][\"timestamp_start\"]\n                        else:\n                            timestamp = meta_data[0][\"timestamp\"]\n                    except IndexError:\n                        logging.info(\"File %s has empty meta_data\" % h5_file.filename)\n                    else:\n                        f_list[data_file] = timestamp\n\n        data_files = list(sorted(f_list, key=f_list.__getitem__, reverse=False))\n    return data_files", "response": "Generate a list of. h5 files which have a similar file name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_parameter_from_files(files, parameters=None, unique=False, sort=True):\n    ''' Takes a list of files, searches for the parameter name in the file name and in the file.\n    Returns a ordered dict with the file name in the first dimension and the corresponding parameter values in the second.\n    If a scan parameter appears in the file name and in the file the first parameter setting has to be in the file name, otherwise a warning is shown.\n    The file names can be sorted by the first parameter value of each file.\n\n    Parameters\n    ----------\n    files : string, list of strings\n    parameters : string, list of strings\n    unique : boolean\n        If set only one file per scan parameter value is used.\n    sort : boolean\n\n    Returns\n    -------\n    collections.OrderedDict\n\n    '''\n    logging.debug('Get the parameter ' + str(parameters) + ' values from ' + str(len(files)) + ' files')\n    files_dict = collections.OrderedDict()\n    if isinstance(files, basestring):\n        files = (files, )\n    if isinstance(parameters, basestring):\n        parameters = (parameters, )\n    parameter_values_from_file_names_dict = get_parameter_value_from_file_names(files, parameters, unique=unique, sort=sort)  # get the parameter from the file name\n    for file_name in files:\n        with tb.open_file(file_name, mode=\"r\") as in_file_h5:  # open the actual file\n            scan_parameter_values = collections.OrderedDict()\n            try:\n                scan_parameters = in_file_h5.root.scan_parameters[:]  # get the scan parameters from the scan parameter table\n                if parameters is None:\n                    parameters = get_scan_parameter_names(scan_parameters)\n                for parameter in parameters:\n                    try:\n                        scan_parameter_values[parameter] = np.unique(scan_parameters[parameter]).tolist()  # different scan parameter values used\n                    except ValueError:  # the scan parameter does not exists\n                        pass\n            except tb.NoSuchNodeError:  # scan parameter table does not exist\n                try:\n                    scan_parameters = get_scan_parameter(in_file_h5.root.meta_data[:])  # get the scan parameters from the meta data\n                    if scan_parameters:\n                        try:\n                            scan_parameter_values = np.unique(scan_parameters[parameters]).tolist()  # different scan parameter values used\n                        except ValueError:  # the scan parameter does not exists\n                            pass\n                except tb.NoSuchNodeError:  # meta data table does not exist\n                    pass\n            if not scan_parameter_values:  # if no scan parameter values could be set from file take the parameter found in the file name\n                try:\n                    scan_parameter_values = parameter_values_from_file_names_dict[file_name]\n                except KeyError:  # no scan parameter found at all, neither in the file name nor in the file\n                    scan_parameter_values = None\n            else:  # use the parameter given in the file and cross check if it matches the file name parameter if these is given\n                try:\n                    for key, value in scan_parameter_values.items():\n                        if value and value[0] != parameter_values_from_file_names_dict[file_name][key][0]:  # parameter value exists: check if the first value is the file name value\n                            logging.warning('Parameter values in the file name and in the file differ. Take ' + str(key) + ' parameters ' + str(value) + ' found in %s.', file_name)\n                except KeyError:  # parameter does not exists in the file name\n                    pass\n                except IndexError:\n                    raise IncompleteInputError('Something wrong check!')\n            if unique and scan_parameter_values is not None:\n                existing = False\n                for parameter in scan_parameter_values:  # loop to determine if any value of any scan parameter exists already\n                    all_par_values = [values[parameter] for values in files_dict.values()]\n                    if any(x in [scan_parameter_values[parameter]] for x in all_par_values):\n                        existing = True\n                        break\n                if not existing:\n                    files_dict[file_name] = scan_parameter_values\n                else:\n                    logging.warning('Scan parameter value(s) from %s exists already, do not add to result', file_name)\n            else:\n                files_dict[file_name] = scan_parameter_values\n    return collections.OrderedDict(sorted(files_dict.iteritems(), key=itemgetter(1)) if sort else files_dict)", "response": "Takes a list of files searches for the parameter name in the first dimension and the corresponding parameter values in the second dimension."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the parameter names of all files are similar. Takes the dictionary from get_parameter_from_files output as input.", "response": "def check_parameter_similarity(files_dict):\n    \"\"\"\n    Checks if the parameter names of all files are similar. Takes the dictionary from get_parameter_from_files output as input.\n\n    \"\"\"\n    try:\n        parameter_names = files_dict.itervalues().next().keys()  # get the parameter names of the first file, to check if these are the same in the other files\n    except AttributeError:  # if there is no parameter at all\n        if any(i is not None for i in files_dict.itervalues()):  # check if there is also no parameter for the other files\n            return False\n        else:\n            return True\n    if any(parameter_names != i.keys() for i in files_dict.itervalues()):\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking a dict of hdf5 files and combines their meta data tables into one numpy record array.", "response": "def combine_meta_data(files_dict, meta_data_v2=True):\n    \"\"\"\n    Takes the dict of hdf5 files and combines their meta data tables into one new numpy record array.\n\n    Parameters\n    ----------\n    meta_data_v2 : bool\n        True for new (v2) meta data format, False for the old (v1) format.\n    \"\"\"\n    if len(files_dict) > 10:\n        logging.info(\"Combine the meta data from %d files\", len(files_dict))\n    # determine total length needed for the new combined array, thats the fastest way to combine arrays\n    total_length = 0  # the total length of the new table\n    for file_name in files_dict.iterkeys():\n        with tb.open_file(file_name, mode=\"r\") as in_file_h5:  # open the actual file\n            total_length += in_file_h5.root.meta_data.shape[0]\n\n    if meta_data_v2:\n        meta_data_combined = np.empty((total_length, ), dtype=[\n            ('index_start', np.uint32),\n            ('index_stop', np.uint32),\n            ('data_length', np.uint32),\n            ('timestamp_start', np.float64),\n            ('timestamp_stop', np.float64),\n            ('error', np.uint32)])\n    else:\n        meta_data_combined = np.empty((total_length, ), dtype=[\n            ('start_index', np.uint32),\n            ('stop_index', np.uint32),\n            ('length', np.uint32),\n            ('timestamp', np.float64),\n            ('error', np.uint32)])\n\n    if len(files_dict) > 10:\n        progress_bar = progressbar.ProgressBar(widgets=['', progressbar.Percentage(), ' ', progressbar.Bar(marker='*', left='|', right='|'), ' ', progressbar.AdaptiveETA()], maxval=total_length, term_width=80)\n        progress_bar.start()\n\n    index = 0\n\n    # fill actual result array\n    for file_name in files_dict.iterkeys():\n        with tb.open_file(file_name, mode=\"r\") as in_file_h5:  # open the actual file\n            array_length = in_file_h5.root.meta_data.shape[0]\n            meta_data_combined[index:index + array_length] = in_file_h5.root.meta_data[:]\n            index += array_length\n            if len(files_dict) > 10:\n                progress_bar.update(index)\n    if len(files_dict) > 10:\n        progress_bar.finish()\n    return meta_data_combined"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the dy / dx of a spline curve with the fit and differentiation of a spline curve.", "response": "def smooth_differentiation(x, y, weigths=None, order=5, smoothness=3, derivation=1):\n    '''Returns the dy/dx(x) with the fit and differentiation of a spline curve\n\n    Parameters\n    ----------\n    x : array like\n    y : array like\n\n    Returns\n    -------\n    dy/dx : array like\n    '''\n    if (len(x) != len(y)):\n        raise ValueError(\"x, y must have the same length\")\n    f = splrep(x, y, w=weigths, k=order, s=smoothness)  # spline function\n    return splev(x, f, der=derivation)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reduce_sorted_to_intersect(ar1, ar2):\n    # Ravel both arrays, behavior for the first array could be different\n    ar1 = np.asarray(ar1).ravel()\n    ar2 = np.asarray(ar2).ravel()\n\n    # get min max values of the arrays\n    ar1_biggest_value = ar1[-1]\n    ar1_smallest_value = ar1[0]\n    ar2_biggest_value = ar2[-1]\n    ar2_smallest_value = ar2[0]\n\n    if ar1_biggest_value < ar2_smallest_value or ar1_smallest_value > ar2_biggest_value:  # special case, no intersection at all\n        return ar1[0:0], ar2[0:0]\n\n    # get min/max indices with values that are also in the other array\n    min_index_ar1 = np.argmin(ar1 < ar2_smallest_value)\n    max_index_ar1 = np.argmax(ar1 > ar2_biggest_value)\n    min_index_ar2 = np.argmin(ar2 < ar1_smallest_value)\n    max_index_ar2 = np.argmax(ar2 > ar1_biggest_value)\n\n    if min_index_ar1 < 0:\n        min_index_ar1 = 0\n    if min_index_ar2 < 0:\n        min_index_ar2 = 0\n    if max_index_ar1 == 0 or max_index_ar1 > ar1.shape[0]:\n        max_index_ar1 = ar1.shape[0]\n    if max_index_ar2 == 0 or max_index_ar2 > ar2.shape[0]:\n        max_index_ar2 = ar2.shape[0]\n\n    # reduce the data\n    return ar1[min_index_ar1:max_index_ar1], ar2[min_index_ar2:max_index_ar2]", "response": "Takes two sorted arrays and return the intersection ar1 in ar2 in ar1."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the values that appear at least twice in array.", "response": "def get_not_unique_values(array):\n    '''Returns the values that appear at least twice in array.\n\n    Parameters\n    ----------\n    array : array like\n\n    Returns\n    -------\n    numpy.array\n    '''\n    s = np.sort(array, axis=None)\n    s = s[s[1:] == s[:-1]]\n    return np.unique(s)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_meta_data_index_at_scan_parameter(meta_data_array, scan_parameter_name):\n    '''Takes the analyzed meta_data table and returns the indices where the scan parameter changes\n\n    Parameters\n    ----------\n    meta_data_array : numpy.recordarray\n    scan_parameter_name : string\n\n    Returns\n    -------\n    numpy.ndarray:\n        first dimension: scan parameter value\n        second dimension: index where scan parameter value was used first\n    '''\n    scan_parameter_values = meta_data_array[scan_parameter_name]\n    diff = np.concatenate(([1], np.diff(scan_parameter_values)))\n    idx = np.concatenate((np.where(diff)[0], [len(scan_parameter_values)]))\n    index = np.empty(len(idx) - 1, dtype={'names': [scan_parameter_name, 'index'], 'formats': ['u4', 'u4']})\n    index[scan_parameter_name] = scan_parameter_values[idx[:-1]]\n    index['index'] = idx[:-1]\n    return index", "response": "Takes the analyzed meta_data table and returns the indices where the scan parameter changes"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef select_hits(hits_array, condition=None):\n    '''Selects the hits with condition.\n    E.g.: condition = 'rel_BCID == 7 & event_number < 1000'\n\n    Parameters\n    ----------\n    hits_array : numpy.array\n    condition : string\n        A condition that is applied to the hits in numexpr. Only if the expression evaluates to True the hit is taken.\n\n    Returns\n    -------\n    numpy.array\n        hit array with the selceted hits\n    '''\n    if condition is None:\n        return hits_array\n\n    for variable in set(re.findall(r'[a-zA-Z_]+', condition)):\n        exec(variable + ' = hits_array[\\'' + variable + '\\']')\n\n    return hits_array[ne.evaluate(condition)]", "response": "Selects the hits with condition."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nselect the hits that occurred in events and optional selection criterion.", "response": "def get_hits_in_events(hits_array, events, assume_sorted=True, condition=None):\n    '''Selects the hits that occurred in events and optional selection criterion.\n        If a event range can be defined use the get_data_in_event_range function. It is much faster.\n\n    Parameters\n    ----------\n    hits_array : numpy.array\n    events : array\n    assume_sorted : bool\n        Is true if the events to select are sorted from low to high value. Increases speed by 35%.\n    condition : string\n        A condition that is applied to the hits in numexpr. Only if the expression evaluates to True the hit is taken.\n\n    Returns\n    -------\n    numpy.array\n        hit array with the hits in events.\n    '''\n\n    logging.debug(\"Calculate hits that exists in the given %d events.\" % len(events))\n    if assume_sorted:\n        events, _ = reduce_sorted_to_intersect(events, hits_array['event_number'])  # reduce the event number range to the max min event number of the given hits to save time\n        if events.shape[0] == 0:  # if there is not a single selected hit\n            return hits_array[0:0]\n    try:\n        if assume_sorted:\n            selection = analysis_utils.in1d_events(hits_array['event_number'], events)\n        else:\n            logging.warning('Events are usually sorted. Are you sure you want this?')\n            selection = np.in1d(hits_array['event_number'], events)\n        if condition is None:\n            hits_in_events = hits_array[selection]\n        else:\n            # bad hack to be able to use numexpr\n            for variable in set(re.findall(r'[a-zA-Z_]+', condition)):\n                exec(variable + ' = hits_array[\\'' + variable + '\\']')\n\n            hits_in_events = hits_array[ne.evaluate(condition + ' & selection')]\n    except MemoryError:\n        logging.error('There are too many hits to do in RAM operations. Consider decreasing chunk size and use the write_hits_in_events function instead.')\n        raise MemoryError\n    return hits_in_events"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_hits_of_scan_parameter(input_file_hits, scan_parameters=None, try_speedup=False, chunk_size=10000000):\n    '''Takes the hit table of a hdf5 file and returns hits in chunks for each unique combination of scan_parameters.\n    Yields the hits in chunks, since they usually do not fit into memory.\n\n    Parameters\n    ----------\n    input_file_hits : pytable hdf5 file\n        Has to include a hits node\n    scan_parameters : iterable with strings\n    try_speedup : bool\n        If true a speed up by searching for the event numbers in the data is done. If the event numbers are not in the data\n        this slows down the search.\n    chunk_size : int\n        How many rows of data are read into ram.\n\n    Returns\n    -------\n    Yields tuple, numpy.array\n        Actual scan parameter tuple, hit array with the hits of a chunk of the given scan parameter tuple\n    '''\n\n    with tb.open_file(input_file_hits, mode=\"r+\") as in_file_h5:\n        hit_table = in_file_h5.root.Hits\n        meta_data = in_file_h5.root.meta_data[:]\n        meta_data_table_at_scan_parameter = get_unique_scan_parameter_combinations(meta_data, scan_parameters=scan_parameters)\n        parameter_values = get_scan_parameters_table_from_meta_data(meta_data_table_at_scan_parameter, scan_parameters)\n        event_number_ranges = get_ranges_from_array(meta_data_table_at_scan_parameter['event_number'])  # get the event number ranges for the different scan parameter settings\n        index_event_number(hit_table)  # create a event_numer index to select the hits by their event number fast, no needed but important for speed up\n#\n        # variables for read speed up\n        index = 0  # index where to start the read out of the hit table, 0 at the beginning, increased during looping\n        best_chunk_size = chunk_size  # number of hits to copy to RAM during looping, the optimal chunk size is determined during looping\n\n        # loop over the selected events\n        for parameter_index, (start_event_number, stop_event_number) in enumerate(event_number_ranges):\n            logging.debug('Read hits for ' + str(scan_parameters) + ' = ' + str(parameter_values[parameter_index]))\n\n            readout_hit_len = 0  # variable to calculate a optimal chunk size value from the number of hits for speed up\n            # loop over the hits in the actual selected events with optimizations: determine best chunk size, start word index given\n            for hits, index in data_aligned_at_events(hit_table, start_event_number=start_event_number, stop_event_number=stop_event_number, start_index=index, try_speedup=try_speedup, chunk_size=best_chunk_size):\n                yield parameter_values[parameter_index], hits\n                readout_hit_len += hits.shape[0]\n            best_chunk_size = int(1.5 * readout_hit_len) if int(1.05 * readout_hit_len) < chunk_size and int(1.05 * readout_hit_len) > 1e3 else chunk_size", "response": "Takes the hit table of a hdf5 file and returns hits in chunks for each unique combination of scan_parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_data_in_event_range(array, event_start=None, event_stop=None, assume_sorted=True):\n    '''Selects the data (rows of a table) that occurred in the given event range [event_start, event_stop[\n\n    Parameters\n    ----------\n    array : numpy.array\n    event_start : int, None\n    event_stop : int, None\n    assume_sorted : bool\n        Set to true if the hits are sorted by the event_number. Increases speed.\n\n    Returns\n    -------\n    numpy.array\n        hit array with the hits in the event range.\n    '''\n    logging.debug(\"Calculate data of the the given event range [\" + str(event_start) + \", \" + str(event_stop) + \"[\")\n    event_number = array['event_number']\n    if assume_sorted:\n        data_event_start = event_number[0]\n        data_event_stop = event_number[-1]\n        if (event_start is not None and event_stop is not None) and (data_event_stop < event_start or data_event_start > event_stop or event_start == event_stop):  # special case, no intersection at all\n            return array[0:0]\n\n        # get min/max indices with values that are also in the other array\n        if event_start is None:\n            min_index_data = 0\n        else:\n            min_index_data = np.argmin(event_number < event_start)\n\n        if event_stop is None:\n            max_index_data = event_number.shape[0]\n        else:\n            max_index_data = np.argmax(event_number >= event_stop)\n\n        if min_index_data < 0:\n            min_index_data = 0\n        if max_index_data == 0 or max_index_data > event_number.shape[0]:\n            max_index_data = event_number.shape[0]\n        return array[min_index_data:max_index_data]\n    else:\n        return array[ne.evaluate('event_number >= event_start & event_number < event_stop')]", "response": "Selects the data that occurred in the given event range [ event_start event_stop ]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nselects the hits that occurred in events and writes them to a pytable.", "response": "def write_hits_in_events(hit_table_in, hit_table_out, events, start_hit_word=0, chunk_size=5000000, condition=None):\n    '''Selects the hits that occurred in events and writes them to a pytable. This function reduces the in RAM operations and has to be\n    used if the get_hits_in_events function raises a memory error. Also a condition can be set to select hits.\n\n    Parameters\n    ----------\n    hit_table_in : pytable.table\n    hit_table_out : pytable.table\n        functions need to be able to write to hit_table_out\n    events : array like\n        defines the events to be written from hit_table_in to hit_table_out. They do not have to exists at all.\n    start_hit_word: int\n        Index of the first hit word to be analyzed. Used for speed up.\n    chunk_size : int\n        defines how many hits are analyzed in RAM. Bigger numbers increase the speed, too big numbers let the program crash with a memory error.\n    condition : string\n        A condition that is applied to the hits in numexpr style. Only if the expression evaluates to True the hit is taken.\n\n    Returns\n    -------\n    start_hit_word: int\n        Index of the last hit word analyzed. Used to speed up the next call of write_hits_in_events.\n    '''\n    if len(events) > 0:  # needed to avoid crash\n        min_event = np.amin(events)\n        max_event = np.amax(events)\n        logging.debug(\"Write hits from hit number >= %d that exists in the selected %d events with %d <= event number <= %d into a new hit table.\" % (start_hit_word, len(events), min_event, max_event))\n        table_size = hit_table_in.shape[0]\n        iHit = 0\n        for iHit in range(start_hit_word, table_size, chunk_size):\n            hits = hit_table_in.read(iHit, iHit + chunk_size)\n            last_event_number = hits[-1]['event_number']\n            hit_table_out.append(get_hits_in_events(hits, events=events, condition=condition))\n            if last_event_number > max_event:  # speed up, use the fact that the hits are sorted by event_number\n                return iHit\n    return start_hit_word"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_hits_in_event_range(hit_table_in, hit_table_out, event_start=None, event_stop=None, start_hit_word=0, chunk_size=5000000, condition=None):\n    '''Selects the hits that occurred in given event range [event_start, event_stop[ and write them to a pytable. This function reduces the in RAM\n       operations and has to be used if the get_data_in_event_range function raises a memory error. Also a condition can be set to select hits.\n\n    Parameters\n    ----------\n    hit_table_in : pytable.table\n    hit_table_out : pytable.table\n        functions need to be able to write to hit_table_out\n    event_start, event_stop : int, None\n        start/stop event numbers. Stop event number is excluded. If None start/stop is set automatically.\n    chunk_size : int\n        defines how many hits are analyzed in RAM. Bigger numbers increase the speed, too big numbers let the program crash with a memory error.\n    condition : string\n        A condition that is applied to the hits in numexpr style. Only if the expression evaluates to True the hit is taken.\n    Returns\n    -------\n    start_hit_word: int\n        Index of the last hit word analyzed. Used to speed up the next call of write_hits_in_events.\n    '''\n\n    logging.debug('Write hits that exists in the given event range from + ' + str(event_start) + ' to ' + str(event_stop) + ' into a new hit table')\n    table_size = hit_table_in.shape[0]\n    for iHit in range(0, table_size, chunk_size):\n        hits = hit_table_in.read(iHit, iHit + chunk_size)\n        last_event_number = hits[-1]['event_number']\n        selected_hits = get_data_in_event_range(hits, event_start=event_start, event_stop=event_stop)\n        if condition is not None:\n            # bad hack to be able to use numexpr\n            for variable in set(re.findall(r'[a-zA-Z_]+', condition)):\n                exec(variable + ' = hits[\\'' + variable + '\\']')\n            selected_hits = selected_hits[ne.evaluate(condition)]\n        hit_table_out.append(selected_hits)\n        if last_event_number > event_stop:  # speed up, use the fact that the hits are sorted by event_number\n            return iHit + chunk_size\n    return start_hit_word", "response": "This function writes hits that occurred in given event range to a hit table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_events_with_n_cluster(event_number, condition='n_cluster==1'):\n    '''Selects the events with a certain number of cluster.\n\n    Parameters\n    ----------\n    event_number : numpy.array\n\n    Returns\n    -------\n    numpy.array\n    '''\n\n    logging.debug(\"Calculate events with clusters where \" + condition)\n    n_cluster_in_events = analysis_utils.get_n_cluster_in_events(event_number)\n    n_cluster = n_cluster_in_events[:, 1]\n#    return np.take(n_cluster_in_events, ne.evaluate(condition), axis=0)  # does not return 1d, bug?\n    return n_cluster_in_events[ne.evaluate(condition), 0]", "response": "Selects the events with a certain number of cluster."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nselect the events with cluster of a given cluster size.", "response": "def get_events_with_cluster_size(event_number, cluster_size, condition='cluster_size==1'):\n    '''Selects the events with cluster of a given cluster size.\n\n    Parameters\n    ----------\n    event_number : numpy.array\n    cluster_size : numpy.array\n    condition : string\n\n    Returns\n    -------\n    numpy.array\n    '''\n\n    logging.debug(\"Calculate events with clusters with \" + condition)\n    return np.unique(event_number[ne.evaluate(condition)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nselects the events with a certain error code.", "response": "def get_events_with_error_code(event_number, event_status, select_mask=0b1111111111111111, condition=0b0000000000000000):\n    '''Selects the events with a certain error code.\n\n    Parameters\n    ----------\n    event_number : numpy.array\n    event_status : numpy.array\n    select_mask : int\n        The mask that selects the event error code to check.\n    condition : int\n        The value the selected event error code should have.\n\n    Returns\n    -------\n    numpy.array\n    '''\n\n    logging.debug(\"Calculate events with certain error code\")\n    return np.unique(event_number[event_status & select_mask == condition])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking the numpy meta data array and returns the different scan parameter settings and the name aligned in a dictionary", "response": "def get_scan_parameter(meta_data_array, unique=True):\n    '''Takes the numpy meta data array and returns the different scan parameter settings and the name aligned in a dictionary\n\n    Parameters\n    ----------\n    meta_data_array : numpy.ndarray\n    unique: boolean\n        If true only unique values for each scan parameter are returned\n\n    Returns\n    -------\n    python.dict{string, numpy.Histogram}:\n        A dictionary with the scan parameter name/values pairs\n    '''\n\n    try:\n        last_not_parameter_column = meta_data_array.dtype.names.index('error_code')  # for interpreted meta_data\n    except ValueError:\n        last_not_parameter_column = meta_data_array.dtype.names.index('error')  # for raw data file meta_data\n    if last_not_parameter_column == len(meta_data_array.dtype.names) - 1:  # no meta_data found\n        return\n    scan_parameters = collections.OrderedDict()\n    for scan_par_name in meta_data_array.dtype.names[4:]:  # scan parameters are in columns 5 (= index 4) and above\n        scan_parameters[scan_par_name] = np.unique(meta_data_array[scan_par_name]) if unique else meta_data_array[scan_par_name]\n    return scan_parameters"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_scan_parameters_table_from_meta_data(meta_data_array, scan_parameters=None):\n    '''Takes the meta data array and returns the scan parameter values as a view of a numpy array only containing the parameter data .\n    Parameters\n    ----------\n    meta_data_array : numpy.ndarray\n        The array with the scan parameters.\n    scan_parameters : list of strings\n        The name of the scan parameters to take. If none all are used.\n\n    Returns\n    -------\n    numpy.Histogram\n    '''\n\n    if scan_parameters is None:\n        try:\n            last_not_parameter_column = meta_data_array.dtype.names.index('error_code')  # for interpreted meta_data\n        except ValueError:\n            return\n        if last_not_parameter_column == len(meta_data_array.dtype.names) - 1:  # no meta_data found\n            return\n        # http://stackoverflow.com/questions/15182381/how-to-return-a-view-of-several-columns-in-numpy-structured-array\n        scan_par_data = {name: meta_data_array.dtype.fields[name] for name in meta_data_array.dtype.names[last_not_parameter_column + 1:]}\n    else:\n        scan_par_data = collections.OrderedDict()\n        for name in scan_parameters:\n            scan_par_data[name] = meta_data_array.dtype.fields[name]\n\n    return np.ndarray(meta_data_array.shape, np.dtype(scan_par_data), meta_data_array, 0, meta_data_array.strides)", "response": "Takes the meta data array and returns the scan parameter values as a view of a numpy array only containing the parameter data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake the scan parameter array and creates a scan parameter index labeling the unique scan parameter combinations.", "response": "def get_scan_parameters_index(scan_parameter):\n    '''Takes the scan parameter array and creates a scan parameter index labeling the unique scan parameter combinations.\n    Parameters\n    ----------\n    scan_parameter : numpy.ndarray\n        The table with the scan parameters.\n\n    Returns\n    -------\n    numpy.Histogram\n    '''\n    _, index = np.unique(scan_parameter, return_index=True)\n    index = np.sort(index)\n    values = np.array(range(0, len(index)), dtype='i4')\n    index = np.append(index, len(scan_parameter))\n    counts = np.diff(index)\n    return np.repeat(values, counts)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_unique_scan_parameter_combinations(meta_data_array, scan_parameters=None, scan_parameter_columns_only=False):\n    '''Takes the numpy meta data array and returns the first rows with unique combinations of different scan parameter values for selected scan parameters.\n        If selected columns only is true, the returned histogram only contains the selected columns.\n\n    Parameters\n    ----------\n    meta_data_array : numpy.ndarray\n    scan_parameters : list of string, None\n        Scan parameter names taken. If None all are used.\n    selected_columns_only : bool\n\n    Returns\n    -------\n    numpy.Histogram\n    '''\n\n    try:\n        last_not_parameter_column = meta_data_array.dtype.names.index('error_code')  # for interpreted meta_data\n    except ValueError:\n        last_not_parameter_column = meta_data_array.dtype.names.index('error')  # for raw data file meta_data\n    if last_not_parameter_column == len(meta_data_array.dtype.names) - 1:  # no meta_data found\n        return\n    if scan_parameters is None:\n        return unique_row(meta_data_array, use_columns=range(4, len(meta_data_array.dtype.names)), selected_columns_only=scan_parameter_columns_only)\n    else:\n        use_columns = []\n        for scan_parameter in scan_parameters:\n            try:\n                use_columns.append(meta_data_array.dtype.names.index(scan_parameter))\n            except ValueError:\n                logging.error('No scan parameter ' + scan_parameter + ' found')\n                raise RuntimeError('Scan parameter not found')\n        return unique_row(meta_data_array, use_columns=use_columns, selected_columns_only=scan_parameter_columns_only)", "response": "Takes the numpy meta data array and returns the first rows with unique combinations of different scan parameter values for selected scan parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef data_aligned_at_events(table, start_event_number=None, stop_event_number=None, start_index=None, stop_index=None, chunk_size=10000000, try_speedup=False, first_event_aligned=True, fail_on_missing_events=True):\n    '''Takes the table with a event_number column and returns chunks with the size up to chunk_size. The chunks are chosen in a way that the events are not splitted.\n    Additional parameters can be set to increase the readout speed. Events between a certain range can be selected.\n    Also the start and the stop indices limiting the table size can be specified to improve performance.\n    The event_number column must be sorted.\n    In case of try_speedup is True, it is important to create an index of event_number column with pytables before using this function. Otherwise the queries are slowed down.\n\n    Parameters\n    ----------\n    table : pytables.table\n        The data.\n    start_event_number : int\n        The retruned data contains events with event number >= start_event_number. If None, no limit is set.\n    stop_event_number : int\n        The retruned data contains events with event number < stop_event_number. If None, no limit is set.\n    start_index : int\n        Start index of data. If None, no limit is set.\n    stop_index : int\n        Stop index of data. If None, no limit is set.\n    chunk_size : int\n        Maximum chunk size per read.\n    try_speedup : bool\n        If True, try to reduce the index range to read by searching for the indices of start and stop event number. If these event numbers are usually\n        not in the data this speedup can even slow down the function!\n\n    The following parameters are not used when try_speedup is True:\n\n    first_event_aligned : bool\n        If True, assuming that the first event is aligned to the data chunk and will be added. If False, the lowest event number of the first chunk will not be read out.\n    fail_on_missing_events : bool\n        If True, an error is given when start_event_number or stop_event_number is not part of the data.\n\n    Returns\n    -------\n    Iterator of tuples\n        Data of the actual data chunk and start index for the next chunk.\n\n    Example\n    -------\n    start_index = 0\n    for scan_parameter in scan_parameter_range:\n        start_event_number, stop_event_number = event_select_function(scan_parameter)\n        for data, start_index in data_aligned_at_events(table, start_event_number=start_event_number, stop_event_number=stop_event_number, start_index=start_index):\n            do_something(data)\n\n    for data, index in data_aligned_at_events(table):\n        do_something(data)\n    '''\n    # initialize variables\n    start_index_known = False\n    stop_index_known = False\n    start_index = 0 if start_index is None else start_index\n    stop_index = table.nrows if stop_index is None else stop_index\n    if stop_index < start_index:\n        raise InvalidInputError('Invalid start/stop index')\n    table_max_rows = table.nrows\n    if stop_event_number is not None and start_event_number is not None and stop_event_number < start_event_number:\n        raise InvalidInputError('Invalid start/stop event number')\n\n    # set start stop indices from the event numbers for fast read if possible; not possible if the given event number does not exist in the data stream\n    if try_speedup and table.colindexed[\"event_number\"]:\n        if start_event_number is not None:\n            start_condition = 'event_number==' + str(start_event_number)\n            start_indices = table.get_where_list(start_condition, start=start_index, stop=stop_index)\n            if start_indices.shape[0] != 0:  # set start index if possible\n                start_index = start_indices[0]\n                start_index_known = True\n\n        if stop_event_number is not None:\n            stop_condition = 'event_number==' + str(stop_event_number)\n            stop_indices = table.get_where_list(stop_condition, start=start_index, stop=stop_index)\n            if stop_indices.shape[0] != 0:  # set the stop index if possible, stop index is excluded\n                stop_index = stop_indices[0]\n                stop_index_known = True\n\n    if start_index_known and stop_index_known and start_index + chunk_size >= stop_index:  # special case, one read is enough, data not bigger than one chunk and the indices are known\n        yield table.read(start=start_index, stop=stop_index), stop_index\n    else:  # read data in chunks, chunks do not divide events, abort if stop_event_number is reached\n\n        # search for begin\n        current_start_index = start_index\n        if start_event_number is not None:\n            while current_start_index < stop_index:\n                current_stop_index = min(current_start_index + chunk_size, stop_index)\n                array_chunk = table.read(start=current_start_index, stop=current_stop_index)  # stop index is exclusive, so add 1\n                last_event_in_chunk = array_chunk[\"event_number\"][-1]\n\n                if last_event_in_chunk < start_event_number:\n                    current_start_index = current_start_index + chunk_size  # not there yet, continue to next read (assuming sorted events)\n                else:\n                    first_event_in_chunk = array_chunk[\"event_number\"][0]\n#                     if stop_event_number is not None and first_event_in_chunk >= stop_event_number and start_index != 0 and start_index == current_start_index:\n#                         raise InvalidInputError('The stop event %d is missing. Change stop_event_number.' % stop_event_number)\n                    if array_chunk.shape[0] == chunk_size and first_event_in_chunk == last_event_in_chunk:\n                        raise InvalidInputError('Chunk size too small. Increase chunk size to fit full event.')\n\n                    if not first_event_aligned and first_event_in_chunk == start_event_number and start_index != 0 and start_index == current_start_index:  # first event in first chunk not aligned at index 0, so take next event\n                        if fail_on_missing_events:\n                            raise InvalidInputError('The start event %d is missing. Change start_event_number.' % start_event_number)\n                        chunk_start_index = np.searchsorted(array_chunk[\"event_number\"], start_event_number + 1, side='left')\n                    elif fail_on_missing_events and first_event_in_chunk > start_event_number and start_index == current_start_index:\n                        raise InvalidInputError('The start event %d is missing. Change start_event_number.' % start_event_number)\n                    elif first_event_aligned and first_event_in_chunk == start_event_number and start_index == current_start_index:\n                        chunk_start_index = 0\n                    else:\n                        chunk_start_index = np.searchsorted(array_chunk[\"event_number\"], start_event_number, side='left')\n                        if fail_on_missing_events and array_chunk[\"event_number\"][chunk_start_index] != start_event_number and start_index == current_start_index:\n                            raise InvalidInputError('The start event %d is missing. Change start_event_number.' % start_event_number)\n#                     if fail_on_missing_events and ((start_index == current_start_index and chunk_start_index == 0 and start_index != 0 and not first_event_aligned) or array_chunk[\"event_number\"][chunk_start_index] != start_event_number):\n#                         raise InvalidInputError('The start event %d is missing. Change start_event_number.' % start_event_number)\n                    current_start_index = current_start_index + chunk_start_index  # calculate index for next loop\n                    break\n        elif not first_event_aligned and start_index != 0:\n            while current_start_index < stop_index:\n                current_stop_index = min(current_start_index + chunk_size, stop_index)\n                array_chunk = table.read(start=current_start_index, stop=current_stop_index)  # stop index is exclusive, so add 1\n                first_event_in_chunk = array_chunk[\"event_number\"][0]\n                last_event_in_chunk = array_chunk[\"event_number\"][-1]\n\n                if array_chunk.shape[0] == chunk_size and first_event_in_chunk == last_event_in_chunk:\n                    raise InvalidInputError('Chunk size too small. Increase chunk size to fit full event.')\n\n                chunk_start_index = np.searchsorted(array_chunk[\"event_number\"], first_event_in_chunk + 1, side='left')\n                current_start_index = current_start_index + chunk_start_index\n                if not first_event_in_chunk == last_event_in_chunk:\n                    break\n\n        # data loop\n        while current_start_index < stop_index:\n            current_stop_index = min(current_start_index + chunk_size, stop_index)\n            array_chunk = table.read(start=current_start_index, stop=current_stop_index)  # stop index is exclusive, so add 1\n            first_event_in_chunk = array_chunk[\"event_number\"][0]\n            last_event_in_chunk = array_chunk[\"event_number\"][-1]\n\n            chunk_start_index = 0\n\n            if stop_event_number is None:\n                if current_stop_index == table_max_rows:\n                    chunk_stop_index = array_chunk.shape[0]\n                else:\n                    chunk_stop_index = np.searchsorted(array_chunk[\"event_number\"], last_event_in_chunk, side='left')\n            else:\n                if last_event_in_chunk >= stop_event_number:\n                    chunk_stop_index = np.searchsorted(array_chunk[\"event_number\"], stop_event_number, side='left')\n                elif current_stop_index == table_max_rows:  # this will also add the last event of the table\n                    chunk_stop_index = array_chunk.shape[0]\n                else:\n                    chunk_stop_index = np.searchsorted(array_chunk[\"event_number\"], last_event_in_chunk, side='left')\n\n            nrows = chunk_stop_index - chunk_start_index\n            if nrows == 0:\n                if array_chunk.shape[0] == chunk_size and first_event_in_chunk == last_event_in_chunk:\n                    raise InvalidInputError('Chunk size too small to fit event. Data corruption possible. Increase chunk size to read full event.')\n                elif chunk_start_index == 0:  # not increasing current_start_index\n                    return\n                elif stop_event_number is not None and last_event_in_chunk >= stop_event_number:\n                    return\n            else:\n                yield array_chunk[chunk_start_index:chunk_stop_index], current_start_index + nrows + chunk_start_index\n\n            current_start_index = current_start_index + nrows + chunk_start_index", "response": "Takes the table with a event_number column and returns chunks with the size up to chunk_size."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef select_good_pixel_region(hits, col_span, row_span, min_cut_threshold=0.2, max_cut_threshold=2.0):\n    '''Takes the hit array and masks all pixels with a certain occupancy.\n\n    Parameters\n    ----------\n    hits : array like\n        If dim > 2 the additional dimensions are summed up.\n    min_cut_threshold : float\n        A number to specify the minimum threshold, which pixel to take. Pixels are masked if\n        occupancy < min_cut_threshold * np.ma.median(occupancy)\n        0 means that no pixels are masked\n    max_cut_threshold : float\n        A number to specify the maximum threshold, which pixel to take. Pixels are masked if\n        occupancy > max_cut_threshold * np.ma.median(occupancy)\n        Can be set to None that no pixels are masked by max_cut_threshold\n\n    Returns\n    -------\n    numpy.ma.array, shape=(80,336)\n        The hits array with masked pixels.\n    '''\n    hits = np.sum(hits, axis=(-1)).astype('u8')\n    mask = np.ones(shape=(80, 336), dtype=np.uint8)\n\n    mask[min(col_span):max(col_span) + 1, min(row_span):max(row_span) + 1] = 0\n\n    ma = np.ma.masked_where(mask, hits)\n    if max_cut_threshold is not None:\n        return np.ma.masked_where(np.logical_or(ma < min_cut_threshold * np.ma.median(ma), ma > max_cut_threshold * np.ma.median(ma)), ma)\n    else:\n        return np.ma.masked_where(ma < min_cut_threshold * np.ma.median(ma), ma)", "response": "Takes the hit array and masks all pixels with a certain occupancy."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate a correction factor for a single hit cluster at the given GDACs from the cluster_size_histogram via cubic interpolation.", "response": "def get_hit_rate_correction(gdacs, calibration_gdacs, cluster_size_histogram):\n    '''Calculates a correction factor for single hit clusters at the given GDACs from the cluster_size_histogram via cubic interpolation.\n\n    Parameters\n    ----------\n    gdacs : array like\n        The GDAC settings where the threshold should be determined from the calibration\n    calibration_gdacs : array like\n        GDAC settings used during the source scan for the cluster size calibration.\n    cluster_size_histogram : numpy.array, shape=(80,336,# of GDACs during calibration)\n        The calibration array\n\n    Returns\n    -------\n    numpy.array, shape=(80,336,# of GDACs during calibration)\n        The threshold values for each pixel at gdacs.\n    '''\n    logging.info('Calculate the correction factor for the single hit cluster rate at %d given GDAC settings', len(gdacs))\n    if len(calibration_gdacs) != cluster_size_histogram.shape[0]:\n        raise ValueError('Length of the provided pixel GDACs does not match the dimension of the cluster size array')\n    hist_sum = np.sum(cluster_size_histogram, axis=1)\n    hist_rel = cluster_size_histogram / hist_sum[:, np.newaxis].astype('f4') * 100.\n    maximum_rate = np.amax(hist_rel[:, 1])\n    correction_factor = maximum_rate / hist_rel[:, 1]\n    # sort arrays since interpolate does not work otherwise\n    calibration_gdacs_sorted = np.array(calibration_gdacs)\n    correction_factor_sorted = correction_factor[np.argsort(calibration_gdacs_sorted)]\n    calibration_gdacs_sorted = np.sort(calibration_gdacs_sorted)\n    interpolation = interp1d(calibration_gdacs_sorted.tolist(), correction_factor_sorted.tolist(), kind='cubic', bounds_error=True)\n    return interpolation(gdacs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the mean threshold from the threshold calibration at the given gdac settings.", "response": "def get_mean_threshold_from_calibration(gdac, mean_threshold_calibration):\n    '''Calculates the mean threshold from the threshold calibration at the given gdac settings. If the given gdac value was not used during caluibration\n    the value is determined by interpolation.\n\n    Parameters\n    ----------\n    gdacs : array like\n        The GDAC settings where the threshold should be determined from the calibration\n    mean_threshold_calibration : pytable\n        The table created during the calibration scan.\n\n    Returns\n    -------\n    numpy.array, shape=(len(gdac), )\n        The mean threshold values at each value in gdacs.\n    '''\n    interpolation = interp1d(mean_threshold_calibration['parameter_value'], mean_threshold_calibration['mean_threshold'], kind='slinear', bounds_error=True)\n    return interpolation(gdac)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_pixel_thresholds_from_calibration_array(gdacs, calibration_gdacs, threshold_calibration_array, bounds_error=True):\n    '''Calculates the threshold for all pixels in threshold_calibration_array at the given GDAC settings via linear interpolation. The GDAC settings used during calibration have to be given.\n\n    Parameters\n    ----------\n    gdacs : array like\n        The GDAC settings where the threshold should be determined from the calibration\n    calibration_gdacs : array like\n        GDAC settings used during calibration, needed to translate the index of the calibration array to a value.\n    threshold_calibration_array : numpy.array, shape=(80,336,# of GDACs during calibration)\n        The calibration array\n\n    Returns\n    -------\n    numpy.array, shape=(80,336,# gdacs given)\n        The threshold values for each pixel at gdacs.\n    '''\n    if len(calibration_gdacs) != threshold_calibration_array.shape[2]:\n        raise ValueError('Length of the provided pixel GDACs does not match the third dimension of the calibration array')\n    interpolation = interp1d(x=calibration_gdacs, y=threshold_calibration_array, kind='slinear', bounds_error=bounds_error)\n    return interpolation(gdacs)", "response": "Calculates the threshold for all pixels in threshold_calibration_array at the given GDACs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_n_cluster_per_event_hist(cluster_table):\n    '''Calculates the number of cluster in every event.\n\n    Parameters\n    ----------\n    cluster_table : pytables.table\n\n    Returns\n    -------\n    numpy.Histogram\n    '''\n    logging.info(\"Histogram number of cluster per event\")\n    cluster_in_events = analysis_utils.get_n_cluster_in_events(cluster_table)[:, 1]  # get the number of cluster for every event\n    return np.histogram(cluster_in_events, bins=range(0, np.max(cluster_in_events) + 2))", "response": "Calculates the number of cluster in every event."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding contiguous True regions of the array condition. Returns a 2D array where first column is the start index and second column is the end index.", "response": "def contiguous_regions(condition):\n    \"\"\"Finds contiguous True regions of the boolean array \"condition\". Returns\n    a 2D array where the first column is the start index of the region and the\n    second column is the end index.\n    http://stackoverflow.com/questions/4494404/find-large-number-of-consecutive-values-fulfilling-condition-in-a-numpy-array\n    \"\"\"\n    # Find the indicies of changes in \"condition\"\n    d = np.diff(condition, n=1)\n    idx, = d.nonzero()\n\n    # We need to start things after the change in \"condition\". Therefore,\n    # we'll shift the index by 1 to the right.\n    idx += 1\n\n    if condition[0]:\n        # If the start of condition is True prepend a 0\n        idx = np.r_[0, idx]\n\n    if condition[-1]:\n        # If the end of condition is True, append the length of the array\n        idx = np.r_[idx, condition.size]\n\n    # Reshape the result into two columns\n    idx.shape = (-1, 2)\n    return idx"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck FEI4 raw data array for corrupted data.", "response": "def check_bad_data(raw_data, prepend_data_headers=None, trig_count=None):\n    \"\"\"Checking FEI4 raw data array for corrupted data.\n    \"\"\"\n    consecutive_triggers = 16 if trig_count == 0 else trig_count\n    is_fe_data_header = logical_and(is_fe_word, is_data_header)\n    trigger_idx = np.where(is_trigger_word(raw_data) >= 1)[0]\n    fe_dh_idx = np.where(is_fe_data_header(raw_data) >= 1)[0]\n    n_triggers = trigger_idx.shape[0]\n    n_dh = fe_dh_idx.shape[0]\n\n    # get index of the last trigger\n    if n_triggers:\n        last_event_data_headers_cnt = np.where(fe_dh_idx > trigger_idx[-1])[0].shape[0]\n        if consecutive_triggers and last_event_data_headers_cnt == consecutive_triggers:\n            if not np.all(trigger_idx[-1] > fe_dh_idx):\n                trigger_idx = np.r_[trigger_idx, raw_data.shape]\n            last_event_data_headers_cnt = None\n        elif last_event_data_headers_cnt != 0:\n            fe_dh_idx = fe_dh_idx[:-last_event_data_headers_cnt]\n        elif not np.all(trigger_idx[-1] > fe_dh_idx):\n            trigger_idx = np.r_[trigger_idx, raw_data.shape]\n    # if any data header, add trigger for histogramming, next readout has to have trigger word\n    elif n_dh:\n        trigger_idx = np.r_[trigger_idx, raw_data.shape]\n        last_event_data_headers_cnt = None\n    # no trigger, no data header\n    # assuming correct data, return input values\n    else:\n        return False, prepend_data_headers, n_triggers, n_dh\n\n#     # no triggers, check for the right amount of data headers\n#     if consecutive_triggers and prepend_data_headers and prepend_data_headers + n_dh != consecutive_triggers:\n#         return True, n_dh, n_triggers, n_dh\n\n    n_triggers_cleaned = trigger_idx.shape[0]\n    n_dh_cleaned = fe_dh_idx.shape[0]\n\n    # check that trigger comes before data header\n    if prepend_data_headers is None and n_triggers_cleaned and n_dh_cleaned and not trigger_idx[0] < fe_dh_idx[0]:\n        return True, last_event_data_headers_cnt, n_triggers, n_dh  # FIXME: 0?\n    # check that no trigger comes before the first data header\n    elif consecutive_triggers and prepend_data_headers is not None and n_triggers_cleaned and n_dh_cleaned and trigger_idx[0] < fe_dh_idx[0]:\n        return True, last_event_data_headers_cnt, n_triggers, n_dh  # FIXME: 0?\n    # check for two consecutive triggers\n    elif consecutive_triggers is None and prepend_data_headers == 0 and n_triggers_cleaned and n_dh_cleaned and trigger_idx[0] < fe_dh_idx[0]:\n        return True, last_event_data_headers_cnt, n_triggers, n_dh  # FIXME: 0?\n    elif prepend_data_headers is not None:\n        trigger_idx += (prepend_data_headers + 1)\n        fe_dh_idx += (prepend_data_headers + 1)\n        # for histogramming add trigger at index 0\n        trigger_idx = np.r_[0, trigger_idx]\n        fe_dh_idx = np.r_[range(1, prepend_data_headers + 1), fe_dh_idx]\n\n    event_hist, bins = np.histogram(fe_dh_idx, trigger_idx)\n    if consecutive_triggers is None and np.any(event_hist == 0):\n        return True, last_event_data_headers_cnt, n_triggers, n_dh\n    elif consecutive_triggers and np.any(event_hist != consecutive_triggers):\n        return True, last_event_data_headers_cnt, n_triggers, n_dh\n\n    return False, last_event_data_headers_cnt, n_triggers, n_dh"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef consecutive(data, stepsize=1):\n    return np.split(data, np.where(np.diff(data) != stepsize)[0] + 1)", "response": "Converts array into chunks with consecutive elements of given step size."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef print_raw_data_file(input_file, start_index=0, limit=200, flavor='fei4b', select=None, tdc_trig_dist=False, trigger_data_mode=0, meta_data_v2=True):\n    with tb.open_file(input_file + '.h5', mode=\"r\") as file_h5:\n        if meta_data_v2:\n            index_start = file_h5.root.meta_data.read(field='index_start')\n            index_stop = file_h5.root.meta_data.read(field='index_stop')\n        else:\n            index_start = file_h5.root.meta_data.read(field='start_index')\n            index_stop = file_h5.root.meta_data.read(field='stop_index')\n        total_words = 0\n        for read_out_index, (index_start, index_stop) in enumerate(np.column_stack((index_start, index_stop))):\n            if start_index < index_stop:\n                print \"\\nchunk %d with length %d (from index %d to %d)\\n\" % (read_out_index, (index_stop - index_start), index_start, index_stop)\n                raw_data = file_h5.root.raw_data.read(index_start, index_stop)\n                total_words += print_raw_data(raw_data=raw_data, start_index=max(start_index - index_start, 0), limit=limit - total_words, flavor=flavor, index_offset=index_start, select=select, tdc_trig_dist=tdc_trig_dist, trigger_data_mode=trigger_data_mode)\n                if limit and total_words >= limit:\n                    break", "response": "Print FEI4 raw data from a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_raw_data(raw_data, start_index=0, limit=200, flavor='fei4b', index_offset=0, select=None, tdc_trig_dist=False, trigger_data_mode=0):\n    if not select:\n        select = ['DH', 'TW', \"AR\", \"VR\", \"SR\", \"DR\", 'TDC', 'UNKNOWN FE WORD', 'UNKNOWN WORD']\n    total_words = 0\n    for index in range(start_index, raw_data.shape[0]):\n        dw = FEI4Record(raw_data[index], chip_flavor=flavor, tdc_trig_dist=tdc_trig_dist, trigger_data_mode=trigger_data_mode)\n        if dw in select:\n            print index + index_offset, '{0:12d} {1:08b} {2:08b} {3:08b} {4:08b}'.format(raw_data[index], (raw_data[index] & 0xFF000000) >> 24, (raw_data[index] & 0x00FF0000) >> 16, (raw_data[index] & 0x0000FF00) >> 8, (raw_data[index] & 0x000000FF) >> 0), dw\n            total_words += 1\n            if limit and total_words >= limit:\n                break\n    return total_words", "response": "Print FEI4 raw data array for debugging."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, pbar):\n        'Updates the widget to show the ETA or total time when finished.'\n        self.n_refresh += 1\n        if pbar.currval == 0:\n            return 'ETA:  --:--:--'\n        elif pbar.finished:\n            return 'Time: %s' % self.format_time(pbar.seconds_elapsed)\n        else:\n            elapsed = pbar.seconds_elapsed\n            try:\n                speed = pbar.currval / elapsed\n                if self.speed_smooth is not None:\n                    self.speed_smooth = (self.speed_smooth * (1 - self.SMOOTHING)) + (speed * self.SMOOTHING)\n                else:\n                    self.speed_smooth = speed\n                eta = float(pbar.maxval) / self.speed_smooth - elapsed + 1 if float(pbar.maxval) / self.speed_smooth - elapsed + 1 > 0 else 0\n\n                if float(pbar.currval) / pbar.maxval > 0.30 or self.n_refresh > 10:  # ETA only rather precise if > 30% is already finished or more than 10 times updated\n                    return 'ETA:  %s' % self.format_time(eta)\n                if self.old_eta is not None and self.old_eta < eta:  # do not show jumping ETA if non precise mode is active\n                    return 'ETA: ~%s' % self.format_time(self.old_eta)\n                else:\n                    self.old_eta = eta\n                    return 'ETA: ~%s' % self.format_time(eta)\n            except ZeroDivisionError:\n                speed = 0", "response": "Updates the widget to show the ETA or total time when finished."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_result(x_p, y_p, y_p_e, smoothed_data, smoothed_data_diff, filename=None):\n    ''' Fit spline to the profile histogramed data, differentiate, determine MPV and plot.\n     Parameters\n    ----------\n        x_p, y_p : array like\n            data points (x,y)\n        y_p_e : array like\n            error bars in y\n    '''\n    logging.info('Plot results')\n    plt.close()\n\n    p1 = plt.errorbar(x_p * analysis_configuration['vcal_calibration'], y_p, yerr=y_p_e, fmt='o')  # plot data with error bars\n    p2, = plt.plot(x_p * analysis_configuration['vcal_calibration'], smoothed_data, '-r')  # plot smoothed data\n    factor = np.amax(y_p) / np.amin(smoothed_data_diff) * 1.1\n    p3, = plt.plot(x_p * analysis_configuration['vcal_calibration'], factor * smoothed_data_diff, '-', lw=2)  # plot differentiated data\n    mpv_index = np.argmax(-analysis_utils.smooth_differentiation(x_p, y_p, weigths=1 / y_p_e, order=3, smoothness=analysis_configuration['smoothness'], derivation=1))\n    p4, = plt.plot([x_p[mpv_index] * analysis_configuration['vcal_calibration'], x_p[mpv_index] * analysis_configuration['vcal_calibration']], [0, factor * smoothed_data_diff[mpv_index]], 'k-', lw=2)\n    text = 'MPV ' + str(int(x_p[mpv_index] * analysis_configuration['vcal_calibration'])) + ' e'\n    plt.text(1.01 * x_p[mpv_index] * analysis_configuration['vcal_calibration'], -10. * smoothed_data_diff[mpv_index], text, ha='left')\n    plt.legend([p1, p2, p3, p4], ['data', 'smoothed spline', 'spline differentiation', text], prop={'size': 12}, loc=0)\n    plt.title('\\'Single hit cluster\\'-occupancy for different pixel thresholds')\n    plt.xlabel('Pixel threshold [e]')\n    plt.ylabel('Single hit cluster occupancy [a.u.]')\n    plt.ylim(0, np.amax(y_p) * 1.15)\n    if filename is None:\n        plt.show()\n    else:\n        filename.savefig(plt.gcf())\n    return smoothed_data_diff", "response": "Fit spline to the profile histogramed data and differentiate determine MPV and plot."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates HitOR calibration file from raw data file and plotting of calibration data.", "response": "def create_hitor_calibration(output_filename, plot_pixel_calibrations=False):\r\n    '''Generating HitOr calibration file (_calibration.h5) from raw data file and plotting of calibration data.\r\n\r\n    Parameters\r\n    ----------\r\n    output_filename : string\r\n        Input raw data file name.\r\n    plot_pixel_calibrations : bool, iterable\r\n        If True, genearating additional pixel calibration plots. If list of column and row tuples (from 1 to 80 / 336), print selected pixels.\r\n\r\n    Returns\r\n    -------\r\n    nothing\r\n    '''\r\n    logging.info('Analyze HitOR calibration data and plot results of %s', output_filename)\r\n\r\n    with AnalyzeRawData(raw_data_file=output_filename, create_pdf=True) as analyze_raw_data:  # Interpret the raw data file\r\n        analyze_raw_data.create_occupancy_hist = False  # too many scan parameters to do in ram histogramming\r\n        analyze_raw_data.create_hit_table = True\r\n        analyze_raw_data.create_tdc_hist = True\r\n        analyze_raw_data.align_at_tdc = True  # align events at TDC words, first word of event has to be a tdc word\r\n        analyze_raw_data.interpret_word_table()\r\n        analyze_raw_data.interpreter.print_summary()\r\n        analyze_raw_data.plot_histograms()\r\n\r\n        n_injections = analyze_raw_data.n_injections  # use later\r\n        meta_data = analyze_raw_data.out_file_h5.root.meta_data[:]\r\n        scan_parameters_dict = get_scan_parameter(meta_data)\r\n        inner_loop_parameter_values = scan_parameters_dict[next(reversed(scan_parameters_dict))]  # inner loop parameter name is unknown\r\n        scan_parameter_names = scan_parameters_dict.keys()\r\n#         col_row_combinations = get_unique_scan_parameter_combinations(analyze_raw_data.out_file_h5.root.meta_data[:], scan_parameters=('column', 'row'), scan_parameter_columns_only=True)\r\n\r\n        meta_data_table_at_scan_parameter = get_unique_scan_parameter_combinations(meta_data, scan_parameters=scan_parameter_names)\r\n        scan_parameter_values = get_scan_parameters_table_from_meta_data(meta_data_table_at_scan_parameter, scan_parameter_names)\r\n        event_number_ranges = get_ranges_from_array(meta_data_table_at_scan_parameter['event_number'])\r\n        event_ranges_per_parameter = np.column_stack((scan_parameter_values, event_number_ranges))\r\n        if analyze_raw_data.out_file_h5.root.Hits.nrows == 0:\r\n            raise AnalysisError(\"Found no hits.\")\r\n        hits = analyze_raw_data.out_file_h5.root.Hits[:]\r\n        event_numbers = hits['event_number'].copy()  # create contigous array, otherwise np.searchsorted too slow, http://stackoverflow.com/questions/15139299/performance-of-numpy-searchsorted-is-poor-on-structured-arrays\r\n\r\n        output_filename = os.path.splitext(output_filename)[0]\r\n        with tb.open_file(output_filename + \"_calibration.h5\", mode=\"w\") as calibration_data_file:\r\n            logging.info('Create calibration')\r\n            calibration_data = np.full(shape=(80, 336, len(inner_loop_parameter_values), 4), fill_value=np.nan, dtype='f4')  # result of the calibration is a histogram with col_index, row_index, plsrDAC value, mean discrete tot, rms discrete tot, mean tot from TDC, rms tot from TDC\r\n\r\n            progress_bar = progressbar.ProgressBar(widgets=['', progressbar.Percentage(), ' ', progressbar.Bar(marker='*', left='|', right='|'), ' ', progressbar.AdaptiveETA()], maxval=len(event_ranges_per_parameter), term_width=80)\r\n            progress_bar.start()\r\n\r\n            for index, (actual_scan_parameter_values, event_start, event_stop) in enumerate(event_ranges_per_parameter):\r\n                if event_stop is None:  # happens for the last chunk\r\n                    event_stop = hits[-1]['event_number'] + 1\r\n                array_index = np.searchsorted(event_numbers, np.array([event_start, event_stop]))\r\n                actual_hits = hits[array_index[0]:array_index[1]]\r\n                for item_index, item in enumerate(scan_parameter_names):\r\n                    if item == \"column\":\r\n                        actual_col = actual_scan_parameter_values[item_index]\r\n                    elif item == \"row\":\r\n                        actual_row = actual_scan_parameter_values[item_index]\r\n                    elif item == \"PlsrDAC\":\r\n                        plser_dac = actual_scan_parameter_values[item_index]\r\n                    else:\r\n                        raise ValueError(\"Unknown scan parameter %s\" % item)\r\n\r\n                # Only pixel of actual column/row should be in the actual data chunk but since FIFO is not cleared for each scan step due to speed reasons and there might be noisy pixels this is not always the case\r\n                n_wrong_pixel = np.count_nonzero(np.logical_or(actual_hits['column'] != actual_col, actual_hits['row'] != actual_row))\r\n                if n_wrong_pixel != 0:\r\n                    logging.warning('%d hit(s) from other pixels for scan parameters %s', n_wrong_pixel, ', '.join(['%s=%s' % (name, value) for (name, value) in zip(scan_parameter_names, actual_scan_parameter_values)]))\r\n\r\n                actual_hits = actual_hits[np.logical_and(actual_hits['column'] == actual_col, actual_hits['row'] == actual_row)]  # Only take data from selected pixel\r\n                actual_tdc_hits = actual_hits[(actual_hits['event_status'] & 0b0000111110011100) == 0b0000000100000000]  # only take hits from good events (one TDC word only, no error)\r\n                actual_tot_hits = actual_hits[(actual_hits['event_status'] & 0b0000100010011100) == 0b0000000000000000]  # only take hits from good events for tot\r\n                tot, tdc = actual_tot_hits['tot'], actual_tdc_hits['TDC']\r\n\r\n                if tdc.shape[0] < n_injections:\r\n                    logging.info('%d of %d expected TDC hits for scan parameters %s', tdc.shape[0], n_injections, ', '.join(['%s=%s' % (name, value) for (name, value) in zip(scan_parameter_names, actual_scan_parameter_values)]))\r\n                if tot.shape[0] < n_injections:\r\n                    logging.info('%d of %d expected hits for scan parameters %s', tot.shape[0], n_injections, ', '.join(['%s=%s' % (name, value) for (name, value) in zip(scan_parameter_names, actual_scan_parameter_values)]))\r\n\r\n                inner_loop_scan_parameter_index = np.where(plser_dac == inner_loop_parameter_values)[0][0]  # translate the scan parameter value to an index for the result histogram\r\n                # numpy mean and std return nan if array is empty\r\n                calibration_data[actual_col - 1, actual_row - 1, inner_loop_scan_parameter_index, 0] = np.mean(tot)\r\n                calibration_data[actual_col - 1, actual_row - 1, inner_loop_scan_parameter_index, 1] = np.mean(tdc)\r\n                calibration_data[actual_col - 1, actual_row - 1, inner_loop_scan_parameter_index, 2] = np.std(tot)\r\n                calibration_data[actual_col - 1, actual_row - 1, inner_loop_scan_parameter_index, 3] = np.std(tdc)\r\n\r\n                progress_bar.update(index)\r\n            progress_bar.finish()\r\n\r\n            calibration_data_out = calibration_data_file.create_carray(calibration_data_file.root, name='HitOrCalibration', title='Hit OR calibration data', atom=tb.Atom.from_dtype(calibration_data.dtype), shape=calibration_data.shape, filters=tb.Filters(complib='blosc', complevel=5, fletcher32=False))\r\n            calibration_data_out[:] = calibration_data\r\n            calibration_data_out.attrs.dimensions = scan_parameter_names\r\n            calibration_data_out.attrs.scan_parameter_values = inner_loop_parameter_values\r\n            calibration_data_out.flush()\r\n#             with PdfPages(output_filename + \"_calibration.pdf\") as output_pdf:\r\n            plot_scurves(calibration_data[:, :, :, 0], inner_loop_parameter_values, \"ToT calibration\", \"ToT\", 15, \"Charge [PlsrDAC]\", filename=analyze_raw_data.output_pdf)\r\n            plot_scurves(calibration_data[:, :, :, 1], inner_loop_parameter_values, \"TDC calibration\", \"TDC [ns]\", None, \"Charge [PlsrDAC]\", filename=analyze_raw_data.output_pdf)\r\n            tot_mean_all_pix = np.nanmean(calibration_data[:, :, :, 0], axis=(0, 1))\r\n            tot_error_all_pix = np.nanstd(calibration_data[:, :, :, 0], axis=(0, 1))\r\n            tdc_mean_all_pix = np.nanmean(calibration_data[:, :, :, 1], axis=(0, 1))\r\n            tdc_error_all_pix = np.nanstd(calibration_data[:, :, :, 1], axis=(0, 1))\r\n            plot_tot_tdc_calibration(scan_parameters=inner_loop_parameter_values, tot_mean=tot_mean_all_pix, tot_error=tot_error_all_pix, tdc_mean=tdc_mean_all_pix, tdc_error=tdc_error_all_pix, filename=analyze_raw_data.output_pdf, title=\"Mean charge calibration of %d pixel(s)\" % np.count_nonzero(~np.all(np.isnan(calibration_data[:, :, :, 0]), axis=2)))\r\n            # plotting individual pixels\r\n            if plot_pixel_calibrations is True:\r\n                # selecting pixels with non-nan entries\r\n                col_row_non_nan = np.nonzero(~np.all(np.isnan(calibration_data[:, :, :, 0]), axis=2))\r\n                plot_pixel_calibrations = np.dstack(col_row_non_nan)[0]\r\n            elif plot_pixel_calibrations is False:\r\n                plot_pixel_calibrations = np.array([], dtype=np.int)\r\n            else:  # assuming list of column / row tuples\r\n                plot_pixel_calibrations = np.array(plot_pixel_calibrations) - 1\r\n            # generate index array\r\n            pixel_indices = np.arange(plot_pixel_calibrations.shape[0])\r\n            plot_n_pixels = 10  # number of pixels at the beginning, center and end of the array\r\n            np.random.seed(0)\r\n            # select random pixels\r\n            if pixel_indices.size - 2 * plot_n_pixels >= 0:\r\n                random_pixel_indices = np.sort(np.random.choice(pixel_indices[plot_n_pixels:-plot_n_pixels], min(plot_n_pixels, pixel_indices.size - 2 * plot_n_pixels), replace=False))\r\n            else:\r\n                random_pixel_indices = np.array([], dtype=np.int)\r\n            selected_pixel_indices = np.unique(np.hstack([pixel_indices[:plot_n_pixels], random_pixel_indices, pixel_indices[-plot_n_pixels:]]))\r\n            # plotting individual pixels\r\n            for (column, row) in plot_pixel_calibrations[selected_pixel_indices]:\r\n                logging.info(\"Plotting charge calibration for pixel column \" + str(column + 1) + \" / row \" + str(row + 1))\r\n                tot_mean_single_pix = calibration_data[column, row, :, 0]\r\n                tot_std_single_pix = calibration_data[column, row, :, 2]\r\n                tdc_mean_single_pix = calibration_data[column, row, :, 1]\r\n                tdc_std_single_pix = calibration_data[column, row, :, 3]\r\n                plot_tot_tdc_calibration(scan_parameters=inner_loop_parameter_values, tot_mean=tot_mean_single_pix, tot_error=tot_std_single_pix, tdc_mean=tdc_mean_single_pix, tdc_error=tdc_std_single_pix, filename=analyze_raw_data.output_pdf, title=\"Charge calibration for pixel column \" + str(column + 1) + \" / row \" + str(row + 1))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a run status mail with the traceback to a specified E - Mail address.", "response": "def send_mail(subject, body, smtp_server, user, password, from_addr, to_addrs):\n    ''' Sends a run status mail with the traceback to a specified E-Mail address if a run crashes.\n    '''\n    logging.info('Send status E-Mail (' + subject + ')')\n    content = string.join((\n        \"From: %s\" % from_addr,\n        \"To: %s\" % ','.join(to_addrs),  # comma separated according to RFC822\n        \"Subject: %s\" % subject,\n        \"\",\n        body),\n        \"\\r\\n\")\n    server = smtplib.SMTP_SSL(smtp_server)\n    server.login(user, password)\n    server.sendmail(from_addr, to_addrs, content)\n    server.quit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_module_cfgs(self):\n        ''' Extracts the configuration of the modules.\n        '''\n        # Adding here default run config parameters.\n        if \"dut\" not in self._conf or self._conf[\"dut\"] is None:\n            raise ValueError('Parameter \"dut\" not defined.')\n        if \"dut_configuration\" not in self._conf or self._conf[\"dut_configuration\"] is None:\n            raise ValueError('Parameter \"dut_configuration\" not defined.')\n        self._conf.setdefault('working_dir', None)  # string, if None, absolute path of configuration.yaml file will be used\n\n        if 'modules' in self._conf and self._conf['modules']:\n            for module_id, module_cfg in [(key, value) for key, value in self._conf['modules'].items() if (\"activate\" not in value or (\"activate\" in value and value[\"activate\"] is True))]:\n                # Check here for missing module config items.\n                # Capital letter keys are Basil drivers, other keys are parameters.\n                # FIFO, RX, TX, TLU and TDC are generic driver names which are used in the scan implementations.\n                # The use of these reserved driver names allows for abstraction.\n                # Accessing Basil drivers with real name is still possible.\n                if \"module_group\" in module_id:\n                    raise ValueError('The module ID \"%s\" contains the reserved name \"module_group\".' % module_id)\n                if \"flavor\" not in module_cfg or module_cfg[\"flavor\"] is None:\n                    raise ValueError('No parameter \"flavor\" defined for module \"%s\".' % module_id)\n                if module_cfg[\"flavor\"] in fe_flavors:\n                    for driver_name in _reserved_driver_names:\n                        # TDC is not mandatory\n                        if driver_name == \"TDC\":\n                            # TDC is allowed to have set None\n                            module_cfg.setdefault('TDC', None)\n                            continue\n                        if driver_name not in module_cfg or module_cfg[driver_name] is None:\n                            raise ValueError('No parameter \"%s\" defined for module \"%s\".' % (driver_name, module_id))\n                    if \"rx_channel\" not in module_cfg or module_cfg[\"rx_channel\"] is None:\n                        raise ValueError('No parameter \"rx_channel\" defined for module \"%s\".' % module_id)\n                    if \"tx_channel\" not in module_cfg or module_cfg[\"tx_channel\"] is None:\n                        raise ValueError('No parameter \"tx_channel\" defined for module \"%s\".' % module_id)\n                    if \"chip_address\" not in module_cfg:\n                        raise ValueError('No parameter \"chip_address\" defined for module \"%s\".' % module_id)\n                    module_cfg.setdefault(\"tdc_channel\", None)\n                    module_cfg.setdefault(\"configuration\", None)  # string or number, if None, using the last valid configuration\n                    module_cfg.setdefault(\"send_data\", None)  # address string of PUB socket\n                    module_cfg.setdefault(\"activate\", True)  # set module active by default\n                    # Save config to dict.\n                    self._module_cfgs[module_id] = module_cfg\n                    self._modules[module_id] = [module_id]\n        else:\n            raise ValueError(\"No module configuration specified\")", "response": "Extracts the configuration of the modules."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the default parameters if they are not specified.", "response": "def _set_default_cfg(self):\n        ''' Sets the default parameters if they are not specified.\n        '''\n        # adding special conf for accessing all DUT drivers\n        self._module_cfgs[None] = {\n            'flavor': None,\n            'chip_address': None,\n            'FIFO': list(set([self._module_cfgs[module_id]['FIFO'] for module_id in self._modules])),\n            'RX': list(set([self._module_cfgs[module_id]['RX'] for module_id in self._modules])),\n            'rx_channel': list(set([self._module_cfgs[module_id]['rx_channel'] for module_id in self._modules])),\n            'TX': list(set([self._module_cfgs[module_id]['TX'] for module_id in self._modules])),\n            'tx_channel': list(set([self._module_cfgs[module_id]['tx_channel'] for module_id in self._modules])),\n            'TDC': list(set([self._module_cfgs[module_id]['TDC'] for module_id in self._modules])),\n            'tdc_channel': list(set([self._module_cfgs[module_id]['tdc_channel'] for module_id in self._modules])),\n            'TLU': list(set([self._module_cfgs[module_id]['TLU'] for module_id in self._modules])),\n            'configuration': None,\n            'send_data': None}\n\n        tx_groups = groupby_dict({key: value for (key, value) in self._module_cfgs.items() if key in self._modules}, \"TX\")\n        for tx, module_group in tx_groups.items():\n            flavors = list(set([module_cfg['flavor'] for module_id, module_cfg in self._module_cfgs.items() if module_id in module_group]))\n            if len(flavors) != 1:\n                raise ValueError(\"Parameter 'flavor' must be the same for module group TX=%s.\" % tx)\n\n            chip_addresses = list(set([module_cfg['chip_address'] for module_id, module_cfg in self._module_cfgs.items() if module_id in module_group]))\n            if len(module_group) != len(chip_addresses) or (len(module_group) != 1 and None in chip_addresses):\n                raise ValueError(\"Parameter 'chip_address' must be different for each module in module group TX=%s.\" % tx)\n\n            # Adding broadcast config for parallel mode.\n            self._module_cfgs[\"module_group_TX=\" + tx] = {\n                'flavor': flavors[0],\n                'chip_address': None,  # broadcast\n                'FIFO': list(set([module_cfg['FIFO'] for module_id, module_cfg in self._module_cfgs.items() if module_id in module_group])),\n                'RX': list(set([module_cfg['RX'] for module_id, module_cfg in self._module_cfgs.items() if module_id in module_group])),\n                'rx_channel': list(set([module_cfg['rx_channel'] for module_id, module_cfg in self._module_cfgs.items() if module_id in module_group])),\n                'TX': tx,\n                'tx_channel': list(set([module_cfg['tx_channel'] for module_id, module_cfg in self._module_cfgs.items() if module_id in module_group])),\n                'TDC': list(set([module_cfg['TDC'] for module_id, module_cfg in self._module_cfgs.items() if module_id in module_group])),\n                'tdc_channel': list(set([module_cfg['tdc_channel'] for module_id, module_cfg in self._module_cfgs.items() if module_id in module_group])),\n                'TLU': list(set([module_cfg['TLU'] for module_id, module_cfg in self._module_cfgs.items() if module_id in module_group])),\n                'configuration': None,\n                'send_data': None}\n            self._tx_module_groups[\"module_group_TX=\" + tx] = module_group\n\n        # Setting up per module attributes\n        self._module_attr = {key: {} for key in self._module_cfgs}\n        # Setting up per module run conf\n        for module_id in self._module_cfgs:\n            sc = namedtuple('run_configuration', field_names=self._default_run_conf.keys())\n            run_conf = sc(**self._run_conf)\n            if module_id in self._modules and self.__class__.__name__ in self._conf[\"modules\"][module_id] and self._conf[\"modules\"][module_id][self.__class__.__name__] is not None:\n                self._module_run_conf[module_id] = run_conf._replace(**self._conf[\"modules\"][module_id][self.__class__.__name__])._asdict()\n            else:\n                self._module_run_conf[module_id] = run_conf._asdict()\n                # update module group with run specific configuration\n                if module_id in self._tx_module_groups and self._tx_module_groups[module_id]:\n                    selected_module_id = self._tx_module_groups[module_id][0]\n                    if self.__class__.__name__ in self._conf[\"modules\"][selected_module_id] and self._conf[\"modules\"][selected_module_id][self.__class__.__name__] is not None:\n                        self._module_run_conf[module_id] = run_conf._replace(**self._conf[\"modules\"][selected_module_id][self.__class__.__name__])._asdict()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_modules(self):\n        ''' Initialize all modules consecutively'''\n        for module_id, module_cfg in self._module_cfgs.items():\n            if module_id in self._modules or module_id in self._tx_module_groups:\n                if module_id in self._modules:\n                    module_id_str = \"module \" + module_id\n                else:\n                    module_id_str = module_id.split('=', 1)\n                    module_id_str[0] = module_id_str[0].replace(\"_\", \" \")\n                    module_id_str = \"=\".join(module_id_str)\n                logging.info(\"Initializing configuration for %s...\" % module_id_str)\n                # adding scan parameters to dict\n                if 'scan_parameters' in self._module_run_conf[module_id] and self._module_run_conf[module_id]['scan_parameters'] is not None:\n                    # evaluating string for support of nested lists and other complex data structures\n                    if isinstance(self._module_run_conf[module_id]['scan_parameters'], basestring):\n                        self._module_run_conf[module_id]['scan_parameters'] = ast.literal_eval(self._module_run_conf[module_id]['scan_parameters'])\n                    sp = namedtuple('scan_parameters', field_names=zip(*self._module_run_conf[module_id]['scan_parameters'])[0])\n                    self._scan_parameters[module_id] = sp(*zip(*self._module_run_conf[module_id]['scan_parameters'])[1])\n                else:\n                    sp = namedtuple_with_defaults('scan_parameters', field_names=[])\n                    self._scan_parameters[module_id] = sp()\n                # init FE config\n                if module_id in self._modules:\n                    # only real modules can have an existing configuration\n                    last_configuration = self.get_configuration(module_id=module_id)\n                else:\n                    last_configuration = None\n                if (('configuration' not in module_cfg or module_cfg['configuration'] is None) and last_configuration is None) or (isinstance(module_cfg['configuration'], (int, long)) and module_cfg['configuration'] <= 0):\n                    if 'chip_address' in module_cfg:\n                        if module_cfg['chip_address'] is None:\n                            chip_address = 0\n                            broadcast = True\n                        else:\n                            chip_address = module_cfg['chip_address']\n                            broadcast = False\n                    else:\n                        raise ValueError('Parameter \"chip_address\" not specified for module \"%s\".' % module_id)\n                    if 'flavor' in module_cfg and module_cfg['flavor']:\n                        module_cfg['configuration'] = FEI4Register(fe_type=module_cfg['flavor'], chip_address=chip_address, broadcast=broadcast)\n                    else:\n                        raise ValueError('Parameter \"flavor\" not specified for module \"%s\".' % module_id)\n                # use existing config\n                elif not module_cfg['configuration'] and last_configuration:\n                    module_cfg['configuration'] = FEI4Register(configuration_file=last_configuration)\n                # path string\n                elif isinstance(module_cfg['configuration'], basestring):\n                    if os.path.isabs(module_cfg['configuration']):  # absolute path\n                        module_cfg['configuration'] = FEI4Register(configuration_file=module_cfg['configuration'])\n                    else:  # relative path\n                        module_cfg['configuration'] = FEI4Register(configuration_file=os.path.join(module_cfg['working_dir'], module_cfg['configuration']))\n                # run number\n                elif isinstance(module_cfg['configuration'], (int, long)) and module_cfg['configuration'] > 0:\n                    module_cfg['configuration'] = FEI4Register(configuration_file=self.get_configuration(module_id=module_id, run_number=module_cfg['configuration']))\n                # assume configuration already initialized\n                elif not isinstance(module_cfg['configuration'], FEI4Register):\n                    raise ValueError('Found no valid value for parameter \"configuration\" for module \"%s\".' % module_id)\n\n                # init register utils\n                self._registers[module_id] = self._module_cfgs[module_id]['configuration']\n                self._register_utils[module_id] = FEI4RegisterUtils(self._module_dut[module_id], self._module_cfgs[module_id]['configuration'])\n\n                if module_id in self._modules:\n                    # Create module data path for real modules\n                    module_path = self.get_module_path(module_id)\n                    if not os.path.exists(module_path):\n                        os.makedirs(module_path)\n\n        # Set all modules to conf mode to prevent from receiving BCR and ECR broadcast\n        for module_id in self._tx_module_groups:\n            with self.access_module(module_id=module_id):\n                self.register_utils.set_conf_mode()\n\n        # Initial configuration (reset and configuration) of all modules.\n        # This is done by iterating over each module individually\n        for module_id in self._modules:\n            logging.info(\"Configuring %s...\" % module_id)\n            with self.access_module(module_id=module_id):\n                if self._run_conf['configure_fe']:\n                    self.register_utils.global_reset()\n                    self.register_utils.configure_all()\n                else:\n                    self.register_utils.set_conf_mode()\n                if is_fe_ready(self):\n                    fe_not_ready = False\n                else:\n                    fe_not_ready = True\n                # BCR and ECR might result in RX errors\n                # a reset of the RX and FIFO will happen just before scan()\n                if self._run_conf['reset_fe']:\n                    self.register_utils.reset_bunch_counter()\n                    self.register_utils.reset_event_counter()\n                if fe_not_ready:\n                    # resetting service records must be done once after power up\n                    self.register_utils.reset_service_records()\n                    if not is_fe_ready(self):\n                        logging.warning('Module \"%s\" is not sending any data.' % module_id)\n                # set all modules to conf mode afterwards to be immune to ECR and BCR\n                self.register_utils.set_conf_mode()", "response": "Initialize all modules consecutively"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_run(self):\n        ''' Start runs on all modules sequentially.\n\n        Sets properties to access current module properties.\n        '''\n        if self.broadcast_commands:  # Broadcast FE commands\n            if self.threaded_scan:\n                with ExitStack() as restore_config_stack:\n                    # Configure each FE individually\n                    # Sort module config keys, configure broadcast modules first\n                    for module_id in itertools.chain(self._tx_module_groups, self._modules):\n                        if self.abort_run.is_set():\n                            break\n                        with self.access_module(module_id=module_id):\n                            if module_id in self._modules:\n                                module_id_str = \"module \" + module_id\n                            else:\n                                module_id_str = module_id.split('=', 1)\n                                module_id_str[0] = module_id_str[0].replace(\"_\", \" \")\n                                module_id_str = \"=\".join(module_id_str)\n                            logging.info('Scan parameter(s) for %s: %s', module_id_str, ', '.join(['%s=%s' % (key, value) for (key, value) in self.scan_parameters._asdict().items()]) if self.scan_parameters else 'None')\n                            # storing register values until scan has finished and then restore configuration\n                            restore_config_stack.enter_context(self.register.restored(name=self.run_number))\n                            self.configure()\n                    for module_id in self._tx_module_groups:\n                        if self.abort_run.is_set():\n                            break\n                        with self.access_module(module_id=module_id):\n                            # set all modules to run mode by before entering scan()\n                            self.register_utils.set_run_mode()\n\n                    with self.access_module(module_id=None):\n                        self.fifo_readout.reset_rx()\n                        self.fifo_readout.reset_fifo(self._selected_fifos)\n                        self.fifo_readout.print_fei4_rx_status()\n\n                        with self.access_files():\n                            self._scan_threads = []\n                            for module_id in self._tx_module_groups:\n                                if self.abort_run.is_set():\n                                    break\n                                t = ExcThread(target=self.scan, name=module_id)\n                                t.daemon = True  # exiting program even when thread is alive\n                                self._scan_threads.append(t)\n                            for t in self._scan_threads:\n                                t.start()\n                            while any([t.is_alive() for t in self._scan_threads]):\n#                                 if self.abort_run.is_set():\n#                                     break\n                                for t in self._scan_threads:\n                                    try:\n                                        t.join(0.01)\n                                    except Exception:\n                                        self._scan_threads.remove(t)\n                                        self.handle_err(sys.exc_info())\n#                             alive_threads = [t.name for t in self._scan_threads if (not t.join(10.0) and t.is_alive())]\n#                             if alive_threads:\n#                                 raise RuntimeError(\"Scan thread(s) not finished: %s\" % \", \".join(alive_threads))\n                            self._scan_threads = []\n                for module_id in self._tx_module_groups:\n                    if self.abort_run.is_set():\n                        break\n                    with self.access_module(module_id=module_id):\n                        # set modules to conf mode by after finishing scan()\n                        self.register_utils.set_conf_mode()\n            else:\n                for tx_module_id, tx_group in self._tx_module_groups.items():\n                    if self.abort_run.is_set():\n                        break\n                    with ExitStack() as restore_config_stack:\n                        for module_id in itertools.chain([tx_module_id], tx_group):\n                            if self.abort_run.is_set():\n                                break\n                            with self.access_module(module_id=module_id):\n                                logging.info('Scan parameter(s) for module %s: %s', module_id, ', '.join(['%s=%s' % (key, value) for (key, value) in self.scan_parameters._asdict().items()]) if self.scan_parameters else 'None')\n                                # storing register values until scan has finished and then restore configuration\n                                restore_config_stack.enter_context(self.register.restored(name=self.run_number))\n                                self.configure()\n                        with self.access_module(module_id=tx_module_id):\n                            # set all modules to run mode by before entering scan()\n                            self.register_utils.set_run_mode()\n\n                            self.fifo_readout.reset_rx()\n                            self.fifo_readout.reset_fifo(self._selected_fifos)\n                            self.fifo_readout.print_fei4_rx_status()\n\n                            # some scans use this event to stop scan loop, clear event here to make another scan possible\n                            self.stop_run.clear()\n                            with self.access_files():\n                                self.scan()\n\n                    with self.access_module(module_id=tx_module_id):\n                        # set modules to conf mode by after finishing scan()\n                        self.register_utils.set_conf_mode()\n        else:  # Scan each FE individually\n            if self.threaded_scan:\n                self._scan_threads = []\n                # loop over grpups of modules with different TX\n                for tx_module_ids in zip_nofill(*self._tx_module_groups.values()):\n                    if self.abort_run.is_set():\n                        break\n                    with ExitStack() as restore_config_stack:\n                        for module_id in tx_module_ids:\n                            if self.abort_run.is_set():\n                                break\n                            with self.access_module(module_id=module_id):\n                                logging.info('Scan parameter(s) for module %s: %s', module_id, ', '.join(['%s=%s' % (key, value) for (key, value) in self.scan_parameters._asdict().items()]) if self.scan_parameters else 'None')\n                                # storing register values until scan has finished and then restore configuration\n                                restore_config_stack.enter_context(self.register.restored(name=self.run_number))\n                                self.configure()\n                                # set modules to run mode by before entering scan()\n                                self.register_utils.set_run_mode()\n                            t = ExcThread(target=self.scan, name=module_id)\n                            t.daemon = True  # exiting program even when thread is alive\n                            self._scan_threads.append(t)\n                        with self.access_module(module_id=tx_module_ids):\n                            self.fifo_readout.reset_rx()\n                            self.fifo_readout.reset_fifo(self._selected_fifos)\n                            self.fifo_readout.print_fei4_rx_status()\n\n                            with self.access_files():\n                                # some scans use this event to stop scan loop, clear event here to make another scan possible\n                                self.stop_run.clear()\n                                for t in self._scan_threads:\n                                    t.start()\n                                while any([t.is_alive() for t in self._scan_threads]):\n#                                     if self.abort_run.is_set():\n#                                         break\n                                    for t in self._scan_threads:\n                                        try:\n                                            t.join(0.01)\n                                        except Exception:\n                                            self._scan_threads.remove(t)\n                                            self.handle_err(sys.exc_info())\n#                                 alive_threads = [t.name for t in self._scan_threads if (not t.join(10.0) and t.is_alive())]\n#                                 if alive_threads:\n#                                     raise RuntimeError(\"Scan thread(s) not finished: %s\" % \", \".join(alive_threads))\n                                self._scan_threads = []\n\n                    for module_id in tx_module_ids:\n                        if self.abort_run.is_set():\n                            break\n                        with self.access_module(module_id=module_id):\n                            # set modules to conf mode by after finishing scan()\n                            self.register_utils.set_conf_mode()\n            else:\n                for module_id in self._modules:\n                    if self.abort_run.is_set():\n                        break\n                    # some scans use this event to stop scan loop, clear event here to make another scan possible\n                    self.stop_run.clear()\n                    with self.access_module(module_id=module_id):\n                        logging.info('Scan parameter(s) for module %s: %s', module_id, ', '.join(['%s=%s' % (key, value) for (key, value) in self.scan_parameters._asdict().items()]) if self.scan_parameters else 'None')\n                        with self.register.restored(name=self.run_number):\n                            self.configure()\n                            # set modules to run mode by before entering scan()\n                            self.register_utils.set_run_mode()\n\n                            self.fifo_readout.reset_rx()\n                            self.fifo_readout.reset_fifo(self._selected_fifos)\n                            self.fifo_readout.print_fei4_rx_status()\n\n                            # some scans use this event to stop scan loop, clear event here to make another scan possible\n                            self.stop_run.clear()\n                            with self.access_files():\n                                self.scan()\n                            # set modules to conf mode by after finishing scan()\n                            self.register_utils.set_conf_mode()\n\n        if self._modules:\n            self.fifo_readout.print_readout_status()", "response": "Start runs on all modules sequentially."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef close(self):\n        '''Releasing hardware resources.\n        '''\n        try:\n            self.dut.close()\n        except Exception:\n            logging.warning('Closing DUT was not successful')\n        else:\n            logging.debug('Closed DUT')", "response": "Closes the DUT and releases hardware resources."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle_data(self, data, new_file=False, flush=True):\n        '''Handling of the data.\n\n        Parameters\n        ----------\n        data : list, tuple\n            Data tuple of the format (data (np.array), last_time (float), curr_time (float), status (int))\n        '''\n        for i, module_id in enumerate(self._selected_modules):\n            if data[i] is None:\n                continue\n            self._raw_data_files[module_id].append(data_iterable=data[i], scan_parameters=self._scan_parameters[module_id]._asdict(), new_file=new_file, flush=flush)", "response": "Handling of the data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle_err(self, exc):\n        '''Handling of Exceptions.\n\n        Parameters\n        ----------\n        exc : list, tuple\n            Information of the exception of the format (type, value, traceback).\n            Uses the return value of sys.exc_info().\n        '''\n        if self.reset_rx_on_error and isinstance(exc[1], (RxSyncError, EightbTenbError)):\n            self.fifo_readout.print_readout_status()\n            self.fifo_readout.reset_rx()\n        else:\n            # print just the first error massage\n            if not self.abort_run.is_set():\n                self.abort(msg=exc[1].__class__.__name__ + \": \" + str(exc[1]))\n            self.err_queue.put(exc)", "response": "Handling of Exceptions.\n\n        Parameters\n        ----------\n        exc : list, tuple\n            Information of the exception of the format (type, value, traceback).\n            Uses the return value of sys.exc_info()."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the configuration file for a given module ID and run number.", "response": "def get_configuration(self, module_id, run_number=None):\n        ''' Returns the configuration for a given module ID.\n\n        The working directory is searched for a file matching the module_id with the\n        given run number. If no run number is defined the last successfull run defines\n        the run number.\n        '''\n        def find_file(run_number):\n            module_path = self.get_module_path(module_id)\n            for root, _, files in os.walk(module_path):\n                for cfgfile in files:\n                    cfg_root, cfg_ext = os.path.splitext(cfgfile)\n                    if cfg_root.startswith(''.join([str(run_number), '_', module_id])) and cfg_ext.endswith(\".cfg\"):\n                        return os.path.join(root, cfgfile)\n\n        if not run_number:\n            run_numbers = sorted(self._get_run_numbers(status='FINISHED').keys(), reverse=True)\n            found_fin_run_cfg = True\n            if not run_numbers:\n                return None\n            last_fin_run = run_numbers[0]\n            for run_number in run_numbers:\n                cfg_file = find_file(run_number)\n                if cfg_file:\n                    if not found_fin_run_cfg:\n                        logging.warning(\"Module '%s' has no configuration for run %d, use config of run %d\", module_id, last_fin_run, run_number)\n                    return cfg_file\n                else:\n                    found_fin_run_cfg = False\n        else:\n            cfg_file = find_file(run_number)\n            if cfg_file:\n                return cfg_file\n            else:\n                raise ValueError('Found no configuration with run number %s' % run_number)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nselect module and give access to the module.", "response": "def select_module(self, module_id):\n        ''' Select module and give access to the module.\n        '''\n        if not isinstance(module_id, basestring) and isinstance(module_id, Iterable) and set(module_id) - set(self._modules):\n            raise ValueError('Module IDs invalid:' % \", \".join(set(module_id) - set(self._modules)))\n        if isinstance(module_id, basestring) and module_id not in self._module_cfgs:\n            raise ValueError('Module ID \"%s\" is not valid' % module_id)\n        if self._current_module_handle is not None:\n            raise RuntimeError('Module handle \"%s\" cannot be set because another module is active' % module_id)\n\n        if module_id is None:\n            self._selected_modules = self._modules.keys()\n        elif not isinstance(module_id, basestring) and isinstance(module_id, Iterable):\n            self._selected_modules = module_id\n        elif module_id in self._modules:\n            self._selected_modules = [module_id]\n        elif module_id in self._tx_module_groups:\n            self._selected_modules = self._tx_module_groups[module_id]\n        else:\n            RuntimeError('Cannot open files. Module handle \"%s\" is not valid.' % self.current_module_handle)\n\n        # FIFO readout\n        self._selected_fifos = list(set([module_cfg['FIFO'] for (name, module_cfg) in self._module_cfgs.items() if name in self._selected_modules]))\n\n        # Module filter functions dict for quick lookup\n        self._readout_fifos = []\n        self._filter = []\n        self._converter = []\n        for selected_module_id in self._selected_modules:\n            module_cfg = self._module_cfgs[selected_module_id]\n            self._readout_fifos.append(module_cfg['FIFO'])\n            if 'tdc_channel' not in module_cfg:\n                tdc_filter = false\n                self._converter.append(None)\n            elif module_cfg['tdc_channel'] is None:\n                tdc_filter = is_tdc_word\n                self._converter.append(convert_tdc_to_channel(channel=module_cfg['tdc_channel']))  # for the raw data analyzer\n            else:\n                tdc_filter = logical_and(is_tdc_word, is_tdc_from_channel(module_cfg['tdc_channel']))\n                self._converter.append(convert_tdc_to_channel(channel=module_cfg['tdc_channel']))  # for the raw data analyzer\n            if 'rx_channel' not in module_cfg:\n                self._filter.append(logical_or(is_trigger_word, tdc_filter))\n            elif module_cfg['rx_channel'] is None:\n                self._filter.append(logical_or(is_trigger_word, logical_or(tdc_filter, is_fe_word)))\n            else:\n                self._filter.append(logical_or(is_trigger_word, logical_or(tdc_filter, logical_and(is_fe_word, is_data_from_channel(module_cfg['rx_channel'])))))\n\n        # select readout channels and report sync status only from actively selected modules\n        self._enabled_fe_channels = list(set([config['RX'] for (name, config) in self._module_cfgs.items() if name in self._selected_modules]))\n\n        # enabling specific TX channels\n        tx_channels = list(set([1 << config['tx_channel'] for (name, config) in self._module_cfgs.items() if name in self._selected_modules]))\n        if tx_channels:\n            self.dut['TX']['OUTPUT_ENABLE'] = reduce(lambda x, y: x | y, tx_channels)\n        else:\n            self.dut['TX']['OUTPUT_ENABLE'] = 0\n\n        if not isinstance(module_id, basestring) and isinstance(module_id, Iterable):\n            self._current_module_handle = None\n        else:\n            self._current_module_handle = module_id\n\n        if module_id is not None and isinstance(module_id, basestring):\n            current_thread().name = module_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef deselect_module(self):\n        ''' Deselect module and cleanup.\n        '''\n        self._enabled_fe_channels = []  # ignore any RX sync errors\n        self._readout_fifos = []\n        self._filter = []\n        self._converter = []\n        self.dut['TX']['OUTPUT_ENABLE'] = 0\n        self._current_module_handle = None\n        if isinstance(current_thread(), _MainThread):\n            current_thread().name = \"MainThread\"", "response": "Deselect module and cleanup."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef enter_sync(self):\n        ''' Waiting for all threads to appear, then continue.\n        '''\n        if self._scan_threads and self.current_module_handle not in [t.name for t in self._scan_threads]:\n            raise RuntimeError('Thread name \"%s\" is not valid.')\n        if self._scan_threads and self.current_module_handle in self._curr_sync_threads:\n            raise RuntimeError('Thread \"%s\" is already actively reading FIFO.')\n        with self._sync_lock:\n            self._curr_sync_threads.append(self.current_module_handle)\n        self._enter_sync_event.clear()\n        while not self._enter_sync_event.wait(0.01):\n            if self.abort_run.is_set():\n                break\n            with self._sync_lock:\n                if len(set(self._curr_sync_threads) & set([t.name for t in self._scan_threads if t.is_alive()])) == len(set([t.name for t in self._scan_threads if t.is_alive()])) or not self._scan_threads:\n                    self._enter_sync_event.set()", "response": "Wait for all threads to appear then continue."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef exit_sync(self):\n        ''' Waiting for all threads to appear, then continue.\n        '''\n        if self._scan_threads and self.current_module_handle not in [t.name for t in self._scan_threads]:\n            raise RuntimeError('Thread name \"%s\" is not valid.')\n        if self._scan_threads and self.current_module_handle not in self._curr_sync_threads:\n            raise RuntimeError('Thread \"%s\" is not reading FIFO.')\n        with self._sync_lock:\n            self._curr_sync_threads.remove(self.current_module_handle)\n        self._exit_sync_event.clear()\n        while not self._exit_sync_event.wait(0.01):\n            if self.abort_run.is_set():\n                break\n            with self._sync_lock:\n                if len(set(self._curr_sync_threads) & set([t.name for t in self._scan_threads if t.is_alive()])) == 0 or not self._scan_threads:\n                    self._exit_sync_event.set()", "response": "Waiting for all threads to appear, then continue."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef readout(self, *args, **kwargs):\n        ''' Running the FIFO readout while executing other statements.\n\n        Starting and stopping of the FIFO readout is synchronized between the threads.\n        '''\n        timeout = kwargs.pop('timeout', 10.0)\n        self.start_readout(*args, **kwargs)\n        try:\n            yield\n        finally:\n            try:\n                self.stop_readout(timeout=timeout)\n            except Exception:\n                # in case something fails, call this on last resort\n                # if run was aborted, immediately stop readout\n                if self.abort_run.is_set():\n                    with self._readout_lock:\n                        if self.fifo_readout.is_running:\n                            self.fifo_readout.stop(timeout=0.0)", "response": "A context manager that starts the FIFO readout while executing other statements."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start_readout(self, *args, **kwargs):\n        ''' Starting the FIFO readout.\n\n        Starting of the FIFO readout is executed only once by a random thread.\n        Starting of the FIFO readout is synchronized between all threads reading out the FIFO.\n        '''\n        # Pop parameters for fifo_readout.start\n        callback = kwargs.pop('callback', self.handle_data)\n        errback = kwargs.pop('errback', self.handle_err)\n        reset_rx = kwargs.pop('reset_rx', True)\n        reset_fifo = kwargs.pop('reset_fifo', True)\n        fill_buffer = kwargs.pop('fill_buffer', False)\n        no_data_timeout = kwargs.pop('no_data_timeout', None)\n        enabled_fe_channels = kwargs.pop('enabled_fe_channels', self._enabled_fe_channels)\n        if args or kwargs:\n            self.set_scan_parameters(*args, **kwargs)\n        if self._scan_threads and self.current_module_handle not in [t.name for t in self._scan_threads]:\n            raise RuntimeError('Thread name \"%s\" is not valid.' % t.name)\n        if self._scan_threads and self.current_module_handle in self._curr_readout_threads:\n            raise RuntimeError('Thread \"%s\" is already actively reading FIFO.')\n        with self._readout_lock:\n            self._curr_readout_threads.append(self.current_module_handle)\n        self._starting_readout_event.clear()\n        while not self._starting_readout_event.wait(0.01):\n            if self.abort_run.is_set():\n                break\n            with self._readout_lock:\n                if len(set(self._curr_readout_threads) & set([t.name for t in self._scan_threads if t.is_alive()])) == len(set([t.name for t in self._scan_threads if t.is_alive()])) or not self._scan_threads:\n                    if not self.fifo_readout.is_running:\n                        self.fifo_readout.start(fifos=self._selected_fifos, callback=callback, errback=errback, reset_rx=reset_rx, reset_fifo=reset_fifo, fill_buffer=fill_buffer, no_data_timeout=no_data_timeout, filter_func=self._filter, converter_func=self._converter, fifo_select=self._readout_fifos, enabled_fe_channels=enabled_fe_channels)\n                        self._starting_readout_event.set()", "response": "Start the FIFO readout."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stop_readout(self, timeout=10.0):\n        ''' Stopping the FIFO readout.\n\n        Stopping of the FIFO readout is executed only once by a random thread.\n        Stopping of the FIFO readout is synchronized between all threads reading out the FIFO.\n        '''\n        if self._scan_threads and self.current_module_handle not in [t.name for t in self._scan_threads]:\n            raise RuntimeError('Thread name \"%s\" is not valid.')\n        if self._scan_threads and self.current_module_handle not in self._curr_readout_threads:\n            raise RuntimeError('Thread \"%s\" is not reading FIFO.')\n        with self._readout_lock:\n            self._curr_readout_threads.remove(self.current_module_handle)\n        self._stopping_readout_event.clear()\n        while not self._stopping_readout_event.wait(0.01):\n            with self._readout_lock:\n                if len(set(self._curr_readout_threads) & set([t.name for t in self._scan_threads if t.is_alive()])) == 0 or not self._scan_threads or self.abort_run.is_set():\n                    if self.fifo_readout.is_running:\n                        self.fifo_readout.stop(timeout=timeout)\n                    self._stopping_readout_event.set()", "response": "Stops the FIFO readout."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nopening the hit or calibration file and return the calibration per pixel", "response": "def get_charge_calibration(calibation_file, max_tdc):\n    ''' Open the hit or calibration file and return the calibration per pixel'''\n    with tb.open_file(calibation_file, mode=\"r\") as in_file_calibration_h5:\n        tdc_calibration = in_file_calibration_h5.root.HitOrCalibration[:, :, :, 1]\n        tdc_calibration_values = in_file_calibration_h5.root.HitOrCalibration.attrs.scan_parameter_values[:]\n    return get_charge(max_tdc, tdc_calibration_values, tdc_calibration)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd the Plot pyBAR data. entry to Dataset menu.", "response": "def addEntry(self):\n        \"\"\"Add the `Plot pyBAR data`. entry to `Dataset` menu.\n        \"\"\"\n        export_icon = QtGui.QIcon()\n        pixmap = QtGui.QPixmap(os.path.join(PLUGINSDIR,\n                                            'csv/icons/document-export.png'))\n        export_icon.addPixmap(pixmap, QtGui.QIcon.Normal, QtGui.QIcon.On)\n\n        self.plot_action = QtGui.QAction(\n            translate('PlotpyBARdata',\n                      \"Plot data with pyBAR plugin\",\n                      \"Plot data with pyBAR plugin\"),\n            self,\n            shortcut=QtGui.QKeySequence.UnknownKey, triggered=self.plot,\n            icon=export_icon,\n            statusTip=translate('PlotpyBARdata',\n                                \"Plotting of selected data with pyBAR\",\n                                \"Status bar text for the Dataset -> Plot pyBAR data... action\"))\n\n        # Add the action to the Dataset menu\n        menu = self.vtgui.dataset_menu\n        menu.addSeparator()\n        menu.addAction(self.plot_action)\n\n        # Add the action to the leaf context menu\n        cmenu = self.vtgui.leaf_node_cm\n        cmenu.addSeparator()\n        cmenu.addAction(self.plot_action)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the export QAction when the Dataset menu is pulled down.", "response": "def updateDatasetMenu(self):\n        \"\"\"Update the `export` QAction when the Dataset menu is pulled down.\n\n        This method is a slot. See class ctor for details.\n        \"\"\"\n        enabled = True\n        current = self.vtgui.dbs_tree_view.currentIndex()\n        if current:\n            leaf = self.vtgui.dbs_tree_model.nodeFromIndex(current)\n            if leaf.node_kind in (u'group', u'root group'):\n                enabled = False\n\n        self.plot_action.setEnabled(enabled)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot(self):\n        # The PyTables node tied to the current leaf of the databases tree\n        current = self.vtgui.dbs_tree_view.currentIndex()\n        leaf = self.vtgui.dbs_tree_model.nodeFromIndex(current).node\n\n        data_name = leaf.name\n\n        hists_1d = ['HistRelBcid', 'HistErrorCounter', 'HistTriggerErrorCounter', 'HistServiceRecord', 'HistTot', 'HistTdc', 'HistClusterTot', 'HistClusterSize']\n        hists_2d = ['HistOcc', 'Enable', 'Imon', 'C_High', 'EnableDigInj', 'C_Low', 'FDAC', 'TDAC', 'HistTdcPixel', 'HistTotPixel', 'HistThreshold', 'HistNoise', 'HistThresholdFitted', 'HistNoiseFitted', 'HistThresholdFittedCalib', 'HistNoiseFittedCalib']\n\n        if data_name in hists_1d:\n            plot_1d_hist(hist=leaf[:], title=data_name)\n        elif data_name in hists_2d:\n            if data_name == 'HistOcc':\n                leaf = np.sum(leaf[:], axis=2)\n            plot_2d_hist(hist=leaf[:], title=data_name)\n        elif 'Table' in str(type(leaf)) and len(leaf[:].dtype.names) <= 3:  # detect tables with less than 4 columns\n            plot_table(leaf[:], title=data_name)\n        elif data_name == 'HitOrCalibration':\n            print 'Comming soon'\n        else:\n            print 'Plotting', data_name, '(%s) is not supported!' % type(leaf)", "response": "This method exports a given dataset to a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef helpAbout(self):\n\n        # Text to be displayed\n        about_text = translate('pyBarPlugin',\n                               \"\"\"<qt>\n            <p>Data plotting plug-in for pyBAR.\n            </qt>\"\"\",\n                               'About')\n\n        descr = dict(module_name='pyBarPlugin',\n                     folder=PLUGINSDIR,\n                     version=__version__,\n                     plugin_name='pyBarPlugin',\n                     author='David-Leon Pohl <david-leon.pohl@rub.de>, Jens Janssen <janssen@physik.uni-bonn.de>',\n                     descr=about_text)\n\n        return descr", "response": "Help text for the object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending the config via ZeroMQ to a specified socket.", "response": "def send_meta_data(socket, conf, name):\n    '''Sends the config via ZeroMQ to a specified socket. Is called at the beginning of a run and when the config changes. Conf can be any config dictionary.\n    '''\n    meta_data = dict(\n        name=name,\n        conf=conf\n    )\n    try:\n        socket.send_json(meta_data, flags=zmq.NOBLOCK)\n    except zmq.Again:\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_data(socket, data, scan_parameters={}, name='ReadoutData'):\n    '''Sends the data of every read out (raw data and meta data) via ZeroMQ to a specified socket\n    '''\n    if not scan_parameters:\n        scan_parameters = {}\n    data_meta_data = dict(\n        name=name,\n        dtype=str(data[0].dtype),\n        shape=data[0].shape,\n        timestamp_start=data[1],  # float\n        timestamp_stop=data[2],  # float\n        readout_error=data[3],  # int\n        scan_parameters=scan_parameters  # dict\n    )\n    try:\n        socket.send_json(data_meta_data, flags=zmq.SNDMORE | zmq.NOBLOCK)\n        socket.send(data[0], flags=zmq.NOBLOCK)  # PyZMQ supports sending numpy arrays without copying any data\n    except zmq.Again:\n        pass", "response": "Sends the data of every read out to a specified socket"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite raw data from data queue to file", "response": "def save_raw_data_from_data_queue(data_queue, filename, mode='a', title='', scan_parameters=None):  # mode=\"r+\" to append data, raw_data_file_h5 must exist, \"w\" to overwrite raw_data_file_h5, \"a\" to append data, if raw_data_file_h5 does not exist it is created\n    '''Writing raw data file from data queue\n\n    If you need to write raw data once in a while this function may make it easy for you.\n    '''\n    if not scan_parameters:\n        scan_parameters = {}\n    with open_raw_data_file(filename, mode='a', title='', scan_parameters=list(dict.iterkeys(scan_parameters))) as raw_data_file:\n        raw_data_file.append(data_queue, scan_parameters=scan_parameters)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_linear_relation(x, y, x_err=None, y_err=None, title=None, point_label=None, legend=None, plot_range=None, plot_range_y=None, x_label=None, y_label=None, y_2_label=None, log_x=False, log_y=False, size=None, filename=None):\r\n    ''' Takes point data (x,y) with errors(x,y) and fits a straight line. The deviation to this line is also plotted, showing the offset.\r\n\r\n     Parameters\r\n    ----------\r\n    x, y, x_err, y_err: iterable\r\n\r\n    filename: string, PdfPages object or None\r\n        PdfPages file object: plot is appended to the pdf\r\n        string: new plot file with the given filename is created\r\n        None: the plot is printed to screen\r\n    '''\r\n    fig = Figure()\r\n    FigureCanvas(fig)\r\n    ax = fig.add_subplot(111)\r\n    if x_err is not None:\r\n        x_err = [x_err, x_err]\r\n    if y_err is not None:\r\n        y_err = [y_err, y_err]\r\n    ax.set_title(title)\r\n    if y_label is not None:\r\n        ax.set_ylabel(y_label)\r\n    if log_x:\r\n        ax.set_xscale('log')\r\n    if log_y:\r\n        ax.set_yscale('log')\r\n    if plot_range:\r\n        ax.set_xlim((min(plot_range), max(plot_range)))\r\n    if plot_range_y:\r\n        ax.set_ylim((min(plot_range_y), max(plot_range_y)))\r\n    if legend:\r\n        fig.legend(legend, 0)\r\n    ax.grid(True)\r\n    ax.errorbar(x, y, xerr=x_err, yerr=y_err, fmt='o', color='black')  # plot points\r\n    # label points if needed\r\n    if point_label is not None:\r\n        for X, Y, Z in zip(x, y, point_label):\r\n            ax.annotate('{}'.format(Z), xy=(X, Y), xytext=(-5, 5), ha='right', textcoords='offset points')\r\n    line_fit, _ = np.polyfit(x, y, 1, full=False, cov=True)\r\n    fit_fn = np.poly1d(line_fit)\r\n    ax.plot(x, fit_fn(x), '-', lw=2, color='gray')\r\n    setp(ax.get_xticklabels(), visible=False)  # remove ticks at common border of both plots\r\n\r\n    divider = make_axes_locatable(ax)\r\n    ax_bottom_plot = divider.append_axes(\"bottom\", 2.0, pad=0.0, sharex=ax)\r\n\r\n    ax_bottom_plot.bar(x, y - fit_fn(x), align='center', width=np.amin(np.diff(x)) / 2, color='gray')\r\n#     plot(x, y - fit_fn(x))\r\n    ax_bottom_plot.grid(True)\r\n    if x_label is not None:\r\n        ax.set_xlabel(x_label)\r\n    if y_2_label is not None:\r\n        ax.set_ylabel(y_2_label)\r\n\r\n    ax.set_ylim((-np.amax(np.abs(y - fit_fn(x)))), (np.amax(np.abs(y - fit_fn(x)))))\r\n\r\n    ax.plot(ax.set_xlim(), [0, 0], '-', color='black')\r\n    setp(ax_bottom_plot.get_yticklabels()[-2:-1], visible=False)\r\n\r\n    if size is not None:\r\n        fig.set_size_inches(size)\r\n\r\n    if not filename:\r\n        fig.show()\r\n    elif isinstance(filename, PdfPages):\r\n        filename.savefig(fig)\r\n    elif filename:\r\n        fig.savefig(filename, bbox_inches='tight')\r\n\r\n    return fig", "response": "Plots a linear relation between two data sets."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nplot a 2D histogram of x and y.", "response": "def plot_profile_histogram(x, y, n_bins=100, title=None, x_label=None, y_label=None, log_y=False, filename=None):\r\n    '''Takes 2D point data (x,y) and creates a profile histogram similar to the TProfile in ROOT. It calculates\r\n    the y mean for every bin at the bin center and gives the y mean error as error bars.\r\n\r\n    Parameters\r\n    ----------\r\n    x : array like\r\n        data x positions\r\n    y : array like\r\n        data y positions\r\n    n_bins : int\r\n        the number of bins used to create the histogram\r\n    '''\r\n    if len(x) != len(y):\r\n        raise ValueError('x and y dimensions have to be the same')\r\n    n, bin_edges = np.histogram(x, bins=n_bins)  # needed to calculate the number of points per bin\r\n    sy = np.histogram(x, bins=n_bins, weights=y)[0]  # the sum of the bin values\r\n    sy2 = np.histogram(x, bins=n_bins, weights=y * y)[0]  # the quadratic sum of the bin values\r\n    bin_centers = (bin_edges[1:] + bin_edges[:-1]) / 2  # calculate the bin center for all bins\r\n    mean = sy / n  # calculate the mean of all bins\r\n    std = np.sqrt((sy2 / n - mean * mean))  # TODO: not understood, need check if this is really the standard deviation\r\n    #     std_mean = np.sqrt((sy2 - 2 * mean * sy + mean * mean) / (1*(n - 1)))  # this should be the formular ?!\r\n    std_mean = std / np.sqrt((n - 1))\r\n    mean[np.isnan(mean)] = 0.0\r\n    std_mean[np.isnan(std_mean)] = 0.0\r\n\r\n    fig = Figure()\r\n    FigureCanvas(fig)\r\n    ax = fig.add_subplot(111)\r\n    ax.errorbar(bin_centers, mean, yerr=std_mean, fmt='o')\r\n    ax.set_title(title)\r\n    if x_label is not None:\r\n        ax.set_xlabel(x_label)\r\n    if y_label is not None:\r\n        ax.set_ylabel(y_label)\r\n    if log_y:\r\n        ax.yscale('log')\r\n    ax.grid(True)\r\n    if not filename:\r\n        fig.show()\r\n    elif isinstance(filename, PdfPages):\r\n        filename.savefig(fig)\r\n    else:\r\n        fig.savefig(filename)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef round_to_multiple(number, multiple):\r\n    '''Rounding up to the nearest multiple of any positive integer\r\n\r\n    Parameters\r\n    ----------\r\n    number : int, float\r\n        Input number.\r\n    multiple : int\r\n        Round up to multiple of multiple. Will be converted to int. Must not be equal zero.\r\n    Returns\r\n    -------\r\n    ceil_mod_number : int\r\n        Rounded up number.\r\n\r\n    Example\r\n    -------\r\n    round_to_multiple(maximum, math.floor(math.log10(maximum)))\r\n    '''\r\n    multiple = int(multiple)\r\n    if multiple == 0:\r\n        multiple = 1\r\n    ceil_mod_number = number - number % (-multiple)\r\n    return int(ceil_mod_number)", "response": "Round up to the nearest multiple of any positive integer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate quantiles from histograms cuts off hist below and above given quantile.", "response": "def hist_quantiles(hist, prob=(0.05, 0.95), return_indices=False, copy=True):\r\n    '''Calculate quantiles from histograms, cuts off hist below and above given quantile. This function will not cut off more than the given values.\r\n\r\n    Parameters\r\n    ----------\r\n    hist : array_like, iterable\r\n        Input histogram with dimension at most 1.\r\n    prob : float, list, tuple\r\n        List of quantiles to compute. Upper and lower limit. From 0 to 1. Default is 0.05 and 0.95.\r\n    return_indices : bool, optional\r\n        If true, return the indices of the hist.\r\n    copy : bool, optional\r\n        Whether to copy the input data (True), or to use a reference instead. Default is False.\r\n\r\n    Returns\r\n    -------\r\n    masked_hist : masked_array\r\n       Hist with masked elements.\r\n    masked_hist : masked_array, tuple\r\n        Hist with masked elements and indices.\r\n    '''\r\n    # make np array\r\n    hist_t = np.array(hist)\r\n    # calculate cumulative distribution\r\n    cdf = np.cumsum(hist_t)\r\n    # copy, convert and normalize\r\n    if cdf[-1] == 0:\r\n        normcdf = cdf.astype('float')\r\n    else:\r\n        normcdf = cdf.astype('float') / cdf[-1]\r\n    # calculate unique values from cumulative distribution and their indices\r\n    unormcdf, indices = np.unique(normcdf, return_index=True)\r\n    # calculate limits\r\n    try:\r\n        hp = np.where(unormcdf > prob[1])[0][0]\r\n        lp = np.where(unormcdf >= prob[0])[0][0]\r\n    except IndexError:\r\n        hp_index = hist_t.shape[0]\r\n        lp_index = 0\r\n    else:\r\n        hp_index = indices[hp]\r\n        lp_index = indices[lp]\r\n    # copy and create ma\r\n    masked_hist = np.ma.array(hist, copy=copy, mask=True)\r\n    masked_hist.mask[lp_index:hp_index + 1] = False\r\n    if return_indices:\r\n        return masked_hist, (lp_index, hp_index)\r\n    else:\r\n        return masked_hist"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the last nonzero entry in a histogram.", "response": "def hist_last_nonzero(hist, return_index=False, copy=True):\r\n    '''Find the last nonzero index and mask the remaining entries.\r\n\r\n    Parameters\r\n    ----------\r\n    hist : array_like, iterable\r\n        Input histogram with dimension at most 1.\r\n    return_index : bool, optional\r\n        If true, return the index.\r\n    copy : bool, optional\r\n        Whether to copy the input data (True), or to use a reference instead. Default is False.\r\n\r\n    Returns\r\n    -------\r\n    masked_hist : masked_array\r\n       Hist with masked elements.\r\n    masked_hist : masked_array, tuple\r\n        Hist with masked elements and index of the element after the last nonzero value.\r\n    '''\r\n    # make np array\r\n    hist_t = np.array(hist)\r\n    index = (np.where(hist_t)[-1][-1] + 1) if np.sum(hist_t) > 1 else hist_t.shape[0]\r\n    # copy and create ma\r\n    masked_hist = np.ma.array(hist, copy=copy, mask=True)\r\n    masked_hist.mask[index:] = False\r\n    if return_index:\r\n        return masked_hist, index\r\n    else:\r\n        return masked_hist"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readout(self, fifo, no_data_timeout=None):\r\n        '''Readout thread continuously reading FIFO.\r\n\r\n        Readout thread, which uses read_raw_data_from_fifo() and appends data to self._fifo_data_deque (collection.deque).\r\n        '''\r\n        logging.info('Starting readout thread for %s', fifo)\r\n        time_last_data = time()\r\n        time_wait = 0.0\r\n        empty_reads = 0\r\n        while not self.force_stop[fifo].wait(time_wait if time_wait >= 0.0 else 0.0):\r\n            time_read = time()\r\n            try:\r\n                if no_data_timeout and time_last_data + no_data_timeout < get_float_time():\r\n                    raise NoDataTimeout('Received no data for %0.1f second(s) from %s' % (no_data_timeout, fifo))\r\n                raw_data = self.read_raw_data_from_fifo(fifo)\r\n            except NoDataTimeout:\r\n                no_data_timeout = None  # raise exception only once\r\n                if self.errback:\r\n                    self.errback(sys.exc_info())\r\n                else:\r\n                    raise\r\n            except Exception:\r\n                if self.errback:\r\n                    self.errback(sys.exc_info())\r\n                else:\r\n                    raise\r\n                if self.stop_readout.is_set():  # in case of a exception, break immediately\r\n                    break\r\n            else:\r\n                n_data_words = raw_data.shape[0]\r\n                if n_data_words > 0:\r\n                    time_last_data = time()\r\n                    empty_reads = 0\r\n                    time_start_read, time_stop_read = self.update_timestamp(fifo)\r\n                    status = 0\r\n                    self._fifo_data_deque[fifo].append((raw_data, time_start_read, time_stop_read, status))\r\n                    with self._fifo_conditions[fifo]:\r\n                        self._fifo_conditions[fifo].notify_all()\r\n                elif self.stop_readout.is_set():\r\n                    if empty_reads == self._n_empty_reads:\r\n                        break\r\n                    else:\r\n                        empty_reads += 1\r\n            finally:\r\n                # ensure that the readout interval does not depend on the processing time of the data\r\n                # and stays more or less constant over time\r\n                time_wait = self.readout_interval - (time() - time_read)\r\n        self._fifo_data_deque[fifo].append(None)  # last item, None will stop worker\r\n        with self._fifo_conditions[fifo]:\r\n            self._fifo_conditions[fifo].notify_all()\r\n        logging.info('Stopping readout thread for %s', fifo)", "response": "Readout thread continuously reading FIFO."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef worker(self, fifo):\r\n        '''Worker thread continuously filtering and converting data when data becomes available.\r\n        '''\r\n        logging.debug('Starting worker thread for %s', fifo)\r\n        self._fifo_conditions[fifo].acquire()\r\n        while True:\r\n            try:\r\n                data_tuple = self._fifo_data_deque[fifo].popleft()\r\n            except IndexError:\r\n                self._fifo_conditions[fifo].wait(self.readout_interval)  # sleep a little bit, reducing CPU usage\r\n            else:\r\n                if data_tuple is None:  # if None then exit\r\n                    break\r\n                else:\r\n                    for index, (filter_func, converter_func, fifo_select) in enumerate(izip(self.filter_func, self.converter_func, self.fifo_select)):\r\n                        if fifo_select is None or fifo_select == fifo:\r\n                            # filter and do the conversion\r\n                            converted_data_tuple = convert_data_iterable((data_tuple,), filter_func=filter_func, converter_func=converter_func)[0]\r\n                            n_data_words = converted_data_tuple[0].shape[0]\r\n                            with self.data_words_per_second_lock:\r\n                                self._words_per_read[index].append((n_data_words, converted_data_tuple[1], converted_data_tuple[2]))\r\n                            self._data_deque[index].append(converted_data_tuple)\r\n                            with self._data_conditions[index]:\r\n                                self._data_conditions[index].notify_all()\r\n        for index, fifo_select in enumerate(self.fifo_select):\r\n            if fifo_select is None or fifo_select == fifo:\r\n                self._data_deque[index].append(None)\r\n                with self._data_conditions[index]:\r\n                    self._data_conditions[index].notify_all()\r\n        self._fifo_conditions[fifo].release()\r\n        logging.debug('Stopping worker thread for %s', fifo)", "response": "This method is a thread that continuously filters and converts data when data becomes available."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nthread continuously calling callback function for writing data when data becomes available.", "response": "def writer(self, index, no_data_timeout=None):\r\n        '''Writer thread continuously calling callback function for writing data when data becomes available.\r\n        '''\r\n        is_fe_data_header = logical_and(is_fe_word, is_data_header)\r\n        logging.debug('Starting writer thread with index %d', index)\r\n        self._data_conditions[index].acquire()\r\n        time_last_data = time()\r\n        time_write = time()\r\n        converted_data_tuple_list = [None] * len(self.filter_func)  # callback function gets a list of lists of tuples\r\n        while True:\r\n            try:\r\n                if no_data_timeout and time_last_data + no_data_timeout < time():\r\n                    raise NoDataTimeout('Received no data for %0.1f second(s) for writer thread with index %d' % (no_data_timeout, index))\r\n                converted_data_tuple = self._data_deque[index].popleft()\r\n            except NoDataTimeout:  # no data timeout\r\n                no_data_timeout = None  # raise exception only once\r\n                if self.errback:\r\n                    self.errback(sys.exc_info())\r\n                else:\r\n                    raise\r\n            except IndexError:  # no data in queue\r\n                self._data_conditions[index].wait(self.readout_interval)  # sleep a little bit, reducing CPU usage\r\n            else:\r\n                if converted_data_tuple is None:  # if None then write and exit\r\n                    if self.callback and any(converted_data_tuple_list):\r\n                        try:\r\n                            self.callback(converted_data_tuple_list)\r\n                        except Exception:\r\n                            self.errback(sys.exc_info())\r\n                    break\r\n                else:\r\n                    if no_data_timeout and np.any(is_fe_data_header(converted_data_tuple[0])):  # check for FEI4 data words\r\n                        time_last_data = time()\r\n                    if converted_data_tuple_list[index]:\r\n                        converted_data_tuple_list[index].append(converted_data_tuple)\r\n                    else:\r\n                        converted_data_tuple_list[index] = [converted_data_tuple]  # adding iterable\r\n                    if self.fill_buffer:\r\n                        self._data_buffer[index].append(converted_data_tuple)\r\n            # check if calling the callback function is about time\r\n            if self.callback and any(converted_data_tuple_list) and ((self.write_interval and time() - time_write >= self.write_interval) or not self.write_interval):\r\n                try:\r\n                    self.callback(converted_data_tuple_list)  # callback function gets a list of lists of tuples\r\n                except Exception:\r\n                    self.errback(sys.exc_info())\r\n                else:\r\n                    converted_data_tuple_list = [None] * len(self.filter_func)\r\n                    time_write = time()  # update last write timestamp\r\n        self._data_conditions[index].release()\r\n        logging.debug('Stopping writer thread with index %d', index)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_data_from_buffer(self, filter_func=None, converter_func=None):\r\n        '''Reads local data buffer and returns data and meta data list.\r\n\r\n        Returns\r\n        -------\r\n        data : list\r\n            List of data and meta data dicts.\r\n        '''\r\n        if self._is_running:\r\n            raise RuntimeError('Readout thread running')\r\n        if not self.fill_buffer:\r\n            logging.warning('Data buffer is not activated')\r\n        return [convert_data_iterable(data_iterable, filter_func=filter_func, converter_func=converter_func) for data_iterable in self._data_buffer]", "response": "Reads local data buffer and returns data and meta data dicts."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading local data buffer and returns raw data array.", "response": "def get_raw_data_from_buffer(self, filter_func=None, converter_func=None):\r\n        '''Reads local data buffer and returns raw data array.\r\n\r\n        Returns\r\n        -------\r\n        data : np.array\r\n            An array containing data words from the local data buffer.\r\n        '''\r\n        if self._is_running:\r\n            raise RuntimeError('Readout thread running')\r\n        if not self.fill_buffer:\r\n            logging.warning('Data buffer is not activated')\r\n        return [convert_data_array(data_array_from_data_iterable(data_iterable), filter_func=filter_func, converter_func=converter_func) for data_iterable in self._data_buffer]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_raw_data_from_fifo(self, fifo, filter_func=None, converter_func=None):\r\n        '''Reads FIFO data and returns raw data array.\r\n\r\n        Returns\r\n        -------\r\n        data : np.array\r\n            An array containing FIFO data words.\r\n        '''\r\n        return convert_data_array(self.dut[fifo].get_data(), filter_func=filter_func, converter_func=converter_func)", "response": "Reads FIFO data and returns raw data array."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting an item from the queue Q.", "response": "def get_item_from_queue(Q, timeout=0.01):\r\n    \"\"\" Attempts to retrieve an item from the queue Q. If Q is\r\n        empty, None is returned.\r\n\r\n        Blocks for 'timeout' seconds in case the queue is empty,\r\n        so don't use this method for speedy retrieval of multiple\r\n        items (use get_all_from_queue for that).\r\n    \"\"\"\r\n    try:\r\n        item = Q.get(True, 0.01)\r\n    except Queue.Empty:\r\n        return None\r\n\r\n    return item"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef argmin_list(seq, func):\r\n    best_score, best = func(seq[0]), []\r\n    for x in seq:\r\n        x_score = func(x)\r\n        if x_score < best_score:\r\n            best, best_score = [x], x_score\r\n        elif x_score == best_score:\r\n            best.append(x)\r\n    return best", "response": "Returns a list of elements of seq with the lowest scores."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nflatten iterable but leaves out strings", "response": "def flatten_iterable(iterable):\r\n    \"\"\"flatten iterable, but leaves out strings\r\n\r\n    [[[1, 2, 3], [4, 5]], 6] -> [1, 2, 3, 4, 5, 6]\r\n\r\n    \"\"\"\r\n    for item in iterable:\r\n        if isinstance(item, collections.Iterable) and not isinstance(item, basestring):\r\n            for sub in flatten_iterable(item):\r\n                yield sub\r\n        else:\r\n            yield item"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates iterable from item but leaves out strings", "response": "def iterable(item):\r\n    \"\"\"generate iterable from item, but leaves out strings\r\n\r\n    \"\"\"\r\n    if isinstance(item, collections.Iterable) and not isinstance(item, basestring):\r\n        return item\r\n    else:\r\n        return [item]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef natsorted(seq, cmp=natcmp):\r\n    \"Returns a copy of seq, sorted by natural string sort.\"\r\n    import copy\r\n    temp = copy.copy(seq)\r\n    natsort(temp, cmp)\r\n    return temp", "response": "Returns a copy of seq sorted by natural string sort."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_iso_time():\r\n    '''returns time as ISO string, mapping to and from datetime in ugly way\r\n\r\n    convert to string with str()\r\n    '''\r\n    t1 = time.time()\r\n    t2 = datetime.datetime.fromtimestamp(t1)\r\n    t4 = t2.__str__()\r\n    try:\r\n        t4a, t4b = t4.split(\".\", 1)\r\n    except ValueError:\r\n        t4a = t4\r\n        t4b = '000000'\r\n    t5 = datetime.datetime.strptime(t4a, \"%Y-%m-%d %H:%M:%S\")\r\n    ms = int(t4b.ljust(6, '0')[:6])\r\n    return t5.replace(microsecond=ms)", "response": "returns time as ISO string mapping to and from datetime in ugly way"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_float_time():\r\n    '''returns time as double precision floats - Time64 in pytables - mapping to and from python datetime's\r\n\r\n    '''\r\n    t1 = time.time()\r\n    t2 = datetime.datetime.fromtimestamp(t1)\r\n    return time.mktime(t2.timetuple()) + 1e-6 * t2.microsecond", "response": "returns time as double precision floats - Time64 in pytables - mapping to and from python datetime s\r\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef groupby_dict(dictionary, key):\r\n    ''' Group dict of dicts by key.\r\n    '''\r\n    return dict((k, list(g)) for k, g in itertools.groupby(sorted(dictionary.keys(), key=lambda name: dictionary[name][key]), key=lambda name: dictionary[name][key]))", "response": "Group dict of dicts by key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a new iterable with fillvalue removed from the first iterable.", "response": "def zip_nofill(*iterables):\r\n    '''Zipping iterables without fillvalue.\r\n\r\n    Note: https://stackoverflow.com/questions/38054593/zip-longest-without-fillvalue\r\n    '''\r\n    return (tuple([entry for entry in iterable if entry is not None]) for iterable in itertools.izip_longest(*iterables, fillvalue=None))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding a file in a directory upwards.", "response": "def find_file_dir_up(filename, path=None, n=None):\r\n    '''Finding file in directory upwards.\r\n    '''\r\n    if path is None:\r\n        path = os.getcwd()\r\n    i = 0\r\n    while True:\r\n        current_path = path\r\n        for _ in range(i):\r\n            current_path = os.path.split(current_path)[0]\r\n        if os.path.isfile(os.path.join(current_path, filename)):  # found file and return\r\n            return os.path.join(current_path, filename)\r\n        elif os.path.dirname(current_path) == current_path:  # root of filesystem\r\n            return\r\n        elif n is not None and i == n:\r\n            return\r\n        else:  # file not found\r\n            i += 1\r\n            continue"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload configuration from a text file into a single object.", "response": "def load_configuration_from_text_file(register, configuration_file):\r\n    '''Loading configuration from text files to register object\r\n\r\n    Parameters\r\n    ----------\r\n    register : pybar.fei4.register object\r\n    configuration_file : string\r\n        Full path (directory and filename) of the configuration file. If name is not given, reload configuration from file.\r\n    '''\r\n    logging.info(\"Loading configuration: %s\" % configuration_file)\r\n    register.configuration_file = configuration_file\r\n\r\n    config_dict = parse_global_config(register.configuration_file)\r\n\r\n    if 'Flavor' in config_dict:\r\n        flavor = config_dict.pop('Flavor').lower()\r\n        if register.flavor:\r\n            pass\r\n        else:\r\n            register.init_fe_type(flavor)\r\n    else:\r\n        if register.flavor:\r\n            pass\r\n        else:\r\n            raise ValueError('Flavor not specified')\r\n    if 'Chip_ID' in config_dict:\r\n        chip_id = config_dict.pop('Chip_ID')\r\n        if register.chip_address:\r\n            pass\r\n        else:\r\n            register.set_chip_address(chip_address=chip_id & 0x7, broadcast=True if chip_id & 0x8 else False)\r\n    elif 'Chip_Address' in config_dict:\r\n        chip_address = config_dict.pop('Chip_Address')\r\n        if register.chip_address:\r\n            pass\r\n        else:\r\n            register.set_chip_address(chip_address)\r\n    else:\r\n        if register.chip_id_initialized:\r\n            pass\r\n        else:\r\n            raise ValueError('Chip address not specified')\r\n    global_registers_configured = []\r\n    pixel_registers_configured = []\r\n    for key in config_dict.keys():\r\n        value = config_dict.pop(key)\r\n        if key in register.global_registers:\r\n            register.set_global_register_value(key, value)\r\n            global_registers_configured.append(key)\r\n        elif key in register.pixel_registers:\r\n            register.set_pixel_register_value(key, value)\r\n            pixel_registers_configured.append(key)\r\n        elif key in register.calibration_parameters:\r\n            register.calibration_parameters[key] = value\r\n        else:\r\n            register.miscellaneous[key] = value\r\n\r\n    global_registers = register.get_global_register_attributes('name', readonly=False)\r\n    pixel_registers = register.pixel_registers.keys()\r\n    global_registers_not_configured = set(global_registers).difference(global_registers_configured)\r\n    pixel_registers_not_configured = set(pixel_registers).difference(pixel_registers_configured)\r\n    if global_registers_not_configured:\r\n        logging.warning(\"Following global register(s) not configured: {}\".format(', '.join('\\'' + reg + '\\'' for reg in global_registers_not_configured)))\r\n    if pixel_registers_not_configured:\r\n        logging.warning(\"Following pixel register(s) not configured: {}\".format(', '.join('\\'' + reg + '\\'' for reg in pixel_registers_not_configured)))\r\n    if register.miscellaneous:\r\n        logging.warning(\"Found following unknown parameter(s): {}\".format(', '.join('\\'' + parameter + '\\'' for parameter in register.miscellaneous.iterkeys())))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads a configuration from a HDF5 file to a register object.", "response": "def load_configuration_from_hdf5(register, configuration_file, node=''):\r\n    '''Loading configuration from HDF5 file to register object\r\n\r\n    Parameters\r\n    ----------\r\n    register : pybar.fei4.register object\r\n    configuration_file : string, file\r\n        Filename of the HDF5 configuration file or file object.\r\n    node : string\r\n        Additional identifier (subgroup). Useful when more than one configuration is stored inside a HDF5 file.\r\n    '''\r\n    def load_conf():\r\n        logging.info(\"Loading configuration: %s\" % h5_file.filename)\r\n        register.configuration_file = h5_file.filename\r\n        if node:\r\n            configuration_group = h5_file.root.configuration.node\r\n        else:\r\n            configuration_group = h5_file.root.configuration\r\n\r\n        # miscellaneous\r\n        for row in configuration_group.miscellaneous:\r\n            name = row['name']\r\n            try:\r\n                value = literal_eval(row['value'])\r\n            except ValueError:\r\n                value = row['value']\r\n            if name == 'Flavor':\r\n                if register.flavor:\r\n                    pass\r\n                else:\r\n                    register.init_fe_type(value)\r\n            elif name == 'Chip_ID':\r\n                if register.chip_address:\r\n                    pass\r\n                else:\r\n                    register.set_chip_address(chip_address=value & 0x7, broadcast=True if value & 0x8 else False)\r\n            elif name == 'Chip_Address':\r\n                if register.chip_address:\r\n                    pass\r\n                else:\r\n                    register.set_chip_address(chip_address=value, broadcast=False)\r\n            else:\r\n                register.miscellaneous[name] = value\r\n\r\n        if register.flavor:\r\n            pass\r\n        else:\r\n            raise ValueError('Flavor not specified')\r\n\r\n        if register.chip_id_initialized:\r\n            pass\r\n        else:\r\n            raise ValueError('Chip address not specified')\r\n\r\n        # calibration parameters\r\n        for row in configuration_group.calibration_parameters:\r\n            name = row['name']\r\n            value = row['value']\r\n            register.calibration_parameters[name] = literal_eval(value)\r\n\r\n        # global\r\n        for row in configuration_group.global_register:\r\n            name = row['name']\r\n            value = row['value']\r\n            register.set_global_register_value(name, literal_eval(value))\r\n\r\n        # pixels\r\n        for pixel_reg in h5_file.iter_nodes(configuration_group, 'CArray'):  # ['Enable', 'TDAC', 'C_High', 'C_Low', 'Imon', 'FDAC', 'EnableDigInj']:\r\n            if pixel_reg.name in register.pixel_registers:\r\n                register.set_pixel_register_value(pixel_reg.name, np.asarray(pixel_reg).T)  # np.asarray(h5_file.get_node(configuration_group, name=pixel_reg)).T\r\n\r\n    if isinstance(configuration_file, tb.file.File):\r\n        h5_file = configuration_file\r\n        load_conf()\r\n    else:\r\n        with tb.open_file(configuration_file, mode=\"r\", title='') as h5_file:\r\n            load_conf()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave the configuration to text files from the given register object.", "response": "def save_configuration_to_text_file(register, configuration_file):\r\n    '''Saving configuration to text files from register object\r\n\r\n    Parameters\r\n    ----------\r\n    register : pybar.fei4.register object\r\n    configuration_file : string\r\n        Filename of the configuration file.\r\n    '''\r\n    configuration_path, filename = os.path.split(configuration_file)\r\n    if os.path.split(configuration_path)[1] == 'configs':\r\n        configuration_path = os.path.split(configuration_path)[0]\r\n    filename = os.path.splitext(filename)[0].strip()\r\n    register.configuration_file = os.path.join(os.path.join(configuration_path, 'configs'), filename + \".cfg\")\r\n    if os.path.isfile(register.configuration_file):\r\n        logging.warning(\"Overwriting configuration: %s\", register.configuration_file)\r\n    else:\r\n        logging.info(\"Saving configuration: %s\" % register.configuration_file)\r\n    pixel_reg_dict = {}\r\n    for path in [\"tdacs\", \"fdacs\", \"masks\", \"configs\"]:\r\n        configuration_file_path = os.path.join(configuration_path, path)\r\n        if not os.path.exists(configuration_file_path):\r\n            os.makedirs(configuration_file_path)\r\n        if path == \"tdacs\":\r\n            dac = register.get_pixel_register_objects(name=\"TDAC\")[0]\r\n            dac_config_path = os.path.join(configuration_file_path, \"_\".join([dac['name'].lower(), filename]) + \".dat\")\r\n            write_pixel_dac_config(dac_config_path, dac['value'])\r\n            pixel_reg_dict[dac['name']] = os.path.relpath(dac_config_path, os.path.dirname(register.configuration_file))\r\n        elif path == \"fdacs\":\r\n            dac = register.get_pixel_register_objects(name=\"FDAC\")[0]\r\n            dac_config_path = os.path.join(configuration_file_path, \"_\".join([dac['name'].lower(), filename]) + \".dat\")\r\n            write_pixel_dac_config(dac_config_path, dac['value'])\r\n            pixel_reg_dict[dac['name']] = os.path.relpath(dac_config_path, os.path.dirname(register.configuration_file))\r\n        elif path == \"masks\":\r\n            masks = register.get_pixel_register_objects(bitlength=1)\r\n            for mask in masks:\r\n                dac_config_path = os.path.join(configuration_file_path, \"_\".join([mask['name'].lower(), filename]) + \".dat\")\r\n                write_pixel_mask_config(dac_config_path, mask['value'])\r\n                pixel_reg_dict[mask['name']] = os.path.relpath(dac_config_path, os.path.dirname(register.configuration_file))\r\n        elif path == \"configs\":\r\n            with open(register.configuration_file, 'w') as f:\r\n                lines = []\r\n                lines.append(\"# FEI4 Flavor\\n\")\r\n                lines.append('%s %s\\n' % ('Flavor', register.flavor))\r\n                lines.append(\"\\n# FEI4 Chip ID\\n\")\r\n                lines.append('%s %d\\n' % ('Chip_ID', register.chip_id))\r\n                lines.append(\"\\n# FEI4 Global Registers\\n\")\r\n                global_regs = register.get_global_register_objects(readonly=False)\r\n                for global_reg in sorted(global_regs, key=itemgetter('name')):\r\n                    lines.append('%s %d\\n' % (global_reg['name'], global_reg['value']))\r\n                lines.append(\"\\n# FEI4 Pixel Registers\\n\")\r\n                for key in sorted(pixel_reg_dict):\r\n                    lines.append('%s %s\\n' % (key, pixel_reg_dict[key]))\r\n                lines.append(\"\\n# FEI4 Calibration Parameters\\n\")\r\n                for key in register.calibration_parameters:\r\n                    if register.calibration_parameters[key] is None:\r\n                        lines.append('%s %s\\n' % (key, register.calibration_parameters[key]))\r\n                    elif isinstance(register.calibration_parameters[key], (float, int, long)):\r\n                        lines.append('%s %s\\n' % (key, round(register.calibration_parameters[key], 4)))\r\n                    elif isinstance(register.calibration_parameters[key], list):\r\n                        lines.append('%s %s\\n' % (key, [round(elem, 2) for elem in register.calibration_parameters[key]]))\r\n                    else:\r\n                        raise ValueError('type %s not supported' % type(register.calibration_parameters[key]))\r\n                if register.miscellaneous:\r\n                    lines.append(\"\\n# Miscellaneous\\n\")\r\n                    for key, value in register.miscellaneous.iteritems():\r\n                        lines.append('%s %s\\n' % (key, value))\r\n                f.writelines(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving a configuration to HDF5 file from register object.", "response": "def save_configuration_to_hdf5(register, configuration_file, name=''):\r\n    '''Saving configuration to HDF5 file from register object\r\n\r\n    Parameters\r\n    ----------\r\n    register : pybar.fei4.register object\r\n    configuration_file : string, file\r\n        Filename of the HDF5 configuration file or file object.\r\n    name : string\r\n        Additional identifier (subgroup). Useful when storing more than one configuration inside a HDF5 file.\r\n    '''\r\n    def save_conf():\r\n        logging.info(\"Saving configuration: %s\" % h5_file.filename)\r\n        register.configuration_file = h5_file.filename\r\n        try:\r\n            configuration_group = h5_file.create_group(h5_file.root, \"configuration\")\r\n        except tb.NodeError:\r\n            configuration_group = h5_file.root.configuration\r\n        if name:\r\n            try:\r\n                configuration_group = h5_file.create_group(configuration_group, name)\r\n            except tb.NodeError:\r\n                configuration_group = h5_file.root.configuration.name\r\n\r\n        # calibration_parameters\r\n        try:\r\n            h5_file.remove_node(configuration_group, name='calibration_parameters')\r\n        except tb.NodeError:\r\n            pass\r\n        calibration_data_table = h5_file.create_table(configuration_group, name='calibration_parameters', description=NameValue, title='calibration_parameters')\r\n        calibration_data_row = calibration_data_table.row\r\n        for key, value in register.calibration_parameters.iteritems():\r\n            calibration_data_row['name'] = key\r\n            calibration_data_row['value'] = str(value)\r\n            calibration_data_row.append()\r\n        calibration_data_table.flush()\r\n\r\n        # miscellaneous\r\n        try:\r\n            h5_file.remove_node(configuration_group, name='miscellaneous')\r\n        except tb.NodeError:\r\n            pass\r\n        miscellaneous_data_table = h5_file.create_table(configuration_group, name='miscellaneous', description=NameValue, title='miscellaneous')\r\n        miscellaneous_data_row = miscellaneous_data_table.row\r\n        miscellaneous_data_row['name'] = 'Flavor'\r\n        miscellaneous_data_row['value'] = register.flavor\r\n        miscellaneous_data_row.append()\r\n        miscellaneous_data_row['name'] = 'Chip_ID'\r\n        miscellaneous_data_row['value'] = register.chip_id\r\n        miscellaneous_data_row.append()\r\n        for key, value in register.miscellaneous.iteritems():\r\n            miscellaneous_data_row['name'] = key\r\n            miscellaneous_data_row['value'] = value\r\n            miscellaneous_data_row.append()\r\n        miscellaneous_data_table.flush()\r\n\r\n        # global\r\n        try:\r\n            h5_file.remove_node(configuration_group, name='global_register')\r\n        except tb.NodeError:\r\n            pass\r\n        global_data_table = h5_file.create_table(configuration_group, name='global_register', description=NameValue, title='global_register')\r\n        global_data_table_row = global_data_table.row\r\n        global_regs = register.get_global_register_objects(readonly=False)\r\n        for global_reg in sorted(global_regs, key=itemgetter('name')):\r\n            global_data_table_row['name'] = global_reg['name']\r\n            global_data_table_row['value'] = global_reg['value']  # TODO: some function that converts to bin, hex\r\n            global_data_table_row.append()\r\n        global_data_table.flush()\r\n\r\n        # pixel\r\n        for pixel_reg in register.pixel_registers.itervalues():\r\n            try:\r\n                h5_file.remove_node(configuration_group, name=pixel_reg['name'])\r\n            except tb.NodeError:\r\n                pass\r\n            data = pixel_reg['value'].T\r\n            atom = tb.Atom.from_dtype(data.dtype)\r\n            ds = h5_file.create_carray(configuration_group, name=pixel_reg['name'], atom=atom, shape=data.shape, title=pixel_reg['name'])\r\n            ds[:] = data\r\n\r\n    if isinstance(configuration_file, tb.file.File):\r\n        h5_file = configuration_file\r\n        save_conf()\r\n    else:\r\n        with tb.open_file(configuration_file, mode=\"a\", title='') as h5_file:\r\n            save_conf()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_configuration(self, configuration_file):\r\n        '''Loading configuration\r\n\r\n        Parameters\r\n        ----------\r\n        configuration_file : string\r\n            Path to the configuration file (text or HDF5 file).\r\n        '''\r\n        if os.path.isfile(configuration_file):\r\n            if not isinstance(configuration_file, tb.file.File) and os.path.splitext(configuration_file)[1].strip().lower() != \".h5\":\r\n                load_configuration_from_text_file(self, configuration_file)\r\n            else:\r\n                load_configuration_from_hdf5(self, configuration_file)\r\n        else:\r\n            raise ValueError('Cannot find configuration file specified: %s' % configuration_file)", "response": "Load the configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_configuration(self, configuration_file):\r\n        '''Saving configuration\r\n\r\n        Parameters\r\n        ----------\r\n        configuration_file : string\r\n            Filename of the configuration file.\r\n        '''\r\n        if not isinstance(configuration_file, tb.file.File) and os.path.splitext(configuration_file)[1].strip().lower() != \".h5\":\r\n            return save_configuration_to_text_file(self, configuration_file)\r\n        else:\r\n            return save_configuration_to_hdf5(self, configuration_file)", "response": "Save the configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget fe_command from command name and keyword arguments return list of fe_command", "response": "def get_commands(self, command_name, **kwargs):\r\n        \"\"\"get fe_command from command name and keyword arguments\r\n\r\n        wrapper for build_commands()\r\n        implements FEI4 specific behavior\r\n\r\n        \"\"\"\r\n        chip_id = kwargs.pop(\"ChipID\", self.chip_id_bitarray)\r\n        commands = []\r\n        if command_name == \"zeros\":\r\n            bv = bitarray(endian='little')\r\n            if \"length\" in kwargs:\r\n                bv += bitarray(kwargs[\"length\"], endian='little')  # initialized from int, bits may be random\r\n            elif kwargs:\r\n                raise ValueError(\"Unknown parameter(s): %s\" % \", \".join(kwargs.iterkeys()))\r\n            bv.setall(0)  # all bits to zero\r\n            commands.append(bv)\r\n        elif command_name == \"ones\":\r\n            bv = bitarray(endian='little')\r\n            if \"length\" in kwargs:\r\n                bv += bitarray(kwargs[\"length\"], endian='little')  # initialized from int, bits may be random\r\n            elif kwargs:\r\n                raise ValueError(\"Unknown parameter(s): %s\" % \", \".join(kwargs.iterkeys()))\r\n            bv.setall(1)  # all bits to one\r\n            commands.append(bv)\r\n        elif command_name == \"WrRegister\":\r\n            register_addresses = self.get_global_register_attributes(\"addresses\", **kwargs)\r\n            register_bitsets = self.get_global_register_bitsets(register_addresses)\r\n            commands.extend([self.build_command(command_name, Address=register_address, GlobalData=register_bitset, ChipID=chip_id, **kwargs) for register_address, register_bitset in zip(register_addresses, register_bitsets)])\r\n        elif command_name == \"RdRegister\":\r\n            register_addresses = self.get_global_register_attributes('addresses', **kwargs)\r\n            commands.extend([self.build_command(command_name, Address=register_address, ChipID=chip_id) for register_address in register_addresses])\r\n        elif command_name == \"WrFrontEnd\":\r\n            registers = [\"S0\", \"S1\", \"SR_Clr\", \"CalEn\", \"DIGHITIN_SEL\", \"GateHitOr\", \"ReadErrorReq\", \"StopClkPulse\", \"SR_Clock\", \"Efuse_Sense\", \"HITLD_IN\", \"Colpr_Mode\", \"Colpr_Addr\"]\r\n            if self.fei4a:\r\n                registers.append(\"ReadSkipped\")\r\n            elif self.fei4b:\r\n                registers.append(\"SR_Read\")\r\n            self.create_restore_point()\r\n            dcs = kwargs.pop(\"dcs\", range(40))  # set the double columns to latch\r\n            # in case of empty list\r\n            if not dcs:\r\n                dcs = range(40)\r\n            joint_write = kwargs.pop(\"joint_write\", False)\r\n            same_mask_for_all_dc = kwargs.pop(\"same_mask_for_all_dc\", False)\r\n            register_objects = self.get_pixel_register_objects(do_sort=['pxstrobe'], **kwargs)\r\n            # prepare for writing pixel registers\r\n            if not self.broadcast:\r\n                self.set_global_register_value(\"Colpr_Mode\", 0)  # write only to the addressed double-column\r\n                self.set_global_register_value(\"Colpr_Addr\", 40)  # ivalid address, grounded\r\n                # Broadcasting ConfMode not necessary, writing registers is also possible in RunMode\r\n#                 commands.extend(self.get_commands(\"ConfMode\", ChipID=8))  # set all chips to conf mode to receive commands#\r\n                # set all other chips to invalid addresses, to make broadcasting of WrRegister command possible\r\n                commands.extend(self.get_commands(\"WrRegister\", name=[\"Colpr_Mode\", \"Colpr_Addr\"], ChipID=8))  # braodcast\r\n            self.set_global_register_value(\"S0\", 0)\r\n            self.set_global_register_value(\"S1\", 0)\r\n            self.set_global_register_value(\"SR_Clr\", 0)\r\n            self.set_global_register_value(\"CalEn\", 0)\r\n            self.set_global_register_value(\"DIGHITIN_SEL\", 0)\r\n            self.set_global_register_value(\"GateHitOr\", 0)\r\n            self.set_global_register_value(\"ReadErrorReq\", 0)\r\n            self.set_global_register_value(\"StopClkPulse\", 0)\r\n            self.set_global_register_value(\"SR_Clock\", 0)\r\n            self.set_global_register_value(\"Efuse_Sense\", 0)\r\n            self.set_global_register_value(\"HITLD_IN\", 0)\r\n            self.set_global_register_value(\"Colpr_Mode\", 3 if same_mask_for_all_dc else 0)  # write only the addressed double-column\r\n            self.set_global_register_value(\"Colpr_Addr\", 0)\r\n            if self.fei4a:\r\n                self.set_global_register_value(\"ReadSkipped\", 0)\r\n            elif self.fei4b:\r\n                self.set_global_register_value(\"SR_Read\", 0)\r\n            commands.extend(self.get_commands(\"WrRegister\", name=registers))\r\n\r\n            if joint_write:\r\n                pxstrobes = 0\r\n                first_read = True\r\n                do_latch = False\r\n                for register_object in register_objects:\r\n                    if register_object['bitlength'] != 1:\r\n                        raise ValueError('Pixel register %s: joint write not supported for pixel DACs' % register_object['name'])\r\n                    pxstrobe = register_object['pxstrobe']\r\n                    if not isinstance(pxstrobe, basestring):\r\n                        do_latch = True\r\n                        pxstrobes += 2 ** register_object['pxstrobe']\r\n                    if first_read:\r\n                        pixel_reg_value = register_object['value']\r\n                        first_read = False\r\n                    else:\r\n                        if np.array_equal(pixel_reg_value, register_object['value']):\r\n                            pixel_reg_value = register_object['value']\r\n                        else:\r\n                            raise ValueError('Pixel register %s: joint write not supported, pixel register values must be equal' % register_object['name'])\r\n                if do_latch:\r\n                    self.set_global_register_value(\"Latch_En\", 1)\r\n                else:\r\n                    self.set_global_register_value(\"Latch_En\", 0)\r\n                self.set_global_register_value(\"Pixel_Strobes\", pxstrobes)\r\n                commands.extend(self.get_commands(\"WrRegister\", name=[\"Pixel_Strobes\", \"Latch_En\"]))\r\n                for dc_no in (dcs[:1] if same_mask_for_all_dc else dcs):\r\n                    self.set_global_register_value(\"Colpr_Addr\", dc_no)\r\n                    commands.extend(self.get_commands(\"WrRegister\", name=[\"Colpr_Addr\"]))\r\n                    register_bitset = self.get_pixel_register_bitset(register_objects[0], 0, dc_no)\r\n                    commands.extend([self.build_command(command_name, PixelData=register_bitset, ChipID=8, **kwargs)])  # broadcast\r\n                    if do_latch:\r\n                        commands.extend(self.get_commands(\"GlobalPulse\", Width=0))\r\n            else:\r\n                for register_object in register_objects:\r\n                    pxstrobe = register_object['pxstrobe']\r\n                    if isinstance(pxstrobe, basestring):\r\n                        do_latch = False\r\n                        self.set_global_register_value(\"Pixel_Strobes\", 0)  # no latch\r\n                        self.set_global_register_value(\"Latch_En\", 0)\r\n                        commands.extend(self.get_commands(\"WrRegister\", name=[\"Pixel_Strobes\", \"Latch_En\"]))\r\n                    else:\r\n                        do_latch = True\r\n                        self.set_global_register_value(\"Latch_En\", 1)\r\n                        commands.extend(self.get_commands(\"WrRegister\", name=[\"Latch_En\"]))\r\n                    bitlength = register_object['bitlength']\r\n                    for bit_no, pxstrobe_bit_no in (enumerate(range(bitlength)) if (register_object['littleendian'] is False) else enumerate(reversed(range(bitlength)))):\r\n                        if do_latch:\r\n                            self.set_global_register_value(\"Pixel_Strobes\", 2 ** (pxstrobe + bit_no))\r\n                            commands.extend(self.get_commands(\"WrRegister\", name=[\"Pixel_Strobes\"]))\r\n                        for dc_no in (dcs[:1] if same_mask_for_all_dc else dcs):\r\n                            self.set_global_register_value(\"Colpr_Addr\", dc_no)\r\n                            commands.extend(self.get_commands(\"WrRegister\", name=[\"Colpr_Addr\"]))\r\n                            register_bitset = self.get_pixel_register_bitset(register_object, pxstrobe_bit_no, dc_no)\r\n                            commands.extend([self.build_command(command_name, PixelData=register_bitset, ChipID=8, **kwargs)])  # broadcast\r\n                            if do_latch:\r\n                                commands.extend(self.get_commands(\"GlobalPulse\", Width=0))\r\n            self.restore(pixel_register=False)\r\n            commands.extend(self.get_commands(\"WrRegister\", name=registers))\r\n        elif command_name == \"RdFrontEnd\":\r\n            registers = [\"Conf_AddrEnable\", \"S0\", \"S1\", \"SR_Clr\", \"CalEn\", \"DIGHITIN_SEL\", \"GateHitOr\", \"ReadErrorReq\", \"StopClkPulse\", \"SR_Clock\", \"Efuse_Sense\", \"HITLD_IN\", \"Colpr_Mode\", \"Colpr_Addr\", \"Pixel_Strobes\", \"Latch_En\"]\r\n            if self.fei4a:\r\n                registers.append(\"ReadSkipped\")\r\n            elif self.fei4b:\r\n                registers.append(\"SR_Read\")\r\n            self.create_restore_point()\r\n            dcs = kwargs.pop(\"dcs\", range(40))  # set the double columns to latch\r\n            # in case of empty list\r\n            if not dcs:\r\n                dcs = range(40)\r\n            register_objects = self.get_pixel_register_objects(**kwargs)\r\n            self.set_global_register_value('Conf_AddrEnable', 1)\r\n            self.set_global_register_value(\"S0\", 0)\r\n            self.set_global_register_value(\"S1\", 0)\r\n            self.set_global_register_value(\"SR_Clr\", 0)\r\n            if self.fei4b:\r\n                self.set_global_register_value(\"SR_Read\", 0)\r\n            self.set_global_register_value(\"CalEn\", 0)\r\n            self.set_global_register_value(\"DIGHITIN_SEL\", 0)\r\n            self.set_global_register_value(\"GateHitOr\", 0)\r\n            if self.fei4a:\r\n                self.set_global_register_value(\"ReadSkipped\", 0)\r\n            self.set_global_register_value(\"ReadErrorReq\", 0)\r\n            self.set_global_register_value(\"StopClkPulse\", 0)\r\n            self.set_global_register_value(\"SR_Clock\", 0)\r\n            self.set_global_register_value(\"Efuse_Sense\", 0)\r\n            self.set_global_register_value(\"HITLD_IN\", 0)\r\n            self.set_global_register_value(\"Colpr_Mode\", 0)  # write only the addressed double-column\r\n            self.set_global_register_value(\"Colpr_Addr\", 0)\r\n            self.set_global_register_value(\"Latch_En\", 0)\r\n            self.set_global_register_value(\"Pixel_Strobes\", 0)\r\n            commands.extend(self.get_commands(\"WrRegister\", name=registers))\r\n            for index, register_object in enumerate(register_objects):  # make sure that EnableDigInj is first read back, because it is not latched\r\n                if register_object['name'] == 'EnableDigInj':\r\n                    register_objects[0], register_objects[index] = register_objects[index], register_objects[0]\r\n                    break\r\n            for register_object in register_objects:\r\n                pxstrobe = register_object['pxstrobe']\r\n                bitlength = register_object['bitlength']\r\n                for pxstrobe_bit_no in range(bitlength):\r\n                    logging.debug('Pixel Register %s Bit %d', register_object['name'], pxstrobe_bit_no)\r\n                    do_latch = True\r\n                    try:\r\n                        self.set_global_register_value(\"Pixel_Strobes\", 2 ** (pxstrobe + pxstrobe_bit_no))\r\n                    except TypeError:  # thrown for not latched digInjection\r\n                        self.set_global_register_value(\"Pixel_Strobes\", 0)  # do not latch\r\n                        do_latch = False\r\n                    commands.extend(self.get_commands(\"WrRegister\", name=[\"Pixel_Strobes\"]))\r\n                    for dc_no in dcs:\r\n                        self.set_global_register_value(\"Colpr_Addr\", dc_no)\r\n                        commands.extend(self.get_commands(\"WrRegister\", name=[\"Colpr_Addr\"]))\r\n                        if do_latch is True:\r\n                            self.set_global_register_value(\"S0\", 1)\r\n                            self.set_global_register_value(\"S1\", 1)\r\n                            self.set_global_register_value(\"SR_Clock\", 1)\r\n                            commands.extend(self.get_commands(\"WrRegister\", name=[\"S0\", \"S1\", \"SR_Clock\"]))\r\n                            commands.extend(self.get_commands(\"GlobalPulse\", Width=0))\r\n                        self.set_global_register_value(\"S0\", 0)\r\n                        self.set_global_register_value(\"S1\", 0)\r\n                        self.set_global_register_value(\"SR_Clock\", 0)\r\n                        commands.extend(self.get_commands(\"WrRegister\", name=[\"S0\", \"S1\", \"SR_Clock\"]))\r\n                        register_bitset = self.get_pixel_register_bitset(register_object, pxstrobe_bit_no if (register_object['littleendian'] is False) else register_object['bitlength'] - pxstrobe_bit_no - 1, dc_no)\r\n                        if self.fei4b:\r\n                            self.set_global_register_value(\"SR_Read\", 1)\r\n                            commands.extend(self.get_commands(\"WrRegister\", name=[\"SR_Read\"]))\r\n                        commands.extend([self.build_command(\"WrFrontEnd\", PixelData=register_bitset, ChipID=chip_id)])\r\n                        if self.fei4b:\r\n                            self.set_global_register_value(\"SR_Read\", 0)\r\n                            commands.extend(self.get_commands(\"WrRegister\", name=[\"SR_Read\"]))\r\n            self.restore(pixel_register=False)\r\n            commands.extend(self.get_commands(\"WrRegister\", name=registers))\r\n        else:\r\n            commands.append(self.build_command(command_name, ChipID=chip_id, **kwargs))\r\n        return commands"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding command from command_name and keyword values Returns list of bitarrays.", "response": "def build_command(self, command_name, **kwargs):\r\n        \"\"\"build command from command_name and keyword values\r\n\r\n        Returns\r\n        -------\r\n        command_bitvector : list\r\n            List of bitarrays.\r\n\r\n        Usage\r\n        -----\r\n        Receives: command name as defined inside xml file, key-value-pairs as defined inside bit stream filed for each command\r\n        \"\"\"\r\n#         command_name = command_name.lower()\r\n        command_bitvector = bitarray(0, endian='little')\r\n        if command_name not in self.commands:\r\n            raise ValueError('Unknown command %s' % command_name)\r\n        command_object = self.commands[command_name]\r\n        command_parts = re.split(r'\\s*[+]\\s*', command_object['bitstream'])\r\n        # for index, part in enumerate(command_parts, start = 1): # loop over command parts\r\n        for part in command_parts:  # loop over command parts\r\n            try:\r\n                command_part_object = self.commands[part]\r\n            except KeyError:\r\n                command_part_object = None\r\n            if command_part_object and 'bitstream'in command_part_object:  # command parts of defined content and length, e.g. Slow, ...\r\n                if string_is_binary(command_part_object['bitstream']):\r\n                    command_bitvector += bitarray(command_part_object['bitstream'], endian='little')\r\n                else:\r\n                    command_bitvector += self.build_command(part, **kwargs)\r\n            elif command_part_object:  # Command parts with any content of defined length, e.g. ChipID, Address, ...\r\n                if part in kwargs:\r\n                    value = kwargs[part]\r\n                else:\r\n                    raise ValueError('Value of command part %s not given' % part)\r\n                try:\r\n                    command_bitvector += value\r\n                except TypeError:  # value is no bitarray\r\n                    if string_is_binary(value):\r\n                        value = int(value, 2)\r\n                    try:\r\n                        command_bitvector += bitarray_from_value(value=int(value), size=command_part_object['bitlength'], fmt='I')\r\n                    except Exception:\r\n                        raise TypeError(\"Type of value not supported\")\r\n            elif string_is_binary(part):\r\n                command_bitvector += bitarray(part, endian='little')\r\n            # elif part in kwargs.keys():\r\n            #    command_bitvector += kwargs[command_name]\r\n            else:\r\n                raise ValueError(\"Cannot process command part %s\" % part)\r\n        if command_bitvector.length() != command_object['bitlength']:\r\n            raise ValueError(\"Command has unexpected length\")\r\n        if command_bitvector.length() == 0:\r\n            raise ValueError(\"Command has length 0\")\r\n        return command_bitvector"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of attributes that are not in the global register.", "response": "def get_global_register_attributes(self, register_attribute, do_sort=True, **kwargs):\r\n        \"\"\"Calculating register numbers from register names.\r\n\r\n        Usage: get_global_register_attributes(\"attribute_name\", name = [regname_1, regname_2, ...], addresses = 2)\r\n        Receives: attribute name to be returned, dictionaries (kwargs) of register attributes and values for making cuts\r\n        Returns: list of attribute values that matches dictionaries of attributes\r\n\r\n        \"\"\"\r\n        # speed up of the most often used keyword name\r\n        try:\r\n            names = iterable(kwargs.pop('name'))\r\n        except KeyError:\r\n            register_attribute_list = []\r\n        else:\r\n            register_attribute_list = [self.global_registers[reg][register_attribute] for reg in names]\r\n        for keyword in kwargs.keys():\r\n            allowed_values = iterable(kwargs[keyword])\r\n            try:\r\n                register_attribute_list.extend(map(itemgetter(register_attribute), filter(lambda global_register: set(iterable(global_register[keyword])).intersection(allowed_values), self.global_registers.itervalues())))\r\n            except AttributeError:\r\n                pass\r\n        if not register_attribute_list and filter(None, kwargs.itervalues()):\r\n            raise ValueError('Global register attribute %s empty' % register_attribute)\r\n        if do_sort:\r\n            return sorted(set(flatten_iterable(register_attribute_list)))\r\n        else:\r\n            return flatten_iterable(register_attribute_list)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating register objects from register names list", "response": "def get_global_register_objects(self, do_sort=None, reverse=False, **kwargs):\r\n        \"\"\"Generate register objects (list) from register name list\r\n\r\n        Usage: get_global_register_objects(name = [\"Amp2Vbn\", \"GateHitOr\", \"DisableColumnCnfg\"], address = [2, 3])\r\n        Receives: keyword lists of register names, addresses,... for making cuts\r\n        Returns: list of register objects\r\n\r\n        \"\"\"\r\n        # speed up of the most often used keyword name\r\n        try:\r\n            names = iterable(kwargs.pop('name'))\r\n        except KeyError:\r\n            register_objects = []\r\n        else:\r\n            register_objects = [self.global_registers[reg] for reg in names]\r\n        for keyword in kwargs.iterkeys():\r\n            allowed_values = iterable(kwargs[keyword])\r\n            register_objects.extend(filter(lambda global_register: set(iterable(global_register[keyword])).intersection(allowed_values), self.global_registers.itervalues()))\r\n        if not register_objects and filter(None, kwargs.itervalues()):\r\n            raise ValueError('Global register objects empty')\r\n        if do_sort:\r\n            return sorted(register_objects, key=itemgetter(*do_sort), reverse=reverse)\r\n        else:\r\n            return register_objects"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_global_register_bitsets(self, register_addresses):  # TOTO: add sorting\r\n        register_bitsets = []\r\n        for register_address in register_addresses:\r\n            register_objects = self.get_global_register_objects(addresses=register_address)\r\n            register_bitset = bitarray(16, endian='little')  # TODO remove hardcoded register size, see also below\r\n            register_bitset.setall(0)\r\n            register_littleendian = False\r\n            for register_object in register_objects:\r\n                if register_object['register_littleendian']:  # check for register endianness\r\n                    register_littleendian = True\r\n                if (16 * register_object['address'] + register_object['offset'] < 16 * (register_address + 1) and 16 * register_object['address'] + register_object['offset'] + register_object['bitlength'] > 16 * register_address):\r\n                    reg = bitarray_from_value(value=register_object['value'], size=register_object['bitlength'])\r\n                    if register_object['littleendian']:\r\n                        reg.reverse()\r\n# register_bitset[max(0, 16 * (register_object['address'] - register_address) + register_object['offset']):min(16, 16 * (register_object['address'] - register_address) + register_object['offset'] + register_object['bitlength'])] |= reg[max(0, 16 * (register_address - register_object['address']) - register_object['offset']):min(register_object['bitlength'], 16 * (register_address - register_object['address'] + 1) - register_object['offset'])]  # [ bit(n) bit(n-1)... bit(0) ]\r\n                    register_bitset[max(0, 16 - 16 * (register_object['address'] - register_address) - register_object['offset'] - register_object['bitlength']):min(16, 16 - 16 * (register_object['address'] - register_address) - register_object['offset'])] |= reg[max(0, register_object['bitlength'] - 16 - 16 * (register_address - register_object['address']) + register_object['offset']):min(register_object['bitlength'], register_object['bitlength'] + 16 - 16 * (register_address - register_object['address'] + 1) + register_object['offset'])]  # [ bit(0)... bit(n-1) bit(n) ]\r\n                else:\r\n                    raise Exception(\"wrong register object\")\r\n            if register_littleendian:\r\n                register_bitset.reverse()\r\n            register_bitsets.append(register_bitset)\r\n        return register_bitsets", "response": "This function returns a list of register bitsets that are in the global register table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_pixel_register_objects(self, do_sort=None, reverse=False, **kwargs):\r\n        # speed up of the most often used keyword name\r\n        try:\r\n            names = iterable(kwargs.pop('name'))\r\n        except KeyError:\r\n            register_objects = []\r\n        else:\r\n            register_objects = [self.pixel_registers[reg] for reg in names]\r\n        for keyword in kwargs.iterkeys():\r\n            allowed_values = iterable(kwargs[keyword])\r\n            register_objects.extend(filter(lambda pixel_register: pixel_register[keyword] in allowed_values, self.pixel_registers.itervalues()))\r\n        if not register_objects and filter(None, kwargs.itervalues()):\r\n            raise ValueError('Pixel register objects empty')\r\n        if do_sort:\r\n            return sorted(register_objects, key=itemgetter(*do_sort), reverse=reverse)\r\n        else:\r\n            return register_objects", "response": "Generate register objects from register name list"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_pixel_register_bitset(self, register_object, bit_no, dc_no):\r\n        if not 0 <= dc_no < 40:\r\n            raise ValueError(\"Pixel register %s: DC out of range\" % register_object['name'])\r\n        if not 0 <= bit_no < register_object['bitlength']:\r\n            raise ValueError(\"Pixel register %s: bit number out of range\" % register_object['name'])\r\n        col0 = register_object['value'][dc_no * 2, :]\r\n        sel0 = (2 ** bit_no == (col0 & 2 ** bit_no))\r\n        bv0 = bitarray(sel0.tolist(), endian='little')\r\n        col1 = register_object['value'][dc_no * 2 + 1, :]\r\n        sel1 = (2 ** bit_no == (col1 & 2 ** bit_no))\r\n        # sel1 = sel1.astype(numpy.uint8) # copy of array\r\n        # sel1 = sel1.view(dtype=np.uint8) # in-place type conversion\r\n        bv1 = bitarray(sel1.tolist(), endian='little')\r\n        bv1.reverse()  # shifted first\r\n        # bv = bv1+bv0\r\n        return bv1 + bv0", "response": "This function calculates the bitset of the specified register bit number from the given double column number."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_restore_point(self, name=None):\r\n        '''Creating a configuration restore point.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the restore point. If not given, a md5 hash will be generated.\r\n        '''\r\n        if name is None:\r\n            for i in iter(int, 1):\r\n                name = datetime.datetime.utcnow().strftime('%Y%m%d%H%M%S%f') + '_' + str(i)\r\n                try:\r\n                    self.config_state[name]\r\n                except KeyError:\r\n                    break\r\n                else:\r\n                    pass\r\n        if name in self.config_state:\r\n            raise ValueError('Restore point %s already exists' % name)\r\n        self.config_state[name] = (copy.deepcopy(self.global_registers), copy.deepcopy(self.pixel_registers))\r\n        return name", "response": "Creates a new configuration restore point."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef restore(self, name=None, keep=False, last=True, global_register=True, pixel_register=True):\r\n        '''Restoring a configuration restore point.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the restore point. If not given, a md5 hash will be generated.\r\n        keep : bool\r\n            Keeping restore point for later use.\r\n        last : bool\r\n            If name is not given, the latest restore point will be taken.\r\n        global_register : bool\r\n            Restore global register.\r\n        pixel_register : bool\r\n            Restore pixel register.\r\n        '''\r\n        if name is None:\r\n            if keep:\r\n                name = next(reversed(self.config_state)) if last else next(iter(self.config_state))\r\n                value = self.config_state[name]\r\n            else:\r\n                name, value = self.config_state.popitem(last=last)\r\n        else:\r\n            value = self.config_state[name]\r\n            if not keep:\r\n                value = copy.deepcopy(value)  # make a copy before deleting object\r\n                del self.config_state[name]\r\n\r\n        if global_register:\r\n            self.global_registers = copy.deepcopy(value[0])\r\n        if pixel_register:\r\n            self.pixel_registers = copy.deepcopy(value[1])", "response": "Restores a configuration restore point."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclearing all configuration restore points and point.", "response": "def clear_restore_points(self, name=None):\r\n        '''Deleting all/a configuration restore points/point.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the restore point to be deleted. If not given, all restore points will be deleted.\r\n        '''\r\n        if name is None:\r\n            self.config_state.clear()\r\n        else:\r\n            del self.config_state[name]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_configuration_dict(h5_file, configuation_name, configuration, **kwargs):\r\n    '''Stores any configuration dictionary to HDF5 file.\r\n\r\n    Parameters\r\n    ----------\r\n    h5_file : string, file\r\n        Filename of the HDF5 configuration file or file object.\r\n    configuation_name : str\r\n        Configuration name. Will be used for table name.\r\n    configuration : dict\r\n        Configuration dictionary.\r\n    '''\r\n    def save_conf():\r\n        try:\r\n            h5_file.remove_node(h5_file.root.configuration, name=configuation_name)\r\n        except tb.NodeError:\r\n            pass\r\n        try:\r\n            configuration_group = h5_file.create_group(h5_file.root, \"configuration\")\r\n        except tb.NodeError:\r\n            configuration_group = h5_file.root.configuration\r\n\r\n        scan_param_table = h5_file.create_table(configuration_group, name=configuation_name, description=NameValue, title=configuation_name)\r\n        row_scan_param = scan_param_table.row\r\n        for key, value in dict.iteritems(configuration):\r\n            row_scan_param['name'] = key\r\n            row_scan_param['value'] = str(value)\r\n            row_scan_param.append()\r\n        scan_param_table.flush()\r\n\r\n    if isinstance(h5_file, tb.file.File):\r\n        save_conf()\r\n    else:\r\n        if os.path.splitext(h5_file)[1].strip().lower() != \".h5\":\r\n            h5_file = os.path.splitext(h5_file)[0] + \".h5\"\r\n        with tb.open_file(h5_file, mode=\"a\", title='', **kwargs) as h5_file:\r\n            save_conf()", "response": "Stores any configuration dictionary to HDF5 file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfilter and convert raw data numpy array.", "response": "def convert_data_array(array, filter_func=None, converter_func=None):  # TODO: add copy parameter, otherwise in-place\r\n    '''Filter and convert raw data numpy array (numpy.ndarray).\r\n\r\n    Parameters\r\n    ----------\r\n    array : numpy.array\r\n        Raw data array.\r\n    filter_func : function\r\n        Function that takes array and returns true or false for each item in array.\r\n    converter_func : function\r\n        Function that takes array and returns an array or tuple of arrays.\r\n\r\n    Returns\r\n    -------\r\n    data_array : numpy.array\r\n        Data numpy array of specified dimension (converter_func) and content (filter_func)\r\n    '''\r\n#     if filter_func != None:\r\n#         if not hasattr(filter_func, '__call__'):\r\n#             raise ValueError('Filter is not callable')\r\n    if filter_func:\r\n        array = array[filter_func(array)]\r\n#     if converter_func != None:\r\n#         if not hasattr(converter_func, '__call__'):\r\n#             raise ValueError('Converter is not callable')\r\n    if converter_func:\r\n        array = converter_func(array)\r\n    return array"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert raw data in data iterable.", "response": "def convert_data_iterable(data_iterable, filter_func=None, converter_func=None):  # TODO: add concatenate parameter\r\n    '''Convert raw data in data iterable.\r\n\r\n    Parameters\r\n    ----------\r\n    data_iterable : iterable\r\n        Iterable where each element is a tuple with following content: (raw data, timestamp_start, timestamp_stop, status).\r\n    filter_func : function\r\n        Function that takes array and returns true or false for each item in array.\r\n    converter_func : function\r\n        Function that takes array and returns an array or tuple of arrays.\r\n\r\n    Returns\r\n    -------\r\n    data_list : list\r\n        Data list of the form [(converted data, timestamp_start, timestamp_stop, status), (...), ...]\r\n    '''\r\n    data_list = []\r\n    for item in data_iterable:\r\n        data_list.append((convert_data_array(item[0], filter_func=filter_func, converter_func=converter_func), item[1], item[2], item[3]))\r\n    return data_list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef data_array_from_data_iterable(data_iterable):\r\n    '''Convert data iterable to raw data numpy array.\r\n\r\n    Parameters\r\n    ----------\r\n    data_iterable : iterable\r\n        Iterable where each element is a tuple with following content: (raw data, timestamp_start, timestamp_stop, status).\r\n\r\n    Returns\r\n    -------\r\n    data_array : numpy.array\r\n        concatenated data array\r\n    '''\r\n    try:\r\n        data_array = np.concatenate([item[0] for item in data_iterable])\r\n    except ValueError:  # length is 0\r\n        data_array = np.empty(0, dtype=np.uint32)\r\n    return data_array", "response": "Convert data iterable to raw data numpy array.\r\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting TDC words at a given channel to common TDC header ( 0x4.", "response": "def convert_tdc_to_channel(channel):\r\n    ''' Converts TDC words at a given channel to common TDC header (0x4).\r\n    '''\r\n    def f(value):\r\n        filter_func = logical_and(is_tdc_word, is_tdc_from_channel(channel))\r\n        select = filter_func(value)\r\n        value[select] = np.bitwise_and(value[select], 0x0FFFFFFF)\r\n        value[select] = np.bitwise_or(value[select], 0x40000000)\r\n        f.__name__ = \"convert_tdc_to_channel_\" + str(channel)\r\n        return value\r\n    return f"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a function that returns True if the FE data is from the given channel.", "response": "def is_data_from_channel(channel=4):  # function factory\r\n    '''Selecting FE data from given channel.\r\n\r\n    Parameters\r\n    ----------\r\n    channel : int\r\n        Channel number (4 is default channel on Single Chip Card).\r\n\r\n    Returns\r\n    -------\r\n    Function.\r\n\r\n    Usage:\r\n    1 Selecting FE data from channel 4 (combine with is_fe_word):\r\n        filter_fe_data_from_channel_4 = logical_and(is_fe_word, is_data_from_channel(4))\r\n        fe_data_from_channel_4 = data_array[filter_fe_data_from_channel_4(data_array)]\r\n    2 Sleceting data from channel 4:\r\n        filter_data_from_channel_4 = is_data_from_channel(4)\r\n        data_from_channel_4 = data_array[filter_data_from_channel_4(fe_data_array)]\r\n    3 Sleceting data from channel 4:\r\n        data_from_channel_4 = is_data_from_channel(4)(fe_raw_data)\r\n\r\n    Other usage:\r\n    f_ch4 = functoools.partial(is_data_from_channel, channel=4)\r\n    l_ch4 = lambda x: is_data_from_channel(x, channel=4)\r\n    '''\r\n    if channel >= 0 and channel < 16:\r\n        def f(value):\r\n            return np.equal(np.right_shift(np.bitwise_and(value, 0x0F000000), 24), channel)\r\n        f.__name__ = \"is_data_from_channel_\" + str(channel)  # or use inspect module: inspect.stack()[0][3]\r\n        return f\r\n    else:\r\n        raise ValueError('Invalid channel number')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef logical_and(f1, f2):  # function factory\r\n    '''Logical and from functions.\r\n\r\n    Parameters\r\n    ----------\r\n    f1, f2 : function\r\n        Function that takes array and returns true or false for each item in array.\r\n\r\n    Returns\r\n    -------\r\n    Function.\r\n\r\n    Usage:\r\n    filter_func=logical_and(is_data_record, is_data_from_channel(4))  # new filter function\r\n    filter_func(array) # array that has Data Records from channel 4\r\n    '''\r\n    def f(value):\r\n        return np.logical_and(f1(value), f2(value))\r\n    f.__name__ = \"(\" + f1.__name__ + \"_and_\" + f2.__name__ + \")\"\r\n    return f", "response": "Logical and from functions.\r\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a function that returns true or false for each item in array f1 and f2.", "response": "def logical_or(f1, f2):  # function factory\r\n    '''Logical or from functions.\r\n\r\n    Parameters\r\n    ----------\r\n    f1, f2 : function\r\n        Function that takes array and returns true or false for each item in array.\r\n\r\n    Returns\r\n    -------\r\n    Function.\r\n    '''\r\n    def f(value):\r\n        return np.logical_or(f1(value), f2(value))\r\n    f.__name__ = \"(\" + f1.__name__ + \"_or_\" + f2.__name__ + \")\"\r\n    return f"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef logical_not(f):  # function factory\r\n    '''Logical not from functions.\r\n\r\n    Parameters\r\n    ----------\r\n    f1, f2 : function\r\n        Function that takes array and returns true or false for each item in array.\r\n\r\n    Returns\r\n    -------\r\n    Function.\r\n    '''\r\n    def f(value):\r\n        return np.logical_not(f(value))\r\n    f.__name__ = \"not_\" + f.__name__\r\n    return f", "response": "Returns a function that returns true or false for each item in array f1 and f2."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef logical_xor(f1, f2):  # function factory\r\n    '''Logical xor from functions.\r\n\r\n    Parameters\r\n    ----------\r\n    f1, f2 : function\r\n        Function that takes array and returns true or false for each item in array.\r\n\r\n    Returns\r\n    -------\r\n    Function.\r\n    '''\r\n    def f(value):\r\n        return np.logical_xor(f1(value), f2(value))\r\n    f.__name__ = \"(\" + f1.__name__ + \"_xor_\" + f2.__name__ + \")\"\r\n    return f", "response": "Logical xor from functions.\r\n\r\n    Parameters\r\n    ----------\r\n    f1, f2 : function\r\n        Function that takes array and returns true or false for each item in array.\r\n\r\n    Returns\r\n    -------\r\n    Function."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns 31bit timestamp and 16bit trigger counter", "response": "def get_trigger_data(value, mode=0):\r\n    '''Returns 31bit trigger counter (mode=0), 31bit timestamp (mode=1), 15bit timestamp and 16bit trigger counter (mode=2)\r\n    '''\r\n    if mode == 2:\r\n        return np.right_shift(np.bitwise_and(value, 0x7FFF0000), 16), np.bitwise_and(value, 0x0000FFFF)\r\n    else:\r\n        return np.bitwise_and(value, 0x7FFFFFFF)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_col_row_tot_array_from_data_record_array(array):  # TODO: max ToT\r\n    '''Convert raw data array to column, row, and ToT array.\r\n\r\n    Parameters\r\n    ----------\r\n    array : numpy.array\r\n        Raw data array.\r\n\r\n    Returns\r\n    -------\r\n    Tuple of arrays.\r\n    '''\r\n    def get_col_row_tot_1_array_from_data_record_array(value):\r\n        return np.right_shift(np.bitwise_and(value, 0x00FE0000), 17), np.right_shift(np.bitwise_and(value, 0x0001FF00), 8), np.right_shift(np.bitwise_and(value, 0x000000F0), 4)\r\n\r\n    def get_col_row_tot_2_array_from_data_record_array(value):\r\n        return np.right_shift(np.bitwise_and(value, 0x00FE0000), 17), np.add(np.right_shift(np.bitwise_and(value, 0x0001FF00), 8), 1), np.bitwise_and(value, 0x0000000F)\r\n\r\n    col_row_tot_1_array = np.column_stack(get_col_row_tot_1_array_from_data_record_array(array))\r\n    col_row_tot_2_array = np.column_stack(get_col_row_tot_2_array_from_data_record_array(array))\r\n    # interweave array here\r\n    col_row_tot_array = np.vstack((col_row_tot_1_array.T, col_row_tot_2_array.T)).reshape((3, -1), order='F').T  # http://stackoverflow.com/questions/5347065/interweaving-two-numpy-arrays\r\n    # remove ToT > 14 (late hit, no hit) from array, remove row > 336 in case we saw hit in row 336 (no double hit possible)\r\n    try:\r\n        col_row_tot_array_filtered = col_row_tot_array[col_row_tot_array[:, 2] < 14]  # [np.logical_and(col_row_tot_array[:,2]<14, col_row_tot_array[:,1]<=336)]\r\n    except IndexError:\r\n        # logging.warning('Array is empty')\r\n        return np.array([], dtype=np.dtype('>u4')), np.array([], dtype=np.dtype('>u4')), np.array([], dtype=np.dtype('>u4'))\r\n    return col_row_tot_array_filtered[:, 0], col_row_tot_array_filtered[:, 1], col_row_tot_array_filtered[:, 2]", "response": "Convert raw data array to column row and ToT array."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes the raw data and interprets them. This includes consistency checks and pixel data matching.", "response": "def interpret_pixel_data(data, dc, pixel_array, invert=True):\r\n    '''Takes the pixel raw data and interprets them. This includes consistency checks and pixel/data matching.\r\n    The data has to come from one double column only but can have more than one pixel bit (e.g. TDAC = 5 bit).\r\n\r\n    Parameters\r\n    ----------\r\n    data : numpy.ndarray\r\n        The raw data words.\r\n    dc : int\r\n        The double column where the data is from.\r\n    pixel_array : numpy.ma.ndarray\r\n        The masked numpy.ndarrays to be filled. The masked is set to zero for pixels with valid data.\r\n    invert : boolean\r\n        Invert the read pixel data.\r\n    '''\r\n\r\n    # data validity cut, VR has to follow an AR\r\n    index_value = np.where(is_address_record(data))[0] + 1  # assume value record follows address record\r\n    index_value = index_value[is_value_record(data[index_value])]  # delete all non value records\r\n    index_address = index_value - 1  # calculate address record indices that are followed by an value record\r\n\r\n    # create the pixel address/value arrays\r\n    address = get_address_record_address(data[index_address])\r\n    value = get_value_record(data[index_address + 1])\r\n\r\n    # split array for each bit in pixel data, split is done on decreasing address values\r\n    address_split = np.array_split(address, np.where(np.diff(address.astype(np.int32)) < 0)[0] + 1)\r\n    value_split = np.array_split(value, np.where(np.diff(address.astype(np.int32)) < 0)[0] + 1)\r\n\r\n    if len(address_split) > 5:\r\n        pixel_array.mask[dc * 2, :] = True\r\n        pixel_array.mask[dc * 2 + 1, :] = True\r\n        logging.warning('Invalid pixel data for DC %d', dc)\r\n        return\r\n\r\n    mask = np.empty_like(pixel_array.data)  # BUG in numpy: pixel_array is de-masked if not .data is used\r\n    mask[:] = len(address_split)\r\n\r\n    for bit, (bit_address, bit_value) in enumerate(zip(address_split, value_split)):  # loop over all bits of the pixel data\r\n        # error output, pixel data is often corrupt for FE-I4A\r\n        if len(bit_address) == 0:\r\n            logging.warning('No pixel data for DC %d', dc)\r\n            continue\r\n        if len(bit_address) != 42:\r\n            logging.warning('Some pixel data missing for DC %d', dc)\r\n        if (np.any(bit_address > 672)):\r\n            RuntimeError('Pixel data corrupt for DC %d', dc)\r\n        # set pixel that occurred in the data stream\r\n        pixel = []\r\n        for i in bit_address:\r\n            pixel.extend(range(i - 15, i + 1))\r\n        pixel = np.array(pixel)\r\n\r\n        # create bit set array\r\n        value_new = bit_value.view(np.uint8)  # interpret 32 bit numpy array as uint8 to be able to use bit unpacking; byte unpacking is not supported yet\r\n        if invert:\r\n            value_new = np.invert(value_new)  # read back values are inverted\r\n        value_new = np.insert(value_new[::4], np.arange(len(value_new[1::4])), value_new[1::4])  # delete 0 padding\r\n        value_bit = np.unpackbits(value_new, axis=0)\r\n\r\n        if len(address_split) == 5:  # detect TDAC data, here the bit order is flipped\r\n            bit_set = len(address_split) - bit - 1\r\n        else:\r\n            bit_set = bit\r\n\r\n        pixel_array.data[dc * 2, pixel[pixel >= 336] - 336] = np.bitwise_or(pixel_array.data[dc * 2, pixel[pixel >= 336] - 336], np.left_shift(value_bit[pixel >= 336], bit_set))\r\n        pixel_array.data[dc * 2 + 1, pixel[pixel < 336]] = np.bitwise_or(pixel_array.data[dc * 2 + 1, pixel[pixel < 336]], np.left_shift(value_bit[pixel < 336], bit_set)[::-1])\r\n\r\n        mask[dc * 2, pixel[pixel >= 336] - 336] = mask[dc * 2, pixel[pixel >= 336] - 336] - 1\r\n        mask[dc * 2 + 1, pixel[pixel < 336]] = mask[dc * 2 + 1, pixel[pixel < 336]] - 1\r\n\r\n    pixel_array.mask[np.equal(mask, 0)] = False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_standard_settings(self):\n        '''Set all settings to their standard values.\n        '''\n        if self.is_open(self.out_file_h5):\n            self.out_file_h5.close()\n        self.out_file_h5 = None\n        self._setup_clusterizer()\n        self.chunk_size = 3000000\n        self.n_injections = None\n        self.trig_count = 0  # 0 trig_count = 16 BCID per trigger\n        self.max_tot_value = 13\n        self.vcal_c0, self.vcal_c1 = None, None\n        self.c_low, self.c_mid, self.c_high = None, None, None\n        self.c_low_mask, self.c_high_mask = None, None\n        self._filter_table = tb.Filters(complib='blosc', complevel=5, fletcher32=False)\n        warnings.simplefilter(\"ignore\", OptimizeWarning)\n        self.meta_event_index = None\n        self.fei4b = False\n        self.create_hit_table = False\n        self.create_empty_event_hits = False\n        self.create_meta_event_index = True\n        self.create_tot_hist = True\n        self.create_mean_tot_hist = False\n        self.create_tot_pixel_hist = True\n        self.create_rel_bcid_hist = True\n        self.correct_corrupted_data = False\n        self.create_error_hist = True\n        self.create_service_record_hist = True\n        self.create_occupancy_hist = True\n        self.create_meta_word_index = False\n        self.create_source_scan_hist = False\n        self.create_tdc_hist = False\n        self.create_tdc_counter_hist = False\n        self.create_tdc_pixel_hist = False\n        self.create_trigger_error_hist = False\n        self.create_threshold_hists = False\n        self.create_threshold_mask = True  # Threshold/noise histogram mask: masking all pixels out of bounds\n        self.create_fitted_threshold_mask = True  # Fitted threshold/noise histogram mask: masking all pixels out of bounds\n        self.create_fitted_threshold_hists = False\n        self.create_cluster_hit_table = False\n        self.create_cluster_table = False\n        self.create_cluster_size_hist = False\n        self.create_cluster_tot_hist = False\n        self.align_at_trigger = False  # use the trigger word to align the events\n        self.align_at_tdc = False  # use the trigger word to align the events\n        self.trigger_data_format = 0  # 0: 31bit trigger number, 1: 31bit trigger time stamp, 2: 15bit trigger time stamp + 16bit trigger number\n        self.use_tdc_trigger_time_stamp = False  # the tdc time stamp is the difference between trigger and tdc rising edge\n        self.max_tdc_delay = 255\n        self.max_trigger_number = 2 ** 16 - 1\n        self.set_stop_mode = False", "response": "Set all settings to their standard values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef trig_count(self, value):\n        self._trig_count = 16 if value == 0 else value\n        self.interpreter.set_trig_count(self._trig_count)", "response": "Set the number of BCIDs of one event."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the maximum ToT value that is considered to be a hit", "response": "def max_tot_value(self, value):\n        \"\"\"Set maximum ToT value that is considered to be a hit\"\"\"\n        self._max_tot_value = value\n        self.interpreter.set_max_tot(self._max_tot_value)\n        self.histogram.set_max_tot(self._max_tot_value)\n        self.clusterizer.set_max_hit_charge(self._max_tot_value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef interpret_word_table(self, analyzed_data_file=None, use_settings_from_file=True, fei4b=None):\n        '''Interprets the raw data word table of all given raw data files with the c++ library.\n        Creates the h5 output file and PDF plots.\n\n        Parameters\n        ----------\n        analyzed_data_file : string\n            The file name of the output analyzed data file. If None, the output analyzed data file\n            specified during initialization is taken.\n        use_settings_from_file : boolean\n            True if the needed parameters should be extracted from the raw data file\n        fei4b : boolean\n            True if the raw data is from FE-I4B.\n        '''\n\n        logging.info('Interpreting raw data file(s): ' + (', ').join(self.files_dict.keys()))\n\n        if self._create_meta_word_index:\n            meta_word = np.empty((self._chunk_size,), dtype=dtype_from_descr(data_struct.MetaInfoWordTable))\n            self.interpreter.set_meta_data_word_index(meta_word)\n        self.interpreter.reset_event_variables()\n        self.interpreter.reset_counters()\n\n        self.meta_data = analysis_utils.combine_meta_data(self.files_dict, meta_data_v2=self.interpreter.meta_table_v2)\n\n        if self.meta_data is None or self.meta_data.shape[0] == 0:\n            raise analysis_utils.IncompleteInputError('Meta data is empty. Stopping interpretation.')\n\n        self.interpreter.set_meta_data(self.meta_data)  # tell interpreter the word index per readout to be able to calculate the event number per read out\n        meta_data_size = self.meta_data.shape[0]\n        self.meta_event_index = np.zeros((meta_data_size,), dtype=[('metaEventIndex', np.uint64)])  # this array is filled by the interpreter and holds the event number per read out\n        self.interpreter.set_meta_event_data(self.meta_event_index)  # tell the interpreter the data container to write the meta event index to\n\n        if self.scan_parameters is None:\n            self.histogram.set_no_scan_parameter()\n        else:\n            self.scan_parameter_index = analysis_utils.get_scan_parameters_index(self.scan_parameters)  # a array that labels unique scan parameter combinations\n            self.histogram.add_scan_parameter(self.scan_parameter_index)  # just add an index for the different scan parameter combinations\n\n        if self._create_cluster_size_hist:  # Cluster size result histogram\n            self._cluster_size_hist = np.zeros(shape=(6, ), dtype=np.uint32)\n\n        if self._create_cluster_tot_hist:  # Cluster tot/size result histogram\n            self._cluster_tot_hist = np.zeros(shape=(16, 6), dtype=np.uint32)\n\n        close_analyzed_data_file = False\n        if analyzed_data_file is not None:  # if an output file name is specified create new file for analyzed data\n            if self.is_open(self.out_file_h5) and os.path.abspath(analyzed_data_file) == os.path.abspath(self.out_file_h5.filename):\n                out_file_h5 = self.out_file_h5\n            else:\n                # normalize path\n                analyzed_data_file = os.path.abspath(analyzed_data_file)\n                if os.path.splitext(analyzed_data_file)[1].lower() != \".h5\":\n                    analyzed_data_file = os.path.splitext(analyzed_data_file)[0] + \".h5\"\n                out_file_h5 = tb.open_file(analyzed_data_file, mode=\"w\", title=\"Interpreted FE-I4 raw data\")\n                close_analyzed_data_file = True\n        elif self.is_open(self.out_file_h5):\n                out_file_h5 = self.out_file_h5\n        else:\n            out_file_h5 = None\n\n        tmp_out_file_h5 = self.out_file_h5\n        if not self.is_open(self.out_file_h5) and self.is_open(out_file_h5):\n            close_analyzed_data_file = False\n            tmp_out_file_h5 = out_file_h5\n        self.out_file_h5 = out_file_h5\n        if self.is_open(self.out_file_h5):\n            self._analyzed_data_file = self.out_file_h5.filename\n        else:\n            self._analyzed_data_file is None\n\n        if self._analyzed_data_file is not None:\n            if self._create_hit_table is True:\n                description = data_struct.HitInfoTable().columns.copy()\n                hit_table = self.out_file_h5.create_table(self.out_file_h5.root, name='Hits', description=description, title='hit_data', filters=self._filter_table, chunkshape=(self._chunk_size / 100,))\n            if self._create_meta_word_index is True:\n                meta_word_index_table = self.out_file_h5.create_table(self.out_file_h5.root, name='EventMetaData', description=data_struct.MetaInfoWordTable, title='event_meta_data', filters=self._filter_table, chunkshape=(self._chunk_size / 10,))\n            if self._create_cluster_table:\n                cluster_table = self.out_file_h5.create_table(self.out_file_h5.root, name='Cluster', description=data_struct.ClusterInfoTable, title='Cluster data', filters=self._filter_table, expectedrows=self._chunk_size)\n            if self._create_cluster_hit_table:\n                description = data_struct.ClusterHitInfoTable().columns.copy()\n                cluster_hit_table = self.out_file_h5.create_table(self.out_file_h5.root, name='ClusterHits', description=description, title='cluster_hit_data', filters=self._filter_table, expectedrows=self._chunk_size)\n\n        logging.info(\"Interpreting raw data...\")\n        progress_bar = progressbar.ProgressBar(widgets=['', progressbar.Percentage(), ' ', progressbar.Bar(marker='*', left='|', right='|'), ' ', progressbar.AdaptiveETA()], maxval=analysis_utils.get_total_n_data_words(self.files_dict), term_width=80)\n        progress_bar.start()\n        total_words = 0\n\n        for file_index, raw_data_file in enumerate(self.files_dict.keys()):  # loop over all raw data files\n            self.interpreter.reset_meta_data_counter()\n            with tb.open_file(raw_data_file, mode=\"r\") as in_file_h5:\n                if use_settings_from_file:\n                    self._deduce_settings_from_file(in_file_h5)\n                else:\n                    self.fei4b = fei4b\n                if self.interpreter.meta_table_v2:\n                    index_start = in_file_h5.root.meta_data.read(field='index_start')\n                    index_stop = in_file_h5.root.meta_data.read(field='index_stop')\n                else:\n                    index_start = in_file_h5.root.meta_data.read(field='start_index')\n                    index_stop = in_file_h5.root.meta_data.read(field='stop_index')\n                bad_word_index = set()\n\n                # Check for bad data\n                if self._correct_corrupted_data:\n                    tw = 2147483648  # trigger word\n                    dh = 15269888  # data header\n                    is_fe_data_header = logical_and(is_fe_word, is_data_header)\n                    found_first_trigger = False\n                    readout_slices = np.column_stack((index_start, index_stop))\n                    previous_prepend_data_headers = None\n                    prepend_data_headers = None\n                    last_good_readout_index = None\n                    last_index_with_event_data = None\n                    for read_out_index, (index_start, index_stop) in enumerate(readout_slices):\n                        try:\n                            raw_data = in_file_h5.root.raw_data.read(index_start, index_stop)\n                        except OverflowError, e:\n                            pass\n                        except tb.exceptions.HDF5ExtError:\n                            break\n                        # previous data chunk had bad data, check for good data\n                        if (index_start - 1) in bad_word_index:\n                            bad_data, current_prepend_data_headers, _ , _ = check_bad_data(raw_data, prepend_data_headers=1, trig_count=None)\n                            if bad_data:\n                                bad_word_index = bad_word_index.union(range(index_start, index_stop))\n                            else:\n#                                 logging.info(\"found good data in %s from index %d to %d (chunk %d, length %d)\" % (in_file_h5.filename, index_start, index_stop, read_out_index, (index_stop - index_start)))\n                                if last_good_readout_index + 1 == read_out_index - 1:\n                                    logging.warning(\"found bad data in %s from index %d to %d (chunk %d, length %d)\" % (in_file_h5.filename, readout_slices[last_good_readout_index][1], readout_slices[read_out_index - 1][1], last_good_readout_index + 1, (readout_slices[read_out_index - 1][1] - readout_slices[last_good_readout_index][1])))\n                                else:\n                                    logging.warning(\"found bad data in %s from index %d to %d (chunk %d to %d, length %d)\" % (in_file_h5.filename, readout_slices[last_good_readout_index][1], readout_slices[read_out_index - 1][1], last_good_readout_index + 1, read_out_index - 1, (readout_slices[read_out_index - 1][1] - readout_slices[last_good_readout_index][1])))\n                                previous_good_raw_data = in_file_h5.root.raw_data.read(readout_slices[last_good_readout_index][0], readout_slices[last_good_readout_index][1] - 1)\n                                previous_bad_raw_data = in_file_h5.root.raw_data.read(readout_slices[last_good_readout_index][1] - 1, readout_slices[read_out_index - 1][1])\n                                fixed_raw_data, _ = fix_raw_data(previous_bad_raw_data, lsb_byte=None)\n                                fixed_raw_data = np.r_[previous_good_raw_data, fixed_raw_data, raw_data]\n                                _, prepend_data_headers, n_triggers, n_dh = check_bad_data(fixed_raw_data, prepend_data_headers=previous_prepend_data_headers, trig_count=self.trig_count)\n                                last_good_readout_index = read_out_index\n                                if n_triggers != 0 or n_dh != 0:\n                                    last_index_with_event_data = read_out_index\n                                    last_event_data_prepend_data_headers = prepend_data_headers\n                                fixed_previous_raw_data = np.r_[previous_good_raw_data, fixed_raw_data]\n                                _, previous_prepend_data_headers, _ , _ = check_bad_data(fixed_previous_raw_data, prepend_data_headers=previous_prepend_data_headers, trig_count=self.trig_count)\n                        # check for bad data\n                        else:\n                            # workaround for first data chunk, might have missing trigger in some rare cases (already fixed in firmware)\n                            if read_out_index == 0 and (np.any(is_trigger_word(raw_data) >= 1) or np.any(is_fe_data_header(raw_data) >= 1)):\n                                bad_data, current_prepend_data_headers, n_triggers , n_dh = check_bad_data(raw_data, prepend_data_headers=1, trig_count=None)\n                                # check for full last event in data\n                                if current_prepend_data_headers == self.trig_count:\n                                    current_prepend_data_headers = None\n                            # usually check for bad data happens here\n                            else:\n                                bad_data, current_prepend_data_headers, n_triggers , n_dh = check_bad_data(raw_data, prepend_data_headers=prepend_data_headers, trig_count=self.trig_count)\n\n                            # do additional check with follow up data chunk and decide whether current chunk is defect or not\n                            if bad_data:\n                                if read_out_index == 0:\n                                    fixed_raw_data_chunk, _ = fix_raw_data(raw_data, lsb_byte=None)\n                                    fixed_raw_data_list = [fixed_raw_data_chunk]\n                                else:\n                                    previous_raw_data = in_file_h5.root.raw_data.read(*readout_slices[read_out_index - 1])\n                                    raw_data_with_previous_data_word = np.r_[previous_raw_data[-1], raw_data]\n                                    fixed_raw_data_chunk, _ = fix_raw_data(raw_data_with_previous_data_word, lsb_byte=None)\n                                    fixed_raw_data = np.r_[previous_raw_data[:-1], fixed_raw_data_chunk]\n                                    # last data word of chunk before broken chunk migh be a trigger word or data header which cannot be recovered\n                                    fixed_raw_data_with_tw = np.r_[previous_raw_data[:-1], tw, fixed_raw_data_chunk]\n                                    fixed_raw_data_with_dh = np.r_[previous_raw_data[:-1], dh, fixed_raw_data_chunk]\n                                    fixed_raw_data_list = [fixed_raw_data, fixed_raw_data_with_tw, fixed_raw_data_with_dh]\n                                bad_fixed_data, _, _ , _ = check_bad_data(fixed_raw_data_with_dh, prepend_data_headers=previous_prepend_data_headers, trig_count=self.trig_count)\n                                bad_fixed_data = map(lambda data: check_bad_data(data, prepend_data_headers=previous_prepend_data_headers, trig_count=self.trig_count)[0], fixed_raw_data_list)\n                                if not all(bad_fixed_data): # good fixed data\n                                    # last word in chunk before currrent chunk is also bad\n                                    if index_start != 0:\n                                        bad_word_index.add(index_start - 1)\n                                    # adding all word from current chunk\n                                    bad_word_index = bad_word_index.union(range(index_start, index_stop))\n                                    last_good_readout_index = read_out_index - 1\n                                else:\n                                    # a previous chunk might be broken and the last data word becomes a trigger word, so do additional checks\n                                    if last_index_with_event_data and last_event_data_prepend_data_headers != read_out_index:\n                                        before_bad_raw_data = in_file_h5.root.raw_data.read(readout_slices[last_index_with_event_data - 1][0], readout_slices[last_index_with_event_data - 1][1] - 1)\n                                        previous_bad_raw_data = in_file_h5.root.raw_data.read(readout_slices[last_index_with_event_data][0] - 1, readout_slices[last_index_with_event_data][1])\n                                        fixed_raw_data, _ = fix_raw_data(previous_bad_raw_data, lsb_byte=None)\n                                        previous_good_raw_data = in_file_h5.root.raw_data.read(readout_slices[last_index_with_event_data][1], readout_slices[read_out_index - 1][1])\n                                        fixed_raw_data = np.r_[before_bad_raw_data, fixed_raw_data, previous_good_raw_data, raw_data]\n                                        bad_fixed_previous_data, current_prepend_data_headers, _, _ = check_bad_data(fixed_raw_data, prepend_data_headers=last_event_data_prepend_data_headers, trig_count=self.trig_count)\n                                        if not bad_fixed_previous_data:\n                                            logging.warning(\"found bad data in %s from index %d to %d (chunk %d, length %d)\" % (in_file_h5.filename, readout_slices[last_index_with_event_data][0], readout_slices[last_index_with_event_data][1], last_index_with_event_data, (readout_slices[last_index_with_event_data][1] - readout_slices[last_index_with_event_data][0])))\n                                            bad_word_index = bad_word_index.union(range(readout_slices[last_index_with_event_data][0] - 1, readout_slices[last_index_with_event_data][1]))\n                                        else:\n                                            logging.warning(\"found bad data which cannot be corrected in %s from index %d to %d (chunk %d, length %d)\" % (in_file_h5.filename, index_start, index_stop, read_out_index, (index_stop - index_start)))\n                                    else:\n                                        logging.warning(\"found bad data which cannot be corrected in %s from index %d to %d (chunk %d, length %d)\" % (in_file_h5.filename, index_start, index_stop, read_out_index, (index_stop - index_start)))\n                            if n_triggers != 0 or n_dh != 0:\n                                last_index_with_event_data = read_out_index\n                                last_event_data_prepend_data_headers = prepend_data_headers\n                            if not bad_data or (bad_data and bad_fixed_data):\n                                previous_prepend_data_headers = prepend_data_headers\n                                prepend_data_headers = current_prepend_data_headers\n\n                    consecutive_bad_words_list = consecutive(sorted(bad_word_index))\n\n                lsb_byte = None\n                # Loop over raw data in chunks\n                for word_index in range(0, in_file_h5.root.raw_data.shape[0], self._chunk_size):  # loop over all words in the actual raw data file\n                    try:\n                        raw_data = in_file_h5.root.raw_data.read(word_index, word_index + self._chunk_size)\n                    except OverflowError, e:\n                        logging.error('%s: 2^31 xrange() limitation in 32-bit Python', e)\n                    except tb.exceptions.HDF5ExtError:\n                        logging.warning('Raw data file %s has missing raw data. Continue raw data analysis.', in_file_h5.filename)\n                        break\n                    total_words += raw_data.shape[0]\n                    # fix bad data\n                    if self._correct_corrupted_data:\n                        # increase word shift for every bad data chunk in raw data chunk\n                        word_shift = 0\n                        chunk_indices = np.arange(word_index, word_index + self._chunk_size)\n                        for consecutive_bad_word_indices in consecutive_bad_words_list:\n                            selected_words = np.intersect1d(consecutive_bad_word_indices, chunk_indices, assume_unique=True)\n                            if selected_words.shape[0]:\n                                fixed_raw_data, lsb_byte = fix_raw_data(raw_data[selected_words - word_index - word_shift], lsb_byte=lsb_byte)\n                                raw_data = np.r_[raw_data[:selected_words[0] - word_index - word_shift], fixed_raw_data, raw_data[selected_words[-1] - word_index + 1 - word_shift:]]\n                                # check if last word of bad data chunk in current raw data chunk\n                                if consecutive_bad_word_indices[-1] in selected_words:\n                                    lsb_byte = None\n                                    # word shift by removing data word at the beginning of each defect chunk\n                                    word_shift += 1\n                                # bad data chunk is at the end of current raw data chunk\n                                else:\n                                    break\n\n                    self.interpreter.interpret_raw_data(raw_data)  # interpret the raw data\n                    # store remaining buffered event in the interpreter at the end of the last file\n                    if file_index == len(self.files_dict.keys()) - 1 and word_index == range(0, in_file_h5.root.raw_data.shape[0], self._chunk_size)[-1]:  # store hits of the latest event of the last file\n                        self.interpreter.store_event()\n                    hits = self.interpreter.get_hits()\n                    if self.scan_parameters is not None:\n                        nEventIndex = self.interpreter.get_n_meta_data_event()\n                        self.histogram.add_meta_event_index(self.meta_event_index, nEventIndex)\n                    if self.is_histogram_hits():\n                        self.histogram_hits(hits)\n                    if self.is_cluster_hits():\n                        cluster_hits, clusters = self.cluster_hits(hits)\n                        if self._create_cluster_hit_table:\n                            cluster_hit_table.append(cluster_hits)\n                        if self._create_cluster_table:\n                            cluster_table.append(clusters)\n                        if self._create_cluster_size_hist:\n                            if clusters['size'].shape[0] > 0 and np.max(clusters['size']) + 1 > self._cluster_size_hist.shape[0]:\n                                self._cluster_size_hist.resize(np.max(clusters['size']) + 1)\n                            self._cluster_size_hist += fast_analysis_utils.hist_1d_index(clusters['size'], shape=self._cluster_size_hist.shape)\n                        if self._create_cluster_tot_hist:\n                            if clusters['tot'].shape[0] > 0 and np.max(clusters['tot']) + 1 > self._cluster_tot_hist.shape[0]:\n                                self._cluster_tot_hist.resize((np.max(clusters['tot']) + 1, self._cluster_tot_hist.shape[1]))\n                            if clusters['size'].shape[0] > 0 and np.max(clusters['size']) + 1 > self._cluster_tot_hist.shape[1]:\n                                self._cluster_tot_hist.resize((self._cluster_tot_hist.shape[0], np.max(clusters['size']) + 1))\n                            self._cluster_tot_hist += fast_analysis_utils.hist_2d_index(clusters['tot'], clusters['size'], shape=self._cluster_tot_hist.shape)\n                    if self._analyzed_data_file is not None and self._create_hit_table:\n                        hit_table.append(hits)\n                    if self._analyzed_data_file is not None and self._create_meta_word_index:\n                        size = self.interpreter.get_n_meta_data_word()\n                        meta_word_index_table.append(meta_word[:size])\n\n                    if total_words <= progress_bar.maxval:  # Otherwise exception is thrown\n                        progress_bar.update(total_words)\n                    self.out_file_h5.flush()\n        progress_bar.finish()\n        self._create_additional_data()\n\n        if close_analyzed_data_file:\n            self.out_file_h5.close()\n            self.out_file_h5 = None\n        self.out_file_h5 = out_file_h5\n        if self.is_open(self.out_file_h5):\n            self._analyzed_data_file = self.out_file_h5.filename\n        else:\n            self._analyzed_data_file = None", "response": "Interprets the raw data word table of all given raw data files with the c ++ library."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nanalyze a hit table with the c ++ histogrammming and clusterizer.", "response": "def analyze_hit_table(self, analyzed_data_file=None, analyzed_data_out_file=None):\n        '''Analyzes a hit table with the c++ histogrammming/clusterizer.\n\n        Parameters\n        ----------\n        analyzed_data_file : string\n            The filename of the analyzed data file. If None, the analyzed data file\n            specified during initialization is taken.\n            Filename extension (.h5) does not need to be provided.\n        analyzed_data_out_file : string\n            The filename of the new analyzed data file. If None, the analyzed data file\n            specified during initialization is taken.\n            Filename extension (.h5) does not need to be provided.\n        '''\n        close_analyzed_data_file = False\n        if analyzed_data_file is not None:  # if an output file name is specified create new file for analyzed data\n            if self.is_open(self.out_file_h5) and os.path.abspath(analyzed_data_file) == os.path.abspath(self.out_file_h5.filename):\n                in_file_h5 = self.out_file_h5\n            else:\n                # normalize path\n                analyzed_data_file = os.path.abspath(analyzed_data_file)\n                if os.path.splitext(analyzed_data_file)[1].lower() != \".h5\":\n                    analyzed_data_file = os.path.splitext(analyzed_data_file)[0] + \".h5\"\n                in_file_h5 = tb.open_file(analyzed_data_file, mode=\"r+\")\n                close_analyzed_data_file = True\n        elif self.is_open(self.out_file_h5):\n                in_file_h5 = self.out_file_h5\n        else:\n            raise ValueError('Parameter \"analyzed_data_file\" not specified.')\n\n        # set output file if an output file name is given, otherwise check if an output file is already opened\n        close_analyzed_data_out_file = False\n        if analyzed_data_out_file is not None:  # if an output file name is specified create new file for analyzed data\n            if self.is_open(self.out_file_h5) and os.path.abspath(analyzed_data_out_file) == os.path.abspath(self.out_file_h5.filename):\n                out_file_h5 = self.out_file_h5\n            elif self.is_open(in_file_h5) and os.path.abspath(analyzed_data_out_file) == os.path.abspath(in_file_h5.filename):\n                out_file_h5 = in_file_h5\n            else:\n                # normalize path\n                analyzed_data_out_file = os.path.abspath(analyzed_data_out_file)\n                if os.path.splitext(analyzed_data_out_file)[1].lower() != \".h5\":\n                    analyzed_data_out_file = os.path.splitext(analyzed_data_out_file)[0] + \".h5\"\n                out_file_h5 = tb.open_file(analyzed_data_out_file, mode=\"w\", title=\"Analyzed FE-I4 hits\")\n                close_analyzed_data_out_file = True\n        elif self.is_open(self.out_file_h5):\n                out_file_h5 = self.out_file_h5\n        else:\n            raise ValueError('Parameter \"analyzed_data_out_file\" not specified.')\n\n        tmp_out_file_h5 = self.out_file_h5\n        if not self.is_open(self.out_file_h5):\n            if os.path.abspath(in_file_h5.filename) == os.path.abspath(out_file_h5.filename):\n                close_analyzed_data_file = False\n                tmp_out_file_h5 = in_file_h5\n        self.out_file_h5 = out_file_h5\n        self._analyzed_data_file = self.out_file_h5.filename\n\n        if self._create_cluster_table:\n            cluster_table = self.out_file_h5.create_table(self.out_file_h5.root, name='Cluster', description=data_struct.ClusterInfoTable, title='cluster_hit_data', filters=self._filter_table, expectedrows=self._chunk_size)\n        if self._create_cluster_hit_table:\n            cluster_hit_table = self.out_file_h5.create_table(self.out_file_h5.root, name='ClusterHits', description=data_struct.ClusterHitInfoTable, title='cluster_hit_data', filters=self._filter_table, expectedrows=self._chunk_size)\n\n        if self._create_cluster_size_hist:  # Cluster size result histogram\n            self._cluster_size_hist = np.zeros(shape=(6, ), dtype=np.uint32)\n\n        if self._create_cluster_tot_hist:  # Cluster tot/size result histogram\n            self._cluster_tot_hist = np.zeros(shape=(16, 6), dtype=np.uint32)\n\n        try:\n            meta_data_table = in_file_h5.root.meta_data\n            meta_data = meta_data_table[:]\n            self.scan_parameters = analysis_utils.get_unique_scan_parameter_combinations(meta_data, scan_parameter_columns_only=True)\n            if self.scan_parameters is not None:  # check if there is an additional column after the error code column, if yes this column has scan parameter infos\n                meta_event_index = np.ascontiguousarray(analysis_utils.get_unique_scan_parameter_combinations(meta_data)['event_number'].astype(np.uint64))\n                self.histogram.add_meta_event_index(meta_event_index, array_length=len(meta_event_index))\n                self.scan_parameter_index = analysis_utils.get_scan_parameters_index(self.scan_parameters)  # a array that labels unique scan parameter combinations\n                self.histogram.add_scan_parameter(self.scan_parameter_index)  # just add an index for the different scan parameter combinations\n                scan_parameter_names = analysis_utils.get_scan_parameter_names(self.scan_parameters)\n                logging.info('Adding scan parameter(s) for analysis: %s', (', ').join(scan_parameter_names) if scan_parameter_names else 'None',)\n            else:\n                logging.info(\"No scan parameter data provided\")\n                self.histogram.set_no_scan_parameter()\n        except tb.exceptions.NoSuchNodeError:\n            logging.info(\"No meta data provided\")\n            self.histogram.set_no_scan_parameter()\n\n        table_size = in_file_h5.root.Hits.nrows\n        n_hits = 0  # number of hits in actual chunk\n\n        logging.info('Analyzing hits...')\n        progress_bar = progressbar.ProgressBar(widgets=['', progressbar.Percentage(), ' ', progressbar.Bar(marker='*', left='|', right='|'), ' ', progressbar.AdaptiveETA()], maxval=table_size, term_width=80)\n        progress_bar.start()\n\n        for hits, index in analysis_utils.data_aligned_at_events(in_file_h5.root.Hits, chunk_size=self._chunk_size):\n            n_hits += hits.shape[0]\n\n            if self.is_cluster_hits():\n                cluster_hits, clusters = self.cluster_hits(hits)\n\n            if self.is_histogram_hits():\n                self.histogram_hits(hits)\n\n            if self._analyzed_data_file is not None and self._create_cluster_hit_table:\n                cluster_hit_table.append(cluster_hits)\n            if self._analyzed_data_file is not None and self._create_cluster_table:\n                cluster_table.append(clusters)\n                if self._create_cluster_size_hist:\n                    if clusters['size'].shape[0] > 0 and np.max(clusters['size']) + 1 > self._cluster_size_hist.shape[0]:\n                        self._cluster_size_hist.resize(np.max(clusters['size']) + 1)\n                    self._cluster_size_hist += fast_analysis_utils.hist_1d_index(clusters['size'], shape=self._cluster_size_hist.shape)\n                if self._create_cluster_tot_hist:\n                    if clusters['tot'].shape[0] > 0 and np.max(clusters['tot']) + 1 > self._cluster_tot_hist.shape[0]:\n                        self._cluster_tot_hist.resize((np.max(clusters['tot']) + 1, self._cluster_tot_hist.shape[1]))\n                    if clusters['size'].shape[0] > 0 and np.max(clusters['size']) + 1 > self._cluster_tot_hist.shape[1]:\n                        self._cluster_tot_hist.resize((self._cluster_tot_hist.shape[0], np.max(clusters['size']) + 1))\n                    self._cluster_tot_hist += fast_analysis_utils.hist_2d_index(clusters['tot'], clusters['size'], shape=self._cluster_tot_hist.shape)\n            self.out_file_h5.flush()\n            progress_bar.update(index)\n        progress_bar.finish()\n\n        if table_size == 0:\n            logging.warning('Found no hits')\n\n        if n_hits != table_size:\n            raise analysis_utils.AnalysisError('Tables have different sizes. Not all hits were analyzed.')\n\n        self._create_additional_hit_data()\n        self._create_additional_cluster_data()\n        if close_analyzed_data_out_file:\n            out_file_h5.close()\n        if close_analyzed_data_file:\n            in_file_h5.close()\n        else:\n            self.out_file_h5 = tmp_out_file_h5\n        if self.is_open(self.out_file_h5):\n            self._analyzed_data_file = self.out_file_h5.filename\n        else:\n            self._analyzed_data_file = None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _deduce_settings_from_file(self, opened_raw_data_file):  # TODO: parse better\n        '''Tries to get the scan parameters needed for analysis from the raw data file\n        '''\n        try:  # take infos raw data files (not avalable in old files)\n            flavor = opened_raw_data_file.root.configuration.miscellaneous[:][np.where(opened_raw_data_file.root.configuration.miscellaneous[:]['name'] == 'Flavor')]['value'][0]\n            self._settings_from_file_set = True\n            # adding this for special cases e.g., stop-mode scan\n            if \"trig_count\" in opened_raw_data_file.root.configuration.run_conf[:]['name']:\n                trig_count = opened_raw_data_file.root.configuration.run_conf[:][np.where(opened_raw_data_file.root.configuration.run_conf[:]['name'] == 'trig_count')]['value'][0]\n            else:\n                trig_count = opened_raw_data_file.root.configuration.global_register[:][np.where(opened_raw_data_file.root.configuration.global_register[:]['name'] == 'Trig_Count')]['value'][0]\n            vcal_c0 = opened_raw_data_file.root.configuration.calibration_parameters[:][np.where(opened_raw_data_file.root.configuration.calibration_parameters[:]['name'] == 'Vcal_Coeff_0')]['value'][0]\n            vcal_c1 = opened_raw_data_file.root.configuration.calibration_parameters[:][np.where(opened_raw_data_file.root.configuration.calibration_parameters[:]['name'] == 'Vcal_Coeff_1')]['value'][0]\n            c_low = opened_raw_data_file.root.configuration.calibration_parameters[:][np.where(opened_raw_data_file.root.configuration.calibration_parameters[:]['name'] == 'C_Inj_Low')]['value'][0]\n            c_mid = opened_raw_data_file.root.configuration.calibration_parameters[:][np.where(opened_raw_data_file.root.configuration.calibration_parameters[:]['name'] == 'C_Inj_Med')]['value'][0]\n            c_high = opened_raw_data_file.root.configuration.calibration_parameters[:][np.where(opened_raw_data_file.root.configuration.calibration_parameters[:]['name'] == 'C_Inj_High')]['value'][0]\n            self.c_low_mask = opened_raw_data_file.root.configuration.C_Low[:]\n            self.c_high_mask = opened_raw_data_file.root.configuration.C_High[:]\n            self.fei4b = False if str(flavor) == 'fei4a' else True\n            self.trig_count = int(trig_count)\n            self.vcal_c0 = float(vcal_c0)\n            self.vcal_c1 = float(vcal_c1)\n            self.c_low = float(c_low)\n            self.c_mid = float(c_mid)\n            self.c_high = float(c_high)\n            self.n_injections = int(opened_raw_data_file.root.configuration.run_conf[:][np.where(opened_raw_data_file.root.configuration.run_conf[:]['name'] == 'n_injections')]['value'][0])\n        except tb.exceptions.NoSuchNodeError:\n            if not self._settings_from_file_set:\n                logging.warning('No settings stored in raw data file %s, use standard settings', opened_raw_data_file.filename)\n            else:\n                logging.info('No settings provided in raw data file %s, use already set settings', opened_raw_data_file.filename)\n        except IndexError:  # happens if setting is not available (e.g. repeat_command)\n            pass", "response": "Parses the raw data file and sets the settings to True."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_plsr_dac_charge(self, plsr_dac_array, no_offset=False):\n        '''Takes the PlsrDAC calibration and the stored C-high/C-low mask to calculate the charge from the PlsrDAC array on a pixel basis\n        '''\n        charge = np.zeros_like(self.c_low_mask, dtype=np.float16)  # charge in electrons\n        if self.vcal_c0 is not None and self.vcal_c1 is not None and self.c_low is not None and self.c_mid is not None and self.c_high is not None:\n            voltage = self.vcal_c1 * plsr_dac_array if no_offset else self.vcal_c0 + self.vcal_c1 * plsr_dac_array\n            charge[np.logical_and(self.c_low_mask, ~self.c_high_mask)] = voltage[np.logical_and(self.c_low_mask, ~self.c_high_mask)] * self.c_low / 0.16022\n            charge[np.logical_and(~self.c_low_mask, self.c_high_mask)] = voltage[np.logical_and(self.c_low_mask, ~self.c_high_mask)] * self.c_mid / 0.16022\n            charge[np.logical_and(self.c_low_mask, self.c_high_mask)] = voltage[np.logical_and(self.c_low_mask, ~self.c_high_mask)] * self.c_high / 0.16022\n        return charge", "response": "Calculates the charge from the stored PlsrDAC array and the stored C - high mask."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the fields of the resource.", "response": "def _parse_fields(self, result, field_name):\n        \"\"\" If Schema access, parse fields and build respective lists\n        \"\"\"\n        field_list = []\n        for key, value in result.get('schema', {}).get(field_name, {}).items():\n            if key not in field_list:\n                field_list.append(key)\n        return field_list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _build_fields(self):\n        declared_fields = self.solr._send_request('get', ADMIN_URL)\n        result = decoder.decode(declared_fields)\n        self.field_list = self._parse_fields(result, 'fields')\n\n        # Build regular expressions to match dynamic fields.\n        # dynamic field names may have exactly one wildcard, either at\n        # the beginning or the end of the name\n        self._dynamic_field_regexes = []\n        for wc_pattern in self._parse_fields(result, 'dynamicFields'):\n            if wc_pattern[0] == \"*\":\n                self._dynamic_field_regexes.append(\n                    re.compile(\".*%s\\Z\" % wc_pattern[1:]))\n            elif wc_pattern[-1] == \"*\":\n                self._dynamic_field_regexes.append(\n                    re.compile(\"\\A%s.*\" % wc_pattern[:-1]))", "response": "Builds a list of valid fields from the solr server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _clean_doc(self, doc, namespace, timestamp):\n\n        # Translate the _id field to whatever unique key we're using.\n        # _id may not exist in the doc, if we retrieved it from Solr\n        # as part of update.\n        if '_id' in doc:\n            doc[self.unique_key] = u(doc.pop(\"_id\"))\n\n        # Update namespace and timestamp metadata\n        if 'ns' in doc or '_ts' in doc:\n            raise errors.OperationFailed(\n                'Need to set \"ns\" and \"_ts\" fields, but these fields already '\n                'exist in the document %r!' % doc)\n        doc['ns'] = namespace\n        doc['_ts'] = timestamp\n\n        # SOLR cannot index fields within sub-documents, so flatten documents\n        # with the dot-separated path to each value as the respective key\n        flat_doc = self._formatter.format_document(doc)\n\n        # Only include fields that are explicitly provided in the\n        # schema or match one of the dynamic field patterns, if\n        # we were able to retrieve the schema\n        if len(self.field_list) + len(self._dynamic_field_regexes) > 0:\n            def include_field(field):\n                return field in self.field_list or any(\n                    regex.match(field) for regex in self._dynamic_field_regexes\n                )\n            return dict((k, v) for k, v in flat_doc.items() if include_field(k))\n        return flat_doc", "response": "Reformats the given document before insertion into Solr."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\noverride DocManagerBase. apply_update to have flat documents.", "response": "def apply_update(self, doc, update_spec):\n        \"\"\"Override DocManagerBase.apply_update to have flat documents.\"\"\"\n        # Replace a whole document\n        if not '$set' in update_spec and not '$unset' in update_spec:\n            # update_spec contains the new document.\n            # Update the key in Solr based on the unique_key mentioned as\n            # parameter.\n            update_spec['_id'] = doc[self.unique_key]\n            return update_spec\n        for to_set in update_spec.get(\"$set\", []):\n            value = update_spec['$set'][to_set]\n            # Find dotted-path to the value, remove that key from doc, then\n            # put value at key:\n            keys_to_pop = []\n            for key in doc:\n                if key.startswith(to_set):\n                    if key == to_set or key[len(to_set)] == '.':\n                        keys_to_pop.append(key)\n            for key in keys_to_pop:\n                doc.pop(key)\n            doc[to_set] = value\n        for to_unset in update_spec.get(\"$unset\", []):\n            # MongoDB < 2.5.2 reports $unset for fields that don't exist within\n            # the document being updated.\n            keys_to_pop = []\n            for key in doc:\n                if key.startswith(to_unset):\n                    if key == to_unset or key[len(to_unset)] == '.':\n                        keys_to_pop.append(key)\n            for key in keys_to_pop:\n                doc.pop(key)\n        return doc"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the document with the given id with the given update spec.", "response": "def update(self, document_id, update_spec, namespace, timestamp):\n        \"\"\"Apply updates given in update_spec to the document whose id\n        matches that of doc.\n\n        \"\"\"\n        # Commit outstanding changes so that the document to be updated is the\n        # same version to which the changes apply.\n        self.commit()\n        # Need to escape special characters in the document_id.\n        document_id = ''.join(map(\n            lambda c: '\\\\' + c if c in ESCAPE_CHARACTERS else c,\n            u(document_id)\n        ))\n\n        query = \"%s:%s\" % (self.unique_key, document_id)\n        results = self.solr.search(query)\n        if not len(results):\n            # Document may not be retrievable yet\n            self.commit()\n            results = self.solr.search(query)\n        # Results is an iterable containing only 1 result\n        for doc in results:\n            # Remove metadata previously stored by Mongo Connector.\n            doc.pop('ns')\n            doc.pop('_ts')\n            updated = self.apply_update(doc, update_spec)\n            # A _version_ of 0 will always apply the update\n            updated['_version_'] = 0\n            self.upsert(updated, namespace, timestamp)\n            return updated"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef upsert(self, doc, namespace, timestamp):\n        if self.auto_commit_interval is not None:\n            self.solr.add([self._clean_doc(doc, namespace, timestamp)],\n                          commit=(self.auto_commit_interval == 0),\n                          commitWithin=u(self.auto_commit_interval))\n        else:\n            self.solr.add([self._clean_doc(doc, namespace, timestamp)],\n                          commit=False)", "response": "Update or insert a document into Solr"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating or insert multiple documents into Solr", "response": "def bulk_upsert(self, docs, namespace, timestamp):\n        \"\"\"Update or insert multiple documents into Solr\n\n        docs may be any iterable\n        \"\"\"\n        if self.auto_commit_interval is not None:\n            add_kwargs = {\n                \"commit\": (self.auto_commit_interval == 0),\n                \"commitWithin\": str(self.auto_commit_interval)\n            }\n        else:\n            add_kwargs = {\"commit\": False}\n\n        cleaned = (self._clean_doc(d, namespace, timestamp) for d in docs)\n        if self.chunk_size > 0:\n            batch = list(next(cleaned) for i in range(self.chunk_size))\n            while batch:\n                self.solr.add(batch, **add_kwargs)\n                batch = list(next(cleaned)\n                             for i in range(self.chunk_size))\n        else:\n            self.solr.add(cleaned, **add_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves documents from Solr", "response": "def remove(self, document_id, namespace, timestamp):\n        \"\"\"Removes documents from Solr\n\n        The input is a python dictionary that represents a mongo document.\n        \"\"\"\n        self.solr.delete(id=u(document_id),\n                         commit=(self.auto_commit_interval == 0))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling to query Solr for documents in a time range.", "response": "def search(self, start_ts, end_ts):\n        \"\"\"Called to query Solr for documents in a time range.\"\"\"\n        query = '_ts: [%s TO %s]' % (start_ts, end_ts)\n        return self._stream_search(query)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_last_doc(self):\n        #search everything, sort by descending timestamp, return 1 row\n        try:\n            result = self.solr.search('*:*', sort='_ts desc', rows=1)\n        except ValueError:\n            return None\n\n        for r in result:\n            r['_id'] = r.pop(self.unique_key)\n            return r", "response": "Returns the last document stored in the Solr engine."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the result of the Password - based Key Derivation Function 2 with a single iteration.", "response": "def pbkdf2_single(password, salt, key_length, prf):\n    '''Returns the result of the Password-Based Key Derivation Function 2 with\n       a single iteration (i.e. count = 1).\n\n       prf - a psuedorandom function\n\n       See http://en.wikipedia.org/wiki/PBKDF2\n    '''\n\n    block_number = 0\n    result = b''\n\n    # The iterations\n    while len(result) < key_length:\n        block_number += 1\n        result += prf(password, salt + struct.pack('>L', block_number))\n\n    return result[:key_length]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the result of the scrypt password-based key derivation function. Constraints: r * p < (2 ** 30) dkLen <= (((2 ** 32) - 1) * 32 N must be a power of 2 greater than 1 (eg. 2, 4, 8, 16, 32...) N, r, p must be positive", "response": "def hash(password, salt, N, r, p, dkLen):\n    \"\"\"Returns the result of the scrypt password-based key derivation function.\n\n       Constraints:\n         r * p < (2 ** 30)\n         dkLen <= (((2 ** 32) - 1) * 32\n         N must be a power of 2 greater than 1 (eg. 2, 4, 8, 16, 32...)\n         N, r, p must be positive\n     \"\"\"\n\n    # This only matters to Python 3\n    if not check_bytes(password):\n        raise ValueError('password must be a byte array')\n\n    if not check_bytes(salt):\n        raise ValueError('salt must be a byte array')\n\n    # Scrypt implementation. Significant thanks to https://github.com/wg/scrypt\n    if N < 2 or (N & (N - 1)): raise ValueError('Scrypt N must be a power of 2 greater than 1')\n\n    # A psuedorandom function\n    prf = lambda k, m: hmac.new(key = k, msg = m, digestmod = hashlib.sha256).digest()\n\n    # convert into integers\n    B  = [ get_byte(c) for c in pbkdf2_single(password, salt, p * 128 * r, prf) ]\n    B = [ ((B[i + 3] << 24) | (B[i + 2] << 16) | (B[i + 1] << 8) | B[i + 0]) for i in xrange(0, len(B), 4)]\n\n    XY = [ 0 ] * (64 * r)\n    V  = [ 0 ] * (32 * r * N)\n\n    for i in xrange(0, p):\n        smix(B, i * 32 * r, r, N, V, XY)\n\n    # Convert back into bytes\n    Bc = [ ]\n    for i in B:\n        Bc.append((i >> 0) & 0xff)\n        Bc.append((i >> 8) & 0xff)\n        Bc.append((i >> 16) & 0xff)\n        Bc.append((i >> 24) & 0xff)\n\n    return pbkdf2_single(password, chars_to_bytes(Bc), dkLen, prf)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an internal attribute after ensuring the headers is loaded if necessary.", "response": "def _load_get_attr(self, name):\n        'Return an internal attribute after ensuring the headers is loaded if necessary.'\n        if self._mode in _allowed_read and self._N is None:\n            self._read_header()\n        return getattr(self, name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncloses the underlying file.", "response": "def close(self):\n        '''Close the underlying file.\n\n        Sets data attribute .closed to True. A closed file cannot be used for\n        further I/O operations. close() may be called more than once without\n        error. Some kinds of file objects (for example, opened by popen())\n        may return an exit status upon closing.'''\n\n        if self._mode in _allowed_write and self._valid is None:\n            self._finalize_write()\n        result = self._fp.close()\n        self._closed = True\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef verify_file(fp, password):\n        'Returns whether a scrypt encrypted file is valid.'\n\n        sf = ScryptFile(fp = fp, password = password)\n        for line in sf: pass\n        sf.close()\n        return sf.valid", "response": "Returns whether a scrypt encrypted file is valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readline(self, size = None):\n        '''Next line from the decrypted file, as a string.\n\n        Retain newline.  A non-negative size argument limits the maximum\n        number of bytes to return (an incomplete line may be returned then).\n        Return an empty string at EOF.'''\n\n        if self.closed: raise ValueError('file closed')\n        if self._mode in _allowed_write:\n            raise Exception('file opened for write only')\n        if self._read_finished: return None\n\n        line = b''\n        while not line.endswith(b'\\n') and not self._read_finished and (size is None or len(line) <= size):\n            line += self.read(1)\n        return line", "response": "Read a line from the decrypted file as a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading and parse the header and calculate derived keys.", "response": "def _read_header(self):\n        '''Read and parse the header and calculate derived keys.'''\n\n        try:\n            # Read the entire header\n            header = self._fp.read(96)\n            if len(header) != 96:\n                raise InvalidScryptFileFormat(\"Incomplete header\")\n\n            # Magic number\n            if header[0:6] != b'scrypt':\n                raise InvalidScryptFileFormat('Invalid magic number\").')\n\n            # Version (we only support 0)\n            version = get_byte(header[6])\n            if version != 0:\n                raise InvalidScryptFileFormat('Unsupported version (%d)' % version)\n\n            # Scrypt parameters\n            self._N = 1 << get_byte(header[7])\n            (self._r, self._p) = struct.unpack('>II', header[8:16])\n            self._salt = header[16:48]\n\n            # Generate the key\n            self._key = hash(self._password, self._salt, self._N, self._r, self._p, 64)\n\n            # Header Checksum\n            checksum = header[48:64]\n            calculate_checksum = hashlib.sha256(header[0:48]).digest()[:16]\n            if checksum != calculate_checksum:\n                raise InvalidScryptFileFormat('Incorrect header checksum')\n\n            # Stream checksum\n            checksum = header[64:96]\n            self._checksumer = hmac.new(self.key[32:], msg = header[0:64], digestmod = hashlib.sha256)\n            if checksum != self._checksumer.digest():\n                raise InvalidScryptFileFormat('Incorrect header stream checksum')\n            self._checksumer.update(header[64:96])\n\n            # Prepare the AES engine\n            self._crypto = aesctr.AESCounterModeOfOperation(key = self.key[:32])\n\n            self._done_header = True\n\n        except InvalidScryptFileFormat as e:\n            self.close()\n            raise e\n\n        except Exception as e:\n            self.close()\n            raise InvalidScryptFileFormat('Header error (%s)' % e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read(self, size = None):\n        '''Read at most size bytes, returned as a string.\n\n        If the size argument is negative or omitted, read until EOF is reached.\n        Notice that when in non-blocking mode, less data than what was requested\n        may be returned, even if no size parameter was given.'''\n\n        if self.closed: raise ValueError('File closed')\n        if self._mode in _allowed_write:\n            raise Exception('File opened for write only')\n        if not self._done_header:\n            self._read_header()\n\n        # The encrypted file has been entirely read, so return as much as they want\n        # and remove the returned portion from the decrypted buffer\n        if self._read_finished:\n            if size is None:\n                decrypted = self._decrypted_buffer\n            else:\n                decrypted = self._decrypted_buffer[:size]\n            self._decrypted_buffer = self._decrypted[len(decrypted):]\n            return decrypted\n\n        # Read everything in one chunk\n        if size is None or size < 0:\n            self._encrypted_buffer = self._fp.read()\n            self._read_finished = True\n\n        else:\n            # We fill the encrypted buffer (keeping it with a minimum of 32 bytes in case of the\n            # end-of-file checksum) and decrypt into a decrypted buffer 1 block at a time\n            while not self._read_finished:\n\n                # We have enough decrypted bytes (or will after decrypting the encrypted buffer)\n                available = len(self._decrypted_buffer) + len(self._encrypted_buffer) - 32\n                if available >= size: break\n\n                # Read a little extra for the possible final checksum\n                data = self._fp.read(BLOCK_SIZE)\n\n                # No data left; we're done\n                if not data:\n                    self._read_finished = True\n                    break\n\n                self._encrypted_buffer += data\n\n        # Decrypt as much of the encrypted data as possible (leaving the final check sum)\n        safe = self._encrypted_buffer[:-32]\n        self._encrypted_buffer = self._encrypted_buffer[-32:]\n        self._decrypted_buffer += self._crypto.decrypt(safe)\n        self._checksumer.update(safe)\n\n        # We read all the bytes, only the checksum remains\n        if self._read_finished:\n            self._check_final_checksum(self._encrypted_buffer)\n\n        # Send back the number of bytes requests and remove them from the buffer\n        decrypted = self._decrypted_buffer[:size]\n        self._decrypted_buffer = self._decrypted_buffer[size:]\n\n        return decrypted", "response": "Reads at most size bytes and returns them as a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite the header to the underlying file object.", "response": "def _write_header(self):\n        'Writes the header to the underlying file object.'\n\n        header = b'scrypt' + CHR0 + struct.pack('>BII', int(math.log(self.N, 2)), self.r, self.p) + self.salt\n\n        # Add the header checksum to the header\n        checksum = hashlib.sha256(header).digest()[:16]\n        header += checksum\n\n        # Add the header stream checksum\n        self._checksumer = hmac.new(self.key[32:], msg = header, digestmod = hashlib.sha256)\n        checksum = self._checksumer.digest()\n        header += checksum\n        self._checksumer.update(checksum)\n\n        # Write the header\n        self._fp.write(header)\n\n        # Prepare the AES engine\n        self._crypto = aesctr.AESCounterModeOfOperation(key = self.key[:32])\n        #self._crypto = aes(self.key[:32])\n\n        self._done_header = True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _finalize_write(self):\n        'Finishes any unencrypted bytes and writes the final checksum.'\n\n        # Make sure we have written the header\n        if not self._done_header:\n            self._write_header()\n\n        # Write the remaining decrypted part to disk\n        block = self._crypto.encrypt(self._decrypted_buffer)\n        self._decrypted = ''\n        self._fp.write(block)\n        self._checksumer.update(block)\n\n        # Write the final checksum\n        self._fp.write(self._checksumer.digest())\n        self._valid = True", "response": "Finishes any unencrypted bytes and writes the final checksum."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write(self, str):\n        '''Write string str to the underlying file.\n\n        Note that due to buffering, flush() or close() may be needed before\n        the file on disk reflects the data written.'''\n\n        if self.closed: raise ValueError('File closed')\n        if self._mode in _allowed_read:\n            raise Exception('File opened for read only')\n\n        if self._valid is not None:\n            raise Exception('file already finalized')\n\n        if not self._done_header:\n            self._write_header()\n\n        # Encrypt and write the data\n        encrypted = self._crypto.encrypt(str)\n        self._checksumer.update(encrypted)\n        self._fp.write(encrypted)", "response": "Write string str to the underlying file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a logger with the specified name creating it if necessary.", "response": "def get_logger(logger_name):\n    \"\"\"\n    Return a logger with the specified name, creating it if necessary.\n    \"\"\"\n\n    # Use default global logger\n    if logger_name is None:\n        return __instance\n\n    assert isinstance(logger_name, str), 'Logger name must be a string!'\n\n    with __lock:\n        if logger_name in __loggers:\n            return __loggers[logger_name]\n\n        logger_instance = LogOne(logger_name=logger_name)\n        __loggers[logger_name] = logger_instance\n        return logger_instance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy(location):\n\tcopyData = settings.getDataFile()\n\tcopyFileLocation = os.path.abspath(location)\n\tcopy = {\"copyLocation\": copyFileLocation}\n\tdataFile = open(copyData, \"wb\")\n\tpickle.dump(copy, dataFile)\n\tspeech.speak(location + \" copied successfully!\")\n\tspeech.speak(\"Tip: use 'hallie paste' to paste this file.\")", "response": "copy file or directory at a given location ; can be pasted later"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef paste(location):\n\tcopyData = settings.getDataFile()\n\tif not location:\n\t\tlocation = \".\"\n\ttry:\n\t\tdata = pickle.load(open(copyData, \"rb\"))\n\t\tspeech.speak(\"Pasting \" + data[\"copyLocation\"] + \" to current directory.\")\n\texcept:\n\t\tspeech.fail(\"It doesn't look like you've copied anything yet.\")\n\t\tspeech.fail(\"Type 'hallie copy <file>' to copy a file or folder.\")\n\t\treturn\n\tprocess, error = subprocess.Popen([\"cp\", \"-r\", data[\"copyLocation\"], location], stderr=subprocess.STDOUT, stdout=subprocess.PIPE).communicate()\n\tif \"denied\" in process:\n\t\tspeech.fail(\"Unable to paste your file successfully. This is most likely due to a permission issue. You can try to run me as sudo!\")", "response": "paste a file or directory that has been previously copied to the current directory"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_zfs_apt_repository():\n    with settings(hide('warnings', 'running', 'stdout'),\n                  warn_only=False, capture=True):\n        sudo('DEBIAN_FRONTEND=noninteractive /usr/bin/apt-get update')\n        install_ubuntu_development_tools()\n        apt_install(packages=['software-properties-common',\n                              'dkms',\n                              'linux-headers-generic',\n                              'build-essential'])\n        sudo('echo | add-apt-repository ppa:zfs-native/stable')\n        sudo('DEBIAN_FRONTEND=noninteractive /usr/bin/apt-get update')\n        return True", "response": "Adds the ZFS repository to the apt - get root directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef apt_install(**kwargs):\n    for pkg in list(kwargs['packages']):\n        if is_package_installed(distribution='ubuntu', pkg=pkg) is False:\n            sudo(\"DEBIAN_FRONTEND=noninteractive /usr/bin/apt-get install -y %s\" % pkg)\n        # if we didn't abort above, we should return True\n        return True", "response": "installs a apt package"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef apt_install_from_url(pkg_name, url, log=False):\n    if is_package_installed(distribution='ubuntu', pkg=pkg_name) is False:\n\n        if log:\n            log_green(\n                \"installing %s from %s\" % (pkg_name, url))\n\n        with settings(hide('warnings', 'running', 'stdout'),\n                      capture=True):\n\n            sudo(\"wget -c -O %s.deb %s\" % (pkg_name, url))\n            sudo(\"dpkg -i %s.deb\" % pkg_name)\n            # if we didn't abort above, we should return True\n            return True", "response": "installs a pkg from a url"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntrust a new PGP key related to apt - repository", "response": "def apt_add_key(keyid, keyserver='keyserver.ubuntu.com', log=False):\n    \"\"\" trust a new PGP key related to a apt-repository \"\"\"\n    if log:\n        log_green(\n            'trusting keyid %s from %s' % (keyid, keyserver)\n        )\n    with settings(hide('warnings', 'running', 'stdout')):\n        sudo('apt-key adv --keyserver %s --recv %s' % (keyserver, keyid))\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds an apt repository", "response": "def enable_apt_repositories(prefix, url, version, repositories):\n    \"\"\" adds an apt repository \"\"\"\n    with settings(hide('warnings', 'running', 'stdout'),\n                  warn_only=False, capture=True):\n        sudo('apt-add-repository \"%s %s %s %s\"' % (prefix,\n                                                   url,\n                                                   version,\n                                                   repositories))\n        with hide('running', 'stdout'):\n            output = sudo(\"DEBIAN_FRONTEND=noninteractive /usr/bin/apt-get update\")\n        if 'Some index files failed to download' in output:\n            raise SystemExit(1)\n        else:\n            # if we didn't abort above, we should return True\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef install_gem(gem):\n    with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                  warn_only=False, capture=True):\n        # convert 0 into True, any errors will always raise an exception\n        return not bool(\n            run(\"gem install %s --no-rdoc --no-ri\" % gem).return_code)", "response": "install a particular gem"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninstall a python module locally", "response": "def install_python_module_locally(name):\n    \"\"\" instals a python module using pip \"\"\"\n    with settings(hide('everything'),\n                  warn_only=False, capture=True):\n        # convert 0 into True, any errors will always raise an exception\n        print(not bool(local('pip --quiet install %s' % name).return_code))\n        return not bool(\n            local('pip --quiet install %s' % name).return_code)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_package_installed(distribution, pkg):\n    if ('centos' in distribution or\n            'el' in distribution or\n            'redhat' in distribution):\n        return(is_rpm_package_installed(pkg))\n\n    if ('ubuntu' in distribution or\n            'debian' in distribution):\n        return(is_deb_package_installed(pkg))", "response": "checks if a particular package is installed"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if a particular rpm package is installed", "response": "def is_rpm_package_installed(pkg):\n    \"\"\" checks if a particular rpm package is installed \"\"\"\n\n    with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                  warn_only=True, capture=True):\n\n        result = sudo(\"rpm -q %s\" % pkg)\n        if result.return_code == 0:\n            return True\n        elif result.return_code == 1:\n            return False\n        else:   # print error to user\n            print(result)\n            raise SystemExit()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef yum_install(**kwargs):\n    if 'repo' in kwargs:\n        repo = kwargs['repo']\n\n    for pkg in list(kwargs['packages']):\n        if is_package_installed(distribution='el', pkg=pkg) is False:\n            if 'repo' in locals():\n                log_green(\n                    \"installing %s from repo %s ...\" % (pkg, repo))\n                sudo(\"yum install -y --quiet --enablerepo=%s %s\" % (repo, pkg))\n            else:\n                log_green(\"installing %s ...\" % pkg)\n                sudo(\"yum install -y --quiet %s\" % pkg)", "response": "installs a yum package from a list of packages"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef yum_group_install(**kwargs):\n    for grp in list(kwargs['groups']):\n        log_green(\"installing %s ...\" % grp)\n        if 'repo' in kwargs:\n            repo = kwargs['repo']\n            sudo(\"yum groupinstall -y --quiet \"\n                 \"--enablerepo=%s '%s'\" % (repo, grp))\n        else:\n            sudo(\"yum groups mark install -y --quiet '%s'\" % grp)\n            sudo(\"yum groups mark convert -y --quiet '%s'\" % grp)\n            sudo(\"yum groupinstall -y --quiet '%s'\" % grp)", "response": "installs a yum group"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninstall a pkg from a url", "response": "def yum_install_from_url(pkg_name, url):\n    \"\"\" installs a pkg from a url\n        p pkg_name: the name of the package to install\n        p url: the full URL for the rpm package\n    \"\"\"\n    if is_package_installed(distribution='el', pkg=pkg_name) is False:\n        log_green(\n            \"installing %s from %s\" % (pkg_name, url))\n        with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                      warn_only=True, capture=True):\n\n            result = sudo(\"rpm -i %s\" % url)\n            if result.return_code == 0:\n                return True\n            elif result.return_code == 1:\n                return False\n            else:  # print error to user\n                print(result)\n                raise SystemExit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef launch_background_job(self, job, on_error=None, on_success=None):\n        if not self.main.mode_online:\n            self.sortie_erreur_GUI(\n                \"Local mode activated. Can't run background task !\")\n            self.reset()\n            return\n\n        on_error = on_error or self.sortie_erreur_GUI\n        on_success = on_success or self.sortie_standard_GUI\n\n        def thread_end(r):\n            on_success(r)\n            self.update()\n\n        def thread_error(r):\n            on_error(r)\n            self.reset()\n\n        logging.info(\n            f\"Launching background task from interface {self.__class__.__name__} ...\")\n        th = threads.worker(job, thread_error, thread_end)\n        self._add_thread(th)", "response": "Launch the callable job in background thread."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of items that are in the list list_base and have the same items as the liste_base.", "response": "def filtre(liste_base, criteres) -> groups.Collection:\n        \"\"\"\n        Return a filter list, bases on criteres\n\n        :param liste_base: Acces list\n        :param criteres: Criteria { `attribut`:[valeurs,...] }\n        \"\"\"\n\n        def choisi(ac):\n            for cat, li in criteres.items():\n                v = ac[cat]\n                if not (v in li):\n                    return False\n            return True\n\n        return groups.Collection(a for a in liste_base if choisi(a))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads remote data from database.", "response": "def load_remote_data(self, callback_etat=print):\n        \"\"\"\n        Load remote data. On succes, build base.\n        On failure, raise :class:`~.Core.exceptions.StructureError`, :class:`~.Core.exceptions.ConnexionError`\n\n        :param callback_etat: State renderer str , int , int -> None\n        \"\"\"\n        callback_etat(\"Chargement des utilisateurs\", 0, 1)\n        self._load_users()\n        self.base = self.BASE_CLASS.load_from_db(callback_etat=callback_etat)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndefaults implementation requires users from DB. Should setup users attribute", "response": "def _load_users(self):\n        \"\"\"Default implentation requires users from DB.\n        Should setup `users` attribute\"\"\"\n        r = sql.abstractRequetesSQL.get_users()()\n        self.users = {d[\"id\"]: dict(d) for d in r}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_autolog(self, user_id):\n        try:\n            with open(\"local/init\", \"rb\") as f:\n                s = f.read()\n                s = security.protege_data(s, False)\n                self.autolog = json.loads(s).get(\"autolog\", {})\n        except FileNotFoundError:\n            return\n\n        mdp = self.autolog.get(user_id, None)\n        return mdp", "response": "Read auto - connection parameters and returns local password or None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking mdp and return True it's ok", "response": "def loggin(self, user_id, mdp, autolog):\n        \"\"\"Check mdp and return True it's ok\"\"\"\n        r = sql.abstractRequetesSQL.check_mdp_user(user_id, mdp)\n        if r():\n            # update auto-log params\n            self.autolog[user_id] = autolog and mdp or False\n            self.modules = self.users[user_id][\"modules\"]  # load modules list\n\n            dic = {\"autolog\": self.autolog, \"modules\": self.modules}\n            s = json.dumps(dic, indent=4, ensure_ascii=False)\n            b = security.protege_data(s, True)\n            with open(\"local/init\", \"wb\") as f:\n                f.write(b)\n\n            self.mode_online = True  # authorization to execute bakground tasks\n            return True\n        else:\n            logging.debug(\"Bad password !\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_widget(self, w):\n        if self.layout():\n            self.layout().addWidget(w)\n        else:\n            layout = QVBoxLayout(self)\n            layout.addWidget(w)", "response": "Convenience function to add a widget to the current instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mkpad(items):\n    '''\n    Find the length of the longest element of a list. Return that value + two.\n    '''\n    pad = 0\n    stritems = [str(e) for e in items]  # cast list to strings\n    for e in stritems:\n        index = stritems.index(e)\n        if len(stritems[index]) > pad:\n            pad = len(stritems[index])\n    pad += 2\n    return pad", "response": "Find the length of the longest element of a list. Return that value + two."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute the size of our columns by first making them divisible of our row height and then splitting them into smaller lists.", "response": "def mkcols(l, rows):\n    '''\n    Compute the size of our columns by first making them a divisible of our row\n    height and then splitting our list into smaller lists the size of the row\n    height.\n    '''\n    cols = []\n    base = 0\n    while len(l) > rows and len(l) % rows != 0:\n        l.append(\"\")\n    for i in range(rows, len(l) + rows, rows):\n        cols.append(l[base:i])\n        base = i\n    return cols"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the optimal number of rows based on our lists largest element and our terminal size in columns and rows.", "response": "def mkrows(l, pad, width, height):\n    '''\n    Compute the optimal number of rows based on our lists' largest element and\n    our terminal size in columns and rows.\n\n    Work out our maximum column number by dividing the width of the terminal by\n    our largest element.\n\n    While the length of our list is greater than the total number of elements we\n    can fit on the screen increment the height by one.\n    '''\n    maxcols = int(width/pad)\n    while len(l) > height * maxcols:\n        height += 1\n    return height"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prtcols(items, vpad=6):\n    '''\n    After computing the size of our rows and columns based on the terminal size\n    and length of the largest element, use zip to aggregate our column lists\n    into row lists and then iterate over the row lists and print them.\n    '''\n    from os import get_terminal_size\n    items = list(items)  # copy list so we don't mutate it\n    width, height = get_terminal_size()\n    height -= vpad  # customize vertical padding\n    pad = mkpad(items)\n    rows = mkrows(items, pad, width, height)\n    cols = mkcols(items, rows)\n    # * operator in conjunction with zip, unzips the list\n    for c in zip(*cols):\n        row_format = '{:<{pad}}' * len(cols)\n        print(row_format.format(*c, pad=pad))", "response": "Print the columns of a list of items."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cmd2list(cmd):\n   ''' Executes a command through the operating system and returns the output\n   as a list, or on error a string with the standard error.\n   EXAMPLE:\n      >>> from subprocess import Popen, PIPE\n      >>> CMDout2array('ls -l')\n   '''\n   p = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)\n   stdout, stderr = p.communicate()\n   if p.returncode != 0 and stderr != '':\n      return \"ERROR: %s\\n\"%(stderr)\n   else:\n      return stdout.split('\\n')", "response": "Executes a command through the operating system and returns the output as a list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a text formatted timer", "response": "def return_timer(self, name, status, timer):\n      ''' Return a text formatted timer '''\n      timer_template = '%s  %s  %s : %s : %9s'\n      t = str(timedelta(0, timer)).split(',')[-1].strip().split(':')\n      #t = str(timedelta(0, timer)).split(':')\n      if len(t) == 4:\n         h, m, s = int(t[0])*24 + int(t[1]), int(t[2]), float(t[3])\n      elif len(t) == 3: h, m, s = int(t[0]), int(t[1]), float(t[2])\n      else: h, m, s = 0, 0, str(t)\n      return timer_template%(\n         name[:20].ljust(20),\n         status[:7].ljust(7),\n         '%3d'%h if h != 0 else ' --',\n         '%2d'%m if m != 0 else '--',\n         '%.6f'%s if isinstance(s, float) else s\n      )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints the execution times for all the processes in the list.", "response": "def print_timers(self):\n      ''' PRINT EXECUTION TIMES FOR THE LIST OF PROGRAMS '''\n      self.timer += time()\n      total_time = self.timer\n      tmp = '*  %s  *'\n      debug.log(\n         '',\n         '* '*29,\n         tmp%(' '*51),\n         tmp%('%s  %s  %s'%('Program Name'.ljust(20), 'Status'.ljust(7), 'Execute Time (H:M:S)')),\n         tmp%('='*51)\n      )\n      for name in self.list:\n         if self.exists(name):\n            timer = getattr(self, name).get_time()\n            status = getattr(self, name).get_status()\n            self.timer -= timer\n            debug.log(tmp%(self.return_timer(name, status, timer)))\n         else:\n            debug.log(tmp%(\"%s  %s -- : -- : --\"%(name[:20].ljust(20),'  '*8)))\n      debug.log(\n         tmp%(self.return_timer('Wrapper', '', self.timer)),\n         tmp%('='*51),\n         tmp%(self.return_timer('Total', '', total_time)),\n         tmp%(' '*51),\n         '* '*29,\n         ''\n      )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_cmd(self):\n      cmd = []\n      if self.path is not None:\n         if '/' in self.path and not os.path.exists(self.path):\n            debug.log('Error: path contains / but does not exist: %s'%self.path)\n         else:\n            if self.ptype is not None:\n               if os.path.exists(self.ptype):\n                  cmd.append(self.ptype)\n               elif '/' not in self.ptype:\n                  for path in os.environ[\"PATH\"].split(os.pathsep):\n                     path = path.strip('\"')\n                     ppath = os.path.join(path, self.ptype)\n                     if os.path.isfile(ppath):\n                        cmd.append(ppath)\n                        break\n            cmd.append(self.path)\n            if sys.version_info < (3, 0):\n               cmd.extend([str(x) if not isinstance(x, (unicode)) else x.encode('utf-8') for x in [quote(str(x)) for x in self.args]+self.unquoted_args])\n            else:\n               cmd.extend([str(x) for x in [quote(str(x)) for x in self.args]+self.unquoted_args])\n      else:\n         debug.log('Error: Program path not set!')\n      return ' '.join(cmd)", "response": "This function returns the commanline call of the program."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef append_args(self, arg):\n      debug.log(\"Adding Arguments: %s\"%(arg))\n      if isinstance(arg, (int,float)): self.args.append(str(arg))\n      if isinstance(arg, str): self.args.append(arg)\n      if isinstance(arg, list):\n         if sys.version_info < (3, 0):\n            self.args.extend([str(x) if not isinstance(x, (unicode)) else x.encode('utf-8') for x in arg])\n         else:\n            self.args.extend([str(x) for x in arg])", "response": "This function appends the provided arguments to the program object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wait(self, pattern='Done', interval=None,\n              epatterns=['error','Error','STACK','Traceback']):\n      \"\"\" This function will wait on a given pattern being shown on the last\n          line of a given outputfile.\n\n      OPTIONS\n         pattern        - The string pattern to recognise when a program\n                          finished properly.\n         interval       - The amount of seconds to wait between checking the\n                          log file.\n         epatterns      - A list of string patterns to recognise when a program\n                          has finished with an error.\n      \"\"\"\n      increasing_interval = False\n      if interval is None:\n         increasing_interval = True\n         interval = 10\n      if self.wdir != '':\n         stderr = \"%s/%s\"%(self.wdir, self.stderr)\n      else:\n         stderr = self.stderr\n      debug.log(\"\\nWaiting for %s to finish...\"%str(self.name))\n      if self.status == 'Executing':\n         self.update_timer(-time()) # TIME START\n         found = False\n         if self.queue is not None:\n            # Handling programs running on the compute servers\n            # Waiting for error log to be created.\n            # Prolonged waiting can be caused by the queue being full, or the\n            # server being unavailable.\n            debug.log(\"   Waiting for the error log to be created (%s)...\"%(\n                     stderr))\n            # Set maximum amount of seconds to wait on the errorlog creation,\n            # before assuming queue failure.\n            max_queued_time = 10800\n            while ( not os.path.exists(stderr)\n                  and time()+self.timer < max_queued_time\n                  and time()+self.timer > 0\n                  ):\n               debug.log(\"      Waiting... (max wait time left: %s seconds)\"%(\n                  str(max_queued_time-time()-self.timer)))\n               sleep(interval)\n               if increasing_interval:\n                  interval *= 1.1\n            \n            if os.path.exists(stderr):\n               if increasing_interval:\n                  interval = 10\n               # File created looking for pattern\n               debug.log('\\nError log created, waiting for program to finish...')\n            # calculate max loops left based on set walltime and check interval\n               max_time = time() + self.walltime * 60 * 60\n               while time() < max_time:\n                  with open_(stderr) as f:\n                     for l in f.readlines()[-5:]: # last five lines\n                        if pattern in l:\n                           found = True\n                           max_time = 0\n                           break\n                        elif any([ep in l for ep in epatterns]):\n                           found = False\n                           max_time = 0\n                           break\n                  if max_time > 0:\n                     debug.log('      Waiting... (max wait-time left: %s seconds)'%(\n                              str(max_time-time())))\n                     sleep(interval)\n               if found:\n                  debug.log(\"   Program finished successfully!\")\n                  self.status = 'Done'\n               else:\n                  debug.log(\"Error: Program took too long, or finished with error!\")\n                  if self.verbose:\n                     debug.print_out(\n                        \"Technical error occurred!\\n\",\n                        \"The service was not able to produce a result.\\n\",\n                        (\"Please check your settings are correct, and the file \"\n                        \"type matches what you specified.\\n\"),\n                        (\"Try again, and if the problem persists please notify the\"\n                        \" technical support.\\n\")\n                        )\n                  self.status = 'Failure'\n            else:\n               debug.log(\n                  (\"Error: %s still does not exist!\\n\")%(stderr),\n                  (\"This error might be caused by the cgebase not being \"\n                   \"available!\")\n                  )\n               if self.verbose:\n                  debug.print_out(\n                     \"Technical error occurred!\\n\",\n                     (\"This error might be caused by the server not being \"\n                     \"available!\\n\"),\n                     (\"Try again later, and if the problem persists please notify \"\n                     \"the technical support.\\n\"),\n                     \"Sorry for any inconvenience.\\n\"\n                     )\n               self.status = 'Failure'\n            if not self.p is None:\n               self.p.wait()\n               self.p = None\n         else:\n            # Handling wrappers running on the webserver\n            if self.p is None:\n               debug.log(\"Program not instanciated!\")\n               self.status = 'Failure'\n            else:\n               ec = self.p.wait()\n               if ec != 0:\n                  debug.log(\"Program failed on execution!\")\n                  self.status = 'Failure'\n               elif os.path.exists(stderr):\n                  with open_(stderr) as f:\n                     for l in f.readlines()[-5:]: # last five lines\n                        if pattern in l:\n                           found = True\n                           break\n                        elif any([ep in l for ep in epatterns]):\n                           found = False\n                           break\n                  if found:\n                     debug.log(\"   Program finished successfully!\")\n                     self.status = 'Done'\n                  else:\n                     debug.log(\"Error: Program failed to finish properly!\")\n                     if self.verbose:\n                        debug.print_out(\"Technical error occurred!\\n\",\n                           \"The service was not able to produce a result.\\n\",\n                           \"Please check your settings are correct, and the file \"+\n                           \"type matches what you specified.\", \"Try again, and if \"+\n                           \"the problem persists please notify the technical \"+\n                           \"support.\\n\")\n                     self.status = 'Failure'\n               else:\n                  debug.log((\"Error: %s does not exist!\\n\")%(stderr),\n                     \"This error might be caused by the cgebase not being \"+\n                     \"available!\")\n                  if self.verbose:\n                     debug.print_out(\"Technical error occurred!\\n\",\n                        \"This error might be caused by the server not being \"+\n                        \"available!\\n\", \"Try again later, and if the problem \"+\n                        \"persists please notify the technical support.\\n\",\n                        \"Sorry for any inconvenience.\\n\")\n                  self.status = 'Failure'\n               self.p = None\n         self.update_timer(time()) # TIME END\n         debug.log(\"   timed: %s\"%(self.get_time()))\n      else:\n         debug.log(\"   The check-out of the program has been sorted previously.\")", "response": "This function will wait for a given pattern to finish."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_out_var(self, varnames=[]):\n      if self.wdir != '':\n         stdout = \"%s/%s\"%(self.wdir, self.stdout)\n      else:\n         stdout = self.stdout\n      response = [None]*len(varnames)\n      # First we check if the file we want to print does exists\n      if os.path.exists(stdout):\n         with open_(stdout, 'r') as f:\n            for line in f:\n               if '=' in line:\n                  var = line.strip('#').split('=')\n                  value = var[1].strip()\n                  var = var[0].strip()\n                  if var in varnames: response[varnames.index(var)] = value\n      else: # FILE DOESN'T EXIST\n         debug.log(\"Error: The stdout file %s does not exist!\"%(stdout))\n      return response", "response": "This function will read the standard out of the program catch\n          variables and return the values\n ArcGIS variable name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_err_pattern(self, pattern):\n      if self.wdir != '':\n         stderr = \"%s/%s\"%(self.wdir, self.stderr)\n      else:\n         stderr = self.stderr\n      response = []\n      # First we check if the file we want to print does exists\n      if os.path.exists(stderr):\n         with open_(stderr, 'r') as f:\n            for line in f:\n               if pattern in line:\n                  response.append(line.strip())\n      else: # FILE DOESN'T EXIST\n         debug.log(\"Error: The stderr file %s does not exist!\"%(stderr))\n      return response", "response": "This function will read the standard error of the program and return a list of lines that match the pattern."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decode_nfo( buffer ):\n    assert utils.is_bytes( buffer )\n    return '\\n'.join( [''.join( [CP437[y] for y in x] ) for x in buffer.split( b'\\r\\n' )] )", "response": "Decodes a byte string in NFO format from DOS Code Page 437 \n    to Unicode."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef runner(self):\n        if os.path.isfile(self.report):\n            self.report_parse()\n        else:\n            logging.info('Starting {} analysis pipeline'.format(self.analysistype))\n            # Create the objects to be used in the analyses (if required)\n            general = None\n            for sample in self.runmetadata.samples:\n                general = getattr(sample, 'general')\n            if general is None:\n                # Create the objects to be used in the analyses\n                objects = Objectprep(self)\n                objects.objectprep()\n                self.runmetadata = objects.samples\n            # Run the analyses\n            MLSTmap(self, self.analysistype, self.cutoff)\n            # Create the reports\n            self.reporter()\n            # Print the metadata to a .json file\n            MetadataPrinter(self)", "response": "Run the necessary methods in the correct order"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reporter(self):\n        logging.info('Preparing reports')\n        # Populate self.plusdict in order to reuse parsing code from an assembly-based method\n        for sample in self.runmetadata.samples:\n            self.plusdict[sample.name] = dict()\n            self.matchdict[sample.name] = dict()\n            if sample.general.bestassemblyfile != 'NA':\n                for gene in sample[self.analysistype].allelenames:\n                    self.plusdict[sample.name][gene] = dict()\n                    for allele, percentidentity in sample[self.analysistype].results.items():\n\n                        if gene in allele:\n                            # Split the allele number from the gene name using the appropriate delimiter\n                            if '_' in allele:\n                                splitter = '_'\n                            elif '-' in allele:\n                                splitter = '-'\n                            else:\n                                splitter = ''\n                            self.matchdict[sample.name].update({gene: allele.split(splitter)[-1]})\n                            # Create the plusdict dictionary as in the assembly-based (r)MLST method. Allows all the\n                            # parsing and sequence typing code to be reused.\n                            try:\n                                self.plusdict[sample.name][gene][allele.split(splitter)[-1]][percentidentity] \\\n                                    = sample[self.analysistype].avgdepth[allele]\n                            except KeyError:\n                                self.plusdict[sample.name][gene][allele.split(splitter)[-1]] = dict()\n                                self.plusdict[sample.name][gene][allele.split(splitter)[-1]][percentidentity] \\\n                                    = sample[self.analysistype].avgdepth[allele]\n                    if gene not in self.matchdict[sample.name]:\n                        self.matchdict[sample.name].update({gene: 'N'})\n        self.profiler()\n        self.sequencetyper()\n        self.mlstreporter()", "response": "Runs the necessary methods to parse raw read outputs and produce a dictionary of results."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a dictionary of the profile scheme and the total number of genes in the typing scheme", "response": "def profiler(self):\n        \"\"\"Creates a dictionary from the profile scheme(s)\"\"\"\n        logging.info('Loading profiles')\n        # Initialise variables\n        profiledata = defaultdict(make_dict)\n        reverse_profiledata = dict()\n        profileset = set()\n        # Find all the unique profiles to use with a set\n        for sample in self.runmetadata.samples:\n            if sample.general.bestassemblyfile != 'NA':\n                if sample[self.analysistype].profile != 'NA':\n                    profileset.add(sample[self.analysistype].profile)\n        # Extract the profiles for each set\n        for sequenceprofile in profileset:\n            #\n            if sequenceprofile not in self.meta_dict:\n                self.meta_dict[sequenceprofile] = dict()\n            reverse_profiledata[sequenceprofile] = dict()\n            self.meta_dict[sequenceprofile]['ND'] = dict()\n            # Clear the list of genes\n            geneset = set()\n            # Calculate the total number of genes in the typing scheme\n            for sample in self.runmetadata.samples:\n                if sample.general.bestassemblyfile != 'NA':\n                    if sequenceprofile == sample[self.analysistype].profile:\n                        geneset = {allele for allele in sample[self.analysistype].alleles}\n            try:\n                # Open the sequence profile file as a dictionary\n                profile = DictReader(open(sequenceprofile), dialect='excel-tab')\n            # Revert to standard comma separated values\n            except KeyError:\n                # Open the sequence profile file as a dictionary\n                profile = DictReader(open(sequenceprofile))\n            # Iterate through the rows\n            for row in profile:\n                # Populate the profile dictionary with profile number: {gene: allele}. Use the first field name,\n                # which will be either ST, or rST as the key to determine the profile number value\n                allele_comprehension = {gene: allele for gene, allele in row.items() if gene in geneset}\n                st = row[profile.fieldnames[0]]\n                for header, value in row.items():\n                    value = value if value else 'ND'\n                    if header not in geneset and header not in ['ST', 'rST']:\n                        if st not in self.meta_dict[sequenceprofile]:\n                            self.meta_dict[sequenceprofile][st] = dict()\n                        if header == 'CC' or header == 'clonal_complex':\n                            header = 'CC'\n                        self.meta_dict[sequenceprofile][st][header] = value\n                        self.meta_dict[sequenceprofile]['ND'][header] = 'ND'\n                        self.meta_dict[sequenceprofile][st]['PredictedSerogroup'] = 'ND'\n                        if header not in self.meta_headers:\n                            self.meta_headers.append(header)\n                profiledata[sequenceprofile][st] = allele_comprehension\n                # Create a 'reverse' dictionary using the the allele comprehension as the key, and\n                # the sequence type as the value - can be used if exact matches are ever desired\n                reverse_profiledata[sequenceprofile].update({frozenset(allele_comprehension.items()): st})\n            # Add the profile data, and gene list to each sample\n            for sample in self.runmetadata.samples:\n                if sample.general.bestassemblyfile != 'NA':\n                    if sequenceprofile == sample[self.analysistype].profile:\n                        # Populate the metadata with the profile data\n                        sample[self.analysistype].profiledata = profiledata[sample[self.analysistype].profile]\n                        sample[self.analysistype].reverse_profiledata = reverse_profiledata[sequenceprofile]\n                        sample[self.analysistype].meta_dict = self.meta_dict[sequenceprofile]\n                else:\n                    sample[self.analysistype].profiledata = 'NA'\n                    sample[self.analysistype].reverse_profiledata = 'NA'\n                    sample[self.analysistype].meta_dict = 'NA'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sequencetyper(self):\n        logging.info('Performing sequence typing')\n        for sample in self.runmetadata.samples:\n            if sample.general.bestassemblyfile != 'NA':\n                if type(sample[self.analysistype].allelenames) == list:\n                    # Initialise variables\n                    header = 0\n                    genome = sample.name\n                    # Initialise self.bestmatch[genome] with an int that will eventually be replaced by the # of matches\n                    self.bestmatch[genome] = defaultdict(int)\n                    if sample[self.analysistype].profile != 'NA':\n                        # Create the profiledata variable to avoid writing self.profiledata[self.analysistype]\n                        profiledata = sample[self.analysistype].profiledata\n                        # Calculate the number of allele matches between each sequence type and the results\n                        best_seqtype = dict()\n                        for sequencetype in sample[self.analysistype].profiledata:\n                            # Initialise a counter\n                            count = 0\n                            # Iterate through each gene for the sequence type\n                            for gene, refallele in sample[self.analysistype].profiledata[sequencetype].items():\n                                # Use the gene to extract the calculated allele\n                                allele = self.matchdict[genome][gene]\n                                # Increment the count on a match\n                                if refallele == allele:\n                                    count += 1\n                            # Add the sequence type to the set of sequence types with the number of matches as the key\n                            try:\n                                best_seqtype[count].add(sequencetype)\n                            except KeyError:\n                                best_seqtype[count] = set()\n                                best_seqtype[count].add(sequencetype)\n                        # Find the highest number of matches from the dictionary\n                        best = sorted(best_seqtype.items(), key=operator.itemgetter(0), reverse=True)[0][1]\n                        # Deal with multiple allele matches\n                        for gene in sample[self.analysistype].allelenames:\n                            # Clear the appropriate count and lists\n                            multiallele = list()\n                            multipercent = list()\n                            # Go through the alleles in plusdict\n                            for allele in self.plusdict[genome][gene]:\n                                percentid = list(self.plusdict[genome][gene][allele].keys())[0]\n                                # \"N\" alleles screw up the allele splitter function\n                                if allele not in ['N', 'NA']:\n                                    # Append as appropriate - alleleNumber is treated as an integer for proper sorting\n                                    multiallele.append(int(allele))\n                                    multipercent.append(percentid)\n                                # If the allele is \"N\"\n                                else:\n                                    # Append \"N\" and a percent identity of 0\n                                    multiallele.append(\"N\")\n                                    multipercent.append(0)\n                            # Populate self.bestdict with genome, gene, alleles joined with a space (this was made like\n                            # this because allele is a list generated by the .iteritems() above\n                            try:\n                                self.bestdict[genome][gene][\" \".join(str(allele)\n                                                                     for allele in sorted(multiallele))] = \\\n                                    multipercent[0]\n                            except IndexError:\n                                self.bestdict[genome][gene]['NA'] = 0\n                            # Find the profile with the most alleles in common with the query genome\n                            for sequencetype in best:\n                                # The number of genes in the analysis\n                                header = len(profiledata[sequencetype])\n                                # refallele is the allele number of the sequence type\n                                refallele = profiledata[sequencetype][gene]\n                                # If there are multiple allele matches for a gene in the reference profile e.g. 10 692\n                                if len(refallele.split(\" \")) > 1:\n                                    # Map the split (on a space) alleles as integers - if they are treated as integers,\n                                    # the alleles will sort properly\n                                    intrefallele = map(int, refallele.split(\" \"))\n                                    # Create a string of the joined, sorted alleles\n                                    sortedrefallele = \" \".join(str(allele) for allele in sorted(intrefallele))\n                                else:\n                                    # Use the reference allele as the sortedRefAllele\n                                    sortedrefallele = refallele\n                                for allele, percentid in self.bestdict[genome][gene].items():\n                                    # If the allele in the query genome matches the allele in the reference profile, add\n                                    # the result to the bestmatch dictionary. Genes with multiple alleles were sorted\n                                    # the same, strings with multiple alleles will match: 10 692 will never be 692 10\n                                    if allele == sortedrefallele and float(percentid) == 100.00:\n                                        # Increment the number of matches to each profile\n                                        self.bestmatch[genome][sequencetype] += 1\n                                    # Special handling of BACT000060 and BACT000065 genes for E. coli and BACT000014\n                                    # for Listeria. When the reference profile has an allele of 'N', and the query\n                                    # allele doesn't, set the allele to 'N', and count it as a match\n                                    elif sortedrefallele == 'N' and allele != 'N':\n                                        # Increment the number of matches to each profile\n                                        self.bestmatch[genome][sequencetype] += 1\n                                    # Consider cases with multiple allele matches\n                                    elif len(allele.split(' ')) > 1:\n                                        # Also increment the number of matches if one of the alleles matches the\n                                        # reference allele e.g. 41 16665 will match either 41 or 16665\n                                        if sortedrefallele != 'N' and allele != 'N':\n                                            match = False\n                                            for sub_allele in allele.split(' '):\n                                                if sub_allele == refallele:\n                                                    match = True\n                                            if match:\n                                                # Increment the number of matches to each profile\n                                                self.bestmatch[genome][sequencetype] += 1\n                                    elif allele == sortedrefallele and sortedrefallele == 'N':\n                                        # Increment the number of matches to each profile\n                                        self.bestmatch[genome][sequencetype] += 1\n                        # Get the best number of matches\n                        # From: https://stackoverflow.com/questions/613183/sort-a-python-dictionary-by-value\n                        try:\n                            sortedmatches = sorted(self.bestmatch[genome].items(), key=operator.itemgetter(1),\n                                                   reverse=True)[0][1]\n                        # If there are no matches, set :sortedmatches to zero\n                        except IndexError:\n                            sortedmatches = 0\n                        # Otherwise, the query profile matches the reference profile\n                        if int(sortedmatches) == header:\n                            # Iterate through best match\n                            for sequencetype, matches in self.bestmatch[genome].items():\n                                if matches == sortedmatches:\n                                    for gene in profiledata[sequencetype]:\n                                        # Populate resultProfile with the genome, best match to profile, # of matches\n                                        # to the profile, gene, query allele(s), reference allele(s), and % identity\n                                        self.resultprofile[genome][sequencetype][sortedmatches][gene][\n                                            list(self.bestdict[genome][gene]\n                                                 .keys())[0]] = str(list(self.bestdict[genome][gene].values())[0])\n                                    sample[self.analysistype].sequencetype = sequencetype\n                                    sample[self.analysistype].matchestosequencetype = matches\n                        # If there are fewer matches than the total number of genes in the typing scheme\n                        elif 0 < int(sortedmatches) < header:\n                            mismatches = []\n                            # Iterate through the sequence types and the number of matches in bestDict for each genome\n                            for sequencetype, matches in self.bestmatch[genome].items():\n                                # If the number of matches for a profile matches the best number of matches\n                                if matches == sortedmatches:\n                                    # Iterate through the gene in the analysis\n                                    for gene in profiledata[sequencetype]:\n                                        # Get the reference allele as above\n                                        refallele = profiledata[sequencetype][gene]\n                                        # As above get the reference allele split and ordered as necessary\n                                        if len(refallele.split(\" \")) > 1:\n                                            intrefallele = map(int, refallele.split(\" \"))\n                                            sortedrefallele = \" \".join(str(allele) for allele in sorted(intrefallele))\n                                        else:\n                                            sortedrefallele = refallele\n                                        # Populate self.mlstseqtype with the genome, best match to profile, # of matches\n                                        # to the profile, gene, query allele(s), reference allele(s), and % identity\n                                        if self.analysistype == 'mlst':\n                                            self.resultprofile[genome][sequencetype][sortedmatches][gene][\n                                                list(self.bestdict[genome][gene]\n                                                     .keys())[0]] = str(list(self.bestdict[genome][gene].values())[0])\n                                        else:\n                                            self.resultprofile[genome][sequencetype][sortedmatches][gene][\n                                                list(self.bestdict[genome][gene].keys())[0]] \\\n                                                = str(list(self.bestdict[genome][gene].values())[0])\n                                            #\n                                            if sortedrefallele != list(self.bestdict[sample.name][gene].keys())[0]:\n                                                mismatches.append(\n                                                    ({gene: ('{} ({})'.format(list(self.bestdict[sample.name][gene]\n                                                                                   .keys())[0], sortedrefallele))}))\n                                        sample[self.analysistype].mismatchestosequencetype = mismatches\n                                        sample[self.analysistype].sequencetype = sequencetype\n                                        sample[self.analysistype].matchestosequencetype = matches\n                        elif sortedmatches == 0:\n                            for gene in sample[self.analysistype].allelenames:\n                                # Populate the results profile with negative values for sequence type and sorted matches\n                                self.resultprofile[genome]['NA'][sortedmatches][gene]['NA'] = 0\n                            # Add the new profile to the profile file (if the option is enabled)\n                            sample[self.analysistype].sequencetype = 'NA'\n                            sample[self.analysistype].matchestosequencetype = 'NA'\n                            sample[self.analysistype].mismatchestosequencetype = 'NA'\n                        else:\n                            sample[self.analysistype].matchestosequencetype = 'NA'\n                            sample[self.analysistype].mismatchestosequencetype = 'NA'\n                            sample[self.analysistype].sequencetype = 'NA'\n                else:\n                    sample[self.analysistype].matchestosequencetype = 'NA'\n                    sample[self.analysistype].mismatchestosequencetype = 'NA'\n                    sample[self.analysistype].sequencetype = 'NA'\n\n            else:\n                sample[self.analysistype].matchestosequencetype = 'NA'\n                sample[self.analysistype].mismatchestosequencetype = 'NA'\n                sample[self.analysistype].sequencetype = 'NA'\n            # Clear out the reverse_profiledata attribute - frozen sets can not be .json encoded\n            try:\n                delattr(sample[self.analysistype], 'reverse_profiledata')\n            except AttributeError:\n                pass", "response": "Determines the sequence type of each strain based on comparisons to sequence type profiles"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing the results into a report", "response": "def mlstreporter(self):\n        \"\"\" Parse the results into a report\"\"\"\n        logging.info('Writing reports')\n        # Initialise variables\n        header_row = str()\n        combinedrow = str()\n        combined_header_row = str()\n        reportdirset = set()\n        mlst_dict = dict()\n        # Populate a set of all the report directories to use. A standard analysis will only have a single report\n        # directory, while pipeline analyses will have as many report directories as there are assembled samples\n        for sample in self.runmetadata.samples:\n            if sample.general.bestassemblyfile != 'NA':\n                # Ignore samples that lack a populated reportdir attribute\n                if sample[self.analysistype].reportdir != 'NA':\n                    make_path(sample[self.analysistype].reportdir)\n                    # Add to the set - I probably could have used a counter here, but I decided against it\n                    reportdirset.add(sample[self.analysistype].reportdir)\n        # Create a report for each sample from :self.resultprofile\n        for sample in self.runmetadata.samples:\n            if sample.general.bestassemblyfile != 'NA':\n                if sample[self.analysistype].reportdir != 'NA':\n                    if type(sample[self.analysistype].allelenames) == list:\n                        # Initialise the string\n                        row = str()\n                        if self.analysistype == 'mlst':\n                            header_row = str()\n                            try:\n                                if sample.general.referencegenus not in mlst_dict:\n                                    mlst_dict[sample.general.referencegenus] = dict()\n                            except AttributeError:\n                                sample.general.referencegenus = 'ND'\n                                mlst_dict[sample.general.referencegenus] = dict()\n                        # Additional fields such as clonal complex and lineage\n                        additional_fields = list()\n                        #\n                        if self.meta_headers:\n                            for header in self.meta_headers:\n                                try:\n                                    _ = sample[self.analysistype].meta_dict[\n                                        sample[self.analysistype].sequencetype][header]\n                                    additional_fields.append(header.rstrip())\n                                except (AttributeError, KeyError):\n                                    pass\n                        if self.analysistype == 'mlst':\n                            additional_fields = sorted(additional_fields)\n                            #\n                            try:\n                                if sample.general.referencegenus == 'Listeria':\n                                    additional_fields.append('PredictedSerogroup')\n                            except AttributeError:\n                                pass\n                            header_fields = additional_fields\n                        else:\n                            additional_fields = [\n                                'genus', 'species', 'subspecies', 'lineage', 'sublineage', 'other_designation', 'notes'\n                            ]\n                            header_fields = [\n                                'rMLST_genus', 'species', 'subspecies', 'lineage', 'sublineage', 'other_designation',\n                                'notes'\n                            ]\n                        # Populate the header with the appropriate data, including all the genes in the list of targets\n                        if not header_row:\n                            if additional_fields:\n                                header_row = 'Strain,MASHGenus,{additional},SequenceType,Matches,{matches},\\n' \\\n                                    .format(additional=','.join(header_fields),\n                                            matches=','.join(sorted(sample[self.analysistype].allelenames)))\n                            else:\n                                header_row = 'Strain,MASHGenus,SequenceType,Matches,{matches},\\n' \\\n                                    .format(matches=','.join(sorted(sample[self.analysistype].allelenames)))\n                        # Iterate through the best sequence types for the sample\n                        for seqtype in self.resultprofile[sample.name]:\n                            sample[self.analysistype].sequencetype = seqtype\n                            try:\n                                if sample.general.referencegenus == 'Listeria':\n                                    for serogroup, mlst_list in self.listeria_serogroup_dict.items():\n                                        if seqtype in [str(string) for string in mlst_list]:\n                                            sample[self.analysistype].meta_dict[seqtype]['PredictedSerogroup'] = \\\n                                                serogroup\n                            except AttributeError:\n                                pass\n                            # The number of matches to the profile\n                            sample[self.analysistype].matches = list(self.resultprofile[sample.name][seqtype].keys())[0]\n                            # Extract the closest reference genus\n                            try:\n                                genus = sample.general.referencegenus\n                            except AttributeError:\n                                try:\n                                    genus = sample.general.closestrefseqgenus\n                                except AttributeError:\n                                    genus = 'ND'\n                            # If this is the first of one or more sequence types, include the sample name\n                            if additional_fields:\n                                row += '{name},{mashgenus},{additional},{seqtype},{matches},'\\\n                                    .format(name=sample.name,\n                                            mashgenus=genus,\n                                            additional=','.join(sample[self.analysistype].\n                                                                meta_dict[sample[self.analysistype]\n                                                                .sequencetype][header] for header in additional_fields),\n                                            seqtype=seqtype,\n                                            matches=sample[self.analysistype].matches)\n                            else:\n                                row += '{name},{mashgenus},{seqtype},{matches},' \\\n                                    .format(name=sample.name,\n                                            mashgenus=genus,\n                                            seqtype=seqtype,\n                                            matches=sample[self.analysistype].matches)\n                            # Iterate through all the genes present in the analyses for the sample\n                            for gene in sorted(sample[self.analysistype].allelenames):\n                                refallele = sample[self.analysistype].profiledata[seqtype][gene]\n                                # Set the allele and percent id from the dictionary's keys and values, respectively\n                                allele = \\\n                                    list(self.resultprofile[sample.name][seqtype][sample[self.analysistype].matches]\n                                         [gene].keys())[0]\n                                percentid = \\\n                                    list(self.resultprofile[sample.name][seqtype][sample[self.analysistype].matches]\n                                         [gene].values())[0]\n                                try:\n                                    if refallele and refallele != allele:\n                                        if 0 < float(percentid) < 100:\n                                            row += '{} ({:.2f}%),'.format(allele, float(percentid))\n                                        else:\n                                            row += '{} ({}),'.format(allele, refallele)\n                                    else:\n                                        # Add the allele and % id to the row (only add the % identity if it is not 100%)\n                                        if 0 < float(percentid) < 100:\n                                            row += '{} ({:.2f}%),'.format(allele, float(percentid))\n                                        else:\n                                            row += '{},'.format(allele)\n                                    self.referenceprofile[sample.name][gene] = allele\n                                except ValueError:\n                                    pass\n                            # Add a newline\n                            row += '\\n'\n                        #\n                        combinedrow += row\n                        #\n                        combined_header_row += header_row\n                        combined_header_row += row\n                        if self.analysistype == 'mlst':\n                            mlst_dict[sample.general.referencegenus]['header'] = header_row\n                            try:\n                                mlst_dict[sample.general.referencegenus]['combined_row'] += row\n                            except KeyError:\n                                mlst_dict[sample.general.referencegenus]['combined_row'] = str()\n                                mlst_dict[sample.general.referencegenus]['combined_row'] += row\n                        # If the length of the # of report directories is greater than 1 (script is being run as part of\n                        # the assembly pipeline) make a report for each sample\n                        if self.pipeline:\n                            # Open the report\n                            with open(os.path.join(sample[self.analysistype].reportdir,\n                                                   '{}_{}.csv'.format(sample.name, self.analysistype)), 'w') as report:\n                                # Write the row to the report\n                                report.write(header_row)\n                                report.write(row)\n        # Create the report folder\n        make_path(self.reportpath)\n        # Create the report containing all the data from all samples\n        if self.analysistype == 'mlst':\n            for genus in mlst_dict:\n                if mlst_dict[genus]['combined_row']:\n                    with open(os.path.join(self.reportpath, '{at}_{genus}.csv'.format(at=self.analysistype,\n                                                                                      genus=genus)), 'w') \\\n                            as mlstreport:\n                        # Add the header\n                        mlstreport.write(mlst_dict[genus]['header'])\n                        # Write the results to this report\n                        mlstreport.write(mlst_dict[genus]['combined_row'])\n            with open(os.path.join(self.reportpath,  '{at}.csv'.format(at=self.analysistype)), 'w') \\\n                    as combinedreport:\n                # Write the results to this report\n                combinedreport.write(combined_header_row)\n        else:\n            with open(os.path.join(self.reportpath,  '{at}.csv'.format(at=self.analysistype)), 'w') \\\n                    as combinedreport:\n                # Add the header\n                combinedreport.write(header_row)\n                # Write the results to this report\n                combinedreport.write(combinedrow)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef report_parse(self):\n        # Initialise lists\n        report_strains = list()\n        genus_list = list()\n        if self.analysistype == 'mlst':\n            for sample in self.runmetadata.samples:\n                try:\n                    genus_list.append(sample.general.referencegenus)\n                except AttributeError:\n                    sample.general.referencegenus = 'ND'\n                    genus_list.append(sample.general.referencegenus)\n        # Read in the report\n        if self.analysistype == 'mlst':\n            for genus in genus_list:\n                try:\n                    report_name = os.path.join(self.reportpath, '{at}_{genus}.csv'.format(at=self.analysistype,\n                                                                                          genus=genus))\n                    report_strains = self.report_read(report_strains=report_strains,\n                                                      report_name=report_name)\n                except FileNotFoundError:\n                    report_name = self.report\n                    report_strains = self.report_read(report_strains=report_strains,\n                                                      report_name=report_name)\n        else:\n            report_name = self.report\n            report_strains = self.report_read(report_strains=report_strains,\n                                              report_name=report_name)\n        # Populate strains not in the report with 'empty' GenObject with appropriate attributes\n        for sample in self.runmetadata.samples:\n            if sample.name not in report_strains:\n                setattr(sample, self.analysistype, GenObject())\n                sample[self.analysistype].sequencetype = 'ND'\n                sample[self.analysistype].matches = 0\n                sample[self.analysistype].results = dict()", "response": "Parse the report and return the dictionary of results."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef guess_type(filename, **kwargs):\n\n    extension = os.path.splitext(filename)[1]\n    case = {'.xls': Xls,\n            '.xlsx': Xlsx,\n            '.csv': Csv}\n    if extension and case.get(extension.lower()):\n        low_extension = extension.lower()\n        new_kwargs = dict()\n        class_name = case.get(low_extension)\n        class_kwargs = inspect.getargspec(class_name.__init__).args[1:]\n        for kwarg in kwargs:\n            if kwarg in class_kwargs:\n                new_kwargs[kwarg] = kwargs[kwarg]\n        return case.get(low_extension)(filename, **new_kwargs)\n    else:\n        raise Exception('No extension found')", "response": "Utility function to call classes based on filename extension."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_gene_seqs(database_path, gene):\n    gene_path = database_path + \"/\" + gene + \".fsa\"\n    gene_seq = \"\"\n    # Open fasta file\n    with open(gene_path) as gene_file:\n        header = gene_file.readline()\n        for line in gene_file:\n            seq = line.strip()\n            gene_seq += seq\n    return gene_seq", "response": "This function takes the database path and a gene name as inputs and \n    returns the gene sequence contained in the file given by the gene name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_db_mutations(mut_db_path, gene_list, res_stop_codons):\n\n    # Open resistens-overview.txt\n    try:\n        drugfile = open(mut_db_path, \"r\")\n    except:\n        sys.exit(\"Wrong path: %s\"%(mut_db_path))\n    \n    # Initiate variables\n    known_mutations = dict()\n    drug_genes = dict()\n    known_stop_codon = dict()\n    indelflag = False\n    stopcodonflag = False\n   \n    # Go throug mutation file line by line\n    for line in drugfile:\n        # Ignore headers and check where the indel section starts\n        if line.startswith(\"#\"):\n            if \"indel\" in line.lower():\n                indelflag = True\n            elif \"stop codon\" in line.lower():\n                stopcodonflag = True\n            else:\n                stopcodonflag = False\n            continue\n        # Ignore empty lines \n        if line.strip() == \"\":\n            continue\n        # Assert that all lines have the correct set of columns\n        mutation = [data.strip() for data in line.strip().split(\"\\t\")]\n        assert len(mutation) == 9, \"mutation overview file (%s) must have 9 columns, %s\"%(mut_db_path, mutation)\n\n        # Extract all info on the line (even though it is not all used)\n        gene_ID = mutation[0]\n\n        # Only consider mutations in genes found in the gene list\n        if gene_ID in gene_list:\n            gene_name = mutation[1]\n            no_of_mut = int(mutation[2])\n            mut_pos = int(mutation[3])\n            ref_codon = mutation[4]\n            ref_aa = mutation[5]\n            alt_aa = mutation[6].split(\",\")\n            res_drug = mutation[7].replace(\"\\t\", \" \")\n            pmid = mutation[8].split(\",\")\n\n            # Check if resistance is known to be caused by a stop codon in the gene\n            if (\"*\" in alt_aa and res_stop_codons != 'specified') or (res_stop_codons == 'specified' and stopcodonflag == True):\n                if gene_ID not in known_stop_codon:\n                    known_stop_codon[gene_ID] = {\"pos\": [], \"drug\": res_drug}\n                known_stop_codon[gene_ID][\"pos\"].append(mut_pos)\n\n            # Add genes associated with drug resistance to drug_genes dict\n            drug_lst = res_drug.split(\",\")\n            for drug in drug_lst:\n                drug = drug.upper()\n                if drug not in drug_genes:\n                    drug_genes[drug] = []\n                if gene_ID not in drug_genes[drug]:\n                    drug_genes[drug].append(gene_ID)\n\n            # Initiate empty dict to store relevant mutation information\n            mut_info = dict()\n            \n            # Save need mutation info with pmid cooresponding to the amino acid change\n            for i in range(len(alt_aa)):\n                try:\n                    mut_info[alt_aa[i]] = {\"gene_name\": gene_name, \"drug\": res_drug, \"pmid\": pmid[i]}\n                except IndexError:\n                    mut_info[alt_aa[i]] = {\"gene_name\": gene_name, \"drug\": res_drug, \"pmid\": \"-\"}\n    \n    \t    # Check if more than one mutations is needed for resistance\n            if no_of_mut != 1:\n                print(\"More than one mutation is needed, this is not implemented\",  mutation)\n    \n            # Add all possible types of mutations to the dict\n            if gene_ID not in known_mutations:\n                known_mutations[gene_ID] = {\"sub\" : dict(), \"ins\" : dict(), \"del\" : dict()}\n\n            # Check for the type of mutation\n            if indelflag == False:\n                mutation_type = \"sub\"\n            else:\n                mutation_type = ref_aa\n\n    \t    # Save mutations positions with required information given in mut_info\n            if mut_pos not in known_mutations[gene_ID][mutation_type]:\n                known_mutations[gene_ID][mutation_type][mut_pos] = dict() \n            for aa in alt_aa:\n                known_mutations[gene_ID][mutation_type][mut_pos][aa] = mut_info[aa]\n\n    drugfile.close()\n\n    # Check that all genes in the gene list has known mutations\n    for gene in gene_list:\n        if gene not in known_mutations:\n            known_mutations[gene] = {\"sub\" : dict(), \"ins\" : dict(), \"del\" : dict()}\n    return known_mutations, drug_genes, known_stop_codon", "response": "This function opens the file resistens - overview. txt and reads the content of the file into a dict of dicts. The keys are the gene ID and the values are the list of known mutations in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_best_sequence(hits_found, specie_path, gene, silent_N_flag):\n\n    # Get information from the fisrt hit found\t\n    all_start = hits_found[0][0]\n    current_end = hits_found[0][1]\n    final_sbjct = hits_found[0][2]\n    final_qry = hits_found[0][3] \n    sbjct_len = hits_found[0][4]  \n\n    alternative_overlaps = []\n    \n    # Check if more then one hit was found within the same gene\n    for i in range(len(hits_found)-1):\n\n        # Save information from previous hit\n        pre_block_start = hits_found[i][0]\n        pre_block_end = hits_found[i][1]\n        pre_sbjct = hits_found[i][2]\n        pre_qry = hits_found[i][3]\n\n\t# Save information from next hit\n        next_block_start = hits_found[i+1][0]\n        next_block_end = hits_found[i+1][1]\n        next_sbjct = hits_found[i+1][2]\n        next_qry = hits_found[i+1][3]\n\n        # Check for overlapping sequences, collaps them and save alternative overlaps if any\n        if next_block_start <= current_end:\n\n            # Find overlap start and take gaps into account     \n            pos_count = 0\n            overlap_pos = pre_block_start\n            for i in range(len(pre_sbjct)):\n\n                # Stop loop if overlap_start position is reached\n                if overlap_pos == next_block_start:\n                    overlap_start = pos_count\n                    break\n                if pre_sbjct[i] != \"-\":\n                    overlap_pos += 1\n                pos_count += 1\n            \n            # Find overlap length and add next sequence to final sequence \n            if len(pre_sbjct[overlap_start:]) > len(next_sbjct):\n                #  <--------->\n                #     <--->\n                overlap_len = len(next_sbjct)\n                overlap_end_pos = next_block_end\n            else:\n                #  <--------->\n                #        <--------->\n                overlap_len = len(pre_sbjct[overlap_start:])\n                overlap_end_pos = pre_block_end\n\n                # Update current end\n                current_end = next_block_end\n\n                # Use the entire pre sequence and add the last part of the next sequence\n                final_sbjct += next_sbjct[overlap_len:]\n                final_qry += next_qry[overlap_len:]\n                \n            # Find query overlap sequences\n            pre_qry_overlap = pre_qry[overlap_start : (overlap_start + overlap_len)] # can work for both types of overlap\n            next_qry_overlap = next_qry[:overlap_len]\n            sbjct_overlap = next_sbjct[:overlap_len]\n\n            # If alternative query overlap excist save it\n            if pre_qry_overlap != next_qry_overlap:\n                print(\"OVERLAP WARNING:\")\n                print(pre_qry_overlap, \"\\n\", next_qry_overlap)\n\n                # Save alternative overlaps\n                alternative_overlaps += [(next_block_start, overlap_end_pos, sbjct_overlap, next_qry_overlap)]\n        \n        elif next_block_start > current_end:\n            #  <------->\n            #              <-------> \n            gap_size = next_block_start - current_end - 1\n            final_qry += \"N\"*gap_size\n            if silent_N_flag:\n                final_sbjct += \"N\"*gap_size\n            else:\n                ref_seq = get_gene_seqs(specie_path, gene)\n                final_sbjct += ref_seq[pre_block_end:pre_block_end+gap_size]\n\n            current_end = next_block_end\n            final_sbjct += next_sbjct\n            final_qry += next_qry\n    \n    # Calculate coverage\n    no_call = final_qry.upper().count(\"N\")\n    coverage = (current_end - all_start +1 - no_call) / float(sbjct_len)\n    \n    # Calculate identity\n    equal = 0\n    not_equal = 0\n    for i in range(len(final_qry)):\n        if final_qry[i].upper() != \"N\":\n            if final_qry[i].upper() == final_sbjct[i].upper():\n                equal += 1\n            else:\n                not_equal += 1\n    identity = equal/float(equal + not_equal)\n\n    return final_sbjct, final_qry, all_start, current_end, alternative_overlaps, coverage, identity", "response": "This function finds the best sequence for a given gene from a list of hits found."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_mismatches(gene, sbjct_start, sbjct_seq, qry_seq, alternative_overlaps = []):\n\n    # Initiate the mis_matches list that will store all found mis matcehs\n    mis_matches = []\n\n    # Find mis matches in RNA genes\n    if gene in RNA_gene_list:\n        mis_matches += find_nucleotid_mismatches(sbjct_start, sbjct_seq, qry_seq)\n    else:\n        # Check if the gene sequence is with a promoter\n        regex = r\"promoter_size_(\\d+)(?:bp)\"\n        promtr_gene_objt = re.search(regex, gene)\n\n        # Check for promoter sequences\n        if promtr_gene_objt:\n\n            # Get promoter length\n            promtr_len = int(promtr_gene_objt.group(1))\n\n            # Extract promoter sequence, while considering gaps\t\n            # --------agt-->----\n            #    ---->?\n            if sbjct_start <= promtr_len:\n\n                #Find position in sbjct sequence where promoter ends\n                promtr_end = 0\n                nuc_count = sbjct_start - 1\n                for i in range(len(sbjct_seq)): \n                    promtr_end += 1\n                    if sbjct_seq[i] != \"-\":\n                        nuc_count += 1\n                    if nuc_count == promtr_len:\n                        break    \n\n                # Check if only a part of the promoter is found\n                #--------agt-->----\n                # ----\n                promtr_sbjct_start = -1\n                if nuc_count < promtr_len:\n                    promtr_sbjct_start = nuc_count - promtr_len\n\n                # Get promoter part of subject and query \n                sbjct_promtr_seq = sbjct_seq[:promtr_end]\n                qry_promtr_seq = qry_seq[:promtr_end]\n\n                \n                # For promoter part find nucleotide mis matches\n                mis_matches += find_nucleotid_mismatches(promtr_sbjct_start, sbjct_promtr_seq, qry_promtr_seq, promoter = True)\n                \n                # Check if gene is also found\n                #--------agt-->----\n                #     -----------           \n                if (sbjct_start + len(sbjct_seq.replace(\"-\", \"\"))) > promtr_len:\n                    sbjct_gene_seq = sbjct_seq[promtr_end:]\n                    qry_gene_seq = qry_seq[promtr_end:]\n                    sbjct_gene_start = 1\n\n                    # Find mismatches in gene part\n                    mis_matches += find_codon_mismatches(sbjct_gene_start, sbjct_gene_seq, qry_gene_seq)\n            \n            # No promoter, only gene is found\n            #--------agt-->----\n            #            ----- \n            else:\n                sbjct_gene_start = sbjct_start - promtr_len\n            \n                # Find mismatches in gene part\n                mis_matches += find_codon_mismatches(sbjct_gene_start, sbjct_seq, qry_seq)\n            \n        else:\n            # Find mismatches in gene\n            mis_matches += find_codon_mismatches(sbjct_start, sbjct_seq, qry_seq)\n\n    # Find mismatches in alternative overlaps if any\n    for overlap in alternative_overlaps:\n        mis_matches += find_mismatches(gene, overlap[0], overlap[2], overlap[3])\n\n    return mis_matches", "response": "This function finds mis matches between two sequences."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_nucleotid_mismatches(sbjct_start, sbjct_seq, qry_seq, promoter = False):\n\n    # Initiate the mis_matches list that will store all found mis matcehs\n    mis_matches = []\n    \n    sbjct_start = abs(sbjct_start)\n    seq_pos = sbjct_start\n\n    # Set variables depending on promoter status\n    factor = 1\n    mut_prefix = \"r.\"\n    if promoter == True:\n        factor = (-1)\n        mut_prefix = \"n.\"\n        # Reverse promoter sequences\n        sbjct_seq = sbjct_seq[::-1]\n        qry_seq = qry_seq[::-1]    \n    \n    # Go through sequences one nucleotide at a time\n    shift = 0\n    for index in range(sbjct_start - 1, len(sbjct_seq)):\n        mut_name = mut_prefix\n        mut = \"\"\n\n        # Shift index according to gaps\n        i = index + shift\n        \n        # If the end of the sequence is reached, stop\n        if i == len(sbjct_seq):\n            break\n        \n        sbjct_nuc = sbjct_seq[i]\n        qry_nuc = qry_seq[i]\n        \n        # Check for mis matches\n        if sbjct_nuc.upper() != qry_nuc.upper():\n            \n            # check for insertions and deletions\n            if sbjct_nuc == \"-\" or qry_nuc == \"-\":\n                if sbjct_nuc == \"-\":\n                    mut = \"ins\"\n                    indel_start_pos = (seq_pos -1) *factor\n                    indel_end_pos = seq_pos * factor\n                    indel = find_nuc_indel(sbjct_seq[i:], qry_seq[i:])\n                else:\n                    mut = \"del\"\n                    indel_start_pos = seq_pos * factor\n                    indel = find_nuc_indel(qry_seq[i:], sbjct_seq[i:]) \n                    indel_end_pos = (seq_pos + len(indel) - 1) * factor  \n                    seq_pos += len(indel) - 1\n                \n                # Shift the index to the end of the indel\n                shift += len(indel) - 1\n                                     \n                # Write mutation name, depending on sequnce\n                if len(indel) == 1 and mut == \"del\":\n                    mut_name += str(indel_start_pos) + mut + indel\n                else:\n                    if promoter == True:\n\n                        # Reverse the sequence and the start and end positions\n                        indel = indel[::-1]\n                        temp = indel_start_pos\n                        indel_start_pos = indel_end_pos\n                        indel_end_pos = temp\n    \n                    mut_name += str(indel_start_pos) + \"_\" +str(indel_end_pos) + mut + indel  \n                \n                mis_matches += [[mut, seq_pos * factor, seq_pos * factor, indel, mut_name, mut, indel]]\n            \n            # Check for substitutions mutations\n            else:\n                mut = \"sub\"\n                mut_name += str(seq_pos * factor) + sbjct_nuc + \">\" + qry_nuc\n                mis_matches += [[mut, seq_pos * factor, seq_pos * factor, qry_nuc, mut_name, sbjct_nuc, qry_nuc]]\n\n        # Increment sequence position\n        if mut != \"ins\":\n            seq_pos += 1\n\n    return mis_matches", "response": "This function finds mis matches in a sequence of nucleotides in a subject and query."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef aa(codon):\n    codon = codon.upper()\n    aa = {\"ATT\": \"I\", \"ATC\": \"I\", \"ATA\": \"I\",\n            \"CTT\": \"L\", \"CTC\": \"L\", \"CTA\": \"L\", \"CTG\": \"L\", \"TTA\": \"L\", \"TTG\": \"L\",\n            \"GTT\": \"V\", \"GTC\": \"V\", \"GTA\": \"V\", \"GTG\": \"V\",\n            \"TTT\": \"F\", \"TTC\": \"F\",\n            \"ATG\": \"M\",\n            \"TGT\": \"C\", \"TGC\": \"C\",\n            \"GCT\": \"A\", \"GCC\": \"A\", \"GCA\": \"A\", \"GCG\": \"A\",\n            \"GGT\": \"G\", \"GGC\": \"G\", \"GGA\": \"G\", \"GGG\": \"G\",\n            \"CCT\": \"P\", \"CCC\": \"P\", \"CCA\": \"P\", \"CCG\": \"P\",\n            \"ACT\": \"T\", \"ACC\": \"T\", \"ACA\": \"T\", \"ACG\": \"T\",\n            \"TCT\": \"S\", \"TCC\": \"S\", \"TCA\": \"S\", \"TCG\": \"S\", \"AGT\": \"S\", \"AGC\": \"S\",\n            \"TAT\": \"Y\", \"TAC\": \"Y\",\n            \"TGG\": \"W\",\n            \"CAA\": \"Q\", \"CAG\": \"Q\",\n            \"AAT\": \"N\", \"AAC\": \"N\",\n            \"CAT\": \"H\", \"CAC\": \"H\",\n            \"GAA\": \"E\", \"GAG\": \"E\",\n            \"GAT\": \"D\", \"GAC\": \"D\",\n            \"AAA\": \"K\", \"AAG\": \"K\",\n            \"CGT\": \"R\", \"CGC\": \"R\", \"CGA\": \"R\", \"CGG\": \"R\", \"AGA\": \"R\", \"AGG\": \"R\",\n            \"TAA\": \"*\", \"TAG\": \"*\", \"TGA\": \"*\"} \n\n    # Translate valid codon \n    try:\n        amino_a = aa[codon]\n    except KeyError:\n        amino_a = \"?\"\n    return amino_a", "response": "This function converts a codon to an amino acid."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_inframe_gap(seq, nucs_needed = 3):\n    nuc_count = 0\n    gap_indel  = \"\"\n    nucs = \"\"\n    for i in range(len(seq)):\n\n        # Check if the character is not a gap\n        if seq[i] != \"-\":\n\n            # Check if the indel is a 'clean' \n            # i.e. if the insert or deletion starts at the first nucleotide in the codon and can be divided by 3\n            if gap_indel.count(\"-\") == len(gap_indel) and gap_indel.count(\"-\") >= 3 and len(gap_indel) != 0:\n                return gap_indel\n            nuc_count += 1\n        gap_indel += seq[i]\n\n        # If the number of nucleotides in the indel equals the amount needed for the indel, the indel is returned.\n        if nuc_count == nucs_needed:\n            return gap_indel\n\n    # This will only happen if the gap is in the very end of a sequence\n    return gap_indel", "response": "This function takes a sequence and returns the inframe gap of the sequence."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_indels(sbjct_seq, qry_seq, start_pos):\n\n    seqs = [sbjct_seq, qry_seq]\n    indels = []\n    gap_obj = re.compile(r\"-+\")\n    for i in range(len(seqs)):\n        for match in gap_obj.finditer(seqs[i]):\n            pos = int(match.start())\n            gap = match.group()\n\n            # Find position of the mutation corresponding to the subject sequence\n            sbj_pos = len(sbjct_seq[:pos].replace(\"-\",\"\")) + start_pos\n    \n            # Get indel sequence and the affected sequences in sbjct and qry in the reading frame\n            indel = seqs[abs(i-1)][pos:pos+len(gap)]                   \n\n            # Find codon number for mutation\n            codon_no = int(math.ceil((sbj_pos)/3))\n            qry_pos = len(qry_seq[:pos].replace(\"-\",\"\")) + start_pos\n            qry_codon = int(math.ceil((qry_pos)/3))\n            if i == 0:\n                mut = \"ins\"\n            else:\n                mut = \"del\"\n            \n            indels.append( [mut, codon_no, sbj_pos, indel, qry_codon])\n\n    # Sort indels based on codon position and sequence position\n    indels = sorted(indels, key = lambda x:(x[1],x[2]))\n    \n    return indels", "response": "This function uses regex to find insert and delete indels in sequences\n    given as arguments. A list of these indels are returned."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_codon_mismatches(sbjct_start, sbjct_seq, qry_seq):\n    mis_matches = []\n    \n    # Find start pos of first codon in frame, i_start\n    codon_offset = (sbjct_start-1) % 3\n    i_start = 0\n    if codon_offset != 0:\n        i_start = 3 - codon_offset\n    sbjct_start = sbjct_start + i_start\n    \n    # Set sequences in frame\n    sbjct_seq = sbjct_seq[i_start:]\n    qry_seq = qry_seq[i_start:]\n    \n    # Find codon number of the first codon in the sequence, start at 0\n    codon_no = int((sbjct_start-1) / 3) # 1,2,3 start on 0\n  \n    # s_shift and q_shift are used when gaps appears\n    q_shift = 0\n    s_shift = 0\n    mut_no = 0\n    \n    # Find inserts and deletions in sequence\n    indel_no = 0\n    indels = get_indels(sbjct_seq, qry_seq, sbjct_start)\n\n    # Go through sequence and save mutations when found\n    for index in range(0, len(sbjct_seq), 3):\n        # Count codon number\n        codon_no += 1\n        \n        # Shift index according to gaps\n        s_i = index + s_shift\n        q_i = index + q_shift\n\n        # Get codons\n        sbjct_codon = sbjct_seq[s_i:s_i+3]\n        qry_codon =  qry_seq[q_i:q_i+3]\n        \n        if len(sbjct_seq[s_i:].replace(\"-\",\"\")) + len(qry_codon[q_i:].replace(\"-\",\"\")) < 6:\n            break\n\n        # Check for mutations\n        if sbjct_codon.upper() != qry_codon.upper():\n\n            # Check for codon insertions and deletions and frameshift mutations\n            if \"-\" in sbjct_codon or \"-\" in qry_codon:\n\n                # Get indel info\n                try:\n                    indel_data = indels[indel_no]\n                except IndexError:\n                    print(sbjct_codon, qry_codon)\n                    print(indels)\n                    print(gene, indel_data, indel_no)\n                mut = indel_data[0]\n                codon_no_indel = indel_data[1]                \n                seq_pos = indel_data[2] + sbjct_start - 1\n                indel = indel_data[3]\n                indel_no +=1\n                \n                # Get the affected sequence in frame for both for sbjct and qry \n                if mut == \"ins\":\n                    sbjct_rf_indel = get_inframe_gap(sbjct_seq[s_i:], 3)\n                    qry_rf_indel = get_inframe_gap(qry_seq[q_i:], int(math.floor(len(sbjct_rf_indel)/3) *3))                    \n                else:\n                    qry_rf_indel = get_inframe_gap(qry_seq[q_i:], 3)\n                    sbjct_rf_indel = get_inframe_gap(sbjct_seq[s_i:], int(math.floor(len(qry_rf_indel)/3) *3))\n                                        \n                mut_name, aa_ref, aa_alt = name_indel_mutation(sbjct_seq, indel, sbjct_rf_indel, qry_rf_indel, codon_no, mut, sbjct_start - 1)\n\n                # Set index to the correct reading frame after the indel gap \n                shift_diff_before = abs(s_shift - q_shift)\n                s_shift += len(sbjct_rf_indel) - 3\n                q_shift += len(qry_rf_indel) - 3\n                shift_diff = abs(s_shift - q_shift)\n\n                if shift_diff_before != 0 and shift_diff %3 == 0:\n\n                    if s_shift > q_shift:\n                        nucs_needed = int((len(sbjct_rf_indel)/3) *3) + shift_diff\n                        pre_qry_indel = qry_rf_indel\n                        qry_rf_indel = get_inframe_gap(qry_seq[q_i:], nucs_needed)\n                        q_shift += len(qry_rf_indel) - len(pre_qry_indel)\n                    elif q_shift > s_shift:\n                        nucs_needed = int((len(qry_rf_indel)/3)*3) + shift_diff\n                        pre_sbjct_indel = sbjct_rf_indel\n                        sbjct_rf_indel = get_inframe_gap(sbjct_seq[s_i:], nucs_needed)\n                        s_shift += len(sbjct_rf_indel) - len(pre_sbjct_indel)\n\n                    \n                    mut_name, aa_ref, aa_alt = name_indel_mutation(sbjct_seq, indel, sbjct_rf_indel, qry_rf_indel, codon_no, mut, sbjct_start - 1) \n\n                    if \"Frameshift\" in mut_name:\n                        mut_name = mut_name.split(\"-\")[0] + \"- Frame restored\"\n\n                mis_matches += [[mut, codon_no_indel, seq_pos, indel, mut_name, sbjct_rf_indel, qry_rf_indel, aa_ref, aa_alt]]\n\n                # Check if the next mutation in the indels list is in the current codon\n                # Find the number of individul gaps in the evaluated sequence\n                no_of_indels = len(re.findall(\"\\-\\w\", sbjct_rf_indel)) + len(re.findall(\"\\-\\w\", qry_rf_indel))\n                if no_of_indels > 1:\n\n                    for j in range(indel_no, indel_no + no_of_indels - 1):\n                        try:\n                            indel_data = indels[j]\n                        except IndexError:\n                            sys.exit(\"indel_data list is out of range, bug!\")\n                        mut = indel_data[0]\n                        codon_no_indel = indel_data[1]                \n                        seq_pos = indel_data[2] + sbjct_start - 1\n                        indel = indel_data[3]\n                        indel_no +=1\n                        mis_matches += [[mut, codon_no_indel, seq_pos, indel, mut_name, sbjct_rf_indel, qry_rf_indel, aa_ref, aa_alt]]\n\n                # Set codon number, and save nucleotides from out of frame mutations                \n                if mut == \"del\":\n                    codon_no += int((len(sbjct_rf_indel) - 3)/3)\n                # If evaluated insert is only gaps codon_no should not increment\n                elif sbjct_rf_indel.count(\"-\") == len(sbjct_rf_indel):\n                    codon_no -= 1\n            \n            # Check of point mutations\n            else:\n                mut = \"sub\"\n                aa_ref = aa(sbjct_codon)\n                aa_alt = aa(qry_codon)\n                \n                if aa_ref != aa_alt:\n                    # End search for mutation if a premature stop codon is found\n                    mut_name = \"p.\" + aa_ref + str(codon_no) + aa_alt\n\n                    mis_matches += [[mut, codon_no, codon_no, aa_alt, mut_name, sbjct_codon, qry_codon, aa_ref, aa_alt]]\n\n            # If a Premature stop codon occur report it an stop the loop\n            try:\n                if mis_matches[-1][-1] == \"*\":\n                    mut_name += \" - Premature stop codon\"\n                    mis_matches[-1][4] = mis_matches[-1][4].split(\"-\")[0] + \" - Premature stop codon\"\n                    break\n            except IndexError:\n                pass\n\n    # Sort mutations on position\n    mis_matches = sorted(mis_matches, key = lambda x:x[1])\n    \n    return mis_matches", "response": "This function finds mismatches in a sequence in a given subject and query."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_output(gene, gene_name, mis_matches, known_mutations, known_stop_codon, unknown_flag, GENES):\n    RNA = False\n    known_header = \"Mutation\\tNucleotide change\\tAmino acid change\\tResistance\\tPMID\\n\"\n    unknown_header = \"Mutation\\tNucleotide change\\tAmino acid change\\n\"\n    if gene in RNA_gene_list:\n        RNA = True\n        known_header = \"Mutation\\tNucleotide change\\tResistance\\tPMID\\n\"\n        unknown_header = \"Mutation\\tNucleotide change\\n\"\n\n    known_lst = []\n    unknown_lst = []\n    all_results_lst = [] \n    output_mut = []\n    stop_codons = []\n\n    # Go through each mutation    \n    for i in range(len(mis_matches)):\n        m_type = mis_matches[i][0]\n        pos = mis_matches[i][1] # sort on pos?\n        look_up_pos = mis_matches[i][2]\n        look_up_mut = mis_matches[i][3]\n        mut_name = mis_matches[i][4]\n        nuc_ref = mis_matches[i][5]\n        nuc_alt = mis_matches[i][6]\n        ref =  mis_matches[i][-2]\n        alt = mis_matches[i][-1]\n\n        # First index in list indicates if mutation is known\n        output_mut += [[]]\n        #output_mut[i] = [0]\n\n    \t# Define output vaiables\n        codon_change = nuc_ref + \" -> \" + nuc_alt\n        aa_change = ref + \" -> \" + alt\n        if RNA == True:\n            aa_change = \"RNA mutations\"\n        elif pos < 0:\n            aa_change = \"Promoter mutations\"\n        \n        # Check if mutation is known\n        gene_mut_name, resistence, pmid = look_up_known_muts(known_mutations, known_stop_codon, gene, look_up_pos, look_up_mut, m_type, gene_name, mut_name)\n        gene_mut_name = gene_mut_name + \" \" + mut_name\n\n        output_mut[i] = [gene_mut_name, codon_change, aa_change, resistence, pmid]\n        \n        # Add mutation to output strings for known mutations \n        if resistence != \"Unknown\":\n            if RNA == True:\n                # don't include the amino acid change field for RNA mutations\n                known_lst += [\"\\t\".join(output_mut[i][:2]) + \"\\t\" + \"\\t\".join(output_mut[i][3:])]\n            else:\n                known_lst += [\"\\t\".join(output_mut[i])]\n            all_results_lst += [\"\\t\".join(output_mut[i])]\n\n        # Add mutation to output strings for unknown mutations \n        else:\n            if RNA == True:\n                unknown_lst += [\"\\t\".join(output_mut[i][:2])]\n            else:\n                unknown_lst += [\"\\t\".join(output_mut[i][:3])]\n            if unknown_flag == True:\n                all_results_lst += [\"\\t\".join(output_mut[i])]\n\n        # Check that you do not print two equal lines (can happen it two indels occure in the same codon)\n        if len(output_mut) > 1:\n            if output_mut[i] == output_mut[i-1]:\n                if resistence != \"Unknown\":\n                    known_lst = known_lst[:-1]\n                    all_results_lst = all_results_lst[:-1]\n                else:\n                    unknown_lst = unknown_lst[:-1]\n                    if unknown_flag == True:\n                        all_results_lst = all_results_lst[:-1]\n        if \"Premature stop codon\" in mut_name:\n            sbjct_len = GENES[gene]['sbjct_len']\n            qry_len = pos * 3 \n            prec_truckat = round(((float(sbjct_len) - qry_len )/ float(sbjct_len)) * 100, 2) \n            perc = \"%\"\n            stop_codons.append(\"Premature stop codon in %s, %.2f%s lost\"%(gene, prec_truckat, perc))\n\n    # Creat final strings\n    all_results = \"\\n\".join(all_results_lst)\n    total_known_str = \"\" \n    total_unknown_str = \"\"\n\n    # Check if there are only unknown mutations\n    resistence_lst = [res for mut in output_mut for res in mut[3].split(\",\")]\n\n    # Save known mutations\n    unknown_no = resistence_lst.count(\"Unknown\")\n    if unknown_no < len(resistence_lst):\n        total_known_str = known_header + \"\\n\".join(known_lst)\n    else:\n        total_known_str = \"No known mutations found in %s\"%gene_name\n\n    # Save unknown mutations\n    if unknown_no > 0:\n        total_unknown_str = unknown_header + \"\\n\".join(unknown_lst)\n    else:\n        total_unknown_str = \"No unknown mutations found in %s\"%gene_name\n\n    return all_results, total_known_str, total_unknown_str, resistence_lst + stop_codons", "response": "This function takes a gene name a list of mis matches found betreewn subject and query of a gene and returns a list of strings that can be written to the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntries to merge all the bravado_core models across all loaded APIs and return them as a new set of bravado_core models.", "response": "def merge(self):\n        \"\"\"Try merging all the bravado_core models across all loaded APIs. If\n        duplicates occur, use the same bravado-core model to represent each, so\n        bravado-core won't treat them as different models when passing them\n        from one PyMacaron client stub to an other or when returning them via the\n        PyMacaron server stub.\n        \"\"\"\n\n        # The sole purpose of this method is to trick isinstance to return true\n        # on model_values of the same kind but different apis/specs at:\n        # https://github.com/Yelp/bravado-core/blob/4840a6e374611bb917226157b5948ee263913abc/bravado_core/marshal.py#L160\n\n        log.info(\"Merging models of apis \" + \", \".join(apis.keys()))\n\n        # model_name => (api_name, model_json_def, bravado_core.model.MODELNAME)\n        models = {}\n\n        # First pass: find duplicate and keep only one model of each (fail if\n        # duplicates have same name but different definitions)\n        for api_name, api in apis.items():\n            for model_name, model_def in api.api_spec.swagger_dict['definitions'].items():\n                if model_name in models:\n                    other_api_name, other_model_def, _ = models.get(model_name)\n                    log.debug(\"Model %s in %s is a duplicate of one in %s\" % (model_name, api_name, other_api_name))\n\n                    if ApiPool._cmp_models(model_def, other_model_def) != 0:\n                        raise MergeApisException(\"Cannot merge apis! Model %s exists in apis %s and %s but have different definitions:\\n[%s]\\n[%s]\"\n                                                 % (model_name, api_name, other_api_name, pprint.pformat(model_def), pprint.pformat(other_model_def)))\n                else:\n                    models[model_name] = (api_name, model_def, api.api_spec.definitions[model_name])\n\n        # Second pass: patch every models and replace with the one we decided\n        # to keep\n        log.debug(\"Patching api definitions to remove all duplicates\")\n        for api_name, api in apis.items():\n            for model_name in api.api_spec.definitions.keys():\n                _, _, model_class = models.get(model_name)\n                api.api_spec.definitions[model_name] = model_class"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncompares two models and return True if they are equal False otherwise.", "response": "def _cmp_models(self, m1, m2):\n        \"\"\"Compare two models from different swagger APIs and tell if they are\n        equal (return 0), or not (return != 0)\"\"\"\n\n        # Don't alter m1/m2 by mistake\n        m1 = copy.deepcopy(m1)\n        m2 = copy.deepcopy(m2)\n\n        # Remove keys added by bravado-core\n        def _cleanup(d):\n            \"\"\"Remove all keys in the blacklist\"\"\"\n            for k in ('x-model', 'x-persist', 'x-scope'):\n                if k in d:\n                    del d[k]\n            for v in list(d.values()):\n                if isinstance(v, dict):\n                    _cleanup(v)\n\n        _cleanup(m1)\n        _cleanup(m2)\n\n        # log.debug(\"model1:\\n\" + pprint.pformat(m1))\n        # log.debug(\"model2:\\n\" + pprint.pformat(m2))\n        return not m1 == m2"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(\n        self,\n        name,\n        command_to_run,\n        description=\"\",\n        environment_variables=None,\n        required_arguments=None,\n        required_arguments_default_values=None,\n        extra_data_to_post=None,\n    ):\n        \"\"\"Create a task type.\n\n        Args:\n            name (str): The name of the task.\n            command_to_run (str): The command to run to execute the task.\n            description (str, optional): The description of the task type.\n            environment_variables (list, optional): The environment\n                variables required on the host to execute the task.\n            required_arguments (list, optional): The argument names for\n                the task type.\n            required_arguments_default_values (dict, optional): Default\n                values for the tasks required arguments.\n            extra_data_to_post (dict, optional): Extra key-value pairs\n                to add to the request data. This is useful for\n                subclasses which require extra parameters.\n\n        Returns:\n            :class:`saltant.models.base_task_instance.BaseTaskType`:\n                A task type model instance representing the task type\n                just created.\n        \"\"\"\n        # Set None for optional list and dicts to proper datatypes\n        if environment_variables is None:\n            environment_variables = []\n\n        if required_arguments is None:\n            required_arguments = []\n\n        if required_arguments_default_values is None:\n            required_arguments_default_values = {}\n\n        # Create the object\n        request_url = self._client.base_api_url + self.list_url\n        data_to_post = {\n            \"name\": name,\n            \"description\": description,\n            \"command_to_run\": command_to_run,\n            \"environment_variables\": json.dumps(environment_variables),\n            \"required_arguments\": json.dumps(required_arguments),\n            \"required_arguments_default_values\": json.dumps(\n                required_arguments_default_values\n            ),\n        }\n\n        # Add in extra data if any was passed in\n        if extra_data_to_post is not None:\n            data_to_post.update(extra_data_to_post)\n\n        response = self._client.session.post(request_url, data=data_to_post)\n\n        # Validate that the request was successful\n        self.validate_request_success(\n            response_text=response.text,\n            request_url=request_url,\n            status_code=response.status_code,\n            expected_status_code=HTTP_201_CREATED,\n        )\n\n        # Return a model instance representing the task type\n        return self.response_data_to_model_instance(response.json())", "response": "Creates a new object of the specified type."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the object type with the given parameters.", "response": "def put(\n        self,\n        id,\n        name,\n        description,\n        command_to_run,\n        environment_variables,\n        required_arguments,\n        required_arguments_default_values,\n        extra_data_to_put=None,\n    ):\n        \"\"\"Updates a task type on the saltant server.\n\n        Args:\n            id (int): The ID of the task type.\n            name (str): The name of the task type.\n            description (str): The description of the task type.\n            command_to_run (str): The command to run to execute the task.\n            environment_variables (list): The environment variables\n                required on the host to execute the task.\n            required_arguments (list): The argument names for the task type.\n            required_arguments_default_values (dict): Default values for\n                the tasks required arguments.\n            extra_data_to_put (dict, optional): Extra key-value pairs to\n                add to the request data. This is useful for subclasses\n                which require extra parameters.\n\n        Returns:\n            :class:`saltant.models.base_task_type.BaseTaskType`:\n                A :class:`saltant.models.base_task_type.BaseTaskType`\n                subclass instance representing the task type just\n                updated.\n        \"\"\"\n        # Update the object\n        request_url = self._client.base_api_url + self.detail_url.format(id=id)\n        data_to_put = {\n            \"name\": name,\n            \"description\": description,\n            \"command_to_run\": command_to_run,\n            \"environment_variables\": json.dumps(environment_variables),\n            \"required_arguments\": json.dumps(required_arguments),\n            \"required_arguments_default_values\": json.dumps(\n                required_arguments_default_values\n            ),\n        }\n\n        # Add in extra data if any was passed in\n        if extra_data_to_put is not None:\n            data_to_put.update(extra_data_to_put)\n\n        response = self._client.session.put(request_url, data=data_to_put)\n\n        # Validate that the request was successful\n        self.validate_request_success(\n            response_text=response.text,\n            request_url=request_url,\n            status_code=response.status_code,\n            expected_status_code=HTTP_200_OK,\n        )\n\n        # Return a model instance representing the task instance\n        return self.response_data_to_model_instance(response.json())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert the response data to a task type model.", "response": "def response_data_to_model_instance(self, response_data):\n        \"\"\"Convert response data to a task type model.\n\n        Args:\n            response_data (dict): The data from the request's response.\n\n        Returns:\n            :class:`saltant.models.base_task_type.BaseTaskType`:\n                A model instance representing the task type from the\n                reponse data.\n        \"\"\"\n        # Coerce datetime strings into datetime objects\n        response_data[\"datetime_created\"] = dateutil.parser.parse(\n            response_data[\"datetime_created\"]\n        )\n\n        # Instantiate a model for the task instance\n        return super(\n            BaseTaskTypeManager, self\n        ).response_data_to_model_instance(response_data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun regression testing - lint and then run all tests.", "response": "def regression():\n    \"\"\"\n    Run regression testing - lint and then run all tests.\n    \"\"\"\n    # HACK: Start using hitchbuildpy to get around this.\n    Command(\"touch\", DIR.project.joinpath(\"pathquery\", \"__init__.py\").abspath()).run()\n    storybook = _storybook({}).only_uninherited()\n    #storybook.with_params(**{\"python version\": \"2.7.10\"})\\\n             #.ordered_by_name().play()\n    Command(\"touch\", DIR.project.joinpath(\"pathquery\", \"__init__.py\").abspath()).run()\n    storybook.with_params(**{\"python version\": \"3.5.0\"}).ordered_by_name().play()\n    lint()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndeploy to pypi as specified version.", "response": "def deploy(version):\n    \"\"\"\n    Deploy to pypi as specified version.\n    \"\"\"\n    NAME = \"pathquery\"\n    git = Command(\"git\").in_dir(DIR.project)\n    version_file = DIR.project.joinpath(\"VERSION\")\n    old_version = version_file.bytes().decode('utf8')\n    if version_file.bytes().decode(\"utf8\") != version:\n        DIR.project.joinpath(\"VERSION\").write_text(version)\n        git(\"add\", \"VERSION\").run()\n        git(\"commit\", \"-m\", \"RELEASE: Version {0} -> {1}\".format(\n            old_version,\n            version\n        )).run()\n        git(\"push\").run()\n        git(\"tag\", \"-a\", version, \"-m\", \"Version {0}\".format(version)).run()\n        git(\"push\", \"origin\", version).run()\n    else:\n        git(\"push\").run()\n\n    # Set __version__ variable in __init__.py, build sdist and put it back\n    initpy = DIR.project.joinpath(NAME, \"__init__.py\")\n    original_initpy_contents = initpy.bytes().decode('utf8')\n    initpy.write_text(\n        original_initpy_contents.replace(\"DEVELOPMENT_VERSION\", version)\n    )\n    python(\"setup.py\", \"sdist\").in_dir(DIR.project).run()\n    initpy.write_text(original_initpy_contents)\n\n    # Upload to pypi\n    python(\n        \"-m\", \"twine\", \"upload\", \"dist/{0}-{1}.tar.gz\".format(NAME, version)\n    ).in_dir(DIR.project).run()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninstall a new version of a package in the hitch venv.", "response": "def hvenvup(package, directory):\n    \"\"\"\n    Install a new version of a package in the hitch venv.\n    \"\"\"\n    pip = Command(DIR.gen.joinpath(\"hvenv\", \"bin\", \"pip\"))\n    pip(\"uninstall\", package, \"-y\").run()\n    pip(\"install\", DIR.project.joinpath(directory).abspath()).run()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset up the application and test environment.", "response": "def set_up(self):\n        \"\"\"Set up your applications and the test environment.\"\"\"\n        self.path.state = self.path.gen.joinpath(\"state\")\n        if self.path.state.exists():\n            self.path.state.rmtree(ignore_errors=True)\n        self.path.state.mkdir()\n\n        if self.path.gen.joinpath(\"q\").exists():\n            self.path.gen.joinpath(\"q\").remove()\n\n        for filename, text in self.given.get(\"files\", {}).items():\n            filepath = self.path.state.joinpath(filename)\n            if not filepath.dirname().exists():\n                filepath.dirname().makedirs()\n            filepath.write_text(text)\n\n        for filename, linkto in self.given.get(\"symlinks\", {}).items():\n            filepath = self.path.state.joinpath(filename)\n            linktopath = self.path.state.joinpath(linkto)\n            linktopath.symlink(filepath)\n\n        for filename, permission in self.given.get(\"permissions\", {}).items():\n            filepath = self.path.state.joinpath(filename)\n            filepath.chmod(int(permission, 8))\n\n\n        pylibrary = hitchbuildpy.PyLibrary(\n            name=\"py3.5.0\",\n            base_python=hitchbuildpy.PyenvBuild(\"3.5.0\").with_build_path(self.path.share),\n            module_name=\"pathquery\",\n            library_src=self.path.project,\n        ).with_build_path(self.path.gen)\n        \n        pylibrary.ensure_built()\n        \n        self.python = pylibrary.bin.python\n\n\n        self.example_py_code = ExamplePythonCode(self.python, self.path.state)\\\n            .with_code(self.given.get('code', ''))\\\n            .with_setup_code(self.given.get('setup', ''))\\\n            .with_terminal_size(160, 100)\\\n            .with_env(TMPDIR=self.path.gen)\\\n            .with_long_strings(\n                yaml_snippet_1=self.given.get('yaml_snippet_1'),\n                yaml_snippet=self.given.get('yaml_snippet'),\n                yaml_snippet_2=self.given.get('yaml_snippet_2'),\n                modified_yaml_snippet=self.given.get('modified_yaml_snippet'),\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_valid(self):\n        self.errors = []\n\n        for field in self.get_all_field_names_declared_by_user():\n            getattr(type(self), field).is_valid(self, type(self), field)\n            field_errors = getattr(type(self), field).errors(self)\n            self.errors.extend(field_errors)\n\n        return len(self.errors) == 0", "response": "Validates single instance. Returns boolean value and store errors in self. errors\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main(self):\n        logging.info('Starting {} analysis pipeline'.format(self.analysistype))\n        self.createobjects()\n        # Run the genesipping analyses\n        self.methods()\n        # Determine if the analyses are complete\n        self.complete()\n        self.additionalsipping()\n        # Update the report object\n        self.reports = Reports(self)\n        # Once all the analyses are complete, create reports for each sample\n        Reports.methodreporter(self.reports)\n        # Print the metadata\n        printer = MetadataPrinter(self)\n        printer.printmetadata()", "response": "Run the analyses and create the object objects and report objects for each sample."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef methods(self):\n        self.contamination_detection()\n        ReportImage(self, 'confindr')\n        self.run_genesippr()\n        ReportImage(self, 'genesippr')\n        self.run_sixteens()\n        self.run_mash()\n        self.run_gdcs()\n        ReportImage(self, 'gdcs')", "response": "Run the typing methods"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the levels of contamination in the reads", "response": "def contamination_detection(self):\n        \"\"\"\n        Calculate the levels of contamination in the reads\n        \"\"\"\n        self.qualityobject = quality.Quality(self)\n        self.qualityobject.contamination_finder(input_path=self.sequencepath,\n                                                report_path=self.reportpath)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_genesippr(self):\n        GeneSippr(args=self,\n                  pipelinecommit=self.commit,\n                  startingtime=self.starttime,\n                  scriptpath=self.homepath,\n                  analysistype='genesippr',\n                  cutoff=0.95,\n                  pipeline=False,\n                  revbait=False)", "response": "Run the genesippr analyses"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_sixteens(self):\n        SixteensFull(args=self,\n                     pipelinecommit=self.commit,\n                     startingtime=self.starttime,\n                     scriptpath=self.homepath,\n                     analysistype='sixteens_full',\n                     cutoff=0.985)", "response": "Run the 16S analyses using the filtered database"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_mash(self):\n        self.pipeline = True\n        mash.Mash(inputobject=self,\n                  analysistype='mash')", "response": "Run MASH to determine the closest refseq genomes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndetermine if the analyses of the strains are complete e. g. there are no missing GDCS genes and there are no missing GDCS genes.", "response": "def complete(self):\n        \"\"\"\n        Determine if the analyses of the strains are complete e.g. there are no missing GDCS genes, and the \n        sample.general.bestassemblyfile != 'NA'\n        \"\"\"\n        # Boolean to store the completeness of the analyses\n        allcomplete = True\n        # Clear the list of samples that still require more sequence data\n        self.incomplete = list()\n        for sample in self.runmetadata.samples:\n            if sample.general.bestassemblyfile != 'NA':\n                try:\n                    # If the sample has been tagged as incomplete, only add it to the complete metadata list if the\n                    # pipeline is on its final iteration\n                    if sample.general.incomplete:\n                        if self.final:\n                            self.completemetadata.append(sample)\n                        else:\n                            sample.general.complete = False\n                            allcomplete = False\n                            self.incomplete.append(sample.name)\n                except AttributeError:\n                    sample.general.complete = True\n                    self.completemetadata.append(sample)\n            else:\n                if self.final:\n                    self.completemetadata.append(sample)\n                else:\n                    sample.general.complete = False\n                    allcomplete = False\n                    self.incomplete.append(sample.name)\n        # If all the samples are complete, set the global variable for run completeness to True\n        if allcomplete:\n            self.analysescomplete = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef protected_operation(fn):\n    @functools.wraps(fn)\n    def advice(parent_object, *args, **kw):\n        response = _advice(parent_object.request)\n        if response is not None:\n            return response\n        else:\n            return fn(parent_object, *args, **kw)\n\n    return advice", "response": "Decorator to prevent an operation from being executed when the related uri resource is still in use."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef protected_operation_with_request(fn):\n\n    @functools.wraps(fn)\n    def wrapped(request, *args, **kwargs):\n        response = _advice(request)\n        if response is not None:\n            return response\n        else:\n            return fn(request, *args, **kwargs)\n\n    return wrapped", "response": "Decorator to prevent an operation from being executed when the related uri resource is still in use."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nallow adding protected = True to a view_config", "response": "def protected_view(view, info):\n    \"\"\"allows adding `protected=True` to a view_config`\"\"\"\n\n    if info.options.get('protected'):\n        def wrapper_view(context, request):\n            response = _advice(request)\n            if response is not None:\n                return response\n            else:\n                return view(context, request)\n        return wrapper_view\n    return view"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef syncdb(pool=None):\n    from flask_philo_sqlalchemy.schema import Base  # noqa\n    from flask_philo_sqlalchemy.orm import BaseModel  # noqa\n    from flask_philo_sqlalchemy.connection import create_pool\n\n    if pool is None:\n        pool = create_pool()\n\n    for conn_name, conn in pool.connections.items():\n        Base.metadata.create_all(conn.engine)", "response": "Create tables if they don t exist"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef checkInstalledPip(package, speak=True, speakSimilar=True):\n    packages = sorted([i.key for i in pip.get_installed_distributions()])\n    installed = package in packages\n    similar = None\n\n    if not installed:\n        similar = [pkg for pkg in packages if package in pkg]\n\n    if speak:\n        speakInstalledPackages(package, \"pip\", installed, similar, speakSimilar)\n\n    return (installed, similar)", "response": "checks if a given package is installed on pip"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if a given package is installed on homebrew", "response": "def checkInstalledBrew(package, similar=True, speak=True, speakSimilar=True):\n    \"\"\"checks if a given package is installed on homebrew\"\"\"\n    packages = subprocess.check_output(['brew', 'list']).split()\n    installed = package in packages\n    similar = []\n\n    if not installed:\n        similar = [pkg for pkg in packages if package in pkg]\n    if speak:\n        speakInstalledPackages(package, \"homebrew\", installed, similar, speakSimilar)\n\n    return (installed, similar)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the SQL module with the given credences.", "response": "def init_module(remote_credences=None,local_path=None):\n    \"\"\"Connnexion informations : remote_credences for remote acces OR local_path for local access\"\"\"\n    if remote_credences is not None:\n        RemoteConnexion.HOST = remote_credences[\"DB\"][\"host\"]\n        RemoteConnexion.USER = remote_credences[\"DB\"][\"user\"]\n        RemoteConnexion.PASSWORD = remote_credences[\"DB\"][\"password\"]\n        RemoteConnexion.NAME = remote_credences[\"DB\"][\"name\"]\n        MonoExecutant.ConnectionClass = RemoteConnexion\n        Executant.ConnectionClass = RemoteConnexion\n        abstractRequetesSQL.setup_marks(\"psycopg2\")\n    elif local_path is not None:\n        LocalConnexion.PATH = local_path\n        MonoExecutant.ConnectionClass = LocalConnexion\n        Executant.ConnectionClass = LocalConnexion\n        abstractRequetesSQL.setup_marks(\"sqlite3\")\n    else:\n        raise ValueError(\"Sql module should be init with one of remote or local mode !\")\n    logging.info(f\"Sql module initialized with {MonoExecutant.ConnectionClass.__name__}\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate emmpt DB according to the given scheme.", "response": "def cree_local_DB(scheme):\n    \"\"\"Create emmpt DB according to the given scheme : dict { table : [ (column_name, column_type), .. ]}\n    Usefull at installation of application (and for developement)\n    \"\"\"\n    conn = LocalConnexion()\n    req = \"\"\n    for table, fields in scheme.items():\n        req += f\"DROP TABLE IF EXISTS {table};\"\n        req_fields = \", \".join(f'{c_name} {c_type}' for c_name, c_type in fields)\n        req += f\"\"\"CREATE TABLE {table} (  {req_fields} ) ;\"\"\"\n    cur = conn.cursor()\n    cur.executescript(req)\n    conn.connexion.commit()\n    conn.connexion.close()\n    logging.info(\"Database created with succes.\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute(self, requete_SQL):\n        try:\n            cursor = self.cursor()\n            if isinstance(requete_SQL,tuple):\n                res = self._execute_one(cursor,*requete_SQL)\n            else:\n                res = []\n                for r in requete_SQL:\n                    if r:\n                        res.append(self._execute_one(cursor,*r))\n\n        except self.SQL.Error as e:\n            raise StructureError(f\"SQL error ! Details : \\n {e}\")\n        else:\n            self.connexion.commit()\n        finally:\n            self.connexion.close()\n        return res", "response": "Execute one or many requests\n            requete_SQL may be a tuple or a list of such tuples Return the result or a list of results\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef jsonise(dic):\n        d = {}\n        for k, v in dic.items():\n            if type(v) in abstractRequetesSQL.TYPES_PERMIS:\n                d[k] = v\n            else:\n                try:\n                    d[k] = json.dumps(v, ensure_ascii=False, cls=formats.JsonEncoder)\n                except ValueError as e:\n                    logging.exception(\"Erreur d'encodage JSON !\")\n                    raise e\n        return d", "response": "Renvoie un dictionnaire dont les champs dont compatibles avec SQL\n        Utilise Json. Attention \u00e0 None et non - null et non - null"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef insert(table, datas, avoid_conflict=False):\n        if avoid_conflict:\n            debut = \"\"\"INSERT INTO {table} {ENTETE_INSERT} VALUES {BIND_INSERT} ON CONFLICT DO NOTHING\"\"\"\n        else:\n            debut = \"\"\"INSERT INTO {table} {ENTETE_INSERT} VALUES {BIND_INSERT} RETURNING *\"\"\"\n        l = [abstractRequetesSQL.formate(debut, table=table, INSERT=d, args=d) for d in datas if d]\n        return Executant(l)", "response": "Insert row from datas."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(cls,table, dic, Id):\n        if dic:\n            req = \"UPDATE {table} SET {SET} WHERE id = \" + cls.named_style.format('__id') +  \" RETURNING * \"\n            r = abstractRequetesSQL.formate(req, SET=dic, table=table, args=dict(dic, __id=Id))\n            return MonoExecutant(r)\n        return MonoExecutant((f\"SELECT * FROM {table} WHERE id = \" + cls.named_style.format('__id'),\n                              {\"__id\": Id}))", "response": "Update row with Id from table. Set fields given by dic."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cree(table, dic, avoid_conflict=False):\n        if avoid_conflict:\n            req = \"\"\" INSERT INTO {table} {ENTETE_INSERT} VALUES {BIND_INSERT} ON CONFLICT DO NOTHING RETURNING *\"\"\"\n        else:\n            req = \"\"\" INSERT INTO {table} {ENTETE_INSERT} VALUES {BIND_INSERT} RETURNING *\"\"\"\n        r = abstractRequetesSQL.formate(req, table=table, INSERT=dic, args=dic)\n        return MonoExecutant(r)", "response": "Create ONE row from dic and returns the entry created"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef supprime(cls,table, **kwargs):\n        assert len(kwargs) == 1\n        field, value = kwargs.popitem()\n        req = f\"\"\"DELETE FROM {table} WHERE {field} = \"\"\" + cls.mark_style\n        args = (value,)\n        return MonoExecutant((req, args))", "response": "Remove entries matchin given condition\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nenumerate the children of the given object as would be visible and utilized by dispatch.", "response": "def trace(self, context, obj):\n\t\t\"\"\"Enumerate the children of the given object, as would be visible and utilized by dispatch.\"\"\"\n\t\t\n\t\troot = obj\n\t\t\n\t\tif isroutine(obj):\n\t\t\tyield Crumb(self, root, endpoint=True, handler=obj, options=opts(obj))\n\t\t\treturn\n\t\t\n\t\tfor name, attr in getmembers(obj if isclass(obj) else obj.__class__):\n\t\t\tif name == '__getattr__':\n\t\t\t\tsig = signature(attr)\n\t\t\t\tpath = '{' + list(sig.parameters.keys())[1] + '}'\n\t\t\t\treta = sig.return_annotation\n\t\t\t\t\n\t\t\t\tif reta is not sig.empty:\n\t\t\t\t\tif callable(reta) and not isclass(reta):\n\t\t\t\t\t\tyield Crumb(self, root, path, endpoint=True, handler=reta, options=opts(reta))\n\t\t\t\t\telse:\n\t\t\t\t\t\tyield Crumb(self, root, path, handler=reta)\n\t\t\t\t\n\t\t\t\telse:\n\t\t\t\t\tyield Crumb(self, root, path, handler=attr)\n\t\t\t\t\n\t\t\t\tdel sig, path, reta\n\t\t\t\tcontinue\n\t\t\t\n\t\t\telif name == '__call__':\n\t\t\t\tyield Crumb(self, root, None, endpoint=True, handler=obj)\n\t\t\t\tcontinue\n\t\t\t\n\t\t\tif self.protect and name[0] == '_':\n\t\t\t\tcontinue\n\t\t\t\n\t\t\tyield Crumb(self, root, name,\n\t\t\t\t\tendpoint=callable(attr) and not isclass(attr), handler=attr, options=opts(attr))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef main(argv=None):\n    '''\n    Main entry-point for calling layouts directly as a program.\n    '''\n    # Prep argparse\n    ap = argparse.ArgumentParser(\n        description='Basic query options for Python HID-IO Layouts repository',\n    )\n    ap.add_argument('--list', action='store_true', help='List available layout aliases.')\n    ap.add_argument('--get', metavar='NAME', help='Retrieve the given layout, and return the JSON data')\n\n    # Parse arguments\n    args = ap.parse_args(argv)\n\n    # Create layouts context manager\n    mgr = Layouts()\n\n    # Check if generating a list\n    if args.list:\n        for name in mgr.list_layouts():\n            print(name)\n\n    # Retrieve JSON layout\n    if args.get is not None:\n        layout = mgr.get_layout(args.get)\n        print(json.dumps(layout.json()))", "response": "Main entry - point for calling layouts directly as a program."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves a cache of the layouts git repo from GitHub and store it in cache_dir.", "response": "def retrieve_github_cache(self, github_path, version, cache_dir, token):\n        '''\n        Retrieves a cache of the layouts git repo from GitHub\n\n        @param github_path: Location of the git repo on GitHub (e.g. hid-io/layouts)\n        @param version: git reference for the version to download (e.g. master)\n        @param cache_dir: Directory to operate on external cache from\n        @param token: GitHub access token\n        '''\n        # Check for environment variable Github token\n        token = os.environ.get('GITHUB_APIKEY', None)\n\n        # Retrieve repo information\n        try:\n            gh = Github(token)\n            repo = gh.get_repo(github_path)\n            commit = repo.get_commit(version)\n            commits = repo.get_commits()\n            total_commits = 0\n            commit_number = 0\n            for cmt in commits:\n                if commit == cmt:\n                    commit_number = total_commits\n                total_commits += 1\n            commit_number = total_commits - commit_number\n            tar_url = repo.get_archive_link('tarball', commit.sha)\n        except GithubException.RateLimitExceededException:\n            if token is None:\n                log.warning(\"GITHUB_APIKEY is not set!\")\n            raise\n\n        # GitHub only uses the first 7 characters of the sha in the download\n        dirname_orig = \"{}-{}\".format(github_path.replace('/', '-'), commit.sha[:7])\n        dirname_orig_path = os.path.join(cache_dir, dirname_orig)\n        # Adding a commit number so it's clear which is the latest version without requiring git\n        dirname = \"{}-{}\".format(commit_number, dirname_orig)\n        dirname_path = os.path.join(cache_dir, dirname)\n\n        # If directory doesn't exist, check if tarball does\n        if not os.path.isdir(dirname_path):\n            filename = \"{}.tar.gz\".format(dirname)\n            filepath = os.path.join(cache_dir, filename)\n\n            # If tarball doesn't exist, download it\n            if not os.path.isfile(filepath):\n                # Retrieve tar file\n                chunk_size = 2000\n                req = requests.get(tar_url, stream=True)\n                with open(filepath, 'wb') as infile:\n                    for chunk in req.iter_content(chunk_size):\n                        infile.write(chunk)\n\n            # Extract tarfile\n            tar = tarfile.open(filepath)\n            tar.extractall(cache_dir)\n            os.rename(dirname_orig_path, dirname_path)\n            tar.close()\n\n            # Remove tar.gz\n            os.remove(filepath)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_layout(self, name):\n        '''\n        Returns the layout with the given name\n        '''\n        layout_chain = []\n\n        # Retrieve initial layout file\n        try:\n            json_data = self.json_files[self.layout_names[name]]\n        except KeyError:\n            log.error('Could not find layout: %s', name)\n            log.error('Layouts path: %s', self.layout_path)\n            raise\n        layout_chain.append(Layout(name, json_data))\n\n        # Recursively locate parent layout files\n        parent = layout_chain[-1].parent()\n        while parent is not None:\n            # Find the parent\n            parent_path = None\n            for path in self.json_file_paths:\n                if os.path.normcase(os.path.normpath(parent)) in os.path.normcase(path):\n                    parent_path = path\n\n            # Make sure a path was found\n            if parent_path is None:\n                raise UnknownLayoutPathException('Could not find: {}'.format(parent_path))\n\n            # Build layout for parent\n            json_data = self.json_files[parent_path]\n            layout_chain.append(Layout(parent_path, json_data))\n\n            # Check parent of parent\n            parent = layout_chain[-1].parent()\n\n        # Squash layout files\n        layout = self.squash_layouts(layout_chain)\n        return layout", "response": "Returns the layout with the given name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef squash_layouts(self, layouts):\n        '''\n        Returns a squashed layout\n\n        The first element takes precedence (i.e. left to right).\n        Dictionaries are recursively merged, overwrites only occur on non-dictionary entries.\n\n        [0,1]\n\n        0:\n        test: 'my data'\n\n        1:\n        test: 'stuff'\n\n        Result:\n        test: 'my data'\n\n        @param layouts: List of layouts to merge together\n        @return: New layout with list of layouts squash merged\n        '''\n        top_layout = layouts[0]\n        json_data = {}\n\n        # Generate a new container Layout\n        layout = Layout(top_layout.name(), json_data, layouts)\n\n        # Merge in each of the layouts\n        for mlayout in reversed(layouts):\n            # Overwrite all fields, *except* dictionaries\n            # For dictionaries, keep recursing until non-dictionaries are found\n            self.dict_merge(layout.json(), mlayout.json())\n\n        return layout", "response": "Squash a list of layouts into one Layout with the same data."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a JSON dictionary of the specified key and value.", "response": "def dict(self, name, key_caps=False, value_caps=False):\n        '''\n        Returns a JSON dict\n\n        @key_caps: Converts all dictionary keys to uppercase\n        @value_caps: Converts all dictionary values to uppercase\n\n        @return: JSON item (may be a variable, list or dictionary)\n        '''\n        # Invalid Dictionary\n        if not isinstance(self.json_data[name], dict):\n            raise InvalidDictionaryException\n\n        # Convert key and/or values of dictionary to uppercase\n        output = {}\n        for key, value in self.json_data[name].items():\n            output[key.upper() if key_caps else key] = value.upper() if value_caps else value\n\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef locale(self):\n        '''\n        Do a lookup for the locale code that is set for this layout.\n\n        NOTE: USB HID specifies only 35 different locales. If your layout does not fit, it should be set to Undefined/0\n\n        @return: Tuple (<USB HID locale code>, <name>)\n        '''\n        name = self.json_data['hid_locale']\n\n        # Set to Undefined/0 if not set\n        if name is None:\n            name = \"Undefined\"\n\n        return (int(self.json_data['from_hid_locale'][name]), name)", "response": "Do a lookup for the locale code that is set for this layout."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a sequence of combinations needed to compose given text.", "response": "def compose(self, text, minimal_clears=False, no_clears=False):\n        '''\n        Returns the sequence of combinations necessary to compose given text.\n\n        If the text expression is not possible with the given layout an ComposeException is thrown.\n\n        Iterate over the string, converting each character into a key sequence.\n        Between each character, an empty combo is inserted to handle duplicate strings (and USB HID codes between characters)\n\n        @param text: Input UTF-8 string\n        @param minimal_clears: Set to True to minimize the number of code clears. False (default) includes a clear after every character.\n        @param no_clears: Set to True to not add any code clears (useful for input sequences). False (default) to include code clears.\n\n        @returns: Sequence of combinations needed to generate the given text string\n        '''\n        sequence = []\n        clear = self.json_data['to_hid_keyboard']['0x00'] # No Event\n\n        for char in text:\n            # Make sure the composition element is available\n            if char not in self.json_data['composition']:\n                raise ComposeException(\"'{}' is not defined as a composition in the layout '{}'\".format(char, self.name))\n\n            # Lookup the sequence to handle this character\n            lookup = self.json_data['composition'][char]\n\n            # If using minimal clears, check to see if we need to re-use any codes\n            # Only need to check the most recent addition with the first combo\n            if sequence and set(tuple(lookup[0])) & set(tuple(sequence[-1])) and not no_clears:\n                sequence.extend([[clear]])\n\n            # Add to overall sequence\n            sequence.extend(lookup)\n\n            # Add empty combo for sequence splitting\n            if not minimal_clears and not no_clears:\n                # Blindly add a clear combo between characters\n                sequence.extend([[clear]])\n\n        # When using minimal clears, we still need to add a final clear\n        if minimal_clears and not no_clears:\n            sequence.extend([[clear]])\n\n        return sequence"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main(self):\n        logging.info('Starting {at} analysis pipeline'.format(at=self.analysistype))\n        # Create the objects to be used in the analyses\n        objects = Objectprep(self)\n        objects.objectprep()\n        self.runmetadata = objects.samples\n        self.threads = int(self.cpus / len(self.runmetadata.samples)) if self.cpus / len(self.runmetadata.samples) > 1 \\\n            else 1\n        if self.genesippr:\n            # Run the genesippr analyses\n            self.analysistype = 'genesippr'\n            self.targetpath = os.path.join(self.reffilepath, self.analysistype)\n            Sippr(inputobject=self,\n                  cutoff=0.90,\n                  averagedepth=5)\n            # Create the reports\n            self.reports = Reports(self)\n            Reports.reporter(self.reports)\n        if self.sixteens:\n            # Run the 16S analyses\n            SixteensFull(args=self,\n                         pipelinecommit=self.commit,\n                         startingtime=self.starttime,\n                         scriptpath=self.homepath,\n                         analysistype='sixteens_full',\n                         cutoff=0.985)\n        if self.closestreference:\n            self.pipeline = True\n            mash.Mash(inputobject=self,\n                      analysistype='mash')\n        if self.rmlst:\n            rmlst = MLSTSippr(args=self,\n                              pipelinecommit=self.commit,\n                              startingtime=self.starttime,\n                              scriptpath=self.homepath,\n                              analysistype='rMLST',\n                              cutoff=1.0,\n                              pipeline=True)\n            rmlst.runner()\n        if self.resistance:\n            # ResFinding\n            res = Resistance(args=self,\n                             pipelinecommit=self.commit,\n                             startingtime=self.starttime,\n                             scriptpath=self.homepath,\n                             analysistype='resfinder',\n                             cutoff=0.7,\n                             pipeline=False,\n                             revbait=True)\n            res.main()\n        if self.virulence:\n            self.genus_specific()\n            Virulence(args=self,\n                      pipelinecommit=self.commit,\n                      startingtime=self.starttime,\n                      scriptpath=self.homepath,\n                      analysistype='virulence',\n                      cutoff=0.95,\n                      pipeline=False,\n                      revbait=True)\n        if self.gdcs:\n            self.genus_specific()\n            # Run the GDCS analysis\n            self.analysistype = 'GDCS'\n            self.targetpath = os.path.join(self.reffilepath, self.analysistype)\n            Sippr(inputobject=self,\n                  cutoff=0.95,\n                  k=self.gdcs_kmer_size)\n            # Create the reports\n            self.reports = Reports(self)\n            Reports.gdcsreporter(self.reports)\n        if self.mlst:\n            self.genus_specific()\n            mlst = MLSTSippr(args=self,\n                             pipelinecommit=self.commit,\n                             startingtime=self.starttime,\n                             scriptpath=self.homepath,\n                             analysistype='MLST',\n                             cutoff=1.0,\n                             pipeline=True)\n            mlst.runner()\n        # Serotyping\n        if self.serotype:\n            self.genus_specific()\n            SeroSippr(args=self,\n                      pipelinecommit=self.commit,\n                      startingtime=self.starttime,\n                      scriptpath=self.homepath,\n                      analysistype='serosippr',\n                      cutoff=0.90,\n                      pipeline=True)\n        # Point mutation detection\n        if self.pointfinder:\n            self.genus_specific()\n            PointSippr(args=self,\n                       pipelinecommit=self.commit,\n                       startingtime=self.starttime,\n                       scriptpath=self.homepath,\n                       analysistype='pointfinder',\n                       cutoff=0.85,\n                       pipeline=True,\n                       revbait=True)\n        if self.user_genes:\n            custom = CustomGenes(args=self,\n                                 kmer_size=self.kmer_size,\n                                 allow_soft_clips=self.allow_soft_clips)\n            custom.main()\n        # Print the metadata\n        MetadataPrinter(self)", "response": "Run the analyses in the correct order."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines if the closest refseq genus is known - i. e. if the MASH analyses are performed and if required is True then perform the analyses if required is False then perform the analyses if required is True.", "response": "def genus_specific(self):\n        \"\"\"\n        For genus-specific targets, MLST and serotyping, determine if the closest refseq genus is known - i.e. if 16S\n        analyses have been performed. Perform the analyses if required\n        \"\"\"\n        # Initialise a variable to store whether the necessary analyses have already been performed\n        closestrefseqgenus = False\n        for sample in self.runmetadata.samples:\n            if sample.general.bestassemblyfile != 'NA':\n                try:\n                    closestrefseqgenus = sample.general.closestrefseqgenus\n                except AttributeError:\n                    pass\n        # Perform the 16S analyses as required\n        if not closestrefseqgenus:\n            logging.info('Must perform MASH analyses to determine genera of samples')\n            self.pipeline = True\n            # Run the analyses\n            mash.Mash(self, 'mash')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntell iTunes to pause", "response": "def pause():\n\t\"\"\"Tell iTunes to pause\"\"\"\n\n\tif not settings.platformCompatible():\n\t\treturn False\n\n\t(output, error) = subprocess.Popen([\"osascript\", \"-e\", PAUSE], stdout=subprocess.PIPE).communicate()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resume():\n\n\tif not settings.platformCompatible():\n\t\treturn False\n\n\t(output, error) = subprocess.Popen([\"osascript\", \"-e\", RESUME], stdout=subprocess.PIPE).communicate()", "response": "Tell iTunes to resume"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntell iTunes to skip a song", "response": "def skip():\n\t\"\"\"Tell iTunes to skip a song\"\"\"\n\n\tif not settings.platformCompatible():\n\t\treturn False\n\n\t(output, error) = subprocess.Popen([\"osascript\", \"-e\", SKIP], stdout=subprocess.PIPE).communicate()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntells iTunes to play a given song artist or album.", "response": "def play(song, artist=None, album=None):\n\t\"\"\"Tells iTunes to play a given song/artist/album - MACOSX ONLY\"\"\"\n\n\tif not settings.platformCompatible():\n\t\treturn False\n\n\tif song and not artist and not album:\n\t\t(output, error) = subprocess.Popen([\"osascript\", \"-e\", DEFAULT_ITUNES_PLAY % (song, song, song)], stdout=subprocess.PIPE).communicate()\n\t\tif output:\n\t\t\tspeech.speak(\"Playing \" + output)\n\t\telse:\n\t\t\tspeech.speak(\"Unable to find \" + song + \" in your library.\")\n\n\telif song and artist and not album:\n\t\t(output, error) = subprocess.Popen([\"osascript\", \"-e\", ITUNES_SONG_AND_ARTIST % (song, artist, song, artist)], stdout=subprocess.PIPE).communicate()\n\t\tif output:\n\t\t\tspeech.speak(\"Playing \" + output)\n\t\telse:\n\t\t\tspeech.speak(\"Unable to find \" + song + \" in your library.\")\n\n\telif album and artist and not song:\n\t\t(output, error) = subprocess.Popen([\"osascript\", \"-e\", ITUNES_ALBUM_AND_ARTIST % (artist, album)], stdout=subprocess.PIPE).communicate()\n\t\tif output:\n\t\t\tspeech.speak(\"Playing \" + output)\n\t\telse:\n\t\t\tspeech.speak(\"Unable to find \" + song + \" in your library.\")\n\n\telif album and not artist and not song:\n\t\t(output, error) = subprocess.Popen([\"osascript\", \"-e\", ITUNES_ALBUM % (album)], stdout=subprocess.PIPE).communicate()\n\t\tif output:\n\t\t\tspeech.speak(\"Playing \" + output)\n\t\telse:\n\t\t\tspeech.speak(\"Unable to find \" + song + \" in your library.\")\n\n\telif artist and not album and not song:\n\t\t(output, error) = subprocess.Popen([\"osascript\", \"-e\", ITUNES_ARTIST % (artist)], stdout=subprocess.PIPE).communicate()\n\t\tif output:\n\t\t\tspeech.speak(\"Playing \" + output)\n\t\telse:\n\t\t\tspeech.speak(\"Unable to find \" + song + \" in your library.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef service_provider(*services):\n\n    def real_decorator(clazz):\n        instance = clazz()\n        for service in services:\n            global_lookup.add(service, instance)\n        return clazz\n\n    return real_decorator", "response": "This is a class decorator that declares a class to provide a set of services."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsyllabifying the given word whether simplex or complex.", "response": "def syllabify(word):\n    '''Syllabify the given word, whether simplex or complex.'''\n    compound = bool(re.search(r'(-| |=)', word))\n    syllabify = _syllabify_compound if compound else _syllabify_simplex\n    syllabifications = list(syllabify(word))\n\n    for word, rules in rank(syllabifications):\n        # post-process\n        word = str(replace_umlauts(word, put_back=True))\n        rules = rules[1:]\n\n        yield word, rules"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef apply_T6(word):\n    '''If a VVV-sequence contains a long vowel, there is a syllable boundary\n    between it and the third vowel, e.g. [kor.ke.aa], [yh.ti.\u00f6\u00f6n], [ruu.an],\n    [m\u00e4\u00e4.yt.te].'''\n    WORD = word\n    offset = 0\n\n    for vvv in vvv_sequences(WORD):\n        seq = vvv.group(2)\n        j = 2 if is_long(seq[:2]) else 1 if is_long(seq[1:]) else 0\n\n        if j:\n            i = vvv.start(2) + j + offset\n            WORD = WORD[:i] + '.' + WORD[i:]\n            offset += 1\n\n    RULE = ' T6' if word != WORD else ''\n\n    return WORD, RULE", "response": "This function applies T6 to a word."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef apply_T7(word):\n    '''If a VVV-sequence does not contain a potential /i/-final diphthong,\n    there is a syllable boundary between the second and third vowels, e.g.\n    [kau.an], [leu.an], [kiu.as].'''\n    WORD = word\n    offset = 0\n\n    for vvv in vvv_sequences(WORD):\n        i = vvv.start(2) + 2 + offset\n        WORD = WORD[:i] + '.' + WORD[i:]\n        offset += 1\n\n    RULE = ' T7' if word != WORD else ''\n\n    return WORD, RULE", "response": "A function to apply T7 to a VVV - sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsplits the syllables that do not take primary stress.", "response": "def apply_T8(word):\n    '''Split /ie/, /uo/, or /y\u00f6/ sequences in syllables that do not take\n    primary stress.'''\n    WORD = word\n    offset = 0\n\n    for vv in tail_diphthongs(WORD):\n        i = vv.start(1) + 1 + offset\n        WORD = WORD[:i] + '.' + WORD[i:]\n        offset += 1\n\n    RULE = ' T8' if word != WORD else ''\n\n    return WORD, RULE"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wsp(word):\n    '''Return the number of unstressed heavy syllables.'''\n    HEAVY = r'[ieaAoO]{1}[\\.]*(u|y)[^ieaAoO]+(\\.|$)'\n\n    # # if the word is not monosyllabic, lop off the final syllable, which is\n    # # extrametrical\n    # if '.' in word:\n    #     word = word[:word.rindex('.')]\n\n    # gather the indices of syllable boundaries\n    delimiters = [i for i, char in enumerate(word) if char == '.']\n\n    if len(delimiters) % 2 != 0:\n        delimiters.append(len(word))\n\n    unstressed = []\n\n    # gather the indices of unstressed positions\n    for i, d in enumerate(delimiters):\n        if i % 2 == 0:\n            unstressed.extend(range(d + 1, delimiters[i + 1]))\n\n    # find the number of unstressed heavy syllables\n    heavies = re.finditer(HEAVY, word)\n    violations = sum(1 for m in heavies if m.start(0) in unstressed)\n\n    return violations", "response": "Return the number of unstressed heavy syllables."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pk_prom(word):\n    '''Return the number of stressed light syllables.'''\n    LIGHT = r'[ieaAoO]{1}[\\.]*(u|y)(\\.|$)'\n\n    # # if the word is not monosyllabic, lop off the final syllable, which is\n    # # extrametrical\n    # if '.' in word:\n    #     word = word[:word.rindex('.')]\n\n    # gather the indices of syllable boundaries\n    delimiters = [0, ] + [i for i, char in enumerate(word) if char == '.']\n\n    if len(delimiters) % 2 != 0:\n        delimiters.append(len(word))\n\n    stressed = []\n\n    # gather the indices of stressed positions\n    for i, d in enumerate(delimiters):\n        if i % 2 == 0:\n            stressed.extend(range(d + 1, delimiters[i + 1]))\n\n    # find the number of stressed light syllables\n    heavies = re.finditer(LIGHT, word)\n    violations = sum(1 for m in heavies if m.start(1) in stressed)\n\n    return violations", "response": "Return the number of stressed light syllables."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ext(self, extension):\n        new_pathq = copy(self)\n        new_pathq._pattern.ext = extension\n        return new_pathq", "response": "Match files with an extension - e. g. js txt"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef apply_T8(word):\n    '''Split /ie/ sequences in syllables that do not take primary stress.'''\n    WORD = word\n    offset = 0\n\n    for ie in ie_sequences(WORD):\n        i = ie.start(1) + 1 + offset\n        WORD = WORD[:i] + '.' + WORD[i:]\n        offset += 1\n\n    RULE = ' T8' if word != WORD else ''\n\n    return WORD, RULE", "response": "Split / ie sequences in syllables that do not take primary stress."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef apply_T9(word):\n    '''Split /iu/ sequences that do not appear in the first, second, or final\n    syllables.'''\n    WORD = word\n    index = 0\n    offset = 0\n\n    for iu in iu_sequences(WORD):\n        if iu.start(1) != index:\n            i = iu.start(1) + 1 + offset\n            WORD = WORD[:i] + '.' + WORD[i:]\n            index = iu.start(1)\n            offset += 1\n\n    RULE = ' T9' if word != WORD else ''\n\n    return WORD, RULE", "response": "Split / iu sequences that do not appear in the first second or final\n    syllables."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a class from a string including module and class.", "response": "def import_class(import_str):\n    \"\"\"Returns a class from a string including module and class.\"\"\"\n    mod_str, _sep, class_str = import_str.rpartition('.')\n    try:\n        __import__(mod_str)\n        return getattr(sys.modules[mod_str], class_str)\n    except (ValueError, AttributeError):\n        raise ImportError('Class %s cannot be found (%s)' %\n                          (class_str,\n                           traceback.format_exception(*sys.exc_info())))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntry to import an object from the default namespace and returns an instance of it", "response": "def import_object_ns(name_space, import_str, *args, **kwargs):\n    \"\"\"Tries to import object from default namespace.\n\n    Imports a class and return an instance of it, first by trying\n    to find the class in a default namespace, then failing back to\n    a full path if not found in the default namespace.\n    \"\"\"\n    import_value = \"%s.%s\" % (name_space, import_str)\n    try:\n        return import_class(import_value)(*args, **kwargs)\n    except ImportError:\n        return import_class(import_str)(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef install_virtualbox(distribution, force_setup=False):\n\n    if 'ubuntu' in distribution:\n        with hide('running', 'stdout'):\n            sudo('DEBIAN_FRONTEND=noninteractive apt-get update')\n            sudo(\"sudo DEBIAN_FRONTEND=noninteractive apt-get -y -o \"\n                    \"Dpkg::Options::='--force-confdef' \"\n                    \"-o Dpkg::Options::='--force-confold' upgrade --force-yes\")\n            install_ubuntu_development_tools()\n            apt_install(packages=['dkms',\n                                  'linux-headers-generic',\n                                  'build-essential'])\n            sudo('wget -q '\n                 'https://www.virtualbox.org/download/oracle_vbox.asc -O- |'\n                 'sudo apt-key add -')\n\n            os = lsb_release()\n            apt_string = ' '.join(\n                ['deb',\n                 'http://download.virtualbox.org/virtualbox/debian',\n                 '%s contrib' % os['DISTRIB_CODENAME']])\n\n            apt_add_repository_from_apt_string(apt_string, 'vbox.list')\n\n            apt_install(packages=['virtualbox-5.0'])\n\n            loaded_modules = sudo('lsmod')\n\n            if 'vboxdrv' not in loaded_modules or force_setup:\n\n                if 'Vivid Vervet' in run('cat /etc/os-release'):\n                    sudo('systemctl start vboxdrv')\n                else:\n                    sudo('/etc/init.d/vboxdrv start')\n\n            sudo('wget -c '\n                 'http://download.virtualbox.org/virtualbox/5.0.4/'\n                 'Oracle_VM_VirtualBox_Extension_Pack-5.0.4-102546.vbox-extpack') # noqa\n\n            sudo('VBoxManage extpack install --replace '\n                 'Oracle_VM_VirtualBox_Extension_Pack-5.0.4-102546.vbox-extpack')", "response": "installs the virtualbox if the distribution is ubuntu"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef runner(self):\n        printtime('Starting mashsippr analysis pipeline', self.starttime)\n        if not self.pipeline:\n            # Create the objects to be used in the analyses\n            objects = Objectprep(self)\n            objects.objectprep()\n            self.runmetadata = objects.samples\n        # Run the analyses\n        Mash(self, self.analysistype)", "response": "Run the necessary methods in the correct order for the mashsippr analysis pipeline"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cree_widgets(self):\n        for t in self.FIELDS:\n            if type(t) is str:\n                attr, kwargs = t, {}\n            else:\n                attr, kwargs = t[0], t[1].copy()\n            self.champs.append(attr)\n            is_editable = kwargs.pop(\"is_editable\", self.is_editable)\n            args = [self.acces[attr], is_editable]\n            with_base = kwargs.pop(\"with_base\", False)\n            if with_base:\n                args.append(self.acces.base)\n\n            if 'with_label' in kwargs:\n                label = kwargs.pop('with_label')\n            else:\n                label = ASSOCIATION[attr][0]\n            if kwargs:\n                w = ASSOCIATION[attr][3](*args, **kwargs)\n            else:\n                w = ASSOCIATION[attr][3](*args)\n\n            self.widgets[attr] = (w, label)", "response": "Create widgets and store them in self. widgets"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef preservesurrogates(s):\n    if not isinstance(s, six.text_type):\n        raise TypeError(u\"String to split must be of type 'unicode'!\")\n    surrogates_regex_str = u\"[{0}-{1}][{2}-{3}]\".format(HIGH_SURROGATE_START,\n                                                        HIGH_SURROGATE_END,\n                                                        LOW_SURROGATE_START,\n                                                        LOW_SURROGATE_END)\n    surrogates_regex = re.compile(u\"(?:{0})|.\".format(surrogates_regex_str))\n    return surrogates_regex.findall(s)", "response": "Function for splitting a string into a list of characters preserving surrogates."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _unichr(i):\n    if not isinstance(i, int):\n        raise TypeError\n    try:\n        return six.unichr(i)\n    except ValueError:\n        # Workaround the error \"ValueError: unichr() arg not in range(0x10000) (narrow Python build)\"\n        return struct.pack(\"i\", i).decode(\"utf-32\")", "response": "Helper function for taking a Unicode scalar value and returning a Unicode character."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _uax44lm2transform(s):\n    result = s\n\n    # For the regex, we are using lookaround assertions to verify that there is a word character immediately before (the\n    # lookbehind assertion (?<=\\w)) and immediately after (the lookahead assertion (?=\\w)) the hyphen, per the \"medial\n    # hyphen\" definition that it is a hyphen occurring immediately between two letters.\n    medialhyphen = re.compile(r\"(?<=\\w)-(?=\\w)\")\n    whitespaceunderscore = re.compile(r\"[\\s_]\", re.UNICODE)\n\n    # Ok to hard code, this name should never change: https://www.unicode.org/policies/stability_policy.html#Name\n    if result != \"HANGUL JUNGSEONG O-E\":\n        result = medialhyphen.sub(\"\", result)\n    result = whitespaceunderscore.sub(\"\", result)\n    return result.lower()", "response": "This function transforms a string into a UAX44 - LM2 string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _to_unicode_scalar_value(s):\n    if len(s) == 1:\n        return ord(s)\n    elif len(s) == 2:\n        return (ord(s[0]) - 0xD800) * 0x0400 + (ord(s[1]) - 0xDC00) + 0x10000\n    else:\n        raise ValueError", "response": "Helper function to convert a Unicode scalar value from a string to a Unicode scalar value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_nr_prefix(i):\n    for lookup_range, prefix_string in _nr_prefix_strings.items():\n        if i in lookup_range:\n            return prefix_string\n    raise ValueError(\"No prefix string associated with {0}!\".format(i))", "response": "Helper function for looking up the derived name prefix associated with a Unicode scalar value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef casefold(s, fullcasefold=True, useturkicmapping=False):\n    if not isinstance(s, six.text_type):\n        raise TypeError(u\"String to casefold must be of type 'unicode'!\")\n    lookup_order = \"CF\"\n    if not fullcasefold:\n        lookup_order = \"CS\"\n    if useturkicmapping:\n        lookup_order = \"T\" + lookup_order\n    return u\"\".join([casefold_map.lookup(c, lookup_order=lookup_order) for c in preservesurrogates(s)])", "response": "This function will perform a case folding on the input string s."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _build_unicode_character_database(self):\n        filename = \"UnicodeData.txt\"\n        current_dir = os.path.abspath(os.path.dirname(__file__))\n        tag = re.compile(r\"<\\w+?>\")\n        with codecs.open(os.path.join(current_dir, filename), mode=\"r\", encoding=\"utf-8\") as fp:\n            for line in fp:\n                if not line.strip():\n                    continue\n                data = line.strip().split(\";\")\n                # Replace the start/end range markers with their proper derived names.\n                if data[1].endswith((u\"First>\", u\"Last>\")) and _is_derived(int(data[0], 16)):\n                    data[1] = _get_nr_prefix(int(data[0], 16))\n                    if data[1].startswith(\"HANGUL SYLLABLE\"):  # For Hangul syllables, use naming rule NR1\n                        data[1] += _get_hangul_syllable_name(int(data[0], 16))\n                    else:  # Others should use naming rule NR2\n                        data[1] += data[0]\n                data[3] = int(data[3])  # Convert the Canonical Combining Class value into an int.\n                if data[5]:  # Convert the contents of the decomposition into characters, preserving tag info.\n                    data[5] = u\" \".join([_hexstr_to_unichr(s) if not tag.match(s) else s for s in data[5].split()])\n                for i in [6, 7, 8]:  # Convert the decimal, digit and numeric fields to either ints or fractions.\n                    if data[i]:\n                        if \"/\" in data[i]:\n                            data[i] = Fraction(data[i])\n                        else:\n                            data[i] = int(data[i])\n                for i in [12, 13, 14]:  # Convert the uppercase, lowercase and titlecase fields to characters.\n                    if data[i]:\n                        data[i] = _hexstr_to_unichr(data[i])\n                lookup_name = _uax44lm2transform(data[1])\n                uc_data = UnicodeCharacter(u\"U+\" + data[0], *data[1:])\n                self._unicode_character_database[int(data[0], 16)] = uc_data\n                self._name_database[lookup_name] = uc_data\n        # Fill out the \"compressed\" ranges of UnicodeData.txt i.e. fill out the remaining characters per the Name\n        # Derivation Rules.  See the Unicode Standard, ch. 4, section 4.8, Unicode Name Property\n        for lookup_range, prefix_string in _nr_prefix_strings.items():\n            exemplar = self._unicode_character_database.__getitem__(lookup_range[0])\n            for item in lookup_range:\n                hex_code = _padded_hex(item)\n                new_name = prefix_string\n                if prefix_string.startswith(\"HANGUL SYLLABLE\"):  # For Hangul, use naming rule NR1\n                    new_name += _get_hangul_syllable_name(item)\n                else:  # Everything else uses naming rule NR2\n                    new_name += hex_code\n                uc_data = exemplar._replace(code=u\"U+\" + hex_code, name=new_name)\n                self._unicode_character_database[item] = uc_data\n                self._name_database[_uax44lm2transform(new_name)] = uc_data", "response": "Function for parsing the Unicode Character Database and generating a lookup table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfunctioning for retrieving the UnicodeCharacter associated with a name.", "response": "def lookup_by_name(self, name):\n        \"\"\"\n        Function for retrieving the UnicodeCharacter associated with a name.  The name lookup uses the loose matching\n        rule UAX44-LM2 for loose matching.  See the following for more info:\n\n        https://www.unicode.org/reports/tr44/#UAX44-LM2\n\n        For example:\n\n        ucd = UnicodeData()\n        ucd.lookup_by_name(\"LATIN SMALL LETTER SHARP S\") -> UnicodeCharacter(name='LATIN SMALL LETTER SHARP S',...)\n        ucd.lookup_by_name(\"latin_small_letter_sharp_s\") -> UnicodeCharacter(name='LATIN SMALL LETTER SHARP S',...)\n\n\n        :param name: Name of the character to look up.\n        :return: UnicodeCharacter instance with data associated with the character.\n        \"\"\"\n        try:\n            return self._name_database[_uax44lm2transform(name)]\n        except KeyError:\n            raise KeyError(u\"Unknown character name: '{0}'!\".format(name))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef lookup_by_partial_name(self, partial_name):\n        for k, v in self._name_database.items():\n            if _uax44lm2transform(partial_name) in k:\n                yield v", "response": "This method returns a generator that yields UnicodeCharacter instances for the given partial name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _load_unicode_block_info(self):\n        filename = \"Blocks.txt\"\n        current_dir = os.path.abspath(os.path.dirname(__file__))\n        with codecs.open(os.path.join(current_dir, filename), mode=\"r\", encoding=\"utf-8\") as fp:\n            for line in fp:\n                if not line.strip() or line.startswith(\"#\"):\n                    continue  # Skip empty lines or lines that are comments (comments start with '#')\n                # Format: Start Code..End Code; Block Name\n                block_range, block_name = line.strip().split(\";\")\n                start_range, end_range = block_range.strip().split(\"..\")\n                self._unicode_blocks[six.moves.range(int(start_range, 16), int(end_range, 16) + 1)] = block_name.strip()", "response": "Function for parsing Unicode character set info from the Unicode CharacterSet Database and generating a lookup table."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _build_casefold_map(self):\n        self._casefold_map = defaultdict(dict)\n        filename = \"CaseFolding.txt\"\n        current_dir = os.path.abspath(os.path.dirname(__file__))\n        with codecs.open(os.path.join(current_dir, filename), mode=\"r\", encoding=\"utf-8\") as fp:\n            for line in fp:\n                if not line.strip() or line.startswith(\"#\"):\n                    continue  # Skip empty lines or lines that are comments (comments start with '#')\n                code, status, mapping, name = line.split(\";\")\n                src = _hexstr_to_unichr(code)\n                target = u\"\".join([_hexstr_to_unichr(c) for c in mapping.strip().split()])\n                self._casefold_map[status.strip()][src] = target", "response": "Function for parsing the Unicode Character\n        database and generating a lookup table."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfunctions to lookup a character in the casefold map.", "response": "def lookup(self, c, lookup_order=\"CF\"):\n        \"\"\"\n        Function to lookup a character in the casefold map.\n\n        The casefold map has four sub-tables, the 'C' or common table, the 'F' or\n        full table, the 'S' or simple table and the 'T' or the Turkic special\n        case table.  These tables correspond to the statuses defined in the\n        CaseFolding.txt file.  We can specify the order of the tables to use for\n        performing the lookup by the lookup_order parameter.\n\n        Per the usage specified in the CaseFolding.txt file, we can use the 'C'\n        and 'S' tables for doing a simple case fold.  To perform a full case\n        fold, we can use the 'C' and 'F' tables.  The default behavior for this\n        function is a full case fold (lookup_order=\"CF\").\n\n        :param c: character to lookup\n        :param lookup_order:\n        \"\"\"\n        if not isinstance(c, six.text_type):\n            raise TypeError(u\"Character to lookup must be of type 'unicode'!\")\n        for d in lookup_order:\n            try:\n                return self._casefold_map[d][c]\n            except KeyError:\n                pass\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_from_json(data):\n        if isinstance(data, str):\n            data = json.loads(data)\n        applications = [\n            ApplicationResponse.load_from_json(a) for a in data['applications']\n        ] if data['applications'] is not None else []\n        return RegistryResponse(\n            data['query_uri'], data['success'],\n            data['has_references'], data['count'], applications\n        )", "response": "Load a RegistryResponse from a dictionary or a string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_from_json(data):\n        if isinstance(data, str):\n            data = json.loads(data)\n        items = [Item.load_from_json(a) for a in data['items']] if data['items'] is not None else []\n        return ApplicationResponse(\n            data['title'], data['uri'], data['service_url'],\n            data['success'], data['has_references'], data['count'], items\n        )", "response": "Load a : class : ApplicationResponse from a dictionary or string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads a : class : Item from a dictionary ot string", "response": "def load_from_json(data):\n        \"\"\"\n        Load a :class:`Item` from a dictionary ot string (that will be parsed\n        as json)\n        \"\"\"\n        if isinstance(data, str):\n            data = json.loads(data)\n        return Item(data['title'], data['uri'])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef apply_T11(word):\n    '''If a VVV sequence contains a /u, y/-final diphthong and the third vowel\n    is /i/, there is a syllable boundary between the diphthong and /i/.'''\n    WORD = word\n    offset = 0\n\n    for vvv in t11_vvv_sequences(WORD):\n        # i = vvv.start(1) + (1 if vvv.group(1).startswith('i') else 2) + offset\n        i = vvv.start(1) + (1 if vvv.group(1)[-1] in 'uy' else 2) + offset\n        WORD = WORD[:i] + '.' + WORD[i:]\n        offset += 1\n\n    RULE = ' T11' if word != WORD else ''\n\n    return WORD, RULE", "response": "Apply T11 to a word."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _syllabify_simplex(word):\n    '''Syllabify the given word.'''\n    word, rules = apply_T1(word)\n\n    if re.search(r'[^ieAyOauo]*([ieAyOauo]{2})[^ieAyOauo]*', word):\n        word, T2 = apply_T2(word)\n        word, T8 = apply_T8(word)\n        word, T9 = apply_T9(word)\n        rules += T2 + T8 + T9\n\n        # T4 produces variation\n        syllabifications = list(apply_T4(word))\n\n    else:\n        syllabifications = [(word, ''), ]\n\n    for word, rule in syllabifications:\n        RULES = rules + rule\n\n        if re.search(r'[ieAyOauo]{3}', word):\n            word, T6 = apply_T6(word)\n            word, T5 = apply_T5(word)\n            word, T10 = apply_T10(word)\n            word, T7 = apply_T7(word)\n            word, T2 = apply_T2(word)\n            RULES += T5 + T6 + T10 + T7 + T2\n\n        RULES = RULES or ' T0'  # T0 means no rules have applied\n\n        yield word, RULES", "response": "Syllabify the given word."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef T1(word):\n    '''Insert a syllable boundary in front of every CV sequence.'''\n    # split consonants and vowels: 'balloon' -> ['b', 'a', 'll', 'oo', 'n']\n    WORD = [i for i in re.split(r'([ieaou\u00e4\u00f6y]+)', word, flags=FLAGS) if i]\n\n    # keep track of which sub-rules are applying\n    sub_rules = set()\n\n    # a count divisible by 2 indicates an even syllable\n    count = 1\n\n    for i, v in enumerate(WORD):\n\n        # T1B\n        # If there is a consonant cluster word-initially, the entire cluster\n        # forms the onset of the first syllable:\n        # CCV > #CCV\n        if i == 0 and phon.is_consonant(v[0]):\n            sub_rules.add('b')\n\n        elif phon.is_consonant(v[0]):\n            count += 1\n\n            # True if the current syllable is unstressed, else False\n            unstressed = count % 2 == 0\n\n            # T1C\n            # If there is a consonant cluster word-finally, the entire cluster\n            # forms the coda of the final syllable:\n            # VCC# > VCC#\n            if i + 1 == len(WORD):\n                sub_rules.add('c')\n\n            # T1D\n            # If there is a bare \"Finnish\" consonant cluster word-medially and\n            # the previous syllable receives stress, the first consonant of the\n            # cluster forms the coda of the previous syllable (to create a\n            # heavy syllable); otherwise, the whole cluster forms the onset of\n            # the current syllable (this is the /kr/ rule):\n            # 'VCCV > 'VC.CV,  VCCV > V.CCV\n            elif phon.is_cluster(v):\n                sub_rules.add('d')\n                WORD[i] = v[0] + '.' + v[1:] if unstressed else '.' + v\n\n            elif phon.is_cluster(v[1:]):\n\n                # T1E (optional)\n                # If there is a word-medial \"Finnish\" consonant cluster that is\n                # preceded by a sonorant consonant, if the previous syllable\n                # receives stress, the sonorant consonant and the first\n                # consonant of the cluster form the coda of the previous\n                # syllable, and the remainder of the cluster forms the onset of\n                # the current syllable:\n                # 'VlCC > VlC.C\n                if phon.is_sonorant(v[0]) and unstressed:\n                    sub_rules.add('e')\n                    WORD[i] = v[:2] + '.' + v[2:]\n\n                # T1F\n                # If there is a word-medial \"Finnish\" cluster that follows a\n                # consonant, that first consonant forms the coda of the\n                # previous syllable, and the cluster forms the onset of the\n                # current syllable:\n                # VCkr > VC.kr\n                else:\n                    sub_rules.add('f')\n                    WORD[i] = v[0] + '.' + v[1:]\n\n            # T1A\n            # There is a syllable boundary in front of every CV sequence:\n            # VCV > V.CV, CCV > C.CV\n            else:\n                WORD[i] = v[:-1] + '.' + v[-1]\n                sub_rules.add('a')\n\n    WORD = ''.join(WORD)\n    rules = '' if word == WORD else ' T1'  # + ''.join(sub_rules)  # TODO: sort\n\n    return WORD, rules", "response": "T1 - > T1."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsplit any VV sequence that is not a genuine diphthong or long vowel. Eg., [ ta. e ko. et. taa ]. This rule can apply within VVV + sequences.", "response": "def T2(word, rules):\n    '''Split any VV sequence that is not a genuine diphthong or long vowel.\n    E.g., [ta.e], [ko.et.taa]. This rule can apply within VVV+ sequences.'''\n    WORD = word\n    offset = 0\n\n    for vv in vv_sequences(WORD):\n        seq = vv.group(1)\n\n        if not phon.is_diphthong(seq) and not phon.is_long(seq):\n            i = vv.start(1) + 1 + offset\n            WORD = WORD[:i] + '.' + WORD[i:]\n            offset += 1\n\n    rules += ' T2' if word != WORD else ''\n\n    return WORD, rules"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef T8(word, rules):\n    '''Join /ie/, /uo/, or /y\u00f6/ sequences in syllables that take primary\n    stress.'''\n    WORD = word\n\n    try:\n        vv = tail_diphthongs(WORD)\n        i = vv.start(1) + 1\n        WORD = WORD[:i] + word[i + 1:]\n\n    except AttributeError:\n        pass\n\n    rules += ' T8' if word != WORD else ''\n\n    return WORD, rules", "response": "Join IE UO or Y\u00f6 or Y\u00f6 sequences in syllables that take primary\n stress."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the number of stressed light syllables.", "response": "def pk_prom(word):\n    '''Return the number of stressed light syllables.'''\n    violations = 0\n    stressed = []\n\n    for w in extract_words(word):\n        stressed += w.split('.')[2:-1:2]  # odd syllables, excl. word-initial\n\n    # (CVV = light)\n    for syll in stressed:\n        if phon.is_vowel(syll[-1]):\n            violations += 1\n\n    # # (CVV = heavy)\n    # for syll in stressed:\n    #     if re.search(\n    #             ur'^[^ieaou\u00e4\u00f6y]*[ieaou\u00e4\u00f6y]{1}$',  syll, flags=re.I | re.U):\n    #         violations += 1\n\n    return violations"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ansi_format_iter( self, x_start=0, y_start=0, width=None, height=None, frame=0, columns=1, downsample=1 ):\n\n        image = self.get_image()\n        frames = []\n        frame_count = 1 if not hasattr( image, 'n_frames' ) else image.n_frames\n        if isinstance( frame, int ):\n            assert frame in range( 0, frame_count )\n            frames = [frame]\n        else:\n            frames = [f for f in frame if f in range( 0, frame_count )]\n\n        if not width:\n            width = image.size[0]-x_start\n        if not height:\n            height = image.size[1]-y_start\n\n        if image.mode == 'P':\n            palette = from_palette_bytes( image.getpalette() )\n\n            def data_fetch( x, y, fr ):\n                if fr not in range( 0, frame_count ):\n                    return Transparent()\n                if not ((0 <= x < image.size[0]) and (0 <= y < image.size[1])):\n                    return Transparent()\n                image.seek( fr )\n                return palette[image.getpixel( (x, y) )]\n\n            for x in ansi.format_image_iter( data_fetch, x_start, y_start, width, height, frames, columns, downsample ):\n                yield x\n        return", "response": "Return an iterator over the ANSI escape sequences that can be used to render the image."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ansi_format_iter( self, x_start=0, y_start=0, width=None, height=None, frame=0, columns=1, downsample=1, frame_index=None, frame_flip_v=0, frame_flip_h=0 ):\n\n        assert x_start in range( 0, self.width )\n        assert y_start in range( 0, self.height )\n        if frame_index is not None:\n            fn_index = lambda fr: mrc.property_get( frame_index, fr )\n        else:\n            fn_index = lambda fr: fr if fr in range( 0, self.frame_count ) else None\n        fn_flip_v = lambda fr: mrc.property_get( frame_flip_v, fr )\n        fn_flip_h = lambda fr: mrc.property_get( frame_flip_h, fr )\n\n        frames = []\n        try:\n            frame_iter = iter( frame )\n            frames = [f for f in frame_iter]\n        except TypeError:\n            frames = [frame]\n\n        if not width:\n            width = self.width-x_start\n        if not height:\n            height = self.height-y_start\n\n        stride = width*height\n\n        def data_fetch( x, y, fr_obj ):\n            fr = fn_index( fr_obj )\n            if fr is None:\n                return Transparent()\n            if not ((0 <= x < self.width) and (0 <= y < self.height)):\n                return Transparent()\n            if fn_flip_h( fr_obj ):\n                x = self.width - x - 1\n            if fn_flip_v( fr_obj ):\n                y = self.height - y - 1\n            index = self.width*y + x\n            p = self.source[stride*fr+index]\n            if self.mask:\n                p = p if self.mask[stride*fr+index] else None\n            return self.palette[p] if p is not None else Transparent()\n\n        for x in ansi.format_image_iter( data_fetch, x_start, y_start, width, height, frames, columns, downsample ):\n            yield x\n        return", "response": "Return an iterator over the ANSI escape sequences that can be used to render the image."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main():\n\n    parser = OptionParser(description=\n             \"Purge a single url from fastly.\")\n    parser.add_option(\"-k\", \"--key\", dest=\"apikey\",\n                      default=\"\", help=\"fastly api key\")\n    parser.add_option(\"-H\", \"--host\", dest=\"host\",\n                      help=\"host to purge from\")\n    parser.add_option(\"-p\", \"--path\", dest=\"path\",\n                      help=\"path to purge\")\n\n    (options, args) = parser.parse_args()\n    for val in options.__dict__.values():\n        if val is None:\n            print \"Missing required options\"\n            parser.print_help()\n            sys.exit(1)\n\n    client = fastly.connect(options.apikey)\n    purge = client.purge_url(options.host, options.path)\n    print purge", "response": "Purges a single fastly url from fastly."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering callbacks needed by the interface object.", "response": "def set_callbacks(self, **dic_functions):\n        \"\"\"Register callbacks needed by the interface object\"\"\"\n        for action in self.interface.CALLBACKS:\n            try:\n                f = dic_functions[action]\n            except KeyError:\n                pass\n            else:\n                setattr(self.interface.callbacks, action, f)\n        manquantes = [\n            a for a in self.interface.CALLBACKS if not a in dic_functions]\n        if not manquantes:\n            logging.debug(\n                f\"{self.__class__.__name__} : Tous les callbacks demand\u00e9s sont fournis.\")\n        else:\n            logging.warning(\n                f\"{self.__class__.__name__} didn't set asked callbacks {manquantes}\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef populate(self, obj=None, section=None, parse_types=True):\n        section = self.default_section if section is None else section\n        obj = Settings() if obj is None else obj\n        is_dict = isinstance(obj, dict)\n        for k, v in self.get_options(section).items():\n            if parse_types:\n                if v == 'None':\n                    v = None\n                elif self.FLOAT_REGEXP.match(v):\n                    v = float(v)\n                elif self.INT_REGEXP.match(v):\n                    v = int(v)\n                elif self.BOOL_REGEXP.match(v):\n                    v = v == 'True'\n                else:\n                    m = self.EVAL_REGEXP.match(v)\n                    if m:\n                        evalstr = m.group(1)\n                        v = eval(evalstr)\n            logger.debug('setting {} => {} on {}'.format(k, v, obj))\n            if is_dict:\n                obj[k] = v\n            else:\n                setattr(obj, k, v)\n        return obj", "response": "Populates obj with the values from the all values in section."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the module that is calling this function.", "response": "def _get_calling_module(self):\n        \"\"\"Get the last module in the call stack that is not this module or ``None`` if\n        the call originated from this module.\n\n        \"\"\"\n        for frame in inspect.stack():\n            mod = inspect.getmodule(frame[0])\n            logger.debug(f'calling module: {mod}')\n            if mod is not None:\n                mod_name = mod.__name__\n                if mod_name != __name__:\n                    return mod"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a resource based on a file name.", "response": "def resource_filename(self, resource_name, module_name=None):\n        \"\"\"Return a resource based on a file name.  This uses the ``pkg_resources``\n        package first to find the resources.  If it doesn't find it, it returns\n        a path on the file system.\n\n        :param: resource_name the file name of the resource to obtain (or name\n            if obtained from an installed module)\n        :param module_name: the name of the module to obtain the data, which\n            defaults to ``__name__``\n        :return: a path on the file system or resource of the installed module\n\n        \"\"\"\n        if module_name is None:\n            mod = self._get_calling_module()\n            logger.debug(f'calling module: {mod}')\n            if mod is not None:\n                mod_name = mod.__name__\n        if module_name is None:\n            module_name = __name__\n        if pkg_resources.resource_exists(mod_name, resource_name):\n            res = pkg_resources.resource_filename(mod_name, resource_name)\n        else:\n            res = resource_name\n        return Path(res)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parser(self):\n        \"Load the configuration file.\"\n        if not hasattr(self, '_conf'):\n            cfile = self.config_file\n            logger.debug('loading config %s' % cfile)\n            if os.path.isfile(cfile):\n                conf = self._create_config_parser()\n                conf.read(os.path.expanduser(cfile))\n            else:\n                if self.robust:\n                    logger.debug('no default config file %s--skipping' % cfile)\n                else:\n                    raise IOError('no such file: %s' % cfile)\n                conf = None\n            self._conf = conf\n        return self._conf", "response": "Load the configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_options(self, section='default', opt_keys=None, vars=None):\n        vars = vars if vars else self.default_vars\n        conf = self.parser\n        opts = {}\n        if opt_keys is None:\n            if conf is None:\n                opt_keys = {}\n            else:\n                if not self.robust or conf.has_section(section):\n                    opt_keys = conf.options(section)\n                else:\n                    opt_keys = {}\n        else:\n            logger.debug('conf: %s' % conf)\n            copts = conf.options(section) if conf else {}\n            opt_keys = set(opt_keys).intersection(set(copts))\n        for option in opt_keys:\n            logger.debug(f'option: {option}, vars: {vars}')\n            opts[option] = conf.get(section, option, vars=vars)\n        return opts", "response": "Get all options for a section."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an option from section with name.", "response": "def get_option(self, name, section=None, vars=None, expect=None):\n        \"\"\"Return an option from ``section`` with ``name``.\n\n        :param section: section in the ini file to fetch the value; defaults to\n        constructor's ``default_section``\n\n        \"\"\"\n        vars = vars if vars else self.default_vars\n        if section is None:\n            section = self.default_section\n        opts = self.get_options(section, opt_keys=[name], vars=vars)\n        if opts:\n            return opts[name]\n        else:\n            if self._narrow_expect(expect):\n                raise ValueError('no option \\'{}\\' found in section {}'.\n                                 format(name, section))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_option_list(self, name, section=None, vars=None,\n                        expect=None, separator=','):\n        \"\"\"Just like ``get_option`` but parse as a list using ``split``.\n\n        \"\"\"\n        val = self.get_option(name, section, vars, expect)\n        return val.split(separator) if val else []", "response": "Return a list of values from the option named name in section."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets option as a boolean.", "response": "def get_option_boolean(self, name, section=None, vars=None, expect=None):\n        \"\"\"Just like ``get_option`` but parse as a boolean (any case `true`).\n\n        \"\"\"\n        val = self.get_option(name, section, vars, expect)\n        val = val.lower() if val else 'false'\n        return val == 'true'"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_option_path(self, name, section=None, vars=None, expect=None):\n        val = self.get_option(name, section, vars, expect)\n        return Path(val)", "response": "Like get_option but return a Path object of\n        the string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef property_get( prop, instance, **kwargs ):\n    if isinstance( prop, Ref ):\n        return prop.get( instance, **kwargs )\n    return prop", "response": "Wrapper for property reads which auto - dereferences Refs if required."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef property_set( prop, instance, value, **kwargs ):\n\n    if isinstance( prop, Ref ):\n        return prop.set( instance, value, **kwargs )\n    raise AttributeError( \"can't change value of constant {} (context: {})\".format( prop, instance ) )", "response": "Wrapper for property. set"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwraps for attributes of a View class which auto-dereferences Refs. Equivalent to setting a property on the class with the getter wrapped with property_get(), and the setter wrapped with property_set(). prop A string containing the name of the class attribute to wrap.", "response": "def view_property( prop ):\n    \"\"\"Wrapper for attributes of a View class which auto-dereferences Refs.\n    \n    Equivalent to setting a property on the class with the getter wrapped\n    with property_get(), and the setter wrapped with property_set().\n\n    prop\n        A string containing the name of the class attribute to wrap.\n    \"\"\"\n    def getter( self ):\n        return property_get( getattr( self, prop ), self.parent )\n\n    def setter( self, value ):\n        return property_set( getattr( self, prop ), self.parent, value )\n\n    return property( getter, setter )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get( self, instance, **kwargs ):\n        target = instance\n        for attr in self._path:\n            target = getattr( target, attr )\n        return target", "response": "Return an attribute from an object using the Ref path."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset an attribute on an object using the Ref path.", "response": "def set( self, instance, value, **kwargs ):\n        \"\"\"Set an attribute on an object using the Ref path.\n\n        instance\n            The object instance to traverse.\n\n        value\n            The value to set.\n\n        Throws AttributeError if allow_write is False.\n        \"\"\"\n        if not self._allow_write:\n            raise AttributeError( \"can't set Ref directly, allow_write is disabled\" )\n        target = instance\n        for attr in self._path[:-1]:\n            target = getattr( target, attr )\n        setattr( target, self._path[-1], value )\n        return"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntraverse the tree until the tree is not modified.", "response": "def traverse_until_fixpoint(predicate, tree):\n    \"\"\"Traverses the tree again and again until it is not modified.\"\"\"\n    old_tree = None\n    tree = simplify(tree)\n    while tree and old_tree != tree:\n        old_tree = tree\n        tree = tree.traverse(predicate)\n        if not tree:\n            return None\n        tree = simplify(tree)\n    return tree"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning the necessary methods in the correct order for the current runmetadata object", "response": "def runner(self):\n        \"\"\"\n        Run the necessary methods in the correct order\n        \"\"\"\n        logging.info('Starting {} analysis pipeline'.format(self.analysistype))\n        # Initialise the GenObject\n        for sample in self.runmetadata.samples:\n            setattr(sample, self.analysistype, GenObject())\n            try:\n                sample[self.analysistype].pointfindergenus = self.pointfinder_org_dict[sample.general.referencegenus]\n            except KeyError:\n                sample[self.analysistype].pointfindergenus = 'ND'\n        # Run the raw read mapping\n        PointSipping(inputobject=self,\n                     cutoff=self.cutoff)\n        # Create FASTA files from the raw read matcves\n        self.fasta()\n        # Run PointFinder on the FASTA files\n        self.run_pointfinder()\n        # Create summary reports of the PointFinder outputs\n        self.parse_pointfinder()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates the FASTA files of the PointFinder results that are fed into PointFinder", "response": "def fasta(self):\n        \"\"\"\n        Create FASTA files of the PointFinder results to be fed into PointFinder\n        \"\"\"\n        logging.info('Extracting FASTA sequences matching PointFinder database')\n        for sample in self.runmetadata.samples:\n            # Ensure that there are sequence data to extract from the GenObject\n            if GenObject.isattr(sample[self.analysistype], 'sequences'):\n                # Set the name of the FASTA file\n                sample[self.analysistype].pointfinderfasta = \\\n                    os.path.join(sample[self.analysistype].outputdir,\n                                 '{seqid}_pointfinder.fasta'.format(seqid=sample.name))\n                # Create a list to store all the SeqRecords created\n                sequences = list()\n                with open(sample[self.analysistype].pointfinderfasta, 'w') as fasta:\n                    for gene, sequence in sample[self.analysistype].sequences.items():\n                        # Create a SeqRecord using a Seq() of the sequence - both SeqRecord and Seq are from BioPython\n                        seq = SeqRecord(seq=Seq(sequence),\n                                        id=gene,\n                                        name=str(),\n                                        description=str())\n                        sequences.append(seq)\n                    # Write all the SeqRecords to file\n                    SeqIO.write(sequences, fasta, 'fasta')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun PointFinder on the FASTA files extracted from the raw reads and store the results in the output directory.", "response": "def run_pointfinder(self):\n        \"\"\"\n        Run PointFinder on the FASTA sequences extracted from the raw reads\n        \"\"\"\n        logging.info('Running PointFinder on FASTA files')\n        for i in range(len(self.runmetadata.samples)):\n            # Start threads\n            threads = Thread(target=self.pointfinder_threads, args=())\n            # Set the daemon to True - something to do with thread management\n            threads.setDaemon(True)\n            # Start the threading\n            threads.start()\n        # PointFinder requires the path to the blastn executable\n        blast_path = shutil.which('blastn')\n        for sample in self.runmetadata.samples:\n            # Ensure that the attribute storing the name of the FASTA file has been created\n            if GenObject.isattr(sample[self.analysistype], 'pointfinderfasta'):\n                sample[self.analysistype].pointfinder_outputs = os.path.join(sample[self.analysistype].outputdir,\n                                                                             'pointfinder_outputs')\n                # Don't run the analyses if the outputs have already been created\n                if not os.path.isfile(os.path.join(sample[self.analysistype].pointfinder_outputs,\n                                                   '{samplename}_blastn_results.tsv'.format(samplename=sample.name))):\n                    make_path(sample[self.analysistype].pointfinder_outputs)\n                    # Create and run the PointFinder system call\n                    pointfinder_cmd = \\\n                        'python -m pointfinder.PointFinder -i {input} -s {species} -p {db_path} -m blastn ' \\\n                        '-o {output_dir} -m_p {blast_path}'\\\n                        .format(input=sample[self.analysistype].pointfinderfasta,\n                                species=sample[self.analysistype].pointfindergenus,\n                                db_path=self.targetpath,\n                                output_dir=sample[self.analysistype].pointfinder_outputs,\n                                blast_path=blast_path)\n                    self.queue.put(pointfinder_cmd)\n        self.queue.join()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npopulate the summary dictionary for the specified genus.", "response": "def populate_summary_dict(self, genus=str(), key=str()):\n        \"\"\"\n        :param genus: Non-supported genus to be added to the dictionary\n        :param key: section of dictionary to be populated. Supported keys are: prediction, table, and results\n        Populate self.summary_dict as required. If the genus is not provided, populate the dictionary for Salmonella\n        Escherichia and Campylobacter. If the genus is provided, this genus is non-standard, and an 'empty' profile\n        must be created for it\n        \"\"\"\n        # If the genus is not provided, generate the generic dictionary\n        if not genus:\n            # Populate the summary dict\n            self.summary_dict = {\n                'Salmonella':\n                    {\n                        'prediction':\n                            {\n                                'header': 'Strain,Colitsin,Colistin,Spectinomycin,Quinolones,\\n',\n                                'output': str(),\n                                'summary': os.path.join(self.reportpath, 'Salmonella_prediction_summary.csv')\n                            },\n                        'table':\n                            {\n                                'header': 'Strain,parE,parC,gyrA,pmrB,pmrA,gyrB,16S_rrsD,23S,\\n',\n                                'output': str(),\n                                'summary': os.path.join(self.reportpath, 'Salmonella_table_summary.csv')\n                            },\n                        'results':\n                            {\n                                'header': 'Strain,Genus,Mutation,NucleotideChange,AminoAcidChange,Resistance,PMID,\\n',\n                                'output': str(),\n                                'summary': os.path.join(self.reportpath, 'PointFinder_results_summary.csv')\n                            }\n                    },\n                'Escherichia':\n                    {\n                        'prediction':\n                            {\n                                'header': 'Strain,Colistin,GentamicinC,gentamicinC,Streptomycin,Macrolide,Sulfonamide,'\n                                          'Tobramycin,Neomycin,Fluoroquinolones,Aminocoumarin,Tetracycline,KanamycinA,'\n                                          'Spectinomycin,B-lactamResistance,Paromomycin,Kasugamicin,Quinolones,G418,'\n                                          'QuinolonesAndfluoroquinolones,\\n',\n                                'output': str(),\n                                'summary': os.path.join(self.reportpath, 'Escherichia_prediction_summary.csv')\n                            },\n                        'table':\n                            {\n                                'header': 'Strain,parE,parC,folP,gyrA,pmrB,pmrA,16S_rrsB,16S_rrsH,gyrB,ampC,'\n                                          '16S_rrsC,23S,\\n',\n                                'output': str(),\n                                'summary': os.path.join(self.reportpath, 'Escherichia_table_summary.csv')\n                            },\n                        'results':\n                            {\n                                'header': 'Strain,Genus,Mutation,NucleotideChange,AminoAcidChange,Resistance,PMID,\\n',\n                                'output': str(),\n                                'summary': os.path.join(self.reportpath, 'PointFinder_results_summary.csv')\n                            }\n                    },\n                'Campylobacter':\n                    {\n\n                        'prediction':\n                            {\n                                'header': 'Strain,LowLevelIncreaseMIC,AssociatedWithT86Mutations,Macrolide,Quinolone,'\n                                          'Streptinomycin,Erythromycin,IntermediateResistance,HighLevelResistance_'\n                                          'nalidixic_and_ciprofloxacin,\\n',\n                                'output': str(),\n                                'summary': os.path.join(self.reportpath, 'Campylobacter_prediction_summary.csv')\n                            },\n                        'table':\n                            {\n                                'header': 'Strain,L22,rpsL,cmeR,gyrA,23S,\\n',\n                                'output': str(),\n                                'summary': os.path.join(self.reportpath, 'Campylobacter_table_summary.csv')\n                            },\n                        'results':\n                            {\n                                'header': 'Strain,Genus,Mutation,NucleotideChange,AminoAcidChange,Resistance,PMID,\\n',\n                                'output': str(),\n                                'summary': os.path.join(self.reportpath, 'PointFinder_results_summary.csv')\n                            }\n                    }\n            }\n        else:\n            # Create the nesting structure as required\n            if genus not in self.summary_dict:\n                self.summary_dict[genus] = dict()\n            if key not in self.summary_dict[genus]:\n                self.summary_dict[genus][key] = dict()\n            # The output section is the same regardless of the key\n            self.summary_dict[genus][key]['output'] = str()\n            # The results report is more generic, and contains all strains, so the header and summary are set to\n            # the default values required to generate this report\n            if key == 'results':\n                self.summary_dict[genus][key]['header'] = \\\n                    'Strain,Genus,Mutation,NucleotideChange,AminoAcidChange,Resistance,PMID,\\n'\n                self.summary_dict[genus][key]['summary'] = \\\n                    os.path.join(self.reportpath, 'PointFinder_results_summary.csv')\n            # Create an empty header, and a report with the genus name\n            else:\n                self.summary_dict[genus][key]['header'] = 'Strain,\\n'\n                self.summary_dict[genus][key]['summary'] = os.path.join(self.reportpath, '{genus}_{key}_summary.csv'\n                                                                        .format(genus=genus,\n                                                                                key=key))\n                # Remove the report if it exists, as the script will append data to this existing report\n                if os.path.isfile(self.summary_dict[genus][key]['summary']):\n                    os.remove(self.summary_dict[genus][key]['summary'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_pointfinder(self):\n        # Create the nested dictionary that stores the necessary values for creating summary reports\n        self.populate_summary_dict()\n        # Clear out any previous reports\n        for organism in self.summary_dict:\n            for report in self.summary_dict[organism]:\n                try:\n                    os.remove(self.summary_dict[organism][report]['summary'])\n                except FileNotFoundError:\n                    pass\n        for sample in self.runmetadata.samples:\n            # Find the PointFinder outputs. If the outputs don't exist, create the appropriate entries in the\n            # summary dictionary as required\n            try:\n                self.summary_dict[sample.general.referencegenus]['prediction']['output'] = \\\n                    glob(os.path.join(sample[self.analysistype].pointfinder_outputs, '{seq}*prediction.txt'\n                                      .format(seq=sample.name)))[0]\n            except IndexError:\n                try:\n                    self.summary_dict[sample.general.referencegenus]['prediction']['output'] = str()\n                except KeyError:\n                    self.populate_summary_dict(genus=sample.general.referencegenus,\n                                               key='prediction')\n            try:\n                self.summary_dict[sample.general.referencegenus]['table']['output'] = \\\n                    glob(os.path.join(sample[self.analysistype].pointfinder_outputs, '{seq}*table.txt'\n                                      .format(seq=sample.name)))[0]\n            except IndexError:\n                try:\n                    self.summary_dict[sample.general.referencegenus]['table']['output'] = str()\n                except KeyError:\n                    self.populate_summary_dict(genus=sample.general.referencegenus,\n                                               key='table')\n            try:\n                self.summary_dict[sample.general.referencegenus]['results']['output'] = \\\n                    glob(os.path.join(sample[self.analysistype].pointfinder_outputs, '{seq}*results.tsv'\n                                      .format(seq=sample.name)))[0]\n            except IndexError:\n                try:\n                    self.summary_dict[sample.general.referencegenus]['results']['output'] = str()\n                except KeyError:\n                    self.populate_summary_dict(genus=sample.general.referencegenus,\n                                               key='results')\n            # Process the predictions\n            self.write_report(summary_dict=self.summary_dict,\n                              seqid=sample.name,\n                              genus=sample.general.referencegenus,\n                              key='prediction')\n            # Process the results summary\n            self.write_report(summary_dict=self.summary_dict,\n                              seqid=sample.name,\n                              genus=sample.general.referencegenus,\n                              key='results')\n\n            # Process the table summary\n            self.write_table_report(summary_dict=self.summary_dict,\n                                    seqid=sample.name,\n                                    genus=sample.general.referencegenus)", "response": "Parse the PointFinder output files and create the nested dictionary that stores the necessary values for creating the summary reports for the PointFinder outputs\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_report(summary_dict, seqid, genus, key):\n        # Set the header string if the summary report doesn't already exist\n        if not os.path.isfile(summary_dict[genus][key]['summary']):\n            header_string = summary_dict[genus][key]['header']\n        else:\n            header_string = str()\n        summary_string = str()\n        try:\n            # Read in the predictions\n            with open(summary_dict[genus][key]['output'], 'r') as outputs:\n                # Skip the header\n                next(outputs)\n                for line in outputs:\n                    # Skip empty lines\n                    if line != '\\n':\n                        # When processing the results outputs, add the seqid to the summary string\n                        if key == 'results':\n                            summary_string += '{seq},{genus},'.format(seq=seqid,\n                                                                      genus=genus)\n                        # Clean up the string before adding it to the summary string - replace commas\n                        # with semi-colons, and replace tabs with commas\n                        summary_string += line.replace(',', ';').replace('\\t', ',')\n            # Ensure that there were results to report\n            if summary_string:\n                if not summary_string.endswith('\\n'):\n                    summary_string += '\\n'\n            else:\n                if key == 'results':\n                    summary_string += '{seq},{genus}\\n'.format(seq=seqid,\n                                                               genus=genus)\n                else:\n                    summary_string += '{seq}\\n'.format(seq=seqid)\n            # Write the summaries to the summary file\n            with open(summary_dict[genus][key]['summary'], 'a+') as summary:\n                # Write the header if necessary\n                if header_string:\n                    summary.write(header_string)\n                summary.write(summary_string)\n        # Add the strain information If no FASTA file could be created by reference mapping\n        except FileNotFoundError:\n            # Extract the length of the header from the dictionary. Subtract two (don't need the strain, or the\n            # empty column created by a trailing comma\n            header_len = len(summary_dict[genus][key]['header'].split(',')) - 2\n            # When processing the results outputs, add the seqid to the summary string\n            if key == 'results':\n                summary_string += '{seq},{genus}\\n'.format(seq=seqid,\n                                                           genus=genus)\n            # For the prediction summary, populate the summary string with the appropriate number of comma-separated\n            # '0' entries\n            elif key == 'prediction':\n                summary_string += '{seq}{empty}\\n'.format(seq=seqid,\n                                                          empty=',0' * header_len)\n            # Write the summaries to the summary file\n            with open(summary_dict[genus][key]['summary'], 'a+') as summary:\n                # Write the header if necessary\n                if header_string:\n                    summary.write(header_string)\n                summary.write(summary_string)", "response": "Parse the PointFinder outputs and write the summary report for the current analysis type and the current result type."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the PointFinder table output and write a summary report", "response": "def write_table_report(summary_dict, seqid, genus):\n        \"\"\"\n        Parse the PointFinder table output, and write a summary report\n        :param summary_dict: nested dictionary containing data such as header strings, and paths to reports\n        :param seqid: name of the strain,\n        :param genus: MASH-calculated genus of current isolate\n        \"\"\"\n        # Set the header string if the summary report doesn't already exist\n        if not os.path.isfile(summary_dict[genus]['table']['summary']):\n            header_string = summary_dict[genus]['table']['header']\n        else:\n            header_string = str()\n        summary_string = '{seq},'.format(seq=seqid)\n        try:\n            # Read in the predictions\n            with open(summary_dict[genus]['table']['output'], 'r') as outputs:\n                for header_value in summary_dict[genus]['table']['header'].split(',')[:-1]:\n                    for line in outputs:\n                        if line.startswith('{hv}\\n'.format(hv=header_value)):\n                            # Iterate through the lines following the match\n                            for subline in outputs:\n                                if subline != '\\n':\n                                    if subline.startswith('Mutation'):\n                                        for detailline in outputs:\n                                            if detailline != '\\n':\n                                                summary_string += '{},'.format(detailline.split('\\t')[0])\n                                            else:\n                                                break\n                                    else:\n                                        summary_string += '{},'.format(\n                                            subline.replace(',', ';').replace('\\t', ',').rstrip())\n                                        break\n                                else:\n                                    break\n                                break\n                    # Reset the file iterator to the first line in preparation for the next header\n                    outputs.seek(0)\n            # Ensure that there were results to report\n            if summary_string:\n                if not summary_string.endswith('\\n'):\n                    summary_string += '\\n'\n                # Write the summaries to the summary file\n                with open(summary_dict[genus]['table']['summary'], 'a+') as summary:\n                    # Write the header if necessary\n                    if header_string:\n                        summary.write(header_string)\n                    summary.write(summary_string)\n        except FileNotFoundError:\n            # Write the summaries to the summary file\n            with open(summary_dict[genus]['table']['summary'], 'a+') as summary:\n                # Extract the length of the header from the dictionary. Subtract two (don't need the strain, or the\n                # empty column created by a trailing comma\n                header_len = len(summary_dict[genus]['table']['header'].split(',')) - 2\n                # Populate the summary strain with the appropriate number of comma-separated 'Gene not found' entries\n                summary_string += '{empty}\\n'.format(empty='Gene not found,' * header_len)\n                # Write the header if necessary\n                if header_string:\n                    summary.write(header_string)\n                summary.write(summary_string)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef targets(self):\n        logging.info('Performing analysis with {} targets folder'.format(self.analysistype))\n        for sample in self.runmetadata:\n            sample[self.analysistype].runanalysis = True\n            sample[self.analysistype].targetpath = (os.path.join(self.targetpath,\n                                                                 sample[self.analysistype].pointfindergenus))\n            # There is a relatively strict databasing scheme necessary for the custom targets. Eventually,\n            # there will be a helper script to combine individual files into a properly formatted combined file\n            try:\n                sample[self.analysistype].baitfile = glob(os.path.join(sample[self.analysistype].targetpath,\n                                                                       '*.fasta'))[0]\n            # If the fasta file is missing, raise a custom error\n            except IndexError:\n                # Combine any .tfa files in the directory into a combined targets .fasta file\n                fsafiles = glob(os.path.join(sample[self.analysistype].targetpath, '*.fsa'))\n                if fsafiles:\n                    combinetargets(fsafiles, sample[self.analysistype].targetpath)\n                try:\n                    sample[self.analysistype].baitfile = glob(os.path.join(sample[self.analysistype].targetpath,\n                                                                           '*.fasta'))[0]\n                except IndexError as e:\n                    # noinspection PyPropertyAccess\n                    e.args = [\n                        'Cannot find the combined fasta file in {}. Please note that the file must have a '\n                        '.fasta extension'.format(sample[self.analysistype].targetpath)]\n                    if os.path.isdir(sample[self.analysistype].targetpath):\n                        raise\n                    else:\n                        sample[self.analysistype].runanalysis = False\n        for sample in self.runmetadata:\n            # Set the necessary attributes\n            sample[self.analysistype].outputdir = os.path.join(sample.run.outputdirectory, self.analysistype)\n            make_path(sample[self.analysistype].outputdir)\n            sample[self.analysistype].logout = os.path.join(sample[self.analysistype].outputdir, 'logout.txt')\n            sample[self.analysistype].logerr = os.path.join(sample[self.analysistype].outputdir, 'logerr.txt')\n            sample[self.analysistype].baitedfastq = \\\n                os.path.join(sample[self.analysistype].outputdir,\n                             '{at}_targetMatches.fastq.gz'.format(at=self.analysistype))", "response": "Create the multi - FASTA files of all targets if necessary and populate objects\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef strains(self):\n        with open(os.path.join(self.path, 'strains.csv')) as strains:\n            next(strains)\n            for line in strains:\n                oln, seqid = line.split(',')\n                self.straindict[oln] = seqid.rstrip()\n                self.strainset.add(oln)\n                logging.debug(oln)\n                if self.debug:\n                    break", "response": "Create a dictionary of SEQID - > OLNID"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_json(metadata):\n        # Open the metadata file to write\n        with open(metadata.jsonfile, 'w') as metadatafile:\n            # Write the json dump of the object dump to the metadata file\n            json.dump(metadata.dump(), metadatafile, sort_keys=True, indent=4, separators=(',', ': '))", "response": "Write the metadata object to the metadata. jsonfile"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_json(json_metadata):\n        # Load the metadata object from the file\n        with open(json_metadata) as metadatareport:\n            jsondata = json.load(metadatareport)\n        # Create the metadata objects\n        metadata = MetadataObject()\n        # Initialise the metadata categories as GenObjects created using the appropriate key\n        for attr in jsondata:\n            if not isinstance(jsondata[attr], dict):\n                setattr(metadata, attr, jsondata[attr])\n            else:\n                setattr(metadata, attr, GenObject(jsondata[attr]))\n        return metadata", "response": "Read the metadata object from a JSON - formatted metadata object file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetermining the total number of bases in each assembly file in each assembly file and update the assembly_length attribute with the total number of bases in each assembly file in each assembly file.", "response": "def assembly_length(self):\n        \"\"\"\n        Use SeqIO.parse to extract the total number of bases in each assembly file\n        \"\"\"\n        for sample in self.metadata:\n            # Only determine the assembly length if is has not been previously calculated\n            if not GenObject.isattr(sample, 'assembly_length'):\n                # Create the assembly_length attribute, and set it to 0\n                sample.assembly_length = 0\n                for record in SeqIO.parse(sample.bestassemblyfile, 'fasta'):\n                    # Update the assembly_length attribute with the length of the current contig\n                    sample.assembly_length += len(record.seq)\n                # Write the updated object to file\n                self.write_json(sample)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef simulate_reads(self):\n        logging.info('Read simulation')\n        for sample in self.metadata:\n            # Create the simulated_reads GenObject\n            sample.simulated_reads = GenObject()\n            # Iterate through all the desired depths of coverage\n            for depth in self.read_depths:\n                # Create the depth GenObject\n                setattr(sample.simulated_reads, depth, GenObject())\n                # Set the depth and output directory attributes for the depth GenObject\n                sample.simulated_reads[depth].depth = depth\n                sample.simulated_reads[depth].depth_dir = os.path.join(sample.outputdir, 'simulated', depth)\n                # Create the output directory\n                make_path(sample.simulated_reads[depth].depth_dir)\n                # Iterate through all the desired forward and reverse read pair lengths\n                for read_pair in self.read_lengths:\n                    # Create the read_pair GenObject within the depth GenObject\n                    setattr(sample.simulated_reads[depth], read_pair, GenObject())\n                    # Set and create the output directory\n                    sample.simulated_reads[depth][read_pair].outputdir = \\\n                        os.path.join(sample.simulated_reads[depth].depth_dir, read_pair)\n                    make_path(sample.simulated_reads[depth][read_pair].outputdir)\n                    # Create both forward_reads and reverse_reads sub-GenObjects\n                    sample.simulated_reads[depth][read_pair].forward_reads = GenObject()\n                    sample.simulated_reads[depth][read_pair].reverse_reads = GenObject()\n                    # Extract the forward and reverse reads lengths from the read_pair variable\n                    sample.simulated_reads[depth][read_pair].forward_reads.length, \\\n                        sample.simulated_reads[depth][read_pair].reverse_reads.length = read_pair.split('_')\n                    # Set the name of the forward reads - include the depth and read length information\n                    sample.simulated_reads[depth][read_pair].forward_reads.fastq = \\\n                        os.path.join(sample.simulated_reads[depth][read_pair].outputdir,\n                                     '{name}_{depth}_{read_pair}_R1.fastq.gz'\n                                     .format(name=sample.name,\n                                             depth=depth,\n                                             read_pair=read_pair))\n                    # Reverse reads\n                    sample.simulated_reads[depth][read_pair].reverse_reads.fastq = \\\n                        os.path.join(sample.simulated_reads[depth][read_pair].outputdir,\n                                     '{name}_{depth}_{read_pair}_R2.fastq.gz'\n                                     .format(name=sample.name,\n                                             depth=depth,\n                                             read_pair=read_pair))\n                    # Create the trimmed output directory attribute\n                    sample.simulated_reads[depth][read_pair].simulated_trimmed_outputdir \\\n                        = os.path.join(sample.simulated_reads[depth][read_pair].outputdir,\n                                       'simulated_trimmed')\n                    # Set the name of the forward trimmed reads - include the depth and read length information\n                    # This is set now, as the untrimmed files will be removed, and a check is necessary\n                    sample.simulated_reads[depth][read_pair].forward_reads.trimmed_simulated_fastq = \\\n                        os.path.join(sample.simulated_reads[depth][read_pair].simulated_trimmed_outputdir,\n                                     '{name}_simulated_{depth}_{read_pair}_R1.fastq.gz'\n                                     .format(name=sample.name,\n                                             depth=depth,\n                                             read_pair=read_pair))\n                    # Reverse reads\n                    sample.simulated_reads[depth][read_pair].reverse_reads.trimmed_simulated_fastq = \\\n                        os.path.join(sample.simulated_reads[depth][read_pair].simulated_trimmed_outputdir,\n                                     '{name}_simulated_{depth}_{read_pair}_R2.fastq.gz'\n                                     .format(name=sample.name,\n                                             depth=depth,\n                                             read_pair=read_pair))\n                    # Calculate the number of reads required for the forward and reverse reads to yield the\n                    # desired coverage depth e.g. 5Mbp genome at 20X coverage: 100Mbp in reads. 50bp forward reads\n                    # 150bp reverse reads: forward proportion is 50 / (150 + 50) = 0.25 (and reverse is 0.75).\n                    # Forward total reads is 25Mbp (75Mbp reverse). Number of reads required = 25Mbp / 50 bp\n                    # 500000 reads total (same for reverse, as the reads are longer)\n                    sample.simulated_reads[depth][read_pair].num_reads = \\\n                        int(sample.assembly_length *\n                            int(depth) *\n                            (int(sample.simulated_reads[depth][read_pair].forward_reads.length) /\n                             (int(sample.simulated_reads[depth][read_pair].forward_reads.length) +\n                              int(sample.simulated_reads[depth][read_pair].reverse_reads.length)\n                              )\n                             ) /\n                            int(sample.simulated_reads[depth][read_pair].forward_reads.length)\n                            )\n                    logging.info(\n                        'Simulating {num_reads} paired reads for sample {name} with the following parameters:\\n'\n                        'depth {dp}, forward reads {fl}bp, and reverse reads {rl}bp'\n                        .format(num_reads=sample.simulated_reads[depth][read_pair].num_reads,\n                                dp=depth,\n                                name=sample.name,\n                                fl=sample.simulated_reads[depth][read_pair].forward_reads.length,\n                                rl=sample.simulated_reads[depth][read_pair].reverse_reads.length))\n                    # If the reverse reads are set to 0, supply different parameters to randomreads\n                    if sample.simulated_reads[depth][read_pair].reverse_reads.length != '0':\n                        # Ensure that both the simulated reads, and the trimmed simulated reads files don't\n                        # exist before simulating the reads\n                        if not os.path.isfile(sample.simulated_reads[depth][read_pair].forward_reads.fastq) and \\\n                                not os.path.isfile(\n                                    sample.simulated_reads[depth][read_pair].forward_reads.trimmed_simulated_fastq):\n                            # Use the randomreads method in the OLCTools bbtools wrapper to simulate the reads\n                            out, \\\n                                err, \\\n                                sample.simulated_reads[depth][read_pair].forward_reads.simulate_call = bbtools\\\n                                .randomreads(reference=sample.bestassemblyfile,\n                                             length=sample.simulated_reads[depth][read_pair].reverse_reads.length,\n                                             reads=sample.simulated_reads[depth][read_pair].num_reads,\n                                             out_fastq=sample.simulated_reads[depth][read_pair].forward_reads.fastq,\n                                             paired=True,\n                                             returncmd=True,\n                                             **{'ziplevel': '9',\n                                                'illuminanames': 't',\n                                                'Xmx': self.mem}\n                                             )\n                        else:\n                            try:\n                                forward_size = os.path.getsize(sample.simulated_reads[depth][read_pair]\n                                                               .forward_reads.fastq)\n                            except FileNotFoundError:\n                                forward_size = 0\n                            try:\n                                reverse_size = os.path.getsize(sample.simulated_reads[depth][read_pair]\n                                                               .reverse_reads.fastq)\n                            except FileNotFoundError:\n                                reverse_size = 0\n                            if forward_size <= 100 or reverse_size <= 100:\n                                try:\n                                    os.remove(sample.simulated_reads[depth][read_pair].forward_reads.fastq)\n                                except FileNotFoundError:\n                                    pass\n                                try:\n                                    os.remove(sample.simulated_reads[depth][read_pair].reverse_reads.fastq)\n                                except FileNotFoundError:\n                                    pass\n                                # Use the randomreads method in the OLCTools bbtools wrapper to simulate the reads\n                                out, \\\n                                err, \\\n                                sample.simulated_reads[depth][read_pair].forward_reads.simulate_call = bbtools \\\n                                    .randomreads(reference=sample.bestassemblyfile,\n                                                 length=sample.simulated_reads[depth][read_pair].reverse_reads.length,\n                                                 reads=sample.simulated_reads[depth][read_pair].num_reads,\n                                                 out_fastq=sample.simulated_reads[depth][read_pair].forward_reads.fastq,\n                                                 paired=True,\n                                                 returncmd=True,\n                                                 **{'ziplevel': '9',\n                                                    'illuminanames': 't'}\n                                                 )\n                    else:\n                        if not os.path.isfile(sample.simulated_reads[depth][read_pair].forward_reads.fastq):\n                            # Use the randomreads method in the OLCTools bbtools wrapper to simulate the reads\n                            out, \\\n                                err, \\\n                                sample.simulated_reads[depth][read_pair].forward_reads.simulate_call = bbtools\\\n                                .randomreads(reference=sample.bestassemblyfile,\n                                             length=sample.simulated_reads[depth][read_pair].forward_reads.length,\n                                             reads=sample.simulated_reads[depth][read_pair].num_reads,\n                                             out_fastq=sample.simulated_reads[depth][read_pair].forward_reads.fastq,\n                                             paired=False,\n                                             returncmd=True,\n                                             **{'ziplevel': '9',\n                                                'illuminanames': 't'}\n                                             )\n                # Update the JSON file\n                self.write_json(sample)", "response": "Create the simulated reads file for each sample in the metadata and generate the corresponding forward and reverse lengths for each depth of sequencing."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_length_adjust(self, analysistype):\n        logging.info('Trimming {at} reads'.format(at=analysistype))\n        for sample in self.metadata:\n            # Iterate through all the desired depths of coverage\n            for depth in self.read_depths:\n                for read_pair in self.read_lengths:\n                    # Create variables using the analysis type. These will be used in setting GenObject attributes\n                    read_type = '{at}_reads'.format(at=analysistype)\n                    fastq_type = 'trimmed_{at}_fastq'.format(at=analysistype)\n                    logging.info(\n                        'Trimming forward {at} reads for sample {name} at depth {depth} to length {length}'\n                        .format(at=analysistype,\n                                name=sample.name,\n                                depth=depth,\n                                length=sample[read_type][depth][read_pair].forward_reads.length))\n                    # Create the output path if necessary\n                    make_path(os.path.dirname(sample[read_type][depth][read_pair].forward_reads[fastq_type]))\n                    if sample[read_type][depth][read_pair].reverse_reads.length != '0':\n                        # Use the reformat method in the OLCTools bbtools wrapper to trim the reads\n                        out, \\\n                            err, \\\n                            sample[read_type][depth][read_pair].forward_reads.sample_call = bbtools \\\n                            .reformat_reads(forward_in=sample[read_type][depth][read_pair].forward_reads.fastq,\n                                            reverse_in=None,\n                                            forward_out=sample[read_type][depth][read_pair].forward_reads[fastq_type],\n                                            returncmd=True,\n                                            **{'ziplevel': '9',\n                                               'forcetrimright':\n                                                   sample[read_type][depth][read_pair].forward_reads.length,\n                                               'tossbrokenreads': 't',\n                                               'tossjunk': 't',\n                                               'Xmx': self.mem\n                                               }\n                                            )\n                        # # Remove the untrimmed reads\n                        # try:\n                        #     os.remove(sample[read_type][depth][read_pair].forward_reads.fastq)\n                        # except FileNotFoundError:\n                        #     pass\n\n                    else:\n                        # If the files do not need to be trimmed, create a symlink to the original file\n                        relative_symlink(sample[read_type][depth][read_pair].forward_reads.fastq,\n                                         os.path.dirname(sample[read_type][depth][read_pair].\n                                                         forward_reads[fastq_type]),\n                                         os.path.basename(sample[read_type][depth][read_pair].\n                                                          forward_reads[fastq_type])\n                                         )\n                    # Same as above, but for the reverse reads\n                    logging.info(\n                        'Trimming reverse {at} reads for sample {name} at depth {depth} to length {length}'\n                        .format(at=analysistype,\n                                name=sample.name,\n                                depth=depth,\n                                length=sample[read_type][depth][read_pair].reverse_reads.length))\n                    if sample[read_type][depth][read_pair].reverse_reads.length != '0':\n                        # Use the reformat method in the OLCTools bbtools wrapper to trim the reads\n                        out, \\\n                            err, \\\n                            sample[read_type][depth][read_pair].reverse_reads.sample_call = bbtools \\\n                            .reformat_reads(forward_in=sample[read_type][depth][read_pair].reverse_reads.fastq,\n                                            reverse_in=None,\n                                            forward_out=sample[read_type][depth][read_pair].reverse_reads[fastq_type],\n                                            returncmd=True,\n                                            **{'ziplevel': '9',\n                                               'forcetrimright':\n                                                   sample[read_type][depth][read_pair].reverse_reads.length,\n                                               'tossbrokenreads': 't',\n                                               'tossjunk': 't',\n                                               'Xmx': self.mem\n                                               })\n                        # # Remove the untrimmed reads\n                        # try:\n                        #     os.remove(sample[read_type][depth][read_pair].reverse_reads.fastq)\n                        # except FileNotFoundError:\n                        #     pass\n            # Update the JSON file\n            self.write_json(sample)", "response": "This method will trim the reads to the correct length using reformat. sh\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_quality_trim(self):\n        logging.info('Quality trim')\n        for sample in self.metadata:\n            sample.sampled_reads = GenObject()\n            sample.sampled_reads.outputdir = os.path.join(sample.outputdir, 'sampled')\n            sample.sampled_reads.trimmed_dir = os.path.join(sample.sampled_reads.outputdir, 'qualitytrimmed_reads')\n            make_path(sample.sampled_reads.trimmed_dir)\n            for depth in self.read_depths:\n                # Create the depth GenObject\n                setattr(sample.sampled_reads, depth, GenObject())\n                # Set the depth and output directory attributes for the depth GenObject\n                sample.sampled_reads[depth].depth = depth\n                sample.sampled_reads[depth].depth_dir = os.path.join(sample.sampled_reads.outputdir, depth)\n                # Create the output directory\n                make_path(sample.sampled_reads[depth].depth_dir)\n                for read_pair in self.read_lengths:\n                    # Create the read_pair GenObject within the depth GenObject\n                    setattr(sample.sampled_reads[depth], read_pair, GenObject())\n                    # Set and create the output directory\n                    sample.sampled_reads[depth][read_pair].outputdir = \\\n                        os.path.join(sample.sampled_reads[depth].depth_dir, read_pair)\n                    make_path(sample.sampled_reads[depth][read_pair].outputdir)\n                    # Create both forward_reads and reverse_reads sub-GenObjects\n                    sample.sampled_reads[depth][read_pair].forward_reads = GenObject()\n                    sample.sampled_reads[depth][read_pair].reverse_reads = GenObject()\n                    sample.sampled_reads[depth][read_pair].trimmed_dir = \\\n                        os.path.join(sample.sampled_reads.trimmed_dir,\n                                     read_pair)\n                    make_path(sample.sampled_reads[depth][read_pair].trimmed_dir)\n                    # Extract the forward and reverse reads lengths from the read_pair variable\n                    sample.sampled_reads[depth][read_pair].forward_reads.length, \\\n                        sample.sampled_reads[depth][read_pair].reverse_reads.length = read_pair.split('_')\n                    logging.info('Performing quality trimming on reads from sample {name} at depth {depth} '\n                                 'for minimum read length {forward}'\n                                 .format(name=sample.name,\n                                         depth=depth,\n                                         forward=sample.sampled_reads[depth][read_pair].forward_reads.length))\n                    # Set the attributes for the trimmed forward and reverse reads to use for subsampling\n                    sample.sampled_reads[depth][read_pair].trimmed_forwardfastq = \\\n                        os.path.join(sample.sampled_reads[depth][read_pair].trimmed_dir,\n                                     '{name}_{length}_R1.fastq.gz'\n                                     .format(name=sample.name,\n                                             length=sample.sampled_reads[depth][read_pair].forward_reads.length))\n                    sample.sampled_reads[depth][read_pair].trimmed_reversefastq = \\\n                        os.path.join(sample.sampled_reads[depth][read_pair].trimmed_dir,\n                                     '{name}_{length}_R2.fastq.gz'\n                                     .format(name=sample.name,\n                                             length=sample.sampled_reads[depth][read_pair].forward_reads.length))\n                    # Create the trimmed output directory attribute\n                    sample.sampled_reads[depth][read_pair].sampled_trimmed_outputdir \\\n                        = os.path.join(sample.sampled_reads[depth][read_pair].outputdir,\n                                       'sampled_trimmed')\n                    # Set the name of the forward trimmed reads - include the depth and read length information\n                    # This is set now, as the untrimmed files will be removed, and a check is necessary\n                    sample.sampled_reads[depth][read_pair].forward_reads.trimmed_sampled_fastq = \\\n                        os.path.join(sample.sampled_reads[depth][read_pair].sampled_trimmed_outputdir,\n                                     '{name}_sampled_{depth}_{read_pair}_R1.fastq.gz'\n                                     .format(name=sample.name,\n                                             depth=depth,\n                                             read_pair=read_pair))\n                    # Reverse reads\n                    sample.sampled_reads[depth][read_pair].reverse_reads.trimmed_sampled_fastq = \\\n                        os.path.join(sample.sampled_reads[depth][read_pair].sampled_trimmed_outputdir,\n                                     '{name}_sampled_{depth}_{read_pair}_R2.fastq.gz'\n                                     .format(name=sample.name,\n                                             depth=depth,\n                                             read_pair=read_pair))\n                    # Sample if the forward output file does not already exist\n                    if not os.path.isfile(sample.sampled_reads[depth][read_pair].trimmed_forwardfastq) and \\\n                            not os.path.isfile(\n                                sample.sampled_reads[depth][read_pair].forward_reads.trimmed_sampled_fastq):\n                        out, \\\n                            err, \\\n                            sample.sampled_reads[depth][read_pair].sample_cmd = \\\n                            bbtools.bbduk_trim(forward_in=sample.forward_fastq,\n                                               forward_out=sample.sampled_reads[depth][read_pair]\n                                               .trimmed_forwardfastq,\n                                               reverse_in=sample.reverse_fastq,\n                                               reverse_out=sample.sampled_reads[depth][read_pair]\n                                               .trimmed_reversefastq,\n                                               minlength=sample.sampled_reads[depth][read_pair]\n                                               .forward_reads.length,\n                                               forcetrimleft=0,\n                                               returncmd=True,\n                                               **{'ziplevel': '9',\n                                                  'Xmx': self.mem})\n            # Update the JSON file\n            self.write_json(sample)", "response": "Perform quality trim and toss reads below appropriate thresholds"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsample reads from corresponding FASTQ files for appropriate forward and reverse lengths and sequencing depths.", "response": "def sample_reads(self):\n        \"\"\"\n        For each PacBio assembly, sample reads from corresponding FASTQ files for appropriate forward and reverse\n        lengths and sequencing depths using reformat.sh from the bbtools suite\n        \"\"\"\n        logging.info('Read sampling')\n        for sample in self.metadata:\n            # Iterate through all the desired depths of coverage\n            for depth in self.read_depths:\n                for read_pair in self.read_lengths:\n                    # Set the name of the output directory\n                    sample.sampled_reads[depth][read_pair].sampled_outputdir \\\n                        = os.path.join(sample.sampled_reads[depth][read_pair].outputdir, 'sampled')\n                    # Set the name of the forward reads - include the depth and read length information\n                    sample.sampled_reads[depth][read_pair].forward_reads.fastq = \\\n                        os.path.join(sample.sampled_reads[depth][read_pair].sampled_outputdir,\n                                     '{name}_{depth}_{read_pair}_R1.fastq.gz'\n                                     .format(name=sample.name,\n                                             depth=depth,\n                                             read_pair=read_pair))\n                    # Reverse reads\n                    sample.sampled_reads[depth][read_pair].reverse_reads.fastq = \\\n                        os.path.join(sample.sampled_reads[depth][read_pair].sampled_outputdir,\n                                     '{name}_{depth}_{read_pair}_R2.fastq.gz'\n                                     .format(name=sample.name,\n                                             depth=depth,\n                                             read_pair=read_pair))\n                    logging.info(\n                        'Sampling {num_reads} paired reads for sample {name} with the following parameters:\\n'\n                        'depth {dp}, forward reads {fl}bp, and reverse reads {rl}bp'\n                        .format(num_reads=sample.simulated_reads[depth][read_pair].num_reads,\n                                dp=depth,\n                                name=sample.name,\n                                fl=sample.sampled_reads[depth][read_pair].forward_reads.length,\n                                rl=sample.sampled_reads[depth][read_pair].reverse_reads.length))\n                    # Use the reformat method in the OLCTools bbtools wrapper\n                    # Note that upsample=t is used to ensure that the target number of reads (samplereadstarget) is met\n                    if not os.path.isfile(sample.sampled_reads[depth][read_pair].forward_reads.trimmed_sampled_fastq):\n                        out, \\\n                            err, \\\n                            sample.sampled_reads[depth][read_pair].sample_call = bbtools \\\n                            .reformat_reads(forward_in=sample.sampled_reads[depth][read_pair].trimmed_forwardfastq,\n                                            reverse_in=sample.sampled_reads[depth][read_pair].trimmed_reversefastq,\n                                            forward_out=sample.sampled_reads[depth][read_pair].forward_reads.fastq,\n                                            reverse_out=sample.sampled_reads[depth][read_pair].reverse_reads.fastq,\n                                            returncmd=True,\n                                            **{'samplereadstarget': sample.simulated_reads[depth][read_pair].num_reads,\n                                               'upsample': 't',\n                                               'minlength':\n                                                   sample.sampled_reads[depth][read_pair].forward_reads.length,\n                                               'ziplevel': '9',\n                                               'tossbrokenreads': 't',\n                                               'tossjunk': 't',\n                                               'Xmx': self.mem\n                                               }\n                                            )\n                    # # Remove the trimmed reads, as they are no longer necessary\n                    # try:\n                    #     os.remove(sample.sampled_reads[depth][read_pair].trimmed_forwardfastq)\n                    #     os.remove(sample.sampled_reads[depth][read_pair].trimmed_reversefastq)\n                    # except FileNotFoundError:\n                    #     pass\n            # Update the JSON file\n            self.write_json(sample)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef link_reads(self, analysistype):\n        logging.info('Linking {at} reads'.format(at=analysistype))\n        for sample in self.metadata:\n            # Create the output directories\n            genesippr_dir = os.path.join(self.path, 'genesippr', sample.name)\n            sample.genesippr_dir = genesippr_dir\n            make_path(genesippr_dir)\n            cowbat_dir = os.path.join(self.path, 'cowbat', sample.name)\n            sample.cowbat_dir = cowbat_dir\n            make_path(cowbat_dir)\n            # Iterate through all the desired depths of coverage\n            for depth in self.read_depths:\n                for read_pair in self.read_lengths:\n                    # Create variables using the analysis type. These will be used in setting GenObject attributes\n                    read_type = '{at}_reads'.format(at=analysistype)\n                    fastq_type = 'trimmed_{at}_fastq'.format(at=analysistype)\n                    # Link reads to both output directories\n                    for output_dir in [genesippr_dir, cowbat_dir]:\n                        # If the original reads are shorter than the specified read length, the FASTQ files will exist,\n                        # but will be empty. Do not create links for these files\n                        size = os.path.getsize(sample[read_type][depth][read_pair].forward_reads[fastq_type])\n                        if size > 20:\n                            # Create relative symlinks to the FASTQ files - use the relative path from the desired\n                            # output directory to the read storage path e.g.\n                            # ../../2013-SEQ-0072/simulated/40/50_150/simulated_trimmed/2013-SEQ-0072_simulated_40_50_150_R1.fastq.gz\n                            # is the relative path to the output_dir. The link name is the base name of the reads\n                            # joined to the desired output directory e.g.\n                            # output_dir/2013-SEQ-0072/2013-SEQ-0072_simulated_40_50_150_R1.fastq.gz\n                            relative_symlink(sample[read_type][depth][read_pair].forward_reads[fastq_type],\n                                             output_dir)\n                            # Original FASTQ files\n                            relative_symlink(sample.forward_fastq,\n                                             output_dir)\n                            relative_symlink(sample.reverse_fastq,\n                                             output_dir)\n                        # Reverse reads\n                        try:\n                            size = os.path.getsize(sample[read_type][depth][read_pair].reverse_reads[fastq_type])\n                            if size > 20:\n                                relative_symlink(sample[read_type][depth][read_pair].reverse_reads[fastq_type],\n                                                 output_dir)\n                        except FileNotFoundError:\n                            pass", "response": "Create the necessary directories to link the reads to the output directories"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns GeneSippr on each of the samples in the current directory.", "response": "def run_genesippr(self):\n        \"\"\"\n        Run GeneSippr on each of the samples\n        \"\"\"\n        from pathlib import Path\n        home = str(Path.home())\n        logging.info('GeneSippr')\n        # These unfortunate hard coded paths appear to be necessary\n        miniconda_path = os.path.join(home, 'miniconda3')\n        miniconda_path = miniconda_path if os.path.isdir(miniconda_path) else os.path.join(home, 'miniconda')\n        logging.debug(miniconda_path)\n        activate = 'source {mp}/bin/activate {mp}/envs/sipprverse'.format(mp=miniconda_path)\n        sippr_path = '{mp}/envs/sipprverse/bin/sippr.py'.format(mp=miniconda_path)\n        for sample in self.metadata:\n            logging.info(sample.name)\n\n            # Run the pipeline. Check to make sure that the serosippr report, which is created last doesn't exist\n            if not os.path.isfile(os.path.join(sample.genesippr_dir, 'reports', 'genesippr.csv')):\n                cmd = 'python {py_path} -o {outpath} -s {seqpath} -r {refpath} -F'\\\n                    .format(py_path=sippr_path,\n                            outpath=sample.genesippr_dir,\n                            seqpath=sample.genesippr_dir,\n                            refpath=self.referencefilepath\n                            )\n                logging.critical(cmd)\n                # Create another shell script to execute within the PlasmidExtractor conda environment\n                template = \"#!/bin/bash\\n{activate} && {cmd}\".format(activate=activate,\n                                                                     cmd=cmd)\n                genesippr_script = os.path.join(sample.genesippr_dir, 'run_genesippr.sh')\n                with open(genesippr_script, 'w+') as file:\n                    file.write(template)\n                # Modify the permissions of the script to allow it to be run on the node\n                self.make_executable(genesippr_script)\n                # Run shell script\n                os.system('/bin/bash {}'.format(genesippr_script))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the logging level of this logger.", "response": "def set_level(self, level):\n        \"\"\"\n        Set the logging level of this logger.\n\n        :param level: must be an int or a str.\n        \"\"\"\n        for handler in self.__coloredlogs_handlers:\n            handler.setLevel(level=level)\n\n        self.logger.setLevel(level=level)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndisables all logging calls.", "response": "def disable_logger(self, disabled=True):\n        \"\"\"\n        Disable all logging calls.\n        \"\"\"\n        # Disable standard IO streams\n        if disabled:\n            sys.stdout = _original_stdout\n            sys.stderr = _original_stderr\n        else:\n            sys.stdout = self.__stdout_stream\n            sys.stderr = self.__stderr_stream\n\n        # Disable handlers\n        self.logger.disabled = disabled"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef redirect_stdout(self, enabled=True, log_level=logging.INFO):\n        if enabled:\n            if self.__stdout_wrapper:\n                self.__stdout_wrapper.update_log_level(log_level=log_level)\n            else:\n                self.__stdout_wrapper = StdOutWrapper(logger=self, log_level=log_level)\n\n            self.__stdout_stream = self.__stdout_wrapper\n        else:\n            self.__stdout_stream = _original_stdout\n\n        # Assign the new stream to sys.stdout\n        sys.stdout = self.__stdout_stream", "response": "Redirect sys. stdout to file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef redirect_stderr(self, enabled=True, log_level=logging.ERROR):\n        if enabled:\n            if self.__stderr_wrapper:\n                self.__stderr_wrapper.update_log_level(log_level=log_level)\n            else:\n                self.__stderr_wrapper = StdErrWrapper(logger=self, log_level=log_level)\n\n            self.__stderr_stream = self.__stderr_wrapper\n        else:\n            self.__stderr_stream = _original_stderr\n\n        # Assign the new stream to sys.stderr\n        sys.stderr = self.__stderr_stream", "response": "Redirect sys. stderr to file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef use_file(self, enabled=True,\n                 file_name=None,\n                 level=logging.WARNING,\n                 when='d',\n                 interval=1,\n                 backup_count=30,\n                 delay=False,\n                 utc=False,\n                 at_time=None,\n                 log_format=None,\n                 date_format=None):\n        \"\"\"\n        Handler for logging to a file, rotating the log file at certain timed intervals.\n        \"\"\"\n        if enabled:\n            if not self.__file_handler:\n                assert file_name, 'File name is missing!'\n\n                # Create new TimedRotatingFileHandler instance\n                kwargs = {\n                    'filename': file_name,\n                    'when': when,\n                    'interval': interval,\n                    'backupCount': backup_count,\n                    'encoding': 'UTF-8',\n                    'delay': delay,\n                    'utc': utc,\n                }\n\n                if sys.version_info[0] >= 3:\n                    kwargs['atTime'] = at_time\n\n                self.__file_handler = TimedRotatingFileHandler(**kwargs)\n\n                # Use this format for default case\n                if not log_format:\n                    log_format = '%(asctime)s %(name)s[%(process)d] ' \\\n                                 '%(programname)s/%(module)s/%(funcName)s[%(lineno)d] ' \\\n                                 '%(levelname)s %(message)s'\n\n                # Set formatter\n                formatter = logging.Formatter(fmt=log_format, datefmt=date_format)\n                self.__file_handler.setFormatter(fmt=formatter)\n\n                # Set level for this handler\n                self.__file_handler.setLevel(level=level)\n\n                # Add this handler to logger\n                self.add_handler(hdlr=self.__file_handler)\n        elif self.__file_handler:\n            # Remove handler from logger\n            self.remove_handler(hdlr=self.__file_handler)\n            self.__file_handler = None", "response": "Set the logging level and time for a file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nenabling handler for sending the record to Loggly service.", "response": "def use_loggly(self, enabled=True,\n                   loggly_token=None,\n                   loggly_tag=None,\n                   level=logging.WARNING,\n                   log_format=None,\n                   date_format=None):\n        \"\"\"\n        Enable handler for sending the record to Loggly service.\n        \"\"\"\n        if enabled:\n            if not self.__loggly_handler:\n                assert loggly_token, 'Loggly token is missing!'\n\n                # Use logger name for default Loggly tag\n                if not loggly_tag:\n                    loggly_tag = self.name\n\n                # Create new LogglyHandler instance\n                self.__loggly_handler = LogglyHandler(token=loggly_token, tag=loggly_tag)\n\n                # Use this format for default case\n                if not log_format:\n                    log_format = '{\"name\":\"%(name)s\",\"process\":\"%(process)d\",' \\\n                                 '\"levelname\":\"%(levelname)s\",\"time\":\"%(asctime)s\",' \\\n                                 '\"filename\":\"%(filename)s\",\"programname\":\"%(programname)s\",' \\\n                                 '\"module\":\"%(module)s\",\"funcName\":\"%(funcName)s\",' \\\n                                 '\"lineno\":\"%(lineno)d\",\"message\":\"%(message)s\"}'\n\n                # Set formatter\n                formatter = logging.Formatter(fmt=log_format, datefmt=date_format)\n                self.__loggly_handler.setFormatter(fmt=formatter)\n\n                # Set level for this handler\n                self.__loggly_handler.setLevel(level=level)\n\n                # Add this handler to logger\n                self.add_handler(hdlr=self.__loggly_handler)\n        elif self.__loggly_handler:\n            # Remove handler from logger\n            self.remove_handler(hdlr=self.__loggly_handler)\n            self.__loggly_handler = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __find_caller(stack_info=False):\n        frame = logging.currentframe()\n        # On some versions of IronPython, currentframe() returns None if\n        # IronPython isn't run with -X:Frames.\n        if frame:\n            frame = frame.f_back\n\n        caller_info = '(unknown file)', 0, '(unknown function)', None\n\n        while hasattr(frame, 'f_code'):\n            co = frame.f_code\n            if _logone_src in os.path.normcase(co.co_filename):\n                frame = frame.f_back\n                continue\n\n            tb_info = None\n            if stack_info:\n                with StringIO() as _buffer:\n                    _buffer.write('Traceback (most recent call last):\\n')\n                    traceback.print_stack(frame, file=_buffer)\n                    tb_info = _buffer.getvalue().strip()\n\n            caller_info = co.co_filename, frame.f_lineno, co.co_name, tb_info\n            break\n        return caller_info", "response": "Find the caller name so that we can note the source file name line number and function name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlogs a message at the specified severity level.", "response": "def _log(self, level, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with the integer severity 'level'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.log(level, \"We have a %s\", \"mysterious problem\", exc_info=1)\n        \"\"\"\n        if not isinstance(level, int):\n            if logging.raiseExceptions:\n                raise TypeError('Level must be an integer!')\n            else:\n                return\n\n        if self.logger.isEnabledFor(level=level):\n            \"\"\"\n            Low-level logging routine which creates a LogRecord and then calls\n            all the handlers of this logger to handle the record.\n            \"\"\"\n            exc_info = kwargs.get('exc_info', None)\n            extra = kwargs.get('extra', None)\n            stack_info = kwargs.get('stack_info', False)\n            record_filter = kwargs.get('record_filter', None)\n\n            tb_info = None\n            if _logone_src:\n                # IronPython doesn't track Python frames, so findCaller raises an\n                # exception on some versions of IronPython. We trap it here so that\n                # IronPython can use logging.\n                try:\n                    fn, lno, func, tb_info = self.__find_caller(stack_info=stack_info)\n                except ValueError:  # pragma: no cover\n                    fn, lno, func = '(unknown file)', 0, '(unknown function)'\n            else:  # pragma: no cover\n                fn, lno, func = '(unknown file)', 0, '(unknown function)'\n\n            if exc_info:\n                if sys.version_info[0] >= 3:\n                    if isinstance(exc_info, BaseException):\n                        # noinspection PyUnresolvedReferences\n                        exc_info = type(exc_info), exc_info, exc_info.__traceback__\n                    elif not isinstance(exc_info, tuple):\n                        exc_info = sys.exc_info()\n                else:\n                    if not isinstance(exc_info, tuple):\n                        exc_info = sys.exc_info()\n\n            if sys.version_info[0] >= 3:\n                # noinspection PyArgumentList\n                record = self.logger.makeRecord(self.name, level, fn, lno, msg, args,\n                                                exc_info, func, extra, tb_info)\n            else:\n                record = self.logger.makeRecord(self.name, level, fn, lno, msg, args,\n                                                exc_info, func, extra)\n\n            if record_filter:\n                record = record_filter(record)\n\n            self.logger.handle(record=record)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nflushing the buffer to the log if applicable.", "response": "def flush(self):\n        \"\"\"\n        Flush the buffer, if applicable.\n        \"\"\"\n        if self.__buffer.tell() > 0:\n            # Write the buffer to log\n            # noinspection PyProtectedMember\n            self.__logger._log(level=self.__log_level, msg=self.__buffer.getvalue().strip(),\n                               record_filter=StdErrWrapper.__filter_record)\n            # Remove the old buffer\n            self.__buffer.truncate(0)\n            self.__buffer.seek(0)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsyllabifying the given word whether simplex or complex.", "response": "def syllabify(word):\n    '''Syllabify the given word, whether simplex or complex.'''\n    compound = bool(re.search(r'(-| |=)', word))\n    syllabify = _syllabify_compound if compound else _syllabify\n    syllabifications = list(syllabify(word))\n\n    for syll, rules in syllabifications:\n        yield syll, rules\n\n    n = 16 - len(syllabifications)\n\n    # yield empty syllabifications and rules\n    for i in range(n):\n        yield '', ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef apply_T4(word):\n    '''An agglutination diphthong that ends in /u, y/ optionally contains a\n    syllable boundary when -C# or -CCV follow, e.g., [lau.ka.us],\n    [va.ka.ut.taa].'''\n    WORD = word.split('.')\n    PARTS = [[] for part in range(len(WORD))]\n\n    for i, v in enumerate(WORD):\n\n        # i % 2 != 0 prevents this rule from applying to first, third, etc.\n        # syllables, which receive stress (WSP)\n        if is_consonant(v[-1]) and i % 2 != 0:\n            if i + 1 == len(WORD) or is_consonant(WORD[i + 1][0]):\n                vv = u_y_final_diphthongs(v)\n\n                if vv:\n                    I = vv.start(1) + 1\n                    PARTS[i].append(v[:I] + '.' + v[I:])\n\n        # include original form (non-application of rule)\n        PARTS[i].append(v)\n\n    WORDS = [w for w in product(*PARTS)]\n\n    for WORD in WORDS:\n        WORD = '.'.join(WORD)\n        RULE = ' T4' if word != WORD else ''\n\n        yield WORD, RULE", "response": "A generator function that applies T4 to a word."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nuse contextstring if request_id is set otherwise default.", "response": "def format(self, record):\n        \"\"\"Uses contextstring if request_id is set, otherwise default.\"\"\"\n        # NOTE(sdague): default the fancier formating params\n        # to an empty string so we don't throw an exception if\n        # they get used\n        for key in ('instance', 'color'):\n            if key not in record.__dict__:\n                record.__dict__[key] = ''\n\n        if record.__dict__.get('request_id', None):\n            self._fmt = CONF.logging_context_format_string\n        else:\n            self._fmt = CONF.logging_default_format_string\n\n        if (record.levelno == logging.DEBUG and\n                CONF.logging_debug_format_suffix):\n            self._fmt += \" \" + CONF.logging_debug_format_suffix\n\n        # Cache this on the record, Logger will respect our formated copy\n        if record.exc_info:\n            record.exc_text = self.formatException(record.exc_info, record)\n        return logging.Formatter.format(self, record)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nformat exception output with CONF. logging_exception_prefix.", "response": "def formatException(self, exc_info, record=None):\n        \"\"\"Format exception output with CONF.logging_exception_prefix.\"\"\"\n        if not record:\n            return logging.Formatter.formatException(self, exc_info)\n\n        stringbuffer = cStringIO.StringIO()\n        traceback.print_exception(exc_info[0], exc_info[1], exc_info[2],\n                                  None, stringbuffer)\n        lines = stringbuffer.getvalue().split('\\n')\n        stringbuffer.close()\n\n        if CONF.logging_exception_prefix.find('%(asctime)') != -1:\n            record.asctime = self.formatTime(record, self.datefmt)\n\n        formatted_lines = []\n        for line in lines:\n            pl = CONF.logging_exception_prefix % record.__dict__\n            fl = '%s%s' % (pl, line)\n            formatted_lines.append(fl)\n        return '\\n'.join(formatted_lines)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_boutons_interface(self, buttons):\n        for id_action, f, d, is_active in buttons:\n            icon = self.get_icon(id_action)\n            action = self.addAction(QIcon(icon), d)\n            action.setEnabled(is_active)\n            action.triggered.connect(f)", "response": "Display buttons given by the list of tuples id function description is_active"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd update toolbar callback to the interface", "response": "def set_interface(self, interface):\n        \"\"\"Add update toolbar callback to the interface\"\"\"\n        self.interface = interface\n        self.interface.callbacks.update_toolbar = self._update\n        self._update()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the display of button after querying data from interface", "response": "def _update(self):\n        \"\"\"Update the display of button after querying data from interface\"\"\"\n        self.clear()\n        self._set_boutons_communs()\n        if self.interface:\n            self.addSeparator()\n            l_actions = self.interface.get_actions_toolbar()\n            self._set_boutons_interface(l_actions)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init_login(self, from_local=False):\n        if self.toolbar:\n            self.removeToolBar(self.toolbar)\n        widget_login = login.Loading(self.statusBar(), self.theory_main)\n        self.centralWidget().addWidget(widget_login)\n        widget_login.loaded.connect(self.init_tabs)\n        widget_login.canceled.connect(self._quit)\n        widget_login.updated.connect(self.on_update_at_launch)\n        if from_local:\n            widget_login.propose_load_local()\n        else:\n            self.statusBar().showMessage(\"Donn\u00e9es charg\u00e9es depuis le serveur.\", 5000)", "response": "Display login screen. May ask for local data loading if from_local is True."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_response(self, status, content_type, response):\n        headers = [('Access-Control-Allow-Origin', '*'),\n                   ('Access-Control-Allow-Methods', 'GET, POST, OPTIONS'),\n                   ('Access-Control-Allow-Headers', 'Content-Type'),\n                   ('Access-Control-Max-Age', '86400'),\n                   ('Content-type', content_type)\n                  ]\n        self.start_response(status, headers)\n        return [response.encode()]", "response": "Shortcut for making a response to the client s request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract the request feeds the module and returns the response.", "response": "def on_post(self):\n        \"\"\"Extracts the request, feeds the module, and returns the response.\"\"\"\n        request = self.environ['wsgi.input']\n        try:\n            return self.process_request(request)\n        except ClientError as exc:\n            return self.on_client_error(exc)\n        except BadGateway as exc:\n            return self.on_bad_gateway(exc)\n        except InvalidConfig:\n            raise\n        except Exception as exc: # pragma: no cover # pylint: disable=W0703\n            logging.error('Unknown exception: ', exc_info=exc)\n            return self.on_internal_error()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dispatch(self):\n        method_name = 'on_' + self.environ['REQUEST_METHOD'].lower()\n        method = getattr(self, method_name, None)\n        if method:\n            return method()\n        else:\n            return self.on_bad_method()", "response": "Handles dispatching of the request."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clone_data( self, source ):\n        klass = self.__class__\n        assert isinstance( source, klass )\n\n        for name in klass._fields:\n            self._field_data[name] = getattr( source, name )", "response": "Clone data from another Block instance to copy from."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef import_data( self, raw_buffer ):\n        klass = self.__class__\n        if raw_buffer:\n            assert common.is_bytes( raw_buffer )\n#            raw_buffer = memoryview( raw_buffer )\n\n        self._field_data = {}\n\n        for name in klass._fields:\n            if raw_buffer:\n                self._field_data[name] = klass._fields[name].get_from_buffer(\n                    raw_buffer, parent=self\n                )\n            else:\n                self._field_data[name] = klass._fields[name].default\n        \n        if raw_buffer:\n            for name, check in klass._checks.items():\n                check.check_buffer( raw_buffer, parent=self )\n\n            # if we have debug logging on, check the roundtrip works\n            if logger.isEnabledFor( logging.INFO ):\n                test = self.export_data()\n                if logger.getEffectiveLevel() <= logging.DEBUG:\n                    logger.debug( 'Stats for {}:'.format( self ) )\n                    logger.debug( 'Import buffer size: {}'.format( len( raw_buffer ) ) )\n                    logger.debug( 'Export size: {}'.format( len( test ) ) )\n                    if test == raw_buffer:\n                        logger.debug( 'Content: exact match!' )\n                    elif test == raw_buffer[:len( test )]:\n                        logger.debug( 'Content: partial match!' )\n                    else:\n                        logger.debug( 'Content: different!' )\n                        for x in utils.hexdump_diff_iter( raw_buffer[:len( test )], test ):\n                            logger.debug( x )\n                elif test != raw_buffer[:len( test )]:\n                    logger.info( '{} export produced changed output from import'.format( self ) )\n\n#        if raw_buffer:\n#            raw_buffer.release()\n        return", "response": "Import data from a byte array."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef export_data( self ):\n        klass = self.__class__\n\n        output = bytearray( b'\\x00'*self.get_size() )\n\n        # prevalidate all data before export.\n        # this is important to ensure that any dependent fields\n        # are updated beforehand, e.g. a count referenced\n        # in a BlockField\n        queue = []\n        for name in klass._fields:\n            self.scrub_field( name )\n            self.validate_field( name )\n\n        self.update_deps()\n\n        for name in klass._fields:\n            klass._fields[name].update_buffer_with_value(\n                self._field_data[name], output, parent=self\n            )\n\n        for name, check in klass._checks.items():\n            check.update_buffer( output, parent=self )\n        return output", "response": "Export data to a byte array."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates dependencies on all the fields on this Block instance.", "response": "def update_deps( self ):\n        \"\"\"Update dependencies on all the fields on this Block instance.\"\"\"\n        klass = self.__class__\n\n        for name in klass._fields:\n            self.update_deps_on_field( name )\n        return"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvalidate all the fields on this Block instance.", "response": "def validate( self ):\n        \"\"\"Validate all the fields on this Block instance.\"\"\"\n        klass = self.__class__\n\n        for name in klass._fields:\n            self.validate_field( name )\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the projected size of the exported data from this Block instance.", "response": "def get_size( self ):\n        \"\"\"Get the projected size (in bytes) of the exported data from this Block instance.\"\"\"\n        klass = self.__class__\n        size = 0\n        for name in klass._fields:\n            size = max( size, klass._fields[name].get_end_offset( self._field_data[name], parent=self ) )\n        for check in klass._checks.values():\n            size = max( size, check.get_end_offset( parent=self ) )\n        return size"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save(self, path, compressed=True, exist_ok=False):\n        path = os.path.expandvars(os.path.expanduser(path))\n        if os.path.isfile(path) and not exist_ok:\n            raise OSError(17, os.strerror(17), path)\n\n        if os.path.isdir(path):\n            path = os.path.join(path, \"out.gdg\")\n\n        if compressed:\n            bytes_written = cgaddag.gdg_save_compressed(self.gdg, path.encode(\"ascii\"))\n        else:\n            bytes_written = cgaddag.gdg_save(self.gdg, path.encode(\"ascii\"))\n\n        if bytes_written == -1:\n            errno = ctypes.c_int.in_dll(ctypes.pythonapi, \"errno\").value\n            raise OSError(errno, os.strerror(errno), path)\n\n        return bytes_written", "response": "Save the GADDAG to a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads a GADDAG from file and replace the words currently in this GADDAG with the words currently in the GADDAG.", "response": "def load(self, path):\n        \"\"\"\n        Load a GADDAG from file, replacing the words currently in this GADDAG.\n\n        Args:\n            path: path to saved GADDAG to be loaded.\n        \"\"\"\n        path = os.path.expandvars(os.path.expanduser(path))\n\n        gdg = cgaddag.gdg_load(path.encode(\"ascii\"))\n        if not gdg:\n            errno = ctypes.c_int.in_dll(ctypes.pythonapi, \"errno\").value\n            raise OSError(errno, os.strerror(errno), path)\n\n        self.__del__()\n        self.gdg = gdg.contents"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind all words starting with a prefix.", "response": "def starts_with(self, prefix):\n        \"\"\"\n        Find all words starting with a prefix.\n\n        Args:\n            prefix: A prefix to be searched for.\n\n        Returns:\n            A list of all words found.\n        \"\"\"\n        prefix = prefix.lower()\n        found_words = []\n\n        res = cgaddag.gdg_starts_with(self.gdg, prefix.encode(encoding=\"ascii\"))\n        tmp = res\n\n        while tmp:\n            word = tmp.contents.str.decode(\"ascii\")\n            found_words.append(word)\n            tmp = tmp.contents.next\n\n        cgaddag.gdg_destroy_result(res)\n        return found_words"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef contains(self, sub):\n        sub = sub.lower()\n        found_words = set()\n\n        res = cgaddag.gdg_contains(self.gdg, sub.encode(encoding=\"ascii\"))\n        tmp = res\n\n        while tmp:\n            word = tmp.contents.str.decode(\"ascii\")\n            found_words.add(word)\n            tmp = tmp.contents.next\n\n        cgaddag.gdg_destroy_result(res)\n        return list(found_words)", "response": "Find all words containing a substring."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ends_with(self, suffix):\n        suffix = suffix.lower()\n        found_words = []\n\n        res = cgaddag.gdg_ends_with(self.gdg, suffix.encode(encoding=\"ascii\"))\n        tmp = res\n\n        while tmp:\n            word = tmp.contents.str.decode(\"ascii\")\n            found_words.append(word)\n            tmp = tmp.contents.next\n\n        cgaddag.gdg_destroy_result(res)\n        return found_words", "response": "Find all words ending with a suffix."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a word to the GADDAG.", "response": "def add_word(self, word):\n        \"\"\"\n        Add a word to the GADDAG.\n\n        Args:\n            word: A word to be added to the GADDAG.\n        \"\"\"\n        word = word.lower()\n\n        if not (word.isascii() and word.isalpha()):\n            raise ValueError(\"Invalid character in word '{}'\".format(word))\n\n        word = word.encode(encoding=\"ascii\")\n        result = cgaddag.gdg_add_word(self.gdg, word)\n        if result == 1:\n            raise ValueError(\"Invalid character in word '{}'\".format(word))\n        elif result == 2:\n            raise MemoryError(\"Out of memory, GADDAG is in an undefined state\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef formatLog(source=\"\", level=\"\", title=\"\", data={}):\n  # consistently output empty string for unset params, because null values differ by language\n  source = \"\" if source is None else source\n  level = \"\" if level is None else level\n  title = \"\" if title is None else title\n  \n  if not type(data) is dict:\n    data = {}\n  data['source'] = source\n  data['level'] = level\n  data['title'] = title\n\n  return format(data)", "response": "Format a log message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef put(self):\n        return self.manager.put(\n            id=self.id,\n            name=self.name,\n            description=self.description,\n            command_to_run=self.command_to_run,\n            environment_variables=self.environment_variables,\n            required_arguments=self.required_arguments,\n            required_arguments_default_values=(\n                self.required_arguments_default_values\n            ),\n            logs_path=self.logs_path,\n            results_path=self.results_path,\n            container_image=self.container_image,\n            container_type=self.container_type,\n        )", "response": "Updates this task type on the saltant server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(\n        self,\n        name,\n        command_to_run,\n        container_image,\n        container_type,\n        description=\"\",\n        logs_path=\"\",\n        results_path=\"\",\n        environment_variables=None,\n        required_arguments=None,\n        required_arguments_default_values=None,\n        extra_data_to_post=None,\n    ):\n        \"\"\"Create a container task type.\n\n        Args:\n            name (str): The name of the task.\n            command_to_run (str): The command to run to execute the task.\n            container_image (str): The container name and tag. For\n                example, ubuntu:14.04 for Docker; and docker://ubuntu:14:04\n                or shub://vsoch/hello-world for Singularity.\n            container_type (str): The type of the container.\n            description (str, optional): The description of the task type.\n            logs_path (str, optional): The path of the logs directory\n                inside the container.\n            results_path (str, optional): The path of the results\n                directory inside the container.\n            environment_variables (list, optional): The environment\n                variables required on the host to execute the task.\n            required_arguments (list, optional): The argument names for\n                the task type.\n            required_arguments_default_values (dict, optional): Default\n                values for the task's required arguments.\n            extra_data_to_post (dict, optional): Extra key-value pairs\n                to add to the request data. This is useful for\n                subclasses which require extra parameters.\n\n        Returns:\n            :class:`saltant.models.container_task_type.ContainerTaskType`:\n                A container task type model instance representing the\n                task type just created.\n        \"\"\"\n        # Add in extra data specific to container task types\n        if extra_data_to_post is None:\n            extra_data_to_post = {}\n\n        extra_data_to_post.update(\n            {\n                \"container_image\": container_image,\n                \"container_type\": container_type,\n                \"logs_path\": logs_path,\n                \"results_path\": results_path,\n            }\n        )\n\n        # Call the parent create function\n        return super(ContainerTaskTypeManager, self).create(\n            name=name,\n            command_to_run=command_to_run,\n            description=description,\n            environment_variables=environment_variables,\n            required_arguments=required_arguments,\n            required_arguments_default_values=required_arguments_default_values,\n            extra_data_to_post=extra_data_to_post,\n        )", "response": "Creates a new container task type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef put(\n        self,\n        id,\n        name,\n        description,\n        command_to_run,\n        environment_variables,\n        required_arguments,\n        required_arguments_default_values,\n        logs_path,\n        results_path,\n        container_image,\n        container_type,\n        extra_data_to_put=None,\n    ):\n        \"\"\"Updates a task type on the saltant server.\n\n        Args:\n            id (int): The ID of the task type.\n            name (str): The name of the task type.\n            description (str): The description of the task type.\n            command_to_run (str): The command to run to execute the task.\n            environment_variables (list): The environment variables\n                required on the host to execute the task.\n            required_arguments (list): The argument names for the task type.\n            required_arguments_default_values (dict): Default values for\n                the tasks required arguments.\n            extra_data_to_put (dict, optional): Extra key-value pairs to\n                add to the request data. This is useful for subclasses\n                which require extra parameters.\n            logs_path (str): The path of the logs directory inside the\n                container.\n            results_path (str): The path of the results directory inside\n                the container.\n            container_image (str): The container name and tag. For\n                example, ubuntu:14.04 for Docker; and docker://ubuntu:14:04\n                or shub://vsoch/hello-world for Singularity.\n            container_type (str): The type of the container.\n        \"\"\"\n        # Add in extra data specific to container task types\n        if extra_data_to_put is None:\n            extra_data_to_put = {}\n\n        extra_data_to_put.update(\n            {\n                \"logs_path\": logs_path,\n                \"results_path\": results_path,\n                \"container_image\": container_image,\n                \"container_type\": container_type,\n            }\n        )\n\n        # Call the parent create function\n        return super(ContainerTaskTypeManager, self).put(\n            id=id,\n            name=name,\n            description=description,\n            command_to_run=command_to_run,\n            environment_variables=environment_variables,\n            required_arguments=required_arguments,\n            required_arguments_default_values=(\n                required_arguments_default_values\n            ),\n            extra_data_to_put=extra_data_to_put,\n        )", "response": "Updates a task type on the saltant server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _strtobool(val):\n    val = val.lower()\n    if val in ('y', 'yes', 't', 'true', 'on', '1'):\n        return 1\n    elif val in ('n', 'no', 'f', 'false', 'off', '0', ''):\n        return 0\n    else:\n        raise ValueError('Invalid truth value: {0}'.format(val))", "response": "Convert a string representation of truth to true or false ( 0."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _str_to_list(value, separator):\n    value_list = [item.strip() for item in value.split(separator)]\n    value_list_sanitized = builtins.list(filter(None, value_list))\n    if len(value_list_sanitized) > 0:\n        return value_list_sanitized\n    else:\n        raise ValueError('Invalid list variable.')", "response": "Convert a string to a list with sanitization."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites a raw env value. A None value clears the environment variable.", "response": "def write(name, value):\n    \"\"\"Write a raw env value.\n\n    A ``None`` value clears the environment variable.\n\n    Args:\n        name: The environment variable name\n        value: The value to write\n    \"\"\"\n    if value is not None:\n        environ[name] = builtins.str(value)\n    elif environ.get(name):\n        del environ[name]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read(name, default=None, allow_none=False, fallback=None):\n    raw_value = environ.get(name)\n    if raw_value is None and fallback is not None:\n        if not isinstance(fallback, builtins.list) and not isinstance(fallback, builtins.tuple):\n            fallback = [fallback]\n\n        for fall in fallback:\n            raw_value = environ.get(fall)\n            if raw_value is not None:\n                break\n\n    if raw_value or raw_value == '':\n        return raw_value\n    elif default is not None or allow_none:\n        return default\n    else:\n        raise KeyError('Set the \"{0}\" environment variable'.format(name))", "response": "Reads the raw env value."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a string based environment variable value or the default.", "response": "def str(name, default=None, allow_none=False, fallback=None):\n    \"\"\"Get a string based environment value or the default.\n\n    Args:\n        name: The environment variable name\n        default: The default value to use if no environment variable is found\n        allow_none: If the return value can be `None` (i.e. optional)\n    \"\"\"\n    value = read(name, default, allow_none, fallback=fallback)\n    if value is None and allow_none:\n        return None\n    else:\n        return builtins.str(value).strip()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bool(name, default=None, allow_none=False, fallback=None):\n    value = read(name, default, allow_none, fallback=fallback)\n    if isinstance(value, builtins.bool):\n        return value\n    elif isinstance(value, builtins.int):\n        return True if value > 0 else False\n    elif value is None and allow_none:\n        return None\n    else:\n        value_str = builtins.str(value).lower().strip()\n        return _strtobool(value_str)", "response": "Get a boolean based environment variable value or the default."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a string environment variable value or the default.", "response": "def int(name, default=None, allow_none=False, fallback=None):\n    \"\"\"Get a string environment value or the default.\n\n    Args:\n        name: The environment variable name\n        default: The default value to use if no environment variable is found\n        allow_none: If the return value can be `None` (i.e. optional)\n    \"\"\"\n    value = read(name, default, allow_none, fallback=fallback)\n    if isinstance(value, builtins.str):\n        value = value.strip()\n\n    if value is None and allow_none:\n        return None\n    else:\n        return builtins.int(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a list of strings or the default.", "response": "def list(name, default=None, allow_none=False, fallback=None, separator=','):\n    \"\"\"Get a list of strings or the default.\n\n    The individual list elements are whitespace-stripped.\n\n    Args:\n        name: The environment variable name\n        default: The default value to use if no environment variable is found\n        allow_none: If the return value can be `None` (i.e. optional)\n        separator: The list item separator character or pattern\n    \"\"\"\n    value = read(name, default, allow_none, fallback=fallback)\n    if isinstance(value, builtins.list):\n        return value\n    elif isinstance(value, builtins.str):\n        return _str_to_list(value, separator)\n    elif value is None and allow_none:\n        return None\n    else:\n        return [builtins.str(value)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef includeme(config):\n    config.add_route('references', '/references')\n    _add_referencer(config.registry)\n    config.add_view_deriver(protected_resources.protected_view)\n    config.add_renderer('json_item', json_renderer)\n    config.scan()", "response": "this function adds some configuration for the application"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding the Referencer to the registry.", "response": "def _add_referencer(registry):\n    \"\"\"\n    Gets the Referencer from config and adds it to the registry.\n    \"\"\"\n    referencer = registry.queryUtility(IReferencer)\n    if referencer is not None:\n        return referencer\n    ref = registry.settings['urireferencer.referencer']\n    url = registry.settings['urireferencer.registry_url']\n    r = DottedNameResolver()\n    registry.registerUtility(r.resolve(ref)(url), IReferencer)\n    return registry.queryUtility(IReferencer)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_referencer(registry):\n    # Argument might be a config or request\n    regis = getattr(registry, 'registry', None)\n    if regis is None:\n        regis = registry\n    return regis.queryUtility(IReferencer)", "response": "Get the referencer class"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconnecting to AWS EC2", "response": "def _connect_to_ec2(region, credentials):\n    \"\"\"\n    :param region: The region of AWS to connect to.\n    :param EC2Credentials credentials: The credentials to use to authenticate\n        with EC2.\n\n    :return: a connection object to AWS EC2\n    \"\"\"\n    conn = boto.ec2.connect_to_region(\n        region,\n        aws_access_key_id=credentials.access_key_id,\n        aws_secret_access_key=credentials.secret_access_key\n    )\n    if conn:\n        return conn\n    else:\n        log_red('Failure to authenticate to EC2.')\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting the contents of the record to the table.", "response": "def write(self, *args, **kwargs):\n        \"\"\"\n        :param args: tuple(value, style), tuple(value, style)\n        :param kwargs: header=tuple(value, style), header=tuple(value, style)\n        :param args: value, value\n        :param kwargs: header=value, header=value\n        \"\"\"\n\n        if args:\n            kwargs = dict(zip(self.header, args))\n        for header in kwargs:\n            cell = kwargs[header]\n            if not isinstance(cell, tuple):\n                cell = (cell,)\n            self.write_cell(self._row, self.header.index(header), *cell)\n        self._row += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clear_layout(layout: QLayout) -> None:\n    if layout is not None:\n        while layout.count():\n            item = layout.takeAt(0)\n            widget = item.widget()\n            if widget is not None:\n                widget.deleteLater()\n            else:\n                clear_layout(item.layout())", "response": "Clear the layout off all its components"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _load_hangul_syllable_types():\n    filename = \"HangulSyllableType.txt\"\n    current_dir = os.path.abspath(os.path.dirname(__file__))\n    with codecs.open(os.path.join(current_dir, filename), mode=\"r\", encoding=\"utf-8\") as fp:\n        for line in fp:\n            if not line.strip() or line.startswith(\"#\"):\n                continue  # Skip empty lines or lines that are comments (comments start with '#')\n            data = line.strip().split(\";\")\n            syllable_type, _ = map(six.text_type.strip, data[1].split(\"#\"))\n            if \"..\" in data[0]:  # If it is a range and not a single value\n                start, end = map(lambda x: int(x, 16), data[0].strip().split(\"..\"))\n                for idx in range(start, end + 1):\n                    _hangul_syllable_types[idx] = syllable_type\n            else:\n                _hangul_syllable_types[int(data[0].strip(), 16)] = syllable_type", "response": "Loads the Hangul syllable types from the Unicode Character Database."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions for parsing the Jamo short names from the Unicode Character Database and generating a lookup table", "response": "def _load_jamo_short_names():\n    \"\"\"\n    Function for parsing the Jamo short names from the Unicode Character Database (UCD) and generating a lookup table\n    For more info on how this is used, see the Unicode Standard, ch. 03, section 3.12, \"Conjoining Jamo Behavior\" and\n    ch. 04, section 4.8, \"Name\".\n\n    https://www.unicode.org/versions/latest/ch03.pdf\n    https://www.unicode.org/versions/latest/ch04.pdf\n    \"\"\"\n    filename = \"Jamo.txt\"\n    current_dir = os.path.abspath(os.path.dirname(__file__))\n    with codecs.open(os.path.join(current_dir, filename), mode=\"r\", encoding=\"utf-8\") as fp:\n        for line in fp:\n            if not line.strip() or line.startswith(\"#\"):\n                continue  # Skip empty lines or lines that are comments (comments start with '#')\n            data = line.strip().split(\";\")\n            code = int(data[0].strip(), 16)\n            char_info = data[1].split(\"#\")\n            short_name = char_info[0].strip()\n            _jamo_short_names[code] = short_name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_hangul_syllable_type(hangul_syllable):\n    if not _is_hangul_syllable(hangul_syllable):\n        raise ValueError(\"Value 0x%0.4x does not represent a Hangul syllable!\" % hangul_syllable)\n    if not _hangul_syllable_types:\n        _load_hangul_syllable_types()\n    return _hangul_syllable_types[hangul_syllable]", "response": "Function for taking a Unicode scalar value representing a Hangul syllable and determining the correct value for its\n    Hangul_Syllable_Type property."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfunction for taking a Unicode scalar value representing a Jamo and determining the correct value for its Jamo_Short_Name property.", "response": "def _get_jamo_short_name(jamo):\n    \"\"\"\n    Function for taking a Unicode scalar value representing a Jamo and determining the correct value for its\n    Jamo_Short_Name property.  For more information on the Jamo_Short_Name property see the Unicode Standard,\n    ch. 03, section 3.12, Conjoining Jamo Behavior.\n\n    https://www.unicode.org/versions/latest/ch03.pdf\n\n    :param jamo: Unicode scalar value representing a Jamo\n    :return: Returns a string representing its Jamo_Short_Name property\n    \"\"\"\n    if not _is_jamo(jamo):\n        raise ValueError(\"Value 0x%0.4x passed in does not represent a Jamo!\" % jamo)\n    if not _jamo_short_names:\n        _load_jamo_short_names()\n    return _jamo_short_names[jamo]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compose_hangul_syllable(jamo):\n    fmt_str_invalid_sequence = \"{0} does not represent a valid sequence of Jamo!\"\n    if len(jamo) == 3:\n        l_part, v_part, t_part = jamo\n        if not (l_part in range(0x1100, 0x1112 + 1) and\n                v_part in range(0x1161, 0x1175 + 1) and\n                t_part in range(0x11a8, 0x11c2 + 1)):\n            raise ValueError(fmt_str_invalid_sequence.format(jamo))\n        l_index = l_part - L_BASE\n        v_index = v_part - V_BASE\n        t_index = t_part - T_BASE\n        lv_index = l_index * N_COUNT + v_index * T_COUNT\n        return S_BASE + lv_index + t_index\n    elif len(jamo) == 2:\n        if jamo[0] in range(0x1100, 0x1112 + 1) and jamo[1] in range(0x1161, 0x1175 + 1):\n            l_part, v_part = jamo\n            l_index = l_part - L_BASE\n            v_index = v_part - V_BASE\n            lv_index = l_index * N_COUNT + v_index * T_COUNT\n            return S_BASE + lv_index\n        elif _get_hangul_syllable_type(jamo[0]) == \"LV\" and jamo[1] in range(0x11a8, 0x11c2 + 1):\n            lv_part, t_part = jamo\n            t_index = t_part - T_BASE\n            return lv_part + t_index\n        else:\n            raise ValueError(fmt_str_invalid_sequence.format(jamo))\n    else:\n        raise ValueError(fmt_str_invalid_sequence.format(jamo))", "response": "Function for taking a tuple or list of Unicode scalar values representing Jamo and composing it into a Hangul syllable."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction for decomposing a Unicode scalar value representing a Hangul syllable into a tuple of Unicode scalar values l_part v_part t_part.", "response": "def decompose_hangul_syllable(hangul_syllable, fully_decompose=False):\n    \"\"\"\n    Function for taking a Unicode scalar value representing a Hangul syllable and decomposing it into a tuple\n    representing the scalar values of the decomposed (canonical decomposition) Jamo.  If the Unicode scalar value\n    passed in is not in the range of Hangul syllable values (as defined in UnicodeData.txt), a ValueError will be\n    raised.\n\n    The algorithm for doing the decomposition is described in the Unicode Standard, ch. 03, section 3.12,\n    \"Conjoining Jamo Behavior\".\n\n    Example: U+D4DB -> (U+D4CC, U+11B6)  # (canonical decomposition, default)\n             U+D4DB -> (U+1111, U+1171, U+11B6)  # (full canonical decomposition)\n\n    :param hangul_syllable: Unicode scalar value for Hangul syllable\n    :param fully_decompose: Boolean indicating whether or not to do a canonical decomposition (default behavior is\n                            fully_decompose=False) or a full canonical decomposition (fully_decompose=True)\n    :return: Tuple of Unicode scalar values for the decomposed Jamo.\n    \"\"\"\n    if not _is_hangul_syllable(hangul_syllable):\n        raise ValueError(\"Value passed in does not represent a Hangul syllable!\")\n    s_index = hangul_syllable - S_BASE\n\n    if fully_decompose:\n        l_index = s_index // N_COUNT\n        v_index = (s_index % N_COUNT) // T_COUNT\n        t_index = s_index % T_COUNT\n        l_part = L_BASE + l_index\n        v_part = V_BASE + v_index\n        t_part = (T_BASE + t_index) if t_index > 0 else None\n        return l_part, v_part, t_part\n    else:\n        if _get_hangul_syllable_type(hangul_syllable) == \"LV\":  # Hangul_Syllable_Type = LV\n            l_index = s_index // N_COUNT\n            v_index = (s_index % N_COUNT) // T_COUNT\n            l_part = L_BASE + l_index\n            v_part = V_BASE + v_index\n            return l_part, v_part\n        else:  # Assume Hangul_Syllable_Type = LVT\n            lv_index = (s_index // T_COUNT) * T_COUNT\n            t_index = s_index % T_COUNT\n            lv_part = S_BASE + lv_index\n            t_part = T_BASE + t_index\n            return lv_part, t_part"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning for converting a Unicode scalar value representing a Hangul syllable to its syllable name as transformed according to the Unicode naming rule NR1.", "response": "def _get_hangul_syllable_name(hangul_syllable):\n    \"\"\"\n    Function for taking a Unicode scalar value representing a Hangul syllable and converting it to its syllable name as\n    defined by the Unicode naming rule NR1.  See the Unicode Standard, ch. 04, section 4.8, Names, for more information.\n\n    :param hangul_syllable: Unicode scalar value representing the Hangul syllable to convert\n    :return: String representing its syllable name as transformed according to naming rule NR1.\n    \"\"\"\n    if not _is_hangul_syllable(hangul_syllable):\n        raise ValueError(\"Value passed in does not represent a Hangul syllable!\")\n    jamo = decompose_hangul_syllable(hangul_syllable, fully_decompose=True)\n    result = ''\n    for j in jamo:\n        if j is not None:\n            result += _get_jamo_short_name(j)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_client_callers(spec, timeout, error_callback, local, app):\n\n    callers_dict = {}\n\n    def mycallback(endpoint):\n        if not endpoint.handler_client:\n            return\n\n        callers_dict[endpoint.handler_client] = _generate_client_caller(spec, endpoint, timeout, error_callback, local, app)\n\n    spec.call_on_each_endpoint(mycallback)\n\n    return callers_dict", "response": "Generate a dict mapping method names to anonymous functions that will call the server s endpoint of the corresponding name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall the requests_method method and retry up to max_attempts times.", "response": "def _call_retry(self, force_retry):\n        \"\"\"Call request and retry up to max_attempts times (or none if self.max_attempts=1)\"\"\"\n        last_exception = None\n        for i in range(self.max_attempts):\n            try:\n                log.info(\"Calling %s %s\" % (self.method, self.url))\n                response = self.requests_method(\n                    self.url,\n                    data=self.data,\n                    params=self.params,\n                    headers=self.headers,\n                    timeout=(self.connect_timeout, self.read_timeout),\n                    verify=self.verify_ssl,\n                )\n\n                if response is None:\n                    log.warn(\"Got response None\")\n                    if self._method_is_safe_to_retry():\n                        delay = 0.5 + i * 0.5\n                        log.info(\"Waiting %s sec and Retrying since call is a %s\" % (delay, self.method))\n                        time.sleep(delay)\n                        continue\n                    else:\n                        raise PyMacaronCoreException(\"Call %s %s returned empty response\" % (self.method, self.url))\n\n                return response\n\n            except Exception as e:\n\n                last_exception = e\n\n                retry = force_retry\n\n                if isinstance(e, ReadTimeout):\n                    # Log enough to help debugging...\n                    log.warn(\"Got a ReadTimeout calling %s %s\" % (self.method, self.url))\n                    log.warn(\"Exception was: %s\" % str(e))\n                    resp = e.response\n                    if not resp:\n                        log.info(\"Requests error has no response.\")\n                        # TODO: retry=True? Is it really safe?\n                    else:\n                        b = resp.content\n                        log.info(\"Requests has a response with content: \" + pprint.pformat(b))\n                    if self._method_is_safe_to_retry():\n                        # It is safe to retry\n                        log.info(\"Retrying since call is a %s\" % self.method)\n                        retry = True\n\n                elif isinstance(e, ConnectTimeout):\n                    log.warn(\"Got a ConnectTimeout calling %s %s\" % (self.method, self.url))\n                    log.warn(\"Exception was: %s\" % str(e))\n                    # ConnectTimeouts are safe to retry whatever the call...\n                    retry = True\n\n                if retry:\n                    continue\n                else:\n                    raise e\n\n        # max_attempts has been reached: propagate the last received Exception\n        if not last_exception:\n            last_exception = Exception(\"Reached max-attempts (%s). Giving up calling %s %s\" % (self.max_attempts, self.method, self.url))\n        raise last_exception"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef syllabify(word):\n    '''Syllabify the given word, whether simplex or complex.'''\n    word = split(word)  # detect any non-delimited compounds\n    compound = True if re.search(r'-| |\\.', word) else False\n    syllabify = _syllabify_compound if compound else _syllabify\n    syll, rules = syllabify(word)\n\n    yield syll, rules\n\n    n = 3\n\n    if 'T4' in rules:\n        yield syllabify(word, T4=False)\n        n -= 1\n\n    # yield empty syllabifications and rules\n    for n in range(3):\n        yield '', ''", "response": "Syllabify the given word whether simplex or complex."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _syllabify(word, T4=True):\n    '''Syllabify the given word.'''\n    word = replace_umlauts(word)\n    word, rules = apply_T1(word)\n\n    if re.search(r'[^ieAyOauo]*([ieAyOauo]{2})[^ieAyOauo]*', word):\n        word, T2 = apply_T2(word)\n        word, T8 = apply_T8(word)\n        word, T9 = apply_T9(word)\n        word, T4 = apply_T4(word) if T4 else (word, '')\n        rules += T2 + T8 + T9 + T4\n\n    if re.search(r'[ieAyOauo]{3}', word):\n        word, T6 = apply_T6(word)\n        word, T5 = apply_T5(word)\n        word, T7 = apply_T7(word)\n        word, T2 = apply_T2(word)\n        rules += T5 + T6 + T7 + T2\n\n    word = replace_umlauts(word, put_back=True)\n    rules = rules or ' T0'  # T0 means no rules have applied\n\n    return word, rules", "response": "Syllabify the given word."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef apply_T1(word):\n    '''There is a syllable boundary in front of every CV-sequence.'''\n    # split consonants and vowels: 'balloon' -> ['b', 'a', 'll', 'oo', 'n']\n    WORD = [w for w in re.split('([ieAyOauo]+)', word) if w]\n    count = 0\n\n    for i, v in enumerate(WORD):\n\n        if i == 0 and is_consonant(v[0]):\n            continue\n\n        elif is_consonant(v[0]) and i + 1 != len(WORD):\n            if is_cluster(v):  # WSP\n                if count % 2 == 0:\n                    WORD[i] = v[0] + '.' + v[1:]  # CC > C.C, CCC > C.CC\n\n                else:\n                    WORD[i] = '.' + v  # CC > .CC, CCC > .CCC\n\n            # elif is_sonorant(v[0]) and is_cluster(v[1:]):  # NEW\n            #     if count % 2 == 0:\n            #         WORD[i] = v[0:2] + '.' + v[2:]\n\n            #     else:\n            #         WORD[i] = v[0] + '.' + v[1:]\n\n            else:\n                WORD[i] = v[:-1] + '.' + v[-1]  # CC > C.C, CCC > CC.C\n\n            count += 1\n\n    WORD = ''.join(WORD)\n    RULE = ' T1' if word != WORD else ''\n\n    return WORD, RULE", "response": "This function applies T1 to every CV - sequence."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the alignment of the given template and the given query into an extended cigar.", "response": "def extended_cigar(aligned_template, aligned_query):\n   ''' Convert mutation annotations to extended cigar format\n   \n   https://github.com/lh3/minimap2#the-cs-optional-tag\n   \n   USAGE:\n      >>> template = 'CGATCGATAAATAGAGTAG---GAATAGCA'\n      >>> query = 'CGATCG---AATAGAGTAGGTCGAATtGCA'\n      >>> extended_cigar(template, query) == ':6-ata:10+gtc:4*at:3'\n      True\n   '''\n   #   - Go through each position in the alignment\n   insertion = []\n   deletion = []\n   matches = []\n   cigar = []\n   for r_aa, q_aa in zip(aligned_template.lower(), aligned_query.lower()):\n      gap_ref = r_aa == '-'\n      gap_que = q_aa == '-'\n      match = r_aa == q_aa\n      if matches and not match:\n         # End match block\n         cigar.append(\":%s\"%len(matches))\n         matches = []\n      if insertion and not gap_ref:\n         # End insertion\n         cigar.append(\"+%s\"%''.join(insertion))\n         insertion = []\n      elif deletion and not gap_que:\n         # End deletion\n         cigar.append(\"-%s\"%''.join(deletion))\n         deletion = []\n      if gap_ref:\n         if insertion:\n            # Extend insertion\n            insertion.append(q_aa)\n         else:\n            # Start insertion\n            insertion = [q_aa]\n      elif gap_que:\n         if deletion:\n            # Extend deletion\n            deletion.append(r_aa)\n         else:\n            # Start deletion\n            deletion = [r_aa]\n      elif match:\n         if matches:\n            # Extend match block\n            matches.append(r_aa)\n         else:\n            # Start match block\n            matches = [r_aa]\n      else:\n         # Add SNP annotation\n         cigar.append(\"*%s%s\"%(r_aa, q_aa))\n   \n   if matches:\n      cigar.append(\":%s\"%len(matches))\n      del matches\n   if insertion:\n      # End insertion\n      cigar.append(\"+%s\"%''.join(insertion))\n      del insertion\n   elif deletion:\n      # End deletion\n      cigar.append(\"-%s\"%''.join(deletion))\n      del deletion\n   \n   return ''.join(cigar)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cigar2query(template, cigar):\n   ''' Generate query sequence from the template and extended cigar annotation\n   \n   USAGE:\n      >>> template = 'CGATCGATAAATAGAGTAGGAATAGCA'\n      >>> cigar = ':6-ata:10+gtc:4*at:3'\n      >>> cigar2query(template, cigar) == 'CGATCGAATAGAGTAGGTCGAATtGCA'.upper()\n      True\n   '''\n   query = []\n   entries = ['+','-','*',':']\n   number = list(map(str,range(10)))\n   cigar_length = len(cigar)\n   num = []\n   entry = None\n   pos = 0\n   i = 0\n   while i < cigar_length:\n      if cigar[i] in entries:\n         # New entry\n         if entry == ':':\n            old_pos = pos\n            pos += int(''.join(num))\n            query.append(template[old_pos:pos])\n            num = []\n         entry = cigar[i]\n         if entry == '*':\n            i += 2\n            query.append(cigar[i])\n            pos += 1\n      elif cigar[i] in number:\n         num.append(cigar[i])\n      elif entry == '-':\n         pos += 1\n      elif entry == '+':\n         query.append(cigar[i])\n      i += 1\n   \n   if entry == ':':\n      old_pos = pos\n      pos += int(''.join(num))\n      query.append(template[old_pos:pos])\n   \n   return ''.join(query).upper()", "response": "Generates a query sequence from the template and extended cigar annotation."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nblasts wrapper method that takes a simple input and produces a overview list of the hits to templates and their alignments.", "response": "def Blaster(inputfile, databases, db_path, out_path='.', min_cov=0.6,\n            threshold=0.9, blast='blastn', cut_off=True):\n   ''' BLAST wrapper method, that takes a simple input and produces a overview\n   list of the hits to templates, and their alignments\n   \n   Usage\n      >>> import os, subprocess, collections\n      >>> from Bio.Blast import NCBIXML\n      >>> from Bio import SeqIO\n      >>> from string import maketrans\n      >>> inputfile = 'test.fsa'\n      >>> databases = ['enterobacteriaceae']\n      >>> db_path   = '/path/to/databases/plasmidfinder/'\n      >>> Blaster(inputfile, databases, db_path)\n   '''\n   min_cov = 100 * float(min_cov)\n   threshold = 100 * float(threshold)\n   \n   # For alignment\n   gene_align_query = dict() #will contain the sequence alignment lines\n   gene_align_homo = dict()  #will contain the sequence alignment homolog string\n   gene_align_sbjct = dict() #will contain the sequence alignment allele string\n   results = dict()          #will contain the results\n   \n   for db in databases:\n      # Adding the path to the database and output\n      db_file = \"%s/%s.fsa\"%(db_path, db)\n      os.system(\"mkdir -p %s/tmp\"%(out_path))\n      os.system(\"chmod 775 %s/tmp\"%(out_path))\n      out_file = \"%s/tmp/out_%s.xml\"%(out_path, db)\n      \n      # Running blast\n      cmd = \"%s -subject %s -query %s -out %s -outfmt '5' -perc_identity %s -dust 'no'\"%(blast, db_file, inputfile, out_file, threshold)\n      process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n      out, err = process.communicate()\n      \n      # Getting the results\n      result_handle = open(out_file)\n      blast_records = NCBIXML.parse(result_handle)\n      \n      # Declaring variables for saving the results\n      gene_results = dict() #will contain the results for each gene\n      \n      # For finding the best hits\n      best_hsp = dict()\n      \n      # Keeping track of gene split\n      gene_split = collections.defaultdict(dict)\n      \n      # Making the dicts for sequence outputs\n      gene_align_query[db] = dict()\n      gene_align_homo[db] = dict()\n      gene_align_sbjct[db] = dict()\n      \n      # Parsing over the hits and only keeping the best\n      for blast_record in blast_records:\n         query = blast_record.query\n         blast_record.alignments.sort(key = lambda align: -max((len(hsp.query) * (int(hsp.identities)/float(len(hsp.query))) for hsp in align.hsps)))\n         for alignment in blast_record.alignments:\n            # Setting the e-value as 1 and bit as 0 to get the best HSP fragment\n            best_e_value = 1\n            best_bit = 0\n            for hsp in alignment.hsps:\n               if hsp.expect < best_e_value or hsp.bits > best_bit:\n                  best_e_value = hsp.expect\n                  best_bit = hsp.bits\n                  tmp = alignment.title.split(\" \")\n                  sbjct_header = tmp[1]\n                  bit = hsp.bits\n                  sbjct_length = alignment.length\n                  sbjct_start = hsp.sbjct_start\n                  sbjct_end = hsp.sbjct_end\n                  gaps = hsp.gaps\n                  query_string = str(hsp.query)\n                  homo_string = str(hsp.match)\n                  sbjct_string = str(hsp.sbjct)\n                  contig_name = query.replace(\">\",\"\")\n                  query_start = hsp.query_start\n                  query_end = hsp.query_end\n                  HSP_length = len(query_string)\n                  perc_ident = int(hsp.identities)/float(HSP_length) * 100\n                  strand = 0\n                  coverage = ((int(HSP_length) - int(gaps))/float(sbjct_length))\n                  perc_coverage = ((int(HSP_length) - int(gaps))/float(sbjct_length)) * 100\n                  if int(HSP_length) == int(sbjct_length):\n                     cal_score = perc_ident * coverage * 100\n                  else:\n                     cal_score = perc_ident * coverage\n                  hit_id = \"%s:%s..%s:%s:%f\"%(contig_name, query_start, query_end, sbjct_header, cal_score)\n                  \n                  # If the hit is on the other strand\n                  if sbjct_start > sbjct_end:\n                     tmp = sbjct_start\n                     sbjct_start = sbjct_end\n                     sbjct_end = tmp\n                     \n                     query_string = reverse_complement(query_string)\n                     homo_string = homo_string[::-1]\n                     sbjct_string = reverse_complement(sbjct_string)\n                     strand = 1\n                  \n                  if cut_off == True:\n                     if perc_coverage > 20 :\n                        best_hsp = {'evalue': hsp.expect, 'sbjct_header': sbjct_header, 'bit': bit,\n                                    'perc_ident': perc_ident, 'sbjct_length':sbjct_length,\n                                    'sbjct_start': sbjct_start, 'sbjct_end': sbjct_end,\n                                    'gaps': gaps, 'query_string': query_string,\n                                    'homo_string': homo_string, 'sbjct_string': sbjct_string,\n                                    'contig_name': contig_name, 'query_start': query_start,\n                                    'query_end': query_end, 'HSP_length': HSP_length, 'coverage': coverage,\n                                    'cal_score': cal_score, 'hit_id': hit_id, 'strand': strand,\n                                    'perc_coverage': perc_coverage\n                                    }\n                  else:\n                     best_hsp = {'evalue': hsp.expect, 'sbjct_header': sbjct_header, 'bit': bit,\n                                    'perc_ident': perc_ident, 'sbjct_length':sbjct_length,\n                                    'sbjct_start': sbjct_start, 'sbjct_end': sbjct_end,\n                                    'gaps': gaps, 'query_string': query_string,\n                                    'homo_string': homo_string, 'sbjct_string': sbjct_string,\n                                    'contig_name': contig_name, 'query_start': query_start,\n                                    'query_end': query_end, 'HSP_length': HSP_length, 'coverage': coverage,\n                                    'cal_score': cal_score, 'hit_id': hit_id, 'strand': strand,\n                                    'perc_coverage': perc_coverage\n                                    }\n            \n            # Saving the result if any\n            if best_hsp:\n               save = 1\n               \n               # If there are other gene alignments they are compared\n               if gene_results:\n                  tmp_gene_split = gene_split\n                  tmp_results = gene_results\n                  \n                  # Compare the hit results\n                  save, gene_split, gene_results = compare_results(save, best_hsp, tmp_results, tmp_gene_split)\n               \n               # If the hit is not overlapping with other hit seqeunces it is kept\n               if save == 1:\n                  gene_results[hit_id] = best_hsp\n            else:\n               pass\n      \n      # If the hit does not cover the entire database reference the missing seqence data are extracted\n      for hit_id in list(gene_results):\n         hit = gene_results[hit_id]\n         \n         # Calculate possible split gene coverage\n         perc_coverage = hit['perc_coverage']\n         \n         if hit['sbjct_header'] in gene_split and len(gene_split[hit['sbjct_header']]) > 1:\n            # Calculate new length\n            new_length = calculate_new_length(gene_split, gene_results, hit)\n            hit['split_length'] = new_length\n            \n            # Calculate new coverage\n            perc_coverage = new_length / float(hit['sbjct_length']) * 100\n         \n         # If the hit is above the minimum length threshold it is kept\n         if perc_coverage >= min_cov:\n            if hit['coverage'] == 1:\n               gene_align_query[db][hit_id] = hit['query_string']\n               gene_align_homo[db][hit_id] = hit['homo_string']\n               gene_align_sbjct[db][hit_id] = hit['sbjct_string']\n            elif hit['coverage'] != 1:\n               # Getting the whole database sequence\n               for seq_record in SeqIO.parse(db_file, \"fasta\"):\n                  if seq_record.description == hit['sbjct_header']:\n                     gene_align_sbjct[db][hit_id] = str(seq_record.seq)\n                     break\n               \n               # Getting the whole contig to extract extra query seqeunce\n               contig = ''\n               for seq_record in SeqIO.parse(inputfile, \"fasta\"):\n                  if seq_record.description == hit['contig_name']:\n                     contig = str(seq_record.seq)\n                     break\n               \n               # Extract extra sequence from query\n               query_seq, homo_seq = get_query_align(hit, contig)\n               \n               # Saving the new alignment sequences\n               gene_align_query[db][hit_id] = query_seq\n               gene_align_homo[db][hit_id] = homo_seq\n         \n         else:\n            del gene_results[hit_id]\n            if hit['sbjct_header'] in gene_split:\n               del gene_split[hit['sbjct_header']]\n      \n      # Save the database result\n      if gene_results:\n         results[db] = gene_results\n      else:\n         results[db] = \"No hit found\"\n   return (results, gene_align_query, gene_align_homo, gene_align_sbjct)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef compare_results(save, best_hsp, tmp_results, tmp_gene_split):\n   ''' Function for comparing hits and saving only the best hit '''\n   # Get data for comparison\n   hit_id = best_hsp['hit_id']\n   new_start_query = best_hsp['query_start']\n   new_end_query = best_hsp['query_end']\n   new_start_sbjct = int(best_hsp['sbjct_start'])\n   new_end_sbjct = int(best_hsp['sbjct_end'])\n   new_score = best_hsp['cal_score']\n   new_db_hit = best_hsp['sbjct_header']\n   new_contig = best_hsp['contig_name']\n   new_HSP = best_hsp['HSP_length']\n   \n   # See if the best HSP fragment overlap with another allignment and keep the\n   # allignment with the highest score - if the new fragment is not providing new seqeunce\n   for hit in list(tmp_results):\n      hit_data = tmp_results[hit]\n      old_start_query = hit_data['query_start']\n      old_end_query = hit_data['query_end']\n      old_start_sbjct = int(hit_data['sbjct_start'])\n      old_end_sbjct = int(hit_data['sbjct_end'])\n      old_score = hit_data['cal_score']\n      old_db_hit = hit_data['sbjct_header']\n      old_contig = hit_data['contig_name']\n      old_HSP = hit_data['HSP_length']\n      \n      remove_old = 0\n      \n      # If they align to the same gene in the database they are compared\n      if new_db_hit == old_db_hit:\n         # If the hit provids additional sequence it is kept and the new coverage is saved\n         # otherwise the one with the highest score is kept\n         if new_start_sbjct < (old_start_sbjct) or new_end_sbjct > (old_end_sbjct):\n            # Save the hits as splitted\n            tmp_gene_split[old_db_hit][hit_id] = 1\n            if not hit in tmp_gene_split[old_db_hit]:\n               tmp_gene_split[old_db_hit][hit] = 1\n         else:\n            if new_score > old_score:\n               # Set to remove old hit\n               remove_old = 1\n               \n               # Save a split if the new hit still creats one\n               if new_db_hit in tmp_gene_split and not hit_id in tmp_gene_split[new_db_hit]:\n                  tmp_gene_split[new_db_hit][hit_id] = 1\n            else:\n               save = 0\n               \n               # If the old and new hit is not identical the possible saved gene split for the new hit is removed\n               if hit_id != hit:\n                  if new_db_hit in tmp_gene_split and hit_id in tmp_gene_split[new_db_hit]:\n                     del tmp_gene_split[new_db_hit][hit_id]\n               break\n      \n      # If the hits comes form the same part of the contig sequnce but match different genes only the best hit is kept\n      if new_contig == old_contig:\n         # if the two hits cover the exact same place on the contig only\n         # the percentage of identity is compared\n         if old_start_query == new_start_query and old_end_query == new_end_query:\n            if best_hsp['perc_ident'] > hit_data['perc_ident']:\n               \n               # Set to remove old hit\n               remove_old = 1\n               \n               # Save a split if the new hit still creats one\n               if new_db_hit in tmp_gene_split and not hit_id in tmp_gene_split[new_db_hit]:\n                  tmp_gene_split[new_db_hit][hit_id] = 1\n            \n            elif best_hsp['perc_ident'] == hit_data['perc_ident']:\n               # Save both\n               \n               # Save a split if the new hit still creats one\n               if new_db_hit in tmp_gene_split and not hit_id in tmp_gene_split[new_db_hit]:\n                  tmp_gene_split[new_db_hit][hit_id] = 1\n            else:\n               save = 0\n                # Remove new gene from gene split if present\n               if new_db_hit in tmp_gene_split and hit_id in tmp_gene_split[new_db_hit]:\n                  del tmp_gene_split[new_db_hit][hit_id]\n               break\n         \n         elif (max(old_end_query, new_end_query) - min(old_start_query, new_start_query)) <= ((old_end_query - old_start_query) + (new_end_query - new_start_query)):\n            if new_score > old_score:\n               # Set to remove old gene\n               remove_old = 1\n               \n               # Save a split if the new hit still creats one\n               if new_db_hit in tmp_gene_split and not hit_id in tmp_gene_split[new_db_hit]:\n                  tmp_gene_split[new_db_hit][hit_id] = 1\n            \n            elif new_score == old_score:\n               # If both genes are completly covered the longest hit is chosen\n               if int(best_hsp['perc_coverage']) == 100 and int(hit_data['perc_coverage']) == 100 and new_HSP > old_HSP:\n                  # Set to remove old gene\n                  remove_old = 1\n               \n               # Save a split if the new hit creats one - both hits are saved\n               if new_db_hit in tmp_gene_split and not hit_id in tmp_gene_split[new_db_hit]:\n                  tmp_gene_split[new_db_hit][hit_id] = 1\n            else:\n               # Remove new gene from gene split if present\n               if new_db_hit in tmp_gene_split and hit_id in tmp_gene_split[new_db_hit]:\n                  del tmp_gene_split[new_db_hit][hit_id]\n               \n               save = 0\n               break\n      \n      # Remove old hit if new hit is better\n      if remove_old == 1:\n         del tmp_results[hit]\n         # Remove gene from gene split if present\n         if old_db_hit in tmp_gene_split and hit in tmp_gene_split[old_db_hit]:\n            del tmp_gene_split[old_db_hit][hit]\n   \n   return save, tmp_gene_split, tmp_results", "response": "Function for comparing hits and saving only the best hit"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction for calcualting new length if the gene is split on several contigs", "response": "def calculate_new_length(gene_split, gene_results, hit):\n   ''' Function for calcualting new length if the gene is split on several\n   contigs\n   '''\n   # Looping over splitted hits and calculate new length\n   first = 1\n   for split in gene_split[hit['sbjct_header']]:\n      new_start = int(gene_results[split]['sbjct_start'])\n      new_end = int(gene_results[split]['sbjct_end'])\n      \n      # Get the frist HSP\n      if first == 1:\n         new_length = int(gene_results[split]['HSP_length'])\n         old_start = new_start\n         old_end = new_end\n         first = 0\n         continue\n      if new_start < old_start:\n         new_length = new_length + (old_start - new_start)\n         old_start = new_start\n      \n      if new_end > old_end:\n         new_length = new_length + (new_end - old_end)\n         old_end = new_end\n   \n   return(new_length)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchops a stream of data into MODBUS packets.", "response": "def stream_to_packet(data):\n    \"\"\"\n    Chop a stream of data into MODBUS packets.\n\n    :param data: stream of data\n    :returns: a tuple of the data that is a packet with the remaining\n        data, or ``None``\n    \"\"\"\n    if len(data) < 6:\n        return None\n\n    # unpack the length\n    pktlen = struct.unpack(\">H\", data[4:6])[0] + 6\n    if (len(data) < pktlen):\n        return None\n\n    return (data[:pktlen], data[pktlen:])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a complex object into a primitive object.", "response": "def to_primitive(value, convert_instances=False, convert_datetime=True,\n                 level=0, max_depth=3):\n    \"\"\"Convert a complex object into primitives.\n\n    Handy for JSON serialization. We can optionally handle instances,\n    but since this is a recursive function, we could have cyclical\n    data structures.\n\n    To handle cyclical data structures we could track the actual objects\n    visited in a set, but not all objects are hashable. Instead we just\n    track the depth of the object inspections and don't go too deep.\n\n    Therefore, convert_instances=True is lossy ... be aware.\n\n    \"\"\"\n    # handle obvious types first - order of basic types determined by running\n    # full tests on nova project, resulting in the following counts:\n    # 572754 <type 'NoneType'>\n    # 460353 <type 'int'>\n    # 379632 <type 'unicode'>\n    # 274610 <type 'str'>\n    # 199918 <type 'dict'>\n    # 114200 <type 'datetime.datetime'>\n    #  51817 <type 'bool'>\n    #  26164 <type 'list'>\n    #   6491 <type 'float'>\n    #    283 <type 'tuple'>\n    #     19 <type 'long'>\n    if isinstance(value, _simple_types):\n        return value\n\n    if isinstance(value, datetime.datetime):\n        if convert_datetime:\n            return timeutils.strtime(value)\n        else:\n            return value\n\n    # value of itertools.count doesn't get caught by nasty_type_tests\n    # and results in infinite loop when list(value) is called.\n    if type(value) == itertools.count:\n        return six.text_type(value)\n\n    # FIXME(vish): Workaround for LP bug 852095. Without this workaround,\n    #              tests that raise an exception in a mocked method that\n    #              has a @wrap_exception with a notifier will fail. If\n    #              we up the dependency to 0.5.4 (when it is released) we\n    #              can remove this workaround.\n    if getattr(value, '__module__', None) == 'mox':\n        return 'mock'\n\n    if level > max_depth:\n        return '?'\n\n    # The try block may not be necessary after the class check above,\n    # but just in case ...\n    try:\n        recursive = functools.partial(to_primitive,\n                                      convert_instances=convert_instances,\n                                      convert_datetime=convert_datetime,\n                                      level=level,\n                                      max_depth=max_depth)\n        if isinstance(value, dict):\n            return dict((k, recursive(v)) for k, v in six.iteritems(value))\n        elif isinstance(value, (list, tuple)):\n            return [recursive(lv) for lv in value]\n\n        # It's not clear why xmlrpclib created their own DateTime type, but\n        # for our purposes, make it a datetime type which is explicitly\n        # handled\n        if xmlrpclib and isinstance(value, xmlrpclib.DateTime):\n            value = datetime.datetime(*tuple(value.timetuple())[:6])\n\n        if convert_datetime and isinstance(value, datetime.datetime):\n            return timeutils.strtime(value)\n        elif isinstance(value, gettextutils.Message):\n            return value.data\n        elif hasattr(value, 'iteritems'):\n            return recursive(dict(value.iteritems()), level=level + 1)\n        elif hasattr(value, '__iter__'):\n            return recursive(list(value))\n        elif convert_instances and hasattr(value, '__dict__'):\n            # Likely an instance of something. Watch for cycles.\n            # Ignore class member vars.\n            return recursive(value.__dict__, level=level + 1)\n        elif netaddr and isinstance(value, netaddr.IPAddress):\n            return six.text_type(value)\n        else:\n            if any(test(value) for test in _nasty_type_tests):\n                return six.text_type(value)\n            return value\n    except TypeError:\n        # Class objects are tricky since they may define something like\n        # __iter__ defined but it isn't callable as list().\n        return six.text_type(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the first most vowel in syllll.", "response": "def get_vowel(syll):\n    '''Return the firstmost vowel in 'syll'.'''\n    return re.search(r'([ieaou\u00e4\u00f6y]{1})', syll, flags=FLAGS).group(1).upper()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_light(syll):\n    '''Return True if 'syll' is light.'''\n    return re.match(r'(^|[^ieaou\u00e4\u00f6y]+)[ieaou\u00e4\u00f6y]{1}$', syll, flags=FLAGS)", "response": "Return True if syllll is light."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stress(syllabified_simplex_word):\n    '''Assign primary and secondary stress to 'syllabified_simplex_word'.'''\n    syllables = syllabified_simplex_word.split('.')\n    stressed = '\\'' + syllables[0]  # primary stress\n\n    try:\n        n = 0\n        medial = syllables[1:-1]\n\n        for i, syll in enumerate(medial):\n\n            if (i + n) % 2 == 0:\n                stressed += '.' + syll\n\n            else:\n                try:\n                    if is_light(syll) and is_heavy(medial[i + 1]):\n                        stressed += '.' + syll\n                        n += 1\n                        continue\n\n                except IndexError:\n                    pass\n\n                # secondary stress\n                stressed += '.`' + syll\n\n    except IndexError:\n        pass\n\n    if len(syllables) > 1:\n        stressed += '.' + syllables[-1]\n\n    return stressed", "response": "Assign primary and secondary stress to syllabified_simplex_word."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if word violates sonority sequencing.", "response": "def sonseq(word):\n    '''Return True if 'word' does not violate sonority sequencing.'''\n    parts = re.split(r'([ieaou\u00e4\u00f6y]+)', word, flags=re.I | re.U)\n    onset, coda = parts[0], parts[-1]\n\n    #  simplex onset      Finnish complex onset\n    if len(onset) <= 1 or onset.lower() in ONSETS:\n        #      simplex coda    Finnish complex coda\n        return len(coda) <= 1  # or coda in codas_inventory\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef harmonic(word):\n    '''Return True if the word's vowels agree in frontness/backness.'''\n    depth = {'\u00e4': 0, '\u00f6': 0, 'y': 0, 'a': 1, 'o': 1, 'u': 1}\n    vowels = filter(lambda ch: is_front(ch) or is_back(ch), word)\n    depths = (depth[x.lower()] for x in vowels)\n\n    return len(set(depths)) < 2", "response": "Return True if the word s vowels agree in frontness or backness."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef put(self):\n        return self.manager.put(\n            id=self.id,\n            name=self.name,\n            description=self.description,\n            command_to_run=self.command_to_run,\n            environment_variables=self.environment_variables,\n            required_arguments=self.required_arguments,\n            required_arguments_default_values=(\n                self.required_arguments_default_values\n            ),\n            json_file_option=self.json_file_option,\n        )", "response": "Updates this task type on the saltant server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(\n        self,\n        name,\n        command_to_run,\n        description=\"\",\n        environment_variables=None,\n        required_arguments=None,\n        required_arguments_default_values=None,\n        json_file_option=None,\n        extra_data_to_post=None,\n    ):\n        \"\"\"Create a container task type.\n\n        Args:\n            name (str): The name of the task.\n            command_to_run (str): The command to run to execute the task.\n            description (str, optional): The description of the task type.\n            environment_variables (list, optional): The environment\n                variables required on the host to execute the task.\n            required_arguments (list, optional): The argument names for\n                the task type.\n            required_arguments_default_values (dict, optional): Default\n                values for the task's required arguments.\n            json_file_option (str, optional): The name of a command line\n                option, e.g., --json-file, which accepts a JSON-encoded\n                file for the command to run.\n            extra_data_to_post (dict, optional): Extra key-value pairs\n                to add to the request data. This is useful for\n                subclasses which require extra parameters.\n\n        Returns:\n            :class:`saltant.models.container_task_type.ExecutableTaskType`:\n                An executable task type model instance representing the\n                task type just created.\n        \"\"\"\n        # Add in extra data specific to container task types\n        if extra_data_to_post is None:\n            extra_data_to_post = {}\n\n        extra_data_to_post.update({\"json_file_option\": json_file_option})\n\n        # Call the parent create function\n        return super(ExecutableTaskTypeManager, self).create(\n            name=name,\n            command_to_run=command_to_run,\n            description=description,\n            environment_variables=environment_variables,\n            required_arguments=required_arguments,\n            required_arguments_default_values=required_arguments_default_values,\n            extra_data_to_post=extra_data_to_post,\n        )", "response": "Creates a new instance of the executable task type."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates a task type on the saltant server.", "response": "def put(\n        self,\n        id,\n        name,\n        description,\n        command_to_run,\n        environment_variables,\n        required_arguments,\n        required_arguments_default_values,\n        json_file_option,\n        extra_data_to_put=None,\n    ):\n        \"\"\"Updates a task type on the saltant server.\n\n        Args:\n            id (int): The ID of the task type.\n            name (str): The name of the task type.\n            description (str): The description of the task type.\n            command_to_run (str): The command to run to execute the task.\n            environment_variables (list): The environment variables\n                required on the host to execute the task.\n            required_arguments (list): The argument names for the task type.\n            required_arguments_default_values (dict): Default values for\n                the tasks required arguments.\n            json_file_option (str): The name of a command line option,\n                e.g., --json-file, which accepts a JSON-encoded file for\n                the command to run.\n            extra_data_to_put (dict, optional): Extra key-value pairs to\n                add to the request data. This is useful for subclasses\n                which require extra parameters.\n        \"\"\"\n        # Add in extra data specific to container task types\n        if extra_data_to_put is None:\n            extra_data_to_put = {}\n\n        extra_data_to_put.update({\"json_file_option\": json_file_option})\n\n        # Call the parent create function\n        return super(ExecutableTaskTypeManager, self).put(\n            id=id,\n            name=name,\n            description=description,\n            command_to_run=command_to_run,\n            environment_variables=environment_variables,\n            required_arguments=required_arguments,\n            required_arguments_default_values=(\n                required_arguments_default_values\n            ),\n            extra_data_to_put=extra_data_to_put,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a report of the genesippr results for each sample in the runmetadata object", "response": "def reporter(self, analysistype='genesippr'):\n        \"\"\"\n        Creates a report of the genesippr results\n        :param analysistype: The variable to use when accessing attributes in the metadata object\n        \"\"\"\n        logging.info('Creating {} report'.format(analysistype))\n        # Create a dictionary to link all the genera with their genes\n        genusgenes = dict()\n        # The organism-specific targets are in .tfa files in the target path\n        targetpath = str()\n        for sample in self.runmetadata.samples:\n            if sample.general.bestassemblyfile != 'NA':\n                targetpath = sample[analysistype].targetpath\n        for organismfile in glob(os.path.join(targetpath, '*.tfa')):\n            organism = os.path.splitext(os.path.basename(organismfile))[0]\n            # Use BioPython to extract all the gene names from the file\n            for record in SeqIO.parse(open(organismfile), 'fasta'):\n                # Append the gene names to the genus-specific list\n                try:\n                    genusgenes[organism].add(record.id.split('_')[0])\n                except (KeyError, IndexError):\n                    genusgenes[organism] = set()\n                    genusgenes[organism].add(record.id.split('_')[0])\n        # Determine from which genera the gene hits were sourced\n        for sample in self.runmetadata.samples:\n            # Initialise the list to store the genera\n            sample[analysistype].targetgenera = list()\n            if sample.general.bestassemblyfile != 'NA':\n                for organism in genusgenes:\n                    # Iterate through all the genesippr hits and attribute each gene to the appropriate genus\n                    for gene in sample[analysistype].results:\n                        # If the gene name is in the genes from that organism, add the genus name to the list of\n                        # genera found in the sample\n                        if gene.split('_')[0] in genusgenes[organism]:\n                            if organism not in sample[analysistype].targetgenera:\n                                sample[analysistype].targetgenera.append(organism)\n        # Create the path in which the reports are stored\n        make_path(self.reportpath)\n        # The report will have every gene for all genera in the header\n        header = 'Strain,Genus,{},\\n'.format(','.join(self.genelist))\n        data = str()\n        with open(os.path.join(self.reportpath, analysistype + '.csv'), 'w') as report:\n            for sample in self.runmetadata.samples:\n                sample[analysistype].report_output = list()\n                if sample.general.bestassemblyfile != 'NA':\n                    # Add the genus/genera found in the sample\n                    data += '{},{},'.format(sample.name, ';'.join(sample[analysistype].targetgenera))\n                    best_dict = dict()\n                    if sample[analysistype].results:\n                        gene_check = list()\n                        # Find the best match for all the hits\n                        for target, pid in sample[analysistype].results.items():\n                            gene_name = target.split('_')[0]\n                            for gene in self.genelist:\n                                # If the key matches a gene in the list of genes\n                                if gene == gene_name:\n                                    # If the percent identity is better, update the dictionary\n                                    try:\n                                        if float(pid) > best_dict[gene]:\n                                            best_dict[gene] = float(pid)\n                                    except KeyError:\n                                        best_dict[gene] = float(pid)\n                        for gene in self.genelist:\n                            # If the gene was not found in the sample, print an empty cell in the report\n                            try:\n                                best_dict[gene]\n                            except KeyError:\n                                data += ','\n                            # Print the required information for the gene\n                            for name, identity in sample[analysistype].results.items():\n                                if name.split('_')[0] == gene and gene not in gene_check:\n                                    data += '{pid}%'.format(pid=best_dict[gene])\n                                    try:\n                                        if not sample.general.trimmedcorrectedfastqfiles[0].endswith('.fasta'):\n                                            data += ' ({avgd} +/- {std}),'\\\n                                                .format(avgd=sample[analysistype].avgdepth[name],\n                                                        std=sample[analysistype].standarddev[name])\n                                        else:\n                                            data += ','\n                                    except IndexError:\n                                        data += ','\n                                    gene_check.append(gene)\n                                    # Add the simplified results to the object - used in the assembly pipeline report\n                                    sample[analysistype].report_output.append(gene)\n                        # Add a newline after each sample\n                        data += '\\n'\n                    # Add a newline if the sample did not have any gene hits\n                    else:\n                        data += '\\n'\n            # Write the header and data to file\n            report.write(header)\n            report.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a simplified genus - specific report for each gene in the target genus", "response": "def genusspecific(self, analysistype='genesippr'):\n        \"\"\"\n        Creates simplified genus-specific reports. Instead of the % ID and the fold coverage, a simple +/- scheme is\n        used for presence/absence\n        :param analysistype: The variable to use when accessing attributes in the metadata object\n        \"\"\"\n        # Dictionary to store all the output strings\n        results = dict()\n        for genus, genelist in self.genedict.items():\n            # Initialise the dictionary with the appropriate genus\n            results[genus] = str()\n            for sample in self.runmetadata.samples:\n                try:\n                    # Find the samples that match the current genus - note that samples with multiple hits will be\n                    # represented in multiple outputs\n                    if genus in sample[analysistype].targetgenera:\n                        # Populate the results string with the sample name\n                        results[genus] += '{},'.format(sample.name)\n                        # Iterate through all the genes associated with this genus. If the gene is in the current\n                        # sample, add a + to the string, otherwise, add a -\n                        for gene in genelist:\n                            if gene.lower() in [target[0].lower().split('_')[0] for target in\n                                                sample[analysistype].results.items()]:\n                                results[genus] += '+,'\n                            else:\n                                results[genus] += '-,'\n                        results[genus] += '\\n'\n                # If the sample is missing the targetgenera attribute, then it is ignored for these reports\n                except AttributeError:\n                    pass\n        # Create and populate the genus-specific reports\n        for genus, resultstring in results.items():\n            # Only create the report if there are results for the current genus\n            if resultstring:\n                with open(os.path.join(self.reportpath, '{}_genesippr.csv'.format(genus)), 'w') as genusreport:\n                    # Write the header to the report - Strain plus add the genes associated with the genus\n                    genusreport.write('Strain,{}\\n'.format(','.join(self.genedict[genus])))\n                    # Write the results to the report\n                    genusreport.write(resultstring)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a GDCS report of the results of the GDCS analysis", "response": "def gdcsreporter(self, analysistype='GDCS'):\n        \"\"\"\n        Creates a report of the GDCS results\n        :param analysistype: The variable to use when accessing attributes in the metadata object\n        \"\"\"\n        logging.info('Creating {} report'.format(analysistype))\n        # Initialise list to store all the GDCS genes, and genera in the analysis\n        gdcs = list()\n        genera = list()\n        for sample in self.runmetadata.samples:\n            if sample.general.bestassemblyfile != 'NA':\n                if os.path.isdir(sample[analysistype].targetpath):\n                    # Update the fai dict with all the genes in the analysis, rather than just those with baited hits\n                    self.gdcs_fai(sample)\n                    sample[analysistype].createreport = True\n                    # Determine which genera are present in the analysis\n                    if sample.general.closestrefseqgenus not in genera:\n                        genera.append(sample.general.closestrefseqgenus)\n                    try:\n                        # Add all the GDCS genes to the list\n                        for gene in sorted(sample[analysistype].faidict):\n                            if gene not in gdcs:\n                                gdcs.append(gene)\n                    except AttributeError:\n                        sample[analysistype].createreport = False\n                else:\n                    sample[analysistype].createreport = False\n            else:\n                sample[analysistype].createreport = False\n                sample.general.incomplete = True\n        header = 'Strain,Genus,Matches,MeanCoverage,Pass/Fail,{},\\n'.format(','.join(gdcs))\n        data = str()\n        with open(os.path.join(self.reportpath, '{}.csv'.format(analysistype)), 'w') as report:\n            # Sort the samples in the report based on the closest refseq genus e.g. all samples with the same genus\n            # will be grouped together in the report\n            for genus in genera:\n                for sample in self.runmetadata.samples:\n                    if sample.general.closestrefseqgenus == genus:\n                        if sample[analysistype].createreport:\n                            sample[analysistype].totaldepth = list()\n                            # Add the sample to the report if it matches the current genus\n                            # if genus == sample.general.closestrefseqgenus:\n                            data += '{},{},'.format(sample.name, genus)\n                            # Initialise a variable to store the number of GDCS genes were matched\n                            count = 0\n                            # As I want the count to be in the report before all the gene results, this string will\n                            # store the specific sample information, and will be added to data once count is known\n                            specific = str()\n                            for gene in gdcs:\n                                # As there are different genes present in the GDCS databases for each organism of\n                                # interest, genes that did not match because they're absent in the specific database are\n                                # indicated using an X\n                                if gene not in [result for result in sample[analysistype].faidict]:\n                                    specific += 'X,'\n                                else:\n                                    try:\n                                        # Report the necessary information for each gene result\n                                        identity = sample[analysistype].results[gene]\n                                        specific += '{}% ({} +/- {}),'\\\n                                            .format(identity, sample[analysistype].avgdepth[gene],\n                                                    sample[analysistype].standarddev[gene])\n                                        sample[analysistype].totaldepth.append(\n                                            float(sample[analysistype].avgdepth[gene]))\n                                        count += 1\n                                    # If the gene was missing from the results attribute, add a - to the cell\n                                    except (KeyError, AttributeError):\n                                        sample.general.incomplete = True\n                                        specific += '-,'\n                            # Calculate the mean depth of the genes and the standard deviation\n                            sample[analysistype].mean = numpy.mean(sample[analysistype].totaldepth)\n                            sample[analysistype].stddev = numpy.std(sample[analysistype].totaldepth)\n                            # Determine whether the sample pass the necessary quality criteria:\n                            # Pass, all GDCS, mean coverage greater than 20X coverage;\n                            # ?: Indeterminate value;\n                            # -: Fail value\n                            # Allow one missing GDCS to still be considered a pass\n                            if count >= len(sample[analysistype].faidict) - 1:\n                                if sample[analysistype].mean > 20:\n                                    quality = '+'\n                                else:\n                                    quality = '?'\n                                    sample.general.incomplete = True\n                            else:\n                                quality = '-'\n                                sample.general.incomplete = True\n                            # Add the count, mean depth with standard deviation, the pass/fail determination,\n                            #  and the total number of GDCS genes as well as the results\n                            data += '{hits}/{total},{mean} +/- {std},{fail},{gdcs}\\n'\\\n                                .format(hits=str(count),\n                                        total=len(sample[analysistype].faidict),\n                                        mean='{:.2f}'.format(sample[analysistype].mean),\n                                        std='{:.2f}'.format(sample[analysistype].stddev),\n                                        fail=quality,\n                                        gdcs=specific)\n                        # # Any samples with a best assembly of 'NA' are considered incomplete.\n                        # else:\n                        #     data += '{},{},,,-\\n'.format(sample.name, sample.general.closestrefseqgenus)\n                        #     sample.general.incomplete = True\n                    elif sample.general.closestrefseqgenus == 'NA':\n                        data += '{}\\n'.format(sample.name)\n                        sample.general.incomplete = True\n            # Write the header and data to file\n            report.write(header)\n            report.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a report of the results of the sixteens analyses", "response": "def sixteensreporter(self, analysistype='sixteens_full'):\n        \"\"\"\n        Creates a report of the results\n        :param analysistype: The variable to use when accessing attributes in the metadata object\n        \"\"\"\n        # Create the path in which the reports are stored\n        make_path(self.reportpath)\n        # Initialise the header and data strings\n        header = 'Strain,Gene,PercentIdentity,Genus,FoldCoverage\\n'\n        data = ''\n        with open(os.path.join(self.reportpath, analysistype + '.csv'), 'w') as report:\n            with open(os.path.join(self.reportpath, analysistype + '_sequences.fa'), 'w') as sequences:\n                for sample in self.runmetadata.samples:\n                    try:\n                        # Select the best hit of all the full-length 16S genes mapped\n                        sample[analysistype].besthit = sorted(sample[analysistype].results.items(),\n                                                              key=operator.itemgetter(1), reverse=True)[0][0]\n                        # Add the sample name to the data string\n                        data += sample.name + ','\n                        # Find the record that matches the best hit, and extract the necessary values to be place in the\n                        # data string\n                        for name, identity in sample[analysistype].results.items():\n                            if name == sample[analysistype].besthit:\n                                data += '{},{},{},{}\\n'.format(name, identity, sample[analysistype].genus,\n                                                               sample[analysistype].avgdepth[name])\n                                # Create a FASTA-formatted sequence output of the 16S sequence\n                                record = SeqRecord(Seq(sample[analysistype].sequences[name],\n                                                       IUPAC.unambiguous_dna),\n                                                   id='{}_{}'.format(sample.name, '16S'),\n                                                   description='')\n                                SeqIO.write(record, sequences, 'fasta')\n                    except (KeyError, IndexError):\n                        data += '{}\\n'.format(sample.name)\n            # Write the results to the report\n            report.write(header)\n            report.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a final report of all the ConFindr results", "response": "def confindr_reporter(self, analysistype='confindr'):\n        \"\"\"\n        Creates a final report of all the ConFindr results\n        \"\"\"\n        # Initialise the data strings\n        data = 'Strain,Genus,NumContamSNVs,ContamStatus,PercentContam,PercentContamSTD\\n'\n        with open(os.path.join(self.reportpath, analysistype + '.csv'), 'w') as report:\n            # Iterate through all the results\n            for sample in self.runmetadata.samples:\n                data += '{str},{genus},{numcontamsnv},{status},{pc},{pcs}\\n'.format(\n                    str=sample.name,\n                    genus=sample.confindr.genus,\n                    numcontamsnv=sample.confindr.num_contaminated_snvs,\n                    status=sample.confindr.contam_status,\n                    pc=sample.confindr.percent_contam,\n                    pcs=sample.confindr.percent_contam_std\n                )\n            # Write the string to the report\n            report.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate final reports collating results from all the individual iterations through the method pipeline.", "response": "def methodreporter(self):\n        \"\"\"\n        Create final reports collating results from all the individual iterations through the method pipeline\n        \"\"\"\n        # Ensure that the analyses are set to complete\n        self.analysescomplete = True\n        # Reset the report path to original value\n        self.reportpath = os.path.join(self.path, 'reports')\n        # Clear the runmetadata - it will be populated with all the metadata from completemetadata\n        self.runmetadata = MetadataObject()\n        self.runmetadata.samples = list()\n        # As the samples were entered into self.completemetadata depending on when they passed the quality threshold,\n        # this list is not ordered numerically/alphabetically like the original runmetadata. Reset the order.\n        for strain in self.samples:\n            for sample in self.completemetadata:\n                if sample.name == strain:\n                    # Append the sample to the ordered list of objects\n                    self.runmetadata.samples.append(sample)\n        # Create the reports\n        self.reporter()\n        self.genusspecific()\n        self.sixteensreporter()\n        self.gdcsreporter()\n        self.confindr_reporter()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns the methods required to create the genesippr report summary image", "response": "def main(self):\n        \"\"\"\n        Run the methods required to create the genesippr report summary image\n        \"\"\"\n        self.dataframe_setup()\n        self.figure_populate(self.outputfolder,\n                             self.image_report,\n                             self.header_list,\n                             self.samples,\n                             'genesippr',\n                             'report',\n                             fail=self.fail)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsanitizes the data to be consistent with heatmaps.", "response": "def data_sanitise(self, inputstring, header=None):\n        \"\"\"\n        Format the data to be consistent with heatmaps\n        :param inputstring: string containing data to be formatted\n        :param header: class of the data - certain categories have specific formatting requirements\n        :return: the formatted output string\n        \"\"\"\n        if str(inputstring) == 'nan':\n            outputstring = 0\n        elif '%' in str(inputstring):\n            group = re.findall('(\\d+)\\..+', str(inputstring))\n            outputstring = group[0]\n        elif header == 'Pass/Fail':\n            if str(inputstring) == '+':\n                outputstring = '100'\n            else:\n                outputstring = -100\n                self.fail = True\n        elif header == 'ContamStatus':\n            if str(inputstring) == 'Clean':\n                outputstring = '100'\n            else:\n                outputstring = -100\n                self.fail = True\n        elif header == 'MeanCoverage':\n            cov = float(str(inputstring).split(' ')[0])\n            if cov >= 20:\n                outputstring = 100\n            else:\n                outputstring = -100\n                self.fail = True\n        else:\n            outputstring = str(inputstring)\n        return outputstring"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting up a dataframe for the desired header and string combinations of the genesippr and confindr reports.", "response": "def dataframe_setup(self):\n        \"\"\"\n        Set-up a report to store the desired header: sanitized string combinations\n        \"\"\"\n        # Initialise a dictionary to store the sanitized headers and strings\n        genesippr_dict = dict()\n        # Try to open all the reports - use pandas to extract the results from any report that exists\n        try:\n            sippr_matrix = pd.read_csv(os.path.join(self.reportpath, 'genesippr.csv'),\n                                       delimiter=',', index_col=0).T.to_dict()\n        except FileNotFoundError:\n            sippr_matrix = dict()\n        try:\n            conf_matrix = pd.read_csv(os.path.join(self.reportpath, 'confindr_report.csv'),\n                                      delimiter=',', index_col=0).T.to_dict()\n        except FileNotFoundError:\n            conf_matrix = dict()\n        try:\n            gdcs_matrix = pd.read_csv(os.path.join(self.reportpath, 'GDCS.csv'),\n                                      delimiter=',', index_col=0).T.to_dict()\n        except FileNotFoundError:\n            gdcs_matrix = dict()\n        # Populate the header:sanitized string dictionary with results from all strains\n        for sample in self.metadata:\n            genesippr_dict[sample.name] = dict()\n            try:\n                genesippr_dict[sample.name]['eae'] = self.data_sanitise(sippr_matrix[sample.name]['eae'])\n            except KeyError:\n                genesippr_dict[sample.name]['eae'] = 0\n            try:\n                genesippr_dict[sample.name]['hlyAEc'] = self.data_sanitise(sippr_matrix[sample.name]['hlyAEc'])\n            except KeyError:\n                genesippr_dict[sample.name]['hlyAEc'] = 0\n            try:\n                genesippr_dict[sample.name]['VT1'] = self.data_sanitise(sippr_matrix[sample.name]['VT1'])\n            except KeyError:\n                genesippr_dict[sample.name]['VT1'] = 0\n            try:\n                genesippr_dict[sample.name]['VT2'] = self.data_sanitise(sippr_matrix[sample.name]['VT2'])\n            except KeyError:\n                genesippr_dict[sample.name]['VT2'] = 0\n            try:\n                genesippr_dict[sample.name]['hlyALm'] = self.data_sanitise(sippr_matrix[sample.name]['hlyALm'])\n            except KeyError:\n                genesippr_dict[sample.name]['hlyALm'] = 0\n            try:\n                genesippr_dict[sample.name]['IGS'] = self.data_sanitise(sippr_matrix[sample.name]['IGS'])\n            except KeyError:\n                genesippr_dict[sample.name]['IGS'] = 0\n            try:\n                genesippr_dict[sample.name]['inlJ'] = self.data_sanitise(sippr_matrix[sample.name]['inlJ'])\n            except KeyError:\n                genesippr_dict[sample.name]['inlJ'] = 0\n            try:\n                genesippr_dict[sample.name]['invA'] = self.data_sanitise(sippr_matrix[sample.name]['invA'])\n            except KeyError:\n                genesippr_dict[sample.name]['invA'] = 0\n            try:\n                genesippr_dict[sample.name]['stn'] = self.data_sanitise(sippr_matrix[sample.name]['stn'])\n            except KeyError:\n                genesippr_dict[sample.name]['stn'] = 0\n            try:\n                genesippr_dict[sample.name]['GDCS'] = self.data_sanitise(gdcs_matrix[sample.name]['Pass/Fail'],\n                                                                         header='Pass/Fail')\n            except KeyError:\n                genesippr_dict[sample.name]['GDCS'] = 0\n            try:\n                genesippr_dict[sample.name]['Contamination'] = self.data_sanitise(\n                    conf_matrix[sample.name]['ContamStatus'], header='ContamStatus')\n            except KeyError:\n                genesippr_dict[sample.name]['Contamination'] = 0\n            try:\n                genesippr_dict[sample.name]['Coverage'] = self.data_sanitise(\n                    gdcs_matrix[sample.name]['MeanCoverage'], header='MeanCoverage')\n            except KeyError:\n                genesippr_dict[sample.name]['Coverage'] = 0\n        # Create a report from the header: sanitized string dictionary to be used in the creation of the report image\n        with open(self.image_report, 'w') as csv:\n            data = '{}\\n'.format(','.join(self.header_list))\n            for strain in sorted(genesippr_dict):\n                data += '{str},'.format(str=strain)\n                for header in self.header_list[1:]:\n                    data += '{value},'.format(value=genesippr_dict[strain][header])\n\n                data = data.rstrip(',')\n                data += '\\n'\n            csv.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate the plot from the summary report and populate the plot with the data frame", "response": "def figure_populate(outputpath, csv, xlabels, ylabels, analysistype, description, fail=False):\n        \"\"\"\n        Create the report image from the summary report created in self.dataframesetup\n        :param outputpath: Path in which the outputs are to be created\n        :param csv: Name of the report file from which data are to be extracted\n        :param xlabels: List of all the labels to use on the x-axis\n        :param ylabels: List of all the labels to use on the y-axis\n        :param analysistype: String of the analysis type\n        :param description: String describing the analysis: set to either template for the empty heatmap created prior\n        to analyses or report for normal functionality\n        :param fail: Boolean of whether any samples have failed the quality checks - used for determining the palette\n        \"\"\"\n        # Create a data frame from the summary report\n        df = pd.read_csv(\n            os.path.join(outputpath, csv),\n            delimiter=',',\n            index_col=0)\n        # Set the palette appropriately - 'template' uses only grey\n        if description == 'template':\n            cmap = ['#a0a0a0']\n        # 'fail' uses red (fail), grey (not detected), and green (detected/pass)\n        elif fail:\n            cmap = ['#ff0000', '#a0a0a0', '#00cc00']\n        # Otherwise only use grey (not detected) and green (detected/pass)\n        else:\n            cmap = ['#a0a0a0', '#00cc00']\n        # Use seaborn to create a heatmap of the data\n        plot = sns.heatmap(df,\n                           cbar=False,\n                           linewidths=.5,\n                           cmap=cmap)\n        # Move the x-axis to the top of the plot\n        plot.xaxis.set_ticks_position('top')\n        # Remove the y-labels\n        plot.set_ylabel('')\n        # Set the x-tick labels as a slice of the x-labels list (first entry is not required, as it makes the\n        # report image look crowded. Rotate the x-tick labels 90 degrees\n        plot.set_xticklabels(xlabels[1:], rotation=90)\n        # Set the y-tick labels from the supplied list\n        plot.set_yticklabels(ylabels, rotation=0)\n        # Create the figure\n        fig = plot.get_figure()\n        # Save the figure in .png format, using the bbox_inches='tight' option to ensure that everything is scaled\n        fig.savefig(os.path.join(outputpath, '{at}_{desc}.png'.format(at=analysistype,\n                                                                      desc=description)),\n                    bbox_inches='tight'\n                    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds the user s local bin to the PATH", "response": "def add_usr_local_bin_to_path(log=False):\n    \"\"\" adds /usr/local/bin to $PATH \"\"\"\n    if log:\n        bookshelf2.logging_helpers.log_green('inserts /usr/local/bin into PATH')\n\n    with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                  capture=True):\n        try:\n            sudo('echo \"export PATH=/usr/local/bin:$PATH\" '\n                 '|sudo /usr/bin/tee /etc/profile.d/fix-path.sh')\n            return True\n        except:\n            raise SystemExit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dir_attribs(location, mode=None, owner=None,\n                group=None, recursive=False, use_sudo=False):\n    \"\"\" cuisine dir_attribs doesn't do sudo, so we implement our own\n        Updates the mode/owner/group for the given remote directory.\"\"\"\n    args = ''\n    if recursive:\n        args = args + ' -R '\n\n    if mode:\n        if use_sudo:\n            sudo('chmod %s %s %s' % (args, mode,  location))\n        else:\n            run('chmod %s %s %s' % (args, mode,  location))\n    if owner:\n        if use_sudo:\n            sudo('chown %s %s %s' % (args, owner, location))\n        else:\n            run('chown %s %s %s' % (args, owner, location))\n    if group:\n        if use_sudo:\n            sudo('chgrp %s %s %s' % (args, group, location))\n        else:\n            run('chgrp %s %s %s' % (args, group, location))\n    return True", "response": "cuisine dir_attribs does not do sudo so we implement our own\nTaxonomy"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntells if there is a remote directory at the given location.", "response": "def dir_exists(location, use_sudo=False):\n    \"\"\"Tells if there is a remote directory at the given location.\"\"\"\n    with settings(hide('running', 'stdout', 'stderr'), warn_only=True):\n        if use_sudo:\n            # convert return code 0 to True\n            return not bool(sudo('test -d %s' % (location)).return_code)\n        else:\n            return not bool(run('test -d %s' % (location)).return_code)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef disable_env_reset_on_sudo(log=False):\n    if log:\n        bookshelf2.logging_helpers.log_green('disabling env reset on sudo')\n\n    file_append('/etc/sudoers',\n                'Defaults:%wheel !env_reset,!secure_path',\n                use_sudo=True,\n                partial=True)\n    return True", "response": "disables env reset on sudo"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nallows sudo calls through ssh without a tty", "response": "def disable_requiretty_on_sudoers(log=False):\n    \"\"\" allow sudo calls through ssh without a tty \"\"\"\n    if log:\n        bookshelf2.logging_helpers.log_green(\n            'disabling requiretty on sudo calls')\n\n    comment_line('/etc/sudoers',\n                 '^Defaults.*requiretty', use_sudo=True)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef file_attribs(location,\n                 mode=None,\n                 owner=None,\n                 group=None,\n                 use_sudo=False,\n                 recursive=True):\n    \"\"\"Updates the mode/owner/group for the remote file at the given\n    location.\"\"\"\n    return dir_attribs(location=location,\n                       mode=mode,\n                       owner=owner,\n                       group=group,\n                       recursive=recursive,\n                       use_sudo=False)", "response": "Updates the mode owner group for the remote file at the given location."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dictionary of all available OS - related resources", "response": "def os_release():\n    \"\"\" returns /etc/os-release in a dictionary \"\"\"\n    with settings(hide('warnings', 'running', 'stderr'),\n                  warn_only=True, capture=True):\n\n        release = {}\n        data = run('cat /etc/os-release')\n        for line in data.split('\\n'):\n            if not line:\n                continue\n            parts = line.split('=')\n            if len(parts) == 2:\n                release[parts[0]] = parts[1].strip('\\n\\r\"')\n\n        return release"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef linux_distribution():\n    with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                  warn_only=True, capture=True):\n        data = os_release()\n        return(data['ID'])", "response": "returns the linux distribution in lower case"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dictionary of all the items in the lsb - release file", "response": "def lsb_release():\n    \"\"\" returns /etc/lsb-release in a dictionary \"\"\"\n    with settings(hide('warnings', 'running'), capture=True):\n\n        _lsb_release = {}\n        data = sudo('cat /etc/lsb-release')\n        for line in data.split('\\n'):\n            if not line:\n                continue\n            parts = line.split('=')\n            if len(parts) == 2:\n                _lsb_release[parts[0]] = parts[1].strip('\\n\\r\"')\n\n        return _lsb_release"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a human readable ANSI - terminal printout of the stats.", "response": "def ansi_format( self, width=64, height=12 ):\n        \"\"\"Return a human readable ANSI-terminal printout of the stats.\n\n        width\n            Custom width for the graph (in characters).\n\n        height\n            Custom height for the graph (in characters).\n        \"\"\"\n        from mrcrowbar.ansi import format_bar_graph_iter\n        if (256 % width) != 0:\n            raise ValueError( 'Width of the histogram must be a divisor of 256' )\n        elif (width <= 0):\n            raise ValueError( 'Width of the histogram must be greater than zero' )\n        elif (width > 256):\n            raise ValueError( 'Width of the histogram must be less than or equal to 256' )\n    \n        buckets = self.histogram( width )\n        result = []\n        for line in format_bar_graph_iter( buckets, width=width, height=height ):\n            result.append( ' {}\\n'.format( line ) )\n\n        result.append( '\u2558'+('\u2550'*width)+'\u255b\\n' )\n        result.append( 'entropy: {:.10f}\\n'.format( self.entropy ) )\n        result.append( 'samples: {}'.format( self.samples ) )\n        return ''.join( result )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef put(self):\n        return self.manager.put(\n            id=self.id,\n            name=self.name,\n            description=self.description,\n            whitelisted_container_task_types=(\n                self.whitelisted_container_task_types\n            ),\n            whitelisted_executable_task_types=(\n                self.whitelisted_executable_task_types\n            ),\n        )", "response": "Updates this task whitelist on the saltant server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new entry in the task whitelist.", "response": "def create(\n        self,\n        name,\n        description=\"\",\n        whitelisted_container_task_types=None,\n        whitelisted_executable_task_types=None,\n    ):\n        \"\"\"Create a task whitelist.\n\n        Args:\n            name (str): The name of the task whitelist.\n            description (str, optional): A description of the task whitelist.\n            whitelisted_container_task_types (list, optional): A list of\n                whitelisted container task type IDs.\n            whitelisted_executable_task_types (list, optional): A list\n                of whitelisted executable task type IDs.\n\n        Returns:\n            :class:`saltant.models.task_whitelist.TaskWhitelist`:\n                A task whitelist model instance representing the task\n                whitelist just created.\n        \"\"\"\n        # Translate whitelists None to [] if necessary\n        if whitelisted_container_task_types is None:\n            whitelisted_container_task_types = []\n\n        if whitelisted_executable_task_types is None:\n            whitelisted_executable_task_types = []\n\n        # Create the object\n        request_url = self._client.base_api_url + self.list_url\n        data_to_post = {\n            \"name\": name,\n            \"description\": description,\n            \"whitelisted_container_task_types\": whitelisted_container_task_types,\n            \"whitelisted_executable_task_types\": whitelisted_executable_task_types,\n        }\n\n        response = self._client.session.post(request_url, data=data_to_post)\n\n        # Validate that the request was successful\n        self.validate_request_success(\n            response_text=response.text,\n            request_url=request_url,\n            status_code=response.status_code,\n            expected_status_code=HTTP_201_CREATED,\n        )\n\n        # Return a model instance representing the task instance\n        return self.response_data_to_model_instance(response.json())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef enable_logging( level='WARNING' ):\n    log = logging.getLogger( 'mrcrowbar' )\n    log.setLevel( level )\n    out = logging.StreamHandler()\n    out.setLevel( level )\n    form = logging.Formatter( '[%(levelname)s] %(name)s - %(message)s' )\n    out.setFormatter( form )\n    log.addHandler( out )", "response": "Enable logging to stderr. Useful for shell sessions. level\n        Logging threshold. Defaults to WARNING."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\niterate through every location a substring can be found in a source string.", "response": "def find_all_iter( source, substring, start=None, end=None, overlap=False ):\n    \"\"\"Iterate through every location a substring can be found in a source string.\n\n    source\n        The source string to search.\n\n    start\n        Start offset to read from (default: start)\n\n    end\n        End offset to stop reading at (default: end)\n\n    overlap\n        Whether to return overlapping matches (default: false)\n    \"\"\"\n    data = source\n    base = 0\n    if end is not None:\n        data = data[:end]\n    if start is not None:\n        data = data[start:]\n        base = start\n    pointer = 0\n    increment = 1 if overlap else (len( substring ) or 1)\n    while True:\n        pointer = data.find( substring, pointer )\n        if pointer == -1:\n            return\n        yield base+pointer\n        pointer += increment"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_all( source, substring, start=None, end=None, overlap=False ):\n    return [x for x in find_all_iter( source, substring, start, end, overlap )]", "response": "Return every location a substring can be found in a source string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef basic_diff( source1, source2, start=None, end=None ):\n    start = start if start is not None else 0\n    end = end if end is not None else min( len( source1 ), len( source2 ) )\n    end_point = min( end, len( source1 ), len( source2 ) )\n\n    pointer = start\n    diff_start = None\n    results = []\n    while pointer < end_point:\n        if source1[pointer] != source2[pointer]:\n            if diff_start is None:\n                diff_start = pointer\n        else:\n            if diff_start is not None:\n                results.append( (diff_start, pointer-diff_start) )\n                diff_start = None\n        pointer += 1\n    if diff_start is not None:\n        results.append( (diff_start, pointer-diff_start) )\n        diff_start = None\n\n    return results", "response": "Perform a basic diff between two equal - sized binary strings and\n    returns a list of tuples denoting the differences."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hexdump_iter( source, start=None, end=None, length=None, major_len=8, minor_len=4, colour=True, address_base=None ):\n    assert is_bytes( source )\n    start, end = bounds( start, end, length, len( source ) )\n\n    start = max( start, 0 )\n    end = min( end, len( source ) )\n    if len( source ) == 0 or (start == end == 0):\n        return\n    address_base_offset = address_base-start if address_base is not None else 0\n\n    for offset in range( start, end, minor_len*major_len ):\n        yield ansi.format_hexdump_line( source, offset, end, major_len, minor_len, colour, address_base_offset=address_base_offset )\n    return", "response": "Return an iterator over the contents of a byte string in tabular hexadecimal format."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprint the contents of a byte string in tabular hexadecimal format.", "response": "def hexdump( source, start=None, end=None, length=None, major_len=8, minor_len=4, colour=True, address_base=None ):\n    \"\"\"Print the contents of a byte string in tabular hexadecimal/ASCII format.\n    \n    source\n        The byte string to print.\n\n    start\n        Start offset to read from (default: start)\n\n    end\n        End offset to stop reading at (default: end)\n\n    length\n        Length to read in (optional replacement for end)\n\n    major_len\n        Number of hexadecimal groups per line\n\n    minor_len\n        Number of bytes per hexadecimal group\n\n    colour\n        Add ANSI colour formatting to output (default: true)\n\n    address_base\n        Base address to use for labels (default: start)\n\n    Raises ValueError if both end and length are defined.\n    \"\"\"\n    for line in hexdump_iter( source, start, end, length, major_len, minor_len, colour, address_base ):\n        print( line )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hexdump_diff_iter( source1, source2, start=None, end=None, length=None, major_len=8, minor_len=4, colour=True, before=2, after=2, address_base=None ):\n    stride = minor_len*major_len\n    start = start if start is not None else 0\n    end = end if end is not None else max( len( source1 ), len( source2 ) )\n\n    start = max( start, 0 )\n    end = min( end, max( len( source1 ), len( source2 ) ) )\n    address_base_offset = address_base-start if address_base is not None else 0\n\n    diff_lines = []\n    for offset in range( start, end, stride ):\n        if source1[offset:offset+stride] != source2[offset:offset+stride]:\n            diff_lines.append( offset )\n    show_all = before is None or after is None\n    if show_all:\n        show_lines = {x: (2 if x in diff_lines else 1) for x in range( start, end, stride )}\n    else:\n        show_lines = {x: (2 if x in diff_lines else 0) for x in range( start, end, stride )}\n        for index in diff_lines:\n            for b in [index-(x+1)*stride for x in range( before )]:\n                if b in show_lines and show_lines[b] == 0:\n                    show_lines[b] = 1\n            for a in [index+(x+1)*stride for x in range( after )]:\n                if a in show_lines and show_lines[a] == 0:\n                    show_lines[a] = 1\n\n    skip = False\n    for offset in sorted( show_lines.keys() ):\n        if skip == True and show_lines[offset] != 0:\n            yield '...'\n            skip = False\n        if show_lines[offset] == 2:\n            check = basic_diff( source1, source2, start=offset, end=offset+stride )\n            highlights = {}\n            for (o, l) in check:\n                for i in range( o, o+l ):\n                    highlights[i] = DIFF_COLOUR_MAP[0]\n            if offset < len( source1 ):\n                yield ansi.format_hexdump_line( source1, offset, min( end, len( source1 ) ), major_len, minor_len, colour, prefix='-', highlight_addr=DIFF_COLOUR_MAP[0], highlight_map=highlights, address_base_offset=address_base_offset )\n            highlights = {k: DIFF_COLOUR_MAP[1] for k in highlights.keys()}\n            if offset < len( source2 ):\n                yield ansi.format_hexdump_line( source2, offset, min( end, len( source2 ) ), major_len, minor_len, colour, prefix='+' , highlight_addr=DIFF_COLOUR_MAP[1], highlight_map=highlights, address_base_offset=address_base_offset )\n        elif show_lines[offset] == 1:\n            yield ansi.format_hexdump_line( source1, offset, end, major_len, minor_len, colour, prefix=' ', address_base_offset=address_base_offset )\n        elif show_lines[offset] == 0:\n            skip = True\n\n    if skip == True:\n        yield '...'\n        skip = False\n\n    return", "response": "Return an iterator over the differences between two byte strings in tabular hexadecimal or ASCII format."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the differences between two byte strings in tabular hexadecimal format.", "response": "def hexdump_diff( source1, source2, start=None, end=None, length=None, major_len=8, minor_len=4, colour=True, before=2, after=2, address_base=None ):\n    \"\"\"Returns the differences between two byte strings in tabular hexadecimal/ASCII format.\n\n    source1\n        The first byte string source.\n\n    source2\n        The second byte string source.\n\n    start\n        Start offset to read from (default: start)\n\n    end\n        End offset to stop reading at (default: end)\n\n    length\n        Length to read in (optional replacement for end)\n\n    major_len\n        Number of hexadecimal groups per line\n\n    minor_len\n        Number of bytes per hexadecimal group\n\n    colour\n        Add ANSI colour formatting to output (default: true)\n\n    before\n        Number of lines of context preceeding a match to show\n\n    after\n        Number of lines of context following a match to show\n\n    address_base\n        Base address to use for labels (default: start)\n\n    Raises ValueError if both end and length are defined.\n    \"\"\"\n    for line in hexdump_diff_iter( source1, source2, start, end, length, major_len, minor_len, colour, before, after, address_base ):\n        print( line )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexpanding a bitfield into a 64 - bit int.", "response": "def unpack_bits( byte ):\n    \"\"\"Expand a bitfield into a 64-bit int (8 bool bytes).\"\"\"\n    longbits = byte & (0x00000000000000ff)\n    longbits = (longbits | (longbits<<28)) & (0x0000000f0000000f)\n    longbits = (longbits | (longbits<<14)) & (0x0003000300030003)\n    longbits = (longbits | (longbits<<7)) & (0x0101010101010101)\n    return longbits"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pack_bits( longbits ):\n    byte = longbits & (0x0101010101010101)\n    byte = (byte | (byte>>7)) & (0x0003000300030003)\n    byte = (byte | (byte>>14)) & (0x0000000f0000000f)\n    byte = (byte | (byte>>28)) & (0x00000000000000ff)\n    return byte", "response": "Crunch a 64 - bit int into a bitfield."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn an iterator that returns the contents of a byte string as a 256 colour image.", "response": "def pixdump_iter( source, start=None, end=None, length=None, width=64, height=None, palette=None ):\n    \"\"\"Return the contents of a byte string as a 256 colour image.\n\n    source\n        The byte string to print.\n\n    start\n        Start offset to read from (default: start)\n\n    end\n        End offset to stop reading at (default: end)\n\n    length\n        Length to read in (optional replacement for end)\n\n    width\n        Width of image to render in pixels (default: 64)\n\n    height\n        Height of image to render in pixels (default: auto)\n\n    palette\n        List of Colours to use (default: test palette)\n    \"\"\"\n    assert is_bytes( source )\n\n    if not palette:\n        palette = colour.TEST_PALETTE\n\n    start = 0 if (start is None) else start\n    if (end is not None) and (length is not None):\n        raise ValueError( 'Can\\'t define both an end and a length!' )\n    elif (length is not None):\n        end = start+length\n    elif (end is not None):\n        pass\n    else:\n        end = len( source )\n\n    start = max( start, 0 )\n    end = min( end, len( source ) )\n    if len( source ) == 0 or (start == end == 0):\n        return iter(())\n\n    if height is None:\n        height = math.ceil( (end-start)/width )\n\n    def data_fetch( x_pos, y_pos, frame ):\n        index = y_pos*width + x_pos + start\n        if index >= end:\n            return (0, 0, 0, 0)\n        return palette[source[index]]\n\n    return ansi.format_image_iter( data_fetch, width=width, height=height )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pixdump( source, start=None, end=None, length=None, width=64, height=None, palette=None ):\n\n    for line in pixdump_iter( source, start, end, length, width, height, palette ):\n        print( line )", "response": "Print the contents of a byte string as a 256 colour image."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the current read offset for the instance.", "response": "def set_offset( self, offset ):\n        \"\"\"Set the current read offset (in bytes) for the instance.\"\"\"\n        assert offset in range( len( self.buffer ) )\n        self.pos = offset\n        self._fill_buffer()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets an integer containing the next count bits from the source.", "response": "def get_bits( self, count ):\n        \"\"\"Get an integer containing the next [count] bits from the source.\"\"\"\n        result = 0\n        for i in range( count ):\n            if self.bits_remaining <= 0:\n                self._fill_buffer()\n            if self.bits_reverse:\n                bit = (1 if (self.current_bits & (0x80 << 8*(self.bytes_to_cache-1))) else 0)\n                self.current_bits <<= 1\n                self.current_bits &= 0xff\n            else:\n                bit = (self.current_bits & 1)\n                self.current_bits >>= 1\n\n            self.bits_remaining -= 1\n\n            if self.output_reverse:\n                result <<= 1\n                result |= bit\n            else:\n                result |= bit << i\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npushing bits into the target.", "response": "def put_bits( self, value, count ):\n        \"\"\"Push bits into the target.\n\n        value\n            Integer containing bits to push, ordered from least-significant bit to\n            most-significant bit.\n\n        count\n            Number of bits to push to the target.\n        \"\"\"\n        for _ in range( count ):\n\n            # bits are retrieved from the source LSB first\n            bit = (value & 1)\n            value >>= 1\n\n            # however, bits are put into the result based on the rule\n            if self.bits_reverse:\n                if self.insert_at_msb:\n                    self.current_bits |= (bit << (self.bits_remaining-1))\n                else:\n                    self.current_bits <<= 1\n                    self.current_bits |= bit\n            else:\n                if self.insert_at_msb:\n                    self.current_bits >>= 1\n                    self.current_bits |= (bit << 7)\n                else:\n                    self.current_bits |= (bit << (8-self.bits_remaining))\n\n            self.bits_remaining -= 1\n            if self.bits_remaining <= 0:\n                self.output.append( self.current_bits )\n\n                self.current_bits = 0\n                self.bits_remaining = 8"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a byte string containing the target as currently written.", "response": "def get_buffer( self ):\n        \"\"\"Return a byte string containing the target as currently written.\"\"\"\n        last_byte = self.current_bits if (self.bits_remaining < 8) else None\n\n        result = self.output\n        if last_byte is not None:\n            result = bytearray( result )\n            result.append( last_byte )\n\n        if self.bytes_reverse:\n            return bytes( reversed( result ) )\n        else:\n            return bytes( result )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a record for updating.", "response": "def get_for_update(self, connection_name='DEFAULT', **kwargs):\n\n        \"\"\"\n        http://docs.sqlalchemy.org/en/latest/orm/query.html?highlight=update#sqlalchemy.orm.query.Query.with_for_update  # noqa\n        \"\"\"\n        if not kwargs:\n            raise InvalidQueryError(\n                \"Can not execute a query without parameters\")\n\n        obj = self.pool.connections[connection_name].session.query(\n            self._model).with_for_update(\n                nowait=True, of=self._model).filter_by(**kwargs).first()\n        if not obj:\n            raise NotFoundError('Object not found')\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef syllabify(word, compound=None):\n    '''Syllabify the given word, whether simplex or complex.'''\n    if compound is None:\n        compound = bool(re.search(r'(-| |=)', word))\n\n    syllabify = _syllabify_compound if compound else _syllabify\n    syll, rules = syllabify(word)\n\n    yield syll, rules\n\n    n = 7\n\n    if 'T4' in rules:\n        yield syllabify(word, T4=False)\n        n -= 1\n\n    if 'e' in rules:\n        yield syllabify(word, T1E=False)\n        n -= 1\n\n    if 'e' in rules and 'T4' in rules:\n        yield syllabify(word, T4=False, T1E=False)\n        n -= 1\n\n    # yield empty syllabifications and rules\n    for i in range(n):\n        yield '', ''", "response": "Syllabify the given word whether simplex or complex."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts name from CamelCase to snake_case", "response": "def convert_case(name):\n        \"\"\"Converts name from CamelCase to snake_case\"\"\"\n        s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n        return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npluralising the class_name using utterly simple algo and returns as table_name", "response": "def table_name(self):\n        \"\"\"Pluralises the class_name using utterly simple algo and returns as table_name\"\"\"\n        if not self.class_name:\n            raise ValueError\n        else:\n            tbl_name = ModelCompiler.convert_case(self.class_name)\n        last_letter = tbl_name[-1]\n        if last_letter in (\"y\",):\n            return \"{}ies\".format(tbl_name[:-1])\n        elif last_letter in (\"s\",):\n            return \"{}es\".format(tbl_name)\n        else:\n            return \"{}s\".format(tbl_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef basic_types(self):\n        if not self.foreign_key_definitions:\n            return self.standard_types\n        else:\n            tmp = self.standard_types\n            tmp.append('ForeignKey')\n            return tmp", "response": "Returns non - postgres types referenced in user supplied model"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the primary keys referenced in user supplied model", "response": "def primary_keys(self):\n        \"\"\"Returns the primary keys referenced in user supplied model\"\"\"\n        res = []\n        for column in self.column_definitions:\n            if 'primary_key' in column.keys():\n                tmp = column.get('primary_key', None)\n                res.append(column['name']) if tmp else False\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compiled_named_imports(self):\n        res = []\n        if self.postgres_types:\n            res.append(\n                ALCHEMY_TEMPLATES.named_import.safe_substitute(\n                    module='sqlalchemy.dialects.postgresql',\n                    labels=\", \".join(self.postgres_types)))\n        if self.mutable_dict_types:\n            res.append(\n                ALCHEMY_TEMPLATES.named_import.safe_substitute(\n                    module='sqlalchemy.ext.mutable', labels='MutableDict'\n                ))\n        return \"\\n\".join(res)", "response": "Returns compiled named imports required for the model"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef compiled_orm_imports(self):\n        module = 'sqlalchemy.orm'\n        labels = []\n        if self.relationship_definitions:\n            labels.append(\"relationship\")\n        return ALCHEMY_TEMPLATES.named_import.safe_substitute(module=module, labels=\", \".join(labels))", "response": "Returns compiled named imports required for the model"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning compiled column definitions", "response": "def compiled_columns(self):\n        \"\"\"Returns compiled column definitions\"\"\"\n\n        def get_column_args(column):\n            tmp = []\n            for arg_name, arg_val in column.items():\n                if arg_name not in ('name', 'type'):\n                    if arg_name in ('server_default', 'server_onupdate'):\n                        arg_val = '\"{}\"'.format(arg_val)\n                    tmp.append(ALCHEMY_TEMPLATES.column_arg.safe_substitute(arg_name=arg_name,\n                                                                            arg_val=arg_val))\n            return \", \".join(tmp)\n\n        res = []\n        for column in self.column_definitions:\n            column_args = get_column_args(column)\n            column_type, type_params = ModelCompiler.get_col_type_info(column.get('type'))\n            column_name = column.get('name')\n            if column_type in MUTABLE_DICT_TYPES:\n                column_type = ALCHEMY_TEMPLATES.mutable_dict_type.safe_substitute(type=column_type,\n                                                                                  type_params=type_params)\n                type_params = ''\n            res.append(\n                ALCHEMY_TEMPLATES.column_definition.safe_substitute(column_name=column_name,\n                                                                    column_type=column_type,\n                                                                    column_args=column_args,\n                                                                    type_params=type_params))\n        join_string = \"\\n\" + self.tab\n        return join_string.join(res)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef compiled_foreign_keys(self):\n\n        def get_column_args(column):\n            tmp = []\n            for arg_name, arg_val in column.items():\n                if arg_name not in ('name', 'type', 'reference'):\n                    if arg_name in ('server_default', 'server_onupdate'):\n                        arg_val = '\"{}\"'.format(arg_val)\n                    tmp.append(ALCHEMY_TEMPLATES.column_arg.safe_substitute(arg_name=arg_name,\n                                                                            arg_val=arg_val))\n            return \", \".join(tmp)\n\n        def get_fkey_args(column):\n            table = column['reference']['table']\n            column = column['reference']['column']\n            return ALCHEMY_TEMPLATES.foreign_key_arg.safe_substitute(reference_table=table, reference_column=column)\n\n        res = []\n        for column in self.foreign_key_definitions:\n            column_args = get_column_args(column)\n            column_type, type_params = ModelCompiler.get_col_type_info(column.get('type'))\n            column_name = column.get('name')\n            reference = get_fkey_args(column)\n            if column_type in MUTABLE_DICT_TYPES:\n                column_type = ALCHEMY_TEMPLATES.mutable_dict_type.safe_substitute(type=column_type,\n                                                                                  type_params=type_params)\n                type_params = ''\n            res.append(\n                ALCHEMY_TEMPLATES.foreign_key.safe_substitute(column_name=column_name,\n                                                              column_type=column_type,\n                                                              column_args=column_args,\n                                                              foreign_key_args=reference,\n                                                              type_params=type_params))\n        join_string = \"\\n\" + self.tab\n        return join_string.join(res)", "response": "Returns compiled foreign key definitions"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compiled_relationships(self):\n\n        def get_column_args(column):\n            tmp = []\n            for arg_name, arg_val in column.items():\n                if arg_name not in ('name', 'type', 'reference', 'class'):\n                    if arg_name in ('back_populates', ):\n                        arg_val = \"'{}'\".format(arg_val)\n                    tmp.append(ALCHEMY_TEMPLATES.column_arg.safe_substitute(arg_name=arg_name,\n                                                                            arg_val=arg_val))\n            return \", \".join(tmp)\n\n        res = []\n        for column in self.relationship_definitions:\n            column_args = get_column_args(column)\n            column_name = column.get('name')\n            cls_name = column.get(\"class\")\n            res.append(\n                ALCHEMY_TEMPLATES.relationship.safe_substitute(column_name=column_name,\n                                                               column_args=column_args,\n                                                               class_name=cls_name))\n        join_string = \"\\n\" + self.tab\n        return join_string.join(res)", "response": "Returns compiled relationship definitions for all tables in the database"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns names of all the addressable columns referenced in user supplied model", "response": "def columns(self):\n        \"\"\"Return names of all the addressable columns (including foreign keys) referenced in user supplied model\"\"\"\n        res = [col['name'] for col in self.column_definitions]\n        res.extend([col['name'] for col in self.foreign_key_definitions])\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compiled_init_func(self):\n\n        def get_column_assignment(column_name):\n            return ALCHEMY_TEMPLATES.col_assignment.safe_substitute(col_name=column_name)\n\n        def get_compiled_args(arg_name):\n            return ALCHEMY_TEMPLATES.func_arg.safe_substitute(arg_name=arg_name)\n\n        join_string = \"\\n\" + self.tab + self.tab\n        column_assignments = join_string.join([get_column_assignment(n) for n in self.columns])\n        init_args = \", \".join(get_compiled_args(n) for n in self.columns)\n        return ALCHEMY_TEMPLATES.init_function.safe_substitute(col_assignments=column_assignments,\n                                                               init_args=init_args)", "response": "Returns compiled init function"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compiled_update_func(self):\n\n        def get_not_none_col_assignment(column_name):\n            return ALCHEMY_TEMPLATES.not_none_col_assignment.safe_substitute(col_name=column_name)\n\n        def get_compiled_args(arg_name):\n            return ALCHEMY_TEMPLATES.func_arg.safe_substitute(arg_name=arg_name)\n\n        join_string = \"\\n\" + self.tab + self.tab\n        columns = [n for n in self.columns if n not in self.primary_keys]\n        not_none_col_assignments = join_string.join([get_not_none_col_assignment(n) for n in columns])\n        update_args = \", \".join(get_compiled_args(n) for n in columns)\n        return ALCHEMY_TEMPLATES.update_function.safe_substitute(not_none_col_assignments=not_none_col_assignments,\n                                                                 update_args=update_args,\n                                                                 class_name=self.class_name)", "response": "Returns compiled update function"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns compiled hash function based on hash of stringified primary keys.", "response": "def compiled_hash_func(self):\n        \"\"\"Returns compiled hash function based on hash of stringified primary_keys.\n        This isn't the most efficient way\"\"\"\n\n        def get_primary_key_str(pkey_name):\n            return \"str(self.{})\".format(pkey_name)\n\n        hash_str = \"+ \".join([get_primary_key_str(n) for n in self.primary_keys])\n        return ALCHEMY_TEMPLATES.hash_function.safe_substitute(concated_primary_key_strs=hash_str)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the compiled ORM class for the user supplied model", "response": "def compiled_model(self):\n        \"\"\"Returns compile ORM class for the user supplied model\"\"\"\n        return ALCHEMY_TEMPLATES.model.safe_substitute(class_name=self.class_name,\n                                                       table_name=self.table_name,\n                                                       column_definitions=self.compiled_columns,\n                                                       init_function=self.compiled_init_func,\n                                                       update_function=self.compiled_update_func,\n                                                       hash_function=self.compiled_hash_func,\n                                                       eq_function=self.compiled_eq_func,\n                                                       neq_function=self.compiled_neq_func,\n                                                       str_function=self.compiled_str_func,\n                                                       unicode_function=self.compiled_unicode_func,\n                                                       repr_function=self.compiled_repr_func,\n                                                       types=\", \".join(self.basic_types),\n                                                       username=self.username,\n                                                       foreign_keys=self.compiled_foreign_keys,\n                                                       relationships=self.compiled_relationships,\n                                                       named_imports=self.compiled_named_imports,\n                                                       orm_imports=self.compiled_orm_imports,\n                                                       get_proxy_cls_function=self.compiled_proxy_cls_func,\n                                                       add_function=ALCHEMY_TEMPLATES.add_function.template,\n                                                       delete_function=ALCHEMY_TEMPLATES.delete_function.template,\n                                                       to_dict_function=ALCHEMY_TEMPLATES.to_dict_function.template,\n                                                       to_proxy_function=ALCHEMY_TEMPLATES.to_proxy_function.template,\n                                                       from_proxy_function=ALCHEMY_TEMPLATES.from_proxy_function.template)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef put(self):\n        return self.manager.put(\n            id=self.id,\n            name=self.name,\n            description=self.description,\n            private=self.private,\n            runs_executable_tasks=self.runs_executable_tasks,\n            runs_docker_container_tasks=self.runs_docker_container_tasks,\n            runs_singularity_container_tasks=self.runs_singularity_container_tasks,\n            active=self.active,\n            whitelists=self.whitelists,\n        )", "response": "Updates this task queue on the saltant server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a task queue by id or name.", "response": "def get(self, id=None, name=None):\n        \"\"\"Get a task queue.\n\n        Either the id xor the name of the task type must be specified.\n\n        Args:\n            id (int, optional): The id of the task type to get.\n            name (str, optional): The name of the task type to get.\n\n        Returns:\n            :class:`saltant.models.task_queue.TaskQueue`:\n                A task queue model instance representing the task queue\n                requested.\n\n        Raises:\n            ValueError: Neither id nor name were set *or* both id and\n                name were set.\n        \"\"\"\n        # Validate arguments - use an xor\n        if not (id is None) ^ (name is None):\n            raise ValueError(\"Either id or name must be set (but not both!)\")\n\n        # If it's just ID provided, call the parent function\n        if id is not None:\n            return super(TaskQueueManager, self).get(id=id)\n\n        # Try getting the task queue by name\n        return self.list(filters={\"name\": name})[0]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new task queue.", "response": "def create(\n        self,\n        name,\n        description=\"\",\n        private=False,\n        runs_executable_tasks=True,\n        runs_docker_container_tasks=True,\n        runs_singularity_container_tasks=True,\n        active=True,\n        whitelists=None,\n    ):\n        \"\"\"Create a task queue.\n\n        Args:\n            name (str): The name of the task queue.\n            description (str, optional): A description of the task queue.\n            private (bool, optional): A boolean specifying whether the\n                queue is exclusive to its creator. Defaults to False.\n            runs_executable_tasks (bool, optional): A Boolean specifying\n                whether the queue runs executable tasks. Defaults to\n                True.\n            runs_docker_container_tasks (bool, optional): A Boolean\n                specifying whether the queue runs container tasks that\n                run in Docker containers. Defaults to True.\n            runs_singularity_container_tasks (bool, optional): A Boolean\n                specifying whether the queue runs container tasks that\n                run in Singularity containers. Defaults to True.\n            active (bool, optional): A boolean specifying whether the\n                queue is active. Default to True.\n            whitelists (list, optional): A list of task whitelist IDs.\n                Defaults to None (which gets translated to []).\n\n        Returns:\n            :class:`saltant.models.task_queue.TaskQueue`:\n                A task queue model instance representing the task queue\n                just created.\n        \"\"\"\n        # Translate whitelists None to [] if necessary\n        if whitelists is None:\n            whitelists = []\n\n        # Create the object\n        request_url = self._client.base_api_url + self.list_url\n        data_to_post = {\n            \"name\": name,\n            \"description\": description,\n            \"private\": private,\n            \"runs_executable_tasks\": runs_executable_tasks,\n            \"runs_docker_container_tasks\": runs_docker_container_tasks,\n            \"runs_singularity_container_tasks\": runs_singularity_container_tasks,\n            \"active\": active,\n            \"whitelists\": whitelists,\n        }\n\n        response = self._client.session.post(request_url, data=data_to_post)\n\n        # Validate that the request was successful\n        self.validate_request_success(\n            response_text=response.text,\n            request_url=request_url,\n            status_code=response.status_code,\n            expected_status_code=HTTP_201_CREATED,\n        )\n\n        # Return a model instance representing the task instance\n        return self.response_data_to_model_instance(response.json())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef patch(\n        self,\n        id,\n        name=None,\n        description=None,\n        private=None,\n        runs_executable_tasks=None,\n        runs_docker_container_tasks=None,\n        runs_singularity_container_tasks=None,\n        active=None,\n        whitelists=None,\n    ):\n        \"\"\"Partially updates a task queue on the saltant server.\n\n        Args:\n            id (int): The ID of the task queue.\n            name (str, optional): The name of the task queue.\n            description (str, optional): The description of the task\n                queue.\n            private (bool, optional): A Booleon signalling whether the\n                queue can only be used by its associated user.\n            runs_executable_tasks (bool, optional): A Boolean specifying\n                whether the queue runs executable tasks.\n            runs_docker_container_tasks (bool, optional): A Boolean\n                specifying whether the queue runs container tasks that\n                run in Docker containers.\n            runs_singularity_container_tasks (bool, optional): A Boolean\n                specifying whether the queue runs container tasks that\n                run in Singularity containers.\n            active (bool, optional): A Booleon signalling whether the\n                queue is active.\n            whitelists (list, optional): A list of task whitelist IDs.\n\n        Returns:\n            :class:`saltant.models.task_queue.TaskQueue`:\n                A task queue model instance representing the task queue\n                just updated.\n        \"\"\"\n        # Update the object\n        request_url = self._client.base_api_url + self.detail_url.format(id=id)\n\n        data_to_patch = {}\n\n        if name is not None:\n            data_to_patch[\"name\"] = name\n\n        if description is not None:\n            data_to_patch[\"description\"] = description\n\n        if private is not None:\n            data_to_patch[\"private\"] = private\n\n        if runs_executable_tasks is not None:\n            data_to_patch[\"runs_executable_tasks\"] = runs_executable_tasks\n\n        if runs_docker_container_tasks is not None:\n            data_to_patch[\n                \"runs_docker_container_tasks\"\n            ] = runs_docker_container_tasks\n\n        if runs_singularity_container_tasks is not None:\n            data_to_patch[\n                \"runs_singularity_container_tasks\"\n            ] = runs_singularity_container_tasks\n\n        if active is not None:\n            data_to_patch[\"active\"] = active\n\n        if whitelists is not None:\n            data_to_patch[\"whitelists\"] = whitelists\n\n        response = self._client.session.patch(request_url, data=data_to_patch)\n\n        # Validate that the request was successful\n        self.validate_request_success(\n            response_text=response.text,\n            request_url=request_url,\n            status_code=response.status_code,\n            expected_status_code=HTTP_200_OK,\n        )\n\n        # Return a model instance representing the task instance\n        return self.response_data_to_model_instance(response.json())", "response": "Partially updates a task queue on the saltant server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate a task queue on the saltant server.", "response": "def put(\n        self,\n        id,\n        name,\n        description,\n        private,\n        runs_executable_tasks,\n        runs_docker_container_tasks,\n        runs_singularity_container_tasks,\n        active,\n        whitelists,\n    ):\n        \"\"\"Updates a task queue on the saltant server.\n\n        Args:\n            id (int): The ID of the task queue.\n            name (str): The name of the task queue.\n            description (str): The description of the task queue.\n            private (bool): A Booleon signalling whether the queue can\n                only be used by its associated user.\n            runs_executable_tasks (bool): A Boolean specifying whether\n                the queue runs executable tasks.\n            runs_docker_container_tasks (bool): A Boolean specifying\n                whether the queue runs container tasks that run in\n                Docker containers.\n            runs_singularity_container_tasks (bool): A Boolean\n                specifying whether the queue runs container tasks that\n                run in Singularity containers.\n            active (bool): A Booleon signalling whether the queue is\n                active.\n            whitelists (list): A list of task whitelist IDs.\n\n        Returns:\n            :class:`saltant.models.task_queue.TaskQueue`:\n                A task queue model instance representing the task queue\n                just updated.\n        \"\"\"\n        # Update the object\n        request_url = self._client.base_api_url + self.detail_url.format(id=id)\n        data_to_put = {\n            \"name\": name,\n            \"description\": description,\n            \"private\": private,\n            \"runs_executable_tasks\": runs_executable_tasks,\n            \"runs_docker_container_tasks\": runs_docker_container_tasks,\n            \"runs_singularity_container_tasks\": runs_singularity_container_tasks,\n            \"active\": active,\n            \"whitelists\": whitelists,\n        }\n\n        response = self._client.session.put(request_url, data=data_to_put)\n\n        # Validate that the request was successful\n        self.validate_request_success(\n            response_text=response.text,\n            request_url=request_url,\n            status_code=response.status_code,\n            expected_status_code=HTTP_200_OK,\n        )\n\n        # Return a model instance representing the task instance\n        return self.response_data_to_model_instance(response.json())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main(self):\n        self.targets()\n        self.bait(k=49)\n        self.reversebait(maskmiddle='t', k=19)\n        self.subsample_reads()", "response": "Run the required methods in the appropriate order"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef targets(self):\n        for sample in self.runmetadata:\n            if sample.general.bestassemblyfile != 'NA':\n                setattr(sample, self.analysistype, GenObject())\n                sample[self.analysistype].runanalysis = True\n                sample[self.analysistype].targetpath = self.targetpath\n                baitpath = os.path.join(self.targetpath, 'bait')\n                sample[self.analysistype].baitfile = glob(os.path.join(baitpath, '*.fa'))[0]\n                try:\n                    sample[self.analysistype].outputdir = os.path.join(sample.run.outputdirectory, self.analysistype)\n                except AttributeError:\n                    sample[self.analysistype].outputdir = \\\n                        os.path.join(sample.general.outputdirectory, self.analysistype)\n                    sample.run.outputdirectory = sample.general.outputdirectory\n                sample[self.analysistype].logout = os.path.join(sample[self.analysistype].outputdir, 'logout.txt')\n                sample[self.analysistype].logerr = os.path.join(sample[self.analysistype].outputdir, 'logerr.txt')\n                sample[self.analysistype].baitedfastq = os.path.join(sample[self.analysistype].outputdir,\n                                                                     '{}_targetMatches.fastq'.format(self.analysistype))\n                sample[self.analysistype].complete = False", "response": "Create the GenObject for the analysis type and create the hash file for baiting"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef targets(self):\n        logging.info('Performing analysis with {} targets folder'.format(self.analysistype))\n        for sample in self.runmetadata:\n            if sample.general.bestassemblyfile != 'NA':\n                sample[self.analysistype].targetpath = \\\n                    os.path.join(self.targetpath, 'genera', sample[self.analysistype].genus, '')\n                # There is a relatively strict databasing scheme necessary for the custom targets. Eventually,\n                # there will be a helper script to combine individual files into a properly formatted combined file\n                try:\n                    sample[self.analysistype].mappingfile = glob('{}*.fa'\n                                                                 .format(sample[self.analysistype].targetpath))[0]\n                # If the fasta file is missing, raise a custom error\n                except IndexError as e:\n                    # noinspection PyPropertyAccess\n                    e.args = ['Cannot find the combined fasta file in {}. Please note that the file must have a '\n                              '.fasta extension'.format(sample[self.analysistype].targetpath)]\n                    if os.path.isdir(sample[self.analysistype].targetpath):\n                        raise\n                    else:\n                        sample.general.bestassemblyfile = 'NA'", "response": "Sets the targets folder and creates the mapping file for all the targets"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns the necessary methods in the correct order for the current sample.", "response": "def runner(self):\n        \"\"\"\n        Run the necessary methods in the correct order\n        \"\"\"\n        logging.info('Starting {} analysis pipeline'.format(self.analysistype))\n        if not self.pipeline:\n            # If the metadata has been passed from the method script, self.pipeline must still be false in order to\n            # get Sippr() to function correctly, but the metadata shouldn't be recreated\n            try:\n                _ = vars(self.runmetadata)['samples']\n            except AttributeError:\n                # Create the objects to be used in the analyses\n                objects = Objectprep(self)\n                objects.objectprep()\n                self.runmetadata = objects.samples\n\n        else:\n            for sample in self.runmetadata.samples:\n                setattr(sample, self.analysistype, GenObject())\n                sample.run.outputdirectory = sample.general.outputdirectory\n        self.threads = int(self.cpus / len(self.runmetadata.samples)) \\\n            if self.cpus / len(self.runmetadata.samples) > 1 \\\n            else 1\n        # Use a custom sippr method to use the full reference database as bait, and run mirabait against the FASTQ\n        # reads - do not perform reference mapping yet\n        SixteenSBait(self, self.cutoff)\n        # Subsample 1000 reads from the FASTQ files\n        self.subsample()\n        # Convert the subsampled FASTQ files to FASTA format\n        self.fasta()\n        # Create BLAST databases if required\n        self.makeblastdb()\n        # Run BLAST analyses of the subsampled FASTA files against the NCBI 16S reference database\n        self.blast()\n        # Parse the BLAST results\n        self.blastparse()\n        # Feed the BLAST results into a modified sippr method to perform reference mapping using the calculated\n        # genus of the sample as the mapping file\n        SixteenSSipper(self, self.cutoff)\n        # Create reports\n        self.reporter()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef subsample(self):\n        # Create the threads for the analysis\n        logging.info('Subsampling FASTQ reads')\n        for _ in range(self.cpus):\n            threads = Thread(target=self.subsamplethreads, args=())\n            threads.setDaemon(True)\n            threads.start()\n        with progressbar(self.runmetadata.samples) as bar:\n            for sample in bar:\n                if sample.general.bestassemblyfile != 'NA':\n                    # Set the name of the subsampled FASTQ file\n                    sample[self.analysistype].subsampledfastq = \\\n                        os.path.splitext(sample[self.analysistype].baitedfastq)[0] + '_subsampled.fastq'\n                    # Set the system call\n                    sample[self.analysistype].seqtkcall = 'reformat.sh in={} out={} samplereadstarget=1000'\\\n                        .format(sample[self.analysistype].baitedfastq,\n                                sample[self.analysistype].subsampledfastq)\n                    # Add the sample to the queue\n                    self.samplequeue.put(sample)\n        self.samplequeue.join()", "response": "Subsample 1000 reads from the baited files\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fasta(self):\n        logging.info('Converting FASTQ files to FASTA format')\n        # Create the threads for the analysis\n        for _ in range(self.cpus):\n            threads = Thread(target=self.fastathreads, args=())\n            threads.setDaemon(True)\n            threads.start()\n        with progressbar(self.runmetadata.samples) as bar:\n            for sample in bar:\n                if sample.general.bestassemblyfile != 'NA':\n                    # Set the name as the FASTA file - the same as the FASTQ, but with .fa file extension\n                    sample[self.analysistype].fasta = \\\n                        os.path.splitext(sample[self.analysistype].subsampledfastq)[0] + '.fa'\n                    # Set the system call\n                    sample[self.analysistype].reformatcall = 'reformat.sh in={fastq} out={fasta}'\\\n                        .format(fastq=sample[self.analysistype].subsampledfastq,\n                                fasta=sample[self.analysistype].fasta)\n                    # Add the sample to the queue\n                    self.fastaqueue.put(sample)\n        self.fastaqueue.join()", "response": "Convert the subsampled reads to FASTA format using reformat. sh"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking blast database files from targets as necessary", "response": "def makeblastdb(self):\n        \"\"\"\n        Makes blast database files from targets as necessary\n        \"\"\"\n        # Iterate through the samples to set the bait file.\n        for sample in self.runmetadata.samples:\n            if sample.general.bestassemblyfile != 'NA':\n                # Remove the file extension\n                db = os.path.splitext(sample[self.analysistype].baitfile)[0]\n                # Add '.nhr' for searching below\n                nhr = '{}.nhr'.format(db)\n                # Check for already existing database files\n                if not os.path.isfile(str(nhr)):\n                    # Create the databases\n                    command = 'makeblastdb -in {} -parse_seqids -max_file_sz 2GB -dbtype nucl -out {}'\\\n                        .format(sample[self.analysistype].baitfile, db)\n                    out, err = run_subprocess(command)\n                    write_to_logfile(command,\n                                     command,\n                                     self.logfile, sample.general.logout, sample.general.logerr,\n                                     sample[self.analysistype].logout, sample[self.analysistype].logerr)\n                    write_to_logfile(out,\n                                     err,\n                                     self.logfile, sample.general.logout, sample.general.logerr,\n                                     sample[self.analysistype].logout, sample[self.analysistype].logerr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef blast(self):\n        logging.info('BLASTing FASTA files against {} database'.format(self.analysistype))\n        for _ in range(self.cpus):\n            threads = Thread(target=self.blastthreads, args=())\n            threads.setDaemon(True)\n            threads.start()\n        with progressbar(self.runmetadata.samples) as bar:\n            for sample in bar:\n                if sample.general.bestassemblyfile != 'NA':\n                    # Set the name of the BLAST report\n                    sample[self.analysistype].blastreport = os.path.join(\n                        sample[self.analysistype].outputdir,\n                        '{}_{}_blastresults.csv'.format(sample.name, self.analysistype))\n                    # Use the NCBI BLASTn command line wrapper module from BioPython to set the parameters of the search\n                    blastn = NcbiblastnCommandline(query=sample[self.analysistype].fasta,\n                                                   db=os.path.splitext(sample[self.analysistype].baitfile)[0],\n                                                   max_target_seqs=1,\n                                                   num_threads=self.threads,\n                                                   outfmt=\"'6 qseqid sseqid positive mismatch gaps evalue \"\n                                                          \"bitscore slen length qstart qend qseq sstart send sseq'\",\n                                                   out=sample[self.analysistype].blastreport)\n                    # Add a string of the command to the metadata object\n                    sample[self.analysistype].blastcall = str(blastn)\n                    # Add the object and the command to the BLAST queue\n                    self.blastqueue.put((sample, blastn))\n        self.blastqueue.join()", "response": "Run BLAST analyses against the NCBI 16S reference database"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the BLAST results and store necessary data in dictionary objects in sample object", "response": "def blastparse(self):\n        \"\"\"\n        Parse the blast results, and store necessary data in dictionaries in sample object\n        \"\"\"\n        logging.info('Parsing BLAST results')\n        # Load the NCBI 16S reference database as a dictionary\n        for sample in self.runmetadata.samples:\n            if sample.general.bestassemblyfile != 'NA':\n                # Load the NCBI 16S reference database as a dictionary\n                dbrecords = SeqIO.to_dict(SeqIO.parse(sample[self.analysistype].baitfile, 'fasta'))\n                # Allow for no BLAST results\n                if os.path.isfile(sample[self.analysistype].blastreport):\n                    # Initialise a dictionary to store the number of times a genus is the best hit\n                    sample[self.analysistype].frequency = dict()\n                    # Open the sequence profile file as a dictionary\n                    blastdict = DictReader(open(sample[self.analysistype].blastreport),\n                                           fieldnames=self.fieldnames, dialect='excel-tab')\n                    recorddict = dict()\n                    for record in blastdict:\n                        # Create the subject id. It will look like this: gi|1018196593|ref|NR_136472.1|\n                        subject = record['subject_id']\n                        # Extract the genus name. Use the subject id as a key in the dictionary of the reference db.\n                        # It will return the full record e.g. gi|1018196593|ref|NR_136472.1| Escherichia marmotae\n                        # strain HT073016 16S ribosomal RNA, partial sequence\n                        # This full description can be manipulated to extract the genus e.g. Escherichia\n                        genus = dbrecords[subject].description.split('|')[-1].split()[0]\n                        # Increment the number of times this genus was found, or initialise the dictionary with this\n                        # genus the first time it is seen\n                        try:\n                            sample[self.analysistype].frequency[genus] += 1\n                        except KeyError:\n                            sample[self.analysistype].frequency[genus] = 1\n                        try:\n                            recorddict[dbrecords[subject].description] += 1\n                        except KeyError:\n                            recorddict[dbrecords[subject].description] = 1\n                    # Sort the dictionary based on the number of times a genus is seen\n                    sample[self.analysistype].sortedgenera = sorted(sample[self.analysistype].frequency.items(),\n                                                                    key=operator.itemgetter(1), reverse=True)\n                    try:\n                        # Extract the top result, and set it as the genus of the sample\n                        sample[self.analysistype].genus = sample[self.analysistype].sortedgenera[0][0]\n                        # Previous code relies on having the closest refseq genus, so set this as above\n                        # sample.general.closestrefseqgenus = sample[self.analysistype].genus\n                    except IndexError:\n                        # Populate attributes with 'NA'\n                        sample[self.analysistype].sortedgenera = 'NA'\n                        sample[self.analysistype].genus = 'NA'\n                        # sample.general.closestrefseqgenus = 'NA'\n                else:\n                    # Populate attributes with 'NA'\n                    sample[self.analysistype].sortedgenera = 'NA'\n                    sample[self.analysistype].genus = 'NA'\n                    # sample.general.closestrefseqgenus = 'NA'\n            else:\n                # Populate attributes with 'NA'\n                sample[self.analysistype].sortedgenera = 'NA'\n                sample[self.analysistype].genus = 'NA'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reporter(self):\n        # Create the path in which the reports are stored\n        make_path(self.reportpath)\n        logging.info('Creating {} report'.format(self.analysistype))\n        # Initialise the header and data strings\n        header = 'Strain,Gene,PercentIdentity,Genus,FoldCoverage\\n'\n        data = ''\n        with open(self.sixteens_report, 'w') as report:\n            with open(os.path.join(self.reportpath, self.analysistype + '_sequences.fa'), 'w') as sequences:\n                for sample in self.runmetadata.samples:\n                    # Initialise\n                    sample[self.analysistype].sixteens_match = 'NA'\n                    sample[self.analysistype].species = 'NA'\n                    try:\n                        # Select the best hit of all the full-length 16S genes mapped - for 16S use the hit with the\n                        # fewest number of SNPs rather than the highest percent identity\n                        sample[self.analysistype].besthit = sorted(sample[self.analysistype].resultssnp.items(),\n                                                                   key=operator.itemgetter(1))[0][0]\n                        # Parse the baited FASTA file to pull out the the description of the hit\n                        for record in SeqIO.parse(sample[self.analysistype].baitfile, 'fasta'):\n                            # If the best hit e.g. gi|631251361|ref|NR_112558.1| is present in the current record,\n                            # gi|631251361|ref|NR_112558.1| Escherichia coli strain JCM 1649 16S ribosomal RNA ...,\n                            # extract the match and the species\n                            if sample[self.analysistype].besthit in record.id:\n                                # Set the best match and species from the records\n                                sample[self.analysistype].sixteens_match = record.description.split(' 16S')[0]\n                                sample[self.analysistype].species = \\\n                                    sample[self.analysistype].sixteens_match.split('|')[-1].split()[1]\n                        # Add the sample name to the data string\n                        data += sample.name + ','\n                        # Find the record that matches the best hit, and extract the necessary values to be place in the\n                        # data string\n                        for name, identity in sample[self.analysistype].results.items():\n                            if name == sample[self.analysistype].besthit:\n                                data += '{},{},{},{}\\n'.format(name, identity, sample[self.analysistype].genus,\n                                                               sample[self.analysistype].avgdepth[name])\n                                # Create a FASTA-formatted sequence output of the 16S sequence\n                                record = SeqRecord(Seq(sample[self.analysistype].sequences[name],\n                                                       IUPAC.unambiguous_dna),\n                                                   id='{}_{}'.format(sample.name, '16S'),\n                                                   description='')\n                                SeqIO.write(record, sequences, 'fasta')\n                    except (AttributeError, IndexError):\n                        data += '{}\\n'.format(sample.name)\n            # Write the results to the report\n            report.write(header)\n            report.write(data)", "response": "Creates a report of the results of the current sample"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_listener(self, evt_name, fn):\n        self._listeners.setdefault(evt_name, [])\n        listeners = self.__get_listeners(evt_name)\n        listeners.append(fn)", "response": "add_listener - \u521b\u5efa event listener"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_listener(self, evt_name, fn, remove_all=False):\n        listeners = self.__get_listeners(evt_name)\n        if not self.has_listener(evt_name, fn):\n            raise ObservableError(\n                \"function %r does not exist in the %r event\",\n                fn, evt_name)\n        if remove_all:\n            listeners[:] = [i for i in listeners if i != fn]\n        else:\n            listeners.remove(fn)", "response": "remove_listener - remove a listener function from an event."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_listener(self, evt_name, fn):\n        listeners = self.__get_listeners(evt_name)\n        return fn in listeners", "response": "check if a listener exists"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfire event to all listeners", "response": "def fire_event(self, evt_name, *args, **kwargs):\n        \"\"\"\u89e6\u53d1\u4e8b\u4ef6\n\n        :params evt_name: \u4e8b\u4ef6\u540d\u79f0\n        :params args: \u7ed9\u4e8b\u4ef6\u63a5\u53d7\u8005\u7684\u53c2\u6570\n        :params kwargs: \u7ed9\u4e8b\u4ef6\u63a5\u53d7\u8005\u7684\u53c2\u6570\n        \"\"\"\n        listeners = self.__get_listeners(evt_name)\n        evt = self.generate_event(evt_name)\n        for listener in listeners:\n            listener(evt, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_server_ec2(connection,\n                      region,\n                      disk_name,\n                      disk_size,\n                      ami,\n                      key_pair,\n                      instance_type,\n                      tags={},\n                      security_groups=None,\n                      delete_on_termination=True,\n                      log=False,\n                      wait_for_ssh_available=True):\n    \"\"\"\n    Creates EC2 Instance\n    \"\"\"\n\n    if log:\n        log_green(\"Started...\")\n        log_yellow(\"...Creating EC2 instance...\")\n\n    ebs_volume = EBSBlockDeviceType()\n    ebs_volume.size = disk_size\n    bdm = BlockDeviceMapping()\n    bdm[disk_name] = ebs_volume\n\n    # get an ec2 ami image object with our choosen ami\n    image = connection.get_all_images(ami)[0]\n    # start a new instance\n    reservation = image.run(1, 1,\n                            key_name=key_pair,\n                            security_groups=security_groups,\n                            block_device_map=bdm,\n                            instance_type=instance_type)\n\n    # and get our instance_id\n    instance = reservation.instances[0]\n\n    #  and loop and wait until ssh is available\n    while instance.state == u'pending':\n        if log:\n            log_yellow(\"Instance state: %s\" % instance.state)\n        sleep(10)\n        instance.update()\n    if log:\n        log_green(\"Instance state: %s\" % instance.state)\n    if wait_for_ssh_available:\n        wait_for_ssh(instance.public_dns_name)\n\n    # update the EBS volumes to be deleted on instance termination\n    if delete_on_termination:\n        for dev, bd in instance.block_device_mapping.items():\n            instance.modify_attribute('BlockDeviceMapping',\n                                      [\"%s=%d\" % (dev, 1)])\n\n    # add a tag to our instance\n    connection.create_tags([instance.id], tags)\n\n    if log:\n        log_green(\"Public dns: %s\" % instance.public_dns_name)\n\n    # returns our new instance\n    return instance", "response": "Create a server EC2 instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef destroy_ebs_volume(connection, region, volume_id, log=False):\n\n    if ebs_volume_exists(connection, region, volume_id):\n        if log:\n            log_yellow('destroying EBS volume ...')\n        try:\n            connection.delete_volume(volume_id)\n        except:\n            # our EBS volume may be gone, but AWS info tables are stale\n            # wait a bit and ask again\n            sleep(5)\n            if not ebs_volume_exists(connection, region, volume_id):\n                pass\n            else:\n                raise(\"Couldn't delete EBS volume\")", "response": "destroys an EBS volume"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef destroy_ec2(connection, region, instance_id, log=False):\n\n    data = get_ec2_info(connection=connection,\n                        instance_id=instance_id,\n                        region=region)\n\n    instance = connection.terminate_instances(instance_ids=[data['id']])[0]\n    if log:\n        log_yellow('destroying instance ...')\n    while instance.state != \"terminated\":\n        if log:\n            log_yellow(\"Instance state: %s\" % instance.state)\n        sleep(10)\n        instance.update()\n    volume_id = data['volume']\n    if volume_id:\n        destroy_ebs_volume(connection, region, volume_id)", "response": "terminate the EC2 instance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef down_ec2(connection, instance_id, region, log=False):\n    # get the instance_id from the state file, and stop the instance\n    instance = connection.stop_instances(instance_ids=instance_id)[0]\n    while instance.state != \"stopped\":\n        if log:\n            log_yellow(\"Instance state: %s\" % instance.state)\n        sleep(10)\n        instance.update()\n    if log:\n        log_green('Instance state: %s' % instance.state)", "response": "Shutdown an EC2 instance"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if a ebs volume exists", "response": "def ebs_volume_exists(connection, region, volume_id):\n    \"\"\" finds out if a ebs volume exists \"\"\"\n    for vol in connection.get_all_volumes():\n        if vol.id == volume_id:\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_ec2_info(connection,\n                 instance_id,\n                 region,\n                 username=None):\n    \"\"\" queries EC2 for details about a particular instance_id\n    \"\"\"\n    instance = connection.get_only_instances(\n        filters={'instance_id': instance_id}\n        )[0]\n\n    data = instance.__dict__\n    data['state'] = instance.state\n    data['cloud_type'] = 'ec2'\n\n    try:\n        volume = connection.get_all_volumes(\n            filters={'attachment.instance-id': instance.id}\n        )[0].id\n        data['volume'] = volume\n    except:\n        data['volume'] = ''\n    return data", "response": "queries EC2 for details about a particular instance_id\nWorkItem"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef up_ec2(connection,\n           region,\n           instance_id,\n           wait_for_ssh_available=True,\n           log=False,\n           timeout=600):\n    \"\"\" boots an existing ec2_instance \"\"\"\n\n    # boot the ec2 instance\n    instance = connection.start_instances(instance_ids=instance_id)[0]\n    instance.update()\n    while instance.state != \"running\" and timeout > 1:\n        log_yellow(\"Instance state: %s\" % instance.state)\n        if log:\n            log_yellow(\"Instance state: %s\" % instance.state)\n        sleep(10)\n        timeout = timeout - 10\n        instance.update()\n\n    # and make sure we don't return until the instance is fully up\n    if wait_for_ssh_available:\n        wait_for_ssh(instance.ip_address)", "response": "boot an ec2 instance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef seqs_from_file(filename, exit_on_err=False, return_qual=False):\n   # VALIDATE INPUT\n   if not isinstance(filename, str):\n      msg = 'Filename has to be a string.'\n      if exit_on_err:\n         sys.stderr.write('Error: %s\\n'%msg)\n         sys.exit(1)\n      else: raise IOError(msg)\n   if not os.path.exists(filename):\n      msg = 'File \"%s\" does not exist.'%filename\n      if exit_on_err:\n         sys.stderr.write('Error: %s\\n'%msg)\n         sys.exit(1)\n      else: raise IOError(msg)\n   \n   # EXTRACT DATA\n   with open_(filename,\"rt\") as f:\n      query_seq_segments = []\n      seq, name, desc, qual = '', '', '', ''\n      add_segment = query_seq_segments.append\n      for l in f:\n         if len(l.strip()) == 0: continue\n         #sys.stderr.write(\"%s\\n\"%line)\n         fields=l.strip().split()\n         if l.startswith(\">\"):\n            # FASTA HEADER FOUND\n            if query_seq_segments != []:\n               # YIELD SEQUENCE AND RESET\n               seq = ''.join(query_seq_segments)\n               yield (seq, name, desc)\n               seq, name, desc = '', '', ''\n               del query_seq_segments[:]\n            name = fields[0][1:]\n            desc = ' '.join(fields[1:])\n         \n         elif l.startswith(\"@\"):\n            # FASTQ HEADER FOUND\n            name = fields[0][1:]\n            desc = ' '.join(fields[1:])\n            try:\n               # EXTRACT FASTQ SEQUENCE\n               seq  = next(f).strip().split()[0]\n               # SKIP SECOND HEADER LINE AND QUALITY SCORES\n               l = next(f)\n               qual = next(f).strip() # Qualities\n            except:\n               break\n            else:\n               # YIELD SEQUENCE AND RESET\n               if return_qual:\n                  yield (seq, qual, name, desc)\n               else:\n                  yield (seq, name, desc)\n               seq, name, desc, qual = '', '', '', ''\n         \n         elif len(fields[0])>0:\n            # EXTRACT FASTA SEQUENCE\n            add_segment(fields[0])\n      \n      # CHECK FOR LAST FASTA SEQUENCE\n      if query_seq_segments != []:\n         # YIELD SEQUENCE\n         seq = ''.join(query_seq_segments)\n         yield (seq, name, desc)", "response": "Extract sequences from a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open_(filename, mode=None, compresslevel=9):\n   if filename[-3:] == '.gz':\n      if mode is None: mode = 'rt'\n      return closing(gzip.open(filename, mode, compresslevel))\n   else:\n      if mode is None: mode = 'r'\n      return open(filename, mode)", "response": "Open a file and return a file object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads json from file or file name", "response": "def load_json(json_object):\n   ''' Load json from file or file name '''\n   content = None\n   if isinstance(json_object, str) and os.path.exists(json_object):\n      with open_(json_object) as f:\n         try:\n            content = json.load(f)\n         except Exception as e:\n            debug.log(\"Warning: Content of '%s' file is not json.\"%f.name)\n   elif hasattr(json_object, 'read'):\n      try:\n         content = json.load(json_object)\n      except Exception as e:\n         debug.log(\"Warning: Content of '%s' file is not json.\"%json_object.name)\n   else:\n      debug.log(\"%s\\nWarning: Object type invalid!\"%json_object)\n   return content"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsorts an array of strings to groups by patterns", "response": "def sort2groups(array, gpat=['_R1','_R2']):\n   \"\"\" Sort an array of strings to groups by patterns \"\"\"\n   groups = [REGroup(gp) for gp in gpat]\n   unmatched = []\n   for item in array:\n      matched = False\n      for m in groups:\n         if m.match(item):\n            matched = True\n            break\n      if not matched: unmatched.append(item)\n   return [sorted(m.list) for m in groups], sorted(unmatched)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sort_and_distribute(array, splits=2):\n   if not isinstance(array, (list,tuple)): raise TypeError(\"array must be a list\")\n   if not isinstance(splits, int): raise TypeError(\"splits must be an integer\")\n   remaining = sorted(array)\n   if sys.version_info < (3, 0):\n      myrange = xrange(splits)\n   else:\n      myrange = range(splits)\n   groups = [[] for i in myrange]\n   while len(remaining) > 0:\n      for i in myrange:\n         if len(remaining) > 0: groups[i].append(remaining.pop(0))\n   return groups", "response": "Sort an array of strings to groups by alphabetically continuous\n       distribution\n  "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mkpath(filepath, permissions=0o777):\n   # Converting string of octal to integer, if string is given.\n   if isinstance(permissions, str):\n      permissions = sum([int(x)*8**i for i,x in enumerate(reversed(permissions))])\n   # Creating directory\n   if not os.path.exists(filepath):\n      debug.log(\"Creating Directory %s (permissions: %s)\"%(\n         filepath, permissions))\n      os.makedirs(filepath, permissions)\n   else:\n      debug.log(\"Warning: The directory \"+ filepath +\" already exists\")\n   return filepath", "response": "This function creates a directory and returns the path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_zip_dir(zipfile_path, *file_list):\n   try:\n      if isinstance(file_list, (list, tuple)): #unfolding list of list or tuple\n         if len(file_list) == 1:\n            if isinstance(file_list[0], (list, tuple)): file_list = file_list[0]\n      #converting string to iterable list\n      if isinstance(file_list, str): file_list = [file_list]\n      if file_list:\n         with ZipFile(zipfile_path, 'w') as zf:\n            for cur_file in file_list:\n               if '/' in cur_file:\n                  os.chdir('/'.join(cur_file.split('/')[:-1]))\n               elif '/' in zipfile_path:\n                  os.chdir('/'.join(zipfile_path.split('/')[:-1]))\n               zf.write(cur_file.split('/')[-1])\n      else:\n         debug.log('Error: No Files in list!',zipfile_path+' was not created!')\n   except Exception as e:\n      debug.log('Error: Could not create zip dir! argtype: '+\n                 str(type(file_list)), \"FileList: \"+ str(file_list),\n                 \"Errormessage: \"+ str(e))", "response": "This function creates a zipfile located in zipFilePath with the files in file_list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef file_zipper(root_dir):\n   # FINDING AND ZIPPING UNZIPPED FILES\n   for root, dirs, files in os.walk(root_dir, topdown=False):\n      if root != \"\":\n         if root[-1] != '/': root += '/'\n         for current_file in files:\n            filepath = \"%s/%s\"%(root, current_file)\n            try:\n               file_size = os.path.getsize(filepath)\n            except Exception as e:\n               file_size = 0\n               debug.log('Error: file_zipper failed to zip following file '+filepath, e)\n            # Excluding small files, gzipped files and links\n            if (         file_size > 50\n                 and     current_file[-3:] != \".gz\"\n                 and not os.path.islink(filepath)\n               ):\n               if current_file[-4:] == \".zip\":\n                  # Unzip file\n                  ec = Popen('unzip -qq \"%s\" -d %s > /dev/null 2>&1'%(filepath, root), shell=True).wait()\n                  if ec > 0:\n                     debug.log('Error: fileZipper failed to unzip following file %s'%filepath)\n                     continue\n                  else:\n                     ec = Popen('rm -f \"%s\" > /dev/null 2>&1'%(filepath), shell=True).wait()\n                     if ec > 0: debug.log('Error: fileZipper failed to delete the original zip file (%s)'%filepath)\n                     filepath = filepath[:-4]\n                  # Saving a gzipped version\n                  with open_(filepath, 'rb') as f, open_(filepath+\".gz\", 'wb', 9) as gz:\n                     gz.writelines(f)\n                  # Deleting old (non-zipped) file\n                  try: os.remove(filepath)\n                  except OSError as e:\n                     debug.log((\"WARNING! The file %s could not be \"\n                                    \"removed!\\n%s\")%(current_file, e))", "response": "This function will zip the files created in the runroot directory and all subdirectories of the runroot directory."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef move_file(src, dst):\n   # Sanity checkpoint\n   src = re.sub('[^\\w/\\-\\.\\*]', '', src)\n   dst = re.sub('[^\\w/\\-\\.\\*]', '', dst)\n   if len(re.sub('[\\W]', '', src)) < 5 or len(re.sub('[\\W]', '', dst)) < 5:\n      debug.log(\"Error: Moving file failed. Provided paths are invalid! src='%s' dst='%s'\"%(src, dst))\n   else:\n      # Check destination\n      check = False\n      if dst[-1] == '/':\n         if os.path.exists(dst):\n            check = True # Valid Dir\n         else:\n            debug.log(\"Error: Moving file failed. Destination directory does not exist (%s)\"%(dst)) #DEBUG\n      elif os.path.exists(dst):\n         if os.path.isdir(dst):\n            check = True # Valid Dir\n            dst += '/' # Add missing slash\n         else:\n            debug.log(\"Error: Moving file failed. %s exists!\"%dst)\n      elif os.path.exists(os.path.dirname(dst)):\n         check = True # Valid file path\n      else:\n         debug.log(\"Error: Moving file failed. %s is an invalid distination!\"%dst)\n      if check:\n         # Check source\n         files = glob.glob(src)\n         if len(files) != 0:\n            debug.log(\"Moving File(s)...\", \"Move from %s\"%src, \"to %s\"%dst)\n            for file_ in files:\n               # Check if file contains invalid symbols:\n               invalid_chars = re.findall('[^\\w/\\-\\.\\*]', os.path.basename(file_))\n               if invalid_chars:\n                  debug.graceful_exit((\"Error: File %s contains invalid \"\n                                      \"characters %s!\"\n                                      )%(os.path.basename(file_), invalid_chars))\n                  continue\n               # Check file exists\n               if os.path.isfile(file_):\n                  debug.log(\"Moving file: %s\"%file_)\n                  shutil.move(file_, dst)\n               else:\n                  debug.log(\"Error: Moving file failed. %s is not a regular file!\"%file_)\n         else: debug.log(\"Error: Moving file failed. No files were found! (%s)\"%src)", "response": "This function will move a file from one path to another."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef copy_file(src, dst, ignore=None):\n   # Sanity checkpoint\n   src = re.sub('[^\\w/\\-\\.\\*]', '', src)\n   dst = re.sub('[^\\w/\\-\\.\\*]', '', dst)\n   if len(re.sub('[\\W]', '', src)) < 5 or len(re.sub('[\\W]', '', dst)) < 5:\n      debug.log(\"Error: Copying file failed. Provided paths are invalid! src='%s' dst='%s'\"%(src, dst))\n   else:\n      # Check destination\n      check = False\n      if dst[-1] == '/':\n         if os.path.exists(dst):\n            check = True # Valid Dir\n         else:\n            debug.log(\"Error: Copying file failed. Destination directory does not exist (%s)\"%(dst)) #DEBUG\n      elif os.path.exists(dst):\n         if os.path.isdir(dst):\n            check = True # Valid Dir\n            dst += '/' # Add missing slash\n         else:\n            debug.log(\"Error: Copying file failed. %s exists!\"%dst)\n      elif os.path.exists(os.path.dirname(dst)):\n         check = True # Valid file path\n      else:\n         debug.log(\"Error: Copying file failed. %s is an invalid distination!\"%dst)\n      if check:\n         # Check source\n         files = glob.glob(src)\n         if ignore is not None: files = [fil for fil in files if not ignore in fil]\n         if len(files) != 0:\n            debug.log(\"Copying File(s)...\", \"Copy from %s\"%src, \"to %s\"%dst) #DEBUG\n            for file_ in files:\n               # Check file exists\n               if os.path.isfile(file_):\n                  debug.log(\"Copying file: %s\"%file_) #DEBUG\n                  shutil.copy(file_, dst)\n               else:\n                  debug.log(\"Error: Copying file failed. %s is not a regular file!\"%file_) #DEBUG\n         else: debug.log(\"Error: Copying file failed. No files were found! (%s)\"%src)", "response": "This function will copy a file from one path to another."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copy_dir(src, dst):\n   try:\n      debug.log(\"copy dir from \"+ src, \"to \"+ dst)\n      shutil.copytree(src, dst)\n   except Exception as e:\n      debug.log(\"Error: happened while copying!\\n%s\\n\"%e)", "response": "this function will simply copy the file from the source path to the destination path given as input\n  "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef print_out(self, *lst):\n      self.print2file(self.stdout, True, True, *lst)", "response": "Print list of strings to the predefined stdout."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprint list of strings to the predefined stderr.", "response": "def print_err(self, *lst):\n      \"\"\" Print list of strings to the predefined stdout. \"\"\"\n      self.print2file(self.stderr, False, True, *lst)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef print2file(self, logfile, print2screen, addLineFeed, *lst):\n      if addLineFeed:\n         linefeed = '\\n'\n      else: linefeed = ''\n      if print2screen: print(linefeed.join(str(string) for string in lst))\n      try: file_instance = isinstance(logfile, file)\n      except NameError as e:\n         from io import IOBase\n         try: file_instance = isinstance(logfile, IOBase)\n         except: raise e\n      if file_instance:\n         logfile.write(linefeed.join(str(string) for string in lst) + linefeed)\n      elif isinstance(logfile, str) and os.path.exists(logfile):\n         with open_(logfile, 'a') as f:\n            f.write(linefeed.join(str(string) for string in lst) + linefeed)\n      elif not print2screen: # Print to screen if there is no outputfile\n         print(linefeed.join(str(string) for string in lst))", "response": "This function prints to the screen and logs to a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef log(self, *lst):\n      self.print2file(self.logfile, self.debug, True, *lst)\n      if 'Error' in '\\n'.join([str(x) for x in lst]):\n         self.caught_error = '\\n'.join([str(x) for x in lst])", "response": "Print list of strings to the predefined logfile if debug is set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting a message to the predefined log file without a newline.", "response": "def log_no_newline(self, msg):\n      \"\"\" print the message to the predefined log file without newline \"\"\"\n      self.print2file(self.logfile, False, False, msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_tree(self, list_of_keys):\n      cur_obj = self\n      for key in list_of_keys:\n         cur_obj = cur_obj.get(key)\n         if not cur_obj: break\n      return cur_obj", "response": "This function will extract the value from a nested dictionary and return it."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn inverse mapping of dictionary with sorted values.", "response": "def invert(self):\n      ''' Return inverse mapping of dictionary with sorted values.\n      USAGE\n         >>> # Switch the keys and values\n         >>> adv_dict({\n         ...     'A': [1, 2, 3],\n         ...     'B': [4, 2],\n         ...     'C': [1, 4],\n         ... }).invert()\n         {1: ['A', 'C'], 2: ['A', 'B'], 3: ['A'], 4: ['B', 'C']}\n      '''\n      inv_map = {}\n      for k, v in self.items():\n         if sys.version_info < (3, 0):\n            acceptable_v_instance = isinstance(v, (str, int, float, long))\n         else:\n            acceptable_v_instance = isinstance(v, (str, int, float))\n         if acceptable_v_instance: v = [v]\n         elif not isinstance(v, list):\n            raise Exception('Error: Non supported value format! Values may only'\n                            ' be numerical, strings, or lists of numbers and '\n                            'strings.')\n         for val in v:\n            inv_map[val] = inv_map.get(val, [])\n            inv_map[val].append(k)\n            inv_map[val].sort()\n      return inv_map"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreplacing the string with the given string.", "response": "def sub(self, replace, string, count=0):\n      \"\"\" returns new string where the matching cases (limited by the count) in\n      the string is replaced. \"\"\"\n      return self.re.sub(replace, string, count)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmatches the given string to the stored regular expression and stores all groups in mathches. Returns True on success.", "response": "def match(self, s):\n      \"\"\" Matches the string to the stored regular expression, and stores all\n      groups in mathches. Returns False on negative match. \"\"\"\n      self.matches = self.re.search(s)\n      return self.matches"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if the pattern matches the input string returns False otherwise", "response": "def match(self, s):\n      \"\"\" Matching the pattern to the input string, returns True/False and\n          saves the matched string in the internal list\n      \"\"\"\n      if self.re.match(s):\n         self.list.append(s)\n         return True\n      else: return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating the MASH report", "response": "def reporter(self):\n        \"\"\"\n        Create the MASH report\n        \"\"\"\n        logging.info('Creating {} report'.format(self.analysistype))\n        make_path(self.reportpath)\n        header = 'Strain,ReferenceGenus,ReferenceFile,ReferenceGenomeMashDistance,Pvalue,NumMatchingHashes\\n'\n        data = ''\n        for sample in self.metadata:\n            try:\n                data += '{},{},{},{},{},{}\\n'.format(sample.name,\n                                                     sample[self.analysistype].closestrefseqgenus,\n                                                     sample[self.analysistype].closestrefseq,\n                                                     sample[self.analysistype].mashdistance,\n                                                     sample[self.analysistype].pvalue,\n                                                     sample[self.analysistype].nummatches)\n            except AttributeError:\n                data += '{}\\n'.format(sample.name)\n        # Create the report file\n        reportfile = os.path.join(self.reportpath, 'mash.csv')\n        with open(reportfile, 'w') as report:\n            report.write(header)\n            report.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_function(pkgpath):\n    # Extract the module and function name from pkgpath\n    elems = pkgpath.split('.')\n    if len(elems) <= 1:\n        raise PyMacaronCoreException(\"Path %s is too short. Should be at least module.func.\" % elems)\n    func_name = elems[-1]\n    func_module = '.'.join(elems[0:-1])\n\n    # Load the function's module and get the function\n    try:\n        m = import_module(func_module)\n        f = getattr(m, func_name)\n        return f\n    except Exception as e:\n        t = traceback.format_exc()\n        raise PyMacaronCoreException(\"Failed to import %s: %s\\nTrace:\\n%s\" % (pkgpath, str(e), t))", "response": "Take a full path to a python method or class for example\n    mypkg. subpkg. method and return the method or class"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef runner(self):\n        printtime('Starting {} analysis pipeline'.format(self.analysistype), self.starttime)\n        # Create the objects to be used in the analyses\n        objects = Objectprep(self)\n        objects.objectprep()\n        self.runmetadata = objects.samples\n        # Run the analyses\n        sippr = Sippr(self, self.cutoff)\n        sippr.clear()\n        # Print the metadata\n        printer = MetadataPrinter(self)\n        printer.printmetadata()", "response": "Run the necessary methods in the correct order."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsyllabifying the given word whether simplex or complex.", "response": "def syllabify(word):\n    '''Syllabify the given word, whether simplex or complex.'''\n    word = split(word)  # detect any non-delimited compounds\n    compound = True if re.search(r'-| |\\.', word) else False\n    syllabify = _syllabify_compound if compound else _syllabify\n    syll, rules = syllabify(word)\n\n    yield syll, rules\n\n    n = 3\n\n    if 'T4' in rules:\n        yield syllabify(word, T4=False)\n        n -= 1\n\n    if 'e' in rules:\n        yield syllabify(word, T1E=False)\n        n -= 1\n\n    if 'e' in rules and 'T4' in rules:\n        yield syllabify(word, T4=False, T1E=False)\n        n -= 1\n\n    # yield empty syllabifications and rules\n    for n in range(7):\n        yield '', ''"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef edges(self):\n        edge_str = ctypes.create_string_buffer(MAX_CHARS)\n\n        cgaddag.gdg_edges(self.gdg, self.node, edge_str)\n\n        return [char for char in edge_str.value.decode(\"ascii\")]", "response": "Return the edge characters of this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef letter_set(self):\n        end_str = ctypes.create_string_buffer(MAX_CHARS)\n\n        cgaddag.gdg_letter_set(self.gdg, self.node, end_str)\n\n        return [char for char in end_str.value.decode(\"ascii\")]", "response": "Return the letter set of this node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if this char is part of this node s letter set False otherwise.", "response": "def is_end(self, char):\n        \"\"\"\n        Return `True` if this `char` is part of this node's letter set,\n        `False` otherwise.\n        \"\"\"\n        char = char.lower()\n\n        return bool(cgaddag.gdg_is_end(self.gdg, self.node, char.encode(\"ascii\")))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef follow(self, chars):\n        chars = chars.lower()\n\n        node = self.node\n        for char in chars:\n            node = cgaddag.gdg_follow_edge(self.gdg, node, char.encode(\"ascii\"))\n            if not node:\n                raise KeyError(char)\n\n        return Node(self.gdg, node)", "response": "Traverse the GADDAG to the node at the end of the given characters."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsplit a docker link string into a list of 3 items.", "response": "def _split_docker_link(alias_name):\n    \"\"\"\n    Splits a docker link string into a list of 3 items (protocol, host, port).\n    - Assumes IPv4 Docker links\n\n    ex: _split_docker_link('DB') -> ['tcp', '172.17.0.82', '8080']\n    \"\"\"\n    sanitized_name = alias_name.strip().upper()\n    split_list = re.split(r':|//', core.str('{0}_PORT'.format(sanitized_name)))\n    # filter out empty '' vals from the list with filter and\n    # cast to list (required for python3)\n    return list(filter(None, split_list))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the raw docker link value.", "response": "def read(alias_name, allow_none=False):\n    \"\"\"Get the raw docker link value.\n\n    Get the raw environment variable for the docker link\n\n    Args:\n        alias_name: The environment variable name\n        default: The default value if the link isn't available\n        allow_none: If the return value can be `None` (i.e. optional)\n    \"\"\"\n    warnings.warn('Will be removed in v1.0', DeprecationWarning, stacklevel=2)\n    return core.read('{0}_PORT'.format(alias_name), default=None, allow_none=allow_none)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef isset(alias_name):\n    warnings.warn('Will be removed in v1.0', DeprecationWarning, stacklevel=2)\n    raw_value = read(alias_name, allow_none=True)\n    if raw_value:\n        if re.compile(r'.+://.+:\\d+').match(raw_value):\n            return True\n        else:\n            warnings.warn('\"{0}_PORT={1}\" does not look like a docker link.'.format(alias_name, raw_value), stacklevel=2)\n            return False\n\n    return False", "response": "Return a boolean if the docker link is set or not."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the protocol from the docker link alias or return the default value.", "response": "def protocol(alias_name, default=None, allow_none=False):\n    \"\"\"Get the protocol from the docker link alias or return the default.\n\n    Args:\n        alias_name: The docker link alias\n        default: The default value if the link isn't available\n        allow_none: If the return value can be `None` (i.e. optional)\n\n    Examples:\n        Assuming a Docker link was created with ``docker --link postgres:db``\n        and the resulting environment variable is ``DB_PORT=tcp://172.17.0.82:5432``.\n\n        >>> envitro.docker.protocol('DB')\n        tcp\n    \"\"\"\n    warnings.warn('Will be removed in v1.0', DeprecationWarning, stacklevel=2)\n    try:\n        return _split_docker_link(alias_name)[0]\n    except KeyError as err:\n        if default or allow_none:\n            return default\n        else:\n            raise err"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the port from the docker link alias or return the default value.", "response": "def port(alias_name, default=None, allow_none=False):\n    \"\"\"Get the port from the docker link alias or return the default.\n\n    Args:\n        alias_name: The docker link alias\n        default: The default value if the link isn't available\n        allow_none: If the return value can be `None` (i.e. optional)\n\n    Examples:\n        Assuming a Docker link was created with ``docker --link postgres:db``\n        and the resulting environment variable is ``DB_PORT=tcp://172.17.0.82:5432``.\n\n        >>> envitro.docker.port('DB')\n        5432\n    \"\"\"\n    warnings.warn('Will be removed in v1.0', DeprecationWarning, stacklevel=2)\n    try:\n        return int(_split_docker_link(alias_name)[2])\n    except KeyError as err:\n        if default or allow_none:\n            return default\n        else:\n            raise err"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the necessary methods in the correct order.", "response": "def runner(self):\n        \"\"\"\n        Run the necessary methods in the correct order\n        \"\"\"\n        printtime('Starting {} analysis pipeline'.format(self.analysistype), self.starttime)\n        if not self.pipeline:\n            # If the metadata has been passed from the method script, self.pipeline must still be false in order to\n            # get Sippr() to function correctly, but the metadata shouldn't be recreated\n            try:\n                _ = vars(self.runmetadata)['samples']\n            except KeyError:\n                # Create the objects to be used in the analyses\n                objects = Objectprep(self)\n                objects.objectprep()\n                self.runmetadata = objects.samples\n            # Run the analyses\n            Sippr(self, self.cutoff)\n            #\n            self.attributer()\n            # Create the reports\n            self.reporter()\n            # Print the metadata\n            printer = MetadataPrinter(self)\n            printer.printmetadata()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef attributer(self):\n        from Bio import SeqIO\n        import operator\n        for sample in self.runmetadata.samples:\n            # Load the records from the target file into a dictionary\n            record_dict = SeqIO.to_dict(SeqIO.parse(sample[self.analysistype].baitfile, \"fasta\"))\n            sample[self.analysistype].classification = set()\n            sample[self.analysistype].genera = dict()\n            # Add all the genera with hits into the set of genera\n            for result in sample[self.analysistype].results:\n                genus, species = record_dict[result].description.split('|')[-1].split()[:2]\n                sample[self.analysistype].classification.add(genus)\n                sample[self.analysistype].genera[result] = genus\n            # Convert the set to a list for easier JSON serialisation\n            sample[self.analysistype].classification = list(sample[self.analysistype].classification)\n            # If there is a mixed sample, then further analyses will be complicated\n            if len(sample[self.analysistype].classification) > 1:\n                # print('multiple: ', sample.name, sample[self.analysistype].classification)\n                sample.general.closestrefseqgenus = sample[self.analysistype].classification\n                # sample.general.bestassemblyfile = 'NA'\n                sample[self.analysistype].multiple = True\n            else:\n                sample[self.analysistype].multiple = False\n\n                try:\n                    # Recreate the results dictionary with the percent identity as a float rather than a string\n                    sample[self.analysistype].intresults = \\\n                        {key: float(value) for key, value in sample[self.analysistype].results.items()}\n                    # Set the best hit to be the top entry from the sorted results\n                    sample[self.analysistype].besthit = sorted(sample[self.analysistype].intresults.items(),\n                                                               key=operator.itemgetter(1), reverse=True)[0]\n                    sample.general.closestrefseqgenus = sample[self.analysistype].classification[0]\n                except IndexError:\n                    sample.general.bestassemblyfile = 'NA'", "response": "Parses the 16S target files to link accession numbers stored in the. fai and the. metadata files to the genera stored in the. genera file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nspawns a REST API.", "response": "def spawn_server_api(api_name, app, api_spec, error_callback, decorator):\n    \"\"\"Take a a Flask app and a swagger file in YAML format describing a REST\n    API, and populate the app with routes handling all the paths and methods\n    declared in the swagger file.\n\n    Also handle marshaling and unmarshaling between json and object instances\n    representing the definitions from the swagger file.\n    \"\"\"\n\n    def mycallback(endpoint):\n        handler_func = get_function(endpoint.handler_server)\n\n        # Generate api endpoint around that handler\n        handler_wrapper = _generate_handler_wrapper(api_name, api_spec, endpoint, handler_func, error_callback, decorator)\n\n        # Bind handler to the API path\n        log.info(\"Binding %s %s ==> %s\" % (endpoint.method, endpoint.path, endpoint.handler_server))\n        endpoint_name = '_'.join([endpoint.method, endpoint.path]).replace('/', '_')\n        app.add_url_rule(endpoint.path, endpoint_name, handler_wrapper, methods=[endpoint.method])\n\n\n    api_spec.call_on_each_endpoint(mycallback)\n\n    # Add custom error handlers to the app\n    add_error_handlers(app)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake a bravado - core model representing an error and return a Flask Response containing the given error code and error instance as body", "response": "def _responsify(api_spec, error, status):\n    \"\"\"Take a bravado-core model representing an error, and return a Flask Response\n    with the given error code and error instance as body\"\"\"\n    result_json = api_spec.model_to_json(error)\n    r = jsonify(result_json)\n    r.status_code = status\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a handler function for the given url method + path and operation", "response": "def _generate_handler_wrapper(api_name, api_spec, endpoint, handler_func, error_callback, global_decorator):\n    \"\"\"Generate a handler method for the given url method+path and operation\"\"\"\n\n    # Decorate the handler function, if Swagger spec tells us to\n    if endpoint.decorate_server:\n        endpoint_decorator = get_function(endpoint.decorate_server)\n        handler_func = endpoint_decorator(handler_func)\n\n    @wraps(handler_func)\n    def handler_wrapper(**path_params):\n        log.info(\" \")\n        log.info(\" \")\n        log.info(\"=> INCOMING REQUEST %s %s -> %s\" %\n                 (endpoint.method, endpoint.path, handler_func.__name__))\n        log.info(\" \")\n        log.info(\" \")\n\n        # Get caller's pym-call-id or generate one\n        call_id = request.headers.get('PymCallID', None)\n        if not call_id:\n            call_id = str(uuid.uuid4())\n        stack.top.call_id = call_id\n\n        # Append current server to call path, or start one\n        call_path = request.headers.get('PymCallPath', None)\n        if call_path:\n            call_path = \"%s.%s\" % (call_path, api_name)\n        else:\n            call_path = api_name\n        stack.top.call_path = call_path\n\n        if endpoint.param_in_body or endpoint.param_in_query:\n            # Turn the flask request into something bravado-core can process...\n            try:\n                req = FlaskRequestProxy(request, endpoint.param_in_body)\n            except BadRequest:\n                ee = error_callback(ValidationError(\"Cannot parse json data: have you set 'Content-Type' to 'application/json'?\"))\n                return _responsify(api_spec, ee, 400)\n\n            try:\n                # Note: unmarshall validates parameters but does not fail\n                # if extra unknown parameters are submitted\n                parameters = unmarshal_request(req, endpoint.operation)\n                # Example of parameters: {'body': RegisterCredentials()}\n            except jsonschema.exceptions.ValidationError as e:\n                ee = error_callback(ValidationError(str(e)))\n                return _responsify(api_spec, ee, 400)\n\n        # Call the endpoint, with proper parameters depending on whether\n        # parameters are in body, query or url\n        args = []\n        kwargs = {}\n\n        if endpoint.param_in_path:\n            kwargs = path_params\n\n        if endpoint.param_in_body:\n            # Remove the parameters already defined in path_params\n            for k in list(path_params.keys()):\n                del parameters[k]\n            lst = list(parameters.values())\n            assert len(lst) == 1\n            args.append(lst[0])\n\n        if endpoint.param_in_query:\n            kwargs.update(parameters)\n\n        result = handler_func(*args, **kwargs)\n\n        if not result:\n            e = error_callback(PyMacaronCoreException(\"Have nothing to send in response\"))\n            return _responsify(api_spec, e, 500)\n\n        # Did we get the expected response?\n        if endpoint.produces_html:\n            if type(result) is not tuple:\n                e = error_callback(PyMacaronCoreException(\"Method %s should return %s but returned %s\" %\n                                                          (endpoint.handler_server, endpoint.produces, type(result))))\n                return _responsify(api_spec, e, 500)\n\n            # Return an html page\n            return result\n\n        elif endpoint.produces_json:\n            if not hasattr(result, '__module__') or not hasattr(result, '__class__'):\n                e = error_callback(PyMacaronCoreException(\"Method %s did not return a class instance but a %s\" %\n                                                          (endpoint.handler_server, type(result))))\n                return _responsify(api_spec, e, 500)\n\n            # If it's already a flask Response, just pass it through.\n            # Errors in particular may be either passed back as flask Responses, or\n            # raised as exceptions to be caught and formatted by the error_callback\n            result_type = result.__module__ + \".\" + result.__class__.__name__\n            if result_type == 'flask.wrappers.Response':\n                return result\n\n            # We may have got a pymacaron Error instance, in which case\n            # it has a http_reply() method...\n            if hasattr(result, 'http_reply'):\n                # Let's transform this Error into a flask Response\n                log.info(\"Looks like a pymacaron error instance - calling .http_reply()\")\n                return result.http_reply()\n\n            # Otherwise, assume no error occured and make a flask Response out of\n            # the result.\n\n            # TODO: check that result is an instance of a model expected as response from this endpoint\n            result_json = api_spec.model_to_json(result)\n\n            # Send a Flask Response with code 200 and result_json\n            r = jsonify(result_json)\n            r.status_code = 200\n            return r\n\n    handler_wrapper = cross_origin(headers=['Content-Type', 'Authorization'])(handler_wrapper)\n\n    # And encapsulate all in a global decorator, if given one\n    if global_decorator:\n        handler_wrapper = global_decorator(handler_wrapper)\n\n    return handler_wrapper"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the ANSI escape sequence to set character formatting.", "response": "def format_escape( foreground=None, background=None, bold=False, faint=False,\n    italic=False, underline=False, blink=False, inverted=False ):\n    \"\"\"Returns the ANSI escape sequence to set character formatting.\n\n    foreground\n        Foreground colour to use. Accepted types: None, int (xterm\n        palette ID), tuple (RGB, RGBA), Colour\n\n    background\n        Background colour to use. Accepted types: None, int (xterm\n        palette ID), tuple (RGB, RGBA), Colour\n\n    bold\n        Enable bold text (default: False)\n\n    faint\n        Enable faint text (default: False)\n\n    italic\n        Enable italic text (default: False)\n\n    underline\n        Enable underlined text (default: False)\n\n    blink\n        Enable blinky text (default: False)\n\n    inverted\n        Enable inverted text (default: False)\n    \"\"\"\n    fg_format = None\n    if isinstance( foreground, int ):\n        fg_format = ANSI_FORMAT_FOREGROUND_XTERM_CMD.format( foreground )\n    else:\n        fg_rgba = colour.normalise_rgba( foreground )\n        if fg_rgba[3] != 0:\n            fg_format = ANSI_FORMAT_FOREGROUND_CMD.format( *fg_rgba[:3] )\n\n    bg_format = None\n    if isinstance( background, int ):\n        bg_format = ANSI_FORMAT_BACKGROUND_XTERM_CMD.format( background )\n    else:\n        bg_rgba = colour.normalise_rgba( background )\n        if bg_rgba[3] != 0:\n            bg_format = ANSI_FORMAT_BACKGROUND_CMD.format( *bg_rgba[:3] )\n\n    colour_format = []\n    if fg_format is not None:\n        colour_format.append( fg_format )\n    if bg_format is not None:\n        colour_format.append( bg_format )\n    if bold:\n        colour_format.append( ANSI_FORMAT_BOLD_CMD )\n    if faint:\n        colour_format.append( ANSI_FORMAT_FAINT_CMD )\n    if italic:\n        colour_format.append( ANSI_FORMAT_ITALIC_CMD )\n    if underline:\n        colour_format.append( ANSI_FORMAT_UNDERLINE_CMD )\n    if blink:\n        colour_format.append( ANSI_FORMAT_BLINK_CMD )\n    if inverted:\n        colour_format.append( ANSI_FORMAT_INVERTED_CMD )\n\n    colour_format = ANSI_FORMAT_BASE.format( ';'.join( colour_format ) )\n    return colour_format"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format_string( string, foreground=None, background=None, reset=True, bold=False,\n    faint=False, italic=False, underline=False, blink=False, inverted=False ):\n    \"\"\"Returns a Unicode string formatted with an ANSI escape sequence.\n\n    string\n        String to format\n\n    foreground\n        Foreground colour to use. Accepted types: None, int (xterm\n        palette ID), tuple (RGB, RGBA), Colour\n\n    background\n        Background colour to use. Accepted types: None, int (xterm\n        palette ID), tuple (RGB, RGBA), Colour\n\n    reset\n        Reset the formatting at the end (default: True)\n\n    bold\n        Enable bold text (default: False)\n\n    faint\n        Enable faint text (default: False)\n\n    italic\n        Enable italic text (default: False)\n\n    underline\n        Enable underlined text (default: False)\n\n    blink\n        Enable blinky text (default: False)\n\n    inverted\n        Enable inverted text (default: False)\n    \"\"\"\n    colour_format = format_escape( foreground, background, bold, faint,\n                                        italic, underline, blink, inverted )\n    reset_format = '' if not reset else ANSI_FORMAT_RESET\n\n    return '{}{}{}'.format( colour_format, string, reset_format )", "response": "Returns a Unicode string formatted with an ANSI escape sequence."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the ANSI escape sequence to render two vertically - stacked pixels as a single monospace character.", "response": "def format_pixels( top, bottom, reset=True, repeat=1 ):\n    \"\"\"Return the ANSI escape sequence to render two vertically-stacked pixels as a\n    single monospace character.\n\n    top\n        Top colour to use. Accepted types: None, int (xterm\n        palette ID), tuple (RGB, RGBA), Colour\n\n    bottom\n        Bottom colour to use. Accepted types: None, int (xterm\n        palette ID), tuple (RGB, RGBA), Colour\n\n    reset\n        Reset the formatting at the end (default: True)\n\n    repeat\n        Number of horizontal pixels to render (default: 1)\n    \"\"\"\n    top_src = None\n    if isinstance( top, int ):\n        top_src = top\n    else:\n        top_rgba = colour.normalise_rgba( top )\n        if top_rgba[3] != 0:\n            top_src = top_rgba\n\n    bottom_src = None\n    if isinstance( bottom, int ):\n        bottom_src = bottom\n    else:\n        bottom_rgba = colour.normalise_rgba( bottom )\n        if bottom_rgba[3] != 0:\n            bottom_src = bottom_rgba\n\n    # short circuit for empty pixel\n    if (top_src is None) and (bottom_src is None):\n        return ' '*repeat \n\n    string = '\u2580'*repeat;\n    colour_format = []\n\n    if top_src == bottom_src:\n        string = '\u2588'*repeat\n    elif (top_src is None) and (bottom_src is not None):\n        string = '\u2584'*repeat\n\n    if (top_src is None) and (bottom_src is not None):\n        if isinstance( bottom_src, int ):\n            colour_format.append( ANSI_FORMAT_FOREGROUND_XTERM_CMD.format( bottom_src ) )\n        else:\n            colour_format.append( ANSI_FORMAT_FOREGROUND_CMD.format( *bottom_src[:3] ) )\n    else:\n        if isinstance( top_src, int ):\n            colour_format.append( ANSI_FORMAT_FOREGROUND_XTERM_CMD.format( top_src ) )\n        else:\n            colour_format.append( ANSI_FORMAT_FOREGROUND_CMD.format( *top_src[:3] ) )\n\n    if top_src is not None and bottom_src is not None and top_src != bottom_src:\n        if isinstance( top_src, int ):\n            colour_format.append( ANSI_FORMAT_BACKGROUND_XTERM_CMD.format( bottom_src ) )\n        else:\n            colour_format.append( ANSI_FORMAT_BACKGROUND_CMD.format( *bottom_src[:3] ) )\n\n    colour_format = ANSI_FORMAT_BASE.format( ';'.join( colour_format ) )\n    reset_format = '' if not reset else ANSI_FORMAT_RESET\n\n    return '{}{}{}'.format( colour_format, string, reset_format )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef format_image_iter( data_fetch, x_start=0, y_start=0, width=32, height=32, frame=0, columns=1, downsample=1 ):\n    frames = []\n    try:\n        frame_iter = iter( frame )\n        frames = [f for f in frame_iter]\n    except TypeError:\n        frames = [frame]\n\n    rows = math.ceil( len( frames )/columns )\n    for r in range( rows ):\n        for y in range( 0, height, 2*downsample ):\n            result = []\n            for c in range( min( (len( frames )-r*columns), columns ) ):\n                row = []\n                for x in range( 0, width, downsample ):\n                    fr = frames[r*columns + c]\n                    c1 = data_fetch( x_start+x, y_start+y, fr )\n                    c2 = data_fetch( x_start+x, y_start+y+downsample, fr )\n                    row.append( (c1, c2) )\n                prev_pixel = None\n                pointer = 0\n                while pointer < len( row ):\n                    start = pointer\n                    pixel = row[pointer]\n                    while pointer < len( row ) and (row[pointer] == pixel):\n                        pointer += 1\n                    result.append( format_pixels( pixel[0], pixel[1], repeat=pointer-start ) )\n            yield ''.join( result )\n    return", "response": "Return ANSI escape sequence to render a bitmap image."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting a Python object into a byte array using the field definition.", "response": "def update_buffer_with_value( self, value, buffer, parent=None ):\n        \"\"\"Write a Python object into a byte array, using the field definition.\n\n        value\n            Input Python object to process.\n\n        buffer\n            Output byte array to encode value into.\n\n        parent\n            Parent block object where this Field is defined. Used for e.g.\n            evaluating Refs.\n        \"\"\"\n        assert common.is_bytes( buffer )\n        self.validate( value, parent )\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_end_offset( self, value, parent=None, index=None ):\n        return self.get_start_offset( value, parent, index ) + self.get_size( value, parent, index )", "response": "Returns the end offset of the field s data. Used for chainloading."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef nonalpha_split(string):\n    '''Split 'string' along any punctuation or whitespace.'''\n    return re.findall(r'[%s]+|[^%s]+' % (A, A), string, flags=FLAGS)", "response": "Split string along any punctuation or whitespace."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef syllable_split(string):\n    '''Split 'string' into (stressed) syllables and punctuation/whitespace.'''\n    p = r'\\'[%s]+|`[%s]+|[%s]+|[^%s\\'`\\.]+|[^\\.]{1}' % (A, A, A, A)\n    return re.findall(p, string, flags=FLAGS)", "response": "Split string into ( stressed ) syllables and punctuation and whitespace."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef extract_words(string):\n    '''Extract all alphabetic syllabified forms from 'string'.'''\n    return re.findall(r'[%s]+[%s\\.]*[%s]+' % (A, A, A), string, flags=FLAGS)", "response": "Extract all alphabetic syllabified forms from string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a thread that emits state_changed between each sub - request.", "response": "def thread_with_callback(on_error, on_done, requete_with_callback):\n    \"\"\"\n    Return a thread emiting `state_changed` between each sub-requests.\n\n    :param on_error: callback str -> None\n    :param on_done: callback object -> None\n    :param requete_with_callback: Job to execute. monitor_callable -> None\n    :return: Non started thread\n    \"\"\"\n\n    class C(THREAD):\n\n        error = SIGNAL(str)\n        done = SIGNAL(object)\n        state_changed = SIGNAL(int, int)\n\n        def __del__(self):\n            self.wait()\n\n        def run(self):\n            try:\n                r = requete_with_callback(self.state_changed.emit)\n            except (ConnexionError, StructureError) as e:\n                self.error.emit(str(e))\n            else:\n                self.done.emit(r)\n\n    th = C()\n    th.error.connect(on_error)\n    th.done.connect(on_done)\n    return th"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nuse to crypt and decrypt data before saving locally.", "response": "def protege_data(datas_str, sens):\n    \"\"\"\n    Used to crypt/decrypt data before saving locally.\n    Override if securit is needed.\n    bytes -> str when decrypting\n    str -> bytes when crypting\n\n    :param datas_str: When crypting, str. when decrypting bytes\n    :param sens: True to crypt, False to decrypt\n    \"\"\"\n    return bytes(datas_str, encoding=\"utf8\") if sens else str(datas_str, encoding=\"utf8\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_parser(parser: argparse.ArgumentParser) -> None:\n    parser.add_argument(\n        '--delimiter',\n        help='a delimiter for the samples (teeth) in the key',\n        default=' ',\n    )\n    parser.add_argument(\n        '--encoding',\n        help='the encoding of the population file',\n        default='utf-8',\n    )\n    parser.add_argument(\n        '--nsamples', '-n',\n        help='the number of random samples to take',\n        type=int,\n        default=6,\n        dest='nteeth',\n    )\n    parser.add_argument(\n        '--population', '-p',\n        help='{0}, or a path to a file of line-delimited items'.format(\n            ', '.join(POPULATIONS.keys()),\n        ),\n        default='/usr/share/dict/words',\n    )\n    parser.add_argument(\n        '--stats',\n        help='show statistics for the key',\n        default=False,\n        action='store_true',\n    )\n    parser.add_argument(\n        '--version',\n        action='version',\n        version='%(prog)s {0}'.format(__version__),\n    )", "response": "Build a parser for CLI arguments and options."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a parser for CLI arguments and options.", "response": "def default_parser() -> argparse.ArgumentParser:\n    \"\"\"Create a parser for CLI arguments and options.\"\"\"\n    parser = argparse.ArgumentParser(\n        prog=CONSOLE_SCRIPT,\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n    )\n    build_parser(parser)\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef key(\n        seq: Sequence,\n        tooth: Callable[[Sequence], str] = (\n            lambda seq: str(random.SystemRandom().choice(seq)).strip()\n        ),\n        nteeth: int = 6,\n        delimiter: str = ' ',\n) -> str:\n    \"\"\"Concatenate strings generated by the tooth function.\"\"\"\n    return delimiter.join(tooth(seq) for _ in range(nteeth))", "response": "Return a random string from the sequence seq."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a firewall rule to the firewalld service", "response": "def add_firewalld_service(service, permanent=True):\n    \"\"\" adds a firewall rule \"\"\"\n    yum_install(packages=['firewalld'])\n\n    with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                  warn_only=True, capture=True):\n        p = ''\n        if permanent:\n            p = '--permanent'\n        sudo('firewall-cmd --add-service %s %s' % (service, p))\n        sudo('systemctl reload firewalld')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_firewalld_port(port, permanent=True):\n\n    yum_install(packages=['firewalld'])\n\n    log_green('adding a new fw rule: %s' % port)\n    with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                  warn_only=True, capture=True):\n        p = ''\n        if permanent:\n            p = '--permanent'\n        sudo('firewall-cmd --add-port %s %s' % (port, p))\n        sudo('systemctl restart firewalld')", "response": "Adds a firewall rule to the firewalld system"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a new repository file for apt", "response": "def apt_add_repository_from_apt_string(apt_string, apt_file):\n    \"\"\" adds a new repository file for apt \"\"\"\n\n    apt_file_path = '/etc/apt/sources.list.d/%s' % apt_file\n\n    if not file_contains(apt_file_path, apt_string.lower(), use_sudo=True):\n        file_append(apt_file_path, apt_string.lower(), use_sudo=True)\n\n        with hide('running', 'stdout'):\n            sudo(\"DEBIAN_FRONTEND=noninteractive apt-get update\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the current cpu archictecture", "response": "def arch():\n    \"\"\" returns the current cpu archictecture \"\"\"\n    with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                  warn_only=True, capture=True):\n        result = sudo('rpm -E %dist').strip()\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndisable rDNS lookups on the given binary node.", "response": "def disable_openssh_rdns(distribution):\n    \"\"\"\n    Set 'UseDNS no' in openssh config to disable rDNS lookups\n\n    On each request for a new channel openssh defaults to an\n    rDNS lookup on the client IP. This can be slow, if it fails\n    for instance, adding 10s of overhead to every request\n    for a new channel (not connection). This can add a lot of\n    time to a process that opens lots of channels (e.g. running\n    several commands via fabric.)\n\n    This function will disable rDNS lookups in the openssh\n    config and reload ssh to adjust the running instance.\n\n    :param bytes distribution: the name of the distribution\n        running on the node.\n    \"\"\"\n    log_green('Disabling openssh reverse dns lookups')\n    openssh_config_file = '/etc/ssh/sshd_config'\n    dns_config = 'UseDNS no'\n    if not file_contains(openssh_config_file, dns_config, use_sudo=True):\n        file_append(openssh_config_file, dns_config, use_sudo=True)\n        service_name = 'sshd'\n        if 'ubuntu' in distribution:\n            service_name = 'ssh'\n        sudo('service {} reload'.format(service_name))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconnects to AWS EC2", "response": "def connect_to_ec2(region, access_key_id, secret_access_key):\n    \"\"\" returns a connection object to AWS EC2  \"\"\"\n    conn = boto.ec2.connect_to_region(region,\n                                      aws_access_key_id=access_key_id,\n                                      aws_secret_access_key=secret_access_key)\n    return conn"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a connection object to Rackspace", "response": "def connect_to_rackspace(region,\n                         access_key_id,\n                         secret_access_key):\n    \"\"\" returns a connection object to Rackspace  \"\"\"\n    pyrax.set_setting('identity_type', 'rackspace')\n    pyrax.set_default_region(region)\n    pyrax.set_credentials(access_key_id, secret_access_key)\n    nova = pyrax.connect_to_cloudservers(region=region)\n    return nova"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_gce_image(zone,\n                     project,\n                     instance_name,\n                     name,\n                     description):\n    \"\"\"\n    Shuts down the instance and creates and image from the disk.\n\n    Assumes that the disk name is the same as the instance_name (this is the\n    default behavior for boot disks on GCE).\n    \"\"\"\n\n    disk_name = instance_name\n    try:\n        down_gce(instance_name=instance_name, project=project, zone=zone)\n    except HttpError as e:\n        if e.resp.status == 404:\n            log_yellow(\"the instance {} is already down\".format(instance_name))\n        else:\n            raise e\n\n    body = {\n        \"rawDisk\": {},\n        \"name\": name,\n        \"sourceDisk\": \"projects/{}/zones/{}/disks/{}\".format(\n            project, zone, disk_name\n        ),\n        \"description\": description\n    }\n    compute = _get_gce_compute()\n    gce_wait_until_done(\n        compute.images().insert(project=project, body=body).execute()\n    )\n    return name", "response": "Creates a GCE image from the disk."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_image(cloud, **kwargs):\n    if cloud == 'ec2':\n        return create_ami(**kwargs)\n\n    if cloud == 'rackspace':\n        return create_rackspace_image(**kwargs)\n\n    if cloud == 'gce':\n        return create_gce_image(**kwargs)", "response": "proxy call for ec2 rackspace create ami backend functions"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_server(cloud, **kwargs):\n    if cloud == 'ec2':\n        _create_server_ec2(**kwargs)\n    elif cloud == 'rackspace':\n        _create_server_rackspace(**kwargs)\n    elif cloud == 'gce':\n        _create_server_gce(**kwargs)\n    else:\n        raise ValueError(\"Unknown cloud type: {}\".format(cloud))", "response": "Create a new instance of the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gce_wait_until_done(operation):\n    operation_name = operation['name']\n    if 'zone' in operation:\n        zone_url_parts = operation['zone'].split('/')\n        project = zone_url_parts[-3]\n        zone = zone_url_parts[-1]\n\n        def get_zone_operation():\n            return _get_gce_compute().zoneOperations().get(\n                project=project,\n                zone=zone,\n                operation=operation_name\n            )\n        update = get_zone_operation\n    else:\n        project = operation['selfLink'].split('/')[-4]\n\n        def get_global_operation():\n            return _get_gce_compute().globalOperations().get(\n                project=project,\n                operation=operation_name\n            )\n        update = get_global_operation\n    done = False\n    latest_operation = None\n    start = time()\n    timeout = 5*60  # seconds\n    while not done:\n        latest_operation = update().execute()\n        log_yellow(\"waiting for operation\")\n        if (latest_operation['status'] == 'DONE' or\n                time() - start > timeout):\n            done = True\n        else:\n            sleep(10)\n            print \"waiting for operation\"\n    return latest_operation", "response": "This function will wait until the operation completes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef startup_gce_instance(instance_name, project, zone, username, machine_type,\n                         image, public_key, disk_name=None):\n    \"\"\"\n    For now, jclouds is broken for GCE and we will have static slaves\n    in Jenkins.  Use this to boot them.\n    \"\"\"\n    log_green(\"Started...\")\n    log_yellow(\"...Creating GCE Jenkins Slave Instance...\")\n    instance_config = get_gce_instance_config(\n        instance_name, project, zone, machine_type, image,\n        username, public_key, disk_name\n    )\n    operation = _get_gce_compute().instances().insert(\n        project=project,\n        zone=zone,\n        body=instance_config\n    ).execute()\n    result = gce_wait_until_done(operation)\n    if not result:\n        raise RuntimeError(\"Creation of VM timed out or returned no result\")\n    log_green(\"Instance has booted\")", "response": "Create a new GCE Slave Instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new EC2 server and return a new EC2 instance", "response": "def _create_server_ec2(region,\n                       access_key_id,\n                       secret_access_key,\n                       disk_name,\n                       disk_size,\n                       ami,\n                       key_pair,\n                       instance_type,\n                       username,\n                       tags={},\n                       security_groups=None):\n    \"\"\"\n    Creates EC2 Instance and saves it state in a local json file\n    \"\"\"\n    conn = connect_to_ec2(region, access_key_id, secret_access_key)\n\n    log_green(\"Started...\")\n    log_yellow(\"...Creating EC2 instance...\")\n\n    # we need a larger boot device to store our cached images\n    ebs_volume = EBSBlockDeviceType()\n    ebs_volume.size = disk_size\n    bdm = BlockDeviceMapping()\n    bdm[disk_name] = ebs_volume\n\n    # get an ec2 ami image object with our choosen ami\n    image = conn.get_all_images(ami)[0]\n    # start a new instance\n    reservation = image.run(1, 1,\n                            key_name=key_pair,\n                            security_groups=security_groups,\n                            block_device_map=bdm,\n                            instance_type=instance_type)\n\n    # and get our instance_id\n    instance = reservation.instances[0]\n\n    #  and loop and wait until ssh is available\n    while instance.state == u'pending':\n        log_yellow(\"Instance state: %s\" % instance.state)\n        sleep(10)\n        instance.update()\n    log_green(\"Instance state: %s\" % instance.state)\n    wait_for_ssh(instance.public_dns_name)\n\n    # update the EBS volumes to be deleted on instance termination\n    for dev, bd in instance.block_device_mapping.items():\n        instance.modify_attribute('BlockDeviceMapping',\n                                  [\"%s=%d\" % (dev, 1)])\n\n    # add a tag to our instance\n    conn.create_tags([instance.id], tags)\n\n    log_green(\"Public dns: %s\" % instance.public_dns_name)\n    # finally save the details or our new instance into the local state file\n    save_ec2_state_locally(instance_id=instance.id,\n                           region=region,\n                           username=username,\n                           access_key_id=access_key_id,\n                           secret_access_key=secret_access_key)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new server in Rackspace and save it locally.", "response": "def _create_server_rackspace(region,\n                             access_key_id,\n                             secret_access_key,\n                             disk_name,\n                             disk_size,\n                             ami,\n                             key_pair,\n                             instance_type,\n                             username,\n                             instance_name,\n                             tags={},\n                             security_groups=None):\n    \"\"\"\n    Creates Rackspace Instance and saves it state in a local json file\n    \"\"\"\n    nova = connect_to_rackspace(region, access_key_id, secret_access_key)\n    log_yellow(\"Creating Rackspace instance...\")\n\n    flavor = nova.flavors.find(name=instance_type)\n    image = nova.images.find(name=ami)\n\n    server = nova.servers.create(name=instance_name,\n                                 flavor=flavor.id,\n                                 image=image.id,\n                                 region=region,\n                                 availability_zone=region,\n                                 key_name=key_pair)\n\n    while server.status == 'BUILD':\n        log_yellow(\"Waiting for build to finish...\")\n        sleep(5)\n        server = nova.servers.get(server.id)\n\n    # check for errors\n    if server.status != 'ACTIVE':\n        log_red(\"Error creating rackspace instance\")\n        exit(1)\n\n    # the server was assigned IPv4 and IPv6 addresses, locate the IPv4 address\n    ip_address = server.accessIPv4\n\n    if ip_address is None:\n        log_red('No IP address assigned')\n        exit(1)\n\n    wait_for_ssh(ip_address)\n    log_green('New server with IP address {0}.'.format(ip_address))\n    # finally save the details or our new instance into the local state file\n    save_rackspace_state_locally(instance_id=server.id,\n                                 region=region,\n                                 username=username,\n                                 access_key_id=access_key_id,\n                                 secret_access_key=secret_access_key)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef destroy_ebs_volume(region, volume_id, access_key_id, secret_access_key):\n    conn = connect_to_ec2(region, access_key_id, secret_access_key)\n\n    if ebs_volume_exists(region, volume_id, access_key_id, secret_access_key):\n        log_yellow('destroying EBS volume ...')\n        conn.delete_volume(volume_id)", "response": "destroys an EBS volume"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes the rackspace instance.", "response": "def destroy_rackspace(region, instance_id, access_key_id, secret_access_key):\n    \"\"\" terminates the instance \"\"\"\n    nova = connect_to_rackspace(region,\n                                access_key_id,\n                                secret_access_key)\n\n    server = nova.servers.get(instance_id)\n    log_yellow('deleting rackspace instance ...')\n    server.delete()\n\n    # wait for server to be deleted\n    try:\n        while True:\n            server = nova.servers.get(server.id)\n            log_yellow('waiting for deletion ...')\n            sleep(5)\n    except:\n        pass\n    log_green('The server has been deleted')\n    os.unlink('data.json')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ebs_volume_exists(region, volume_id, access_key_id, secret_access_key):\n    conn = connect_to_ec2(region, access_key_id, secret_access_key)\n    for vol in conn.get_all_volumes():\n        if vol.id == volume_id:\n            return True", "response": "Checks if an ebs volume exists"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef enable_marathon_basic_authentication(principal, password):\n    upstart_file = '/etc/init/marathon.conf'\n    with hide('running', 'stdout'):\n        sudo('echo -n \"{}\" > /etc/marathon-mesos.credentials'.format(password))\n    boot_args = ' '.join(['exec',\n                          '/usr/bin/marathon',\n                          '--http_credentials',\n                          '\"{}:{}\"'.format(principal, password),\n                          '--mesos_authentication_principal',\n                          principal,\n                          '--mesos_authentication_secret_file',\n                          '/etc/marathon-mesos.credentials'])\n\n    # check if the init conf file contains the exact user and password\n    if not file_contains(upstart_file, boot_args, use_sudo=True):\n        sed(upstart_file, 'exec /usr/bin/marathon.*', boot_args, use_sudo=True)\n        file_attribs(upstart_file, mode=700, sudo=True)\n        restart_service('marathon')", "response": "configure marathon to start with basic authentication"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef enable_mesos_basic_authentication(principal, password):\n    restart = False\n    secrets_file = '/etc/mesos/secrets'\n    secrets_entry = '%s %s' % (principal, password)\n    if not file_contains(filename=secrets_file,\n                         text=secrets_entry, use_sudo=True):\n        file_append(filename=secrets_file, text=secrets_entry, use_sudo=True)\n        file_attribs(secrets_file, mode=700, sudo=True)\n        restart = True\n\n    # set new startup parameters for mesos-master\n    with quiet():\n        if secrets_file not in sudo('cat /etc/mesos-master/credentials'):\n            sudo('echo %s > /etc/mesos-master/credentials' % secrets_file)\n            restart = True\n\n        if not exists('/etc/mesos-master/\\?authenticate', use_sudo=True):\n            sudo('touch /etc/mesos-master/\\?authenticate')\n            file_attribs('/etc/mesos-master/\\?authenticate',\n                         mode=700,\n                         sudo=True)\n            restart = True\n\n    if restart:\n        restart_service('mesos-master')", "response": "enables and adds a new authorized principal"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef file_attribs(location, mode=None, owner=None, group=None, sudo=False):\n    return dir_attribs(location, mode, owner, group, False, sudo)", "response": "Updates the mode owner group for the remote file at the given location."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_ec2_info(instance_id,\n                 region,\n                 access_key_id,\n                 secret_access_key,\n                 username):\n    \"\"\" queries EC2 for details about a particular instance_id\n    \"\"\"\n    conn = connect_to_ec2(region, access_key_id, secret_access_key)\n    instance = conn.get_only_instances(\n        filters={'instance_id': instance_id}\n        )[0]\n\n    data = {}\n    data['public_dns_name'] = instance.public_dns_name\n    data['id'] = instance.id\n    data['instance_type'] = instance.instance_type\n    data['ip_address'] = instance.ip_address\n    data['architecture'] = instance.architecture\n    data['state'] = instance.state\n    data['region'] = region\n    data['cloud_type'] = 'ec2'\n    data['username'] = username\n\n    # find out the distribution running on the instance\n    if username is not None:\n        wait_for_ssh(data['ip_address'])\n        with settings(host_string=username + '@' + data['ip_address']):\n            data['distribution'] = linux_distribution(username,\n                                                      data['ip_address'])\n            data['os_release'] = os_release(username,\n                                            data['ip_address'])\n\n    try:\n        volume = conn.get_all_volumes(\n            filters={'attachment.instance-id': instance.id})[0].id\n        data['volume'] = volume\n    except:\n        data['volume'] = ''\n    return data", "response": "queries EC2 for details about a particular instance_id\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an ipaddress for a rackspace instance", "response": "def get_ip_address_from_rackspace_server(server_id):\n    \"\"\"\n    returns an ipaddress for a rackspace instance\n    \"\"\"\n    nova = connect_to_rackspace()\n    server = nova.servers.get(server_id)\n    # the server was assigned IPv4 and IPv6 addresses, locate the IPv4 address\n    ip_address = None\n    for network in server.networks['public']:\n        if re.match('\\d+\\.\\d+\\.\\d+\\.\\d+', network):\n            ip_address = network\n            break\n\n    # find out if we have an ip address\n    if ip_address is None:\n        log_red('No IP address assigned')\n        return False\n    else:\n        return ip_address"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nqueries Rackspace for details about a particular server id and region", "response": "def get_rackspace_info(server_id,\n                       region,\n                       access_key_id,\n                       secret_access_key,\n                       username):\n    \"\"\" queries Rackspace for details about a particular server id\n    \"\"\"\n    nova = connect_to_rackspace(region, access_key_id, secret_access_key)\n    server = nova.servers.get(server_id)\n\n    data = {}\n    data['id'] = server.id\n    # this needs to be tackled\n    data['ip_address'] = server.accessIPv4\n    data['state'] = server.status\n    data['region'] = region\n    data['cloud_type'] = 'rackspace'\n    data['username'] = username\n\n    # find out the distribution running on the instance\n    if username is not None:\n        wait_for_ssh(data['ip_address'])\n        with settings(host_string=username + '@' + data['ip_address']):\n            data['distribution'] = linux_distribution(username,\n                                                      data['ip_address'])\n            data['os_release'] = os_release(username,\n                                            data['ip_address'])\n\n    data['volume'] = ''\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninstalls mesos on a single node", "response": "def install_mesos_single_box_mode(distribution):\n    \"\"\" install mesos (all of it) on a single node\"\"\"\n\n    if 'ubuntu' in distribution:\n        log_green('adding mesosphere apt-key')\n        apt_add_key(keyid='E56151BF')\n\n        os = lsb_release()\n        apt_string = 'deb http://repos.mesosphere.io/%s %s main' % (\n            os['DISTRIB_ID'], os['DISTRIB_CODENAME'])\n\n        log_green('adding mesosphere apt repository')\n        apt_add_repository_from_apt_string(apt_string, 'mesosphere.list')\n\n        log_green('installing ubuntu development tools')\n        install_ubuntu_development_tools()\n\n        install_oracle_java(distribution, '8')\n\n        log_green('installing mesos and marathon')\n        apt_install(packages=['mesos', 'marathon'])\n\n        if not file_contains('/etc/default/mesos-master',\n                             'MESOS_QUORUM=1', use_sudo=True):\n            file_append('/etc/default/mesos-master',\n                        'MESOS_QUORUM=1', use_sudo=True)\n\n            log_green('restarting services...')\n            for svc in ['zookeeper', 'mesos-master', 'mesos-slave', 'marathon']:\n                restart_service(svc)\n\n        if not file_contains('/etc/mesos-slave/work_dir',\n                             '/data/mesos', use_sudo=True):\n            file_append('/etc/mesos-slave/work_dir',\n                        '/data/mesos', use_sudo=True)\n\n            log_green('restarting services...')\n            for svc in ['mesos-slave']:\n                restart_service(svc)\n\n        log_green('enabling nginx autoindex on /...')\n\n        with quiet():\n            cmd = 'cat /etc/nginx/sites-available/default'\n            contents = sudo(cmd).replace('\\n', ' ').replace('\\r', '')\n\n        if not bool(re.search('.*#*location \\/ {.*autoindex on;.*', contents)):\n            insert_line_in_file_after_regex(\n                path='/etc/nginx/sites-available/default',\n                line='                autoindex on;',\n                after_regex='^[^#]*location \\/ {',\n                use_sudo=True)\n            log_green('restarting nginx')\n            restart_service('nginx')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insert_line_in_file_after_regex(path, line, after_regex, use_sudo=False):\n\n    tmpfile = str(uuid.uuid4())\n    get_file(path, tmpfile, use_sudo=use_sudo)\n    with open(tmpfile) as f:\n        original = f.read()\n\n    if line not in original:\n        outfile = str(uuid.uuid4())\n        with open(outfile, 'w') as output:\n            for l in original.split('\\n'):\n                output.write(l + '\\n')\n                if re.match(after_regex, l) is not None:\n                    output.write(line + '\\n')\n\n        upload_file(local_path=outfile,\n                    remote_path=path,\n                    use_sudo=use_sudo)\n        os.unlink(outfile)\n    os.unlink(tmpfile)", "response": "inserts a line in the middle of a file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef install_python_module(name):\n\n    with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                  warn_only=False, capture=True):\n        run('pip --quiet install %s' % name)", "response": "installs a python module"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef install_python_module_locally(name):\n    with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                  warn_only=False, capture=True):\n        local('pip --quiet install %s' % name)", "response": "installs a python module locally"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef install_system_gem(gem):\n    with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                  warn_only=False, capture=True):\n        sudo(\"gem install %s --no-rdoc --no-ri\" % gem)", "response": "install a particular gem"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_vagrant_plugin_installed(plugin, use_sudo=False):\n\n    cmd = 'vagrant plugin list'\n\n    if use_sudo:\n        results = sudo(cmd)\n    else:\n        results = run(cmd)\n\n    installed_plugins = []\n    for line in results:\n        plugin = re.search('^(\\S.*) \\((.*)\\)$', line)\n        installed_plugins.append({'name': plugin.group(0),\n                                  'version': plugin.group(1)})\n        return installed_plugins", "response": "checks if vagrant plugin is installed"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_deb_package_installed(pkg):\n\n    with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                  warn_only=True, capture=True):\n\n        result = sudo('dpkg-query -l \"%s\" | grep -q ^.i' % pkg)\n        return not bool(result.return_code)", "response": "checks if a particular deb package is installed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_ssh_available(host, port=22):\n    s = socket.socket()\n    try:\n        s.connect((host, port))\n        return True\n    except:\n        return False", "response": "checks if ssh port is open"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the os - release for a user", "response": "def os_release(username, ip_address):\n    \"\"\" returns /etc/os-release in a dictionary \"\"\"\n    with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                  warn_only=True, capture=True):\n\n        _os_release = {}\n        with settings(host_string=username + '@' + ip_address):\n            data = run('cat /etc/os-release')\n        for line in data.split('\\n'):\n            if not line:\n                continue\n            parts = line.split('=')\n            if len(parts) == 2:\n                _os_release[parts[0]] = parts[1].strip('\\n\\r\"')\n\n        return _os_release"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_state_from_disk():\n    if is_there_state():\n        with open('data.json', 'r') as f:\n            data = json.load(f)\n        return data\n    else:\n        return False", "response": "loads the state from a local data. json file"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef print_ec2_info(region,\n                   instance_id,\n                   access_key_id,\n                   secret_access_key,\n                   username):\n    \"\"\" outputs information about our EC2 instance \"\"\"\n    data = get_ec2_info(instance_id=instance_id,\n                        region=region,\n                        access_key_id=access_key_id,\n                        secret_access_key=secret_access_key,\n                        username=username)\n\n    log_green(\"region: %s\" % data['region'])\n    log_green(\"Instance_type: %s\" % data['instance_type'])\n    log_green(\"Instance state: %s\" % data['state'])\n    log_green(\"Public dns: %s\" % data['public_dns_name'])\n    log_green(\"Ip address: %s\" % data['ip_address'])\n    log_green(\"volume: %s\" % data['volume'])\n    log_green(\"user: %s\" % data['username'])\n    log_green(\"ssh -i %s %s@%s\" % (env.key_filename,\n                                   username,\n                                   data['ip_address']))", "response": "Prints info about our EC2 instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef print_gce_info(zone, project, instance_name, data):\n    try:\n        instance_info = _get_gce_compute().instances().get(\n            project=project,\n            zone=zone,\n            instance=instance_name\n        ).execute()\n        log_yellow(pformat(instance_info))\n        log_green(\"Instance state: %s\" % instance_info['status'])\n        log_green(\"Ip address: %s\" % data['ip_address'])\n    except HttpError as e:\n        if e.resp.status != 404:\n            raise e\n        log_yellow(\"Instance state: DOWN\")\n    log_green(\"project: %s\" % project)\n    log_green(\"zone: %s\" % zone)\n    log_green(\"disk_name: %s\" % instance_name)\n    log_green(\"user: %s\" % data['username'])\n    log_green(\"ssh -i %s %s@%s\" % (env.key_filename,\n                                   data['username'],\n                                   data['ip_address']))", "response": "Prints out information about our Rackspace instance"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint out information about our Rackspace instance", "response": "def print_rackspace_info(region,\n                         instance_id,\n                         access_key_id,\n                         secret_access_key,\n                         username):\n    \"\"\" outputs information about our Rackspace instance \"\"\"\n    data = get_rackspace_info(server_id=instance_id,\n                              region=region,\n                              access_key_id=access_key_id,\n                              secret_access_key=secret_access_key,\n                              username=username)\n\n    log_green(\"region: %s\" % data['region'])\n    log_green(\"Instance state: %s\" % data['state'])\n    log_green(\"Ip address: %s\" % data['ip_address'])\n    log_green(\"volume: %s\" % data['volume'])\n    log_green(\"user: %s\" % data['username'])\n    log_green(\"ssh -i %s %s@%s\" % (env.key_filename,\n                                   username,\n                                   data['ip_address']))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rsync():\n    log_green('syncing code to remote box...')\n    data = load_state_from_disk()\n    if 'SOURCE_PATH' in os.environ:\n        with lcd(os.environ['SOURCE_PATH']):\n            local(\"rsync  -a \"\n                  \"--info=progress2 \"\n                  \"--exclude .git \"\n                  \"--exclude .tox \"\n                  \"--exclude .vagrant \"\n                  \"--exclude venv \"\n                  \". \"\n                  \"-e 'ssh -C -i \" + env.ec2_key_filename + \"' \"\n                  \"%s@%s:\" % (env.user, data['ip_address']))\n    else:\n        print('please export SOURCE_PATH before running rsync')\n        exit(1)", "response": "syncs the source code to the remote box"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_ec2_state_locally(instance_id,\n                           region,\n                           username,\n                           access_key_id,\n                           secret_access_key):\n    \"\"\" queries EC2 for details about a particular instance_id and\n        stores those details locally\n    \"\"\"\n    # retrieve the IP information from the instance\n    data = get_ec2_info(instance_id,\n                        region,\n                        access_key_id,\n                        secret_access_key,\n                        username)\n    return _save_state_locally(data)", "response": "Save the state of the EC2 instance in the local machine."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nopening a ssh shell to the host", "response": "def ssh_session(key_filename,\n                username,\n                ip_address,\n                *cli):\n    \"\"\" opens a ssh shell to the host \"\"\"\n    local('ssh -t -i %s %s@%s %s' % (key_filename,\n                                     username,\n                                     ip_address,\n                                     \"\".join(chain.from_iterable(cli))))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbooting an ec2 instance and update the ec2 state file", "response": "def up_ec2(region,\n           access_key_id,\n           secret_access_key,\n           instance_id,\n           username):\n    \"\"\" boots an existing ec2_instance \"\"\"\n\n    conn = connect_to_ec2(region, access_key_id, secret_access_key)\n    # boot the ec2 instance\n    instance = conn.start_instances(instance_ids=instance_id)[0]\n    while instance.state != \"running\":\n        log_yellow(\"Instance state: %s\" % instance.state)\n        sleep(10)\n        instance.update()\n    # the ip_address has changed so we need to get the latest data from ec2\n    data = get_ec2_info(instance_id=instance_id,\n                        region=region,\n                        access_key_id=access_key_id,\n                        secret_access_key=secret_access_key,\n                        username=username)\n    # and make sure we don't return until the instance is fully up\n    wait_for_ssh(data['ip_address'])\n    # lets update our local state file with the new ip_address\n    save_ec2_state_locally(instance_id=instance_id,\n                           region=region,\n                           username=username,\n                           access_key_id=access_key_id,\n                           secret_access_key=secret_access_key)\n\n    env.hosts = data['ip_address']\n\n    print_ec2_info(region,\n                   instance_id,\n                   access_key_id,\n                   secret_access_key,\n                   username)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwaits until the ssh port is available", "response": "def wait_for_ssh(host, port=22, timeout=600):\n    \"\"\" probes the ssh port and waits until it is available \"\"\"\n    log_yellow('waiting for ssh...')\n    for iteration in xrange(1, timeout): #noqa\n        sleep(1)\n        if is_ssh_available(host, port):\n            return True\n        else:\n            log_yellow('waiting for ssh...')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_visuals(user):\n    pixmap = SuperUserAvatar() if user[\"status\"] == \"admin\" else UserAvatar()\n    label = user[\"label\"]\n    return pixmap, QLabel(label)", "response": "Returns a tuple of QPixmap et QLabel"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef saveDirectory(alias):\n\tif not settings.platformCompatible():\n\t\treturn False\n\tdataFile = open(settings.getDataFile(), \"wb\")\n\tcurrentDirectory = os.path.abspath(\".\")\n\tdirectory = {alias : currentDirectory}\n\tpickle.dump(directory, dataFile)\n\tspeech.success(alias + \" will now link to \" + currentDirectory + \".\")\n\tspeech.success(\"Tip: use 'hallie go to \" + alias + \"' to change to this directory.\")", "response": "save a directory to a certain alias"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngoes to a saved directory", "response": "def goToDirectory(alias):\n\t\"\"\"go to a saved directory\"\"\"\n\tif not settings.platformCompatible():\n\t\treturn False\n\tdata = pickle.load(open(settings.getDataFile(), \"rb\"))\n\ttry:\n\t\tdata[alias]\n\texcept KeyError:\n\t\tspeech.fail(\"Sorry, it doesn't look like you have saved \" + alias + \" yet.\")\n\t\tspeech.fail(\"Go to the directory you'd like to save and type 'hallie save as \" + alias + \"\\'\")\n\t\treturn\n\ttry:\n\t\t(output, error) = subprocess.Popen([\"osascript\", \"-e\", CHANGE_DIR % (data[alias])], stdout=subprocess.PIPE).communicate()\n\texcept:\n\t\tspeech.fail(\"Something seems to have gone wrong. Please report this error to michaelmelchione@gmail.com.\")\n\t\treturn\n\tspeech.success(\"Successfully navigating to \" + data[alias])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list(self, filters=None):\n        # Add in the page and page_size parameters to the filter, such\n        # that our request gets *all* objects in the list. However,\n        # don't do this if the user has explicitly included these\n        # parameters in the filter.\n        if not filters:\n            filters = {}\n\n        if \"page\" not in filters:\n            filters[\"page\"] = 1\n\n        if \"page_size\" not in filters:\n            # The below \"magic number\" is 2^63 - 1, which is the largest\n            # number you can hold in a 64 bit integer. The main point\n            # here is that we want to get everything in one page (unless\n            # otherwise specified, of course).\n            filters[\"page_size\"] = 9223372036854775807\n\n        # Form the request URL - first add in the query filters\n        query_filter_sub_url = \"\"\n\n        for idx, filter_param in enumerate(filters):\n            # Prepend '?' or '&'\n            if idx == 0:\n                query_filter_sub_url += \"?\"\n            else:\n                query_filter_sub_url += \"&\"\n\n            # Add in the query filter\n            query_filter_sub_url += \"{param}={val}\".format(\n                param=filter_param, val=filters[filter_param]\n            )\n\n        # Stitch together all sub-urls\n        request_url = (\n            self._client.base_api_url + self.list_url + query_filter_sub_url\n        )\n\n        # Make the request\n        response = self._client.session.get(request_url)\n\n        # Validate that the request was successful\n        self.validate_request_success(\n            response_text=response.text,\n            request_url=request_url,\n            status_code=response.status_code,\n            expected_status_code=HTTP_200_OK,\n        )\n\n        # Return a list of model instances\n        return self.response_data_to_model_instances_list(response.json())", "response": "This method returns a list of all the container task type related objects in the API."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, id):\n        # Get the object\n        request_url = self._client.base_api_url + self.detail_url.format(id=id)\n\n        response = self._client.session.get(request_url)\n\n        # Validate that the request was successful\n        self.validate_request_success(\n            response_text=response.text,\n            request_url=request_url,\n            status_code=response.status_code,\n            expected_status_code=HTTP_200_OK,\n        )\n\n        # Return a model instance\n        return self.response_data_to_model_instance(response.json())", "response": "Get the object with a given id."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvalidate that a request was successful.", "response": "def validate_request_success(\n        response_text, request_url, status_code, expected_status_code\n    ):\n        \"\"\"Validates that a request was successful.\n\n        Args:\n            response_text (str): The response body of the request.\n            request_url (str): The URL the request was made at.\n            status_code (int): The status code of the response.\n            expected_status_code (int): The expected status code of the\n                response.\n\n        Raises:\n            :class:`saltant.exceptions.BadHttpRequestError`: The HTTP\n                request failed.\n        \"\"\"\n        try:\n            assert status_code == expected_status_code\n        except AssertionError:\n            msg = (\n                \"Request to {url} failed with status {status_code}:\\n\"\n                \"The reponse from the request was as follows:\\n\\n\"\n                \"{content}\"\n            ).format(\n                url=request_url, status_code=status_code, content=response_text\n            )\n            raise BadHttpRequestError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sync(self):\n        self = self.manager.get(uuid=self.uuid)\n\n        return self", "response": "Syncs this object with latest data on the saltant server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef wait_until_finished(\n        self, refresh_period=DEFAULT_TASK_INSTANCE_WAIT_REFRESH_PERIOD\n    ):\n        \"\"\"Wait until a task instance with the given UUID is finished.\n\n        Args:\n            refresh_period (int, optional): How many seconds to wait\n                before checking the task's status. Defaults to 5\n                seconds.\n\n        Returns:\n            :class:`saltant.models.base_task_instance.BaseTaskInstance`:\n                This task instance model after it finished.\n        \"\"\"\n        return self.manager.wait_until_finished(\n            uuid=self.uuid, refresh_period=refresh_period\n        )", "response": "Wait until a task instance with the given UUID is finished."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, task_type_id, task_queue_id, arguments=None, name=\"\"):\n        # Make arguments an empty dictionary if None\n        if arguments is None:\n            arguments = {}\n\n        # Create the object\n        request_url = self._client.base_api_url + self.list_url\n        data_to_post = {\n            \"name\": name,\n            \"arguments\": json.dumps(arguments),\n            \"task_type\": task_type_id,\n            \"task_queue\": task_queue_id,\n        }\n\n        response = self._client.session.post(request_url, data=data_to_post)\n\n        # Validate that the request was successful\n        self.validate_request_success(\n            response_text=response.text,\n            request_url=request_url,\n            status_code=response.status_code,\n            expected_status_code=HTTP_201_CREATED,\n        )\n\n        # Return a model instance representing the task instance\n        return self.response_data_to_model_instance(response.json())", "response": "Creates a new task instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clone(self, uuid):\n        # Clone the object\n        request_url = self._client.base_api_url + self.clone_url.format(\n            id=uuid\n        )\n\n        response = self._client.session.post(request_url)\n\n        # Validate that the request was successful\n        self.validate_request_success(\n            response_text=response.text,\n            request_url=request_url,\n            status_code=response.status_code,\n            expected_status_code=HTTP_201_CREATED,\n        )\n\n        # Return a model instance\n        return self.response_data_to_model_instance(response.json())", "response": "Clone the task instance with given UUID."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nterminate the task instance with given UUID.", "response": "def terminate(self, uuid):\n        \"\"\"Terminate the task instance with given UUID.\n\n        Args:\n            uuid (str): The UUID of the task instance to terminate.\n\n        Returns:\n            :class:`saltant.models.base_task_instance.BaseTaskInstance`:\n                A task instance model instance representing the task\n                instance that was told to terminate.\n        \"\"\"\n        # Clone the object\n        request_url = self._client.base_api_url + self.terminate_url.format(\n            id=uuid\n        )\n\n        response = self._client.session.post(request_url)\n\n        # Validate that the request was successful\n        self.validate_request_success(\n            response_text=response.text,\n            request_url=request_url,\n            status_code=response.status_code,\n            expected_status_code=HTTP_202_ACCEPTED,\n        )\n\n        # Return a model instance\n        return self.response_data_to_model_instance(response.json())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwaiting until a task instance with the given UUID is finished.", "response": "def wait_until_finished(\n        self, uuid, refresh_period=DEFAULT_TASK_INSTANCE_WAIT_REFRESH_PERIOD\n    ):\n        \"\"\"Wait until a task instance with the given UUID is finished.\n\n        Args:\n            uuid (str): The UUID of the task instance to wait for.\n            refresh_period (float, optional): How many seconds to wait\n                in between checking the task's status. Defaults to 5\n                seconds.\n\n        Returns:\n            :class:`saltant.models.base_task_instance.BaseTaskInstance`:\n                A task instance model instance representing the task\n                instance which we waited for.\n        \"\"\"\n        # Wait for the task to finish\n        task_instance = self.get(uuid)\n\n        while task_instance.state not in TASK_INSTANCE_FINISH_STATUSES:\n            # Wait a bit\n            time.sleep(refresh_period)\n\n            # Query again\n            task_instance = self.get(uuid)\n\n        return task_instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts the response data to a task instance model instance.", "response": "def response_data_to_model_instance(self, response_data):\n        \"\"\"Convert response data to a task instance model.\n\n        Args:\n            response_data (dict): The data from the request's response.\n\n        Returns:\n            :class:`saltant.models.base_task_instance.BaseTaskInstance`:\n                A task instance model instance representing the task\n                instance from the reponse data.\n        \"\"\"\n        # Coerce datetime strings into datetime objects\n        response_data[\"datetime_created\"] = dateutil.parser.parse(\n            response_data[\"datetime_created\"]\n        )\n\n        if response_data[\"datetime_finished\"]:\n            response_data[\"datetime_finished\"] = dateutil.parser.parse(\n                response_data[\"datetime_finished\"]\n            )\n\n        # Instantiate a model for the task instance\n        return super(\n            BaseTaskInstanceManager, self\n        ).response_data_to_model_instance(response_data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _ids_and_column_names(names, force_lower_case=False):\n        fixed = OrderedDict()\n        for name in names:\n            identifier = RowWrapper._make_identifier(name)\n            if force_lower_case:\n                identifier = identifier.lower()\n            while identifier in fixed:\n                identifier = RowWrapper._increment_numeric_suffix(identifier)\n            fixed[identifier] = name\n        return fixed", "response": "Ensure all column names are unique identifiers."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _make_identifier(string):\n        string = re.sub(r\"[ \\-+/\\\\*%&$\u00a3#@.,;:'\" \"?<>]\", \"_\", string)\n        if re.match(r\"^\\d\", string):\n            string = \"a_{0}\".format(string)\n        return string", "response": "Attempt to convert string into a valid identifier by replacing invalid characters with _s and prefix with a_."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nincrement numeric suffix to identifier.", "response": "def _increment_numeric_suffix(s):\n        \"\"\"Increment (or add) numeric suffix to identifier.\"\"\"\n        if re.match(r\".*\\d+$\", s):\n            return re.sub(r\"\\d+$\", lambda n: str(int(n.group(0)) + 1), s)\n        return s + \"_2\""}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wrap(self, row: Union[Mapping[str, Any], Sequence[Any]]):\n        return (\n            self.dataclass(\n                **{\n                    ident: row[column_name]\n                    for ident, column_name in self.ids_and_column_names.items()\n                }\n            )\n            if isinstance(row, Mapping)\n            else self.dataclass(\n                **{ident: val for ident, val in zip(self.ids_and_column_names.keys(), row)}\n            )\n        )", "response": "Return row tuple for row."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn row tuple for each row in rows.", "response": "def wrap_all(self, rows: Iterable[Union[Mapping[str, Any], Sequence[Any]]]):\n        \"\"\"Return row tuple for each row in rows.\"\"\"\n        return (self.wrap(r) for r in rows)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds custom error handlers for PyMacaronCoreExceptions to the app", "response": "def add_error_handlers(app):\n    \"\"\"Add custom error handlers for PyMacaronCoreExceptions to the app\"\"\"\n\n    def handle_validation_error(error):\n        response = jsonify({'message': str(error)})\n        response.status_code = error.status_code\n        return response\n\n    app.errorhandler(ValidationError)(handle_validation_error)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_backends(self, service_id, version_number):\n\n\t\tcontent = self._fetch(\"/service/%s/version/%d/backend\" % (service_id, version_number))\n\t\treturn map(lambda x: FastlyBackend(self, x), content)", "response": "List all backends for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a backend for a particular service and version.", "response": "def create_backend(self, \n\t\tservice_id,\n\t\tversion_number, \n\t\tname, \n\t\taddress,\n\t\tuse_ssl=False,\n\t\tport=80,\n\t\tconnect_timeout=1000,\n\t\tfirst_byte_timeout=15000,\n\t\tbetween_bytes_timeout=10000,\n\t\terror_threshold=0,\n\t\tmax_conn=20,\n\t\tweight=100,\n\t\tauto_loadbalance=False,\n\t\tshield=None,\n\t\trequest_condition=None,\n\t\thealthcheck=None,\n\t\tcomment=None):\n\t\t\"\"\"Create a backend for a particular service and version.\"\"\"\n\t\tbody = self._formdata({\n\t\t\t\"name\": name,\n\t\t\t\"address\": address,\n\t\t\t\"use_ssl\": use_ssl,\n\t\t\t\"port\": port,\n\t\t\t\"connect_timeout\": connect_timeout,\n\t\t\t\"first_byte_timeout\": first_byte_timeout,\n\t\t\t\"between_bytes_timeout\": between_bytes_timeout,\n\t\t\t\"error_threshold\": error_threshold,\n\t\t\t\"max_conn\": max_conn,\n\t\t\t\"weight\": weight,\n\t\t\t\"auto_loadbalance\": auto_loadbalance,\n\t\t\t\"shield\": shield,\n\t\t\t\"request_condition\": request_condition,\n\t\t\t\"healthcheck\": healthcheck,\n\t\t\t\"comment\": comment,\n\t\t}, FastlyBackend.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/backend\" % (service_id, version_number), method=\"POST\", body=body)\n\t\treturn FastlyBackend(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the backend for a particular service and version.", "response": "def get_backend(self, service_id, version_number, name):\n\t\t\"\"\"Get the backend for a particular service and version.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/backend/%s\" % (service_id, version_number, name))\n\t\treturn FastlyBackend(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_backend(self, service_id, version_number, name_key, **kwargs):\n\t\tbody = self._formdata(kwargs, FastlyBackend.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/backend/%s\" % (service_id, version_number, name_key), method=\"PUT\", body=body)\n\t\treturn FastlyBackend(self, content)", "response": "Update the backend for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_backends(self, service_id, version_number):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/backend/check_all\" % (service_id, version_number))\n\t\t# TODO: Use a strong-typed class for output?\n\t\treturn content", "response": "Performs a health check against each backend in version."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_cache_settings(self, service_id, version_number):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/cache_settings\" % (service_id, version_number))\n\t\treturn map(lambda x: FastlyCacheSettings(self, x), content)", "response": "Get a list of all cache settings for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new cache settings object.", "response": "def create_cache_settings(self, \n\t\tservice_id, \n\t\tversion_number, \n\t\tname,\n\t\taction,\n\t\tttl=None,\n\t\tstale_ttl=None,\n\t\tcache_condition=None):\n\t\t\"\"\"Create a new cache settings object.\"\"\"\n\t\tbody = self._formdata({\n\t\t\t\"name\": name,\n\t\t\t\"action\": action,\n\t\t\t\"ttl\": ttl,\n\t\t\t\"stale_ttl\": stale_ttl,\n\t\t\t\"cache_condition\": cache_condition,\n\t\t}, FastlyCacheSettings.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/cache_settings\" % (service_id, version_number), method=\"POST\", body=body)\n\t\treturn FastlyCacheSettings(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a specific cache settings object.", "response": "def get_cache_settings(self, service_id, version_number, name):\n\t\t\"\"\"Get a specific cache settings object.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/cache_settings/%s\" % (service_id, version_number, name))\n\t\treturn FastlyCacheSettings(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_cache_settings(self, service_id, version_number, name_key, **kwargs):\n\t\tbody = self._formdata(kwargs, FastlyCacheSettings.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/cache_settings/%s\" % (service_id, version_number, name_key), method=\"PUT\", body=body)\n\t\treturn FastlyCacheSettings(self, content)", "response": "Update a specific cache settings object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_cache_settings(self, service_id, version_number, name):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/cache_settings/%s\" % (service_id, version_number, name), method=\"DELETE\")\n\t\treturn self._status(content)", "response": "Delete a specific cache settings object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_conditions(self, service_id, version_number):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/condition\" % (service_id, version_number))\n\t\treturn map(lambda x: FastlyCondition(self, x), content)", "response": "Gets all conditions for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_condition(self, \n\t\tservice_id, \n\t\tversion_number,\n\t\tname,\n\t\t_type,\n\t\tstatement,\n\t\tpriority=\"10\", \n\t\tcomment=None):\n\t\t\"\"\"Creates a new condition.\"\"\"\n\t\tbody = self._formdata({\n\t\t\t\"name\": name,\n\t\t\t\"type\": _type,\n\t\t\t\"statement\": statement,\n\t\t\t\"priority\": priority,\n\t\t\t\"comment\": comment,\n\t\t}, FastlyCondition.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/condition\" % (service_id, version_number), method=\"POST\", body=body)\n\t\treturn FastlyCondition(self, content)", "response": "Creates a new condition."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_condition(self, service_id, version_number, name):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/condition/%s\" % (service_id, version_number, name))\n\t\treturn FastlyCondition(self, content)", "response": "Gets a specified condition."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_condition(self, service_id, version_number, name_key, **kwargs):\n\t\tbody = self._formdata(kwargs, FastlyCondition.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/condition/%s\" % (service_id, version_number, name_key), method=\"PUT\", body=body)\n\t\treturn FastlyCondition(self, content)", "response": "Updates the specified condition."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves headers and MD5 hash of the content for a particular url from each Fastly edge server.", "response": "def content_edge_check(self, url):\n\t\t\"\"\"Retrieve headers and MD5 hash of the content for a particular url from each Fastly edge server.\"\"\"\n\t\tprefixes = [\"http://\", \"https://\"]\n\t\tfor prefix in prefixes:\n\t\t\tif url.startswith(prefix):\n\t\t\t\turl = url[len(prefix):]\n\t\t\t\tbreak\n\t\tcontent = self._fetch(\"/content/edge_check/%s\" % url)\n\t\treturn content"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_customer(self, customer_id):\n\t\tcontent = self._fetch(\"/customer/%s\" % customer_id)\n\t\treturn FastlyCustomer(self, content)", "response": "Get a specific customer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlist all users from a specified customer id.", "response": "def list_customer_users(self, customer_id):\n\t\t\"\"\"List all users from a specified customer id.\"\"\"\n\t\tcontent = self._fetch(\"/customer/users/%s\" % customer_id)\n\t\treturn map(lambda x: FastlyUser(self, x), content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_directors(self, service_id, version_number):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/director\" % (service_id, version_number))\n\t\treturn map(lambda x: FastlyDirector(self, x), content)", "response": "List the directors for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_director(self, service_id, version_number, \n\t\tname, \n\t\tquorum=75,\n\t\t_type=FastlyDirectorType.RANDOM,\n\t\tretries=5,\n\t\tshield=None):\n\t\t\"\"\"Create a director for a particular service and version.\"\"\"\n\t\tbody = self._formdata({\n\t\t\t\"name\": name,\n\t\t\t\"quorum\": quorum,\n\t\t\t\"type\": _type,\n\t\t\t\"retries\": retries,\n\t\t\t\"shield\": shield,\n\n\t\t}, FastlyDirector.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/director\" % (service_id, version_number), method=\"POST\", body=body)\n\t\treturn FastlyDirector(self, content)", "response": "Create a director for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the director for a particular service and version.", "response": "def get_director(self, service_id, version_number, name):\n\t\t\"\"\"Get the director for a particular service and version.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/director/%s\" % (service_id, version_number, name))\n\t\treturn FastlyDirector(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_director(self, service_id, version_number, name_key, **kwargs):\n\t\tbody = self._formdata(kwargs, FastlyDirector.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/director/%s\" % (service_id, version_number, name_key), method=\"PUT\", body=body)\n\t\treturn FastlyDirector(self, content)", "response": "Update the director for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_director_backend(self, service_id, version_number, director_name, backend_name):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/director/%s/backend/%s\" % (service_id, version_number, director_name, backend_name), method=\"GET\")\n\t\treturn FastlyDirectorBackend(self, content)", "response": "Returns the relationship between a Backend and a Director."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_director_backend(self, service_id, version_number, director_name, backend_name):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/director/%s/backend/%s\" % (service_id, version_number, director_name, backend_name), method=\"DELETE\")\n\t\treturn self._status(content)", "response": "Deletes the relationship between a Backend and a Director."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting the domains for a particular service and version.", "response": "def list_domains(self, service_id, version_number):\n\t\t\"\"\"List the domains for a particular service and version.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/domain\" % (service_id, version_number))\n\t\treturn map(lambda x: FastlyDomain(self, x), content)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a domain for a particular service and version.", "response": "def create_domain(self,\n\t\tservice_id, \n\t\tversion_number, \n\t\tname, \n\t\tcomment=None):\n\t\t\"\"\"Create a domain for a particular service and version.\"\"\"\n\t\tbody = self._formdata({\n\t\t\t\"name\": name,\n\t\t\t\"comment\": comment,\n\n\t\t}, FastlyDomain.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/domain\" % (service_id, version_number), method=\"POST\", body=body)\n\t\treturn FastlyDomain(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the domain for a particular service and version.", "response": "def get_domain(self, service_id, version_number, name):\n\t\t\"\"\"Get the domain for a particular service and version.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/domain/%s\" % (service_id, version_number, name))\n\t\treturn FastlyDomain(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_domain(self, service_id, version_number, name_key, **kwargs):\n\t\tbody = self._formdata(kwargs, FastlyDomain.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/domain/%s\" % (service_id, version_number, name_key), method=\"PUT\", body=body)\n\t\treturn FastlyDomain(self, content)", "response": "Update the domain for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking the status of a domain. Returns an array of 3 items. The first is the details for the domain. The second is the current CNAME of the domain. The third is a boolean indicating whether or not the domain has been properly setup to use Fastly.", "response": "def check_domain(self, service_id, version_number, name):\n\t\t\"\"\"Checks the status of a domain's DNS record. Returns an array of 3 items. The first is the details for the domain. The second is the current CNAME of the domain. The third is a boolean indicating whether or not it has been properly setup to use Fastly.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/domain/%s/check\" % (service_id, version_number, name))\n\t\treturn FastlyDomainCheck(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_domains(self, service_id, version_number):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/domain/check_all\" % (service_id, version_number))\n\t\treturn map(lambda x: FastlyDomainCheck(self, x), content)", "response": "Checks the status of all domain DNS records for a Service Version. Returns an array of items in the same format as the single domain / check."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the specified event log.", "response": "def get_event_log(self, object_id):\n\t\t\"\"\"Get the specified event log.\"\"\"\n\t\tcontent = self._fetch(\"/event_log/%s\" % object_id, method=\"GET\")\n\t\treturn FastlyEventLog(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve all Header objects for a particular Service and Version.", "response": "def list_headers(self, service_id, version_number):\n\t\t\"\"\"Retrieves all Header objects for a particular Version of a Service.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/header\" % (service_id, version_number))\n\t\treturn map(lambda x: FastlyHeader(self, x), content)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new Header object.", "response": "def create_header(self, service_id, version_number, name, destination, source, _type=FastlyHeaderType.RESPONSE, action=FastlyHeaderAction.SET, regex=None, substitution=None, ignore_if_set=None, priority=10, response_condition=None, cache_condition=None, request_condition=None):\n\t\tbody = self._formdata({\n\t\t\t\"name\": name,\n\t\t\t\"dst\": destination,\n\t\t\t\"src\": source,\n\t\t\t\"type\": _type,\n\t\t\t\"action\": action,\n\t\t\t\"regex\": regex,\n\t\t\t\"substitution\": substitution,\n\t\t\t\"ignore_if_set\": ignore_if_set,\n\t\t\t\"priority\": priority,\n\t\t\t\"response_condition\": response_condition,\n\t\t\t\"request_condition\": request_condition,\n\t\t\t\"cache_condition\": cache_condition,\n\t\t}, FastlyHeader.FIELDS)\n\t\t\"\"\"Creates a new Header object.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/header\" % (service_id, version_number), method=\"POST\", body=body)\n\t\treturn FastlyHeader(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_header(self, service_id, version_number, name):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/header/%s\" % (service_id, version_number, name))\n\t\treturn FastlyHeader(self, content)", "response": "Retrieves a Header object by name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_header(self, service_id, version_number, name_key, **kwargs):\n\t\tbody = self._formdata(kwargs, FastlyHeader.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/header/%s\" % (service_id, version_number, name_key), method=\"PUT\", body=body)\n\t\treturn FastlyHeader(self, content)", "response": "Modifies an existing Header object by name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_healthchecks(self, service_id, version_number):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/healthcheck\" % (service_id, version_number))\n\t\treturn map(lambda x: FastlyHealthCheck(self, x), content)", "response": "List all of the healthchecks for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_healthcheck(self,\n\t\tservice_id, \n\t\tversion_number,\n\t\tname,\n\t\thost,\n\t\tmethod=\"HEAD\",\n\t\tpath=\"/\",\n\t\thttp_version=\"1.1\",\n\t\ttimeout=1000,\n\t\tcheck_interval=5000,\n\t\texpected_response=200,\n\t\twindow=5,\n\t\tthreshold=3,\n\t\tinitial=1):\n\t\t\"\"\"Create a healthcheck for a particular service and version.\"\"\"\n\t\tbody = self._formdata({\n\t\t\t\"name\": name,\n\t\t\t\"method\": method,\n\t\t\t\"host\": host,\n\t\t\t\"path\": path,\n\t\t\t\"http_version\": http_version,\n\t\t\t\"timeout\": timeout,\n\t\t\t\"check_interval\": check_interval,\n\t\t\t\"expected_response\": expected_response,\n\t\t\t\"window\": window,\n\t\t\t\"threshold\": threshold,\n\t\t\t\"initial\": initial,\n\t\t}, FastlyHealthCheck.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/healthcheck\" % (service_id, version_number), method=\"POST\", body=body)\n\t\treturn FastlyHealthCheck(self, content)", "response": "Create a healthcheck for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the healthcheck for a particular service and version.", "response": "def get_healthcheck(self, service_id, version_number, name):\n\t\t\"\"\"Get the healthcheck for a particular service and version.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/healthcheck/%s\" % (service_id, version_number, name))\n\t\treturn FastlyHealthCheck(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npurging an individual URL.", "response": "def\tpurge_url(self, host, path):\n\t\t\"\"\"Purge an individual URL.\"\"\"\n\t\tcontent = self._fetch(path, method=\"PURGE\", headers={ \"Host\": host }) \n\t\treturn FastlyPurge(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the status and times of a recently completed purge.", "response": "def check_purge_status(self, purge_id):\n\t\t\"\"\"Get the status and times of a recently completed purge.\"\"\"\n\t\tcontent = self._fetch(\"/purge?id=%s\" % purge_id)\n\t\treturn map(lambda x: FastlyPurgeStatus(self, x), content)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_request_settings(self, service_id, version_number):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/request_settings\" % (service_id, version_number))\n\t\treturn map(lambda x: FastlyRequestSetting(self, x), content)", "response": "Returns a list of all Request Settings objects for the given service and version."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new Request Settings object.", "response": "def create_request_setting(self,\n\t\tservice_id,\n\t\tversion_number,\n\t\tname,\n\t\tdefault_host=None,\n\t\tforce_miss=None,\n\t\tforce_ssl=None,\n\t\taction=None,\n\t\tbypass_busy_wait=None,\n\t\tmax_stale_age=None,\n\t\thash_keys=None,\n\t\txff=None,\n\t\ttimer_support=None,\n\t\tgeo_headers=None,\n\t\trequest_condition=None):\n\t\t\"\"\"Creates a new Request Settings object.\"\"\"\n\t\tbody = self._formdata({\n\t\t\t\"name\": name,\n\t\t\t\"default_host\": default_host,\n\t\t\t\"force_miss\": force_miss,\n\t\t\t\"force_ssl\": force_ssl,\n\t\t\t\"action\": action,\n\t\t\t\"bypass_busy_wait\": bypass_busy_wait,\n\t\t\t\"max_stale_age\": max_stale_age,\n\t\t\t\"hash_keys\": hash_keys,\n\t\t\t\"xff\": xff,\n\t\t\t\"timer_support\": timer_support,\n\t\t\t\"geo_headers\": geo_headers,\n\t\t\t\"request_condition\": request_condition,\n\t\t}, FastlyRequestSetting.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/request_settings\" % (service_id, version_number), method=\"POST\", body=body)\n\t\treturn FastlyRequestSetting(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the specified Request Settings object.", "response": "def get_request_setting(self, service_id, version_number, name):\n\t\t\"\"\"Gets the specified Request Settings object.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/request_settings/%s\" % (service_id, version_number, name))\n\t\treturn FastlyRequestSetting(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the specified Request Settings object.", "response": "def update_request_setting(self, service_id, version_number, name_key, **kwargs):\n\t\t\"\"\"Updates the specified Request Settings object.\"\"\"\n\t\tbody = self._formdata(kwargs, FastlyHealthCheck.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/request_settings/%s\" % (service_id, version_number, name_key), method=\"PUT\", body=body)\n\t\treturn FastlyRequestSetting(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_response_objects(self, service_id, version_number):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/response_object\" % (service_id, version_number))\n\t\treturn map(lambda x: FastlyResponseObject(self, x), content)", "response": "Returns all Response Objects for the specified service and version."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new Response Object.", "response": "def create_response_object(self, service_id, version_number, name, status=\"200\", response=\"OK\", content=\"\", request_condition=None, cache_condition=None):\n\t\t\"\"\"Creates a new Response Object.\"\"\"\n\t\tbody = self._formdata({\n\t\t\t\"name\": name,\n\t\t\t\"status\": status,\n\t\t\t\"response\": response,\n\t\t\t\"content\": content,\n\t\t\t\"request_condition\": request_condition,\n\t\t\t\"cache_condition\": cache_condition,\n\t\t}, FastlyResponseObject.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/response_object\" % (service_id, version_number), method=\"POST\", body=body)\n\t\treturn FastlyResponseObject(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_response_object(self, service_id, version_number, name):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/response_object/%s\" % (service_id, version_number, name))\n\t\treturn FastlyResponseObject(self, content)", "response": "Gets the specified Response Object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_response_object(self, service_id, version_number, name_key, **kwargs):\n\t\tbody = self._formdata(kwargs, FastlyResponseObject.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/response_object/%s\" % (service_id, version_number, name_key), method=\"PUT\", body=body)\n\t\treturn FastlyResponseObject(self, content)", "response": "Updates the specified Response Object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a specific service by id.", "response": "def get_service(self, service_id):\n\t\t\"\"\"Get a specific service by id.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s\" % service_id)\n\t\treturn FastlyService(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting detailed information on a specified service.", "response": "def get_service_details(self, service_id):\n\t\t\"\"\"List detailed information on a specified service.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/details\" % service_id)\n\t\treturn FastlyService(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a specific service by name.", "response": "def get_service_by_name(self, service_name):\n\t\t\"\"\"Get a specific service by name.\"\"\"\n\t\tcontent = self._fetch(\"/service/search?name=%s\" % service_name)\n\t\treturn FastlyService(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting the domains within a service.", "response": "def list_domains_by_service(self, service_id):\n\t\t\"\"\"List the domains within a service.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/domain\" % service_id, method=\"GET\")\n\t\treturn map(lambda x: FastlyDomain(self, x), content)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npurging everything from a service.", "response": "def purge_service(self, service_id):\n\t\t\"\"\"Purge everything from a service.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/purge_all\" % service_id, method=\"POST\")\n\t\treturn self._status(content)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npurging a particular service by a key.", "response": "def purge_service_by_key(self, service_id, key):\n\t\t\"\"\"Purge a particular service by a key.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/purge/%s\" % (service_id, key), method=\"POST\")\n\t\treturn self._status(content)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the settings for a particular service and version.", "response": "def get_settings(self, service_id, version_number):\n\t\t\"\"\"Get the settings for a particular service and version.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/settings\" % (service_id, version_number))\n\t\treturn FastlySettings(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the settings for a particular service and version.", "response": "def update_settings(self, service_id, version_number, settings={}):\n\t\t\"\"\"Update the settings for a particular service and version.\"\"\"\n\t\tbody = urllib.urlencode(settings)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/settings\" % (service_id, version_number), method=\"PUT\", body=body)\n\t\treturn FastlySettings(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the stats from a service.", "response": "def get_stats(self, service_id, stat_type=FastlyStatsType.ALL):\n\t\t\"\"\"Get the stats from a service.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/stats/%s\" % (service_id, stat_type))\n\t\treturn content"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_syslogs(self, service_id, version_number):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/syslog\" % (service_id, version_number))\n\t\treturn map(lambda x: FastlySyslog(self, x), content)", "response": "List all of the Syslogs for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_syslog(self,\n\t\tservice_id,\n\t\tversion_number,\n\t\tname,\n\t\taddress,\n\t\tport=514,\n\t\tuse_tls=\"0\",\n\t\ttls_ca_cert=None,\n\t\ttoken=None,\n\t\t_format=None,\n\t\tresponse_condition=None):\n\t\t\"\"\"Create a Syslog for a particular service and version.\"\"\"\n\t\tbody = self._formdata({\n\t\t\t\"name\": name,\n\t\t\t\"address\": address,\n\t\t\t\"port\": port,\n\t\t\t\"use_tls\": use_tls,\n\t\t\t\"tls_ca_cert\": tls_ca_cert,\n\t\t\t\"token\": token,\n\t\t\t\"format\": _format,\n\t\t\t\"response_condition\": response_condition,\n\t\t}, FastlySyslog.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/syslog\" % (service_id, version_number), method=\"POST\", body=body)\n\t\treturn FastlySyslog(self, content)", "response": "Create a Syslog for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the Syslog for a particular service and version.", "response": "def get_syslog(self, service_id, version_number, name):\n\t\t\"\"\"Get the Syslog for a particular service and version.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/syslog/%s\" % (service_id, version_number, name))\n\t\treturn FastlySyslog(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_syslog(self, service_id, version_number, name_key, **kwargs):\n\t\tbody = self._formdata(kwargs, FastlySyslog.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/syslog/%s\" % (service_id, version_number, name_key), method=\"PUT\", body=body)\n\t\treturn FastlySyslog(self, content)", "response": "Update the Syslog for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the user s password to a new one.", "response": "def change_password(self, old_password, new_password):\n\t\t\"\"\"Update the user's password to a new one.\"\"\"\n\t\tbody = self._formdata({\n\t\t\t\"old_password\": old_password,\n\t\t\t\"password\": new_password,\n\t\t}, [\"old_password\", \"password\"])\n\t\tcontent = self._fetch(\"/current_user/password\", method=\"POST\", body=body)\n\t\treturn FastlyUser(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_user(self, user_id):\n\t\tcontent = self._fetch(\"/user/%s\" % user_id)\n\t\treturn FastlyUser(self, content)", "response": "Get a specific user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrequest a password reset for the specified user.", "response": "def request_password_reset(self, user_id):\n\t\t\"\"\"Requests a password reset for the specified user.\"\"\"\n\t\tcontent = self._fetch(\"/user/%s/password/request_reset\" % (user_id), method=\"POST\")\n\t\treturn FastlyUser(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_vcls(self, service_id, version_number):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/vcl\" % (service_id, version_number))\n\t\treturn map(lambda x: FastlyVCL(self, x), content)", "response": "List the uploaded VCLs for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef upload_vcl(self, service_id, version_number, name, content, main=None, comment=None):\n\t\tbody = self._formdata({\n\t\t\t\"name\": name,\n\t\t\t\"content\": content,\n\t\t\t\"comment\": comment,\n\t\t\t\"main\": main,\n\t\t}, FastlyVCL.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/vcl\" % (service_id, version_number), method=\"POST\", body=body)\n\t\treturn FastlyVCL(self, content)", "response": "Upload a VCL for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vcl(self, service_id, version_number, name, include_content=True):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/vcl/%s?include_content=%d\" % (service_id, version_number, name, int(include_content)))\n\t\treturn FastlyVCL(self, content)", "response": "Get the uploaded VCL for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the uploaded VCL for a particular service and version with HTML syntax highlighting.", "response": "def get_vcl_html(self, service_id, version_number, name):\n\t\t\"\"\"Get the uploaded VCL for a particular service and version with HTML syntax highlighting.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/vcl/%s/content\" % (service_id, version_number, name))\n\t\treturn content.get(\"content\", None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndisplays the generated VCL for a particular service and version.", "response": "def get_generated_vcl(self, service_id, version_number):\n\t\t\"\"\"Display the generated VCL for a particular service and version.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/generated_vcl\" % (service_id, version_number))\n\t\treturn FastlyVCL(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndisplaying the content of generated VCL with HTML syntax highlighting.", "response": "def get_generated_vcl_html(self, service_id, version_number):\n\t\t\"\"\"Display the content of generated VCL with HTML syntax highlighting.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/generated_vcl/content\" % (service_id, version_number))\n\t\treturn content.get(\"content\", None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_main_vcl(self, service_id, version_number, name):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/vcl/%s/main\" % (service_id, version_number, name), method=\"PUT\")\n\t\treturn FastlyVCL(self, content)", "response": "Set the specified VCL as the main VCL."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_vcl(self, service_id, version_number, name_key, **kwargs):\n\t\tbody = self._formdata(kwargs, FastlyVCL.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/vcl/%s\" % (service_id, version_number, name_key), method=\"PUT\", body=body)\n\t\treturn FastlyVCL(self, content)", "response": "Update the uploaded VCL for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_version(self, service_id, inherit_service_id=None, comment=None):\n\t\tbody = self._formdata({\n\t\t\t\"service_id\": service_id,\n\t\t\t\"inherit_service_id\": inherit_service_id,\n\t\t\t\"comment\": comment,\n\t\t}, FastlyVersion.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version\" % service_id, method=\"POST\", body=body)\n\t\treturn FastlyVersion(self, content)", "response": "Create a version for a particular service."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_version(self, service_id, version_number):\n\t\tcontent = self._fetch(\"/service/%s/version/%d\" % (service_id, version_number))\n\t\treturn FastlyVersion(self, content)", "response": "Get the version for a particular service."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_version(self, service_id, version_number, **kwargs):\n\t\tbody = self._formdata(kwargs, FastlyVersion.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/\" % (service_id, version_number), method=\"PUT\", body=body)\n\t\treturn FastlyVersion(self, content)", "response": "Update a particular version for a particular service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclone the current configuration into a new version.", "response": "def clone_version(self, service_id, version_number):\n\t\t\"\"\"Clone the current configuration into a new version.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/clone\" % (service_id, version_number), method=\"PUT\")\n\t\treturn FastlyVersion(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nactivates the current version.", "response": "def activate_version(self, service_id, version_number):\n\t\t\"\"\"Activate the current version.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/activate\" % (service_id, version_number), method=\"PUT\")\n\t\treturn FastlyVersion(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeactivates the current version.", "response": "def deactivate_version(self, service_id, version_number):\n\t\t\"\"\"Deactivate the current version.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/deactivate\" % (service_id, version_number), method=\"PUT\")\n\t\treturn FastlyVersion(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate_version(self, service_id, version_number):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/validate\" % (service_id, version_number))\n\t\treturn self._status(content)", "response": "Validate the version for a particular service and version."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lock_version(self, service_id, version_number):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/lock\" % (service_id, version_number))\n\t\treturn self._status(content)", "response": "Locks the specified version."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all of the wordpresses for a specified service and version.", "response": "def list_wordpressess(self, service_id, version_number):\n\t\t\"\"\"Get all of the wordpresses for a specified service and version.\"\"\"\n\t\tcontent = self._fetch(\"/service/%s/version/%d/wordpress\" % (service_id, version_number))\n\t\treturn map(lambda x: FastlyWordpress(self, x), content)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a wordpress for the specified service and version.", "response": "def create_wordpress(self,\n\t\tservice_id,\n\t\tversion_number,\n\t\tname,\n\t\tpath,\n\t\tcomment=None):\n\t\t\"\"\"Create a wordpress for the specified service and version.\"\"\"\n\t\tbody = self._formdata({\n\t\t\t\"name\": name,\n\t\t\t\"path\": path,\n\t\t\t\"comment\": comment,\n\t\t}, FastlyWordpress.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/wordpress\" % (service_id, version_number), method=\"POST\", body=body)\n\t\treturn FastlyWordpress(self, content)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_wordpress(self, service_id, version_number, name):\n\t\tcontent = self._fetch(\"/service/%s/version/%d/wordpress/%s\" % (service_id, version_number, name))\n\t\treturn FastlyWordpress(self, content)", "response": "Get information on a specific wordpress."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_wordpress(self, service_id, version_number, name_key, **kwargs):\n\t\tbody = self._formdata(kwargs, FastlyWordpress.FIELDS)\n\t\tcontent = self._fetch(\"/service/%s/version/%d/wordpress/%s\" % (service_id, version_number, name_key), method=\"PUT\", body=body)\n\t\treturn FastlyWordpress(self, content)", "response": "Update a specified wordpress."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nannotates word for syllabification stress weights and vowels.", "response": "def annotate(self, word):\n        '''Annotate 'word' for syllabification, stress, weights, and vowels.'''\n        info = []  # e.g., [ ('\\'nak.su.`tus.ta', 'PUSU', 'HLHL', 'AUUA'), ]\n\n        for syllabification, _ in syllabify(self.normalize(word), stress=True):\n            stresses = ''\n            weights = ''\n            vowels = ''\n\n            for syll in syllable_split(syllabification):\n\n                try:\n                    vowels += get_vowel(syll)\n                    weights += get_weight(syll)\n                    stresses += {'\\'': 'P', '`': 'S'}.get(syll[0], 'U')\n\n                except AttributeError:\n\n                    # if the syllable is vowel-less...\n                    if syll[-1].isalpha():\n                        stresses += '*'\n                        weights += '*'\n                        vowels += '*'\n\n                    else:\n                        stresses += ' '\n                        weights += ' '\n                        vowels += ' '\n\n            info.append((\n                syllabification,\n                stresses,\n                weights,\n                vowels,\n                ))\n\n        return info"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef runner(self):\n        logging.info('Starting {} analysis pipeline'.format(self.analysistype))\n        # Run the analyses\n        Sippr(self, self.cutoff)\n        self.serotype_escherichia()\n        self.serotype_salmonella()\n        # Create the reports\n        self.reporter()\n        # Print the metadata\n        metadataprinter.MetadataPrinter(self)", "response": "Run the analyses in the correct order and create the reports and metadata printers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reporter(self):\n        logging.info('Creating {} report'.format(self.analysistype))\n        # Create the path in which the reports are stored\n        make_path(self.reportpath)\n        header = 'Strain,Serotype\\n'\n        data = ''\n        with open(os.path.join(self.reportpath, '{}.csv'.format(self.analysistype)), 'w') as report:\n            for sample in self.runmetadata.samples:\n                if sample.general.bestassemblyfile != 'NA':\n                    data += sample.name + ','\n                    if sample[self.analysistype].results:\n                        # Set the O-type as either the appropriate attribute, or O-untypable\n                        if ';'.join(sample.serosippr.o_set) == '-':\n                            otype = 'O-untypeable'\n                        else:\n                            otype = '{oset} ({opid})'.format(oset=';'.join(sample.serosippr.o_set),\n                                                             opid=sample.serosippr.best_o_pid)\n                        # Same as above, but for the H-type\n                        if ';'.join(sample.serosippr.h_set) == '-':\n                            htype = 'H-untypeable'\n\n                        else:\n                            htype = '{hset} ({hpid})'.format(hset=';'.join(sample.serosippr.h_set),\n                                                             hpid=sample.serosippr.best_h_pid)\n                        serotype = '{otype}:{htype}'.format(otype=otype,\n                                                            htype=htype)\n                        # Populate the data string\n                        data += serotype if serotype != 'O-untypeable:H-untypeable' else 'ND'\n                        data += '\\n'\n                    else:\n                        data += '\\n'\n            report.write(header)\n            report.write(data)", "response": "Creates a report of the results of the selected analyses"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef serotype_escherichia(self):\n        for sample in self.runmetadata.samples:\n            # Initialise negative results to be overwritten when necessary\n            sample[self.analysistype].best_o_pid = '-'\n            sample[self.analysistype].o_genes = ['-']\n            sample[self.analysistype].o_set = ['-']\n            sample[self.analysistype].best_h_pid = '-'\n            sample[self.analysistype].h_genes = ['-']\n            sample[self.analysistype].h_set = ['-']\n            if sample.general.bestassemblyfile != 'NA':\n                if sample.general.closestrefseqgenus == 'Escherichia':\n                    o = dict()\n                    h = dict()\n                    for result, percentid in sample[self.analysistype].results.items():\n                        if 'O' in result.split('_')[-1]:\n                            o.update({result: float(percentid)})\n                        if 'H' in result.split('_')[-1]:\n                            h.update({result: float(percentid)})\n                    # O\n                    try:\n                        sorted_o = sorted(o.items(), key=operator.itemgetter(1), reverse=True)\n                        sample[self.analysistype].best_o_pid = str(sorted_o[0][1])\n\n                        sample[self.analysistype].o_genes = [gene for gene, pid in o.items()\n                                                             if str(pid) == sample[self.analysistype].best_o_pid]\n                        sample[self.analysistype].o_set = \\\n                            list(set(gene.split('_')[-1] for gene in sample[self.analysistype].o_genes))\n                    except (KeyError, IndexError):\n                        pass\n                    # H\n                    try:\n                        sorted_h = sorted(h.items(), key=operator.itemgetter(1), reverse=True)\n                        sample[self.analysistype].best_h_pid = str(sorted_h[0][1])\n                        sample[self.analysistype].h_genes = [gene for gene, pid in h.items()\n                                                             if str(pid) == sample[self.analysistype].best_h_pid]\n                        sample[self.analysistype].h_set = \\\n                            list(set(gene.split('_')[-1] for gene in sample[self.analysistype].h_genes))\n                    except (KeyError, IndexError):\n                        pass", "response": "Create attributes storing the best results for the O and H types"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _syllabify(word):\n    '''Syllabify the given word.'''\n    word = replace_umlauts(word)\n    word, CONTINUE_VV, CONTINUE_VVV, applied_rules = apply_T1(word)\n\n    if CONTINUE_VV:\n        word, T2 = apply_T2(word)\n        word, T4 = apply_T4(word)\n        applied_rules += T2 + T4\n\n    if CONTINUE_VVV:\n        word, T5 = apply_T5(word)\n        word, T6 = apply_T6(word)\n        word, T7 = apply_T7(word)\n        applied_rules += T5 + T6 + T7\n\n    word = replace_umlauts(word, put_back=True)\n\n    return word, applied_rules", "response": "Syllabify the given word."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef apply_T2(word):\n    '''There is a syllable boundary within a sequence VV of two nonidentical\n    vowels that are not a genuine diphthong, e.g., [ta.e], [ko.et.taa].'''\n    T2 = ''\n    WORD = word.split('.')\n\n    for i, v in enumerate(WORD):\n\n        if not contains_diphthong(v):\n            VV = contains_VV(v)\n\n            if VV:\n                I = v.find(VV) + 1\n                WORD[i] = v[:I] + '.' + v[I:]\n                T2 = ' T2'\n\n    word = '.'.join(WORD)\n\n    return word, T2", "response": "This function applies T2 to the word."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying T5 to a word.", "response": "def apply_T5(word):  # BROKEN\n    '''If a (V)VVV-sequence contains a VV-sequence that could be an /i/-final\n    diphthong, there is a syllable boundary between it and the third vowel,\n    e.g., [raa.ois.sa], [huo.uim.me], [la.eis.sa], [sel.vi.\u00e4i.si], [tai.an],\n    [s\u00e4i.e], [oi.om.me].'''\n    T5 = ''\n    WORD = word.split('.')\n\n    for i, v in enumerate(WORD):\n        if contains_VVV(v) and any(i for i in i_DIPHTHONGS if i in v):\n            I = v.rfind('i') - 1 or 2\n            I = I + 2 if is_consonant(v[I - 1]) else I\n            WORD[i] = v[:I] + '.' + v[I:]\n            T5 = ' T5'\n\n    word = '.'.join(WORD)\n\n    return word, T5"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef apply_T6(word):\n    '''If a VVV-sequence contains a long vowel, there is a syllable boundary\n    between it and the third vowel, e.g. [kor.ke.aa], [yh.ti.\u00f6\u00f6n], [ruu.an],\n    [m\u00e4\u00e4.yt.te].'''\n    T6 = ''\n    WORD = word.split('.')\n\n    for i, v in enumerate(WORD):\n\n        if contains_VVV(v):\n            VV = [v.find(j) for j in LONG_VOWELS if v.find(j) > 0]\n\n            if VV:\n                I = VV[0]\n                T6 = ' T6'\n\n                if I + 2 == len(v) or is_vowel(v[I + 2]):\n                    WORD[i] = v[:I + 2] + '.' + v[I + 2:]  # TODO\n\n                else:\n                    WORD[i] = v[:I] + '.' + v[I:]\n\n    word = '.'.join(WORD)\n    word = word.strip('.')  # TODO\n\n    return word, T6", "response": "This function applies T6 to the word."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef apply_T7(word):\n    '''If a VVV-sequence does not contain a potential /i/-final diphthong,\n    there is a syllable boundary between the second and third vowels, e.g.\n    [kau.an], [leu.an], [kiu.as].'''\n    T7 = ''\n    WORD = word.split('.')\n\n    for i, v in enumerate(WORD):\n\n        if contains_VVV(v):\n\n            for I, V in enumerate(v[::-1]):\n\n                if is_vowel(V):\n                    WORD[i] = v[:I] + '.' + v[I:]\n                    T7 = ' T7'\n\n    word = '.'.join(WORD)\n\n    return word, T7", "response": "Apply T7 to a VVV - sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main():\n\n    parser = OptionParser(description=\n             \"Upload a vcl file (set as main) to a given fastly service. All arguments are required.\")\n    parser.add_option(\"-k\", \"--key\", dest=\"apikey\", help=\"fastly api key\")\n    parser.add_option(\"-u\", \"--user\", dest=\"user\", help=\"fastly user name\")\n    parser.add_option(\"-p\", \"--password\", dest=\"password\",\n                      help=\"fastly password\")\n    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                      help=\"vcl file to upload\")\n    parser.add_option(\"-s\", \"--service\", dest=\"service_name\",\n                      help=\"service to update\")\n    parser.add_option(\"-d\", \"--delete_vcl\", action=\"store_true\",\n                      dest=\"delete_vcl\", default=False,\n                      help=\"delete existing vcl files from service\\\n                            before uploading\")\n    parser.add_option(\"-i\", \"--include\", action=\"store_true\",\n                      dest=\"include_vcl\", default=False,\n                      help=\"do not set uploaded vcl as main,\\\n                            to be included only\")\n\n    (options, args) = parser.parse_args()\n    for val in options.__dict__.values():\n        if val is None:\n            print \"Missing required options:\"\n            parser.print_help()\n            sys.exit(1)\n\n    vcl_name = options.filename.split('/').pop()\n    service_name = options.service_name\n    vcl_file = open(options.filename, 'r')\n    vcl_content = vcl_file.read()\n\n    # Need to fully authenticate to access all features.\n    client = fastly.connect(options.apikey)\n    client.login(options.user, options.password)\n\n    service = client.get_service_by_name(service_name)\n    versions = client.list_versions(service.id)\n    latest = versions.pop()\n\n    if latest.locked is True or latest.active is True:\n        print \"\\n[ Cloning version %d ]\\n\"\\\n            % (latest.number)\n\n        latest = client.clone_version(service.id, latest.number)\n\n    if options.delete_vcl:\n        vcls = client.list_vcls(service.id, latest.number)\n        for vcl in vcls:\n            print \"\\n[ Deleting vcl file %s from version %d ]\\n\" %\\\n                (service_name, latest.number)\n\n            client.delete_vcl(service.id, latest.number, vcl.name)\n\n    if vcl_name in latest.vcls:\n        print \"\\n[ Updating vcl file %s on service %s version %d ]\\n\"\\\n            % (vcl_name, service_name, latest.number)\n\n        client.update_vcl(service.id, latest.number, vcl_name,\n                          content=vcl_content)\n    else:\n        print \"\\n[ Uploading new vcl file %s on service %s version %d ]\\n\"\\\n            % (vcl_name, service_name, latest.number)\n\n        client.upload_vcl(service.id, latest.number, vcl_name, vcl_content)\n\n    if options.include_vcl is False:\n        print \"\\n[ Setting vcl %s as main ]\\n\" % (vcl_name)\n        client.set_main_vcl(service.id, latest.number, vcl_name)\n\n    client.activate_version(service.id, latest.number)\n    print \"\\n[ Activing configuration version %d ]\\n\" % (latest.number)", "response": "This function is used to upload a vcl file to a fastly service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning the necessary methods in the correct order", "response": "def main(self):\n        \"\"\"\n        Run the necessary methods in the correct order\n        \"\"\"\n        self.target_validate()\n        self.gene_names()\n        Sippr(inputobject=self,\n              k=self.kmer_size,\n              allow_soft_clips=self.allow_soft_clips)\n        self.report()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts the names of the user - supplied targets", "response": "def gene_names(self):\n        \"\"\"\n        Extract the names of the user-supplied targets\n        \"\"\"\n        # Iterate through all the target names in the formatted targets file\n        for record in SeqIO.parse(self.targets, 'fasta'):\n            # Append all the gene names to the list of names\n            self.genes.append(record.id)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef report(self):\n        # Add all the genes to the header\n        header = 'Sample,'\n        data = str()\n        with open(os.path.join(self.reportpath, '{at}.csv'.format(at=self.analysistype)), 'w') as report:\n            write_header = True\n            for sample in self.runmetadata:\n                data += sample.name + ','\n                # Iterate through all the user-supplied target names\n                for target in sorted(self.genes):\n                    write_results = False\n                    # There was an issue with 'target' not matching 'name' due to a dash being replaced by an underscore\n                    # only in 'name'. This will hopefully address this issue\n                    target = target.replace('-', '_')\n                    if write_header:\n                        header += '{target}_match_details,{target},'.format(target=target)\n                    for name, identity in sample[self.analysistype].results.items():\n                        # Ensure that all dashes are replaced with underscores\n                        name = name.replace('-', '_')\n                        # If the current target matches the target in the header, add the data to the string\n                        if name == target:\n                            write_results = True\n                            gene_results = '{percent_id}% ({avgdepth} +/- {stddev}),{record},'\\\n                                .format(percent_id=identity,\n                                        avgdepth=sample[self.analysistype].avgdepth[name],\n                                        stddev=sample[self.analysistype].standarddev[name],\n                                        record=sample[self.analysistype].sequences[target])\n                            # Populate the data string appropriately\n                            data += gene_results\n                    # If the target is not present, write dashes to represent the results and sequence\n                    if not write_results:\n                        data += '-,-,'\n                data += ' \\n'\n                write_header = False\n            header += '\\n'\n            # Write the strings to the report\n            report.write(header)\n            report.write(data)", "response": "Create the report for the user - supplied target names and their associated results."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert to pseuso acces", "response": "def on_add(self, item):\n        \"\"\"Convert to pseuso acces\"\"\"\n        super(Tels, self).on_add(list_views.PseudoAccesCategorie(item))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_data(self, *args):\n        db = self.begining.get_data() or formats.DATE_DEFAULT\n        df = self.end.get_data() or formats.DATE_DEFAULT\n        jours = max((df - db).days + 1, 0)\n        self.setText(str(jours) + (jours >= 2 and \" jours\" or \" jour\"))", "response": "set the data of the record"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the necessary methods in the correct order", "response": "def runner(self):\n        \"\"\"\n        Run the necessary methods in the correct order\n        \"\"\"\n        logging.info('Starting {} analysis pipeline'.format(self.analysistype))\n        if not self.pipeline:\n            general = None\n            for sample in self.runmetadata.samples:\n                general = getattr(sample, 'general')\n            if general is None:\n                # Create the objects to be used in the analyses\n                objects = Objectprep(self)\n                objects.objectprep()\n                self.runmetadata = objects.samples\n        # Run the analyses\n        Sippr(self, self.cutoff)\n        # Create the reports\n        reports = Reports(self)\n        Reports.reporter(reports, analysistype=self.analysistype)\n        # Print the metadata\n        MetadataPrinter(self)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef same_syllabic_feature(ch1, ch2):\n    '''Return True if ch1 and ch2 are both vowels or both consonants.'''\n    if ch1 == '.' or ch2 == '.':\n        return False\n\n    ch1 = 'V' if ch1 in VOWELS else 'C' if ch1 in CONSONANTS else None\n    ch2 = 'V' if ch2 in VOWELS else 'C' if ch2 in CONSONANTS else None\n\n    return ch1 == ch2", "response": "Return True if ch1 and ch2 are both vowels or both consonants."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsyllabifies the given word.", "response": "def syllabify(word):\n    '''Syllabify the given word.'''\n\n    word = replace_umlauts(word)\n\n    word = apply_T1(word)\n    word = apply_T2(word)\n    word = apply_T4(word)\n    word = apply_T5(word)\n    word = apply_T6(word)\n    word = apply_T7(word)\n\n    word = replace_umlauts(word, put_back=True)[1:]  # FENCEPOST\n\n    return word"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef apply_T1(word):\n    '''There is a syllable boundary in front of every CV-sequence.'''\n    WORD = _split_consonants_and_vowels(word)\n\n    for k, v in WORD.iteritems():\n\n        if k == 1 and is_consonantal_onset(v):\n            WORD[k] = '.' + v\n\n        elif is_consonant(v[0]) and WORD.get(k + 1, 0):\n            WORD[k] = v[:-1] + '.' + v[-1]\n\n    word = _compile_dict_into_word(WORD)\n\n    return word", "response": "This function applies T1 to the given word."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef apply_T5(word):\n    '''If a (V)VVV-sequence contains a VV-sequence that could be an /i/-final\n    diphthong, there is a syllable boundary between it and the third vowel,\n    e.g., [raa.ois.sa], [huo.uim.me], [la.eis.sa], [sel.vi.\u00e4i.si], [tai.an],\n    [s\u00e4i.e], [oi.om.me].'''\n    WORD = _split_consonants_and_vowels(word)\n\n    for k, v in WORD.iteritems():\n\n        if len(v) >= 3 and is_vowel(v[0]):\n            vv = [v.find(i) for i in i_DIPHTHONGS if v.find(i) > 0]\n\n            if any(vv):\n                vv = vv[0]\n\n                if vv == v[0]:\n                    WORD[k] = v[:2] + '.' + v[2:]\n\n                else:\n                    WORD[k] = v[:vv] + '.' + v[vv:]\n\n    word = _compile_dict_into_word(WORD)\n\n    return word", "response": "This function applies T5 to the word."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\napplying T6 to a word.", "response": "def apply_T6(word):\n    '''If a VVV-sequence contains a long vowel, there is a syllable boundary\n    between it and the third vowel, e.g. [kor.ke.aa], [yh.ti.\u00f6\u00f6n], [ruu.an],\n    [m\u00e4\u00e4.yt.te].'''\n    WORD = _split_consonants_and_vowels(word)\n\n    for k, v in WORD.iteritems():\n\n        if len(v) == 3 and is_vowel(v[0]):\n            vv = [v.find(i) for i in LONG_VOWELS if v.find(i) > 0]\n\n            if any(vv):\n                vv = vv[0]\n\n                if vv == v[0]:\n                    WORD[k] = v[:2] + '.' + v[2:]\n\n                else:\n                    WORD[k] = v[:vv] + '.' + v[vv:]\n\n    word = _compile_dict_into_word(WORD)\n\n    return word"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef syllabify(word):\n    '''Syllabify the given word, whether simplex or complex.'''\n    compound = not word.isalpha()\n    syllabify = _syllabify_complex if compound else _syllabify_simplex\n    syllabifications = list(syllabify(word))\n\n    # if variation, order variants from most preferred to least preferred\n    if len(syllabifications) > 1:\n        syllabifications = rank(syllabifications)\n\n    for word, rules in syllabifications:\n        yield _post_process(word, rules)", "response": "Syllabify the given word whether simplex or complex."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the number of unstressed superheavy syllables.", "response": "def wsp(word):\n    '''Return the number of unstressed superheavy syllables.'''\n    violations = 0\n    unstressed = []\n\n    for w in extract_words(word):\n        unstressed += w.split('.')[1::2]  # even syllables\n\n        # include extrametrical odd syllables as potential WSP violations\n        if w.count('.') % 2 == 0:\n            unstressed += [w.rsplit('.', 1)[-1], ]\n\n    # SHSP\n    for syll in unstressed:\n        if re.search(r'[ieaou\u00e4\u00f6y]{2}[^$ieaou\u00e4\u00f6y]+', syll, flags=FLAGS):\n            violations += 1\n\n    # # WSP (CVV = heavy)\n    # for syll in unstressed:\n    #     if re.search(\n    #             ur'[ieaou\u00e4\u00f6y]{2}|[ieaou\u00e4\u00f6y]+[^ieaou\u00e4\u00f6y]+',\n    #             syll, flags=re.I | re.U):\n    #         violations += 1\n\n    return violations"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef modifie(self, key: str, value: Any) -> None:\n        if key in self.FIELDS_OPTIONS:\n            self.modifie_options(key, value)\n        else:\n            self.modifications[key] = value", "response": "Store the modification. value should be dumped in DB compatible format."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprepare a SQL request to save the current modifications.", "response": "def save(self) -> sql.Executant:\n        \"\"\"Prepare a SQL request to save the current modifications.\n        Returns actually a LIST of requests (which may be of length one).\n        Note than it can include modifications on other part of the data.\n        After succes, the base should be updated.\n        \"\"\"\n        r = self._dict_to_SQL(self.modifications)\n        self.modifications.clear()\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset options in modifications. All options will be stored since it should be grouped in the DB.", "response": "def modifie_options(self, field_option, value):\n        \"\"\"Set options in modifications.\n        All options will be stored since it should be grouped in the DB.\"\"\"\n        options = dict(self[\"options\"] or {}, **{field_option: value})\n        self.modifications[\"options\"] = options"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking a dict containing id and attributes and returns a new dict containing the attributes.", "response": "def _from_dict_dict(cls, dic):\n        \"\"\"Takes a dict {id : dict_attributes} \"\"\"\n        return cls({_convert_id(i): v for i, v in dic.items()})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake a list of dict like objects and uses Champ_ID field as Id", "response": "def _from_list_dict(cls, list_dic):\n        \"\"\"Takes a list of dict like objects and uses `champ_id` field as Id\"\"\"\n        return cls({_convert_id(dic[cls.CHAMP_ID]): dict(dic) for dic in list_dic})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a collection of access matching pattern.", "response": "def base_recherche_rapide(self, base, pattern, to_string_hook=None):\n        \"\"\"\n        Return a collection of access matching `pattern`.\n        `to_string_hook` is an optionnal callable dict -> str to map record to string. Default to _record_to_string\n        \"\"\"\n        Ac = self.ACCES\n        if pattern == \"*\":\n            return groups.Collection(Ac(base, i) for i in self)\n\n        if len(pattern) >= MIN_CHAR_SEARCH:  # Needed chars.\n            sub_patterns = pattern.split(\" \")\n            try:\n                regexps = tuple(re.compile(sub_pattern, flags=re.I)\n                                for sub_pattern in sub_patterns)\n            except re.error:\n                return groups.Collection()\n\n            def search(string):\n                for regexp in regexps:\n                    if not regexp.search(string):\n                        return False\n                return True\n\n            to_string_hook = to_string_hook or self._record_to_string\n            return groups.Collection(Ac(base, i) for i, p in self.items() if search(to_string_hook(p)))\n\n        return groups.Collection()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef select_by_field(self, base, field, value):\n        Ac = self.ACCES\n        return groups.Collection(Ac(base, i) for i, row in self.items() if row[field] == value)", "response": "Return collection of acces whose field equal value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nselect the set of acces that satisfy the criteria.", "response": "def select_by_critere(self, base, criteria):\n        \"\"\"\n        :param base: Reference on whole base\n        :param criteria: Callable abstractAcces -> Bool, acting as filter\n        :return: Collection on acces passing the criteria\n        \"\"\"\n        Ac = self.ACCES\n        return groups.Collection(Ac(base, i) for i in self if criteria(Ac(base, i)))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_from_db(cls, callback_etat=print, out=None):\n        dic = cls._load_remote_db(callback_etat)\n        callback_etat(\"Chargement...\", 2, 3)\n        if out is None:\n            return cls(dic)\n        cls.__init__(out, datas=dic)", "response": "Launch data fetching then load data received."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_text_DB(self, s):\n        dic = self.decode_json_str(s)\n        new_dic = {}\n        for table_name, (header, rows) in dic.items():\n            newl = [{c: ligne[i]\n                     for i, c in enumerate(header)} for ligne in rows]\n            new_dic[table_name] = newl\n        return new_dic", "response": "Returns a dict of table interpreted from s.\n        s should be Json string encoding a dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_from_local(cls):\n        try:\n            with open(cls.LOCAL_DB_PATH, 'rb') as f:\n                b = f.read()\n                s = security.protege_data(b, False)\n        except (FileNotFoundError, KeyError):\n            logging.exception(cls.__name__)\n            raise StructureError(\n                \"Erreur dans le chargement de la sauvegarde locale !\")\n        else:\n            return cls(cls.decode_json_str(s))", "response": "Load datas from local file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dumps(self):\n        return {table_name: getattr(self, table_name).dumps() for table_name in self.TABLES}", "response": "Return a dictionnary of current tables"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_to_local(self, callback_etat=print):\n        callback_etat(\"Aquisition...\", 0, 3)\n        d = self.dumps()\n        s = json.dumps(d, indent=4, cls=formats.JsonEncoder)\n        callback_etat(\"Chiffrement...\", 1, 3)\n        s = security.protege_data(s, True)\n        callback_etat(\"Enregistrement...\", 2, 3)\n        try:\n            with open(self.LOCAL_DB_PATH, 'wb') as f:\n                f.write(s)\n        except (FileNotFoundError):\n            logging.exception(self.__class__.__name__)\n            raise StructureError(\"Chemin de sauvegarde introuvable !\")", "response": "Save current in memory base to local file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading the cell at position x and y and puts the default styles in xlwt", "response": "def read_cell(self, x, y):\n        \"\"\"\n            reads the cell at position x and y; puts the default styles in xlwt\n        \"\"\"\n        cell = self._sheet.row(x)[y]\n        if self._file.xf_list[\n            cell.xf_index].background.pattern_colour_index == 64:\n            self._file.xf_list[\n                cell.xf_index].background.pattern_colour_index = 9\n        if self._file.xf_list[\n            cell.xf_index].background.pattern_colour_index in self.colors.keys():\n            style = self.colors[self._file.xf_list[\n                cell.xf_index].background.pattern_colour_index]\n        else:\n            style = self.xlwt.easyxf(\n                'pattern: pattern solid; border: top thin, right thin, bottom thin, left thin;')\n            style.pattern.pattern_fore_colour = self._file.xf_list[\n                cell.xf_index].background.pattern_colour_index\n            self.colors[self._file.xf_list[\n                cell.xf_index].background.pattern_colour_index] = style\n        style.font.name = self._file.font_list[\n            self._file.xf_list[cell.xf_index].font_index].name\n        style.font.bold = self._file.font_list[\n            self._file.xf_list[cell.xf_index].font_index].bold\n        if isinstance(self.header[y], tuple):\n            header = self.header[y][0]\n        else:\n            header = self.header[y]\n        if self.strip:\n            if is_str_or_unicode(cell.value):\n                cell.value = cell.value.strip()\n        if self.style:\n            return {header: (cell.value, style)}\n        else:\n            return {header: cell.value}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting a cell to the current cell", "response": "def write_cell(self, x, y, value, style=None):\n        \"\"\"\n            writing style and value in the cell of x and y position\n        \"\"\"\n        if isinstance(style, str):\n            style = self.xlwt.easyxf(style)\n        if style:\n            self._sheet.write(x, y, label=value, style=style)\n        else:\n            self._sheet.write(x, y, label=value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_arguments(options):\n   # These the next couple of lines defines the header of the Help output\n   parser = ArgumentParser(\n      formatter_class=RawDescriptionHelpFormatter,\n      usage=(\"\"\"%(prog)s\n--------------------------------------------------------------------------------\n\"\"\"),\n      description=(\"\"\"\nService Wrapper\n===============\nThis is the service wrapper script, which is a part of the CGE services.\nRead the online manual for help.\nA list of all published services can be found at:\ncge.cbs.dtu.dk/services\n\n\"\"\"), epilog=(\"\"\"\n--------------------------------------------------------------------------------\n      \"\"\"))\n\n   #ADDING ARGUMENTS\n   setarg = parser.add_argument\n   #SERVICE SPECIFIC ARGUMENTS\n   if isinstance(options, str):\n      options = [[x for i,x in enumerate(line.split()) if i in [1,2]] for line in options.split('\\n') if len(line)>0]\n      for o in options:\n         try:\n            setarg(o[1], type=str, dest=o[0], default=None, help=SUPPRESS)\n         except:\n            None\n   else:\n      for o in options:\n         if o[2] is True:\n            # Handle negative flags\n            setarg(o[0], action=\"store_false\", dest=o[1], default=o[2],\n                   help=o[3])\n         elif o[2] is False:\n            # Handle positive flags\n            setarg(o[0], action=\"store_true\", dest=o[1], default=o[2],\n                   help=o[3])\n         else:\n            help_ = o[3] if o[2] is None else \"%s [%s]\"%(o[3], '%(default)s')\n            setarg(o[0], type=str, dest=o[1], default=o[2],\n                   help=help_)\n   # VALIDATION OF ARGUMENTS\n   args = parser.parse_args()\n   debug.log(\"ARGS: %s\"%args)\n   return args", "response": "This function handles and validates the arguments of the service wrapper script."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_file_type(files):\n   all_are_fasta = True\n   all_are_reads = True\n   all_are_empty = True\n   if sys.version_info < (3, 0):\n      if isinstance(files, (str, unicode)): files = [files]\n   else:\n      if isinstance(files, str): files = [files]\n   for file_ in files:\n      debug.log('Checking file type: %s'%file_)\n      # Check if file is empty\n      if os.stat(file_).st_size == 0: continue\n      else: all_are_empty = False\n      with open_(file_) as f:\n         fc = f.readline()[0]\n         if fc != \"@\": all_are_reads = False\n         if fc != \">\": all_are_fasta = False\n   if all_are_empty:   return 'empty'\n   elif all_are_fasta: return 'fasta'\n   elif all_are_reads: return 'fastq'\n   else: return 'other'", "response": "Check whether the input files are in fasta format reads format or other format."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_file_list(upload_path):\n   newlist = []\n   for el in sorted(os.listdir(upload_path)):\n      if ' ' in el:\n         raise Exception('Error: Spaces are not allowed in file names!\\n')\n      newlist.append(os.path.normpath(upload_path+'/'+el))\n   debug.log('InputFiles: %s\\n'%newlist)\n   return newlist", "response": "This function returns a list of files in the given dir"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_server_rackspace(connection,\n                            distribution,\n                            disk_name,\n                            disk_size,\n                            ami,\n                            region,\n                            key_pair,\n                            instance_type,\n                            instance_name,\n                            tags={},\n                            security_groups=None):\n    \"\"\"\n    Creates Rackspace Instance and saves it state in a local json file\n    \"\"\"\n\n    log_yellow(\"Creating Rackspace instance...\")\n\n    flavor = connection.flavors.find(name=instance_type)\n    image = connection.images.find(name=ami)\n\n    server = connection.servers.create(name=instance_name,\n                                       flavor=flavor.id,\n                                       image=image.id,\n                                       region=region,\n                                       availability_zone=region,\n                                       key_name=key_pair)\n\n    while server.status == 'BUILD':\n        log_yellow(\"Waiting for build to finish...\")\n        sleep(5)\n        server = connection.servers.get(server.id)\n\n    # check for errors\n    if server.status != 'ACTIVE':\n        log_red(\"Error creating rackspace instance\")\n        exit(1)\n\n    # the server was assigned IPv4 and IPv6 addresses, locate the IPv4 address\n    ip_address = server.accessIPv4\n\n    if ip_address is None:\n        log_red('No IP address assigned')\n        exit(1)\n\n    wait_for_ssh(ip_address)\n    log_green('New server with IP address {0}.'.format(ip_address))\n    return server", "response": "Create Rackspace Instance and save it in local json file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting the rackspace instance.", "response": "def destroy_rackspace(connection, region, instance_id):\n    \"\"\" terminates the instance \"\"\"\n\n    server = connection.servers.get(instance_id)\n    log_yellow('deleting rackspace instance ...')\n    server.delete()\n\n    # wait for server to be deleted\n    try:\n        while True:\n            server = connection.servers.get(server.id)\n            log_yellow('waiting for deletion ...')\n            sleep(5)\n    except:\n        pass\n    log_green('The server has been deleted')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_rackspace_info(connection,\n                       server_id):\n    \"\"\" queries Rackspace for details about a particular server id\n    \"\"\"\n    server = connection.servers.get(server_id)\n\n    data = {}\n    data['ip_address'] = server.accessIPv4\n    data['accessIPv4'] = server.accessIPv4\n    data['accessIPv6'] = server.accessIPv6\n    data['addresses'] = server.addresses\n    data['created'] = server.created\n    data['flavor'] = server.flavor\n    data['id'] = server.hostId\n    data['human_id'] = server.human_id\n    data['image'] = server.image['id']\n    data['key_name'] = server.key_name\n    data['state'] = server.status\n    data['metadata'] = server.metadata\n    data['name'] = server.name\n    data['networks'] = server.networks\n    data['tenant_id'] = server.tenant_id\n    data['user_id'] = server.user_id\n    data['cloud_type'] = 'rackspace'\n    return data", "response": "queries Rackspace for details about a particular server id\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef date_decoder(dic):\n    if '__date__' in dic:\n        try:\n            d = datetime.date(**{c: v for c, v in dic.items() if not c == \"__date__\"})\n        except (TypeError, ValueError):\n            raise json.JSONDecodeError(\"Corrupted date format !\", str(dic), 1)\n    elif '__datetime__' in dic:\n        try:\n            d = datetime.datetime(**{c: v for c, v in dic.items() if not c == \"__datetime__\"})\n        except (TypeError, ValueError):\n            raise json.JSONDecodeError(\"Corrupted datetime format !\", str(dic), 1)\n    else:\n        return dic\n    return d", "response": "Add python types decoding. See JsonEncoder"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _type_bool(label,default=False):\n    return label, abstractSearch.nothing, abstractRender.boolen, default", "response": "Shortcut fot boolean like fields"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef in_string(objet, pattern):\n        return bool(re.search(pattern, str(objet), flags=re.I)) if objet else False", "response": "abstractSearch une chaine sans tenir compte de la casse"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef in_date(objet, pattern):\n        if objet:\n            pattern = re.sub(\" \", '', pattern)\n            objet_str = abstractRender.date(objet)\n            return bool(re.search(pattern, objet_str))\n        return False", "response": "abstractSearch une date objet et et"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef in_dateheure(objet, pattern):\n        if objet:\n            pattern = re.sub(\" \", '', pattern)\n            objet_str = abstractRender.dateheure(objet)\n            return bool(re.search(pattern, objet_str))\n        return False", "response": "returns True if objet is in date - heure"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef date(objet):\n        if objet:\n            return \"{}/{}/{}\".format(objet.day, objet.month, objet.year)\n        return \"\"", "response": "abstractRender d un date datetime. date"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef install(domain, lazy=False):\n    if lazy:\n        # NOTE(mrodden): Lazy gettext functionality.\n        #\n        # The following introduces a deferred way to do translations on\n        # messages in OpenStack. We override the standard _() function\n        # and % (format string) operation to build Message objects that can\n        # later be translated when we have more information.\n        def _lazy_gettext(msg):\n            \"\"\"Create and return a Message object.\n\n            Lazy gettext function for a given domain, it is a factory method\n            for a project/module to get a lazy gettext function for its own\n            translation domain (i.e. nova, glance, cinder, etc.)\n\n            Message encapsulates a string so that we can translate\n            it later when needed.\n            \"\"\"\n            return Message(msg, domain=domain)\n\n        from six import moves\n        moves.builtins.__dict__['_'] = _lazy_gettext\n    else:\n        localedir = '%s_LOCALEDIR' % domain.upper()\n        if six.PY3:\n            gettext.install(domain,\n                            localedir=os.environ.get(localedir))\n        else:\n            gettext.install(domain,\n                            localedir=os.environ.get(localedir),\n                            unicode=True)", "response": "Install a _ function using the given translation domain."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting the available languages for the given translation domain.", "response": "def get_available_languages(domain):\n    \"\"\"Lists the available languages for the given translation domain.\n\n    :param domain: the domain to get languages for\n    \"\"\"\n    if domain in _AVAILABLE_LANGUAGES:\n        return copy.copy(_AVAILABLE_LANGUAGES[domain])\n\n    localedir = '%s_LOCALEDIR' % domain.upper()\n    find = lambda x: gettext.find(domain,\n                                  localedir=os.environ.get(localedir),\n                                  languages=[x])\n\n    # NOTE(mrodden): en_US should always be available (and first in case\n    # order matters) since our in-line message strings are en_US\n    language_list = ['en_US']\n    # NOTE(luisg): Babel <1.0 used a function called list(), which was\n    # renamed to locale_identifiers() in >=1.0, the requirements master list\n    # requires >=0.9.6, uncapped, so defensively work with both. We can remove\n    # this check when the master list updates to >=1.0, and update all projects\n    list_identifiers = (getattr(localedata, 'list', None) or\n                        getattr(localedata, 'locale_identifiers'))\n    locale_identifiers = list_identifiers()\n\n    for i in locale_identifiers:\n        if find(i) is not None:\n            language_list.append(i)\n\n    # NOTE(luisg): Babel>=1.0,<1.3 has a bug where some OpenStack supported\n    # locales (e.g. 'zh_CN', and 'zh_TW') aren't supported even though they\n    # are perfectly legitimate locales:\n    #     https://github.com/mitsuhiko/babel/issues/37\n    # In Babel 1.3 they fixed the bug and they support these locales, but\n    # they are still not explicitly \"listed\" by locale_identifiers().\n    # That is  why we add the locales here explicitly if necessary so that\n    # they are listed as supported.\n    aliases = {'zh': 'zh_CN',\n               'zh_Hant_HK': 'zh_HK',\n               'zh_Hant': 'zh_TW',\n               'fil': 'tl_PH'}\n    for (locale_, alias) in six.iteritems(aliases):\n        if locale_ in language_list and alias not in language_list:\n            language_list.append(alias)\n\n    _AVAILABLE_LANGUAGES[domain] = language_list\n    return copy.copy(language_list)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef translate(obj, desired_locale=None):\n    message = obj\n    if not isinstance(message, Message):\n        # If the object to translate is not already translatable,\n        # let's first get its unicode representation\n        message = six.text_type(obj)\n    if isinstance(message, Message):\n        # Even after unicoding() we still need to check if we are\n        # running with translatable unicode before translating\n        return message.translate(desired_locale)\n    return obj", "response": "Translate the object in unicode representation to the desired locale."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _translate_args(args, desired_locale=None):\n    if isinstance(args, tuple):\n        return tuple(translate(v, desired_locale) for v in args)\n    if isinstance(args, dict):\n        translated_dict = {}\n        for (k, v) in six.iteritems(args):\n            translated_v = translate(v, desired_locale)\n            translated_dict[k] = translated_v\n        return translated_dict\n    return translate(args, desired_locale)", "response": "Translates all the translatable elements of the given arguments object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef translate(self, desired_locale=None):\n\n        translated_message = Message._translate_msgid(self.msgid,\n                                                      self.domain,\n                                                      desired_locale)\n        if self.params is None:\n            # No need for more translation\n            return translated_message\n\n        # This Message object may have been formatted with one or more\n        # Message objects as substitution arguments, given either as a single\n        # argument, part of a tuple, or as one or more values in a dictionary.\n        # When translating this Message we need to translate those Messages too\n        translated_params = _translate_args(self.params, desired_locale)\n\n        translated_message = translated_message % translated_params\n\n        return translated_message", "response": "Translate this message to the desired locale."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _sanitize_mod_params(self, other):\n        if other is None:\n            params = (other,)\n        elif isinstance(other, dict):\n            params = self._trim_dictionary_parameters(other)\n        else:\n            params = self._copy_param(other)\n        return params", "response": "Sanitize the parameters used to modulate the object being modded with this Message."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dict that only has matching entries in the msgid.", "response": "def _trim_dictionary_parameters(self, dict_param):\n        \"\"\"Return a dict that only has matching entries in the msgid.\"\"\"\n        # NOTE(luisg): Here we trim down the dictionary passed as parameters\n        # to avoid carrying a lot of unnecessary weight around in the message\n        # object, for example if someone passes in Message() % locals() but\n        # only some params are used, and additionally we prevent errors for\n        # non-deepcopyable objects by unicoding() them.\n\n        # Look for %(param) keys in msgid;\n        # Skip %% and deal with the case where % is first character on the line\n        keys = re.findall('(?:[^%]|^)?%\\((\\w*)\\)[a-z]', self.msgid)\n\n        # If we don't find any %(param) keys but have a %s\n        if not keys and re.findall('(?:[^%]|^)%[a-z]', self.msgid):\n            # Apparently the full dictionary is the parameter\n            params = self._copy_param(dict_param)\n        else:\n            params = {}\n            # Save our existing parameters as defaults to protect\n            # ourselves from losing values if we are called through an\n            # (erroneous) chain that builds a valid Message with\n            # arguments, and then does something like \"msg % kwds\"\n            # where kwds is an empty dictionary.\n            src = {}\n            if isinstance(self.params, dict):\n                src.update(self.params)\n            src.update(dict_param)\n            for key in keys:\n                params[key] = self._copy_param(src[key])\n\n        return params"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a dictionary that can be used to render a registry response to json.", "response": "def registry_adapter(obj, request):\n    \"\"\"\n    Adapter for rendering a :class:`pyramid_urireferencer.models.RegistryResponse` to json.\n\n    :param pyramid_urireferencer.models.RegistryResponse obj: The response to be rendered.\n    :rtype: :class:`dict`\n    \"\"\"\n    return {\n        'query_uri': obj.query_uri,\n        'success': obj.success,\n        'has_references': obj.has_references,\n        'count': obj.count,\n        'applications': [{\n                             'title': a.title,\n                             'uri': a.uri,\n                             'service_url': a.service_url,\n                             'success': a.success,\n                             'has_references': a.has_references,\n                             'count': a.count,\n                             'items': [{\n                                           'uri': i.uri,\n                                           'title': i.title\n                                       } for i in a.items] if a.items is not None else None\n                         } for a in obj.applications] if obj.applications is not None else None\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef application_adapter(obj, request):\n    return {\n        'title': obj.title,\n        'uri': obj.uri,\n        'service_url': obj.service_url,\n        'success': obj.success,\n        'has_references': obj.has_references,\n        'count': obj.count,\n        'items': [{\n                      'uri': i.uri,\n                      'title': i.title\n                  } for i in obj.items] if obj.items is not None else None\n    }", "response": "Returns a dictionary representation of an application response."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreplaces umlauts in a word", "response": "def replace_umlauts(word, put_back=False):  # use translate()\n    '''If put_back is True, put in umlauts; else, take them out!'''\n    if put_back:\n        word = word.replace('A', '\u00e4')\n        word = word.replace('O', '\u00f6')\n\n    else:\n        word = word.replace('\u00e4', 'A').replace('\\xc3\\xa4', 'A')\n        word = word.replace('\u00f6', 'O').replace('\\xc3\\xb6', 'O')\n\n    return word"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfunctions for extracting extra seqeunce data to the query atom", "response": "def get_query_align(hit, contig):\n      \"\"\"\n         Function for extracting extra seqeunce data to the query\n         alignment if the full reference length are not covered\n      \"\"\"\n\n      # Getting data needed to extract sequences\n      query_seq = hit['query_string']\n      homo_seq = hit['homo_string']\n      sbjct_start = int(hit['sbjct_start'])\n      sbjct_end = int(hit['sbjct_end'])\n      query_start = int(hit['query_start'])\n      query_end = int(hit['query_end'])\n      length = int(hit['sbjct_length'])\n\n      # If the alignment doesn't start at the first position data is\n      # added to the begnning\n      if sbjct_start != 1:\n         missing = sbjct_start - 1\n\n         if(query_start >= missing and hit['strand'] != 1\n            or hit['strand'] == 1 and missing <= (len(contig) - query_end)):\n\n            # Getting the query sequence.\n            # If the the hit is on the other strand the characters\n            # are reversed.\n            if hit['strand'] == 1:\n               start_pos = query_end\n               end_pos = query_end + missing\n               chars = contig[start_pos:end_pos]\n               chars = Blaster.reversecomplement(chars)\n            else:\n               start_pos = query_start - missing - 1\n               end_pos = query_start - 1\n               chars = contig[start_pos:end_pos]\n\n            query_seq = chars + str(query_seq)\n         else:\n            # Getting the query sequence.\n            # If the the hit is on the other strand the characters\n            # are reversed.\n            if hit['strand'] == 1:\n               if query_end == len(contig):\n                  query_seq = \"-\" * missing + str(query_seq)\n               else:\n                  start_pos = query_end\n                  chars = contig[start_pos:]\n                  chars = Blaster.reversecomplement(chars)\n\n                  query_seq = (\"-\" * (missing - len(chars))\n                               + chars + str(query_seq))\n            elif query_start < 3:\n               query_seq = \"-\" * missing + str(query_seq)\n            else:\n               end_pos = query_start - 2\n               chars = contig[0:end_pos]\n\n               query_seq = (\"-\" * (missing - len(chars))\n                            + chars + str(query_seq))\n\n         # Adding to the homo sequence\n         spaces = \" \" * missing\n         homo_seq = str(spaces) + str(homo_seq)\n\n      # If the alignment dosen't end and the last position data is\n      # added to the end\n      if sbjct_end < length:\n         missing = length - sbjct_end\n\n         if(missing <= (len(contig) - query_end) and hit['strand'] != 1\n            or hit['strand'] == 1 and query_start >= missing):\n\n            # Getting the query sequence.\n            # If the the hit is on the other strand the characters\n            # are reversed.\n            if hit['strand'] == 1:\n               start_pos = query_start - missing - 1\n               end_pos = query_start - 1\n               chars = contig[start_pos:end_pos]\n               chars = Blaster.reversecomplement(chars)\n            else:\n               start_pos = query_end\n               end_pos = query_end + missing\n               chars = contig[start_pos:end_pos]\n\n            query_seq = query_seq + chars\n         else:\n            # If the hit is on the other strand the characters are reversed\n            if hit['strand'] == 1:\n               if query_start < 3:\n                  query_seq = query_seq + \"-\" * missing\n               else:\n                  end_pos = query_start - 2\n                  chars = contig[0:end_pos]\n                  chars = Blaster.reversecomplement(chars)\n\n                  query_seq = (query_seq\n                               + chars + \"-\" * (missing - len(chars)))\n            elif query_end == len(contig):\n               query_seq = query_seq + \"-\" * missing\n            else:\n               start_pos = query_end\n               chars = contig[start_pos:]\n\n               query_seq = query_seq + chars + \"-\" * (missing - len(chars))\n\n         # Adding to the homo sequence\n         spaces = \" \" * int(missing)\n         homo_seq = str(homo_seq) + str(spaces)\n\n      return query_seq, homo_seq"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a tuple of lookups to order by for the given column and direction.", "response": "def get_ordering_for_column(self, column, direction):\n        \"\"\"\n        Returns a tuple of lookups to order by for the given column\n        and direction. Direction is an integer, either -1, 0 or 1.\n        \"\"\"\n        if direction == 0:\n            return ()\n        if column in self.orderings:\n            ordering = self.orderings[column]\n        else:\n            field = self.get_field(column)\n            if field is None:\n                return ()\n            ordering = column\n        if not isinstance(ordering, (tuple, list)):\n            ordering = [ordering]\n        if direction == 1:\n            return ordering\n        return [lookup[1:] if lookup[0] == '-' else '-' + lookup\n                for lookup in ordering]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef model_to_json(self, object, cleanup=True):\n        model_name = type(object).__name__\n        if model_name not in self.swagger_dict['definitions']:\n            raise ValidationError(\"Swagger spec has no definition for model %s\" % model_name)\n        model_def = self.swagger_dict['definitions'][model_name]\n        log.debug(\"Marshalling %s into json\" % model_name)\n        m = marshal_model(self.spec, model_def, object)\n        if cleanup:\n            self.cleanup_model(m)\n        return m", "response": "Take a model instance and return it as a json struct"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef json_to_model(self, model_name, j):\n        if model_name not in self.swagger_dict['definitions']:\n            raise ValidationError(\"Swagger spec has no definition for model %s\" % model_name)\n        model_def = self.swagger_dict['definitions'][model_name]\n        log.debug(\"Unmarshalling json into %s\" % model_name)\n        return unmarshal_model(self.spec, model_def, j)", "response": "Take a json strust and a model name and return a model instance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate an object against its swagger model", "response": "def validate(self, model_name, object):\n        \"\"\"Validate an object against its swagger model\"\"\"\n        if model_name not in self.swagger_dict['definitions']:\n            raise ValidationError(\"Swagger spec has no definition for model %s\" % model_name)\n        model_def = self.swagger_dict['definitions'][model_name]\n        log.debug(\"Validating %s\" % model_name)\n        return validate_schema_object(self.spec, model_def, object)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef call_on_each_endpoint(self, callback):\n\n        if 'paths' not in self.swagger_dict:\n            return\n\n        for path, d in list(self.swagger_dict['paths'].items()):\n            for method, op_spec in list(d.items()):\n                data = EndpointData(path, method)\n\n                # Which server method handles this endpoint?\n                if 'x-bind-server' not in op_spec:\n                    if 'x-no-bind-server' in op_spec:\n                        # That route should not be auto-generated\n                        log.info(\"Skipping generation of %s %s\" % (method, path))\n                        continue\n                    else:\n                        raise Exception(\"Swagger api defines no x-bind-server for %s %s\" % (method, path))\n                data.handler_server = op_spec['x-bind-server']\n\n                # Make sure that endpoint only produces 'application/json'\n                if 'produces' not in op_spec:\n                    raise Exception(\"Swagger api has no 'produces' section for %s %s\" % (method, path))\n                if len(op_spec['produces']) != 1:\n                    raise Exception(\"Expecting only one type under 'produces' for %s %s\" % (method, path))\n                if op_spec['produces'][0] == 'application/json':\n                    data.produces_json = True\n                elif op_spec['produces'][0] == 'text/html':\n                    data.produces_html = True\n                else:\n                    raise Exception(\"Only 'application/json' or 'text/html' are supported. See %s %s\" % (method, path))\n\n                # Which client method handles this endpoint?\n                if 'x-bind-client' in op_spec:\n                    data.handler_client = op_spec['x-bind-client']\n\n                # Should we decorate the server handler?\n                if 'x-decorate-server' in op_spec:\n                    data.decorate_server = op_spec['x-decorate-server']\n\n                # Should we manipulate the requests parameters?\n                if 'x-decorate-request' in op_spec:\n                    data.decorate_request = op_spec['x-decorate-request']\n\n                # Generate a bravado-core operation object\n                data.operation = Operation.from_spec(self.spec, path, method, op_spec)\n\n                # Figure out how parameters are passed: one json in body? one or\n                # more values in query?\n                if 'parameters' in op_spec:\n                    params = op_spec['parameters']\n                    for p in params:\n                        if p['in'] == 'body':\n                            data.param_in_body = True\n                        if p['in'] == 'query':\n                            data.param_in_query = True\n                        if p['in'] == 'path':\n                            data.param_in_path = True\n\n                    if data.param_in_path:\n                        # Substitute {...} with <...> in path, to make a Flask friendly path\n                        data.path = data.path.replace('{', '<').replace('}', '>')\n\n                    if data.param_in_body and data.param_in_query:\n                        raise Exception(\"Cannot support params in both body and param (%s %s)\" % (method, path))\n\n                else:\n                    data.no_params = True\n\n                callback(data)", "response": "Find all server endpoints defined in the swagger spec and calls callback for each one with an instance of EndpointData as argument."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main(args=None):\n    parser = argparse.ArgumentParser(description=main.__doc__)\n    parser.add_argument(\n        '--binary',\n        dest='mode',\n        action='store_const',\n        const=\"wb\",\n        default=\"w\",\n        help='write in binary mode')\n    parser.add_argument(\n        'output', metavar='FILE', type=unicode, help='Output file')\n\n    logging.basicConfig(\n        level=logging.DEBUG,\n        stream=sys.stderr,\n        format='[%(levelname)s elapsed=%(relativeCreated)dms] %(message)s')\n\n    args = parser.parse_args(args or sys.argv[1:])\n\n    with open(args.output, args.mode) as fd:\n        for line in sys.stdin:\n            fd.write(line)", "response": "Buffer stdin and flush and avoid incomplete files."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a list of basic C - style defines that can be used to generate a header file.", "response": "def basic_c_defines(\n    layout,\n    keyboard_prefix=\"KEY_\",\n    led_prefix=\"LED_\",\n    sysctrl_prefix=\"SYS_\",\n    cons_prefix=\"CONS_\",\n    code_suffix=True,\n    all_caps=True,\n    space_char=\"_\"\n):\n    '''\n    Generates a list of C defines that can be used to generate a header file\n\n    @param layout: Layout object\n    @keyboard_prefix: Prefix used for to_hid_keyboard\n    @led_prefix: Prefix used for to_hid_led\n    @sysctrl_prefix: Prefix used for to_hid_sysctrl\n    @cons_prefix: Prefix used for to_hid_consumer\n    @code_suffix: Append _<usb code> to each name\n    @all_caps: Set to true if labels should be converted to all caps\n    @space_char: Character to replace space with\n\n    @returns: List of C tuples (<name>, <number>) that can be used to generate C-style defines. Each section has it's own list.\n    '''\n    # Keyboard Codes\n    keyboard_defines = []\n    for code, name in layout.json()['to_hid_keyboard'].items():\n        new_name = \"{}{}\".format(keyboard_prefix, name.replace(' ', space_char))\n        if all_caps:\n            new_name = new_name.upper()\n        if code_suffix:\n            new_name = \"{}_{}\".format(new_name, int(code, 0))\n        define = (new_name, code)\n        keyboard_defines.append(define)\n\n    # LED Codes\n    led_defines = []\n    for code, name in layout.json()['to_hid_led'].items():\n        new_name = \"{}{}\".format(led_prefix, name.replace(' ', space_char))\n        if all_caps:\n            new_name = new_name.upper()\n        if code_suffix:\n            new_name = \"{}_{}\".format(new_name, int(code, 0))\n        define = (new_name, code)\n        led_defines.append(define)\n\n    # System Control Codes\n    sysctrl_defines = []\n    for code, name in layout.json()['to_hid_sysctrl'].items():\n        new_name = \"{}{}\".format(sysctrl_prefix, name.replace(' ', space_char))\n        if all_caps:\n            new_name = new_name.upper()\n        if code_suffix:\n            new_name = \"{}_{}\".format(new_name, int(code, 0))\n        define = (new_name, code)\n        sysctrl_defines.append(define)\n\n    # Consumer Codes\n    cons_defines = []\n    for code, name in layout.json()['to_hid_consumer'].items():\n        new_name = \"{}{}\".format(cons_prefix, name.replace(' ', space_char))\n        if all_caps:\n            new_name = new_name.upper()\n        if code_suffix:\n            new_name = \"{}_{}\".format(new_name, int(code, 0))\n        define = (new_name, code)\n        cons_defines.append(define)\n\n    # Return list of list of tuples\n    defines = [keyboard_defines, led_defines, sysctrl_defines, cons_defines]\n    return defines"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef new_email_marketing_campaign(self, name, email_content, from_email,\n                                     from_name, reply_to_email, subject,\n                                     text_content, address,\n                                     is_view_as_webpage_enabled=False,\n                                     view_as_web_page_link_text='',\n                                     view_as_web_page_text='',\n                                     is_permission_reminder_enabled=False,\n                                     permission_reminder_text=''):\n        \"\"\"Create a Constant Contact email marketing campaign.\n        Returns an EmailMarketingCampaign object.\n        \"\"\"\n        url = self.api.join(self.EMAIL_MARKETING_CAMPAIGN_URL)\n\n        inlined_email_content = self.inline_css(email_content)\n        minified_email_content = html_minify(inlined_email_content)\n        worked_around_email_content = work_around(minified_email_content)\n\n        data = {\n            'name': name,\n            'subject': subject,\n            'from_name': from_name,\n            'from_email': from_email,\n            'reply_to_email': reply_to_email,\n            'email_content': worked_around_email_content,\n            'email_content_format': 'HTML',\n            'text_content': text_content,\n            'message_footer': {\n                'organization_name': address['organization_name'],\n                'address_line_1': address['address_line_1'],\n                'address_line_2': address['address_line_2'],\n                'address_line_3': address['address_line_3'],\n                'city': address['city'],\n                'state': address['state'],\n                'international_state': address['international_state'],\n                'postal_code': address['postal_code'],\n                'country': address['country']\n            },\n            'is_view_as_webpage_enabled': is_view_as_webpage_enabled,\n            'view_as_web_page_link_text': view_as_web_page_link_text,\n            'view_as_web_page_text': view_as_web_page_text,\n            'is_permission_reminder_enabled': is_permission_reminder_enabled,\n            'permission_reminder_text': permission_reminder_text\n        }\n\n        response = url.post(data=json.dumps(data),\n                            headers={'content-type': 'application/json'})\n\n        self.handle_response_status(response)\n\n        return EmailMarketingCampaign.objects.create(data=response.json())", "response": "Creates a new EmailMarketingCampaign object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_email_marketing_campaign(self, email_marketing_campaign,\n                                        name, email_content, from_email,\n                                        from_name, reply_to_email, subject,\n                                        text_content, address,\n                                        is_view_as_webpage_enabled=False,\n                                        view_as_web_page_link_text='',\n                                        view_as_web_page_text='',\n                                        is_permission_reminder_enabled=False,\n                                        permission_reminder_text=''):\n        \"\"\"Update a Constant Contact email marketing campaign.\n        Returns the updated EmailMarketingCampaign object.\n        \"\"\"\n        url = self.api.join(\n            '/'.join([self.EMAIL_MARKETING_CAMPAIGN_URL,\n                      str(email_marketing_campaign.constant_contact_id)]))\n\n        inlined_email_content = self.inline_css(email_content)\n        minified_email_content = html_minify(inlined_email_content)\n        worked_around_email_content = work_around(minified_email_content)\n\n        data = {\n            'name': name,\n            'subject': subject,\n            'from_name': from_name,\n            'from_email': from_email,\n            'reply_to_email': reply_to_email,\n            'email_content': worked_around_email_content,\n            'email_content_format': 'HTML',\n            'text_content': text_content,\n            'message_footer': {\n                'organization_name': address['organization_name'],\n                'address_line_1': address['address_line_1'],\n                'address_line_2': address['address_line_2'],\n                'address_line_3': address['address_line_3'],\n                'city': address['city'],\n                'state': address['state'],\n                'international_state': address['international_state'],\n                'postal_code': address['postal_code'],\n                'country': address['country']\n            },\n            'is_view_as_webpage_enabled': is_view_as_webpage_enabled,\n            'view_as_web_page_link_text': view_as_web_page_link_text,\n            'view_as_web_page_text': view_as_web_page_text,\n            'is_permission_reminder_enabled': is_permission_reminder_enabled,\n            'permission_reminder_text': permission_reminder_text\n        }\n\n        response = url.put(data=json.dumps(data),\n                           headers={'content-type': 'application/json'})\n\n        self.handle_response_status(response)\n\n        email_marketing_campaign.data = response.json()\n        email_marketing_campaign.save()\n\n        return email_marketing_campaign", "response": "Updates an existing Constant Contact email marketing campaign."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete a Constant Contact email marketing campaign.", "response": "def delete_email_marketing_campaign(self, email_marketing_campaign):\n        \"\"\"Deletes a Constant Contact email marketing campaign.\n        \"\"\"\n        url = self.api.join('/'.join([\n            self.EMAIL_MARKETING_CAMPAIGN_URL,\n            str(email_marketing_campaign.constant_contact_id)]))\n        response = url.delete()\n        self.handle_response_status(response)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef inline_css(self, html):\n        premailer = Premailer(html)\n        inlined_html = premailer.transform(pretty_print=True)\n        return inlined_html", "response": "Inlines CSS defined in external style sheets."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef preview_email_marketing_campaign(self, email_marketing_campaign):\n        url = self.api.join('/'.join([\n            self.EMAIL_MARKETING_CAMPAIGN_URL,\n            str(email_marketing_campaign.constant_contact_id),\n            'preview']))\n        response = url.get()\n        self.handle_response_status(response)\n        return (response.json()['preview_email_content'],\n                response.json()['preview_text_content'])", "response": "Returns HTML and text previews of an EmailMarketingCampaign."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npulling constant_contact_id out of data.", "response": "def pre_save(cls, sender, instance, *args, **kwargs):\n        \"\"\"Pull constant_contact_id out of data.\n        \"\"\"\n        instance.constant_contact_id = str(instance.data['id'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pre_delete(cls, sender, instance, *args, **kwargs):\n        cc = ConstantContact()\n        response = cc.delete_email_marketing_campaign(instance)\n        response.raise_for_status()", "response": "Deletes the CC email marketing campaign associated with me."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun the necessary methods in the correct order.", "response": "def runner(self):\n        \"\"\"\n        Run the necessary methods in the correct order\n        \"\"\"\n        printtime('Starting {} analysis pipeline'.format(self.analysistype), self.starttime)\n        if not self.pipeline:\n            # If the metadata has been passed from the method script, self.pipeline must still be false in order to\n            # get Sippr() to function correctly, but the metadata shouldn't be recreated\n            try:\n                _ = vars(self.runmetadata)['samples']\n            except KeyError:\n                # Create the objects to be used in the analyses\n                objects = Objectprep(self)\n                objects.objectprep()\n                self.runmetadata = objects.samples\n            # Run the analyses\n            # Sippr(self, self.cutoff)\n            ProbeSippr(self, self.cutoff)\n            #\n            # self.attributer()\n            # Create the reports\n            # self.sipprverse_reporter()\n            # Print the metadata\n            printer = MetadataPrinter(self)\n            printer.printmetadata()\n            quit()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending an email to the specified recipients.", "response": "def send_email(recipients, subject, text_content=None, html_content=None, from_email=None, use_base_template=True, category=None, fail_silently=False, language=None, cc=None, bcc=None, attachments=None, headers=None, bypass_queue=False, bypass_hijacking=False, attach_files=None):\r\n    \"\"\"\r\n    Will send a multi-format email to recipients. Email may be queued through celery\r\n    \"\"\"\r\n    from django.conf import settings\r\n    if not bypass_queue and hasattr(settings, 'MAILING_USE_CELERY') and settings.MAILING_USE_CELERY:\r\n        from celery.execute import send_task\r\n        return send_task('mailing.queue_send_email',[recipients, subject, text_content, html_content, from_email, use_base_template, category, fail_silently, language if language else translation.get_language(), cc, bcc, attachments, headers, bypass_hijacking, attach_files])\r\n    else:\r\n\r\n        header_category_value = '%s%s' % (settings.MAILING_HEADER_CATEGORY_PREFIX if hasattr(settings, 'MAILING_HEADER_CATEGORY_PREFIX') else '', category)\r\n        # Check for sendgrid support and add category header\r\n        # --------------------------------\r\n        if hasattr(settings, 'MAILING_USE_SENDGRID'):\r\n            send_grid_support = settings.MAILING_USE_SENDGRID\r\n        else:\r\n            send_grid_support = False\r\n\r\n        if not headers:\r\n            headers = dict()        \r\n        if send_grid_support and category:\r\n            headers['X-SMTPAPI'] = '{\"category\": \"%s\"}' % header_category_value\r\n\r\n        # Check for Mailgun support and add label header\r\n        # --------------------------------\r\n        if hasattr(settings, 'MAILING_USE_MAILGUN'):\r\n            mailgun_support = settings.MAILING_USE_MAILGUN\r\n        else:\r\n            mailgun_support = False\r\n\r\n        if not headers:\r\n            headers = dict()        \r\n        if mailgun_support and category:\r\n            headers['X-Mailgun-Tag'] = header_category_value\r\n\r\n\r\n        # Ensure recipients are in a list\r\n        # --------------------------------\r\n        if isinstance(recipients, basestring):\r\n            recipients_list = [recipients]\r\n        else:\r\n            recipients_list = recipients\r\n\r\n        # Check if we need to hijack the email\r\n        # --------------------------------\r\n        if hasattr(settings, 'MAILING_MAILTO_HIJACK') and not bypass_hijacking:\r\n            headers['X-MAILER-ORIGINAL-MAILTO'] = ','.join(recipients_list)\r\n            recipients_list = [settings.MAILING_MAILTO_HIJACK]\r\n\r\n        if not subject:\r\n            raise MailerMissingSubjectError('Subject not supplied')\r\n\r\n        # Send ascii, html or multi-part email\r\n        # --------------------------------\r\n        if text_content or html_content:\r\n            if use_base_template:\r\n                prev_language = translation.get_language()\r\n                language and translation.activate(language)\r\n                text_content = render_to_string('mailing/base.txt', {'mailing_text_body': text_content, 'mailing_subject': subject, 'settings': settings}) if text_content else None\r\n                html_content = render_to_string('mailing/base.html', {'mailing_html_body': html_content, 'mailing_subject': subject, 'settings': settings}) if html_content else None\r\n                translation.activate(prev_language)\r\n            msg = EmailMultiAlternatives(subject, text_content if text_content else html_content, from_email if from_email else settings.DEFAULT_FROM_EMAIL, recipients_list, cc=cc, bcc=bcc, attachments=attachments, headers = headers)\r\n            if html_content and text_content:\r\n                msg.attach_alternative(html_content, \"text/html\")\r\n            elif html_content: # Only HTML\r\n                msg.content_subtype = \"html\"\r\n\r\n            # Attach files through attach_files helper\r\n            # --------------------------------\r\n            if attach_files:\r\n                for att in attach_files:  # attachments are tuples of (filepath, mimetype, filename)\r\n                    with open(att[0], 'rb') as f:\r\n                        content = f.read()\r\n                    msg.attach(att[2], content, att[1])\r\n\r\n            # Send email\r\n            # --------------------------------\r\n\r\n            msg.send(fail_silently=fail_silently)\r\n        else:\r\n            raise MailerInvalidBodyError('No text or html body supplied.')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef initialize_connections(self, scopefunc=None):\n        for connection_name, connection_string in\\\n                self.app.config['FLASK_PHILO_SQLALCHEMY'].items():\n            engine = create_engine(connection_string)\n            session = scoped_session(sessionmaker(), scopefunc=scopefunc)\n            session.configure(bind=engine)\n            self.connections[connection_name] = Connection(engine, session)", "response": "Initialize a database connection by each connection string in the configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsorts the list according to the attribute attribut", "response": "def sort(self, attribut, order=False):\n        \"\"\"\n        Impl\u00e9ment un tri par attrbut.\n\n        :param str attribut: Nom du champ concern\u00e9\n        :param bool order: Ordre croissant ou d\u00e9croissant\n        \"\"\"\n        value_default = formats.ASSOCIATION[attribut][3]\n\n        if type(value_default) is str:  # case insensitive sort\n            get = lambda d : (d[attribut] or value_default).casefold()\n        elif type(value_default) is dict: #can't sort dicts\n            def get(d):\n                u = d[attribut] or value_default\n                return [str(u[i]) for i in sorted(u.keys())]\n        else:\n            get = lambda d : d[attribut] or value_default\n\n        list.sort(self, key=get, reverse=order)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the row of given Id if it exists otherwise None. Only works with pseudo - acces", "response": "def index_from_id(self,Id):\n        \"\"\"Return the row of given Id if it'exists, otherwise None. Only works with pseudo-acces\"\"\"\n        try:\n            return [a.Id for a in self].index(Id)\n        except IndexError:\n            return"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef append(self, acces, **kwargs):\n        if acces.Id in set(ac.Id for ac in self):\n            raise ValueError(\"Acces id already in list !\")\n        list.append(self, acces)\n        if kwargs:\n            self.infos[acces.Id] = kwargs", "response": "Append a new entry to the list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsuppressing acces with id = key", "response": "def remove_id(self,key):\n        \"\"\"Suppress acces with id = key\"\"\"\n        self.infos.pop(key, \"\")\n        new_l = [a for a in self if not (a.Id == key)]\n        list.__init__(self, new_l)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning information associated with Id or list index", "response": "def get_info(self, key=None, Id=None) -> dict:\n        \"\"\"Returns information associated with Id or list index\"\"\"\n        if key is not None:\n            Id = self[key].Id\n        return self.infos.get(Id,{})"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef recherche(self, pattern, entete):\n\n        new_liste = []\n        sub_patterns = pattern.split(\" \")\n        for p in self:\n            d_font = {att: False for att in entete}\n            row_valid = True\n            for sub_pattern in sub_patterns:\n                found = False\n                for att in entete:\n                    fonction_recherche = formats.ASSOCIATION[att][1]\n                    attr_found = bool(fonction_recherche(p[att], sub_pattern))\n                    if attr_found:\n                        found = True\n                        d_font[att] = True\n                if not found:\n                    row_valid = False\n                    break\n            if row_valid:\n                new_liste.append(p)\n                info = dict(self.get_info(Id=p.Id),font=d_font)\n                self.infos[p.Id] = info\n\n        list.__init__(self, new_liste)", "response": "Performs a search field by field using functions defined in formats. ASSOCIATION."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extend(self, collection):\n        l_ids = set([a.Id for a in self])\n        for acces in collection:\n            if not acces.Id in l_ids:\n                list.append(self,acces)\n                info = collection.get_info(Id=acces.Id)\n                if info:\n                    self.infos[acces.Id] = info", "response": "Merges the list with the items in the collection. Ensure uniqueness of ids."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef isotime(at=None, subsecond=False):\n    if not at:\n        at = utcnow()\n    st = at.strftime(_ISO8601_TIME_FORMAT\n                     if not subsecond\n                     else _ISO8601_TIME_FORMAT_SUBSECOND)\n    tz = at.tzinfo.tzname(None) if at.tzinfo else 'UTC'\n    st += ('Z' if tz == 'UTC' else tz)\n    return st", "response": "Stringify time in ISO 8601 format."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses time from ISO 8601 format.", "response": "def parse_isotime(timestr):\n    \"\"\"Parse time from ISO 8601 format.\"\"\"\n    try:\n        return iso8601.parse_date(timestr)\n    except iso8601.ParseError as e:\n        raise ValueError(six.text_type(e))\n    except TypeError as e:\n        raise ValueError(six.text_type(e))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef normalize_time(timestamp):\n    offset = timestamp.utcoffset()\n    if offset is None:\n        return timestamp\n    return timestamp.replace(tzinfo=None) - offset", "response": "Normalize time in arbitrary timezone to UTC naive object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_older_than(before, seconds):\n    if isinstance(before, six.string_types):\n        before = parse_strtime(before).replace(tzinfo=None)\n    else:\n        before = before.replace(tzinfo=None)\n\n    return utcnow() - before > datetime.timedelta(seconds=seconds)", "response": "Return True if before is older than seconds."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_newer_than(after, seconds):\n    if isinstance(after, six.string_types):\n        after = parse_strtime(after).replace(tzinfo=None)\n    else:\n        after = after.replace(tzinfo=None)\n\n    return after - utcnow() > datetime.timedelta(seconds=seconds)", "response": "Return True if after is newer than seconds."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef utcnow_ts():\n    if utcnow.override_time is None:\n        # NOTE(kgriffs): This is several times faster\n        # than going through calendar.timegm(...)\n        return int(time.time())\n\n    return calendar.timegm(utcnow().timetuple())", "response": "Timestamp version of our utcnow function."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef utcnow():\n    if utcnow.override_time:\n        try:\n            return utcnow.override_time.pop(0)\n        except AttributeError:\n            return utcnow.override_time\n    return datetime.datetime.utcnow()", "response": "Overridable version of utils. utcnow."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef advance_time_delta(timedelta):\n    assert(utcnow.override_time is not None)\n    try:\n        for dt in utcnow.override_time:\n            dt += timedelta\n    except TypeError:\n        utcnow.override_time += timedelta", "response": "Advance overridden time using a datetime. timedelta."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef marshall_now(now=None):\n    if not now:\n        now = utcnow()\n    return dict(day=now.day, month=now.month, year=now.year, hour=now.hour,\n                minute=now.minute, second=now.second,\n                microsecond=now.microsecond)", "response": "Make an rpc - safe datetime with microseconds."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unmarshall_time(tyme):\n    return datetime.datetime(day=tyme['day'],\n                             month=tyme['month'],\n                             year=tyme['year'],\n                             hour=tyme['hour'],\n                             minute=tyme['minute'],\n                             second=tyme['second'],\n                             microsecond=tyme['microsecond'])", "response": "Unmarshall a datetime dict."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef total_seconds(delta):\n    try:\n        return delta.total_seconds()\n    except AttributeError:\n        return ((delta.days * 24 * 3600) + delta.seconds +\n                float(delta.microseconds) / (10 ** 6))", "response": "Return the total seconds of a datetime. timedelta object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_soon(dt, window):\n    soon = (utcnow() + datetime.timedelta(seconds=window))\n    return normalize_time(dt) <= soon", "response": "Determines if the given time is going to happen in the next window seconds."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef download_file_powershell(url, target):\n    '''\n    Download the file at url to target using Powershell (which will validate\n    trust). Raise an exception if the command cannot complete.\n    '''\n    target = os.path.abspath(target)\n    cmd = [\n        'powershell',\n        '-Command',\n        '(new-object System.Net.WebClient).DownloadFile(%(url)r, %(target)r)' % vars(),\n    ]\n    subprocess.check_call(cmd)", "response": "Download the file at url to target using Powershell."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef download_file_insecure(url, target):\n    '''\n    Use Python to download the file, even though it cannot authenticate the\n    connection.\n    '''\n    try:\n        from urllib.request import urlopen\n    except ImportError:\n        from urllib2 import urlopen\n    src = dst = None\n    try:\n        src = urlopen(url)\n        # Read/write all in one block, so we don't create a corrupt file\n        # if the download is interrupted.\n        data = src.read()\n        dst = open(target, 'wb')\n        dst.write(data)\n    finally:\n        if src:\n            src.close()\n        if dst:\n            dst.close()", "response": "Download a file from a URL and save it to a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _build_install_args(options):\n    '''\n    Build the arguments to 'python setup.py install' on the setuptools package\n    '''\n    install_args = []\n    if options.user_install:\n        if sys.version_info < (2, 6):\n            log.warn('--user requires Python 2.6 or later')\n            raise SystemExit(1)\n        install_args.append('--user')\n    return install_args", "response": "Build the arguments to python setup. py install on the setuptools package"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write(name, value):\n    def wrapped(func):\n        @functools.wraps(func)\n        def _decorator(*args, **kwargs):\n            existing_env = core.read(name, allow_none=True)\n            core.write(name, value)\n            func_val = func(*args, **kwargs)\n            core.write(name, existing_env)\n            return func_val\n        return _decorator\n    return wrapped", "response": "Decorator that changes or sets the environment variable for the specified resource."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef isset(name):\n    def wrapped(func):\n        @functools.wraps(func)\n        def _decorator(*args, **kwargs):\n            if core.isset(name):\n                return func(*args, **kwargs)\n        return _decorator\n    return wrapped", "response": "Only execute the function if the variable is set."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bool(name, execute_bool=True, default=None):\n    def wrapped(func):\n        @functools.wraps(func)\n        def _decorator(*args, **kwargs):\n            if core.isset(name) and core.bool(name) == execute_bool:\n                return func(*args, **kwargs)\n            elif default is not None and default == execute_bool:\n                return func(*args, **kwargs)\n        return _decorator\n    return wrapped", "response": "Decorator to execute the function only if the boolean variable is set."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_cell(self, x, y):\n        if isinstance(self.header[y], tuple):\n            header = self.header[y][0]\n        else:\n            header = self.header[y]\n        x += 1\n        y += 1\n        if self.strip:\n            self._sheet.cell(x, y).value = self._sheet.cell(x, y).value.strip()\n        else:\n            return {header: self._sheet.cell(x, y).value}", "response": "Reads the cell at position x and y and returns value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite the value in the cell of x y to value", "response": "def write_cell(self, x, y, value):\n        \"\"\"\n        Writing value in the cell of x+1 and y+1 position\n        :param x: line index\n        :param y: coll index\n        :param value: value to be written\n        :return:\n        \"\"\"\n        x += 1\n        y += 1\n        self._sheet.update_cell(x, y, value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nopening the file and get sheets", "response": "def _open(self):\n        \"\"\"\n        Open the file; get sheets\n        :return:\n        \"\"\"\n        if not hasattr(self, '_file'):\n            self._file = self.gc.open(self.name)\n            self.sheet_names = self._file.worksheets()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads the sheet and set the header and number columns and rows.", "response": "def _open_sheet(self):\n        \"\"\"\n        Read the sheet, get value the header, get number columns and rows\n        :return:\n        \"\"\"\n        if self.sheet_name and not self.header:\n            self._sheet = self._file.worksheet(self.sheet_name.title)\n            self.ncols = self._sheet.col_count\n            self.nrows = self._sheet.row_count\n            for i in range(1, self.ncols+1):\n                self.header = self.header + [self._sheet.cell(1, i).value]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes imports Makes imports", "response": "def _import(self):\n        \"\"\"\n        Makes imports\n        :return:\n        \"\"\"\n        import os.path\n        import gspread\n        self.path = os.path\n        self.gspread = gspread\n        self._login()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _login(self):\n        # TODO(dmvieira) login changed to oauth2\n        self.gc = self.gspread.login(self.email, self.password)", "response": "Login with your Google account\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef flags(self, index: QModelIndex):\n        if self.IS_EDITABLE and self.header[index.column()] in self.EDITABLE_FIELDS:\n            return Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsEditable\n        else:\n            return super().flags(index) | Qt.ItemIsSelectable", "response": "Flags for the item at the given index."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sort(self, section: int, order=None):\n        attr = self.header[section]\n        old_i, old_sort = self.sort_state\n        self.beginResetModel()\n        if section == old_i:\n            self.collection.sort(attr, not old_sort)\n            self.sort_state = (section, not old_sort)\n        else:\n            self.collection.sort(attr, True)\n            self.sort_state = (section, True)\n        self.endResetModel()", "response": "Sort the entries in the specified section."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbasing implementation just pops the item from the collection and removes the section from the collection.", "response": "def remove_line(self, section):\n        \"\"\"Base implementation just pops the item from collection.\n        Re-implements to add global behaviour\n        \"\"\"\n        self.beginResetModel()\n        self.collection.pop(section)\n        self.endResetModel()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the data of the current instance of the class.", "response": "def _update(self):\n        \"\"\"Emit dataChanged signal on all cells\"\"\"\n        self.dataChanged.emit(self.createIndex(0, 0), self.createIndex(\n            len(self.collection), len(self.header)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_item(self, index):\n        row = index.row() if hasattr(index, \"row\") else index\n        try:\n            return self.collection[row]\n        except IndexError:  # invalid index for exemple\n            return None", "response": "Returns the item with the given index."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_collection(self, collection):\n        self.beginResetModel()\n        self.collection = collection\n        self.sort_state = (-1, False)\n        self.endResetModel()", "response": "Reset sort state set collection and emit resetModel signal"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_item(self, index, new_item):\n        row = index.row() if hasattr(index, \"row\") else index\n        self.collection[row] = new_item\n        self.dataChanged.emit(self.index(\n            row, 0), self.index(row, self.rowCount() - 1))", "response": "Changes the item at index in collection. Emit dataChanged signal."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_data(self, index, value):\n        acces, field = self.get_item(index), self.header[index.column()]\n        self.beginResetModel()\n        self.set_data_hook(acces, field, value)\n        self.endResetModel()", "response": "Uses given data setter and emit modelReset signal"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate selected_ids and emit dataChanged", "response": "def _set_id(self, Id, is_added, index):\n        \"\"\"Update selected_ids and emit dataChanged\"\"\"\n        if is_added:\n            self.selected_ids.add(Id)\n        else:\n            self.selected_ids.remove(Id)\n        self.dataChanged.emit(index, index)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate selected_ids on click on index cell.", "response": "def setData(self, index: QModelIndex, value, role=None):\n        \"\"\"Update selected_ids on click on index cell.\"\"\"\n        if not (index.isValid() and role == Qt.CheckStateRole):\n            return False\n        c_id = self.get_item(index).Id\n        self._set_id(c_id, value == Qt.Checked, index)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate selected_ids with given Id", "response": "def set_by_Id(self, Id, is_added):\n        \"\"\"Update selected_ids with given Id\"\"\"\n        row = self.collection.index_from_id(Id)\n        if row is None:\n            return\n        self._set_id(Id, is_added, self.index(row, 0))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _setup_delegate(self):\n        delegate = self.DELEGATE_CLASS(self)\n        self.setItemDelegate(delegate)\n        delegate.sizeHintChanged.connect(\n            lambda index: self.resizeRowToContents(index.row()))\n        if self.RESIZE_COLUMN:\n            delegate.sizeHintChanged.connect(\n                lambda index: self.resizeColumnToContents(index.column()))\n        delegate.closeEditor.connect(\n            lambda ed: self.resizeRowToContents(delegate.row_done_))", "response": "Add resize behavior on edit"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _draw_placeholder(self):\n        if self.model().rowCount() == 0:\n            painter = QPainter(self.viewport())\n            painter.setFont(_custom_font(is_italic=True))\n            painter.drawText(self.rect().adjusted(0, 0, -5, -5), Qt.AlignCenter | Qt.TextWordWrap,\n                             self.PLACEHOLDER)", "response": "Draw the placeholder text for the current item."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_current_item(self):\n        l = self.selectedIndexes()\n        if len(l) > 0:\n            return self.model().get_item(l[0])", "response": "Returns the currently selected item or None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef model_from_list(l, header):\n        col = groups.sortableListe(PseudoAccesCategorie(n) for n in l)\n        return MultiSelectModel(col, header)", "response": "Return a model with a collection from a list of entries"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the status code from the response.", "response": "def _parse_status_code(response):\n    \"\"\"\n    Return error string code if the response is an error, otherwise ``\"OK\"``\n    \"\"\"\n\n    # This happens when a status response is expected\n    if isinstance(response, string_types):\n        return response\n\n    # This happens when a list of structs are expected\n    is_single_list = isinstance(response, list) and len(response) == 1\n    if is_single_list and isinstance(response[0], string_types):\n        return response[0]\n\n    # This happens when a struct of any kind is returned\n    return \"OK\""}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves the zone record with the given ID that belongs to the given domain and sub - domain.", "response": "def remove_zone_record(self, id, domain, subdomain=None):\n        \"\"\"\n        Remove the zone record with the given ID that belongs to the given\n        domain and sub domain. If no sub domain is given the wildcard sub-domain\n        is assumed.\n        \"\"\"\n\n        if subdomain is None:\n            subdomain = \"@\"\n\n        _validate_int(\"id\", id)\n\n        self._call(\"removeZoneRecord\", domain, subdomain, id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_module_class(self):\n        cname = self.class_name\n        match = re.match(self.CLASS_REGEX, cname)\n        if not match:\n            raise ValueError(f'not a fully qualified class name: {cname}')\n        return match.groups()", "response": "Parse the module and class name part of the fully qualifed class name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the module and class in the initializer.", "response": "def get_module_class(self):\n        \"\"\"Return the module and class as a tuple of the given class in the\n        initializer.\n\n        :param reload: if ``True`` then reload the module before returning the\n        class\n\n        \"\"\"\n        pkg, cname = self.parse_module_class()\n        logger.debug(f'pkg: {pkg}, class: {cname}')\n        pkg = pkg.split('.')\n        mod = reduce(lambda m, n: getattr(m, n), pkg[1:], __import__(pkg[0]))\n        logger.debug(f'mod: {mod}')\n        if self.reload:\n            importlib.reload(mod)\n        cls = getattr(mod, cname)\n        logger.debug(f'class: {cls}')\n        return mod, cls"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef instance(self, *args, **kwargs):\n        mod, cls = self.get_module_class()\n        inst = cls(*args, **kwargs)\n        logger.debug(f'inst: {inst}')\n        return inst", "response": "Create an instance of the specified class in the initializer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_log_level(self, level=logging.INFO):\n        mod, cls = self.parse_module_class()\n        logging.getLogger(mod).setLevel(level)", "response": "Convenciene method to set the log level of the module given in the\n        initializer of this class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register(cls, instance_class, name=None):\n        if name is None:\n            name = instance_class.__name__\n        cls.INSTANCE_CLASSES[name] = instance_class", "response": "Register a class with the factory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nresolve the class from the name.", "response": "def _find_class(self, class_name):\n        \"Resolve the class from the name.\"\n        classes = {}\n        classes.update(globals())\n        classes.update(self.INSTANCE_CLASSES)\n        logger.debug(f'looking up class: {class_name}')\n        cls = classes[class_name]\n        logger.debug(f'found class: {cls}')\n        return cls"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the class name and parameters to use for __init__.", "response": "def _class_name_params(self, name):\n        \"Get the class name and parameters to use for ``__init__``.\"\n        sec = self.pattern.format(**{'name': name})\n        logger.debug(f'section: {sec}')\n        params = {}\n        params.update(self.config.populate({}, section=sec))\n        class_name = params['class_name']\n        del params['class_name']\n        return class_name, params"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn whether the class has a config parameter in the __init__ method.", "response": "def _has_init_config(self, cls):\n        \"\"\"Return whether the class has a ``config`` parameter in the ``__init__``\n        method.\n\n        \"\"\"\n        args = inspect.signature(cls.__init__)\n        return self.config_param_name in args.parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _has_init_name(self, cls):\n        args = inspect.signature(cls.__init__)\n        return self.name_param_name in args.parameters", "response": "Return whether the class has a name parameter in the __init__ method."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the instance from the cache.", "response": "def _instance(self, cls, *args, **kwargs):\n        \"\"\"Return the instance.\n\n        :param cls: the class to create the instance from\n        :param args: given to the ``__init__`` method\n        :param kwargs: given to the ``__init__`` method\n        \"\"\"\n        logger.debug(f'args: {args}, kwargs: {kwargs}')\n        return cls(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new instance of the class with the given name.", "response": "def instance(self, name=None, *args, **kwargs):\n        \"\"\"Create a new instance using key ``name``.\n\n        :param name: the name of the class (by default) or the key name of the\n            class used to find the class\n        :param args: given to the ``__init__`` method\n        :param kwargs: given to the ``__init__`` method\n\n        \"\"\"\n        logger.info(f'new instance of {name}')\n        t0 = time()\n        name = self.default_name if name is None else name\n        logger.debug(f'creating instance of {name}')\n        class_name, params = self._class_name_params(name)\n        cls = self._find_class(class_name)\n        params.update(kwargs)\n        if self._has_init_config(cls):\n            logger.debug(f'found config parameter')\n            params['config'] = self.config\n        if self._has_init_name(cls):\n            logger.debug(f'found name parameter')\n            params['name'] = name\n        if logger.level >= logging.DEBUG:\n            for k, v in params.items():\n                logger.debug(f'populating {k} -> {v} ({type(v)})')\n        inst = self._instance(cls, *args, **params)\n        logger.info(f'created {name} instance of {cls.__name__} ' +\n                    f'in {(time() - t0):.2f}s')\n        return inst"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the instance of the object from the stash.", "response": "def load(self, name=None, *args, **kwargs):\n        \"Load the instance of the object from the stash.\"\n        inst = self.stash.load(name)\n        if inst is None:\n            inst = self.instance(name, *args, **kwargs)\n        logger.debug(f'loaded (conf mng) instance: {inst}')\n        return inst"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving the object instance to the stash.", "response": "def dump(self, name: str, inst):\n        \"Save the object instance to the stash.\"\n        self.stash.dump(name, inst)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a Saltant API client configured from environment variables.", "response": "def from_env(cls, default_timeout=DEFAULT_TIMEOUT_SECONDS):\n        \"\"\"Return a client configured from environment variables.\n\n        Essentially copying this:\n        https://github.com/docker/docker-py/blob/master/docker/client.py#L43.\n\n        The environment variables looked for are the following:\n\n        .. envvar:: SALTANT_API_URL\n\n            The URL of the saltant API. For example,\n            https://shahlabjobs.ca/api/.\n\n        .. envvar:: SALTANT_AUTH_TOKEN\n\n            The registered saltant user's authentication token.\n\n        Example:\n\n            >>> from saltant.client import from_env\n            >>> client = from_env()\n\n        Args:\n            default_timeout (int, optional): The maximum number of\n                seconds to wait for a request to complete. Defaults to\n                90 seconds.\n\n        Returns:\n            :class:`Client`: A saltant API client object.\n\n        Raises:\n            :class:`saltant.exceptions.BadEnvironmentError`: The user\n                has an incorrectly configured environment.\n        \"\"\"\n        # Get variables from environment\n        try:\n            base_api_url = os.environ[\"SALTANT_API_URL\"]\n        except KeyError:\n            raise BadEnvironmentError(\"SALTANT_API_URL not defined!\")\n\n        try:\n            # Try to get an auth token\n            auth_token = os.environ[\"SALTANT_AUTH_TOKEN\"]\n        except KeyError:\n            raise BadEnvironmentError(\"SALTANT_AUTH_TOKEN not defined!\")\n\n        # Return the configured client\n        return cls(\n            base_api_url=base_api_url,\n            auth_token=auth_token,\n            default_timeout=default_timeout,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclearing all global data.", "response": "def clear_global(self):\n        \"\"\"Clear only any cached global data.\n\n        \"\"\"\n        vname = self.varname\n        logger.debug(f'global clearning {vname}')\n        if vname in globals():\n            logger.debug('removing global instance var: {}'.format(vname))\n            del globals()[vname]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclearing the data of the is and force it to be created on the next fetch.", "response": "def clear(self):\n        \"\"\"Clear the data, and thus, force it to be created on the next fetch.  This is\n        done by removing the attribute from ``owner``, deleting it from globals\n        and removing the file from the disk.\n\n        \"\"\"\n        vname = self.varname\n        if self.path.exists():\n            logger.debug('deleting cached work: {}'.format(self.path))\n            self.path.unlink()\n        if self.owner is not None and hasattr(self.owner, vname):\n            logger.debug('removing instance var: {}'.format(vname))\n            delattr(self.owner, vname)\n        self.clear_global()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the data from the file system and create it if it does not exist.", "response": "def _load_or_create(self, *argv, **kwargs):\n        \"\"\"Invoke the file system operations to get the data, or create work.\n\n        If the file does not exist, calling ``__do_work__`` and save it.\n        \"\"\"\n        if self.path.exists():\n            self._info('loading work from {}'.format(self.path))\n            with open(self.path, 'rb') as f:\n                obj = pickle.load(f)\n        else:\n            self._info('saving work to {}'.format(self.path))\n            with open(self.path, 'wb') as f:\n                obj = self._do_work(*argv, **kwargs)\n                pickle.dump(obj, f)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef has_data(self):\n        if not hasattr(self, '_has_data'):\n            try:\n                next(iter(self.delegate.keys()))\n                self._has_data = True\n            except StopIteration:\n                self._has_data = False\n        return self._has_data", "response": "Return whether or not the stash has any data available or not."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a path to the pickled data with key name.", "response": "def _get_instance_path(self, name):\n        \"Return a path to the pickled data with key ``name``.\"\n        fname = self.pattern.format(**{'name': name})\n        logger.debug(f'path {self.create_path}: {self.create_path.exists()}')\n        self._create_path_dir()\n        return Path(self.create_path, fname)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef shelve(self):\n        logger.info('creating shelve data')\n        fname = str(self.create_path.absolute())\n        inst = sh.open(fname, writeback=self.writeback)\n        self.is_open = True\n        return inst", "response": "Return an opened shelve object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete(self, name=None):\n        \"Delete the shelve data file.\"\n        logger.info('clearing shelve data')\n        self.close()\n        for path in Path(self.create_path.parent, self.create_path.name), \\\n            Path(self.create_path.parent, self.create_path.name + '.db'):\n            logger.debug(f'clearing {path} if exists: {path.exists()}')\n            if path.exists():\n                path.unlink()\n                break", "response": "Delete the shelve data file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef close(self):\n        \"Close the shelve object, which is needed for data consistency.\"\n        if self.is_open:\n            logger.info('closing shelve data')\n            try:\n                self.shelve.close()\n                self._shelve.clear()\n            except Exception:\n                self.is_open = False", "response": "Close the shelve object which is needed for data consistency."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _map(self, data_item):\n        \"Map ``data_item`` separately in each thread.\"\n        delegate = self.delegate\n        logger.debug(f'mapping: {data_item}')\n        if self.clobber or not self.exists(data_item.id):\n            logger.debug(f'exist: {data_item.id}: {self.exists(data_item.id)}')\n            delegate.dump(data_item.id, data_item)", "response": "Map data_item separately in each thread."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_all(self, workers=None, limit=None, n_expected=None):\n        if not self.has_data:\n            self._preempt(True)\n            # we did the best we could (avoid repeat later in this method)\n            n_expected = 0\n        keys = tuple(self.delegate.keys())\n        if n_expected is not None and len(keys) < n_expected:\n            self._preempt(True)\n            keys = self.delegate.keys()\n        keys = it.islice(limit, keys) if limit is not None else keys\n        pool = self._create_thread_pool(workers)\n        logger.debug(f'workers={workers}, keys: {keys}')\n        try:\n            return iter(pool.map(self.delegate.load, keys))\n        finally:\n            pool.close()", "response": "Load all instances witih multiple threads."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _make_persistent(self, model_name, pkg_name):\n\n        #\n        # WARNING: ugly piece of monkey-patching below. Hopefully will replace\n        # with native bravado-core code in the future...\n        #\n\n        # Load class at path pkg_name\n        c = get_function(pkg_name)\n        for name in ('load_from_db', 'save_to_db'):\n            if not hasattr(c, name):\n                raise PyMacaronCoreException(\"Class %s has no static method '%s'\" % (pkg_name, name))\n\n        log.info(\"Making %s persistent via %s\" % (model_name, pkg_name))\n\n        # Replace model generator with one that adds 'save_to_db' to every instance\n        model = getattr(self.model, model_name)\n        n = self._wrap_bravado_model_generator(model, c.save_to_db, pkg_name)\n        setattr(self.model, model_name, n)\n\n        # Add class method load_from_db to model generator\n        model = getattr(self.model, model_name)\n        setattr(model, 'load_from_db', c.load_from_db)", "response": "Monkey - patch object persistence to avoid unnecessary modification of the model class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nspawning a new API endpoint for this application.", "response": "def spawn_api(self, app, decorator=None):\n        \"\"\"Auto-generate server endpoints implementing the API into this Flask app\"\"\"\n        if decorator:\n            assert type(decorator).__name__ == 'function'\n        self.is_server = True\n        self.app = app\n\n        if self.local:\n            # Re-generate client callers, this time as local and passing them the app\n            self._generate_client_callers(app)\n\n        return spawn_server_api(self.name, app, self.api_spec, self.error_callback, decorator)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake a json strust and a model name and return a model instance", "response": "def json_to_model(self, model_name, j, validate=False):\n        \"\"\"Take a json strust and a model name, and return a model instance\"\"\"\n        if validate:\n            self.api_spec.validate(model_name, j)\n        return self.api_spec.json_to_model(model_name, j)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nassembles items in iterable into discreet collections.", "response": "def assemble(\n    iterable, patterns=None, minimum_items=2, case_sensitive=True,\n    assume_padded_when_ambiguous=False\n):\n    '''Assemble items in *iterable* into discreet collections.\n\n    *patterns* may be specified as a list of regular expressions to limit\n    the returned collection possibilities. Use this when interested in\n    collections that only match specific patterns. Each pattern must contain\n    the expression from :py:data:`DIGITS_PATTERN` exactly once.\n\n    A selection of common expressions are available in :py:data:`PATTERNS`.\n\n    .. note::\n\n        If a pattern is supplied as a string it will be automatically compiled\n        to a :py:class:`re.RegexObject` instance for convenience.\n\n    When *patterns* is not specified, collections are formed by examining all\n    possible groupings of the items in *iterable* based around common numerical\n    components.\n\n    *minimum_items* dictates the minimum number of items a collection must have\n    in order to be included in the result. The default is 2, filtering out\n    single item collections.\n\n    If *case_sensitive* is False, then items will be treated as part of the same\n    collection when they only differ in casing. To avoid ambiguity, the\n    resulting collection will always be lowercase. For example, \"item.0001.dpx\"\n    and \"Item.0002.dpx\" would be part of the same collection, \"item.%04d.dpx\".\n\n    .. note::\n\n        Any compiled *patterns* will also respect the set case sensitivity.\n\n    For certain collections it may be ambiguous whether they are padded or not.\n    For example, 1000-1010 can be considered either an unpadded collection or a\n    four padded collection. By default, Clique is conservative and assumes that\n    the collection is unpadded. To change this behaviour, set\n    *assume_padded_when_ambiguous* to True and any ambiguous collection will have\n    a relevant padding set.\n\n    .. note::\n\n        *assume_padded_when_ambiguous* has no effect on collections that are\n        unambiguous. For example, 1-100 will always be considered unpadded\n        regardless of the *assume_padded_when_ambiguous* setting.\n\n    Return tuple of two lists (collections, remainder) where 'collections' is a\n    list of assembled :py:class:`~clique.collection.Collection` instances and\n    'remainder' is a list of items that did not belong to any collection.\n\n    '''\n    collection_map = defaultdict(set)\n    collections = []\n    remainder = []\n\n    # Compile patterns.\n    flags = 0\n    if not case_sensitive:\n        flags |= re.IGNORECASE\n\n    compiled_patterns = []\n\n    if patterns is not None:\n        if not patterns:\n            return collections, list(iterable)\n\n        for pattern in patterns:\n            if isinstance(pattern, basestring):\n                compiled_patterns.append(re.compile(pattern, flags=flags))\n            else:\n                compiled_patterns.append(pattern)\n\n    else:\n        compiled_patterns.append(re.compile(DIGITS_PATTERN, flags=flags))\n\n    # Process iterable.\n    for item in iterable:\n        matched = False\n\n        for pattern in compiled_patterns:\n            for match in pattern.finditer(item):\n                index = match.group('index')\n\n                head = item[:match.start('index')]\n                tail = item[match.end('index'):]\n\n                if not case_sensitive:\n                    head = head.lower()\n                    tail = tail.lower()\n\n                padding = match.group('padding')\n                if padding:\n                    padding = len(index)\n                else:\n                    padding = 0\n\n                key = (head, tail, padding)\n                collection_map[key].add(int(index))\n                matched = True\n\n        if not matched:\n            remainder.append(item)\n\n    # Form collections.\n    merge_candidates = []\n    for (head, tail, padding), indexes in collection_map.items():\n        collection = Collection(head, tail, padding, indexes)\n        collections.append(collection)\n\n        if collection.padding == 0:\n            merge_candidates.append(collection)\n\n    # Merge together collections that align on padding boundaries. For example,\n    # 0998-0999 and 1000-1001 can be merged into 0998-1001. Note that only\n    # indexes within the padding width limit are merged. If a collection is\n    # entirely merged into another then it will not be included as a separate\n    # collection in the results.\n    fully_merged = []\n    for collection in collections:\n        if collection.padding == 0:\n            continue\n\n        for candidate in merge_candidates:\n            if (\n                candidate.head == collection.head and\n                candidate.tail == collection.tail\n            ):\n                merged_index_count = 0\n                for index in candidate.indexes:\n                    if len(str(abs(index))) == collection.padding:\n                        collection.indexes.add(index)\n                        merged_index_count += 1\n\n                if merged_index_count == len(candidate.indexes):\n                    fully_merged.append(candidate)\n\n    # Filter out fully merged collections.\n    collections = [collection for collection in collections\n                   if collection not in fully_merged]\n\n    # Filter out collections that do not have at least as many indexes as\n    # minimum_items. In addition, add any members of a filtered collection,\n    # which are not members of an unfiltered collection, to the remainder.\n    filtered = []\n    remainder_candidates = []\n    for collection in collections:\n        if len(collection.indexes) >= minimum_items:\n            filtered.append(collection)\n        else:\n            for member in collection:\n                remainder_candidates.append(member)\n\n    for candidate in remainder_candidates:\n        # Check if candidate has already been added to remainder to avoid\n        # duplicate entries.\n        if candidate in remainder:\n            continue\n\n        has_membership = False\n\n        for collection in filtered:\n            if candidate in collection:\n                has_membership = True\n                break\n\n        if not has_membership:\n            remainder.append(candidate)\n\n    # Set padding for all ambiguous collections according to the\n    # assume_padded_when_ambiguous setting.\n    if assume_padded_when_ambiguous:\n        for collection in filtered:\n            if (\n                not collection.padding and collection.indexes\n            ):\n                indexes = list(collection.indexes)\n                first_index_width = len(str(indexes[0]))\n                last_index_width = len(str(indexes[-1]))\n                if first_index_width == last_index_width:\n                    collection.padding = first_index_width\n\n    return filtered, remainder"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(value, pattern='{head}{padding}{tail} [{ranges}]'):\n    '''Parse *value* into a :py:class:`~clique.collection.Collection`.\n\n    Use *pattern* to extract information from *value*. It may make use of the\n    following keys:\n\n        * *head* - Common leading part of the collection.\n        * *tail* - Common trailing part of the collection.\n        * *padding* - Padding value in ``%0d`` format.\n        * *range* - Total range in the form ``start-end``.\n        * *ranges* - Comma separated ranges of indexes.\n        * *holes* - Comma separated ranges of missing indexes.\n\n    .. note::\n\n        *holes* only makes sense if *range* or *ranges* is also present.\n\n    '''\n    # Construct regular expression for given pattern.\n    expressions = {\n        'head': '(?P<head>.*)',\n        'tail': '(?P<tail>.*)',\n        'padding': '%(?P<padding>\\d*)d',\n        'range': '(?P<range>\\d+-\\d+)?',\n        'ranges': '(?P<ranges>[\\d ,\\-]+)?',\n        'holes': '(?P<holes>[\\d ,\\-]+)'\n    }\n\n    pattern_regex = re.escape(pattern)\n    for key, expression in expressions.items():\n        pattern_regex = pattern_regex.replace(\n            '\\{{{0}\\}}'.format(key),\n            expression\n        )\n    pattern_regex = '^{0}$'.format(pattern_regex)\n\n    # Match pattern against value and use results to construct collection.\n    match = re.search(pattern_regex, value)\n    if match is None:\n        raise ValueError('Value did not match pattern.')\n\n    groups = match.groupdict()\n    if 'padding' in groups and groups['padding']:\n        groups['padding'] = int(groups['padding'])\n    else:\n        groups['padding'] = 0\n\n    # Create collection and then add indexes.\n    collection = Collection(\n        groups.get('head', ''),\n        groups.get('tail', ''),\n        groups['padding']\n    )\n\n    if groups.get('range', None) is not None:\n        start, end = map(int, groups['range'].split('-'))\n        collection.indexes.update(range(start, end + 1))\n\n    if groups.get('ranges', None) is not None:\n        parts = [part.strip() for part in groups['ranges'].split(',')]\n        for part in parts:\n            index_range = list(map(int, part.split('-', 2)))\n\n            if len(index_range) > 1:\n                # Index range.\n                for index in range(index_range[0], index_range[1] + 1):\n                    collection.indexes.add(index)\n            else:\n                # Single index.\n                collection.indexes.add(index_range[0])\n\n    if 'holes' in groups:\n        parts = [part.strip() for part in groups['holes'].split(',')]\n        for part in parts:\n            index_range = map(int, part.split('-', 2))\n\n            if len(index_range) > 1:\n                # Index range.\n                for index in range(index_range[0], index_range[1] + 1):\n                    collection.indexes.remove(index)\n            else:\n                # Single index.\n                collection.indexes.remove(index_range[0])\n\n    return collection", "response": "Parse a string into a : py : class ~clique. collection. Collection."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add(self, item):\n        '''Add *item*.'''\n        if not item in self:\n            index = bisect.bisect_right(self._members, item)\n            self._members.insert(index, item)", "response": "Add item to the list."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove the specified item from the set.", "response": "def discard(self, item):\n        '''Remove *item*.'''\n        index = self._index(item)\n        if index >= 0:\n            del self._members[index]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _index(self, item):\n        '''Return index of *item* in member list or -1 if not present.'''\n        index = bisect.bisect_left(self._members, item)\n        if index != len(self) and self._members[index] == item:\n            return index\n\n        return -1", "response": "Return index of item in member list or - 1 if not present."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns whether the item matches this collection expression.", "response": "def match(self, item):\n        '''Return whether *item* matches this collection expression.\n\n        If a match is successful return data about the match otherwise return\n        None.\n\n        '''\n        match = self._expression.match(item)\n        if not match:\n            return None\n\n        index = match.group('index')\n        padded = False\n        if match.group('padding'):\n            padded = True\n\n        if self.padding == 0:\n            if padded:\n                return None\n\n        elif len(index) != self.padding:\n            return None\n\n        return match"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add(self, item):\n        '''Add *item* to collection.\n\n        raise :py:class:`~clique.error.CollectionError` if *item* cannot be\n        added to the collection.\n\n        '''\n        match = self.match(item)\n        if match is None:\n            raise clique.error.CollectionError(\n                'Item does not match collection expression.'\n            )\n\n        self.indexes.add(int(match.group('index')))", "response": "Add item to the collection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove item from the collection.", "response": "def remove(self, item):\n        '''Remove *item* from collection.\n\n        raise :py:class:`~clique.error.CollectionError` if *item* cannot be\n        removed from the collection.\n\n        '''\n        match = self.match(item)\n        if match is None:\n            raise clique.error.CollectionError(\n                'Item not present in collection.'\n            )\n\n        index = int(match.group('index'))\n        try:\n            self.indexes.remove(index)\n        except KeyError:\n            raise clique.error.CollectionError(\n                'Item not present in collection.'\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn string representation as specified by pattern.", "response": "def format(self, pattern='{head}{padding}{tail} [{ranges}]'):\n        '''Return string representation as specified by *pattern*.\n\n        Pattern can be any format accepted by Python's standard format function\n        and will receive the following keyword arguments as context:\n\n            * *head* - Common leading part of the collection.\n            * *tail* - Common trailing part of the collection.\n            * *padding* - Padding value in ``%0d`` format.\n            * *range* - Total range in the form ``start-end``\n            * *ranges* - Comma separated ranges of indexes.\n            * *holes* - Comma separated ranges of missing indexes.\n\n        '''\n        data = {}\n        data['head'] = self.head\n        data['tail'] = self.tail\n\n        if self.padding:\n            data['padding'] = '%0{0}d'.format(self.padding)\n        else:\n            data['padding'] = '%d'\n\n        if '{holes}' in pattern:\n            data['holes'] = self.holes().format('{ranges}')\n\n        if '{range}' in pattern or '{ranges}' in pattern:\n            indexes = list(self.indexes)\n            indexes_count = len(indexes)\n\n            if indexes_count == 0:\n                data['range'] = ''\n\n            elif indexes_count == 1:\n                data['range'] = '{0}'.format(indexes[0])\n\n            else:\n                data['range'] = '{0}-{1}'.format(\n                    indexes[0], indexes[-1]\n                )\n\n        if '{ranges}' in pattern:\n            separated = self.separate()\n            if len(separated) > 1:\n                ranges = [collection.format('{range}')\n                          for collection in separated]\n\n            else:\n                ranges = [data['range']]\n\n            data['ranges'] = ', '.join(ranges)\n\n        return pattern.format(**data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn whether entire collection is contiguous.", "response": "def is_contiguous(self):\n        '''Return whether entire collection is contiguous.'''\n        previous = None\n        for index in self.indexes:\n            if previous is None:\n                previous = index\n                continue\n\n            if index != (previous + 1):\n                return False\n\n            previous = index\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef holes(self):\n        '''Return holes in collection.\n\n        Return :py:class:`~clique.collection.Collection` of missing indexes.\n\n        '''\n        missing = set([])\n        previous = None\n        for index in self.indexes:\n            if previous is None:\n                previous = index\n                continue\n\n            if index != (previous + 1):\n                missing.update(range(previous + 1, index))\n\n            previous = index\n\n        return Collection(self.head, self.tail, self.padding, indexes=missing)", "response": "Return a new collection with holes in self."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_compatible(self, collection):\n        '''Return whether *collection* is compatible with this collection.\n\n        To be compatible *collection* must have the same head, tail and padding\n        properties as this collection.\n\n        '''\n        return all([\n            isinstance(collection, Collection),\n            collection.head == self.head,\n            collection.tail == self.tail,\n            collection.padding == self.padding\n        ])", "response": "Return whether the given collection is compatible with this one."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef merge(self, collection):\n        '''Merge *collection* into this collection.\n\n        If the *collection* is compatible with this collection then update\n        indexes with all indexes in *collection*.\n\n        raise :py:class:`~clique.error.CollectionError` if *collection* is not\n        compatible with this collection.\n\n        '''\n        if not self.is_compatible(collection):\n            raise clique.error.CollectionError('Collection is not compatible '\n                                               'with this collection.')\n\n        self.indexes.update(collection.indexes)", "response": "Merge the current collection into the given collection."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning contiguous parts of collection as separate collections.", "response": "def separate(self):\n        '''Return contiguous parts of collection as separate collections.\n\n        Return as list of :py:class:`~clique.collection.Collection` instances.\n\n        '''\n        collections = []\n        start = None\n        end = None\n\n        for index in self.indexes:\n            if start is None:\n                start = index\n                end = start\n                continue\n\n            if index != (end + 1):\n                collections.append(\n                    Collection(self.head, self.tail, self.padding,\n                               indexes=set(range(start, end + 1)))\n                )\n                start = index\n\n            end = index\n\n        if start is None:\n            collections.append(\n                Collection(self.head, self.tail, self.padding)\n            )\n        else:\n            collections.append(\n                Collection(self.head, self.tail, self.padding,\n                           indexes=range(start, end + 1))\n            )\n\n        return collections"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef format_check(settings):\n\n    valid_keys = ['logs_folder', 'log_file', 'log_console', 'log_name',\n                  'log_filename', 'keep_osm_tags']\n\n    for key in list(settings.keys()):\n        assert key in valid_keys, \\\n            ('{} not found in list of valid configuation keys').format(key)\n        assert isinstance(key, str), ('{} must be a string').format(key)\n        if key == 'keep_osm_tags':\n            assert isinstance(settings[key], list), \\\n                ('{} must be a list').format(key)\n            for value in settings[key]:\n                assert all(isinstance(element, str) for element in value), \\\n                    'all elements must be a string'\n        if key == 'log_file' or key == 'log_console':\n            assert isinstance(settings[key], bool), \\\n                ('{} must be boolean').format(key)", "response": "Check the format of a osmnet_config object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a dict representation of an osmnet osmnet_config instance.", "response": "def to_dict(self):\n        \"\"\"\n        Return a dict representation of an osmnet osmnet_config instance.\n        \"\"\"\n        return {'logs_folder': self.logs_folder,\n                'log_file': self.log_file,\n                'log_console': self.log_console,\n                'log_name': self.log_name,\n                'log_filename': self.log_filename,\n                'keep_osm_tags': self.keep_osm_tags\n                }"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef great_circle_dist(lat1, lon1, lat2, lon2):\n    radius = 6372795  # meters\n\n    lat1 = math.radians(lat1)\n    lon1 = math.radians(lon1)\n    lat2 = math.radians(lat2)\n    lon2 = math.radians(lon2)\n\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n\n    # formula from:\n    # http://en.wikipedia.org/wiki/Haversine_formula#The_haversine_formula\n    a = math.pow(math.sin(dlat / 2), 2)\n    b = math.cos(lat1) * math.cos(lat2) * math.pow(math.sin(dlon / 2), 2)\n    d = 2 * radius * math.asin(math.sqrt(a + b))\n\n    return d", "response": "Calculates the great circle distance between two lat / lon points and returns the distance in meters."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a filter to query Overpass API for the specified OSM network type.", "response": "def osm_filter(network_type):\n    \"\"\"\n    Create a filter to query Overpass API for the specified OSM network type.\n\n    Parameters\n    ----------\n    network_type : string, {'walk', 'drive'} denoting the type of street\n    network to extract\n\n    Returns\n    -------\n    osm_filter : string\n    \"\"\"\n    filters = {}\n\n    # drive: select only roads that are drivable by normal 2 wheel drive\n    # passenger vehicles both private and public\n    # roads. Filter out un-drivable roads and service roads tagged as parking,\n    # driveway, or emergency-access\n    filters['drive'] = ('[\"highway\"!~\"cycleway|footway|path|pedestrian|steps'\n                        '|track|proposed|construction|bridleway|abandoned'\n                        '|platform|raceway|service\"]'\n                        '[\"motor_vehicle\"!~\"no\"][\"motorcar\"!~\"no\"]'\n                        '[\"service\"!~\"parking|parking_aisle|driveway'\n                        '|emergency_access\"]')\n\n    # walk: select only roads and pathways that allow pedestrian access both\n    # private and public pathways and roads.\n    # Filter out limited access roadways and allow service roads\n    filters['walk'] = ('[\"highway\"!~\"motor|proposed|construction|abandoned'\n                       '|platform|raceway\"][\"foot\"!~\"no\"]'\n                       '[\"pedestrians\"!~\"no\"]')\n\n    if network_type in filters:\n        osm_filter = filters[network_type]\n    else:\n        raise ValueError('unknown network_type \"{}\"'.format(network_type))\n\n    return osm_filter"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef osm_net_download(lat_min=None, lng_min=None, lat_max=None, lng_max=None,\n                     network_type='walk', timeout=180, memory=None,\n                     max_query_area_size=50*1000*50*1000,\n                     custom_osm_filter=None):\n    \"\"\"\n    Download OSM ways and nodes within a bounding box from the Overpass API.\n\n    Parameters\n    ----------\n    lat_min : float\n        southern latitude of bounding box\n    lng_min : float\n        eastern longitude of bounding box\n    lat_max : float\n        northern latitude of bounding box\n    lng_max : float\n        western longitude of bounding box\n    network_type : string\n        Specify the network type where value of 'walk' includes roadways\n        where pedestrians are allowed and pedestrian\n        pathways and 'drive' includes driveable roadways.\n    timeout : int\n        the timeout interval for requests and to pass to Overpass API\n    memory : int\n        server memory allocation size for the query, in bytes. If none,\n        server will use its default allocation size\n    max_query_area_size : float\n        max area for any part of the geometry, in the units the geometry is\n        in: any polygon bigger will get divided up for multiple queries to\n        Overpass API (default is 50,000 * 50,000 units (ie, 50km x 50km in\n        area, if units are meters))\n    custom_osm_filter : string, optional\n        specify custom arguments for the way[\"highway\"] query to OSM. Must\n        follow Overpass API schema. For\n        example to request highway ways that are service roads use:\n        '[\"highway\"=\"service\"]'\n\n    Returns\n    -------\n    response_json : dict\n    \"\"\"\n\n    # create a filter to exclude certain kinds of ways based on the requested\n    # network_type\n    if custom_osm_filter is None:\n        request_filter = osm_filter(network_type)\n    else:\n        request_filter = custom_osm_filter\n\n    response_jsons_list = []\n    response_jsons = []\n\n    # server memory allocation in bytes formatted for Overpass API query\n    if memory is None:\n        maxsize = ''\n    else:\n        maxsize = '[maxsize:{}]'.format(memory)\n\n    # define the Overpass API query\n    # way[\"highway\"] denotes ways with highway keys and {filters} returns\n    # ways with the requested key/value. the '>' makes it recurse so we get\n    # ways and way nodes. maxsize is in bytes.\n\n    # turn bbox into a polygon and project to local UTM\n    polygon = Polygon([(lng_max, lat_min), (lng_min, lat_min),\n                       (lng_min, lat_max), (lng_max, lat_max)])\n    geometry_proj, crs_proj = project_geometry(polygon,\n                                               crs={'init': 'epsg:4326'})\n\n    # subdivide the bbox area poly if it exceeds the max area size\n    # (in meters), then project back to WGS84\n    geometry_proj_consolidated_subdivided = consolidate_subdivide_geometry(\n        geometry_proj, max_query_area_size=max_query_area_size)\n    geometry, crs = project_geometry(geometry_proj_consolidated_subdivided,\n                                     crs=crs_proj, to_latlong=True)\n    log('Requesting network data within bounding box from Overpass API '\n        'in {:,} request(s)'.format(len(geometry)))\n    start_time = time.time()\n\n    # loop through each polygon in the geometry\n    for poly in geometry:\n        # represent bbox as lng_max, lat_min, lng_min, lat_max and round\n        # lat-longs to 8 decimal places to create\n        # consistent URL strings\n        lng_max, lat_min, lng_min, lat_max = poly.bounds\n        query_template = '[out:json][timeout:{timeout}]{maxsize};' \\\n                         '(way[\"highway\"]' \\\n                         '{filters}({lat_min:.8f},{lng_max:.8f},' \\\n                         '{lat_max:.8f},{lng_min:.8f});>;);out;'\n        query_str = query_template.format(lat_max=lat_max, lat_min=lat_min,\n                                          lng_min=lng_min, lng_max=lng_max,\n                                          filters=request_filter,\n                                          timeout=timeout, maxsize=maxsize)\n        response_json = overpass_request(data={'data': query_str},\n                                         timeout=timeout)\n\n        response_jsons_list.append(response_json)\n\n    log('Downloaded OSM network data within bounding box from Overpass '\n        'API in {:,} request(s) and'\n        ' {:,.2f} seconds'.format(len(geometry), time.time()-start_time))\n\n    # stitch together individual json results\n    for json in response_jsons_list:\n        try:\n            response_jsons.extend(json['elements'])\n        except KeyError:\n            pass\n\n    # remove duplicate records resulting from the json stitching\n    start_time = time.time()\n    record_count = len(response_jsons)\n\n    if record_count == 0:\n        raise Exception('Query resulted in no data. Check your query '\n                        'parameters: {}'.format(query_str))\n    else:\n        response_jsons_df = pd.DataFrame.from_records(response_jsons,\n                                                      index='id')\n        nodes = response_jsons_df[response_jsons_df['type'] == 'node']\n        nodes = nodes[~nodes.index.duplicated(keep='first')]\n        ways = response_jsons_df[response_jsons_df['type'] == 'way']\n        ways = ways[~ways.index.duplicated(keep='first')]\n        response_jsons_df = pd.concat([nodes, ways], axis=0)\n        response_jsons_df.reset_index(inplace=True)\n        response_jsons = response_jsons_df.to_dict(orient='records')\n        if record_count - len(response_jsons) > 0:\n            log('{:,} duplicate records removed. Took {:,.2f} seconds'.format(\n                record_count - len(response_jsons), time.time() - start_time))\n\n    return {'elements': response_jsons}", "response": "Download OSM ways and nodes within a bounding box from the Overpass API."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef overpass_request(data, pause_duration=None, timeout=180,\n                     error_pause_duration=None):\n    \"\"\"\n    Send a request to the Overpass API via HTTP POST and return the\n    JSON response\n\n    Parameters\n    ----------\n    data : dict or OrderedDict\n        key-value pairs of parameters to post to Overpass API\n    pause_duration : int\n        how long to pause in seconds before requests, if None, will query\n        Overpass API status endpoint\n        to find when next slot is available\n    timeout : int\n        the timeout interval for the requests library\n    error_pause_duration : int\n        how long to pause in seconds before re-trying requests if error\n\n    Returns\n    -------\n    response_json : dict\n    \"\"\"\n\n    # define the Overpass API URL, then construct a GET-style URL\n    url = 'http://www.overpass-api.de/api/interpreter'\n\n    start_time = time.time()\n    log('Posting to {} with timeout={}, \"{}\"'.format(url, timeout, data))\n    response = requests.post(url, data=data, timeout=timeout)\n\n    # get the response size and the domain, log result\n    size_kb = len(response.content) / 1000.\n    domain = re.findall(r'//(?s)(.*?)/', url)[0]\n    log('Downloaded {:,.1f}KB from {} in {:,.2f} seconds'\n        .format(size_kb, domain, time.time()-start_time))\n\n    try:\n        response_json = response.json()\n        if 'remark' in response_json:\n            log('Server remark: \"{}\"'.format(response_json['remark'],\n                                             level=lg.WARNING))\n\n    except Exception:\n        # 429 = 'too many requests' and 504 = 'gateway timeout' from server\n        # overload. handle these errors by recursively\n        # calling overpass_request until a valid response is achieved\n        if response.status_code in [429, 504]:\n            # pause for error_pause_duration seconds before re-trying request\n            if error_pause_duration is None:\n                error_pause_duration = get_pause_duration()\n            log('Server at {} returned status code {} and no JSON data. '\n                'Re-trying request in {:.2f} seconds.'\n                .format(domain, response.status_code, error_pause_duration),\n                level=lg.WARNING)\n            time.sleep(error_pause_duration)\n            response_json = overpass_request(data=data,\n                                             pause_duration=pause_duration,\n                                             timeout=timeout)\n\n        # else, this was an unhandled status_code, throw an exception\n        else:\n            log('Server at {} returned status code {} and no JSON data'\n                .format(domain, response.status_code), level=lg.ERROR)\n            raise Exception('Server returned no JSON data.\\n{} {}\\n{}'\n                            .format(response, response.reason, response.text))\n\n    return response_json", "response": "Send a request to the Overpass API and return the JSON response"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_pause_duration(recursive_delay=5, default_duration=10):\n    try:\n        response = requests.get('http://overpass-api.de/api/status')\n        status = response.text.split('\\n')[3]\n        status_first_token = status.split(' ')[0]\n    except Exception:\n        # if status endpoint cannot be reached or output parsed, log error\n        # and return default duration\n        log('Unable to query http://overpass-api.de/api/status',\n            level=lg.ERROR)\n        return default_duration\n\n    try:\n        # if first token is numeric, it indicates the number of slots\n        # available - no wait required\n        available_slots = int(status_first_token)\n        pause_duration = 0\n    except Exception:\n        # if first token is 'Slot', it tells you when your slot will be free\n        if status_first_token == 'Slot':\n            utc_time_str = status.split(' ')[3]\n            utc_time = date_parser.parse(utc_time_str).replace(tzinfo=None)\n            pause_duration = math.ceil(\n                (utc_time - dt.datetime.utcnow()).total_seconds())\n            pause_duration = max(pause_duration, 1)\n\n        # if first token is 'Currently', it is currently running a query so\n        # check back in recursive_delay seconds\n        elif status_first_token == 'Currently':\n            time.sleep(recursive_delay)\n            pause_duration = get_pause_duration()\n\n        else:\n            # any other status is unrecognized - log an error and return\n            # default duration\n            log('Unrecognized server status: \"{}\"'.format(status),\n                level=lg.ERROR)\n            return default_duration\n\n    return pause_duration", "response": "Get the pause duration of the current item in the order they are available."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef consolidate_subdivide_geometry(geometry, max_query_area_size):\n\n    # let the linear length of the quadrats (with which to subdivide the\n    # geometry) be the square root of max area size\n    quadrat_width = math.sqrt(max_query_area_size)\n\n    if not isinstance(geometry, (Polygon, MultiPolygon)):\n        raise ValueError('Geometry must be a shapely Polygon or MultiPolygon')\n\n    # if geometry is a MultiPolygon OR a single Polygon whose area exceeds\n    # the max size, get the convex hull around the geometry\n    if isinstance(\n            geometry, MultiPolygon) or \\\n            (isinstance(\n                geometry, Polygon) and geometry.area > max_query_area_size):\n        geometry = geometry.convex_hull\n\n    # if geometry area exceeds max size, subdivide it into smaller sub-polygons\n    if geometry.area > max_query_area_size:\n        geometry = quadrat_cut_geometry(geometry, quadrat_width=quadrat_width)\n\n    if isinstance(geometry, Polygon):\n        geometry = MultiPolygon([geometry])\n\n    return geometry", "response": "Consolidate a geometry into a convex hull then subdivide it into smaller sub - polygons if it exceeds max_query_area_size."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef quadrat_cut_geometry(geometry, quadrat_width, min_num=3,\n                         buffer_amount=1e-9):\n    \"\"\"\n    Split a Polygon or MultiPolygon up into sub-polygons of a specified size,\n    using quadrats.\n\n    Parameters\n    ----------\n    geometry : shapely Polygon or MultiPolygon\n        the geometry to split up into smaller sub-polygons\n    quadrat_width : float\n        the linear width of the quadrats with which to cut up the geometry\n        (in the units the geometry is in)\n    min_num : float\n        the minimum number of linear quadrat lines (e.g., min_num=3 would\n        produce a quadrat grid of 4 squares)\n    buffer_amount : float\n        buffer the quadrat grid lines by quadrat_width times buffer_amount\n\n    Returns\n    -------\n    multipoly : shapely MultiPolygon\n    \"\"\"\n\n    # create n evenly spaced points between the min and max x and y bounds\n    lng_max, lat_min, lng_min, lat_max = geometry.bounds\n    x_num = math.ceil((lng_min-lng_max) / quadrat_width) + 1\n    y_num = math.ceil((lat_max-lat_min) / quadrat_width) + 1\n    x_points = np.linspace(lng_max, lng_min, num=max(x_num, min_num))\n    y_points = np.linspace(lat_min, lat_max, num=max(y_num, min_num))\n\n    # create a quadrat grid of lines at each of the evenly spaced points\n    vertical_lines = [LineString([(x, y_points[0]), (x, y_points[-1])])\n                      for x in x_points]\n    horizont_lines = [LineString([(x_points[0], y), (x_points[-1], y)])\n                      for y in y_points]\n    lines = vertical_lines + horizont_lines\n\n    # buffer each line to distance of the quadrat width divided by 1 billion,\n    # take their union, then cut geometry into pieces by these quadrats\n    buffer_size = quadrat_width * buffer_amount\n    lines_buffered = [line.buffer(buffer_size) for line in lines]\n    quadrats = unary_union(lines_buffered)\n    multipoly = geometry.difference(quadrats)\n\n    return multipoly", "response": "Split a shapely Polygon or MultiPolygon into smaller sub - polygons and buffer them into smaller quadrats."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprojecting a shapely geometry to a shapely polygon or MultiPolygon from WGS84 to UTM or vice - versa.", "response": "def project_geometry(geometry, crs, to_latlong=False):\n    \"\"\"\n    Project a shapely Polygon or MultiPolygon from WGS84 to UTM, or vice-versa\n\n    Parameters\n    ----------\n    geometry : shapely Polygon or MultiPolygon\n        the geometry to project\n    crs : int\n        the starting coordinate reference system of the passed-in geometry\n    to_latlong : bool\n        if True, project from crs to WGS84, if False, project\n        from crs to local UTM zone\n\n    Returns\n    -------\n    geometry_proj, crs : tuple (projected shapely geometry, crs of the\n    projected geometry)\n    \"\"\"\n    gdf = gpd.GeoDataFrame()\n    gdf.crs = crs\n    gdf.name = 'geometry to project'\n    gdf['geometry'] = None\n    gdf.loc[0, 'geometry'] = geometry\n    gdf_proj = project_gdf(gdf, to_latlong=to_latlong)\n    geometry_proj = gdf_proj['geometry'].iloc[0]\n    return geometry_proj, gdf_proj.crs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_node(e):\n    node = {'id': e['id'],\n            'lat': e['lat'],\n            'lon': e['lon']}\n\n    if 'tags' in e:\n        if e['tags'] is not np.nan:\n            for t, v in list(e['tags'].items()):\n                if t in config.settings.keep_osm_tags:\n                    node[t] = v\n\n    return node", "response": "Process a node element entry into a dict suitable for going into a Pandas DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef process_way(e):\n    way = {'id': e['id']}\n\n    if 'tags' in e:\n        if e['tags'] is not np.nan:\n            for t, v in list(e['tags'].items()):\n                if t in config.settings.keep_osm_tags:\n                    way[t] = v\n\n    # nodes that make up a way\n    waynodes = []\n\n    for n in e['nodes']:\n        waynodes.append({'way_id': e['id'], 'node_id': n})\n\n    return way, waynodes", "response": "Process a way element entry into a list of dicts suitable for going into a Pandas DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_network_osm_query(data):\n    if len(data['elements']) == 0:\n        raise RuntimeError('OSM query results contain no data.')\n\n    nodes = []\n    ways = []\n    waynodes = []\n\n    for e in data['elements']:\n        if e['type'] == 'node':\n            nodes.append(process_node(e))\n        elif e['type'] == 'way':\n            w, wn = process_way(e)\n            ways.append(w)\n            waynodes.extend(wn)\n\n    nodes = pd.DataFrame.from_records(nodes, index='id')\n    ways = pd.DataFrame.from_records(ways, index='id')\n    waynodes = pd.DataFrame.from_records(waynodes, index='way_id')\n\n    return (nodes, ways, waynodes)", "response": "Convert OSM query data to DataFrames of ways and way - nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ways_in_bbox(lat_min, lng_min, lat_max, lng_max, network_type,\n                 timeout=180, memory=None,\n                 max_query_area_size=50*1000*50*1000,\n                 custom_osm_filter=None):\n    \"\"\"\n    Get DataFrames of OSM data in a bounding box.\n\n    Parameters\n    ----------\n    lat_min : float\n        southern latitude of bounding box\n    lng_min : float\n        eastern longitude of bounding box\n    lat_max : float\n        northern latitude of bounding box\n    lng_max : float\n        western longitude of bounding box\n    network_type : {'walk', 'drive'}, optional\n        Specify the network type where value of 'walk' includes roadways\n        where pedestrians are allowed and pedestrian pathways and 'drive'\n        includes driveable roadways.\n    timeout : int\n        the timeout interval for requests and to pass to Overpass API\n    memory : int\n        server memory allocation size for the query, in bytes. If none,\n        server will use its default allocation size\n    max_query_area_size : float\n        max area for any part of the geometry, in the units the geometry is\n        in: any polygon bigger will get divided up for multiple queries to\n        Overpass API (default is 50,000 * 50,000 units (ie, 50km x 50km in\n        area, if units are meters))\n    custom_osm_filter : string, optional\n        specify custom arguments for the way[\"highway\"] query to OSM. Must\n        follow Overpass API schema. For\n        example to request highway ways that are service roads use:\n        '[\"highway\"=\"service\"]'\n\n    Returns\n    -------\n    nodes, ways, waynodes : pandas.DataFrame\n\n    \"\"\"\n    return parse_network_osm_query(\n        osm_net_download(lat_max=lat_max, lat_min=lat_min, lng_min=lng_min,\n                         lng_max=lng_max, network_type=network_type,\n                         timeout=timeout, memory=memory,\n                         max_query_area_size=max_query_area_size,\n                         custom_osm_filter=custom_osm_filter))", "response": "Get DataFrames of OSM data in a bounding box."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef intersection_nodes(waynodes):\n    counts = waynodes.node_id.value_counts()\n    return set(counts[counts > 1].index.values)", "response": "Returns a set of all the nodes that appear in 2 or more ways."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a table of node pairs for the given nodes and ways.", "response": "def node_pairs(nodes, ways, waynodes, two_way=True):\n    \"\"\"\n    Create a table of node pairs with the distances between them.\n\n    Parameters\n    ----------\n    nodes : pandas.DataFrame\n        Must have 'lat' and 'lon' columns.\n    ways : pandas.DataFrame\n        Table of way metadata.\n    waynodes : pandas.DataFrame\n        Table linking way IDs to node IDs. Way IDs should be in the index,\n        with a column called 'node_ids'.\n    two_way : bool, optional\n        Whether the routes are two-way. If True, node pairs will only\n        occur once. Default is True.\n\n    Returns\n    -------\n    pairs : pandas.DataFrame\n        Will have columns of 'from_id', 'to_id', and 'distance'.\n        The index will be a MultiIndex of (from id, to id).\n        The distance metric is in meters.\n\n    \"\"\"\n    start_time = time.time()\n\n    def pairwise(l):\n        return zip(islice(l, 0, len(l)), islice(l, 1, None))\n    intersections = intersection_nodes(waynodes)\n    waymap = waynodes.groupby(level=0, sort=False)\n    pairs = []\n\n    for id, row in ways.iterrows():\n        nodes_in_way = waymap.get_group(id).node_id.values\n        nodes_in_way = [x for x in nodes_in_way if x in intersections]\n\n        if len(nodes_in_way) < 2:\n            # no nodes to connect in this way\n            continue\n\n        for from_node, to_node in pairwise(nodes_in_way):\n            if from_node != to_node:\n                fn = nodes.loc[from_node]\n                tn = nodes.loc[to_node]\n\n                distance = round(gcd(fn.lat, fn.lon, tn.lat, tn.lon), 6)\n\n                col_dict = {'from_id': from_node,\n                            'to_id': to_node,\n                            'distance': distance}\n\n                for tag in config.settings.keep_osm_tags:\n                    try:\n                        col_dict.update({tag: row[tag]})\n                    except KeyError:\n                        pass\n\n                pairs.append(col_dict)\n\n                if not two_way:\n\n                    col_dict = {'from_id': to_node,\n                                'to_id': from_node,\n                                'distance': distance}\n\n                    for tag in config.settings.keep_osm_tags:\n                        try:\n                            col_dict.update({tag: row[tag]})\n                        except KeyError:\n                            pass\n\n                    pairs.append(col_dict)\n\n    pairs = pd.DataFrame.from_records(pairs)\n    if pairs.empty:\n        raise Exception('Query resulted in no connected node pairs. Check '\n                        'your query parameters or bounding box')\n    else:\n        pairs.index = pd.MultiIndex.from_arrays([pairs['from_id'].values,\n                                                 pairs['to_id'].values])\n        log('Edge node pairs completed. Took {:,.2f} seconds'\n            .format(time.time()-start_time))\n\n        return pairs"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmakes a graph network from a bounding lat/lon box composed of nodes and edges for use in Pandana street network accessibility calculations. You may either enter a lat/long box via the four lat_min, lng_min, lat_max, lng_max parameters or the bbox parameter as a tuple. Parameters ---------- lat_min : float southern latitude of bounding box, if this parameter is used the bbox parameter should be None. lng_min : float eastern latitude of bounding box, if this parameter is used the bbox parameter should be None. lat_max : float northern longitude of bounding box, if this parameter is used the bbox parameter should be None. lng_max : float western longitude of bounding box, if this parameter is used the bbox parameter should be None. bbox : tuple Bounding box formatted as a 4 element tuple: (lng_max, lat_min, lng_min, lat_max) example: (-122.304611,37.798933,-122.263412,37.822802) a bbox can be extracted for an area using: the CSV format bbox from http://boundingbox.klokantech.com/. If this parameter is used the lat_min, lng_min, lat_max, lng_max parameters in this function should be None. network_type : {'walk', 'drive'}, optional Specify the network type where value of 'walk' includes roadways where pedestrians are allowed and pedestrian pathways and 'drive' includes driveable roadways. To use a custom definition see the custom_osm_filter parameter. Default is walk. two_way : bool, optional Whether the routes are two-way. If True, node pairs will only occur once. timeout : int, optional the timeout interval for requests and to pass to Overpass API memory : int, optional server memory allocation size for the query, in bytes. If none, server will use its default allocation size max_query_area_size : float, optional max area for any part of the geometry, in the units the geometry is in: any polygon bigger will get divided up for multiple queries to Overpass API (default is 50,000 * 50,000 units (ie, 50km x 50km in area, if units are meters)) custom_osm_filter : string, optional specify custom arguments for the way[\"highway\"] query to OSM. Must follow Overpass API schema. For example to request highway ways that are service roads use: '[\"highway\"=\"service\"]' Returns ------- nodesfinal, edgesfinal : pandas.DataFrame", "response": "def network_from_bbox(lat_min=None, lng_min=None, lat_max=None, lng_max=None,\n                      bbox=None, network_type='walk', two_way=True,\n                      timeout=180, memory=None,\n                      max_query_area_size=50*1000*50*1000,\n                      custom_osm_filter=None):\n    \"\"\"\n    Make a graph network from a bounding lat/lon box composed of nodes and\n    edges for use in Pandana street network accessibility calculations.\n    You may either enter a lat/long box via the four lat_min,\n    lng_min, lat_max, lng_max parameters or the bbox parameter as a tuple.\n\n    Parameters\n    ----------\n    lat_min : float\n        southern latitude of bounding box, if this parameter is used the bbox\n        parameter should be None.\n    lng_min : float\n        eastern latitude of bounding box, if this parameter is used the bbox\n        parameter should be None.\n    lat_max : float\n        northern longitude of bounding box, if this parameter is used the bbox\n        parameter should be None.\n    lng_max : float\n        western longitude of bounding box, if this parameter is used the bbox\n        parameter should be None.\n    bbox : tuple\n        Bounding box formatted as a 4 element tuple:\n        (lng_max, lat_min, lng_min, lat_max)\n        example: (-122.304611,37.798933,-122.263412,37.822802)\n        a bbox can be extracted for an area using: the CSV format bbox from\n        http://boundingbox.klokantech.com/. If this parameter is used the\n        lat_min, lng_min, lat_max, lng_max parameters in this function\n        should be None.\n    network_type : {'walk', 'drive'}, optional\n        Specify the network type where value of 'walk' includes roadways where\n        pedestrians are allowed and pedestrian pathways and 'drive' includes\n        driveable roadways. To use a custom definition see the\n        custom_osm_filter parameter. Default is walk.\n    two_way : bool, optional\n        Whether the routes are two-way. If True, node pairs will only\n        occur once.\n    timeout : int, optional\n        the timeout interval for requests and to pass to Overpass API\n    memory : int, optional\n        server memory allocation size for the query, in bytes. If none,\n        server will use its default allocation size\n    max_query_area_size : float, optional\n        max area for any part of the geometry, in the units the geometry is\n        in: any polygon bigger will get divided up for multiple queries to\n        Overpass API (default is 50,000 * 50,000 units (ie, 50km x 50km in\n        area, if units are meters))\n    custom_osm_filter : string, optional\n        specify custom arguments for the way[\"highway\"] query to OSM. Must\n        follow Overpass API schema. For\n        example to request highway ways that are service roads use:\n        '[\"highway\"=\"service\"]'\n\n    Returns\n    -------\n    nodesfinal, edgesfinal : pandas.DataFrame\n\n    \"\"\"\n\n    start_time = time.time()\n\n    if bbox is not None:\n        assert isinstance(bbox, tuple) \\\n               and len(bbox) == 4, 'bbox must be a 4 element tuple'\n        assert (lat_min is None) and (lng_min is None) and \\\n               (lat_max is None) and (lng_max is None), \\\n            'lat_min, lng_min, lat_max and lng_max must be None ' \\\n            'if you are using bbox'\n\n        lng_max, lat_min, lng_min, lat_max = bbox\n\n    assert lat_min is not None, 'lat_min cannot be None'\n    assert lng_min is not None, 'lng_min cannot be None'\n    assert lat_max is not None, 'lat_max cannot be None'\n    assert lng_max is not None, 'lng_max cannot be None'\n    assert isinstance(lat_min, float) and isinstance(lng_min, float) and \\\n        isinstance(lat_max, float) and isinstance(lng_max, float), \\\n        'lat_min, lng_min, lat_max, and lng_max must be floats'\n\n    nodes, ways, waynodes = ways_in_bbox(\n        lat_min=lat_min, lng_min=lng_min, lat_max=lat_max, lng_max=lng_max,\n        network_type=network_type, timeout=timeout,\n        memory=memory, max_query_area_size=max_query_area_size,\n        custom_osm_filter=custom_osm_filter)\n    log('Returning OSM data with {:,} nodes and {:,} ways...'\n        .format(len(nodes), len(ways)))\n\n    edgesfinal = node_pairs(nodes, ways, waynodes, two_way=two_way)\n\n    # make the unique set of nodes that ended up in pairs\n    node_ids = sorted(set(edgesfinal['from_id'].unique())\n                      .union(set(edgesfinal['to_id'].unique())))\n    nodesfinal = nodes.loc[node_ids]\n    nodesfinal = nodesfinal[['lon', 'lat']]\n    nodesfinal.rename(columns={'lon': 'x', 'lat': 'y'}, inplace=True)\n    nodesfinal['id'] = nodesfinal.index\n    edgesfinal.rename(columns={'from_id': 'from', 'to_id': 'to'}, inplace=True)\n    log('Returning processed graph with {:,} nodes and {:,} edges...'\n        .format(len(nodesfinal), len(edgesfinal)))\n    log('Completed OSM data download and Pandana node and edge table '\n        'creation in {:,.2f} seconds'.format(time.time()-start_time))\n\n    return nodesfinal, edgesfinal"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of lines from a markdown file.", "response": "def read_lines(in_file):\n    \"\"\"Returns a list of lines from a input markdown file.\"\"\"\n\n    with open(in_file, 'r') as inf:\n        in_contents = inf.read().split('\\n')\n    return in_contents"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_lines(lines, remove=('[[back to top]', '<a class=\"mk-toclify\"')):\n\n    if not remove:\n        return lines[:]\n\n    out = []\n    for l in lines:\n        if l.startswith(remove):\n            continue\n        out.append(l)\n    return out", "response": "Removes existing links and tags from a list of lines."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef slugify_headline(line, remove_dashes=False):\n    stripped_right = line.rstrip('#')\n    stripped_both = stripped_right.lstrip('#')\n    level = len(stripped_right) - len(stripped_both)\n    stripped_wspace = stripped_both.strip()\n\n    # character replacements\n    replaced_colon = stripped_wspace.replace('.', '')\n    replaced_slash = replaced_colon.replace('/', '')\n    rem_nonvalids = ''.join([c if c in VALIDS\n                             else '-' for c in replaced_slash])\n\n    lowered = rem_nonvalids.lower()\n    slugified = re.sub(r'(-)\\1+', r'\\1', lowered)  # remove duplicate dashes\n    slugified = slugified.strip('-')  # strip dashes from start and end\n\n    # exception '&' (double-dash in github)\n    slugified = slugified.replace('-&-', '--')\n\n    if remove_dashes:\n        slugified = slugified.replace('-','')\n\n    return [stripped_wspace, slugified, level]", "response": "Takes a string version of the head line and returns a tuple of the stripped version of the head line a string version for anchor tags and the level of the headline as integer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tag_and_collect(lines, id_tag=True, back_links=False, exclude_h=None, remove_dashes=False):\n    out_contents = []\n    headlines = []\n    for l in lines:\n        saw_headline = False\n\n        orig_len = len(l)\n        l = l.lstrip()\n\n        if l.startswith(('# ', '## ', '### ', '#### ', '##### ', '###### ')):\n\n            # comply with new markdown standards\n\n            # not a headline if '#' not followed by whitespace '##no-header':\n            if not l.lstrip('#').startswith(' '):\n                continue\n            # not a headline if more than 6 '#':\n            if len(l) - len(l.lstrip('#')) > 6:\n                continue\n            # headers can be indented by at most 3 spaces:\n            if orig_len - len(l) > 3:\n                continue\n\n            # ignore empty headers\n            if not set(l) - {'#', ' '}:\n                continue\n\n            saw_headline = True\n            slugified = slugify_headline(l, remove_dashes)\n\n            if not exclude_h or not slugified[-1] in exclude_h:\n                if id_tag:\n                    id_tag = '<a class=\"mk-toclify\" id=\"%s\"></a>'\\\n                              % (slugified[1])\n                    out_contents.append(id_tag)\n                headlines.append(slugified)\n\n        out_contents.append(l)\n        if back_links and saw_headline:\n            out_contents.append('[[back to top](#table-of-contents)]')\n    return out_contents, headlines", "response": "Returns a list of headlines and anchor tags for the given list of lines."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npositions the headlines in a sequence of words.", "response": "def positioning_headlines(headlines):\n    \"\"\"\n    Strips unnecessary whitespaces/tabs if first header is not left-aligned\n    \"\"\"\n    left_just = False\n    for row in headlines:\n        if row[-1] == 1:\n            left_just = True\n            break\n    if not left_just:\n        for row in headlines:\n            row[-1] -= 1\n    return headlines"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_toc(headlines, hyperlink=True, top_link=False, no_toc_header=False):\n    processed = []\n    if not no_toc_header:\n        if top_link:\n            processed.append('<a class=\"mk-toclify\" id=\"table-of-contents\"></a>\\n')\n        processed.append('# Table of Contents')\n\n    for line in headlines:\n        if hyperlink:\n            item = '%s- [%s](#%s)' % ((line[2]-1)*'    ', line[0], line[1])\n        else:\n            item = '%s- %s' % ((line[2]-1)*'    ', line[0])\n        processed.append(item)\n    processed.append('\\n')\n    return processed", "response": "Create a TOC header from a list of headlines."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding the Markdown output contents incl. the table of contents.", "response": "def build_markdown(toc_headlines, body, spacer=0, placeholder=None):\n    \"\"\"\n    Returns a string with the Markdown output contents incl.\n    the table of contents.\n\n    Keyword arguments:\n        toc_headlines: lines for the table of contents\n            as created by the create_toc function.\n        body: contents of the Markdown file including\n            ID-anchor tags as returned by the\n            tag_and_collect function.\n        spacer: Adds vertical space after the table\n            of contents. Height in pixels.\n        placeholder: If a placeholder string is provided, the placeholder\n            will be replaced by the TOC instead of inserting the TOC at\n            the top of the document\n\n    \"\"\"\n    if spacer:\n        spacer_line = ['\\n<div style=\"height:%spx;\"></div>\\n' % (spacer)]\n        toc_markdown = \"\\n\".join(toc_headlines + spacer_line)\n    else:\n        toc_markdown = \"\\n\".join(toc_headlines)\n\n    body_markdown = \"\\n\".join(body).strip()\n\n    if placeholder:\n        markdown = body_markdown.replace(placeholder, toc_markdown)\n    else:\n        markdown = toc_markdown + body_markdown\n\n    return markdown"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef output_markdown(markdown_cont, output_file):\n    if output_file:\n        with open(output_file, 'w') as out:\n            out.write(markdown_cont)", "response": "Writes a markdown file to an output file if outfile is a valid path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfunction to add table of contents to a markdown file.", "response": "def markdown_toclify(input_file, output_file=None, github=False,\n                     back_to_top=False, nolink=False,\n                     no_toc_header=False, spacer=0, placeholder=None,\n                     exclude_h=None, remove_dashes=False):\n    \"\"\" Function to add table of contents to markdown files.\n\n    Parameters\n    -----------\n      input_file: str\n        Path to the markdown input file.\n\n      output_file: str (defaul: None)\n        Path to the markdown output file.\n\n      github: bool (default: False)\n        Uses GitHub TOC syntax if True.\n\n      back_to_top: bool (default: False)\n        Inserts back-to-top links below headings if True.\n\n      nolink: bool (default: False)\n        Creates the table of contents without internal links if True.\n\n      no_toc_header: bool (default: False)\n        Suppresses the Table of Contents header if True\n\n      spacer: int (default: 0)\n        Inserts horizontal space (in pixels) after the table of contents.\n\n      placeholder: str (default: None)\n        Inserts the TOC at the placeholder string instead\n        of inserting the TOC at the top of the document.\n\n      exclude_h: list (default None)\n        Excludes header levels, e.g., if [2, 3], ignores header\n        levels 2 and 3 in the TOC.\n\n      remove_dashes: bool (default: False)\n        Removes dashes from headline slugs\n\n    Returns\n    -----------\n    cont: str\n      Markdown contents including the TOC.\n\n    \"\"\"\n    raw_contents = read_lines(input_file)\n    cleaned_contents = remove_lines(raw_contents, remove=('[[back to top]', '<a class=\"mk-toclify\"'))\n    processed_contents, raw_headlines = tag_and_collect(\n                                            cleaned_contents,\n                                            id_tag=not github,\n                                            back_links=back_to_top,\n                                            exclude_h=exclude_h,\n                                            remove_dashes=remove_dashes\n                                            )\n\n    leftjustified_headlines = positioning_headlines(raw_headlines)\n    processed_headlines = create_toc(leftjustified_headlines,\n                                     hyperlink=not nolink,\n                                     top_link=not nolink and not github,\n                                     no_toc_header=no_toc_header)\n\n    if nolink:\n        processed_contents = cleaned_contents\n\n    cont = build_markdown(toc_headlines=processed_headlines,\n                          body=processed_contents,\n                          spacer=spacer,\n                          placeholder=placeholder)\n\n    if output_file:\n        output_markdown(cont, output_file)\n    return cont"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef url_parse(name):\n    position = name.find(\"github.com\")\n    if position >= 0:\n        if position != 0:\n            position_1 = name.find(\"www.github.com\")\n            position_2 = name.find(\"http://github.com\")\n            position_3 = name.find(\"https://github.com\")\n            if position_1*position_2*position_3 != 0:\n                exception()\n                sys.exit(0)\n        name = name[position+11:]\n        if name.endswith('/'):\n            name = name[:-1]\n        return name\n    else:\n        if name.endswith('/'):\n            name = name[:-1]\n        return name", "response": "parse urls with different prefixes"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef geturl_req(url):\n    request = urllib.request.Request(url)\n    request.add_header('Authorization', 'token %s' % API_TOKEN)\n    try:\n        response_url = urllib.request.urlopen(request).geturl()\n        return response_url\n    except urllib.error.HTTPError:\n        exception()\n        sys.exit(0)", "response": "get request that returns 302"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main():\n    parser = argparse.ArgumentParser(\n        description='Github within the Command Line')\n    group = parser.add_mutually_exclusive_group()\n    group.add_argument('-n', '--url', type=str,\n                       help=\"Get repos from the user profile's URL\")\n    group.add_argument('-r', '--recursive', type=str,\n                       help=\"Get the file structure from the repo link\")\n    group.add_argument('-R', '--readme', type=str,\n                       help=\"Get the raw version of the repo readme from repo link\")\n    group.add_argument('-re', '--releases', type=str,\n                       help=\"Get the list of releases from repo link\")\n    group.add_argument('-dt', '--tarball', type=str,\n                       help=\"Download the tarball of the given repo\")\n    group.add_argument('-dz', '--zipball', type=str,\n                       help=\"Download the zipball of the given repo\")\n    group.add_argument('-op', '--openfile', type=str,\n                       help=\"Show the contents of the given file in a repo\")\n    group.add_argument('-f', '--followers', type=str,\n                       help=\"Get followers of the user\")\n    group.add_argument('-fo', '--following', type=str,\n                       help=\"Get people following the user\")\n    group.add_argument('-c', '--contributors', type=str,\n                       help=\"Get contributors of a repo\")\n\n    if len(sys.argv) == 1:\n        parser.print_help()\n        return\n    args = parser.parse_args()\n\n# URL\n\n    if args.url:\n        name = url_parse(args.url)\n        url = GITHUB_API + 'users/' + name + '/repos'\n\n# TREE\n\n    if args.recursive:\n        name = url_parse(args.recursive)\n        url = GITHUB_API + 'repos/' + name + '/branches/master'\n        response = get_req(url)\n        jsondata = json.loads(response)\n        sha = jsondata['commit']['commit']['tree']['sha']\n        url = GITHUB_API + 'repos/' + name + '/git/trees/' + sha + '?recursive=1'\n\n# README\n\n    if args.readme:\n        name = url_parse(args.readme)\n        url = GITHUB_API + 'repos/' + name + '/readme'\n\n# RELEASES\n\n    if args.releases:\n        name = url_parse(args.releases)\n        url = GITHUB_API + 'repos/' + name + '/releases'\n\n# TARBALL/ZIPBALL\n\n    if args.tarball or args.zipball:\n        if args.tarball:\n            key = '/tarball/'\n            name = url_parse(args.tarball)\n        if args.zipball:\n            key = '/zipball/'\n            name = url_parse(args.zipball)\n        url = GITHUB_API + 'repos/' + name + key + 'master'\n\n# OPEN ONE FILE\n\n    if args.openfile:\n        name = url_parse(args.openfile)\n        position = name.find('/')\n        user = name[:position+1]\n        rest = name[position+1:]\n        position = rest.find('/')\n        repo = rest[:position+1]\n        rest = rest[position+1:]\n        url = GITHUB_API + 'repos/' + user + repo + 'contents/' + rest\n\n# GET RESPONSES\n\n# TARBALL/ZIPBALL\n\n    if args.tarball or args.zipball:\n        response_url = geturl_req(url)\n        position = name.find('/')\n        name = name[position+1:]\n        if args.tarball:\n            name = name+'.tar.gz'\n        if args.zipball:\n            name = name+'.zip'\n        print(\"\\nDownloading \" + name + '...\\n')\n        urllib.request.urlretrieve(response_url, name)\n        print(name + ' has been saved\\n')\n        return\n\n# FOLLOWERS\n\n    if args.followers:\n        name = url_parse(args.followers)\n        url = GITHUB_API + 'users/' + name + '/followers'\n\n#FOLLOWING\n    if args.following:\n        name = url_parse(args.following)\n        url = GITHUB_API + 'users/' + name + '/following'\n\n#CONTRIBUTORS\n    if args.contributors:\n        name = url_parse(args.contributors)\n        url = GITHUB_API + 'repos/' + name + '/contributors'\n\n# OTHER OPTIONS\n\n    response = get_req(url)\n    jsondata = json.loads(response)\n\n# USERNAME and URL\n\n    if args.url:\n        table = PrettyTable([\" Repository \", \"\u2605 Star\"])\n        table.align[\" Repository \"] = \"l\"\n        for i in jsondata:\n            table.add_row([i['name'], i['stargazers_count']])\n        print(table)\n\n# RECURSIVE TREE\n\n    if args.recursive:\n        table = PrettyTable([\" File/Folder \", \" Size (Bytes) \"])\n        table.align[\" File/Folder \"] = \"l\"\n        for i in jsondata['tree']:\n            size = '-'\n            path = i['path']+'/'\n            if i['type'] == 'blob':\n                size = i['size']\n                path = path[:-1]\n            table.add_row([path, size])\n        print(table)\n\n# README\n\n    if args.readme:\n        print(base64.b64decode(jsondata['content']).decode('utf-8'))\n\n# RELEASES\n    if args.releases:\n        table = PrettyTable([\" Release name \", \" Release Date \", \" Release Time \"])\n        for i in jsondata:\n            time = str(dateutil.parser.parse(i['published_at']))\n            date = time[:10]\n            time = time[11:]\n            time = time[:5]\n            time = time + ' UTC'\n            table.add_row([i['tag_name'], date, time])\n        print(table)\n\n# OPEN ONE FILE\n\n    if args.openfile:\n        try:\n            print(base64.b64decode(jsondata['content']).decode('utf-8'))\n            return\n        except:\n            print(\"\\nDirectory URL was given, hence its contents will be displayed\\n\")\n            table = PrettyTable([\"Folder Contents\"])\n            for i in jsondata:\n                table.add_row([i['name']])\n            print(table)\n\n# GET FOLLOWERS\n    if args.followers:\n        table = PrettyTable([\" FOLLOWERS \"])\n        table.align[\" FOLLOWERS \"] = \"l\"\n        for i in jsondata:\n            table.add_row([i['login']])\n        print(\"Number of followers:\"+str(len(jsondata)))\n        print(table)\n\n# GET FOLLOWING\n    if args.following:\n        table = PrettyTable([\" FOLLOWING \"])\n        table.align[\" FOLLOWING \"] = \"l\"\n        for i in jsondata:\n            table.add_row([i['login']])\n        print(\"Number of following:\"+str(len(jsondata)))\n        print(table)\n\n# GET CONTRIBUTORS\n    if args.contributors:\n        table = PrettyTable([\"\tCONTRIBUTORS \"])\n        table.align[\" CONTRIBUTORS \"] = \"l\"\n        for i in jsondata:\n            table.add_row([i['login']])\n        print(\"Number of contributors:\"+str(len(jsondata)))\n        print(table)", "response": "main function of the command line"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_capture(parser, token):\n    bits = token.split_contents()\n\n    # tokens\n    t_as = 'as'\n    t_silent = 'silent'\n    var = 'capture'\n    silent = False\n\n    num_bits = len(bits)\n    if len(bits) > 4:\n        raise TemplateSyntaxError(\"'capture' node supports '[as variable] [silent]' parameters.\")\n    elif num_bits == 4:\n        t_name, t_as, var, t_silent = bits\n        silent = True\n    elif num_bits == 3:\n        t_name, t_as, var = bits\n    elif num_bits == 2:\n        t_name, t_silent = bits\n        silent = True\n    else:\n        var = 'capture'\n        silent = False\n\n    if t_silent != 'silent' or t_as != 'as':\n        raise TemplateSyntaxError(\"'capture' node expects 'as variable' or 'silent' syntax.\")\n\n    nodelist = parser.parse(('endcapture',))\n    parser.delete_first_token()\n    return CaptureNode(nodelist, var, silent)", "response": "Capture the contents of a tag output."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _save_token_on_disk(self):\n        token = self._token.copy()\n\n        # Client secret is needed for token refreshing and isn't returned\n        # as a pared of OAuth token by default\n        token.update(client_secret=self._client_secret)\n\n        with codecs.open(config.TOKEN_FILE_PATH, 'w', 'utf8') as f:\n            json.dump(\n                token, f,\n                ensure_ascii=False,\n                sort_keys=True,\n                indent=4,\n            )", "response": "Helper function that saves the token on disk"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_oauth_token(self):\n        url = urljoin(self.api_url, '/oauth2/token')\n\n        oauth = OAuth2Session(\n            client_id=self._client_id,\n            redirect_uri=config.REDIRECT_URI,\n        )\n\n        token = oauth.fetch_token(\n            token_url=url,\n            code=self._auth_code,\n            client_secret=self._client_secret,\n        )\n\n        return token", "response": "Get Monzo access token via OAuth 2 grant type."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrefreshes Monzo OAuth 2 token.", "response": "def _refresh_oath_token(self):\n        \"\"\"\n        Refresh Monzo OAuth 2 token.\n\n        Official docs:\n            https://monzo.com/docs/#refreshing-access\n\n        :raises UnableToRefreshTokenException: when token couldn't be refreshed\n        \"\"\"\n        url = urljoin(self.api_url, '/oauth2/token')\n        data = {\n            'grant_type': 'refresh_token',\n            'client_id': self._client_id,\n            'client_secret': self._client_secret,\n            'refresh_token': self._token['refresh_token'],\n        }\n\n        token_response = requests.post(url, data=data)\n        token = token_response.json()\n\n        # Not ideal, but that's how Monzo API returns errors\n        if 'error' in token:\n            raise CantRefreshTokenError(\n                \"Unable to refresh the token: {}\".format(token)\n            )\n\n        self._token = token\n        self._save_token_on_disk()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting information about the access token.", "response": "def whoami(self):\n        \"\"\"\n        Get information about the access token.\n\n        Official docs:\n            https://monzo.com/docs/#authenticating-requests\n\n        :returns: access token details\n        :rtype: dict\n        \"\"\"\n        endpoint = '/ping/whoami'\n        response = self._get_response(\n            method='get', endpoint=endpoint,\n        )\n\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef accounts(self, refresh=False):\n        if not refresh and self._cached_accounts:\n            return self._cached_accounts\n\n        endpoint = '/accounts'\n        response = self._get_response(\n            method='get', endpoint=endpoint,\n        )\n\n        accounts_json = response.json()['accounts']\n        accounts = [MonzoAccount(data=account) for account in accounts_json]\n        self._cached_accounts = accounts\n\n        return accounts", "response": "Returns a list of Monzo accounts owned by the currently authorised user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef balance(self, account_id=None):\n        if not account_id:\n            if len(self.accounts()) == 1:\n                account_id = self.accounts()[0].id\n            else:\n                raise ValueError(\"You need to pass account ID\")\n\n        endpoint = '/balance'\n        response = self._get_response(\n            method='get', endpoint=endpoint,\n            params={\n                'account_id': account_id,\n            },\n        )\n\n        return MonzoBalance(data=response.json())", "response": "Returns balance information for a specific account."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of MonzoPot objects owned by the currently authorised user.", "response": "def pots(self, refresh=False):\n        \"\"\"\n        Returns a list of pots owned by the currently authorised user.\n\n        Official docs:\n            https://monzo.com/docs/#pots\n\n        :param refresh: decides if the pots information should be refreshed.\n        :type refresh: bool\n        :returns: list of Monzo pots\n        :rtype: list of MonzoPot\n        \"\"\"\n        if not refresh and self._cached_pots:\n            return self._cached_pots\n\n        endpoint = '/pots/listV1'\n        response = self._get_response(\n            method='get', endpoint=endpoint,\n        )\n\n        pots_json = response.json()['pots']\n        pots = [MonzoPot(data=pot) for pot in pots_json]\n        self._cached_pots = pots\n\n        return pots"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef transactions(self, account_id=None, reverse=True, limit=None):\n        if not account_id:\n            if len(self.accounts()) == 1:\n                account_id = self.accounts()[0].id\n            else:\n                raise ValueError(\"You need to pass account ID\")\n\n        endpoint = '/transactions'\n        response = self._get_response(\n            method='get', endpoint=endpoint,\n            params={\n                'account_id': account_id,\n            },\n        )\n\n        # The API does not allow reversing the list or limiting it, so to do\n        # the basic query of 'get the latest transaction' we need to always get\n        # all transactions and do the reversing and slicing in Python\n        # I send Monzo an email, we'll se how they'll respond\n        transactions = response.json()['transactions']\n        if reverse:\n            transactions.reverse()\n\n        if limit:\n            transactions = transactions[:limit]\n\n        return [MonzoTransaction(data=t) for t in transactions]", "response": "Returns a list of transactions on the user s account."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef transaction(self, transaction_id, expand_merchant=False):\n        endpoint = '/transactions/{}'.format(transaction_id)\n\n        data = dict()\n        if expand_merchant:\n            data['expand[]'] = 'merchant'\n\n        response = self._get_response(\n            method='get', endpoint=endpoint, params=data,\n        )\n\n        return MonzoTransaction(data=response.json()['transaction'])", "response": "Returns an individual Monzo transaction"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate auth string from credentials.", "response": "def get_auth_string(self):\n        \"\"\"Create auth string from credentials.\"\"\"\n        auth_info = '{}:{}'.format(self.sauce_username, self.sauce_access_key)\n        return base64.b64encode(auth_info.encode('utf-8')).decode('utf-8')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_user(self):\n        method = 'GET'\n        endpoint = '/rest/v1/users/{}'.format(self.client.sauce_username)\n        return self.client.request(method, endpoint)", "response": "Access basic account information."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_user(self, username, password, name, email):\n        method = 'POST'\n        endpoint = '/rest/v1/users/{}'.format(self.client.sauce_username)\n        body = json.dumps({'username': username, 'password': password,\n                           'name': name, 'email': email, })\n        return self.client.request(method, endpoint, body)", "response": "Create a sub account."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_concurrency(self):\n        method = 'GET'\n        endpoint = '/rest/v1.1/users/{}/concurrency'.format(\n            self.client.sauce_username)\n        return self.client.request(method, endpoint)", "response": "Check account concurrency limits."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_subaccounts(self):\n        method = 'GET'\n        endpoint = '/rest/v1/users/{}/list-subaccounts'.format(\n            self.client.sauce_username)\n        return self.client.request(method, endpoint)", "response": "Get a list of sub accounts associated with a parent account."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a list of sibling accounts associated with provided account.", "response": "def get_siblings(self):\n        \"\"\"Get a list of sibling accounts associated with provided account.\"\"\"\n        method = 'GET'\n        endpoint = '/rest/v1.1/users/{}/siblings'.format(\n            self.client.sauce_username)\n        return self.client.request(method, endpoint)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_subaccount_info(self):\n        method = 'GET'\n        endpoint = '/rest/v1/users/{}/subaccounts'.format(\n            self.client.sauce_username)\n        return self.client.request(method, endpoint)", "response": "Get information about a sub account."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef change_access_key(self):\n        method = 'POST'\n        endpoint = '/rest/v1/users/{}/accesskey/change'.format(\n            self.client.sauce_username)\n        return self.client.request(method, endpoint)", "response": "Change the access key of your account."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the current activity for the current user.", "response": "def get_activity(self):\n        \"\"\"Check account concurrency limits.\"\"\"\n        method = 'GET'\n        endpoint = '/rest/v1/{}/activity'.format(self.client.sauce_username)\n        return self.client.request(method, endpoint)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_usage(self, start=None, end=None):\n        method = 'GET'\n        endpoint = '/rest/v1/users/{}/usage'.format(self.client.sauce_username)\n        data = {}\n        if start:\n            data['start'] = start\n        if end:\n            data['end'] = end\n        if data:\n            endpoint = '?'.join([endpoint, urlencode(data)])\n        return self.client.request(method, endpoint)", "response": "Get historical account usage data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a list of objects describing all the OS and browser platforms available on Sauce Labs.", "response": "def get_platforms(self, automation_api='all'):\n        \"\"\"Get a list of objects describing all the OS and browser platforms\n        currently supported on Sauce Labs.\"\"\"\n        method = 'GET'\n        endpoint = '/rest/v1/info/platforms/{}'.format(automation_api)\n        return self.client.request(method, endpoint)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlist all jobs belonging to a specific user.", "response": "def get_jobs(self, full=None, limit=None, skip=None, start=None, end=None,\n                 output_format=None):\n        \"\"\"List jobs belonging to a specific user.\"\"\"\n        method = 'GET'\n        endpoint = '/rest/v1/{}/jobs'.format(self.client.sauce_username)\n        data = {}\n        if full is not None:\n            data['full'] = full\n        if limit is not None:\n            data['limit'] = limit\n        if skip is not None:\n            data['skip'] = skip\n        if start is not None:\n            data['from'] = start\n        if end is not None:\n            data['to'] = end\n        if output_format is not None:\n            data['format'] = output_format\n        if data:\n            endpoint = '?'.join([endpoint, urlencode(data)])\n        return self.client.request(method, endpoint)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_job(self, job_id, build=None, custom_data=None,\n                   name=None, passed=None, public=None, tags=None):\n        \"\"\"Edit an existing job.\"\"\"\n        method = 'PUT'\n        endpoint = '/rest/v1/{}/jobs/{}'.format(self.client.sauce_username,\n                                                job_id)\n        data = {}\n        if build is not None:\n            data['build'] = build\n        if custom_data is not None:\n            data['custom-data'] = custom_data\n        if name is not None:\n            data['name'] = name\n        if passed is not None:\n            data['passed'] = passed\n        if public is not None:\n            data['public'] = public\n        if tags is not None:\n            data['tags'] = tags\n        body = json.dumps(data)\n        return self.client.request(method, endpoint, body=body)", "response": "Edit an existing job."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stop_job(self, job_id):\n        method = 'PUT'\n        endpoint = '/rest/v1/{}/jobs/{}/stop'.format(\n            self.client.sauce_username, job_id)\n        return self.client.request(method, endpoint)", "response": "Terminates a running job."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget details about the static assets collected for a specific job.", "response": "def get_job_asset_url(self, job_id, filename):\n        \"\"\"Get details about the static assets collected for a specific job.\"\"\"\n        return 'https://saucelabs.com/rest/v1/{}/jobs/{}/assets/{}'.format(\n            self.client.sauce_username, job_id, filename)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_auth_token(self, job_id, date_range=None):\n        key = '{}:{}'.format(self.client.sauce_username,\n                             self.client.sauce_access_key)\n        if date_range:\n            key = '{}:{}'.format(key, date_range)\n        return hmac.new(key.encode('utf-8'), job_id.encode('utf-8'),\n                        md5).hexdigest()", "response": "Get an auth token to access protected job resources."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nuploading a file to the temporary sauce storage.", "response": "def upload_file(self, filepath, overwrite=True):\n        \"\"\"Uploads a file to the temporary sauce storage.\"\"\"\n        method = 'POST'\n        filename = os.path.split(filepath)[1]\n        endpoint = '/rest/v1/storage/{}/{}?overwrite={}'.format(\n            self.client.sauce_username, filename, \"true\" if overwrite else \"false\")\n        with open(filepath, 'rb') as filehandle:\n            body = filehandle.read()\n        return self.client.request(method, endpoint, body,\n                                   content_type='application/octet-stream')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks which files are in your temporary storage.", "response": "def get_stored_files(self):\n        \"\"\"Check which files are in your temporary storage.\"\"\"\n        method = 'GET'\n        endpoint = '/rest/v1/storage/{}'.format(self.client.sauce_username)\n        return self.client.request(method, endpoint)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves all running tunnels for a specific user.", "response": "def get_tunnels(self):\n        \"\"\"Retrieves all running tunnels for a specific user.\"\"\"\n        method = 'GET'\n        endpoint = '/rest/v1/{}/tunnels'.format(self.client.sauce_username)\n        return self.client.request(method, endpoint)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_tunnel(self, tunnel_id):\n        method = 'GET'\n        endpoint = '/rest/v1/{}/tunnels/{}'.format(\n            self.client.sauce_username, tunnel_id)\n        return self.client.request(method, endpoint)", "response": "Get information for a tunnel given its ID."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying a patch to the base base.", "response": "def apply(patch):\n    \"\"\"Apply a patch.\n\n    The patch's :attr:`~Patch.obj` attribute is injected into the patch's\n    :attr:`~Patch.destination` under the patch's :attr:`~Patch.name`.\n\n    This is a wrapper around calling\n    ``setattr(patch.destination, patch.name, patch.obj)``.\n\n    Parameters\n    ----------\n    patch : gorilla.Patch\n        Patch.\n\n    Raises\n    ------\n    RuntimeError\n        Overwriting an existing attribute is not allowed when the setting\n        :attr:`Settings.allow_hit` is set to ``True``.\n\n    Note\n    ----\n    If both the attributes :attr:`Settings.allow_hit` and\n    :attr:`Settings.store_hit` are ``True`` but that the target attribute seems\n    to have already been stored, then it won't be stored again to avoid losing\n    the original attribute that was stored the first time around.\n    \"\"\"\n    settings = Settings() if patch.settings is None else patch.settings\n\n    # When a hit occurs due to an attribute at the destination already existing\n    # with the patch's name, the existing attribute is referred to as 'target'.\n    try:\n        target = get_attribute(patch.destination, patch.name)\n    except AttributeError:\n        pass\n    else:\n        if not settings.allow_hit:\n            raise RuntimeError(\n                \"An attribute named '%s' already exists at the destination \"\n                \"'%s'. Set a different name through the patch object to avoid \"\n                \"a name clash or set the setting 'allow_hit' to True to \"\n                \"overwrite the attribute. In the latter case, it is \"\n                \"recommended to also set the 'store_hit' setting to True in \"\n                \"order to store the original attribute under a different \"\n                \"name so it can still be accessed.\"\n                % (patch.name, patch.destination.__name__))\n\n        if settings.store_hit:\n            original_name = _ORIGINAL_NAME % (patch.name,)\n            if not hasattr(patch.destination, original_name):\n                setattr(patch.destination, original_name, target)\n\n    setattr(patch.destination, patch.name, patch.obj)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef patch(destination, name=None, settings=None):\n    def decorator(wrapped):\n        base = _get_base(wrapped)\n        name_ = base.__name__ if name is None else name\n        settings_ = copy.deepcopy(settings)\n        patch = Patch(destination, name_, wrapped, settings=settings_)\n        data = get_decorator_data(base, set_default=True)\n        data.patches.append(patch)\n        return wrapped\n\n    return decorator", "response": "Decorator to create a patch."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef patches(destination, settings=None, traverse_bases=True,\n            filter=default_filter, recursive=True, use_decorators=True):\n    \"\"\"Decorator to create a patch for each member of a module or a class.\n\n    Parameters\n    ----------\n    destination : object\n        Patch destination.\n    settings : gorilla.Settings\n        Settings.\n    traverse_bases : bool\n        If the object is a class, the base classes are also traversed.\n    filter : function\n        Attributes for which the function returns ``False`` are skipped. The\n        function needs to define two parameters: ``name``, the attribute name,\n        and ``obj``, the attribute value. If ``None``, no attribute is skipped.\n    recursive : bool\n        If ``True``, and a hit occurs due to an attribute at the destination\n        already existing with the given name, and both the member and the\n        target attributes are classes, then instead of creating a patch\n        directly with the member attribute value as is, a patch for each of its\n        own members is created with the target as new destination.\n    use_decorators : bool\n        Allows to take any modifier decorator into consideration to allow for\n        more granular customizations.\n\n    Returns\n    -------\n    object\n        The decorated object.\n\n    Note\n    ----\n    A 'target' differs from a 'destination' in that a target represents an\n    existing attribute at the destination about to be hit by a patch.\n\n    See Also\n    --------\n    :class:`Patch`, :func:`create_patches`.\n    \"\"\"\n    def decorator(wrapped):\n        settings_ = copy.deepcopy(settings)\n        patches = create_patches(\n            destination, wrapped, settings=settings_,\n            traverse_bases=traverse_bases, filter=filter, recursive=recursive,\n            use_decorators=use_decorators)\n        data = get_decorator_data(_get_base(wrapped), set_default=True)\n        data.patches.extend(patches)\n        return wrapped\n\n    return decorator", "response": "Decorator to create a patch for each member of a module or class."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef settings(**kwargs):\n    def decorator(wrapped):\n        data = get_decorator_data(_get_base(wrapped), set_default=True)\n        data.override.setdefault('settings', {}).update(kwargs)\n        return wrapped\n\n    return decorator", "response": "Decorator to update a patch s settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filter(value):\n    def decorator(wrapped):\n        data = get_decorator_data(_get_base(wrapped), set_default=True)\n        data.filter = value\n        return wrapped\n\n    return decorator", "response": "Modifier decorator to force the inclusion or exclusion of an attribute."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_patches(destination, root, settings=None, traverse_bases=True,\n                   filter=default_filter, recursive=True, use_decorators=True):\n    \"\"\"Create a patch for each member of a module or a class.\n\n    Parameters\n    ----------\n    destination : object\n        Patch destination.\n    root : object\n        Root object, either a module or a class.\n    settings : gorilla.Settings\n        Settings.\n    traverse_bases : bool\n        If the object is a class, the base classes are also traversed.\n    filter : function\n        Attributes for which the function returns ``False`` are skipped. The\n        function needs to define two parameters: ``name``, the attribute name,\n        and ``obj``, the attribute value. If ``None``, no attribute is skipped.\n    recursive : bool\n        If ``True``, and a hit occurs due to an attribute at the destination\n        already existing with the given name, and both the member and the\n        target attributes are classes, then instead of creating a patch\n        directly with the member attribute value as is, a patch for each of its\n        own members is created with the target as new destination.\n    use_decorators : bool\n        ``True`` to take any modifier decorator into consideration to allow for\n        more granular customizations.\n\n    Returns\n    -------\n    list of gorilla.Patch\n        The patches.\n\n    Note\n    ----\n    A 'target' differs from a 'destination' in that a target represents an\n    existing attribute at the destination about to be hit by a patch.\n\n    See Also\n    --------\n    :func:`patches`.\n    \"\"\"\n    if filter is None:\n        filter = _true\n\n    out = []\n    root_patch = Patch(destination, '', root, settings=settings)\n    stack = collections.deque((root_patch,))\n    while stack:\n        parent_patch = stack.popleft()\n        members = _get_members(parent_patch.obj, traverse_bases=traverse_bases,\n                               filter=None, recursive=False)\n        for name, value in members:\n            patch = Patch(parent_patch.destination, name, value,\n                          settings=copy.deepcopy(parent_patch.settings))\n            if use_decorators:\n                base = _get_base(value)\n                decorator_data = get_decorator_data(base)\n                filter_override = (None if decorator_data is None\n                                   else decorator_data.filter)\n                if ((filter_override is None and not filter(name, value))\n                        or filter_override is False):\n                    continue\n\n                if decorator_data is not None:\n                    patch._update(**decorator_data.override)\n            elif not filter(name, value):\n                continue\n\n            if recursive and isinstance(value, _CLASS_TYPES):\n                try:\n                    target = get_attribute(patch.destination, patch.name)\n                except AttributeError:\n                    pass\n                else:\n                    if isinstance(target, _CLASS_TYPES):\n                        patch.destination = target\n                        stack.append(patch)\n                        continue\n\n            out.append(patch)\n\n    return out", "response": "Create a list of patches for each member of a module or a class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_patches(modules, recursive=True):\n    out = []\n    modules = (module\n               for package in modules\n               for module in _module_iterator(package, recursive=recursive))\n    for module in modules:\n        members = _get_members(module, filter=None)\n        for _, value in members:\n            base = _get_base(value)\n            decorator_data = get_decorator_data(base)\n            if decorator_data is None:\n                continue\n\n            out.extend(decorator_data.patches)\n\n    return out", "response": "Find all the patches created through decorators."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_attribute(obj, name):\n    objs = inspect.getmro(obj) if isinstance(obj, _CLASS_TYPES) else [obj]\n    for obj_ in objs:\n        try:\n            return object.__getattribute__(obj_, name)\n        except AttributeError:\n            pass\n\n    raise AttributeError(\"'%s' object has no attribute '%s'\"\n                         % (type(obj), name))", "response": "Get an attribute while bypassing the descriptor protocol."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving any decorator data from an object.", "response": "def get_decorator_data(obj, set_default=False):\n    \"\"\"Retrieve any decorator data from an object.\n\n    Parameters\n    ----------\n    obj : object\n        Object.\n    set_default : bool\n        If no data is found, a default one is set on the object and returned,\n        otherwise ``None`` is returned.\n\n    Returns\n    -------\n    gorilla.DecoratorData\n        The decorator data or ``None``.\n    \"\"\"\n    if isinstance(obj, _CLASS_TYPES):\n        datas = getattr(obj, _DECORATOR_DATA, {})\n        data = datas.setdefault(obj, None)\n        if data is None and set_default:\n            data = DecoratorData()\n            datas[obj] = data\n            setattr(obj, _DECORATOR_DATA, datas)\n    else:\n        data = getattr(obj, _DECORATOR_DATA, None)\n        if data is None and set_default:\n            data = DecoratorData()\n            setattr(obj, _DECORATOR_DATA, data)\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_base(obj):\n    if hasattr(obj, '__func__'):\n        obj = obj.__func__\n    elif isinstance(obj, property):\n        obj = obj.fget\n    elif isinstance(obj, (classmethod, staticmethod)):\n        # Fallback for Python < 2.7 back when no `__func__` attribute\n        # was defined for those descriptors.\n        obj = obj.__get__(None, object)\n    else:\n        return obj\n\n    return _get_base(obj)", "response": "Unwrap decorators to retrieve the base object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_members(obj, traverse_bases=True, filter=default_filter,\n                 recursive=True):\n    \"\"\"Retrieve the member attributes of a module or a class.\n\n    The descriptor protocol is bypassed.\"\"\"\n    if filter is None:\n        filter = _true\n\n    out = []\n    stack = collections.deque((obj,))\n    while stack:\n        obj = stack.popleft()\n        if traverse_bases and isinstance(obj, _CLASS_TYPES):\n            roots = [base for base in inspect.getmro(obj)\n                     if base not in (type, object)]\n        else:\n            roots = [obj]\n\n        members = []\n        seen = set()\n        for root in roots:\n            for name, value in _iteritems(getattr(root, '__dict__', {})):\n                if name not in seen and filter(name, value):\n                    members.append((name, value))\n\n                seen.add(name)\n\n        members = sorted(members)\n        for _, value in members:\n            if recursive and isinstance(value, _CLASS_TYPES):\n                stack.append(value)\n\n        out.extend(members)\n\n    return out", "response": "Retrieve the member attributes of a module or a class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _update(self, **kwargs):\n        for key, value in _iteritems(kwargs):\n            if key == 'settings':\n                if isinstance(value, dict):\n                    if self.settings is None:\n                        self.settings = Settings(**value)\n                    else:\n                        self.settings._update(**value)\n                else:\n                    self.settings = copy.deepcopy(value)\n            else:\n                setattr(self, key, value)", "response": "Update some attributes.\n\n        If a 'settings' attribute is passed as a dict, then it updates the\n        content of the settings, if any, instead of completely overwriting it."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_collection(self, path):\n        while True:\n            items = self.get(path)\n            req = self.req\n            for item in items:\n                yield item\n            if req.links and req.links['next'] and\\\n                    req.links['next']['rel'] == 'next':\n                path = req.links['next']['url']\n            else:\n                break", "response": "To get pagewise data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_projects_search(self, searchstring):\n        log.debug('List all projects with: %s' % searchstring)\n        return self.collection('projects/search/%s.json' %\n                               quote_plus(searchstring))", "response": "List projects with searchstring."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates a project with the given data.", "response": "def update_project(self, ID, data):\n        \"\"\"Update a project.\"\"\"\n        # http://teampasswordmanager.com/docs/api-projects/#update_project\n        log.info('Update project %s with %s' % (ID, data))\n        self.put('projects/%s.json' % ID, data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nchange parent of project.", "response": "def change_parent_of_project(self, ID, NewParrentID):\n        \"\"\"Change parent of project.\"\"\"\n        # http://teampasswordmanager.com/docs/api-projects/#change_parent\n        log.info('Change parrent for project %s to %s' % (ID, NewParrentID))\n        data = {'parent_id': NewParrentID}\n        self.put('projects/%s/change_parent.json' % ID, data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating security of project.", "response": "def update_security_of_project(self, ID, data):\n        \"\"\"Update security of project.\"\"\"\n        # http://teampasswordmanager.com/docs/api-projects/#update_project_security\n        log.info('Update project %s security %s' % (ID, data))\n        self.put('projects/%s/security.json' % ID, data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_passwords_search(self, searchstring):\n        log.debug('List all passwords with: %s' % searchstring)\n        return self.collection('passwords/search/%s.json' %\n                               quote_plus(searchstring))", "response": "List all passwords with searchstring."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate a password with the given data.", "response": "def update_password(self, ID, data):\n        \"\"\"Update a password.\"\"\"\n        # http://teampasswordmanager.com/docs/api-passwords/#update_password\n        log.info('Update Password %s with %s' % (ID, data))\n        self.put('passwords/%s.json' % ID, data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_security_of_password(self, ID, data):\n        # http://teampasswordmanager.com/docs/api-passwords/#update_security_password\n        log.info('Update security of password %s with %s' % (ID, data))\n        self.put('passwords/%s/security.json' % ID, data)", "response": "Update security of a password."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate custom fields definitions of a password.", "response": "def update_custom_fields_of_password(self, ID, data):\n        \"\"\"Update custom fields definitions of a password.\"\"\"\n        # http://teampasswordmanager.com/docs/api-passwords/#update_cf_password\n        log.info('Update custom fields of password %s with %s' % (ID, data))\n        self.put('passwords/%s/custom_fields.json' % ID, data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist my passwords with searchstring.", "response": "def list_mypasswords_search(self, searchstring):\n        \"\"\"List my passwords with searchstring.\"\"\"\n        # http://teampasswordmanager.com/docs/api-my-passwords/#list_passwords\n        log.debug('List MyPasswords with %s' % searchstring)\n        return self.collection('my_passwords/search/%s.json' %\n                               quote_plus(searchstring))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating my password with data.", "response": "def update_mypassword(self, ID, data):\n        \"\"\"Update my password.\"\"\"\n        # http://teampasswordmanager.com/docs/api-my-passwords/#update_password\n        log.info('Update MyPassword %s with %s' % (ID, data))\n        self.put('my_passwords/%s.json' % ID, data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate a User s metadata.", "response": "def update_user(self, ID, data):\n        \"\"\"Update a User.\"\"\"\n        # http://teampasswordmanager.com/docs/api-users/#update_user\n        log.info('Update user %s with %s' % (ID, data))\n        self.put('users/%s.json' % ID, data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchanges password of a User.", "response": "def change_user_password(self, ID, data):\n        \"\"\"Change password of a User.\"\"\"\n        # http://teampasswordmanager.com/docs/api-users/#change_password\n        log.info('Change user %s password' % ID)\n        self.put('users/%s/change_password.json' % ID, data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convert_user_to_ldap(self, ID, DN):\n        # http://teampasswordmanager.com/docs/api-users/#convert_to_ldap\n        data = {'login_dn': DN}\n        log.info('Convert User %s to LDAP DN %s' % (ID, DN))\n        self.put('users/%s/convert_to_ldap.json' % ID, data)", "response": "Convert a normal user to an LDAP user."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates a Group with the given data.", "response": "def update_group(self, ID, data):\n        \"\"\"Update a Group.\"\"\"\n        # http://teampasswordmanager.com/docs/api-groups/#update_group\n        log.info('Update group %s with %s' % (ID, data))\n        self.put('groups/%s.json' % ID, data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_user_to_group(self, GroupID, UserID):\n        # http://teampasswordmanager.com/docs/api-groups/#add_user\n        log.info('Add User %s to Group %s' % (UserID, GroupID))\n        self.put('groups/%s/add_user/%s.json' % (GroupID, UserID))", "response": "Add a user to a group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete a user from a group.", "response": "def delete_user_from_group(self, GroupID, UserID):\n        \"\"\"Delete a user from a group.\"\"\"\n        # http://teampasswordmanager.com/docs/api-groups/#del_user\n        log.info('Delete user %s from group %s' % (UserID, GroupID))\n        self.put('groups/%s/delete_user/%s.json' % (GroupID, UserID))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef up_to_date(self):\n        VersionInfo = self.get_latest_version()\n        CurrentVersion = VersionInfo.get('version')\n        LatestVersion = VersionInfo.get('latest_version')\n        if  CurrentVersion == LatestVersion:\n            log.info('TeamPasswordManager is up-to-date!')\n            log.debug('Current Version: {} Latest Version: {}'.format(LatestVersion, LatestVersion))\n            return True\n        else:\n            log.warning('TeamPasswordManager is not up-to-date!')\n            log.debug('Current Version: {} Latest Version: {}'.format(LatestVersion, LatestVersion))\n            return False", "response": "Check if Team Password Manager is up to date."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\niterating over the date values in a list of data sets.", "response": "def iterate_date_values(d, start_date=None, stop_date=None, default=0):\n    \"\"\"\n    Convert (date, value) sorted lists into contiguous value-per-day data sets. Great for sparklines.\n\n    Example::\n\n        [(datetime.date(2011, 1, 1), 1), (datetime.date(2011, 1, 4), 2)] -> [1, 0, 0, 2]\n\n    \"\"\"\n    dataiter = iter(d)\n    cur_day, cur_val = next(dataiter)\n\n    start_date = start_date or cur_day\n\n    while cur_day < start_date:\n        cur_day, cur_val = next(dataiter)\n\n    for d in iterate_date(start_date, stop_date):\n        if d != cur_day:\n            yield default\n            continue\n\n        yield cur_val\n        try:\n            cur_day, cur_val = next(dataiter)\n        except StopIteration:\n            if not stop_date:\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef truncate_datetime(t, resolution):\n\n    resolutions = ['year', 'month', 'day', 'hour', 'minute', 'second', 'microsecond']\n    if resolution not in resolutions:\n        raise KeyError(\"Resolution is not valid: {0}\".format(resolution))\n\n    args = []\n    for r in resolutions:\n        args += [getattr(t, r)]\n        if r == resolution:\n            break\n\n    return datetime.datetime(*args)", "response": "Given a datetime t and a resolution truncate the precision beyond the given resolution."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_timezone(dt, timezone):\n    if dt.tzinfo is None:\n        dt = dt.replace(tzinfo=_UTC)\n    return timezone.normalize(dt.astimezone(timezone))", "response": "Return an aware datetime which is dt converted to timezone timezone."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a naive datetime object for the given timezone.", "response": "def now(timezone=None):\n    \"\"\"\n    Return a naive datetime object for the given ``timezone``. A ``timezone``\n    is any pytz- like or datetime.tzinfo-like timezone object. If no timezone\n    is given, then UTC is assumed.\n\n    This method is best used with pytz installed::\n\n        pip install pytz\n    \"\"\"\n    d = datetime.datetime.utcnow()\n    if not timezone:\n        return d\n\n    return to_timezone(d, timezone).replace(tzinfo=None)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nenumerate all the results of a SQLAlchemy query object q and yield individual results in batches of size limit.", "response": "def enumerate_query_by_limit(q, limit=1000):\n    \"\"\"\n    Enumerate over SQLAlchemy query object ``q`` and yield individual results\n    fetched in batches of size ``limit`` using SQL LIMIT and OFFSET.\n    \"\"\"\n    for offset in count(0, limit):\n        r = q.offset(offset).limit(limit).all()\n\n        for row in r:\n            yield row\n\n        if len(r) < limit:\n            break"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates a dictionary of data against the provided schema.", "response": "def validate_many(d, schema):\n    \"\"\"Validate a dictionary of data against the provided schema.\n\n    Returns a list of values positioned in the same order as given in ``schema``, each\n    value is validated with the corresponding validator. Raises formencode.Invalid if\n    validation failed.\n\n    Similar to get_many but using formencode validation.\n\n    :param d: A dictionary of data to read values from.\n    :param schema: A list of (key, validator) tuples. The key will be used to fetch\n        a value from ``d`` and the validator will be applied to it.\n\n    Example::\n\n        from formencode import validators\n\n        email, password, password_confirm = validate_many(request.params, [\n            ('email', validators.Email(not_empty=True)),\n            ('password', validators.String(min=4)),\n            ('password_confirm', validators.String(min=4)),\n        ])\n    \"\"\"\n    return [validator.to_python(d.get(key), state=key) for key,validator in schema]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nensure that each argument in the list of arguments is hashable. Raises descriptive TypeError otherwise.", "response": "def assert_hashable(*args, **kw):\n    \"\"\" Verify that each argument is hashable.\n\n    Passes silently if successful. Raises descriptive TypeError otherwise.\n\n    Example::\n\n        >>> assert_hashable(1, 'foo', bar='baz')\n        >>> assert_hashable(1, [], baz='baz')\n        Traceback (most recent call last):\n          ...\n        TypeError: Argument in position 1 is not hashable: []\n        >>> assert_hashable(1, 'foo', bar=[])\n        Traceback (most recent call last):\n          ...\n        TypeError: Keyword argument 'bar' is not hashable: []\n    \"\"\"\n    try:\n        for i, arg in enumerate(args):\n            hash(arg)\n    except TypeError:\n        raise TypeError('Argument in position %d is not hashable: %r' % (i, arg))\n    try:\n        for key, val in iterate_items(kw):\n            hash(val)\n    except TypeError:\n        raise TypeError('Keyword argument %r is not hashable: %r' % (key, val))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef memoized_method(method=None, cache_factory=None):\n\n    if method is None:\n        return lambda f: memoized_method(f, cache_factory=cache_factory)\n\n    cache_factory = cache_factory or dict\n\n    @wraps(method)\n    def memoized_method_property(self):\n        cache = cache_factory()\n        cache_attr = \"_%s_cache\" %(method.__name__, )\n        setattr(self, cache_attr, cache)\n        result = partial(\n            _memoized_call,\n            partial(method, self),\n            cache\n        )\n        result.memoize_cache = cache\n        return result\n    return memoized_property(memoized_method_property)", "response": "Memoize a class s method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef deprecated(message, exception=PendingDeprecationWarning):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            warnings.warn(message, exception, stacklevel=2)\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator", "response": "Decorator for deprecated functions."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naggregates iterator values into buckets based on how frequently the values appear.", "response": "def groupby_count(i, key=None, force_keys=None):\n    \"\"\" Aggregate iterator values into buckets based on how frequently the\n    values appear.\n\n    Example::\n\n        >>> list(groupby_count([1, 1, 1, 2, 3]))\n        [(1, 3), (2, 1), (3, 1)]\n    \"\"\"\n    counter = defaultdict(lambda: 0)\n    if not key:\n        key = lambda o: o\n\n    for k in i:\n        counter[key(k)] += 1\n\n    if force_keys:\n        for k in force_keys:\n            counter[k] += 0\n\n    return counter.items()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_iterable(maybe_iter, unless=(string_types, dict)):\n    try:\n        iter(maybe_iter)\n    except TypeError:\n        return False\n    return not isinstance(maybe_iter, unless)", "response": "Return whether maybe_iter is an iterable unless it s an instance of one\n    of the base class or tuple of base classes given in unless."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iterate_items(dictish):\n    if hasattr(dictish, 'iteritems'):\n        return dictish.iteritems()\n    if hasattr(dictish, 'items'):\n        return dictish.items()\n    return dictish", "response": "Return a consistent ( key value iterable on dict - like objects and\n    including lists of tuple pairs."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\niterates over an iterator i in size chunks yield chunks.", "response": "def iterate_chunks(i, size=10):\n    \"\"\"\n    Iterate over an iterator ``i`` in ``size`` chunks, yield chunks.\n    Similar to pagination.\n\n    Example::\n\n        >>> list(iterate_chunks([1, 2, 3, 4], size=2))\n        [[1, 2], [3, 4]]\n    \"\"\"\n    accumulator = []\n\n    for n, i in enumerate(i):\n        accumulator.append(i)\n        if (n+1) % size == 0:\n            yield accumulator\n            accumulator = []\n\n    if accumulator:\n        yield accumulator"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef listify(fn=None, wrapper=list):\n    def listify_return(fn):\n        @wraps(fn)\n        def listify_helper(*args, **kw):\n            return wrapper(fn(*args, **kw))\n        return listify_helper\n    if fn is None:\n        return listify_return\n    return listify_return(fn)", "response": "A function which returns a list of items in the alphabetical order."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if o is a subclass of bases.", "response": "def is_subclass(o, bases):\n    \"\"\"\n    Similar to the ``issubclass`` builtin, but does not raise a ``TypeError``\n    if either ``o`` or ``bases`` is not an instance of ``type``.\n\n    Example::\n\n        >>> is_subclass(IOError, Exception)\n        True\n        >>> is_subclass(Exception, None)\n        False\n        >>> is_subclass(None, Exception)\n        False\n        >>> is_subclass(IOError, (None, Exception))\n        True\n        >>> is_subclass(Exception, (None, 42))\n        False\n    \"\"\"\n    try:\n        return _issubclass(o, bases)\n    except TypeError:\n        pass\n\n    if not isinstance(o, type):\n        return False\n    if not isinstance(bases, tuple):\n        return False\n\n    bases = tuple(b for b in bases if isinstance(b, type))\n    return _issubclass(o, bases)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_many(d, required=[], optional=[], one_of=[]):\n    d = d or {}\n    r = [d[k] for k in required]\n    r += [d.get(k)for k in optional]\n\n    if one_of:\n        for k in (k for k in one_of if k in d):\n            return r + [d[k]]\n\n        raise KeyError(\"Missing a one_of value.\")\n\n    return r", "response": "Returns a predictable number of elements out of d in a list for auto - expanding."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a random string of given length and alphabet.", "response": "def random_string(length=6, alphabet=string.ascii_letters+string.digits):\n    \"\"\"\n    Return a random string of given length and alphabet.\n\n    Default alphabet is url-friendly (base62).\n    \"\"\"\n    return ''.join([random.choice(alphabet) for i in xrange(length)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef number_to_string(n, alphabet):\n    result = ''\n    base = len(alphabet)\n    current = int(n)\n    if current < 0:\n        raise ValueError(\"invalid n (must be non-negative): %s\", n)\n    while current:\n        result = alphabet[current % base] + result\n        current = current // base\n\n    return result", "response": "Given an integer n convert it to a string composed of\n    the given alphabet mapping where the position of each element in alphabet is its radix value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a string s convert it to an integer composed of the given alphabet mapping where the position of each element in alphabet is the radix value of the string s.", "response": "def string_to_number(s, alphabet):\n    \"\"\"\n    Given a string ``s``, convert it to an integer composed of the given\n    ``alphabet`` mapping, where the position of each element in ``alphabet`` is\n    its radix value.\n\n    Examples::\n\n        >>> string_to_number('101111000110000101001110', '01')\n        12345678\n\n        >>> string_to_number('babbbbaaabbaaaababaabbba', 'ab')\n        12345678\n\n        >>> string_to_number('ZXP0', string.ascii_letters + string.digits)\n        12345678\n\n    \"\"\"\n    base = len(alphabet)\n    inverse_alphabet = dict(zip(alphabet, xrange(0, base)))\n    n = 0\n    exp = 0\n    for i in reversed(s):\n        n += inverse_alphabet[i] * (base ** exp)\n        exp += 1\n\n    return n"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bytes_to_number(b, endian='big'):\n    if endian == 'big':\n        b = reversed(b)\n\n    n = 0\n    for i, ch in enumerate(bytearray(b)):\n        n ^= ch << i * 8\n\n    return n", "response": "Convert a string or bytearray to a number."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts an integer to a corresponding string of bytes.", "response": "def number_to_bytes(n, endian='big'):\n    \"\"\"\n    Convert an integer to a corresponding string of bytes..\n\n    :param n:\n        Integer to convert.\n\n    :param endian:\n        Byte order to convert into ('big' or 'little' endian-ness, default\n        'big')\n\n    Assumes bytes are 8 bits.\n\n    This is a special-case version of number_to_string with a full base-256\n    ASCII alphabet. It is the reverse of ``bytes_to_number(b)``.\n\n    Examples::\n\n        >>> r(number_to_bytes(42))\n        b'*'\n        >>> r(number_to_bytes(255))\n        b'\\\\xff'\n        >>> r(number_to_bytes(256))\n        b'\\\\x01\\\\x00'\n        >>> r(number_to_bytes(256, endian='little'))\n        b'\\\\x00\\\\x01'\n    \"\"\"\n    res = []\n    while n:\n        n, ch = divmod(n, 256)\n        if PY3:\n            res.append(ch)\n        else:\n            res.append(chr(ch))\n\n    if endian == 'big':\n        res.reverse()\n\n    if PY3:\n        return bytes(res)\n    else:\n        return ''.join(res)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_str(obj, encoding='utf-8', **encode_args):\n    # Note: On py3, ``b'x'.__str__()`` returns ``\"b'x'\"``, so we need to do the\n    # explicit check first.\n    if isinstance(obj, binary_type):\n        return obj\n\n    # We coerce to unicode if '__unicode__' is available because there is no\n    # way to specify encoding when calling ``str(obj)``, so, eg,\n    # ``str(Exception(u'\\u1234'))`` will explode.\n    if isinstance(obj, text_type) or hasattr(obj, text_type_magicmethod):\n        # Note: unicode(u'foo') is O(1) (by experimentation)\n        return text_type(obj).encode(encoding, **encode_args)\n\n    return binary_type(obj)", "response": "r Converts obj into a string if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting input string into a float. If conversion fails return default.", "response": "def to_float(s, default=0.0, allow_nan=False):\n    \"\"\"\n    Return input converted into a float. If failed, then return ``default``.\n\n    Note that, by default, ``allow_nan=False``, so ``to_float`` will not return\n    ``nan``, ``inf``, or ``-inf``.\n\n    Examples::\n\n        >>> to_float('1.5')\n        1.5\n        >>> to_float(1)\n        1.0\n        >>> to_float('')\n        0.0\n        >>> to_float('nan')\n        0.0\n        >>> to_float('inf')\n        0.0\n        >>> to_float('-inf', allow_nan=True)\n        -inf\n        >>> to_float(None)\n        0.0\n        >>> to_float(0, default='Empty')\n        0.0\n        >>> to_float(None, default='Empty')\n        'Empty'\n    \"\"\"\n    try:\n        f = float(s)\n    except (TypeError, ValueError):\n        return default\n    if not allow_nan:\n        if f != f or f in _infs:\n            return default\n    return f"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format_int(n, singular=_Default, plural=_Default):\n    n = int(n)\n\n    if singular in (None, _Default):\n        if plural is _Default:\n            plural = None\n\n        singular = u'{:,}'\n\n    elif plural is _Default:\n        plural = singular + u's'\n\n    if n == 1 or not plural:\n        return singular.format(n)\n\n    return plural.format(n)", "response": "Return a string representation of the given integer n."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dollars_to_cents(s, allow_negative=False):\n    # TODO: Implement cents_to_dollars\n    if not s:\n        return\n\n    if isinstance(s, string_types):\n        s = ''.join(RE_NUMBER.findall(s))\n\n    dollars = int(round(float(s) * 100))\n    if not allow_negative and dollars < 0:\n        raise ValueError('Negative values not permitted.')\n\n    return dollars", "response": "Converts a string or integer representing dollars to an integer of cents."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef slugify(s, delimiter='-'):\n    s = unicodedata.normalize('NFKD', to_unicode(s)).encode('ascii', 'ignore').decode('ascii')\n    return RE_SLUG.sub(delimiter, s).strip(delimiter).lower()", "response": "Normalize s into ASCII and replace non - word characters with delimiter."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a string that can be used as a parameter for cache - busting URLs.", "response": "def get_cache_buster(src_path, method='importtime'):\n    \"\"\" Return a string that can be used as a parameter for cache-busting URLs\n    for this asset.\n\n    :param src_path:\n        Filesystem path to the file we're generating a cache-busting value for.\n\n    :param method:\n        Method for cache-busting. Supported values: importtime, mtime, md5\n        The default is 'importtime', because it requires the least processing.\n\n    Note that the mtime and md5 cache busting methods' results are cached on\n    the src_path.\n\n    Example::\n\n        >>> SRC_PATH = os.path.join(os.path.dirname(__file__), 'html.py')\n        >>> get_cache_buster(SRC_PATH) is _IMPORT_TIME\n        True\n        >>> get_cache_buster(SRC_PATH, method='mtime') == _cache_key_by_mtime(SRC_PATH)\n        True\n        >>> get_cache_buster(SRC_PATH, method='md5') == _cache_key_by_md5(SRC_PATH)\n        True\n    \"\"\"\n    try:\n        fn = _BUST_METHODS[method]\n    except KeyError:\n        raise KeyError('Unsupported busting method value: %s' % method)\n\n    return fn(src_path)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nyield compiled DOM attribute key - value strings.", "response": "def _generate_dom_attrs(attrs, allow_no_value=True):\n    \"\"\" Yield compiled DOM attribute key-value strings.\n\n    If the value is `True`, then it is treated as no-value. If `None`, then it\n    is skipped.\n    \"\"\"\n    for attr in iterate_items(attrs):\n        if isinstance(attr, basestring):\n            attr = (attr, True)\n        key, value = attr\n        if value is None:\n            continue\n        if value is True and not allow_no_value:\n            value = key  # E.g. <option checked=\"true\" />\n        if value is True:\n            yield True  # E.g. <option checked />\n        else:\n            yield '%s=\"%s\"' % (key, value.replace('\"', '\\\\\"'))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tag(tagname, content='', attrs=None):\n    attrs_str = attrs and ' '.join(_generate_dom_attrs(attrs))\n    open_tag = tagname\n    if attrs_str:\n        open_tag += ' ' + attrs_str\n\n    if content is None:\n        return literal('<%s />' % open_tag)\n\n    content = ''.join(iterate(content, unless=(basestring, literal)))\n    return literal('<%s>%s</%s>' % (open_tag, content, tagname))", "response": "Helper for programmatically building HTML tags."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef package_meta():\n    _version_re = re.compile(r'__version__\\s+=\\s+(.*)')\n    _url_re = re.compile(r'__url__\\s+=\\s+(.*)')\n    _license_re = re.compile(r'__license__\\s+=\\s+(.*)')\n\n    with open('lambda_uploader/__init__.py', 'rb') as ffinit:\n        initcontent = ffinit.read()\n        version = str(ast.literal_eval(_version_re.search(\n            initcontent.decode('utf-8')).group(1)))\n        url = str(ast.literal_eval(_url_re.search(\n            initcontent.decode('utf-8')).group(1)))\n        licencia = str(ast.literal_eval(_license_re.search(\n            initcontent.decode('utf-8')).group(1)))\n    return {\n        'version': version,\n        'license': licencia,\n        'url': url,\n    }", "response": "Read the package metadata."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef subscribe(self):\n        ''' Subscribes the lambda to the Kinesis stream '''\n        try:\n            LOG.debug('Creating Kinesis subscription')\n            if self.starting_position_ts:\n                self._lambda_client \\\n                    .create_event_source_mapping(\n                        EventSourceArn=self.stream_name,\n                        FunctionName=self.function_name,\n                        BatchSize=self.batch_size,\n                        StartingPosition=self.starting_position,\n                        StartingPositionTimestamp=self.starting_position_ts)\n            else:\n                self._lambda_client \\\n                    .create_event_source_mapping(\n                        EventSourceArn=self.stream_name,\n                        FunctionName=self.function_name,\n                        BatchSize=self.batch_size,\n                        StartingPosition=self.starting_position)\n            LOG.debug('Subscription created')\n        except botocore.exceptions.ClientError as ex:\n            response_code = ex.response['Error']['Code']\n            if response_code == 'ResourceConflictException':\n                LOG.debug('Subscription exists. Updating ...')\n                resp = self._lambda_client\\\n                           .list_event_source_mappings(\n                                FunctionName=self.function_name,\n                                EventSourceArn=self.stream_name)\n                uuid = resp['EventSourceMappings'][0]['UUID']\n                self._lambda_client \\\n                    .update_event_source_mapping(\n                        UUID=uuid,\n                        FunctionName=self.function_name,\n                        Enabled=True,\n                        BatchSize=self.batch_size)\n            else:\n                LOG.error('Subscription failed, error=%s' % str(ex))\n                raise ex", "response": "Subscribes the lambda to the Kinesis stream"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _format_vpc_config(self):\n        '''\n        Returns {} if the VPC config is set to None by Config,\n        returns the formatted config otherwise\n        '''\n        if self._config.raw['vpc']:\n            return {\n                'SubnetIds': self._config.raw['vpc']['subnets'],\n                'SecurityGroupIds': self._config.raw['vpc']['security_groups']\n            }\n        else:\n            return {\n                'SubnetIds': [],\n                'SecurityGroupIds': [],\n            }", "response": "Formats the VPC config as a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _upload_s3(self, zip_file):\n        '''\n        Uploads the lambda package to s3\n        '''\n        s3_client = self._aws_session.client('s3')\n        transfer = boto3.s3.transfer.S3Transfer(s3_client)\n        transfer.upload_file(zip_file, self._config.s3_bucket,\n                             self._config.s3_package_name())", "response": "Uploads the lambda package to s3"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef main(arv=None):\n    # Check for Python 2.7 or later\n    if sys.version_info[0] < 3 and not sys.version_info[1] == 7:\n        raise RuntimeError('lambda-uploader requires Python 2.7 or later')\n\n    import argparse\n\n    parser = argparse.ArgumentParser(\n            description='Simple way to create and upload python lambda jobs')\n\n    parser.add_argument('--version', '-v', action='version',\n                        version=lambda_uploader.__version__)\n    parser.add_argument('--no-upload', dest='no_upload',\n                        action='store_const', help='dont upload the zipfile',\n                        const=True)\n    parser.add_argument('--no-clean', dest='no_clean',\n                        action='store_const',\n                        help='dont cleanup the temporary workspace',\n                        const=True)\n    parser.add_argument('--publish', '-p', dest='publish',\n                        action='store_const',\n                        help='publish an upload to an immutable version',\n                        const=True)\n    parser.add_argument('--virtualenv', '-e',\n                        help='use specified virtualenv instead of making one',\n                        default=None)\n    parser.add_argument('--extra-files', '-x',\n                        action='append',\n                        help='include file or directory path in package',\n                        default=[])\n    parser.add_argument('--no-virtualenv', dest='no_virtualenv',\n                        action='store_const',\n                        help='do not create or include a virtualenv at all',\n                        const=True)\n    parser.add_argument('--role', dest='role',\n                        default=getenv('LAMBDA_UPLOADER_ROLE'),\n                        help=('IAM role to assign the lambda function, '\n                              'can be set with $LAMBDA_UPLOADER_ROLE'))\n    parser.add_argument('--variables', dest='variables',\n                        help='add environment variables')\n    parser.add_argument('--profile', dest='profile',\n                        help='specify AWS cli profile')\n    parser.add_argument('--requirements', '-r', dest='requirements',\n                        help='specify a requirements.txt file')\n    alias_help = 'alias for published version (WILL SET THE PUBLISH FLAG)'\n    parser.add_argument('--alias', '-a', dest='alias',\n                        default=None, help=alias_help)\n    parser.add_argument('--alias-description', '-m', dest='alias_description',\n                        default=None, help='alias description')\n    parser.add_argument('--s3-bucket', '-s', dest='s3_bucket',\n                        help='S3 bucket to store the lambda function in',\n                        default=None)\n    parser.add_argument('--s3-key', '-k', dest='s3_key',\n                        help='Key name of the lambda function s3 object',\n                        default=None)\n    parser.add_argument('--config', '-c', help='Overrides lambda.json',\n                        default='lambda.json')\n    parser.add_argument('function_dir', default=getcwd(), nargs='?',\n                        help='lambda function directory')\n    parser.add_argument('--no-build', dest='no_build',\n                        action='store_const', help='dont build the sourcecode',\n                        const=True)\n\n    verbose = parser.add_mutually_exclusive_group()\n    verbose.add_argument('-V', dest='loglevel', action='store_const',\n                         const=logging.INFO,\n                         help=\"Set log-level to INFO.\")\n    verbose.add_argument('-VV', dest='loglevel', action='store_const',\n                         const=logging.DEBUG,\n                         help=\"Set log-level to DEBUG.\")\n    parser.set_defaults(loglevel=logging.WARNING)\n\n    args = parser.parse_args()\n\n    logging.basicConfig(level=args.loglevel)\n    try:\n        _execute(args)\n    except Exception:\n        print(TRACEBACK_MESSAGE\n              % (INTERROBANG, lambda_uploader.__version__,\n                 boto3_version, botocore_version),\n              file=sys.stderr)\n\n        traceback.print_exc()\n        sys.stderr.flush()\n        sys.exit(1)", "response": "This function is the main function of the lambda - uploader."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_package(path, requires, virtualenv=None, ignore=None,\n                  extra_files=None, zipfile_name=ZIPFILE_NAME,\n                  pyexec=None):\n    '''Builds the zip file and creates the package with it'''\n    pkg = Package(path, zipfile_name, pyexec)\n\n    if extra_files:\n        for fil in extra_files:\n            pkg.extra_file(fil)\n    if virtualenv is not None:\n        pkg.virtualenv(virtualenv)\n    pkg.requirements(requires)\n    pkg.build(ignore)\n\n    return pkg", "response": "Builds the zip file and creates the package with it"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall all necessary methods to build the Lambda Package", "response": "def build(self, ignore=None):\n        '''Calls all necessary methods to build the Lambda Package'''\n        self._prepare_workspace()\n        self.install_dependencies()\n        self.package(ignore)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clean_workspace(self):\n        '''Clean up the temporary workspace if one exists'''\n        if os.path.isdir(self._temp_workspace):\n            shutil.rmtree(self._temp_workspace)", "response": "Clean up the temporary workspace if one exists"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the requirements for the package.", "response": "def requirements(self, requires):\n        '''\n        Sets the requirements for the package.\n\n        It will take either a valid path to a requirements file or\n        a list of requirements.\n        '''\n        if requires:\n            if isinstance(requires, basestring) and \\\n               os.path.isfile(os.path.abspath(requires)):\n                self._requirements_file = os.path.abspath(requires)\n            else:\n                if isinstance(self._requirements, basestring):\n                    requires = requires.split()\n                self._requirements_file = None\n                self._requirements = requires\n        else:\n            # If the default requirements file is found use that\n            if os.path.isfile(self._requirements_file):\n                return\n            self._requirements, self._requirements_file = None, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef virtualenv(self, virtualenv):\n        '''\n        Sets the virtual environment for the lambda package\n\n        If this is not set then package_dependencies will create a new one.\n\n        Takes a path to a virtualenv or a boolean if the virtualenv creation\n        should be skipped.\n        '''\n        # If a boolean is passed then set the internal _skip_virtualenv flag\n        if isinstance(virtualenv, bool):\n            self._skip_virtualenv = virtualenv\n        else:\n            self._virtualenv = virtualenv\n            if not os.path.isdir(self._virtualenv):\n                raise Exception(\"virtualenv %s not found\" % self._virtualenv)\n            LOG.info(\"Using existing virtualenv at %s\" % self._virtualenv)\n            # use supplied virtualenv path\n            self._pkg_venv = self._virtualenv\n            self._skip_virtualenv = True", "response": "Sets the virtual environment for the lambda package."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new virtualenv and installs requirements", "response": "def install_dependencies(self):\n        ''' Creates a virtualenv and installs requirements '''\n        # If virtualenv is set to skip then do nothing\n        if self._skip_virtualenv:\n            LOG.info('Skip Virtualenv set ... nothing to do')\n            return\n\n        has_reqs = _isfile(self._requirements_file) or self._requirements\n        if self._virtualenv is None and has_reqs:\n            LOG.info('Building new virtualenv and installing requirements')\n            self._build_new_virtualenv()\n            self._install_requirements()\n        elif self._virtualenv is None and not has_reqs:\n            LOG.info('No requirements found, so no virtualenv will be made')\n            self._pkg_venv = False\n        else:\n            raise Exception('Cannot determine what to do about virtualenv')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _build_new_virtualenv(self):\n        '''Build a new virtualenvironment if self._virtualenv is set to None'''\n        if self._virtualenv is None:\n            # virtualenv was \"None\" which means \"do default\"\n            self._pkg_venv = os.path.join(self._temp_workspace, 'venv')\n            self._venv_pip = 'bin/pip'\n            if sys.platform == 'win32' or sys.platform == 'cygwin':\n                self._venv_pip = 'Scripts\\pip.exe'\n\n            python_exe = self._python_executable()\n\n            proc = Popen([\"virtualenv\", \"-p\", python_exe,\n                          self._pkg_venv], stdout=PIPE, stderr=PIPE)\n            stdout, stderr = proc.communicate()\n            LOG.debug(\"Virtualenv stdout: %s\" % stdout)\n            LOG.debug(\"Virtualenv stderr: %s\" % stderr)\n\n            if proc.returncode is not 0:\n                raise Exception('virtualenv returned unsuccessfully')\n\n        else:\n            raise Exception('cannot build a new virtualenv when asked to omit')", "response": "Build a new virtualenvironment if self. _virtualenv is None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninstalling the requirements. txt file in the virtual environment.", "response": "def _install_requirements(self):\n        '''\n        Create a new virtualenvironment and install requirements\n        if there are any.\n        '''\n        if not hasattr(self, '_pkg_venv'):\n            err = 'Must call build_new_virtualenv before install_requirements'\n            raise Exception(err)\n\n        cmd = None\n        if self._requirements:\n            LOG.debug(\"Installing requirements found %s in config\"\n                      % self._requirements)\n            cmd = [os.path.join(self._pkg_venv, self._venv_pip),\n                   'install'] + self._requirements\n\n        elif _isfile(self._requirements_file):\n            # Pip install\n            LOG.debug(\"Installing requirements from requirements.txt file\")\n            cmd = [os.path.join(self._pkg_venv, self._venv_pip),\n                   \"install\", \"-r\",\n                   self._requirements_file]\n\n        if cmd is not None:\n            prc = Popen(cmd, stdout=PIPE, stderr=PIPE)\n            stdout, stderr = prc.communicate()\n            LOG.debug(\"Pip stdout: %s\" % stdout)\n            LOG.debug(\"Pip stderr: %s\" % stderr)\n\n            if prc.returncode is not 0:\n                raise Exception('pip returned unsuccessfully')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef package(self, ignore=None):\n        ignore = ignore or []\n        package = os.path.join(self._temp_workspace, 'lambda_package')\n\n        # Copy site packages into package base\n        LOG.info('Copying site packages')\n\n        if hasattr(self, '_pkg_venv') and self._pkg_venv:\n            lib_dir = 'lib/python*/site-packages'\n            lib64_dir = 'lib64/python*/site-packages'\n\n            if sys.platform == 'win32' or sys.platform == 'cygwin':\n                lib_dir = 'lib\\\\site-packages'\n                lib64_dir = 'lib64\\\\site-packages'\n\n            # Look for the site packages\n            lib_site_list = glob.glob(os.path.join(\n                self._pkg_venv, lib_dir))\n            if lib_site_list:\n                utils.copy_tree(lib_site_list[0], package)\n            else:\n                LOG.debug(\"no lib site packages found\")\n\n            lib64_site_list = glob.glob(os.path.join(\n                self._pkg_venv, lib64_dir))\n            if lib64_site_list:\n                lib64_site_packages = lib64_site_list[0]\n                if not os.path.islink(lib64_site_packages):\n                    LOG.info('Copying lib64 site packages')\n                    utils.copy_tree(lib64_site_packages, package)\n                lib64_site_packages = lib64_site_list[0]\n            else:\n                LOG.debug(\"no lib64 site packages found\")\n\n        # Append the temp workspace to the ignore list:\n        ignore.append(r\"^%s/.*\" % re.escape(TEMP_WORKSPACE_NAME))\n        utils.copy_tree(self._path, package, ignore)\n\n        # Add extra files\n        for p in self._extra_files:\n            LOG.info('Copying extra %s into package' % p)\n            ignore.append(re.escape(p))\n            if os.path.isdir(p):\n                utils.copy_tree(p, package, ignore=ignore, include_parent=True)\n            else:\n                shutil.copy(p, package)\n\n        self._create_zip(package)", "response": "Creates a zip file of the lambda script and its dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nencode the properties of the url parameters from dictionary to a string.", "response": "def encode_properties(parameters):\n    \"\"\"\n    Performs encoding of url parameters from dictionary to a string. It does\n    not escape backslash because it is not needed.\n\n    See: http://www.jfrog.com/confluence/display/RTF/Artifactory+REST+API#ArtifactoryRESTAPI-SetItemProperties\n    \"\"\"\n    result = []\n\n    for param in iter(sorted(parameters)):\n        if isinstance(parameters[param], (list, tuple)):\n            value = ','.join([escape_chars(x) for x in parameters[param]])\n        else:\n            value = escape_chars(parameters[param])\n\n        result.append(\"%s=%s\" % (param, value))\n\n    return '|'.join(result)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsplit a path string into drive root and relative path.", "response": "def splitroot(self, part, sep=sep):\n        \"\"\"\n        Splits path string into drive, root and relative path\n\n        Uses '/artifactory/' as a splitting point in URI. Everything\n        before it, including '/artifactory/' itself is treated as drive.\n        The next folder is treated as root, and everything else is taken\n        for relative path.\n        \"\"\"\n        drv = ''\n        root = ''\n\n        base = get_global_base_url(part)\n        if base and without_http_prefix(part).startswith(without_http_prefix(base)):\n            mark = without_http_prefix(base).rstrip(sep)+sep\n            parts = part.split(mark)\n        else:\n            mark = sep+'artifactory'+sep\n            parts = part.split(mark)\n\n        if len(parts) >= 2:\n            drv = parts[0] + mark.rstrip(sep)\n            rest = sep + mark.join(parts[1:])\n        elif part.endswith(mark.rstrip(sep)):\n            drv = part\n            rest = ''\n        else:\n            rest = part\n\n        if not rest:\n            return drv, '', ''\n\n        if rest == sep:\n            return drv, '', ''\n\n        if rest.startswith(sep):\n            root, _, part = rest[1:].partition(sep)\n            root = sep + root + sep\n\n        return drv, root, part"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms a GET request to url with optional authentication", "response": "def rest_get(self, url, params=None, headers=None, auth=None, verify=True, cert=None):\n        \"\"\"\n        Perform a GET request to url with optional authentication\n        \"\"\"\n        res = requests.get(url, params=params, headers=headers, auth=auth, verify=verify,\n                           cert=cert)\n        return res.text, res.status_code"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rest_put(self, url, params=None, headers=None, auth=None, verify=True, cert=None):\n        res = requests.put(url, params=params, headers=headers, auth=auth, verify=verify,\n                           cert=cert)\n        return res.text, res.status_code", "response": "Perform a PUT request to url with optional authentication\n                          "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform a PUT request to url with optional authentication", "response": "def rest_post(self, url, params=None, headers=None, auth=None, verify=True, cert=None):\n        \"\"\"\n        Perform a PUT request to url with optional authentication\n        \"\"\"\n        res = requests.post(url, params=params, headers=headers, auth=auth, verify=verify,\n                            cert=cert)\n        return res.text, res.status_code"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rest_del(self, url, params=None, auth=None, verify=True, cert=None):\n        res = requests.delete(url, params=params, auth=auth, verify=verify, cert=cert)\n        return res.text, res.status_code", "response": "Perform a DELETE request to url with optional authentication\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rest_get_stream(self, url, auth=None, verify=True, cert=None):\n        res = requests.get(url, auth=auth, stream=True, verify=verify, cert=cert)\n        return res.raw, res.status_code", "response": "Perform a chunked GET request to url with optional authentication\n        This is specifically to download files."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrequesting remote file or directory status info info", "response": "def get_stat_json(self, pathobj):\n        \"\"\"\n        Request remote file/directory status info\n        Returns a json object as specified by Artifactory REST API\n        \"\"\"\n        url = '/'.join([pathobj.drive,\n                        'api/storage',\n                        str(pathobj.relative_to(pathobj.drive)).strip('/')])\n\n        text, code = self.rest_get(url, auth=pathobj.auth, verify=pathobj.verify,\n                                   cert=pathobj.cert)\n        if code == 404 and \"Unable to find item\" in text:\n            raise OSError(2, \"No such file or directory: '%s'\" % url)\n        if code != 200:\n            raise RuntimeError(text)\n\n        return json.loads(text)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nopens the remote file and returns a file - like object HTTPResponse", "response": "def open(self, pathobj):\n        \"\"\"\n        Opens the remote file and returns a file-like object HTTPResponse\n        Given the nature of HTTP streaming, this object doesn't support\n        seek()\n        \"\"\"\n        url = str(pathobj)\n        raw, code = self.rest_get_stream(url, auth=pathobj.auth, verify=pathobj.verify,\n                                         cert=pathobj.cert)\n\n        if not code == 200:\n            raise RuntimeError(\"%d\" % code)\n\n        return raw"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupload a given file - like object to the server.", "response": "def deploy(self, pathobj, fobj, md5=None, sha1=None, parameters=None):\n        \"\"\"\n        Uploads a given file-like object\n        HTTP chunked encoding will be attempted\n        \"\"\"\n        if isinstance(fobj, urllib3.response.HTTPResponse):\n            fobj = HTTPResponseWrapper(fobj)\n\n        url = str(pathobj)\n\n        if parameters:\n            url += \";%s\" % encode_matrix_parameters(parameters)\n\n        headers = {}\n\n        if md5:\n            headers['X-Checksum-Md5'] = md5\n        if sha1:\n            headers['X-Checksum-Sha1'] = sha1\n\n        text, code = self.rest_put_stream(url,\n                                          fobj,\n                                          headers=headers,\n                                          auth=pathobj.auth,\n                                          verify=pathobj.verify,\n                                          cert=pathobj.cert)\n\n        if code not in [200, 201]:\n            raise RuntimeError(\"%s\" % text)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmove artifact from src to dst", "response": "def move(self, src, dst):\n        \"\"\"\n        Move artifact from src to dst\n        \"\"\"\n        url = '/'.join([src.drive,\n                        'api/move',\n                        str(src.relative_to(src.drive)).rstrip('/')])\n\n        params = {'to': str(dst.relative_to(dst.drive)).rstrip('/')}\n\n        text, code = self.rest_post(url,\n                                    params=params,\n                                    auth=src.auth,\n                                    verify=src.verify,\n                                    cert=src.cert)\n\n        if code not in [200, 201]:\n            raise RuntimeError(\"%s\" % text)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the relative path to another path identified by the passed arguments.", "response": "def relative_to(self, *other):\n        \"\"\"\n        Return the relative path to another path identified by the passed\n        arguments.  If the operation is not possible (because this is not\n        a subpath of the other path), raise ValueError.\n        \"\"\"\n        obj = super(ArtifactoryPath, self).relative_to(*other)\n        obj.auth = self.auth\n        obj.verify = self.verify\n        obj.cert = self.cert\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding new or modifies existing properties listed in properties", "response": "def set_properties(self, properties, recursive=True):\n        \"\"\"\n        Adds new or modifies existing properties listed in properties\n\n        properties - is a dict which contains the property names and values to set.\n                     Property values can be a list or tuple to set multiple values\n                     for a key.\n        recursive  - on folders property attachment is recursive by default. It is\n                     possible to force recursive behavior.\n        \"\"\"\n        if not properties:\n            return\n\n        return self._accessor.set_properties(self, properties, recursive)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getScreenDims(self):\n        width = ale_lib.getScreenWidth(self.obj)\n        height = ale_lib.getScreenHeight(self.obj)\n        return (width,height)", "response": "returns a tuple that contains ( screen_width screen_height"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getScreen(self,screen_data=None):\n        if(screen_data is None):\n            width = ale_lib.getScreenWidth(self.obj)\n            height = ale_lib.getScreenWidth(self.obj)\n            screen_data = np.zeros(width*height,dtype=np.uint8)\n        ale_lib.getScreen(self.obj,as_ctypes(screen_data))\n        return screen_data", "response": "This function fills screen_data with the RAW Pixel data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting to lowercase and strip spaces", "response": "def lowstrip(term):\n    \"\"\"Convert to lowercase and strip spaces\"\"\"\n    term = re.sub('\\s+', ' ', term)\n    term = term.lower()\n    return term"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main(left_path, left_column, right_path, right_column,\n         outfile, titles, join, minscore, count, warp):\n    \"\"\"Perform the similarity join\"\"\"\n    right_file = csv.reader(open(right_path, 'r'))\n    if titles:\n        right_header = next(right_file)\n    index = NGram((tuple(r) for r in right_file),\n                  threshold=minscore,\n                  warp=warp, key=lambda x: lowstrip(x[right_column]))\n    left_file = csv.reader(open(left_path, 'r'))\n    out = csv.writer(open(outfile, 'w'), lineterminator='\\n')\n    if titles:\n        left_header = next(left_file)\n        out.writerow(left_header + [\"Rank\", \"Similarity\"] + right_header)\n    for row in left_file:\n        if not row: continue # skip blank lines\n        row = tuple(row)\n        results = index.search(lowstrip(row[left_column]), threshold=minscore)\n        if results:\n            if count > 0:\n                results = results[:count]\n            for rank, result in enumerate(results, 1):\n                out.writerow(row + (rank, result[1]) + result[0])\n        elif join == \"outer\":\n            out.writerow(row)", "response": "Perform the similarity join"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncommands - line arguments.", "response": "def console_main():\n    \"\"\"Process command-line arguments.\"\"\"\n    from argparse import ArgumentParser\n    parser = ArgumentParser(description=__doc__)\n    parser.add_argument('-t', '--titles', action='store_true',\n                        help='input files have column titles')\n    parser.add_argument(\n        '-j', '--join', choices=['inner', 'outer'],\n        help=('The kind of left join to perform.  Outer join outputs left-hand '\n              'rows which have no right hand match, while inner join discards '\n              'such rows. Default: %(default)s'))\n    parser.add_argument('-m', '--minscore', type=float,\n                        help='Minimum match score: %(default)s')\n    parser.add_argument('-c', '--count', type=int,\n                help='Max number of rows to match (0 for all): %(default)s')\n    parser.add_argument('-w', '--warp', type=float,\n            help='N-gram warp, higher helps short strings: %(default)s')\n    parser.add_argument('left', nargs=1, help='First CSV file')\n    parser.add_argument('leftcolumn', nargs=1, type=int, help='Column in first CSV file')\n    parser.add_argument('right', nargs=1, help='Second CSV file')\n    parser.add_argument('rightcolumn', nargs=1, type=int, help='Column in second CSV file')\n    parser.add_argument('outfile', nargs=1, help='Output CSV file')\n    parser.set_defaults(\n        titles=False, join='outer', minscore=0.24, count=0, warp=1.0)\n    args = parser.parse_args()\n    for path in [args.left[0], args.right[0]]:\n        if not os.path.isfile(path):\n            parser.error('File \"%s\" does not exist.' % path)\n    if not (0 <= args.minscore <= 1.0):\n        parser.error(\"Minimum score must be between 0 and 1\")\n    if not args.count >= 0:\n        parser.error(\"Maximum number of matches per row must be non-negative.\")\n    if args.count == 0:\n        args.count = None # to return all results\n    main(args.left[0], args.leftcolumn[0], args.right[0], args.rightcolumn[0],\n         args.outfile[0], args.titles, args.join, args.minscore, args.count,\n         args.warp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a shallow copy of this NGram object with the same settings and and referencing the same items.", "response": "def copy(self, items=None):\n        \"\"\"Return a new NGram object with the same settings, and\n        referencing the same items.  Copy is shallow in that\n        each item is not recursively copied.   Optionally specify\n        alternate items to populate the copy.\n\n        >>> from ngram import NGram\n        >>> from copy import deepcopy\n        >>> n = NGram(['eggs', 'spam'])\n        >>> m = n.copy()\n        >>> m.add('ham')\n        >>> sorted(list(n))\n        ['eggs', 'spam']\n        >>> sorted(list(m))\n        ['eggs', 'ham', 'spam']\n        >>> p = n.copy(['foo', 'bar'])\n        >>> sorted(list(p))\n        ['bar', 'foo']\n        \"\"\"\n        return NGram(items if items is not None else self,\n                     self.threshold, self.warp, self._key,\n                     self.N, self._pad_len, self._pad_char)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsplits a string into ngrams.", "response": "def _split(self, string):\n        \"\"\"Iterates over the ngrams of a string (no padding).\n\n        >>> from ngram import NGram\n        >>> n = NGram()\n        >>> list(n._split(\"hamegg\"))\n        ['ham', 'ame', 'meg', 'egg']\n        \"\"\"\n        for i in range(len(string) - self.N + 1):\n            yield string[i:i + self.N]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd an item to the N - gram index.", "response": "def add(self, item):\n        \"\"\"Add an item to the N-gram index (if it has not already been added).\n\n        >>> from ngram import NGram\n        >>> n = NGram()\n        >>> n.add(\"ham\")\n        >>> list(n)\n        ['ham']\n        >>> n.add(\"spam\")\n        >>> sorted(list(n))\n        ['ham', 'spam']\n        \"\"\"\n        if item not in self:\n            # Add the item to the base set\n            super(NGram, self).add(item)\n            # Record length of padded string\n            padded_item = self.pad(self.key(item))\n            self.length[item] = len(padded_item)\n            for ngram in self._split(padded_item):\n                # Add a new n-gram and string to index if necessary\n                self._grams.setdefault(ngram, {}).setdefault(item, 0)\n                # Increment number of times the n-gram appears in the string\n                self._grams[ngram][item] += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef items_sharing_ngrams(self, query):\n        # From matched string to number of N-grams shared with query string\n        shared = {}\n        # Dictionary mapping n-gram to string to number of occurrences of that\n        # ngram in the string that remain to be matched.\n        remaining = {}\n        for ngram in self.split(query):\n            try:\n                for match, count in self._grams[ngram].items():\n                    remaining.setdefault(ngram, {}).setdefault(match, count)\n                    # match as many occurrences as exist in matched string\n                    if remaining[ngram][match] > 0:\n                        remaining[ngram][match] -= 1\n                        shared.setdefault(match, 0)\n                        shared[match] += 1\n            except KeyError:\n                pass\n        return shared", "response": "Retrieve the subset of items that share n - grams with this string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch the index for items whose key exceeds the threshold similarity to the key of the given item.", "response": "def searchitem(self, item, threshold=None):\n        \"\"\"Search the index for items whose key exceeds the threshold\n        similarity to the key of the given item.\n\n        :return: list of pairs of (item, similarity) by decreasing similarity.\n\n        >>> from ngram import NGram\n        >>> n = NGram([(0, \"SPAM\"), (1, \"SPAN\"), (2, \"EG\"),\n        ... (3, \"SPANN\")], key=lambda x:x[1])\n        >>> sorted(n.searchitem((2, \"SPA\"), 0.35))\n        [((0, 'SPAM'), 0.375), ((1, 'SPAN'), 0.375)]\n        \"\"\"\n        return self.search(self.key(item), threshold)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef search(self, query, threshold=None):\n        threshold = threshold if threshold is not None else self.threshold\n        results = []\n        # Identify possible results\n        for match, samegrams in self.items_sharing_ngrams(query).items():\n            allgrams = (len(self.pad(query))\n                        + self.length[match] - (2 * self.N) - samegrams + 2)\n            similarity = self.ngram_similarity(samegrams, allgrams, self.warp)\n            if similarity >= threshold:\n                results.append((match, similarity))\n        # Sort results by decreasing similarity\n        results.sort(key=lambda x: x[1], reverse=True)\n        return results", "response": "Search the index for items whose key exceeds threshold \\\n        similarity to the query string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef finditem(self, item, threshold=None):\n        results = self.searchitem(item, threshold)\n        if results:\n            return results[0][0]\n        else:\n            return None", "response": "Return the most similar item to the provided one or None if nothing exceeds the threshold."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find(self, query, threshold=None):\n        results = self.search(query, threshold)\n        if results:\n            return results[0][0]\n        else:\n            return None", "response": "Simply return the best match to the query None on no match."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compare(s1, s2, **kwargs):\n        if s1 is None or s2 is None:\n            if s1 == s2:\n                return 1.0\n            return 0.0\n        try:\n            return NGram([s1], **kwargs).search(s2)[0][1]\n        except IndexError:\n            return 0.0", "response": "Compares two strings and returns their similarity between 0. 0 and 1. 0."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove all elements from this set.", "response": "def clear(self):\n        \"\"\"Remove all elements from this set.\n\n        >>> from ngram import NGram\n        >>> n = NGram(['spam', 'eggs'])\n        >>> sorted(list(n))\n        ['eggs', 'spam']\n        >>> n.clear()\n        >>> list(n)\n        []\n        \"\"\"\n        super(NGram, self).clear()\n        self._grams = {}\n        self.length = {}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the union of two or more sets as a new set.", "response": "def union(self, *others):\n        \"\"\"Return the union of two or more sets as a new set.\n\n        >>> from ngram import NGram\n        >>> a = NGram(['spam', 'eggs'])\n        >>> b = NGram(['spam', 'ham'])\n        >>> sorted(list(a.union(b)))\n        ['eggs', 'ham', 'spam']\n        \"\"\"\n        return self.copy(super(NGram, self).union(*others))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the difference of two sets as a new set.", "response": "def difference(self, *others):\n        \"\"\"Return the difference of two or more sets as a new set.\n\n        >>> from ngram import NGram\n        >>> a = NGram(['spam', 'eggs'])\n        >>> b = NGram(['spam', 'ham'])\n        >>> list(a.difference(b))\n        ['eggs']\n        \"\"\"\n        return self.copy(super(NGram, self).difference(*others))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef intersection(self, *others):\n        return self.copy(super(NGram, self).intersection(*others))", "response": "Return the intersection of two sets as a new set."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef intersection_update(self, *others):\n        self.difference_update(super(NGram, self).difference(*others))", "response": "Update the set with the intersection of itself and other sets."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the symmetric difference of two sets as a new set.", "response": "def symmetric_difference(self, other):\n        \"\"\"Return the symmetric difference of two sets as a new set.\n\n        >>> from ngram import NGram\n        >>> a = NGram(['spam', 'eggs'])\n        >>> b = NGram(['spam', 'ham'])\n        >>> sorted(list(a.symmetric_difference(b)))\n        ['eggs', 'ham']\n        \"\"\"\n        return self.copy(super(NGram, self).symmetric_difference(other))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the set with the symmetric difference of itself and other.", "response": "def symmetric_difference_update(self, other):\n        \"\"\"Update the set with the symmetric difference of itself and `other`.\n\n        >>> from ngram import NGram\n        >>> n = NGram(['spam', 'eggs'])\n        >>> other = set(['spam', 'ham'])\n        >>> n.symmetric_difference_update(other)\n        >>> sorted(list(n))\n        ['eggs', 'ham']\n        \"\"\"\n        intersection = super(NGram, self).intersection(other)\n        self.update(other)  # add items present in other\n        self.difference_update(intersection)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsubtract the arg from the value.", "response": "def sub(value, arg):\n    \"\"\"Subtract the arg from the value.\"\"\"\n    try:\n        nvalue, narg = handle_float_decimal_combinations(\n            valid_numeric(value), valid_numeric(arg), '-')\n        return nvalue - narg\n    except (ValueError, TypeError):\n        try:\n            return value - arg\n        except Exception:\n            return ''"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the absolute value.", "response": "def absolute(value):\n    \"\"\"Return the absolute value.\"\"\"\n    try:\n        return abs(valid_numeric(value))\n    except (ValueError, TypeError):\n        try:\n            return abs(value)\n        except Exception:\n            return ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates the cli command line.", "response": "def cli(config, server, api_key, all, credentials, project):\n    \"\"\"Create the cli command line.\"\"\"\n    # Check first for the pybossa.rc file to configure server and api-key\n    home = expanduser(\"~\")\n    if os.path.isfile(os.path.join(home, '.pybossa.cfg')):\n        config.parser.read(os.path.join(home, '.pybossa.cfg'))\n        config.server = config.parser.get(credentials,'server')\n        config.api_key = config.parser.get(credentials, 'apikey')\n        try:\n            config.all = config.parser.get(credentials, 'all')\n        except ConfigParser.NoOptionError:\n            config.all = None\n    if server:\n        config.server = server\n    if api_key:\n        config.api_key = api_key\n    if all:\n        config.all = all\n    try:\n        config.project = json.loads(project.read())\n    except JSONDecodeError as e:\n        click.secho(\"Error: invalid JSON format in project.json:\", fg='red')\n        if e.msg == 'Expecting value':\n            e.msg += \" (if string enclose it with double quotes)\"\n        click.echo(\"%s\\n%s: line %s column %s\" % (e.doc, e.msg, e.lineno, e.colno))\n        raise click.Abort()\n    try:\n        project_schema = {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\"type\": \"string\"},\n                \"short_name\": {\"type\": \"string\"},\n                \"description\": {\"type\": \"string\"}\n            }\n        }\n        jsonschema.validate(config.project, project_schema)\n    except jsonschema.exceptions.ValidationError as e:\n        click.secho(\"Error: invalid type in project.json\", fg='red')\n        click.secho(\"'%s': %s\" % (e.path[0], e.message), fg='yellow')\n        click.echo(\"'%s' must be a %s\" % (e.path[0], e.validator_value))\n        raise click.Abort()\n\n    config.pbclient = pbclient\n    config.pbclient.set('endpoint', config.server)\n    config.pbclient.set('api_key', config.api_key)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_project(config, task_presenter, results,\n                   long_description, tutorial, watch): # pragma: no cover\n    \"\"\"Update project templates and information.\"\"\"\n    if watch:\n        res = _update_project_watch(config, task_presenter, results,\n                                    long_description, tutorial)\n    else:\n        res = _update_project(config, task_presenter, results,\n                              long_description, tutorial)\n        click.echo(res)", "response": "Update project templates and information."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding tasks to a project.", "response": "def add_tasks(config, tasks_file, tasks_type, priority, redundancy):\n    \"\"\"Add tasks to a project.\"\"\"\n    res = _add_tasks(config, tasks_file, tasks_type, priority, redundancy)\n    click.echo(res)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds helping materials to a project.", "response": "def add_helpingmaterials(config, helping_materials_file, helping_type):\n    \"\"\"Add helping materials to a project.\"\"\"\n    res = _add_helpingmaterials(config, helping_materials_file, helping_type)\n    click.echo(res)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_tasks(config, task_id):\n    if task_id is None:\n        msg = (\"Are you sure you want to delete all the tasks and associated task runs?\")\n        if click.confirm(msg):\n            res = _delete_tasks(config, task_id)\n            click.echo(res)\n\n        else:\n            click.echo(\"Aborting.\")\n    else:\n        res = _delete_tasks(config, task_id)\n        click.echo(res)", "response": "Delete tasks from a project."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_task_redundancy(config, task_id, redundancy):\n    if task_id is None:\n        msg = (\"Are you sure you want to update all the tasks redundancy?\")\n        if click.confirm(msg):\n            res = _update_tasks_redundancy(config, task_id, redundancy)\n            click.echo(res)\n\n        else:\n            click.echo(\"Aborting.\")\n    else:\n        res = _update_tasks_redundancy(config, task_id, redundancy)\n        click.echo(res)", "response": "Update task redudancy for a project."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_project(config):\n    try:\n        response = config.pbclient.create_project(config.project['name'],\n                                                  config.project['short_name'],\n                                                  config.project['description'])\n        check_api_error(response)\n        return (\"Project: %s created!\" % config.project['short_name'])\n    except exceptions.ConnectionError:\n        return(\"Connection Error! The server %s is not responding\" % config.server)\n    except (ProjectNotFound, TaskNotFound):\n        raise", "response": "Create a project in a PyBossa server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _update_project_watch(config, task_presenter, results,\n                          long_description, tutorial):  # pragma: no cover\n    \"\"\"Update a project in a loop.\"\"\"\n    logging.basicConfig(level=logging.INFO,\n                        format='%(asctime)s - %(message)s',\n                        datefmt='%Y-%m-%d %H:%M:%S')\n    path = os.getcwd()\n    event_handler = PbsHandler(config, task_presenter, results,\n                               long_description, tutorial)\n    observer = Observer()\n    # We only want the current folder, not sub-folders\n    observer.schedule(event_handler, path, recursive=False)\n    observer.start()\n    try:\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        observer.stop()\n    observer.join()", "response": "Update a project in a loop."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _update_task_presenter_bundle_js(project):\n    if os.path.isfile ('bundle.min.js'):\n        with open('bundle.min.js') as f:\n            js = f.read()\n        project.info['task_presenter'] += \"<script>\\n%s\\n</script>\" % js\n        return\n\n    if os.path.isfile ('bundle.js'):\n        with open('bundle.js') as f:\n            js = f.read()\n        project.info['task_presenter'] += \"<script>\\n%s\\n</script>\" % js", "response": "Append to template a distribution bundle js."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _load_data(data_file, data_type):\n    raw_data = data_file.read()\n    if data_type is None:\n        data_type = data_file.name.split('.')[-1]\n    # Data list to process\n    data = []\n    # JSON type\n    if data_type == 'json':\n        data = json.loads(raw_data)\n        return data\n    # CSV type\n    elif data_type == 'csv':\n        csv_data = StringIO(raw_data)\n        reader = csv.DictReader(csv_data, delimiter=',')\n        for line in reader:\n            data.append(line)\n        return data\n    elif data_type in ['xlsx', 'xlsm', 'xltx', 'xltm']:\n        excel_data = StringIO(raw_data)\n        wb = openpyxl.load_workbook(excel_data)\n        ws = wb.active\n        # First headers\n        headers = []\n        for row in ws.iter_rows(max_row=1):\n            for cell in row:\n                tmp = '_'.join(cell.value.split(\" \")).lower()\n                headers.append(tmp)\n        # Simulate DictReader\n        for row in ws.iter_rows(row_offset=1):\n            values = []\n            for cell in row:\n                values.append(cell.value)\n            tmp = dict(itertools.izip(headers, values))\n            if len(values) == len(headers) and not row_empty(values):\n                data.append(tmp)\n        return data\n    # PO type\n    elif data_type == 'po':\n        po = polib.pofile(raw_data)\n        for entry in po.untranslated_entries():\n            data.append(entry.__dict__)\n        return data\n    # PROPERTIES type (used in Java and Firefox extensions)\n    elif data_type == 'properties':\n        lines = raw_data.split('\\n')\n        for l in lines:\n            if l:\n                var_id, string = l.split('=')\n                tmp = dict(var_id=var_id, string=string)\n                data.append(tmp)\n        return data\n    else:\n        return data", "response": "Load data from CSV XLSM XLTM PO or PROPERTIES type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding tasks to a project.", "response": "def _add_tasks(config, tasks_file, tasks_type, priority, redundancy):\n    \"\"\"Add tasks to a project.\"\"\"\n    try:\n        project = find_project_by_short_name(config.project['short_name'],\n                                             config.pbclient,\n                                             config.all)\n        data = _load_data(tasks_file, tasks_type)\n        if len(data) == 0:\n            return (\"Unknown format for the tasks file. Use json, csv, po or \"\n                    \"properties.\")\n        # If true, warn user\n        # if sleep:  # pragma: no cover\n        #     click.secho(msg, fg='yellow')\n        # Show progress bar\n        with click.progressbar(data, label=\"Adding Tasks\") as pgbar:\n            for d in pgbar:\n                task_info = create_task_info(d)\n                response = config.pbclient.create_task(project_id=project.id,\n                                                       info=task_info,\n                                                       n_answers=redundancy,\n                                                       priority_0=priority)\n\n                # Check if for the data we have to auto-throttle task creation\n                sleep, msg = enable_auto_throttling(config, data)\n                check_api_error(response)\n                # If auto-throttling enabled, sleep for sleep seconds\n                if sleep:  # pragma: no cover\n                    time.sleep(sleep)\n            return (\"%s tasks added to project: %s\" % (len(data),\n                    config.project['short_name']))\n    except exceptions.ConnectionError:\n        return (\"Connection Error! The server %s is not responding\" % config.server)\n    except (ProjectNotFound, TaskNotFound):\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding helping materials to a project.", "response": "def _add_helpingmaterials(config, helping_file, helping_type):\n    \"\"\"Add helping materials to a project.\"\"\"\n    try:\n        project = find_project_by_short_name(config.project['short_name'],\n                                             config.pbclient,\n                                             config.all)\n        data = _load_data(helping_file, helping_type)\n        if len(data) == 0:\n            return (\"Unknown format for the tasks file. Use json, csv, po or \"\n                    \"properties.\")\n        # Show progress bar\n        with click.progressbar(data, label=\"Adding Helping Materials\") as pgbar:\n            for d in pgbar:\n                helping_info, file_path = create_helping_material_info(d)\n                if file_path:\n                    # Create first the media object\n                    hm = config.pbclient.create_helpingmaterial(project_id=project.id,\n                                                                info=helping_info,\n                                                                file_path=file_path)\n                    check_api_error(hm)\n\n                    z = hm.info.copy()\n                    z.update(helping_info)\n                    hm.info = z\n                    response = config.pbclient.update_helping_material(hm)\n                    check_api_error(response)\n                else:\n                    response = config.pbclient.create_helpingmaterial(project_id=project.id,\n                                                                      info=helping_info)\n                check_api_error(response)\n                # Check if for the data we have to auto-throttle task creation\n                sleep, msg = enable_auto_throttling(config, data,\n                                                    endpoint='/api/helpinmaterial')\n                # If true, warn user\n                if sleep:  # pragma: no cover\n                    click.secho(msg, fg='yellow')\n                # If auto-throttling enabled, sleep for sleep seconds\n                if sleep:  # pragma: no cover\n                    time.sleep(sleep)\n            return (\"%s helping materials added to project: %s\" % (len(data),\n                    config.project['short_name']))\n    except exceptions.ConnectionError:\n        return (\"Connection Error! The server %s is not responding\" % config.server)\n    except (ProjectNotFound, TaskNotFound):\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting tasks from a project.", "response": "def _delete_tasks(config, task_id, limit=100, offset=0):\n    \"\"\"Delete tasks from a project.\"\"\"\n    try:\n        project = find_project_by_short_name(config.project['short_name'],\n                                             config.pbclient,\n                                             config.all)\n        if task_id:\n            response = config.pbclient.delete_task(task_id)\n            check_api_error(response)\n            return \"Task.id = %s and its associated task_runs have been deleted\" % task_id\n        else:\n            limit = limit\n            offset = offset\n            tasks = config.pbclient.get_tasks(project.id, limit, offset)\n            while len(tasks) > 0:\n                for t in tasks:\n                    response = config.pbclient.delete_task(t.id)\n                    check_api_error(response)\n                offset += limit\n                tasks = config.pbclient.get_tasks(project.id, limit, offset)\n            return \"All tasks and task_runs have been deleted\"\n    except exceptions.ConnectionError:\n        return (\"Connection Error! The server %s is not responding\" % config.server)\n    except (ProjectNotFound, TaskNotFound):\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating tasks redundancy from a project.", "response": "def _update_tasks_redundancy(config, task_id, redundancy, limit=300, offset=0):\n    \"\"\"Update tasks redundancy from a project.\"\"\"\n    try:\n        project = find_project_by_short_name(config.project['short_name'],\n                                             config.pbclient,\n                                             config.all)\n        if task_id:\n            response = config.pbclient.find_tasks(project.id, id=task_id)\n            check_api_error(response)\n            task = response[0]\n            task.n_answers = redundancy\n            response = config.pbclient.update_task(task)\n            check_api_error(response)\n            msg = \"Task.id = %s redundancy has been updated to %s\" % (task_id,\n                                                                      redundancy)\n            return msg\n        else:\n            limit = limit\n            offset = offset\n            tasks = config.pbclient.get_tasks(project.id, limit, offset)\n            with click.progressbar(tasks, label=\"Updating Tasks\") as pgbar:\n                while len(tasks) > 0:\n                    for t in pgbar:\n                        t.n_answers = redundancy\n                        response = config.pbclient.update_task(t)\n                        check_api_error(response)\n                        # Check if for the data we have to auto-throttle task update\n                        sleep, msg = enable_auto_throttling(config, tasks)\n                        # If auto-throttling enabled, sleep for sleep seconds\n                        if sleep:  # pragma: no cover\n                            time.sleep(sleep)\n                    offset += limit\n                    tasks = config.pbclient.get_tasks(project.id, limit, offset)\n                return \"All tasks redundancy have been updated\"\n    except exceptions.ConnectionError:\n        return (\"Connection Error! The server %s is not responding\" % config.server)\n    except (ProjectNotFound, TaskNotFound):\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn project by short_name.", "response": "def find_project_by_short_name(short_name, pbclient, all=None):\n    \"\"\"Return project by short_name.\"\"\"\n    try:\n        response = pbclient.find_project(short_name=short_name, all=all)\n        check_api_error(response)\n        if (len(response) == 0):\n            msg = '%s not found! You can use the all=1 argument to \\\n                   search in all the server.'\n            error = 'Project Not Found'\n            raise ProjectNotFound(msg, error)\n        return response[0]\n    except exceptions.ConnectionError:\n        raise\n    except ProjectNotFound:\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_api_error(api_response):\n    print(api_response)\n    \"\"\"Check if returned API response contains an error.\"\"\"\n    if type(api_response) == dict and 'code' in api_response and api_response['code'] <> 200:\n            print(\"Server response code: %s\" % api_response['code'])\n            print(\"Server response: %s\" % api_response)\n            raise exceptions.HTTPError('Unexpected response', response=api_response)\n    if type(api_response) == dict and (api_response.get('status') == 'failed'):\n        if 'ProgrammingError' in api_response.get('exception_cls'):\n            raise DatabaseError(message='PyBossa database error.',\n                                error=api_response)\n        if ('DBIntegrityError' in api_response.get('exception_cls') and\n            'project' in api_response.get('target')):\n            msg = 'PyBossa project already exists.'\n            raise ProjectAlreadyExists(message=msg, error=api_response)\n        if 'project' in api_response.get('target'):\n            raise ProjectNotFound(message='PyBossa Project not found',\n                                  error=api_response)\n        if 'task' in api_response.get('target'):\n            raise TaskNotFound(message='PyBossa Task not found',\n                               error=api_response)\n        else:\n            print(\"Server response: %s\" % api_response)\n            raise exceptions.HTTPError('Unexpected response', response=api_response)", "response": "Check if returned API response contains an error."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nformats the error for the given module.", "response": "def format_error(module, error):\n    \"\"\"Format the error for the given module.\"\"\"\n    logging.error(module)\n    # Beautify JSON error\n    print error.message\n    print json.dumps(error.error, sort_keys=True, indent=4, separators=(',', ': '))\n    exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfetch an authorization code from redis.", "response": "def fetch_by_code(self, code):\n        \"\"\"\n        Returns data belonging to an authorization code from redis or\n        ``None`` if no data was found.\n\n        See :class:`oauth2.store.AuthCodeStore`.\n\n        \"\"\"\n        code_data = self.read(code)\n\n        if code_data is None:\n            raise AuthCodeNotFound\n\n        return AuthorizationCode(**code_data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves the data belonging to an authorization code token in redis.", "response": "def save_code(self, authorization_code):\n        \"\"\"\n        Stores the data belonging to an authorization code token in redis.\n\n        See :class:`oauth2.store.AuthCodeStore`.\n\n        \"\"\"\n        self.write(authorization_code.code,\n                   {\"client_id\": authorization_code.client_id,\n                    \"code\": authorization_code.code,\n                    \"expires_at\": authorization_code.expires_at,\n                    \"redirect_uri\": authorization_code.redirect_uri,\n                    \"scopes\": authorization_code.scopes,\n                    \"data\": authorization_code.data,\n                    \"user_id\": authorization_code.user_id})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave the access token in redis.", "response": "def save_token(self, access_token):\n        \"\"\"\n        Stores the access token and additional data in redis.\n\n        See :class:`oauth2.store.AccessTokenStore`.\n\n        \"\"\"\n        self.write(access_token.token, access_token.__dict__)\n\n        unique_token_key = self._unique_token_key(access_token.client_id,\n                                                  access_token.grant_type,\n                                                  access_token.user_id)\n        self.write(unique_token_key, access_token.__dict__)\n\n        if access_token.refresh_token is not None:\n            self.write(access_token.refresh_token, access_token.__dict__)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete a refresh token after use", "response": "def delete_refresh_token(self, refresh_token):\n        \"\"\"\n        Deletes a refresh token after use\n        :param refresh_token: The refresh token to delete.\n        \"\"\"\n        access_token = self.fetch_by_refresh_token(refresh_token)\n\n        self.delete(access_token.token)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_client(self, client_id, client_secret, redirect_uris,\n                   authorized_grants=None, authorized_response_types=None):\n        \"\"\"\n        Add a client app.\n\n        :param client_id: Identifier of the client app.\n        :param client_secret: Secret the client app uses for authentication\n                              against the OAuth 2.0 provider.\n        :param redirect_uris: A ``list`` of URIs to redirect to.\n\n        \"\"\"\n        self.write(client_id,\n                   {\"identifier\": client_id,\n                    \"secret\": client_secret,\n                    \"redirect_uris\": redirect_uris,\n                    \"authorized_grants\": authorized_grants,\n                    \"authorized_response_types\": authorized_response_types})\n\n        return True", "response": "Add a client app to the cache."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating data needed by an access token.", "response": "def create_access_token_data(self, grant_type):\n        \"\"\"\n        Create data needed by an access token.\n\n        :param grant_type:\n        :type grant_type: str\n\n        :return: A ``dict`` containing he ``access_token`` and the\n                 ``token_type``. If the value of ``TokenGenerator.expires_in``\n                 is larger than 0, a ``refresh_token`` will be generated too.\n        :rtype: dict\n        \"\"\"\n        result = {\"access_token\": self.generate(), \"token_type\": \"Bearer\"}\n\n        if self.expires_in.get(grant_type, 0) > 0:\n            result[\"refresh_token\"] = self.generate()\n\n            result[\"expires_in\"] = self.expires_in[grant_type]\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate(self):\n        random_data = os.urandom(100)\n\n        hash_gen = hashlib.new(\"sha512\")\n        hash_gen.update(random_data)\n\n        return hash_gen.hexdigest()[:self.token_length]", "response": "Generate a new token for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _display_token(self):\n        if self.token is None:\n            return \"301 Moved\", \"\", {\"Location\": \"/login\"}\n\n        return (\"200 OK\",\n                self.TOKEN_TEMPLATE.format(\n                    access_token=self.token[\"access_token\"]),\n                {\"Content-Type\": \"text/html\"})", "response": "Display token information or redirect to login prompt if none is available."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrequest an access token from the OAuth2 server.", "response": "def _request_token(self, env):\n        \"\"\"\n        Retrieves a new access token from the OAuth2 server.\n        \"\"\"\n        params = {}\n\n        content = env['wsgi.input'].read(int(env['CONTENT_LENGTH']))\n        post_params = parse_qs(content)\n        # Convert to dict for easier access\n        for param, value in post_params.items():\n            decoded_param = param.decode('utf-8')\n            decoded_value = value[0].decode('utf-8')\n            if decoded_param == \"username\" or decoded_param == \"password\":\n                params[decoded_param] = decoded_value\n\n        params[\"grant_type\"] = \"password\"\n        params[\"client_id\"] = self.client_id\n        params[\"client_secret\"] = self.client_secret\n        # Request an access token by POSTing a request to the auth server.\n        try:\n            response = urllib2.urlopen(self.token_endpoint, urlencode(params))\n        except HTTPError, he:\n            if he.code == 400:\n                error_body = json.loads(he.read())\n                body = self.SERVER_ERROR_TEMPLATE\\\n                    .format(error_type=error_body[\"error\"],\n                            error_description=error_body[\"error_description\"])\n                return \"400 Bad Request\", body, {\"Content-Type\": \"text/html\"}\n            if he.code == 401:\n                return \"302 Found\", \"\", {\"Location\": \"/login?failed=1\"}\n\n        self.token = json.load(response)\n\n        return \"301 Moved\", \"\", {\"Location\": \"/\"}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_client(self, client_id, client_secret, redirect_uris,\n                   authorized_grants=None, authorized_response_types=None):\n        \"\"\"\n        Add a client app.\n\n        :param client_id: Identifier of the client app.\n        :param client_secret: Secret the client app uses for authentication\n                              against the OAuth 2.0 provider.\n        :param redirect_uris: A ``list`` of URIs to redirect to.\n\n        \"\"\"\n        self.clients[client_id] = Client(\n            identifier=client_id,\n            secret=client_secret,\n            redirect_uris=redirect_uris,\n            authorized_grants=authorized_grants,\n            authorized_response_types=authorized_response_types)\n\n        return True", "response": "Add a client app to the list of available clients."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fetch_by_client_id(self, client_id):\n        if client_id not in self.clients:\n            raise ClientNotFoundError\n\n        return self.clients[client_id]", "response": "Retrieve a client by its identifier."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an instance of AuthorizationCode.", "response": "def fetch_by_code(self, code):\n        \"\"\"\n        Returns an AuthorizationCode.\n\n        :param code: The authorization code.\n        :return: An instance of :class:`oauth2.datatype.AuthorizationCode`.\n        :raises: :class:`AuthCodeNotFound` if no data could be retrieved for\n                 given code.\n\n        \"\"\"\n        if code not in self.auth_codes:\n            raise AuthCodeNotFound\n\n        return self.auth_codes[code]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstores an access token and additional data in memory.", "response": "def save_token(self, access_token):\n        \"\"\"\n        Stores an access token and additional data in memory.\n\n        :param access_token: An instance of :class:`oauth2.datatype.AccessToken`.\n        \"\"\"\n        self.access_tokens[access_token.token] = access_token\n\n        unique_token_key = self._unique_token_key(access_token.client_id,\n                                                  access_token.grant_type,\n                                                  access_token.user_id)\n\n        self.unique_token_identifier[unique_token_key] = access_token.token\n\n        if access_token.refresh_token is not None:\n            self.refresh_tokens[access_token.refresh_token] = access_token\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an access token by its refresh token.", "response": "def fetch_by_refresh_token(self, refresh_token):\n        \"\"\"\n        Find an access token by its refresh token.\n\n        :param refresh_token: The refresh token that was assigned to an\n                              ``AccessToken``.\n        :return: The :class:`oauth2.datatype.AccessToken`.\n        :raises: :class:`oauth2.error.AccessTokenNotFound`\n        \"\"\"\n        if refresh_token not in self.refresh_tokens:\n            raise AccessTokenNotFound\n\n        return self.refresh_tokens[refresh_token]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a Grant that the provider should support.", "response": "def add_grant(self, grant):\n        \"\"\"\n        Adds a Grant that the provider should support.\n\n        :param grant: An instance of a class that extends\n                      :class:`oauth2.grant.GrantHandlerFactory`\n        :type grant: oauth2.grant.GrantHandlerFactory\n        \"\"\"\n        if hasattr(grant, \"expires_in\"):\n            self.token_generator.expires_in[grant.grant_type] = grant.expires_in\n\n        if hasattr(grant, \"refresh_expires_in\"):\n            self.token_generator.refresh_expires_in = grant.refresh_expires_in\n\n        self.grant_types.append(grant)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dispatch(self, request, environ):\n        try:\n            grant_type = self._determine_grant_type(request)\n\n            response = self.response_class()\n\n            grant_type.read_validate_params(request)\n\n            return grant_type.process(request, response, environ)\n        except OAuthInvalidNoRedirectError:\n            response = self.response_class()\n            response.add_header(\"Content-Type\", \"application/json\")\n            response.status_code = 400\n            response.body = json.dumps({\n                \"error\": \"invalid_redirect_uri\",\n                \"error_description\": \"Invalid redirect URI\"\n            })\n\n            return response\n        except OAuthInvalidError as err:\n            response = self.response_class()\n            return grant_type.handle_error(error=err, response=response)\n        except UnsupportedGrantError:\n            response = self.response_class()\n            response.add_header(\"Content-Type\", \"application/json\")\n            response.status_code = 400\n            response.body = json.dumps({\n                \"error\": \"unsupported_response_type\",\n                \"error_description\": \"Grant not supported\"\n            })\n\n            return response\n        except:\n            app_log.error(\"Uncaught Exception\", exc_info=True)\n            response = self.response_class()\n            return grant_type.handle_error(\n                error=OAuthInvalidError(error=\"server_error\",\n                                        explanation=\"Internal server error\"),\n                response=response)", "response": "Checks which Grant supports the current request and dispatches to it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef enable_unique_tokens(self):\n        for grant_type in self.grant_types:\n            if hasattr(grant_type, \"unique_token\"):\n                grant_type.unique_token = True", "response": "Enable the use of unique access tokens on all grant types that support\n        this option."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the value of the HTTP header identified by name.", "response": "def header(self, name, default=None):\n        \"\"\"\n        Returns the value of the HTTP header identified by `name`.\n        \"\"\"\n        wsgi_header = \"HTTP_{0}\".format(name.upper())\n\n        try:\n            return self.env_raw[wsgi_header]\n        except KeyError:\n            return default"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract the client id and client secret from the request body.", "response": "def request_body(request):\n    \"\"\"\n    Extracts the credentials of a client from the\n    *application/x-www-form-urlencoded* body of a request.\n\n    Expects the client_id to be the value of the ``client_id`` parameter and\n    the client_secret to be the value of the ``client_secret`` parameter.\n\n    :param request: The incoming request\n    :type request: oauth2.web.Request\n\n    :return: A tuple in the format of `(<CLIENT ID>, <CLIENT SECRET>)`\n    :rtype: tuple\n    \"\"\"\n    client_id = request.post_param(\"client_id\")\n    if client_id is None:\n        raise OAuthInvalidError(error=\"invalid_request\",\n                                explanation=\"Missing client identifier\")\n\n    client_secret = request.post_param(\"client_secret\")\n    if client_secret is None:\n        raise OAuthInvalidError(error=\"invalid_request\",\n                                explanation=\"Missing client credentials\")\n\n    return client_id, client_secret"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef http_basic_auth(request):\n    auth_header = request.header(\"authorization\")\n\n    if auth_header is None:\n        raise OAuthInvalidError(error=\"invalid_request\",\n                                explanation=\"Authorization header is missing\")\n\n    auth_parts = auth_header.strip().encode(\"latin1\").split(None)\n\n    if auth_parts[0].strip().lower() != b'basic':\n        raise OAuthInvalidError(\n            error=\"invalid_request\",\n            explanation=\"Provider supports basic authentication only\")\n\n    client_id, client_secret = b64decode(auth_parts[1]).split(b':', 1)\n\n    return client_id.decode(\"latin1\"), client_secret.decode(\"latin1\")", "response": "Extracts the client credentials from an HTTP Basic Auth header."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef by_identifier(self, request):\n        client_id = request.get_param(\"client_id\")\n\n        if client_id is None:\n            raise OAuthInvalidNoRedirectError(error=\"missing_client_id\")\n\n        try:\n            client = self.client_store.fetch_by_client_id(client_id)\n        except ClientNotFoundError:\n            raise OAuthInvalidNoRedirectError(error=\"unknown_client\")\n\n        redirect_uri = request.get_param(\"redirect_uri\")\n        if redirect_uri is not None:\n            try:\n                client.redirect_uri = redirect_uri\n            except RedirectUriUnknown:\n                raise OAuthInvalidNoRedirectError(\n                    error=\"invalid_redirect_uri\")\n\n        return client", "response": "Authenticates a client by its identifier."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef by_identifier_secret(self, request):\n        client_id, client_secret = self.source(request=request)\n\n        try:\n            client = self.client_store.fetch_by_client_id(client_id)\n        except ClientNotFoundError:\n            raise OAuthInvalidError(error=\"invalid_client\",\n                                    explanation=\"No client could be found\")\n\n        grant_type = request.post_param(\"grant_type\")\n        if client.grant_type_supported(grant_type) is False:\n            raise OAuthInvalidError(error=\"unauthorized_client\",\n                                    explanation=\"The client is not allowed \"\n                                                \"to use this grant type\")\n\n        if client.secret != client_secret:\n            raise OAuthInvalidError(error=\"invalid_client\",\n                                    explanation=\"Invalid client credentials\")\n\n        return client", "response": "Authenticates a client by its identifier and secret."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef expires_in(self):\n        time_left = self.expires_at - int(time.time())\n\n        if time_left > 0:\n            return time_left\n        return 0", "response": "Returns the time until the token expires in seconds or 0 if the token has expired."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute(self, query, *params):\n        cursor = self.connection.cursor()\n\n        try:\n            cursor.execute(query, params)\n\n            self.connection.commit()\n\n            return cursor.lastrowid\n        finally:\n            cursor.close()", "response": "Executes a query and returns the identifier of the last altered row."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexecute a query and returns the first result of the given query.", "response": "def fetchone(self, query, *args):\n        \"\"\"\n        Returns the first result of the given query.\n\n        :param query: The query to be executed as a `str`.\n        :param params: A `tuple` of parameters that will be replaced for\n                       placeholders in the query.\n        :return: The retrieved row with each field being one element in a\n                 `tuple`.\n        \"\"\"\n        cursor = self.connection.cursor()\n\n        try:\n            cursor.execute(query, args)\n\n            return cursor.fetchone()\n        finally:\n            cursor.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexecute a query and returns all the results of the given query.", "response": "def fetchall(self, query, *args):\n        \"\"\"\n        Returns all results of the given query.\n\n        :param query: The query to be executed as a `str`.\n        :param params: A `tuple` of parameters that will be replaced for\n                       placeholders in the query.\n        :return: A `list` of `tuple`s with each field being one element in the\n                 `tuple`.\n        \"\"\"\n        cursor = self.connection.cursor()\n\n        try:\n            cursor.execute(query, args)\n\n            return cursor.fetchall()\n        finally:\n            cursor.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving an access token by its refresh token.", "response": "def fetch_by_refresh_token(self, refresh_token):\n        \"\"\"\n        Retrieves an access token by its refresh token.\n\n        :param refresh_token: The refresh token of an access token as a `str`.\n\n        :return: An instance of :class:`oauth2.datatype.AccessToken`.\n\n        :raises: :class:`oauth2.error.AccessTokenNotFound` if not access token\n                 could be retrieved.\n        \"\"\"\n        row = self.fetchone(self.fetch_by_refresh_token_query, refresh_token)\n\n        if row is None:\n            raise AccessTokenNotFound\n\n        scopes = self._fetch_scopes(access_token_id=row[0])\n\n        data = self._fetch_data(access_token_id=row[0])\n\n        return self._row_to_token(data=data, scopes=scopes, row=row)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch_existing_token_of_user(self, client_id, grant_type, user_id):\n        token_data = self.fetchone(self.fetch_existing_token_of_user_query,\n                                   client_id, grant_type, user_id)\n\n        if token_data is None:\n            raise AccessTokenNotFound\n\n        scopes = self._fetch_scopes(access_token_id=token_data[0])\n\n        data = self._fetch_data(access_token_id=token_data[0])\n\n        return self._row_to_token(data=data, scopes=scopes, row=token_data)", "response": "Retrieves an existing access token for a specific client and user for a specific grant."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save_token(self, access_token):\n        access_token_id = self.execute(self.create_access_token_query,\n                                       access_token.client_id,\n                                       access_token.grant_type,\n                                       access_token.token,\n                                       access_token.expires_at,\n                                       access_token.refresh_token,\n                                       access_token.refresh_expires_at,\n                                       access_token.user_id)\n\n        for key, value in list(access_token.data.items()):\n            self.execute(self.create_data_query, key, value,\n                         access_token_id)\n\n        for scope in access_token.scopes:\n            self.execute(self.create_scope_query, scope, access_token_id)\n\n        return True", "response": "Creates a new entry for an access token in the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch_by_code(self, code):\n        auth_code_data = self.fetchone(self.fetch_code_query, code)\n\n        if auth_code_data is None:\n            raise AuthCodeNotFound\n\n        data = dict()\n        data_result = self.fetchall(self.fetch_data_query, auth_code_data[0])\n        if data_result is not None:\n            for dataset in data_result:\n                data[dataset[0]] = dataset[1]\n\n        scopes = []\n        scope_result = self.fetchall(self.fetch_scopes_query,\n                                     auth_code_data[0])\n        if scope_result is not None:\n            for scope_set in scope_result:\n                scopes.append(scope_set[0])\n\n        return AuthorizationCode(client_id=auth_code_data[1],\n                                 code=auth_code_data[2],\n                                 expires_at=auth_code_data[3],\n                                 redirect_uri=auth_code_data[4],\n                                 scopes=scopes, data=data,\n                                 user_id=auth_code_data[5])", "response": "Retrieves an authorization code by its code."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new entry of an auth code in the database.", "response": "def save_code(self, authorization_code):\n        \"\"\"\n        Creates a new entry of an auth code in the database.\n\n        :param authorization_code: An instance of\n                                   :class:`oauth2.datatype.AuthorizationCode`.\n\n        :return: `True` if everything went fine.\n        \"\"\"\n        auth_code_id = self.execute(self.create_auth_code_query,\n                                    authorization_code.client_id,\n                                    authorization_code.code,\n                                    authorization_code.expires_at,\n                                    authorization_code.redirect_uri,\n                                    authorization_code.user_id)\n\n        for key, value in list(authorization_code.data.items()):\n            self.execute(self.create_data_query, key, value, auth_code_id)\n\n        for scope in authorization_code.scopes:\n            self.execute(self.create_scope_query, scope, auth_code_id)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fetch_by_client_id(self, client_id):\n        grants = None\n        redirect_uris = None\n        response_types = None\n\n        client_data = self.fetchone(self.fetch_client_query, client_id)\n\n        if client_data is None:\n            raise ClientNotFoundError\n\n        grant_data = self.fetchall(self.fetch_grants_query, client_data[0])\n        if grant_data:\n            grants = []\n            for grant in grant_data:\n                grants.append(grant[0])\n\n        redirect_uris_data = self.fetchall(self.fetch_redirect_uris_query,\n                                           client_data[0])\n        if redirect_uris_data:\n            redirect_uris = []\n            for redirect_uri in redirect_uris_data:\n                redirect_uris.append(redirect_uri[0])\n\n        response_types_data = self.fetchall(self.fetch_response_types_query,\n                                            client_data[0])\n        if response_types_data:\n            response_types = []\n            for response_type in response_types_data:\n                response_types.append(response_type[0])\n\n        return Client(identifier=client_data[1], secret=client_data[2],\n                      authorized_grants=grants,\n                      authorized_response_types=response_types,\n                      redirect_uris=redirect_uris)", "response": "Retrieves a client by its identifier."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch_by_code(self, code):\n        code_data = self.mc.get(self._generate_cache_key(code))\n\n        if code_data is None:\n            raise AuthCodeNotFound\n\n        return AuthorizationCode(**code_data)", "response": "Fetch data belonging to an authorization code from memcache."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstoring the data belonging to an authorization code token in memcache.", "response": "def save_code(self, authorization_code):\n        \"\"\"\n        Stores the data belonging to an authorization code token in memcache.\n\n        See :class:`oauth2.store.AuthCodeStore`.\n\n        \"\"\"\n        key = self._generate_cache_key(authorization_code.code)\n\n        self.mc.set(key, {\"client_id\": authorization_code.client_id,\n                          \"code\": authorization_code.code,\n                          \"expires_at\": authorization_code.expires_at,\n                          \"redirect_uri\": authorization_code.redirect_uri,\n                          \"scopes\": authorization_code.scopes,\n                          \"data\": authorization_code.data,\n                          \"user_id\": authorization_code.user_id})"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save_token(self, access_token):\n        key = self._generate_cache_key(access_token.token)\n        self.mc.set(key, access_token.__dict__)\n\n        unique_token_key = self._unique_token_key(access_token.client_id,\n                                                  access_token.grant_type,\n                                                  access_token.user_id)\n        self.mc.set(self._generate_cache_key(unique_token_key),\n                    access_token.__dict__)\n\n        if access_token.refresh_token is not None:\n            rft_key = self._generate_cache_key(access_token.refresh_token)\n            self.mc.set(rft_key, access_token.__dict__)", "response": "Stores the access token and additional data in memcache."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_refresh_token(self, refresh_token):\n        access_token = self.fetch_by_refresh_token(refresh_token)\n        self.mc.delete(self._generate_cache_key(access_token.token))\n        self.mc.delete(self._generate_cache_key(refresh_token))", "response": "Delete a refresh token after use\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode_scopes(scopes, use_quote=False):\n    scopes_as_string = Scope.separator.join(scopes)\n\n    if use_quote:\n        return quote(scopes_as_string)\n    return scopes_as_string", "response": "Encodes a list of scopes into a string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef json_error_response(error, response, status_code=400):\n    msg = {\"error\": error.error, \"error_description\": error.explanation}\n\n    response.status_code = status_code\n    response.add_header(\"Content-Type\", \"application/json\")\n    response.body = json.dumps(msg)\n\n    return response", "response": "Formats an error as a response containing a JSON body."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nformatting the response of a successful token request as JSON.", "response": "def json_success_response(data, response):\n    \"\"\"\n    Formats the response of a successful token request as JSON.\n\n    Also adds default headers and status code.\n    \"\"\"\n    response.body = json.dumps(data)\n    response.status_code = 200\n\n    response.add_header(\"Content-Type\", \"application/json\")\n    response.add_header(\"Cache-Control\", \"no-store\")\n    response.add_header(\"Pragma\", \"no-cache\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compare(self, previous_scopes):\n        for scope in self.scopes:\n            if scope not in previous_scopes:\n                raise OAuthInvalidError(\n                    error=\"invalid_scope\",\n                    explanation=\"Invalid scope parameter in request\")\n\n        return True", "response": "Compare the scopes read from request with previously issued scopes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse(self, request, source):\n        if source == \"body\":\n            req_scope = request.post_param(\"scope\")\n        elif source == \"query\":\n            req_scope = request.get_param(\"scope\")\n        else:\n            raise ValueError(\"Unknown scope source '\" + source + \"'\")\n\n        if req_scope is None:\n            if self.default is not None:\n                self.scopes = [self.default]\n                self.send_back = True\n                return\n            elif len(self.available_scopes) != 0:\n                raise OAuthInvalidError(\n                    error=\"invalid_scope\",\n                    explanation=\"Missing scope parameter in request\")\n            else:\n                return\n\n        req_scopes = req_scope.split(self.separator)\n\n        self.scopes = [scope for scope in req_scopes\n                       if scope in self.available_scopes]\n\n        if len(self.scopes) == 0 and self.default is not None:\n            self.scopes = [self.default]\n            self.send_back = True", "response": "Parses the scope value in the given request."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_validate_params(self, request):\n        self.client = self.client_authenticator.by_identifier(request)\n\n        response_type = request.get_param(\"response_type\")\n\n        if self.client.response_type_supported(response_type) is False:\n            raise OAuthInvalidError(error=\"unauthorized_client\")\n\n        self.state = request.get_param(\"state\")\n\n        self.scope_handler.parse(request, \"query\")\n\n        return True", "response": "Reads and validates data in an incoming request as required by the client authentication and the Implicit Grant."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncontrolling all steps to authorize a request by a user. :param request: The incoming :class:`oauth2.web.Request` :param response: The :class:`oauth2.web.Response` that will be returned eventually :param environ: The environment variables of this request :param scopes: The scopes requested by an application :return: A tuple containing (`dict`, user_id) or the response.", "response": "def authorize(self, request, response, environ, scopes):\n        \"\"\"\n        Controls all steps to authorize a request by a user.\n\n        :param request: The incoming :class:`oauth2.web.Request`\n        :param response: The :class:`oauth2.web.Response` that will be\n                         returned eventually\n        :param environ: The environment variables of this request\n        :param scopes: The scopes requested by an application\n        :return: A tuple containing (`dict`, user_id) or the response.\n\n        \"\"\"\n        if self.site_adapter.user_has_denied_access(request) is True:\n            raise OAuthInvalidError(error=\"access_denied\",\n                                    explanation=\"Authorization denied by user\")\n\n        try:\n            result = self.site_adapter.authenticate(request, environ, scopes,\n                                                    self.client)\n\n            return self.sanitize_return_value(result)\n        except UserNotAuthenticated:\n            return self.site_adapter.render_auth_page(request, response,\n                                                      environ, scopes,\n                                                      self.client)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a new authorization token. A form to authorize the access of the application can be displayed with the help of `oauth2.web.SiteAdapter`.", "response": "def process(self, request, response, environ):\n        \"\"\"\n        Generates a new authorization token.\n\n        A form to authorize the access of the application can be displayed with\n        the help of `oauth2.web.SiteAdapter`.\n        \"\"\"\n        data = self.authorize(request, response, environ,\n                              self.scope_handler.scopes)\n\n        if isinstance(data, Response):\n            return data\n\n        code = self.token_generator.generate()\n        expires = int(time.time()) + self.token_expiration\n\n        auth_code = AuthorizationCode(client_id=self.client.identifier,\n                                      code=code, expires_at=expires,\n                                      redirect_uri=self.client.redirect_uri,\n                                      scopes=self.scope_handler.scopes,\n                                      data=data[0], user_id=data[1])\n\n        self.auth_code_store.save_code(auth_code)\n\n        response.add_header(\"Location\", self._generate_location(code))\n        response.body = \"\"\n        response.status_code = 302\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nredirecting the client in case an error occurs.", "response": "def handle_error(self, error, response):\n        \"\"\"\n        Redirects the client in case an error in the auth process occurred.\n        \"\"\"\n        query_params = {\"error\": error.error}\n\n        query = urlencode(query_params)\n\n        location = \"%s?%s\" % (self.client.redirect_uri, query)\n\n        response.status_code = 302\n        response.body = \"\"\n        response.add_header(\"Location\", location)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef process(self, request, response, environ):\n        token_data = self.create_token(\n            client_id=self.client.identifier,\n            data=self.data,\n            grant_type=AuthorizationCodeGrant.grant_type,\n            scopes=self.scopes,\n            user_id=self.user_id)\n\n        self.auth_code_store.delete_code(self.code)\n\n        if self.scopes:\n            token_data[\"scope\"] = encode_scopes(self.scopes)\n\n        json_success_response(data=token_data, response=response)\n\n        return response", "response": "Generates a new access token and returns it."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes the incoming request checks if the concrete SiteAdapter is valid and issues a new token that is returned to the client on successful validation.", "response": "def process(self, request, response, environ):\n        \"\"\"\n        Takes the incoming request, asks the concrete SiteAdapter to validate\n        it and issues a new access token that is returned to the client on\n        successful validation.\n        \"\"\"\n        try:\n            data = self.site_adapter.authenticate(request, environ,\n                                                  self.scope_handler.scopes,\n                                                  self.client)\n            data = AuthorizeMixin.sanitize_return_value(data)\n        except UserNotAuthenticated:\n            raise OAuthInvalidError(error=\"invalid_client\",\n                                    explanation=self.OWNER_NOT_AUTHENTICATED)\n\n        if isinstance(data, Response):\n            return data\n\n        token_data = self.create_token(\n            client_id=self.client.identifier,\n            data=data[0],\n            grant_type=ResourceOwnerGrant.grant_type,\n            scopes=self.scope_handler.scopes,\n            user_id=data[1])\n\n        if self.scope_handler.send_back:\n            token_data[\"scope\"] = encode_scopes(self.scope_handler.scopes)\n\n        json_success_response(data=token_data, response=response)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_validate_params(self, request):\n        self.client = self.client_authenticator.by_identifier_secret(request)\n\n        self.password = request.post_param(\"password\")\n        self.username = request.post_param(\"username\")\n\n        self.scope_handler.parse(request=request, source=\"body\")\n\n        return True", "response": "Checks if all incoming parameters meet the expected values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new access token and store it in the access token store.", "response": "def process(self, request, response, environ):\n        \"\"\"\n        Create a new access token.\n\n        :param request: The incoming :class:`oauth2.web.Request`.\n        :param response: The :class:`oauth2.web.Response` that will be returned\n                         to the client.\n        :param environ: A ``dict`` containing data of the environment.\n\n        :return: :class:`oauth2.web.Response`\n\n        \"\"\"\n        token_data = self.token_generator.create_access_token_data(self.refresh_grant_type)\n        expires_at = int(time.time()) + token_data[\"expires_in\"]\n\n        access_token = AccessToken(client_id=self.client.identifier,\n                                   token=token_data[\"access_token\"],\n                                   grant_type=self.refresh_grant_type,\n                                   data=self.data, expires_at=expires_at,\n                                   scopes=self.scope_handler.scopes,\n                                   user_id=self.user_id)\n\n        if self.reissue_refresh_tokens:\n            self.access_token_store.delete_refresh_token(self.refresh_token)\n            access_token.refresh_token = token_data[\"refresh_token\"]\n            refresh_expires_in = self.token_generator.refresh_expires_in\n            refresh_expires_at = int(time.time()) + refresh_expires_in\n            access_token.refresh_expires_at = refresh_expires_at\n        else:\n            del token_data[\"refresh_token\"]\n\n        self.access_token_store.save_token(access_token)\n\n        json_success_response(data=token_data, response=response)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_validate_params(self, request):\n        self.refresh_token = request.post_param(\"refresh_token\")\n\n        if self.refresh_token is None:\n            raise OAuthInvalidError(\n                error=\"invalid_request\",\n                explanation=\"Missing refresh_token in request body\")\n\n        self.client = self.client_authenticator.by_identifier_secret(request)\n\n        try:\n            access_token = self.access_token_store.fetch_by_refresh_token(\n                self.refresh_token\n            )\n        except AccessTokenNotFound:\n            raise OAuthInvalidError(error=\"invalid_request\",\n                                    explanation=\"Invalid refresh token\")\n\n        refresh_token_expires_at = access_token.refresh_expires_at\n        self.refresh_grant_type = access_token.grant_type\n\n        if refresh_token_expires_at != 0 and \\\n                        refresh_token_expires_at < int(time.time()):\n            raise OAuthInvalidError(error=\"invalid_request\",\n                                    explanation=\"Invalid refresh token\")\n\n        self.data = access_token.data\n        self.user_id = access_token.user_id\n\n        self.scope_handler.parse(request, \"body\")\n        self.scope_handler.compare(access_token.scopes)\n\n        return True", "response": "Validate the incoming request."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef value_for_keypath(obj, path):\n    val = obj\n    for part in path.split('.'):\n        match = re.match(list_index_re, part)\n        if match is not None:\n            val = _extract(val, match.group(1))\n            if not isinstance(val, list) and not isinstance(val, tuple):\n                raise TypeError('expected list/tuple')\n            index = int(match.group(2))\n            val = val[index]\n        else:\n            val = _extract(val, part)\n        if val is None:\n            return None\n    return val", "response": "Get value from walking key path with start object obj."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_value_for_keypath(obj, path, new_value, preserve_child = False):\n    parts = path.split('.')\n    last_part = len(parts) - 1\n    dst = obj\n    for i, part in enumerate(parts):\n        match = re.match(list_index_re, part)\n        if match is not None:\n            dst = _extract(dst, match.group(1))\n            if not isinstance(dst, list) and not isinstance(dst, tuple):\n                raise TypeError('expected list/tuple')\n            index = int(match.group(2))\n            if i == last_part:\n                dst[index] = new_value\n            else:\n                dst = dst[index]\n        else:\n            if i != last_part:\n                dst = _extract(dst, part)\n            else:\n                if isinstance(dst, dict):\n                    dst[part] = new_value\n                else:\n                    if not preserve_child:\n                        setattr(dst, part, new_value)\n                    else:\n                        try:\n                            v = getattr(dst, part)\n                        except AttributeError:\n                            setattr(dst, part, new_value)", "response": "Set attribute value new_value at key path of object obj."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate an ImageView for the given image name.", "response": "def view_for_image_named(image_name):\n    \"\"\"Create an ImageView for the given image.\"\"\"\n\n    image = resource.get_image(image_name)\n\n    if not image:\n        return None\n\n    return ImageView(pygame.Rect(0, 0, 0, 0), image)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninstall or upgrade setuptools and EasyInstall", "response": "def main(argv, version=DEFAULT_VERSION):\n    \"\"\"Install or upgrade setuptools and EasyInstall\"\"\"\n    tarball = download_setuptools()\n    _install(tarball, _build_install_args(argv))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fill_gradient(surface, color, gradient,\n                  rect=None, vertical=True, forward=True):\n\n    \"\"\"Fill a surface with a linear gradient pattern.\n\n    color\n\n        starting color\n\n    gradient\n\n        final color\n\n    rect\n\n        area to fill; default is surface's rect\n\n    vertical\n\n        True=vertical; False=horizontal\n\n    forward\n\n        True=forward; False=reverse\n\n    See http://www.pygame.org/wiki/GradientCode\n    \"\"\"\n\n    if rect is None:\n        rect = surface.get_rect()\n\n    x1, x2 = rect.left, rect.right\n    y1, y2 = rect.top, rect.bottom\n\n    if vertical:\n        h = y2 - y1\n    else:\n        h = x2 - x1\n\n    assert h > 0\n\n    if forward:\n        a, b = color, gradient\n    else:\n        b, a = color, gradient\n\n    rate = (float(b[0] - a[0]) / h,\n            float(b[1] - a[1]) / h,\n            float(b[2] - a[2]) / h)\n\n    fn_line = pygame.draw.line\n    if vertical:\n        for line in range(y1, y2):\n            color = (min(max(a[0] + (rate[0] * (line - y1)), 0), 255),\n                     min(max(a[1] + (rate[1] * (line - y1)), 0), 255),\n                     min(max(a[2] + (rate[2] * (line - y1)), 0), 255))\n            fn_line(surface, color, (x1, line), (x2, line))\n    else:\n        for col in range(x1, x2):\n            color = (min(max(a[0] + (rate[0] * (col - x1)), 0), 255),\n                     min(max(a[1] + (rate[1] * (col - x1)), 0), 255),\n                     min(max(a[2] + (rate[2] * (col - x1)), 0), 255))\n            fn_line(surface, color, (col, y1), (col, y2))", "response": "Fill a surface with a linear gradient pattern."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef layout(self):\n        if self.shadowed:\n            shadow_size = theme.current.shadow_size\n            shadowed_frame_size = (self.frame.w + shadow_size,\n                                   self.frame.h + shadow_size)\n            self.surface = pygame.Surface(\n                shadowed_frame_size, pygame.SRCALPHA, 32)\n            shadow_image = resource.get_image('shadow')\n            self.shadow_image = resource.scale_image(shadow_image,\n                                                     shadowed_frame_size)\n        else:\n            self.surface = pygame.Surface(self.frame.size, pygame.SRCALPHA, 32)\n            self.shadow_image = None", "response": "This method is called to have the view layout itself."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stylize(self):\n        # do children first in case parent needs to override their style\n        for child in self.children:\n            child.stylize()\n        style = theme.current.get_dict(self)\n        preserve_child = False\n        try:\n            preserve_child = getattr(theme.current, 'preserve_child')\n        except:\n            preserve_child = False\n\n        for key, val in style.iteritems():\n            kvc.set_value_for_keypath(self, key, val, preserve_child)\n        self.layout()", "response": "Apply theme style attributes to this instance and its children."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndo not call directly.", "response": "def draw(self):\n        \"\"\"Do not call directly.\"\"\"\n\n        if self.hidden:\n            return False\n\n        if self.background_color is not None:\n            render.fillrect(self.surface, self.background_color,\n                            rect=pygame.Rect((0, 0), self.frame.size))\n\n        for child in self.children:\n            if not child.hidden:\n                child.draw()\n\n                topleft = child.frame.topleft\n\n                if child.shadowed:\n                    shadow_size = theme.current.shadow_size\n                    shadow_topleft = (topleft[0] - shadow_size // 2,\n                                      topleft[1] - shadow_size // 2)\n                    self.surface.blit(child.shadow_image, shadow_topleft)\n\n                self.surface.blit(child.surface, topleft)\n\n                if child.border_color and child.border_widths is not None:\n                    if (type(child.border_widths) is int and\n                        child.border_widths > 0):\n                        pygame.draw.rect(self.surface, child.border_color,\n                                         child.frame, child.border_widths)\n                    else:\n                        tw, lw, bw, rw = child.get_border_widths()\n\n                        tl = (child.frame.left, child.frame.top)\n                        tr = (child.frame.right - 1, child.frame.top)\n                        bl = (child.frame.left, child.frame.bottom - 1)\n                        br = (child.frame.right - 1, child.frame.bottom - 1)\n\n                        if tw > 0:\n                            pygame.draw.line(self.surface, child.border_color,\n                                             tl, tr, tw)\n                        if lw > 0:\n                            pygame.draw.line(self.surface, child.border_color,\n                                             tl, bl, lw)\n                        if bw > 0:\n                            pygame.draw.line(self.surface, child.border_color,\n                                             bl, br, bw)\n                        if rw > 0:\n                            pygame.draw.line(self.surface, child.border_color,\n                                             tr, br, rw)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning border width for each side top left bottom right.", "response": "def get_border_widths(self):\n        \"\"\"Return border width for each side top, left, bottom, right.\"\"\"\n        if type(self.border_widths) is int:   # uniform size\n            return [self.border_widths] * 4\n        return self.border_widths"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the view under the point pt.", "response": "def hit(self, pt):\n        \"\"\"Find the view (self, child, or None) under the point `pt`.\"\"\"\n\n        if self.hidden or not self._enabled:\n            return None\n\n        if not self.frame.collidepoint(pt):\n            return None\n\n        local_pt = (pt[0] - self.frame.topleft[0],\n                    pt[1] - self.frame.topleft[1])\n\n        for child in reversed(self.children):   # front to back\n            hit_view = child.hit(local_pt)\n            if hit_view is not None:\n                return hit_view\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbring the class to the front of the tree", "response": "def bring_to_front(self):\n        \"\"\"TODO: explain depth sorting\"\"\"\n        if self.parent is not None:\n            ch = self.parent.children\n            index = ch.index(self)\n            ch[-1], ch[index] = ch[index], ch[-1]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef use_theme(theme):\n    global current\n    current = theme\n    import scene\n    if scene.current is not None:\n        scene.current.stylize()", "response": "Make the given theme current."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set(self, class_name, state, key, value):\n        self._styles.setdefault(class_name, {}).setdefault(state, {})\n        self._styles[class_name][state][key] = value", "response": "Set a single style value for a view class and state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_dict_for_class(self, class_name, state=None, base_name='View'):\n        classes = []\n        klass = class_name\n\n        while True:\n            classes.append(klass)\n            if klass.__name__ == base_name:\n                break\n            klass = klass.__bases__[0]\n\n        if state is None:\n            state = 'normal'\n\n        style = {}\n\n        for klass in classes:\n            class_name = klass.__name__\n\n            try:\n                state_styles = self._styles[class_name][state]\n            except KeyError:\n                state_styles = {}\n\n            if state != 'normal':\n                try:\n                    normal_styles = self._styles[class_name]['normal']\n                except KeyError:\n                    normal_styles = {}\n\n                state_styles = dict(chain(normal_styles.iteritems(),\n                                          state_styles.iteritems()))\n\n            style = dict(chain(state_styles.iteritems(),\n                               style.iteritems()))\n\n        return style", "response": "Returns the style dict for a given class and state."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_dict(self, obj, state=None, base_name='View'):\n        return self.get_dict_for_class(class_name=obj.__class__,\n                                       state=obj.state,\n                                       base_name=base_name)", "response": "Returns a dict of the style dict for a view instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a single style attribute value for the given class.", "response": "def get_value(self, class_name, attr, default_value=None,\n                  state='normal', base_name='View'):\n        \"\"\"Get a single style attribute value for the given class.\n\n        \"\"\"\n        styles = self.get_dict_for_class(class_name, state, base_name)\n        try:\n            return styles[attr]\n        except KeyError:\n            return default_value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning dict of current values for all tracked fields", "response": "def current(self, fields=None):\n        \"\"\"Returns dict of current values for all tracked fields\"\"\"\n        if fields is None:\n            fields = self.fields\n\n        return dict((f, self.get_field_value(f)) for f in fields)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef instantiate_object_id_field(object_id_class_or_tuple=models.TextField):\n    if isinstance(object_id_class_or_tuple, (list, tuple)):\n        object_id_class, object_id_kwargs = object_id_class_or_tuple\n    else:\n        object_id_class = object_id_class_or_tuple\n        object_id_kwargs = {}\n\n    if not issubclass(object_id_class, models.fields.Field):\n        raise TypeError('settings.%s must be a Django model field or (field, kwargs) tuple' % OBJECT_ID_TYPE_SETTING)\n    if not isinstance(object_id_kwargs, dict):\n        raise TypeError('settings.%s kwargs must be a dict' % OBJECT_ID_TYPE_SETTING)\n\n    return object_id_class(db_index=True, **object_id_kwargs)", "response": "Instantiates and returns a model field for FieldHistory. object_id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreporting if the session key has expired.", "response": "def has_expired(self, lifetime, now=None):\n        \"\"\"Report if the session key has expired.\n\n        :param lifetime: A :class:`datetime.timedelta` that specifies the\n                         maximum age this :class:`SessionID` should be checked\n                         against.\n        :param now: If specified, use this :class:`~datetime.datetime` instance\n                         instead of :meth:`~datetime.datetime.utcnow()` as the\n                         current time.\n        \"\"\"\n        now = now or datetime.utcnow()\n        return now > self.created + lifetime"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef destroy(self):\n        for k in list(self.keys()):\n            del self[k]\n\n        if getattr(self, 'sid_s', None):\n            current_app.kvsession_store.delete(self.sid_s)\n            self.sid_s = None\n\n        self.modified = False\n        self.new = False", "response": "Destroys a session completely by deleting all keys and removing it\n        from the internal store immediately."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef regenerate(self):\n        self.modified = True\n\n        if getattr(self, 'sid_s', None):\n            # delete old session\n            current_app.kvsession_store.delete(self.sid_s)\n\n            # remove sid_s, set modified\n            self.sid_s = None\n            self.modified = True", "response": "Generate a new session id for this session."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove all expired session from the store.", "response": "def cleanup_sessions(self, app=None):\n        \"\"\"Removes all expired session from the store.\n\n        Periodically, this function can be called to remove sessions from\n        the backend store that have expired, as they are not removed\n        automatically unless the backend supports time-to-live and has been\n        configured appropriately (see :class:`~simplekv.TimeToLiveMixin`).\n\n        This function retrieves all session keys, checks they are older than\n        :attr:`flask.Flask.permanent_session_lifetime` and if so, removes them.\n\n        Note that no distinction is made between non-permanent and permanent\n        sessions.\n\n        :param app: The app whose sessions should be cleaned up. If ``None``,\n                    uses :py:data:`~flask.current_app`.\"\"\"\n\n        if not app:\n            app = current_app\n        for key in app.kvsession_store.keys():\n            m = self.key_regex.match(key)\n            now = datetime.utcnow()\n            if m:\n                # read id\n                sid = SessionID.unserialize(key)\n\n                # remove if expired\n                if sid.has_expired(app.permanent_session_lifetime, now):\n                    app.kvsession_store.delete(key)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize application and KVSession. This will replace the session management of the application with the session management of the application with Flask - KVSession s.", "response": "def init_app(self, app, session_kvstore=None):\n        \"\"\"Initialize application and KVSession.\n\n        This will replace the session management of the application with\n        Flask-KVSession's.\n\n        :param app: The :class:`~flask.Flask` app to be initialized.\"\"\"\n        app.config.setdefault('SESSION_KEY_BITS', 64)\n        app.config.setdefault('SESSION_RANDOM_SOURCE', SystemRandom())\n\n        if not session_kvstore and not self.default_kvstore:\n            raise ValueError('Must supply session_kvstore either on '\n                             'construction or init_app().')\n\n        # set store on app, either use default\n        # or supplied argument\n        app.kvsession_store = session_kvstore or self.default_kvstore\n\n        app.session_interface = KVSessionInterface()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef transfer_config_dict(soap_object, data_dict):\n    for key, val in data_dict.items():\n        # Transfer each key to the matching attribute ont he SOAP object.\n        setattr(soap_object, key, val)", "response": "Transfer the values of the data dict to the SOAP object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _assemble_and_send_request(self):\n\n        # Fire off the query.\n        return self.client.service.createPickup(\n            WebAuthenticationDetail=self.WebAuthenticationDetail,\n            ClientDetail=self.ClientDetail,\n            TransactionDetail=self.TransactionDetail,\n            Version=self.VersionId,\n            OriginDetail=self.OriginDetail,\n            PickupServiceCategory=self.PickupServiceCategory,\n            PackageCount=self.PackageCount,\n            TotalWeight=self.TotalWeight,\n            CarrierCode=self.CarrierCode,\n            OversizePackageCount=self.OversizePackageCount,\n            Remarks=self.Remarks,\n            CommodityDescription=self.CommodityDescription,\n            CountryRelationship=self.CountryRelationship\n        )", "response": "Assemble and send a request to FedexBaseService."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nassembling and send a request to FedexBaseService.", "response": "def _assemble_and_send_request(self):\n        \"\"\"\n        Fires off the Fedex request.\n\n        @warning: NEVER CALL THIS METHOD DIRECTLY. CALL send_request(),\n            WHICH RESIDES ON FedexBaseService AND IS INHERITED.\n        \"\"\"\n\n        # Fire off the query.\n        return self.client.service.getPickupAvailability(\n            WebAuthenticationDetail=self.WebAuthenticationDetail,\n            ClientDetail=self.ClientDetail,\n            TransactionDetail=self.TransactionDetail,\n            Version=self.VersionId,\n            PickupType=self.PickupType,\n            AccountNumber=self.AccountNumber,\n            PickupAddress=self.PickupAddress,\n            PickupRequestType=self.PickupRequestType,\n            DispatchDate=self.DispatchDate,\n            NumberOfBusinessDays=self.NumberOfBusinessDays,\n            PackageReadyTime=self.PackageReadyTime,\n            CustomerCloseTime=self.CustomerCloseTime,\n            Carriers=self.Carriers,\n            ShipmentAttributes=self.ShipmentAttributes,\n            PackageDetails=self.PackageDetails\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _prepare_wsdl_objects(self):\n\n        # This is the primary data structure for processShipment requests.\n        self.RequestedShipment = self.client.factory.create('RequestedShipment')\n        self.RequestedShipment.ShipTimestamp = datetime.datetime.now()\n\n        # Defaults for TotalWeight wsdl object.\n        total_weight = self.client.factory.create('Weight')\n        # Start at nothing.\n        total_weight.Value = 0.0\n        # Default to pounds.\n        total_weight.Units = 'LB'\n        # This is the total weight of the entire shipment. Shipments may\n        # contain more than one package.\n        self.RequestedShipment.TotalWeight = total_weight\n\n        # This is the top level data structure Shipper Party information.\n        shipper_party = self.client.factory.create('Party')\n        shipper_party.Address = self.client.factory.create('Address')\n        shipper_party.Contact = self.client.factory.create('Contact')\n\n        # Link the Shipper Party to our master data structure.\n        self.RequestedShipment.Shipper = shipper_party\n\n        # This is the top level data structure for RecipientParty information.\n        recipient_party = self.client.factory.create('Party')\n        recipient_party.Contact = self.client.factory.create('Contact')\n        recipient_party.Address = self.client.factory.create('Address')\n\n        # Link the RecipientParty object to our master data structure.\n        self.RequestedShipment.Recipient = recipient_party\n\n        payor = self.client.factory.create('Payor')\n        # Grab the account number from the FedexConfig object by default.\n        # Assume US.\n        payor.ResponsibleParty = self.client.factory.create('Party')\n        payor.ResponsibleParty.Address = self.client.factory.create('Address')\n        payor.ResponsibleParty.Address.CountryCode = 'US'\n\n        # ShippingChargesPayment WSDL object default values.\n        shipping_charges_payment = self.client.factory.create('Payment')\n        shipping_charges_payment.Payor = payor\n        shipping_charges_payment.PaymentType = 'SENDER'\n        self.RequestedShipment.ShippingChargesPayment = shipping_charges_payment\n\n        self.RequestedShipment.LabelSpecification = self.client.factory.create('LabelSpecification')\n\n        # NONE, PREFERRED or LIST\n        self.RequestedShipment.RateRequestTypes = ['PREFERRED']\n\n        # Start with no packages, user must add them.\n        self.RequestedShipment.PackageCount = 0\n        self.RequestedShipment.RequestedPackageLineItems = []\n\n        # This is good to review if you'd like to see what the data structure\n        # looks like.\n        self.logger.debug(self.RequestedShipment)", "response": "Prepare the WSDL objects for the shipment."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _assemble_and_send_validation_request(self):\n\n        # Fire off the query.\n        return self.client.service.validateShipment(\n                WebAuthenticationDetail=self.WebAuthenticationDetail,\n                ClientDetail=self.ClientDetail,\n                TransactionDetail=self.TransactionDetail,\n                Version=self.VersionId,\n                RequestedShipment=self.RequestedShipment)", "response": "Assemble and send a validation request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nassembling the request and send it to FedexBaseService.", "response": "def _assemble_and_send_request(self):\n        \"\"\"\n        Fires off the Fedex request.\n        \n        @warning: NEVER CALL THIS METHOD DIRECTLY. CALL send_request(), \n            WHICH RESIDES ON FedexBaseService AND IS INHERITED.\n        \"\"\"\n\n        # Fire off the query.\n        return self.client.service.processShipment(\n                WebAuthenticationDetail=self.WebAuthenticationDetail,\n                ClientDetail=self.ClientDetail,\n                TransactionDetail=self.TransactionDetail,\n                Version=self.VersionId,\n                RequestedShipment=self.RequestedShipment)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_package(self, package_item):\n\n        self.RequestedShipment.RequestedPackageLineItems.append(package_item)\n        package_weight = package_item.Weight.Value\n        self.RequestedShipment.TotalWeight.Value += package_weight\n        self.RequestedShipment.PackageCount += 1", "response": "Adds a package to the shipment request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprepare the WSDL data structures for the user.", "response": "def _prepare_wsdl_objects(self):\n        \"\"\"\n        Preps the WSDL data structures for the user.\n        \"\"\"\n\n        self.DeletionControlType = self.client.factory.create('DeletionControlType')\n        self.TrackingId = self.client.factory.create('TrackingId')\n        self.TrackingId.TrackingIdType = self.client.factory.create('TrackingIdType')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nassemble and send a request to FedexBaseService.", "response": "def _assemble_and_send_request(self):\n        \"\"\"\n        Fires off the Fedex request.\n        \n        @warning: NEVER CALL THIS METHOD DIRECTLY. CALL send_request(), WHICH RESIDES\n            ON FedexBaseService AND IS INHERITED.\n        \"\"\"\n\n        client = self.client\n        # Fire off the query.\n        return client.service.deleteShipment(\n                WebAuthenticationDetail=self.WebAuthenticationDetail,\n                ClientDetail=self.ClientDetail,\n                TransactionDetail=self.TransactionDetail,\n                Version=self.VersionId,\n                ShipTimestamp=datetime.datetime.now(),\n                TrackingId=self.TrackingId,\n                DeletionControl=self.DeletionControlType)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _prepare_wsdl_objects(self):\n            self.UploadDocumentsRequest = self.client.factory.create('UploadDocumentsRequest')\n            self.OriginCountryCode  =None\n            self.DestinationCountryCode  =None\n            self.Usage  ='ELECTRONIC_TRADE_DOCUMENTS'#Default Usage\n            self.Documents = []\n            self.UploadDocumentsRequest.Documents = []\n            self.logger.debug(self.UploadDocumentsRequest)", "response": "Prepare WSDL objects for the shipment."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nassemble and send a request to Fedex.", "response": "def _assemble_and_send_request(self):\n            \"\"\"\n            Fires off the Fedex request.\n\n            @warning: NEVER CALL THIS METHOD DIRECTLY. CALL send_request(),\n                WHICH RESIDES ON FedexBaseService AND IS INHERITED.\n            \"\"\"\n\n            # Fire off the query.\n            return self.client.service.uploadDocuments(\n                    WebAuthenticationDetail=self.WebAuthenticationDetail,\n                    ClientDetail=self.ClientDetail,\n                    TransactionDetail=self.TransactionDetail,\n                    Version=self.VersionId,\n                    Documents=self.Documents,\n                    Usage = self.Usage,\n                    OriginCountryCode = self.OriginCountryCode,\n                    DestinationCountryCode = self.DestinationCountryCode,\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __set_web_authentication_detail(self):\n\n        # Start of the authentication stuff.\n        web_authentication_credential = self.client.factory.create('WebAuthenticationCredential')\n        web_authentication_credential.Key = self.config_obj.key\n        web_authentication_credential.Password = self.config_obj.password\n\n        # Encapsulates the auth credentials.\n        web_authentication_detail = self.client.factory.create('WebAuthenticationDetail')\n        web_authentication_detail.UserCredential = web_authentication_credential\n\n        # Set Default ParentCredential\n        if hasattr(web_authentication_detail, 'ParentCredential'):\n            web_authentication_detail.ParentCredential = web_authentication_credential\n\n        self.WebAuthenticationDetail = web_authentication_detail", "response": "Sets up the WebAuthenticationCredential node. This is required for all the web authentication requests."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __set_client_detail(self, *args, **kwargs):\n\n        client_detail = self.client.factory.create('ClientDetail')\n        client_detail.AccountNumber = self.config_obj.account_number\n        client_detail.MeterNumber = self.config_obj.meter_number\n        client_detail.IntegratorId = self.config_obj.integrator_id\n        if hasattr(client_detail, 'Region'):\n            client_detail.Region = self.config_obj.express_region_code\n\n        client_language_code = kwargs.get('client_language_code', None)\n        client_locale_code = kwargs.get('client_locale_code', None)\n\n        if hasattr(client_detail, 'Localization') and (client_language_code or client_locale_code):\n            localization = self.client.factory.create('Localization')\n\n            if client_language_code:\n                localization.LanguageCode = client_language_code\n\n            if client_locale_code:\n                localization.LocaleCode = client_locale_code\n\n            client_detail.Localization = localization\n\n        self.ClientDetail = client_detail", "response": "Sets up the ClientDetail node which is required for all shipping resources related requests."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the TransactionDetail attribute of the object.", "response": "def __set_transaction_detail(self, *args, **kwargs):\n        \"\"\"\n        Checks kwargs for 'customer_transaction_id' and sets it if present.\n        \"\"\"\n\n        customer_transaction_id = kwargs.get('customer_transaction_id', None)\n        if customer_transaction_id:\n            transaction_detail = self.client.factory.create('TransactionDetail')\n            transaction_detail.CustomerTransactionId = customer_transaction_id\n            self.logger.debug(transaction_detail)\n            self.TransactionDetail = transaction_detail"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __set_version_id(self):\n\n        version_id = self.client.factory.create('VersionId')\n        version_id.ServiceId = self._version_info['service_id']\n        version_id.Major = self._version_info['major']\n        version_id.Intermediate = self._version_info['intermediate']\n        version_id.Minor = self._version_info['minor']\n        self.logger.debug(version_id)\n        self.VersionId = version_id", "response": "Sets the version_id of the child request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck the response for Fedex errors and raises FedexFailure if any.", "response": "def __check_response_for_fedex_error(self):\n        \"\"\"\n        This checks the response for general Fedex errors that aren't related\n        to any one WSDL.\n        \"\"\"\n\n        if self.response.HighestSeverity == \"FAILURE\":\n            for notification in self.response.Notifications:\n                if notification.Severity == \"FAILURE\":\n                    raise FedexFailure(notification.Code,\n                                       notification.Message)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck for errors that are specific to the current service module.", "response": "def _check_response_for_request_errors(self):\n        \"\"\"\n        Override this in each service module to check for errors that are\n        specific to that module. For example, invalid tracking numbers in\n        a Tracking request.\n        \"\"\"\n\n        if self.response.HighestSeverity == \"ERROR\":\n            for notification in self.response.Notifications:\n                if notification.Severity == \"ERROR\":\n                    raise FedexError(notification.Code,\n                                     notification.Message)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_response_for_request_warnings(self):\n\n        if self.response.HighestSeverity in (\"NOTE\", \"WARNING\"):\n            for notification in self.response.Notifications:\n                if notification.Severity in (\"NOTE\", \"WARNING\"):\n                    self.logger.warning(FedexFailure(notification.Code,\n                                                     notification.Message))", "response": "Check for any errors that are specific to a particular service module and log them if they are not."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend the request to the child object.", "response": "def send_request(self, send_function=None):\n        \"\"\"\n        Sends the assembled request on the child object.\n        @type send_function: function reference\n        @keyword send_function: A function reference (passed without the\n            parenthesis) to a function that will send the request. This\n            allows for overriding the default function in cases such as\n            validation requests.\n        \"\"\"\n\n        # Send the request and get the response back.\n        try:\n            # If the user has overridden the send function, use theirs\n            # instead of the default.\n            if send_function:\n                # Follow the overridden function.\n                self.response = send_function()\n            else:\n                # Default scenario, business as usual.\n                self.response = self._assemble_and_send_request()\n        except suds.WebFault as fault:\n            # When this happens, throw an informative message reminding the\n            # user to check all required variables, making sure they are\n            # populated and valid\n            raise SchemaValidationError(fault.fault)\n\n        # Check the response for general Fedex errors/failures that aren't\n        # specific to any given WSDL/request.\n        self.__check_response_for_fedex_error()\n\n        # Check the response for errors specific to the particular request.\n        # This method can be overridden by a method on the child class object.\n        self._check_response_for_request_errors()\n\n        # Check the response for errors specific to the particular request.\n        # This method can be overridden by a method on the child class object.\n        self._check_response_for_request_warnings()\n\n        # Debug output. (See Request and Response output)\n        self.logger.debug(\"== FEDEX QUERY RESULT ==\")\n        self.logger.debug(self.response)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassemble and send the request.", "response": "def _assemble_and_send_request(self):\n        \"\"\"\n        Fires off the Fedex request.\n        \n        @warning: NEVER CALL THIS METHOD DIRECTLY. CALL send_request(), \n            WHICH RESIDES ON FedexBaseService AND IS INHERITED.\n        \"\"\"\n\n        # We get an exception like this when specifying an IntegratorId:\n        # suds.TypeNotFound: Type not found: 'IntegratorId'\n        # Setting it to None does not seem to appease it.\n        del self.ClientDetail.IntegratorId\n        self.logger.debug(self.WebAuthenticationDetail)\n        self.logger.debug(self.ClientDetail)\n        self.logger.debug(self.TransactionDetail)\n        self.logger.debug(self.VersionId)\n        # Fire off the query.\n        return self.client.service.addressValidation(\n                WebAuthenticationDetail=self.WebAuthenticationDetail,\n                ClientDetail=self.ClientDetail,\n                TransactionDetail=self.TransactionDetail,\n                Version=self.VersionId,\n                InEffectAsOfTimestamp=datetime.datetime.now(),\n                AddressesToValidate=self.AddressesToValidate)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _prepare_wsdl_objects(self):\n\n        self.SelectionDetails = self.client.factory.create('TrackSelectionDetail')\n\n        # Default to Fedex\n        self.SelectionDetails.CarrierCode = 'FDXE'\n\n        track_package_id = self.client.factory.create('TrackPackageIdentifier')\n\n        # Default to tracking number.\n        track_package_id.Type = 'TRACKING_NUMBER_OR_DOORTAG'\n\n        self.SelectionDetails.PackageIdentifier = track_package_id", "response": "Sets up the WSDL objects for the current session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking the response to see if there were any errors specific to the current WSDL.", "response": "def _check_response_for_request_errors(self):\n        \"\"\"\n        Checks the response to see if there were any errors specific to\n        this WSDL.\n        \"\"\"\n        if self.response.HighestSeverity == \"ERROR\":  # pragma: no cover\n            for notification in self.response.Notifications:\n                if notification.Severity == \"ERROR\":\n                    if \"Invalid tracking number\" in notification.Message:\n                        raise FedexInvalidTrackingNumber(\n                                notification.Code, notification.Message)\n                    else:\n                        raise FedexError(notification.Code, notification.Message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _assemble_and_send_request(self):\n\n        client = self.client\n        # Fire off the query.\n        return client.service.track(\n                WebAuthenticationDetail=self.WebAuthenticationDetail,\n                ClientDetail=self.ClientDetail,\n                TransactionDetail=self.TransactionDetail,\n                Version=self.VersionId,\n                SelectionDetails=self.SelectionDetails,\n                ProcessingOptions=self.ProcessingOptions)", "response": "Assemble the request and send it to Fedex."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _prepare_wsdl_objects(self):\n\n        # Default behavior is to not request transit information\n        self.ReturnTransitAndCommit = False\n\n        # This is the primary data structure for processShipment requests.\n        self.RequestedShipment = self.client.factory.create('RequestedShipment')\n        self.RequestedShipment.ShipTimestamp = datetime.datetime.now()\n\n        # Defaults for TotalWeight wsdl object.\n        total_weight = self.client.factory.create('Weight')\n        # Start at nothing.\n        total_weight.Value = 0.0\n        # Default to pounds.\n        total_weight.Units = 'LB'\n        # This is the total weight of the entire shipment. Shipments may\n        # contain more than one package.\n        self.RequestedShipment.TotalWeight = total_weight\n\n        # This is the top level data structure for Shipper information.\n        shipper = self.client.factory.create('Party')\n        shipper.Address = self.client.factory.create('Address')\n        shipper.Contact = self.client.factory.create('Contact')\n\n        # Link the ShipperParty to our master data structure.\n        self.RequestedShipment.Shipper = shipper\n\n        # This is the top level data structure for Recipient information.\n        recipient_party = self.client.factory.create('Party')\n        recipient_party.Contact = self.client.factory.create('Contact')\n        recipient_party.Address = self.client.factory.create('Address')\n        # Link the RecipientParty object to our master data structure.\n        self.RequestedShipment.Recipient = recipient_party\n\n        # Make sender responsible for payment by default.\n        self.RequestedShipment.ShippingChargesPayment = self.create_wsdl_object_of_type('Payment')\n        self.RequestedShipment.ShippingChargesPayment.PaymentType = 'SENDER'\n\n        # Start with no packages, user must add them.\n        self.RequestedShipment.PackageCount = 0\n        self.RequestedShipment.RequestedPackageLineItems = []\n\n        # This is good to review if you'd like to see what the data structure\n        # looks like.\n        self.logger.debug(self.RequestedShipment)", "response": "Prepare the WSDL objects for the shipment."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nassemble and send a request to FedexBaseService.", "response": "def _assemble_and_send_request(self):\n        \"\"\"\n        Fires off the Fedex request.\n        \n        @warning: NEVER CALL THIS METHOD DIRECTLY. CALL send_request(), \n            WHICH RESIDES ON FedexBaseService AND IS INHERITED.\n        \"\"\"\n\n        # Fire off the query.\n        return self.client.service.getRates(\n                WebAuthenticationDetail=self.WebAuthenticationDetail,\n                ClientDetail=self.ClientDetail,\n                TransactionDetail=self.TransactionDetail,\n                Version=self.VersionId,\n                RequestedShipment=self.RequestedShipment,\n                ReturnTransitAndCommit=self.ReturnTransitAndCommit)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef print_label(self, package_num=None):\n\n        if package_num:\n            packages = [\n                self.shipment.response.CompletedShipmentDetail.CompletedPackageDetails[package_num]\n            ]\n        else:\n            packages = self.shipment.response.CompletedShipmentDetail.CompletedPackageDetails\n\n        for package in packages:\n            label_binary = binascii.a2b_base64(package.Label.Parts[0].Image)\n            self._print_base64(label_binary)", "response": "Prints all of a shipment s labels or just one."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _print_base64(self, base64_data):\n\n        label_file = open(self.device, \"w\")\n        label_file.write(base64_data)\n        label_file.close()", "response": "This is a helper method that writes the base64 encoded string to the label printer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate the WSDL objects that are ready for the WSDL request.", "response": "def _prepare_wsdl_objects(self):\n        \"\"\"\n        Create the data structure and get it ready for the WSDL request.\n        \"\"\"\n\n        # Service defaults for objects that are required.\n        self.MultipleMatchesAction = 'RETURN_ALL'\n        self.Constraints = self.create_wsdl_object_of_type('SearchLocationConstraints')\n        self.Address = self.create_wsdl_object_of_type('Address')\n        self.LocationsSearchCriterion = 'ADDRESS'\n        self.SortDetail = self.create_wsdl_object_of_type('LocationSortDetail')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _assemble_and_send_request(self):\n\n        # We get an exception like this when specifying an IntegratorId:\n        # suds.TypeNotFound: Type not found: 'IntegratorId'\n        # Setting it to None does not seem to appease it.\n        del self.ClientDetail.IntegratorId\n        self.logger.debug(self.WebAuthenticationDetail)\n        self.logger.debug(self.ClientDetail)\n        self.logger.debug(self.TransactionDetail)\n        self.logger.debug(self.VersionId)\n        # Fire off the query.\n        return self.client.service.searchLocations(\n                WebAuthenticationDetail=self.WebAuthenticationDetail,\n                ClientDetail=self.ClientDetail,\n                TransactionDetail=self.TransactionDetail,\n                Version=self.VersionId,\n                LocationsSearchCriterion=self.LocationsSearchCriterion,\n                PhoneNumber=self.PhoneNumber,\n                MultipleMatchesAction=self.MultipleMatchesAction,\n                Constraints=self.Constraints,\n                Address=self.Address,\n                SortDetail=self.SortDetail)", "response": "Assemble and send a request to FedexBaseService."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking the response to see if there were any errors specific to the current WSDL.", "response": "def _check_response_for_request_errors(self):\n        \"\"\"\n        Checks the response to see if there were any errors specific to\n        this WSDL.\n        \"\"\"\n        if self.response.HighestSeverity == \"ERROR\":\n            for notification in self.response.Notifications:  # pragma: no cover\n                if notification.Severity == \"ERROR\":\n                    if \"Postal Code Not Found\" in notification.Message:\n                        raise FedexPostalCodeNotFound(notification.Code,\n                                                      notification.Message)\n\n                    elif \"Invalid Postal Code Format\" in self.response.Notifications:\n                        raise FedexInvalidPostalCodeFormat(notification.Code,\n                                                           notification.Message)\n                    else:\n                        raise FedexError(notification.Code,\n                                         notification.Message)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nassembles and send the request.", "response": "def _assemble_and_send_request(self):\n        \"\"\"\n        Fires off the Fedex request.\n        \n        @warning: NEVER CALL THIS METHOD DIRECTLY. CALL send_request(), WHICH RESIDES\n            ON FedexBaseService AND IS INHERITED.\n        \"\"\"\n\n        client = self.client\n\n        # We get an exception like this when specifying an IntegratorId:\n        # suds.TypeNotFound: Type not found: 'IntegratorId'\n        # Setting it to None does not seem to appease it.\n\n        del self.ClientDetail.IntegratorId\n\n        # Fire off the query.\n        response = client.service.postalCodeInquiry(WebAuthenticationDetail=self.WebAuthenticationDetail,\n                                                    ClientDetail=self.ClientDetail,\n                                                    TransactionDetail=self.TransactionDetail,\n                                                    Version=self.VersionId,\n                                                    PostalCode=self.PostalCode,\n                                                    CountryCode=self.CountryCode,\n                                                    CarrierCode=self.CarrierCode)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _prepare_wsdl_objects(self):\n        self.CarrierCode = 'FDXE'\n        self.Origin = self.client.factory.create('Address')\n        self.Destination = self.client.factory.create('Address')\n        self.ShipDate = datetime.date.today().isoformat()\n        self.Service = None\n        self.Packaging = 'YOUR_PACKAGING'", "response": "Create the data structure and get it ready for the WSDL request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nassembling and send a request to FedexBaseService.", "response": "def _assemble_and_send_request(self):\n        \"\"\"\n        Fires off the Fedex request.\n        \n        @warning: NEVER CALL THIS METHOD DIRECTLY. CALL send_request(), \n            WHICH RESIDES ON FedexBaseService AND IS INHERITED.\n        \"\"\"\n\n        # We get an exception like this when specifying an IntegratorId:\n        # suds.TypeNotFound: Type not found: 'IntegratorId'\n        # Setting it to None does not seem to appease it.\n        del self.ClientDetail.IntegratorId\n        self.logger.debug(self.WebAuthenticationDetail)\n        self.logger.debug(self.ClientDetail)\n        self.logger.debug(self.TransactionDetail)\n        self.logger.debug(self.VersionId)\n        # Fire off the query.\n        return self.client.service.serviceAvailability(\n                WebAuthenticationDetail=self.WebAuthenticationDetail,\n                ClientDetail=self.ClientDetail,\n                TransactionDetail=self.TransactionDetail,\n                Version=self.VersionId,\n                Origin=self.Origin,\n                Destination=self.Destination,\n                ShipDate=self.ShipDate,\n                CarrierCode=self.CarrierCode,\n                Service=self.Service,\n                Packaging=self.Packaging)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef basic_sobject_to_dict(obj):\n    if not hasattr(obj, '__keylist__'):\n        return obj\n    data = {}\n    fields = obj.__keylist__\n    for field in fields:\n        val = getattr(obj, field)\n        if isinstance(val, list):\n            data[field] = []\n            for item in val:\n                data[field].append(basic_sobject_to_dict(item))\n        else:\n            data[field] = basic_sobject_to_dict(val)\n    return data", "response": "Converts basic suds object to dict very quickly."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sobject_to_dict(obj, key_to_lower=False, json_serialize=False):\n    import datetime\n\n    if not hasattr(obj, '__keylist__'):\n        if json_serialize and isinstance(obj, (datetime.datetime, datetime.time, datetime.date)):\n            return obj.isoformat()\n        else:\n            return obj\n    data = {}\n    fields = obj.__keylist__\n    for field in fields:\n        val = getattr(obj, field)\n        if key_to_lower:\n            field = field.lower()\n        if isinstance(val, list):\n            data[field] = []\n            for item in val:\n                data[field].append(sobject_to_dict(item, json_serialize=json_serialize))\n        else:\n            data[field] = sobject_to_dict(val, json_serialize=json_serialize)\n    return data", "response": "Converts a suds object to a dict. Includes advanced features."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sobject_to_json(obj, key_to_lower=False):\n    import json\n    data = sobject_to_dict(obj, key_to_lower=key_to_lower, json_serialize=True)\n    return json.dumps(data)", "response": "Converts a suds object to a JSON string."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates the data structure and get it ready for the WSDL request.", "response": "def _prepare_wsdl_objects(self):\n        \"\"\"\n        Create the data structure and get it ready for the WSDL request.\n        \"\"\"\n        self.CarrierCode = 'FDXE'\n        self.RoutingCode = 'FDSD'\n        self.Address = self.client.factory.create('Address')\n        self.ShipDateTime = datetime.datetime.now().isoformat()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _assemble_and_send_request(self):\n\n        # We get an exception like this when specifying an IntegratorId:\n        # suds.TypeNotFound: Type not found: 'IntegratorId'\n        # Setting it to None does not seem to appease it.\n        del self.ClientDetail.IntegratorId\n        self.logger.debug(self.WebAuthenticationDetail)\n        self.logger.debug(self.ClientDetail)\n        self.logger.debug(self.TransactionDetail)\n        self.logger.debug(self.VersionId)\n        # Fire off the query.\n        return self.client.service.validatePostal(\n                WebAuthenticationDetail=self.WebAuthenticationDetail,\n                ClientDetail=self.ClientDetail,\n                TransactionDetail=self.TransactionDetail,\n                Version=self.VersionId,\n                Address=self.Address,\n                ShipDateTime=self.ShipDateTime,\n                CarrierCode=self.CarrierCode,\n                CheckForMismatch=self.CheckForMismatch,\n                RoutingCode=self.RoutingCode)", "response": "Assemble and send a request to FedexBaseService."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions to get potential tags for files using the file names.", "response": "def guess_tags(filename):\n    \"\"\"\n    Function to get potential tags for files using the file names.\n\n    :param filename: This field is the name of file.\n    \"\"\"\n    tags = []\n    stripped_filename = strip_zip_suffix(filename)\n    if stripped_filename.endswith('.vcf'):\n        tags.append('vcf')\n    if stripped_filename.endswith('.json'):\n        tags.append('json')\n    if stripped_filename.endswith('.csv'):\n        tags.append('csv')\n    return tags"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncollating local files as preperation for Open Humans upload.", "response": "def characterize_local_files(filedir, max_bytes=MAX_FILE_DEFAULT):\n    \"\"\"\n    Collate local file info as preperation for Open Humans upload.\n\n    Note: Files with filesize > max_bytes are not included in returned info.\n\n    :param filedir: This field is target directory to get files from.\n    :param max_bytes: This field is the maximum file size to consider. Its\n        default value is 128m.\n    \"\"\"\n    file_data = {}\n    logging.info('Characterizing files in {}'.format(filedir))\n    for filename in os.listdir(filedir):\n        filepath = os.path.join(filedir, filename)\n        file_stats = os.stat(filepath)\n        creation_date = arrow.get(file_stats.st_ctime).isoformat()\n        file_size = file_stats.st_size\n        if file_size <= max_bytes:\n            file_md5 = hashlib.md5()\n            with open(filepath, \"rb\") as f:\n                for chunk in iter(lambda: f.read(4096), b\"\"):\n                    file_md5.update(chunk)\n            md5 = file_md5.hexdigest()\n            file_data[filename] = {\n                'tags': guess_tags(filename),\n                'description': '',\n                'md5': md5,\n                'creation_date': creation_date,\n            }\n    return file_data"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck that the files listed in metadata exactly match files in target dir.", "response": "def validate_metadata(target_dir, metadata):\n    \"\"\"\n    Check that the files listed in metadata exactly match files in target dir.\n\n    :param target_dir: This field is the target directory from which to\n        match metadata\n    :param metadata: This field contains the metadata to be matched.\n    \"\"\"\n    if not os.path.isdir(target_dir):\n        print(\"Error: \" + target_dir + \" is not a directory\")\n        return False\n    file_list = os.listdir(target_dir)\n    for filename in file_list:\n        if filename not in metadata:\n            print(\"Error: \" + filename + \" present at\" + target_dir +\n                  \" not found in metadata file\")\n            return False\n    for filename in metadata:\n        if filename not in file_list:\n            print(\"Error: \" + filename + \" present in metadata file \" +\n                  \" not found on disk at: \" + target_dir)\n            return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_metadata_csv_single_user(csv_in, header, tags_idx):\n    metadata = {}\n    n_headers = len(header)\n    for index, row in enumerate(csv_in, 2):\n        if row[0] == \"\":\n            raise ValueError('Error: In row number ' + str(index) + ':' +\n                             ' \"filename\" must not be empty.')\n        if row[0] == 'None' and [x == 'NA' for x in row[1:]]:\n            break\n        if len(row) != n_headers:\n            raise ValueError('Error: In row number ' + str(index) + ':' +\n                             ' Number of columns (' + str(len(row)) +\n                             ') doesnt match Number of headings (' +\n                             str(n_headers) + ')')\n        metadata[row[0]] = {\n            header[i]: row[i] for i in range(1, len(header)) if\n            i != tags_idx\n        }\n        metadata[row[0]]['tags'] = [t.strip() for t in\n                                    row[tags_idx].split(',') if\n                                    t.strip()]\n    return metadata", "response": "Load the metadata as requested for a single user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_metadata_csv(input_filepath):\n    with open(input_filepath) as f:\n        csv_in = csv.reader(f)\n        header = next(csv_in)\n        if 'tags' in header:\n            tags_idx = header.index('tags')\n        else:\n            raise ValueError('\"tags\" is a compulsory column in metadata file.')\n        if header[0] == 'project_member_id':\n            if header[1] == 'filename':\n                metadata = load_metadata_csv_multi_user(csv_in, header,\n                                                        tags_idx)\n            else:\n                raise ValueError('The second column must be \"filename\"')\n        elif header[0] == 'filename':\n            metadata = load_metadata_csv_single_user(csv_in, header, tags_idx)\n        else:\n            raise ValueError('Incorrect Formatting of metadata. The first' +\n                             ' column for single user upload should be' +\n                             ' \"filename\". For multiuser uploads the first ' +\n                             'column should be \"project member id\" and the' +\n                             ' second column should be \"filename\"')\n    return metadata", "response": "Load metadata from a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate_date(date, project_member_id, filename):\n    try:\n        arrow.get(date)\n    except Exception:\n        return False\n    return True", "response": "Check if the date is in ISO 8601 format."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_single_file_metadata_valid(file_metadata, project_member_id, filename):\n    if project_member_id is not None:\n        if not project_member_id.isdigit() or len(project_member_id) != 8:\n            raise ValueError(\n                'Error: for project member id: ', project_member_id,\n                ' and filename: ', filename,\n                ' project member id must be of 8 digits from 0 to 9')\n    if 'description' not in file_metadata:\n        raise ValueError(\n            'Error: for project member id: ', project_member_id,\n            ' and filename: ', filename,\n            ' \"description\" is a required field of the metadata')\n\n    if not isinstance(file_metadata['description'], str):\n        raise ValueError(\n            'Error: for project member id: ', project_member_id,\n            ' and filename: ', filename,\n            ' \"description\" must be a string')\n\n    if 'tags' not in file_metadata:\n        raise ValueError(\n            'Error: for project member id: ', project_member_id,\n            ' and filename: ', filename,\n            ' \"tags\" is a required field of the metadata')\n\n    if not isinstance(file_metadata['tags'], list):\n        raise ValueError(\n            'Error: for project member id: ', project_member_id,\n            ' and filename: ', filename,\n            ' \"tags\" must be an array of strings')\n\n    if 'creation_date' in file_metadata:\n        if not validate_date(file_metadata['creation_date'], project_member_id,\n                             filename):\n            raise ValueError(\n                'Error: for project member id: ', project_member_id,\n                ' and filename: ', filename,\n                ' Dates must be in ISO 8601 format')\n\n    if 'md5' in file_metadata:\n        if not re.match(r'[a-f0-9]{32}$', file_metadata['md5'],\n                        flags=re.IGNORECASE):\n            raise ValueError(\n                'Error: for project member id: ', project_member_id,\n                ' and filename: ', filename,\n                ' Invalid MD5 specified')\n\n    return True", "response": "Checks if the file metadata fields like project member id description tags md5 and creation date are valid for a single file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef review_metadata_csv_single_user(filedir, metadata, csv_in, n_headers):\n    try:\n        if not validate_metadata(filedir, metadata):\n            return False\n        for filename, file_metadata in metadata.items():\n            is_single_file_metadata_valid(file_metadata, None, filename)\n    except ValueError as e:\n        print_error(e)\n        return False\n    return True", "response": "Check validity of metadata for single user."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks that all subfolders in the given directory are present in the metadata file.", "response": "def validate_subfolders(filedir, metadata):\n    \"\"\"\n    Check that all folders in the given directory have a corresponding\n    entry in the metadata file, and vice versa.\n\n    :param filedir: This field is the target directory from which to\n        match metadata\n    :param metadata: This field contains the metadata to be matched.\n    \"\"\"\n    if not os.path.isdir(filedir):\n        print(\"Error: \" + filedir + \" is not a directory\")\n        return False\n    subfolders = os.listdir(filedir)\n    for subfolder in subfolders:\n        if subfolder not in metadata:\n            print(\"Error: folder \" + subfolder +\n                  \" present on disk but not in metadata\")\n            return False\n    for subfolder in metadata:\n        if subfolder not in subfolders:\n            print(\"Error: folder \" + subfolder +\n                  \" present in metadata but not on disk\")\n            return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef review_metadata_csv_multi_user(filedir, metadata, csv_in, n_headers):\n    try:\n        if not validate_subfolders(filedir, metadata):\n            return False\n        for project_member_id, member_metadata in metadata.items():\n            if not validate_metadata(os.path.join\n                                     (filedir, project_member_id),\n                                     member_metadata):\n                return False\n            for filename, file_metadata in member_metadata.items():\n                is_single_file_metadata_valid(file_metadata, project_member_id,\n                                              filename)\n\n    except ValueError as e:\n        print_error(e)\n        return False\n    return True", "response": "Check validity of metadata for multi user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef review_metadata_csv(filedir, input_filepath):\n    try:\n        metadata = load_metadata_csv(input_filepath)\n    except ValueError as e:\n        print_error(e)\n        return False\n\n    with open(input_filepath) as f:\n        csv_in = csv.reader(f)\n        header = next(csv_in)\n        n_headers = len(header)\n        if header[0] == 'filename':\n            res = review_metadata_csv_single_user(filedir, metadata,\n                                                  csv_in, n_headers)\n            return res\n        if header[0] == 'project_member_id':\n            res = review_metadata_csv_multi_user(filedir, metadata,\n                                                 csv_in, n_headers)\n            return res", "response": "Check validity of metadata fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_metadata_to_filestream(filedir, filestream,\n                                 max_bytes=MAX_FILE_DEFAULT):\n    \"\"\"\n    Make metadata file for all files in a directory(helper function)\n\n    :param filedir: This field is the filepath of the directory whose csv\n        has to be made.\n    :param filestream: This field is a stream for writing to the csv.\n    :param max_bytes: This field is the maximum file size to consider. Its\n        default value is 128m.\n    \"\"\"\n    csv_out = csv.writer(filestream)\n    subdirs = [os.path.join(filedir, i) for i in os.listdir(filedir) if\n               os.path.isdir(os.path.join(filedir, i))]\n    if subdirs:\n        logging.info('Making metadata for subdirs of {}'.format(filedir))\n        if not all([re.match('^[0-9]{8}$', os.path.basename(d))\n                    for d in subdirs]):\n            raise ValueError(\"Subdirs not all project member ID format!\")\n        csv_out.writerow(['project_member_id', 'filename', 'tags',\n                          'description', 'md5', 'creation_date'])\n        for subdir in subdirs:\n            file_info = characterize_local_files(\n                filedir=subdir, max_bytes=max_bytes)\n            proj_member_id = os.path.basename(subdir)\n            if not file_info:\n                csv_out.writerow([proj_member_id, 'None',\n                                  'NA', 'NA', 'NA', 'NA'])\n                continue\n            for filename in file_info:\n                csv_out.writerow([proj_member_id,\n                                  filename,\n                                  ', '.join(file_info[filename]['tags']),\n                                  file_info[filename]['description'],\n                                  file_info[filename]['md5'],\n                                  file_info[filename]['creation_date'],\n                                  ])\n    else:\n        csv_out.writerow(['filename', 'tags',\n                          'description', 'md5', 'creation_date'])\n        file_info = characterize_local_files(\n            filedir=filedir, max_bytes=max_bytes)\n        for filename in file_info:\n            csv_out.writerow([filename,\n                              ', '.join(file_info[filename]['tags']),\n                              file_info[filename]['description'],\n                              file_info[filename]['md5'],\n                              file_info[filename]['creation_date'],\n                              ])", "response": "This function will write the metadata for all files in a directory and all subdirs of the file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mk_metadata_csv(filedir, outputfilepath, max_bytes=MAX_FILE_DEFAULT):\n    with open(outputfilepath, 'w') as filestream:\n        write_metadata_to_filestream(filedir, filestream, max_bytes)", "response": "Make metadata file for all files in a directory."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef download_file(download_url, target_filepath, max_bytes=MAX_FILE_DEFAULT):\n    response = requests.get(download_url, stream=True)\n    size = int(response.headers['Content-Length'])\n\n    if _exceeds_size(size, max_bytes, target_filepath) is True:\n        return response\n\n    logging.info('Downloading {} ({})'.format(\n        target_filepath, format_size(size)))\n\n    if os.path.exists(target_filepath):\n        stat = os.stat(target_filepath)\n        if stat.st_size == size:\n            logging.info('Skipping, file exists and is the right '\n                         'size: {}'.format(target_filepath))\n            return response\n        else:\n            logging.info('Replacing, file exists and is the wrong '\n                         'size: {}'.format(target_filepath))\n            os.remove(target_filepath)\n\n    with open(target_filepath, 'wb') as f:\n        for chunk in response.iter_content(chunk_size=8192):\n            if chunk:\n                f.write(chunk)\n\n    logging.info('Download complete: {}'.format(target_filepath))\n    return response", "response": "Download a file from the url and save it to the target_filepath."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread the project member id from a file.", "response": "def read_id_list(filepath):\n    \"\"\"\n    Get project member id from a file.\n\n    :param filepath: This field is the path of file to read.\n    \"\"\"\n    if not filepath:\n        return None\n    id_list = []\n    with open(filepath) as f:\n        for line in f:\n            line = line.rstrip()\n            if not re.match('^[0-9]{8}$', line):\n                raise('Each line in whitelist or blacklist is expected '\n                      'to contain an eight digit ID, and nothing else.')\n            else:\n                id_list.append(line)\n    return id_list"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_log_level(debug, verbose):\n    if debug:\n        logging.basicConfig(level=logging.DEBUG)\n    elif verbose:\n        logging.basicConfig(level=logging.INFO)", "response": "Function for setting the logging level."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncommanding line function for downloading data from the cluster members to the specified directory.", "response": "def download_cli(directory, master_token=None, member=None, access_token=None,\n                 source=None, project_data=False, max_size='128m',\n                 verbose=False, debug=False, memberlist=None,\n                 excludelist=None, id_filename=False):\n    \"\"\"\n    Command line function for downloading data from project members to the\n    target directory. For more information visit\n    :func:`download<ohapi.command_line.download>`.\n    \"\"\"\n    return download(directory, master_token, member, access_token, source,\n                    project_data, max_size, verbose, debug, memberlist,\n                    excludelist, id_filename)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef download(directory, master_token=None, member=None, access_token=None,\n             source=None, project_data=False, max_size='128m', verbose=False,\n             debug=False, memberlist=None, excludelist=None,\n             id_filename=False):\n    \"\"\"\n    Download data from project members to the target directory.\n\n    Unless this is a member-specific download, directories will be\n    created for each project member ID. Also, unless a source is specified,\n    all shared sources are downloaded and data is sorted into subdirectories\n    according to source.\n\n    Projects can optionally return data to Open Humans member accounts.\n    If project_data is True (or the \"--project-data\" flag is used), this data\n    (the project's own data files, instead of data from other sources) will be\n    downloaded for each member.\n\n    :param directory: This field is the target directory to download data.\n    :param master_token: This field is the master access token for the project.\n        It's default value is None.\n    :param member: This field is specific member whose project data is\n        downloaded. It's default value is None.\n    :param access_token: This field is the user specific access token. It's\n        default value is None.\n    :param source: This field is the data source. It's default value is None.\n    :param project_data: This field is data related to particular project. It's\n        default value is False.\n    :param max_size: This field is the maximum file size. It's default value is\n        128m.\n    :param verbose: This boolean field is the logging level. It's default value\n        is False.\n    :param debug: This boolean field is the logging level. It's default value\n        is False.\n    :param memberlist: This field is list of members whose data will be\n        downloaded. It's default value is None.\n    :param excludelist: This field is list of members whose data will be\n        skipped. It's default value is None.\n    \"\"\"\n    set_log_level(debug, verbose)\n\n    if (memberlist or excludelist) and (member or access_token):\n        raise UsageError('Please do not provide a memberlist or excludelist '\n                         'when retrieving data for a single member.')\n    memberlist = read_id_list(memberlist)\n    excludelist = read_id_list(excludelist)\n    if not (master_token or access_token) or (master_token and access_token):\n        raise UsageError('Please specify either a master access token (-T), '\n                         'or an OAuth2 user access token (-t).')\n    if (source and project_data):\n        raise UsageError(\"It doesn't make sense to use both 'source' and\"\n                         \"'project-data' options!\")\n\n    if master_token:\n        project = OHProject(master_access_token=master_token)\n        if member:\n            if project_data:\n                project.download_member_project_data(\n                    member_data=project.project_data[member],\n                    target_member_dir=directory,\n                    max_size=max_size,\n                    id_filename=id_filename)\n            else:\n                project.download_member_shared(\n                    member_data=project.project_data[member],\n                    target_member_dir=directory,\n                    source=source,\n                    max_size=max_size,\n                    id_filename=id_filename)\n        else:\n            project.download_all(target_dir=directory,\n                                 source=source,\n                                 max_size=max_size,\n                                 memberlist=memberlist,\n                                 excludelist=excludelist,\n                                 project_data=project_data,\n                                 id_filename=id_filename)\n    else:\n        member_data = exchange_oauth2_member(access_token, all_files=True)\n        if project_data:\n            OHProject.download_member_project_data(member_data=member_data,\n                                                   target_member_dir=directory,\n                                                   max_size=max_size,\n                                                   id_filename=id_filename)\n        else:\n            OHProject.download_member_shared(member_data=member_data,\n                                             target_member_dir=directory,\n                                             source=source,\n                                             max_size=max_size,\n                                             id_filename=id_filename)", "response": "Download data from project members to target directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef download_metadata_cli(master_token, output_csv, verbose=False,\n                          debug=False):\n    \"\"\"\n    Command line function for downloading metadata.\n    For more information visit\n    :func:`download_metadata<ohapi.command_line.download_metadata>`.\n    \"\"\"\n    return download_metadata(master_token, output_csv, verbose, debug)", "response": "Command line function for downloading metadata."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndownload metadata for a project in Open Humans.", "response": "def download_metadata(master_token, output_csv, verbose=False, debug=False):\n    \"\"\"\n    Output CSV with metadata for a project's downloadable files in Open Humans.\n\n    :param master_token: This field is the master access token for the project.\n    :param output_csv: This field is the target csv file to which metadata is\n        written.\n    :param verbose: This boolean field is the logging level. It's default value\n        is False.\n    :param debug: This boolean field is the logging level. It's default value\n        is False.\n    \"\"\"\n    set_log_level(debug, verbose)\n\n    project = OHProject(master_access_token=master_token)\n\n    with open(output_csv, 'w') as f:\n        csv_writer = csv.writer(f)\n        header = ['project_member_id', 'data_source', 'file_basename',\n                  'file_upload_date']\n        csv_writer.writerow(header)\n        for member_id in project.project_data:\n            if not project.project_data[member_id]['data']:\n                csv_writer.writerow([member_id, 'NA', 'None', 'NA'])\n            else:\n                for data_item in project.project_data[member_id]['data']:\n                    logging.debug(data_item)\n                    csv_writer.writerow([\n                        member_id, data_item['source'],\n                        data_item['basename'].encode('utf-8'),\n                        data_item['created']])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncommanding line function for uploading metadata files.", "response": "def upload_metadata_cli(directory, create_csv='', review='',\n                        max_size='128m', verbose=False, debug=False):\n    \"\"\"\n    Command line function for drafting or reviewing metadata files.\n    For more information visit\n    :func:`upload_metadata<ohapi.command_line.upload_metadata>`.\n    \"\"\"\n    return upload_metadata(directory, create_csv, review,\n                           max_size, verbose, debug)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef upload_metadata(directory, create_csv='', review='',\n                    max_size='128m', verbose=False, debug=False):\n    \"\"\"\n    Draft or review metadata files for uploading files to Open Humans.\n    The target directory should either represent files for a single member (no\n    subdirectories), or contain a subdirectory for each project member ID.\n\n    :param directory: This field is the directory for which metadata has to be\n        created.\n    :param create_csv: This field is the output filepath to which csv file\n        will be written.\n    :param max_size: This field is the maximum file size. It's default value is\n        None.\n    :param verbose: This boolean field is the logging level. It's default value\n        is False.\n    :param debug: This boolean field is the logging level. It's default value\n        is False.\n    \"\"\"\n    set_log_level(debug, verbose)\n\n    max_bytes = parse_size(max_size)\n    if create_csv and review:\n        raise ValueError(\"Either create_csv must be true or review must be \" +\n                         \"true but not both\")\n    if review:\n        if review_metadata_csv(directory, review):\n            print(\"The metadata file has been reviewed and is valid.\")\n    elif create_csv:\n        mk_metadata_csv(directory, create_csv, max_bytes=max_bytes)\n    else:\n        raise ValueError(\"Either create_csv must be true or review must be \" +\n                         \"true but not both should be false\")", "response": "Uploads metadata files to Open Humans."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef upload_cli(directory, metadata_csv, master_token=None, member=None,\n               access_token=None, safe=False, sync=False, max_size='128m',\n               mode='default', verbose=False, debug=False):\n    \"\"\"\n    Command line function for uploading files to OH.\n    For more information visit\n    :func:`upload<ohapi.command_line.upload>`.\n    \"\"\"\n    return upload(directory, metadata_csv, master_token, member,\n                  access_token, safe, sync, max_size,\n                  mode, verbose, debug)", "response": "Command line function for uploading files to OH."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nuploading files to Open Humans member accounts.", "response": "def upload(directory, metadata_csv, master_token=None, member=None,\n           access_token=None, safe=False, sync=False, max_size='128m',\n           mode='default', verbose=False, debug=False):\n    \"\"\"\n    Upload files for the project to Open Humans member accounts.\n\n    If using a master access token and not specifying member ID:\n\n    (1) Files should be organized in subdirectories according to project\n    member ID, e.g.:\n\n        main_directory/01234567/data.json\n        main_directory/12345678/data.json\n        main_directory/23456789/data.json\n\n    (2) The metadata CSV should have the following format:\n\n        1st column: Project member ID\n        2nd column: filenames\n        3rd & additional columns: Metadata fields (see below)\n\n    If uploading for a specific member:\n    (1) The local directory should not contain subdirectories.\n    (2) The metadata CSV should have the following format:\n    1st column: filenames\n    2nd & additional columns: Metadata fields (see below)\n\n    The default behavior is to overwrite files with matching filenames on\n    Open Humans, but not otherwise delete files. (Use --safe or --sync to\n    change this behavior.)\n\n    If included, the following metadata columns should be correctly formatted:\n    'tags': should be comma-separated strings\n    'md5': should match the file's md5 hexdigest\n    'creation_date', 'start_date', 'end_date': ISO 8601 dates or datetimes\n\n    Other metedata fields (e.g. 'description') can be arbitrary strings.\n    Either specify sync as True or safe as True but not both.\n\n    :param directory: This field is the target directory from which data will\n        be uploaded.\n    :param metadata_csv: This field is the filepath of the metadata csv file.\n    :param master_token: This field is the master access token for the project.\n        It's default value is None.\n    :param member: This field is specific member whose project data is\n        downloaded. It's default value is None.\n    :param access_token: This field is the user specific access token. It's\n        default value is None.\n    :param safe: This boolean field will overwrite matching filename. It's\n        default value is False.\n    :param sync: This boolean field will delete files on Open Humans that are\n        not in the local directory. It's default value is False.\n    :param max_size: This field is the maximum file size. It's default value is\n        None.\n    :param mode: This field takes three value default, sync, safe. It's default\n        value is 'default'.\n    :param verbose: This boolean field is the logging level. It's default value\n        is False.\n    :param debug: This boolean field is the logging level. It's default value\n        is False.\n    \"\"\"\n    if safe and sync:\n        raise UsageError('Safe (--safe) and sync (--sync) modes are mutually '\n                         'incompatible!')\n    if not (master_token or access_token) or (master_token and access_token):\n        raise UsageError('Please specify either a master access token (-T), '\n                         'or an OAuth2 user access token (-t).')\n\n    set_log_level(debug, verbose)\n\n    if sync:\n        mode = 'sync'\n    elif safe:\n        mode = 'safe'\n\n    metadata = load_metadata_csv(metadata_csv)\n\n    subdirs = [i for i in os.listdir(directory) if\n               os.path.isdir(os.path.join(directory, i))]\n    if subdirs:\n        if not all([re.match(r'^[0-9]{8}$', d) for d in subdirs]):\n            raise UsageError(\n                \"Subdirs expected to match project member ID format!\")\n        if (master_token and member) or not master_token:\n            raise UsageError(\n                \"Subdirs shouldn't exist if uploading for specific member!\")\n        project = OHProject(master_access_token=master_token)\n        for member_id in subdirs:\n            subdir_path = os.path.join(directory, member_id)\n            project.upload_member_from_dir(\n                member_data=project.project_data[member_id],\n                target_member_dir=subdir_path,\n                metadata=metadata[member_id],\n                mode=mode,\n                access_token=project.master_access_token,\n            )\n    else:\n        if master_token and not (master_token and member):\n            raise UsageError('No member specified!')\n        if master_token:\n            project = OHProject(master_access_token=master_token)\n            project.upload_member_from_dir(\n                member_data=project.project_data[member],\n                target_member_dir=directory,\n                metadata=metadata,\n                mode=mode,\n                access_token=project.master_access_token,\n            )\n        else:\n            member_data = exchange_oauth2_member(access_token)\n            OHProject.upload_member_from_dir(\n                member_data=member_data,\n                target_member_dir=directory,\n                metadata=metadata,\n                mode=mode,\n                access_token=access_token,\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef oauth_token_exchange_cli(client_id, client_secret, redirect_uri,\n                             base_url=OH_BASE_URL, code=None,\n                             refresh_token=None):\n    \"\"\"\n    Command line function for obtaining the refresh token/code.\n    For more information visit\n    :func:`oauth2_token_exchange<ohapi.api.oauth2_token_exchange>`.\n    \"\"\"\n    print(oauth2_token_exchange(client_id, client_secret, redirect_uri,\n                                base_url, code, refresh_token))", "response": "Command line function for obtaining the refresh token."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef oauth2_auth_url_cli(redirect_uri=None, client_id=None,\n                        base_url=OH_BASE_URL):\n    \"\"\"\n    Command line function for obtaining the Oauth2 url.\n    For more information visit\n    :func:`oauth2_auth_url<ohapi.api.oauth2_auth_url>`.\n    \"\"\"\n    result = oauth2_auth_url(redirect_uri, client_id, base_url)\n    print('The requested URL is : \\r')\n    print(result)", "response": "Command line function for obtaining the Oauth2 url."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef message_cli(subject, message_body, access_token, all_members=False,\n                project_member_ids=None, base_url=OH_BASE_URL,\n                verbose=False, debug=False):\n    \"\"\"\n    Command line function for sending email to a single user or in bulk.\n    For more information visit\n    :func:`message<ohapi.api.message>`.\n\n    \"\"\"\n    if project_member_ids:\n        project_member_ids = re.split(r'[ ,\\r\\n]+', project_member_ids)\n    return message(subject, message_body, access_token, all_members,\n                   project_member_ids, base_url)", "response": "Command line function for sending email to a single user or in bulk."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_cli(access_token, project_member_id, base_url=OH_BASE_URL,\n               file_basename=None, file_id=None, all_files=False):\n    \"\"\"\n    Command line function for deleting files.\n    For more information visit\n    :func:`delete_file<ohapi.api.delete_file>`.\n    \"\"\"\n    response = delete_file(access_token, project_member_id,\n                           base_url, file_basename, file_id, all_files)\n    if (response.status_code == 200):\n        print(\"File deleted successfully\")\n    else:\n        print(\"Bad response while deleting file.\")", "response": "Command line function for deleting files."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef public_data_download_cli(source, username, directory, max_size, quiet,\n                             debug):\n    \"\"\"\n    Command line tools for downloading public data.\n    \"\"\"\n    return public_download(source, username, directory, max_size, quiet, debug)", "response": "Command line tools for downloading public data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading a file from a url.", "response": "def download_url(result, directory, max_bytes):\n    \"\"\"\n    Download a file.\n\n    :param result: This field contains a url from which data will be\n        downloaded.\n    :param directory: This field is the target directory to which data will be\n        downloaded.\n    :param max_bytes: This field is the maximum file size in bytes.\n    \"\"\"\n    response = requests.get(result['download_url'], stream=True)\n\n    # TODO: make this more robust by parsing the URL\n    filename = response.url.split('/')[-1]\n    filename = re.sub(r'\\?.*$', '', filename)\n    filename = '{}-{}'.format(result['user']['id'], filename)\n\n    size = int(response.headers['Content-Length'])\n\n    if size > max_bytes:\n        logging.info('Skipping {}, {} > {}'.format(filename, format_size(size),\n                                                   format_size(max_bytes)))\n\n        return\n\n    logging.info('Downloading {} ({})'.format(filename, format_size(size)))\n\n    output_path = os.path.join(directory, filename)\n\n    try:\n        stat = os.stat(output_path)\n\n        if stat.st_size == size:\n            logging.info('Skipping \"{}\"; exists and is the right size'.format(\n                filename))\n\n            return\n        else:\n            logging.info('Removing \"{}\"; exists and is the wrong size'.format(\n                filename))\n\n            os.remove(output_path)\n    except OSError:\n        # TODO: check errno here?\n        pass\n\n    with open(output_path, 'wb') as f:\n        total_length = response.headers.get('content-length')\n        total_length = int(total_length)\n        dl = 0\n        for chunk in response.iter_content(chunk_size=8192):\n            if chunk:\n                dl += len(chunk)\n                f.write(chunk)\n                d = int(50 * dl / total_length)\n                sys.stdout.write(\"\\r[%s%s]%d%s\" % ('.' * d,\n                                                   '' * (50 - d),\n                                                   d * 2,\n                                                   '%'))\n                sys.stdout.flush\n        print(\"\\n\")\n\n    logging.info('Downloaded {}'.format(filename))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads public data from Open Humans.", "response": "def download(source=None, username=None, directory='.', max_size='128m',\n             quiet=None, debug=None):\n    \"\"\"\n    Download public data from Open Humans.\n\n    :param source: This field is the data source from which to download. It's\n        default value is None.\n    :param username: This fiels is username of user. It's default value is\n        None.\n    :param directory: This field is the target directory to which data is\n        downloaded.\n    :param max_size: This field is the maximum file size. It's default value is\n        128m.\n    :param quiet: This field is the logging level. It's default value is\n        None.\n    :param debug: This field is the logging level. It's default value is\n        None.\n    \"\"\"\n    if debug:\n        logging.basicConfig(level=logging.DEBUG)\n    elif quiet:\n        logging.basicConfig(level=logging.ERROR)\n    else:\n        logging.basicConfig(level=logging.INFO)\n\n    logging.debug(\"Running with source: '{}'\".format(source) +\n                  \" and username: '{}'\".format(username) +\n                  \" and directory: '{}'\".format(directory) +\n                  \" and max-size: '{}'\".format(max_size))\n\n    signal.signal(signal.SIGINT, signal_handler_cb)\n\n    max_bytes = parse_size(max_size)\n\n    options = {}\n\n    if source:\n        options['source'] = source\n\n    if username:\n        options['username'] = username\n\n    page = '{}?{}'.format(BASE_URL_API, urlencode(options))\n\n    results = []\n    counter = 1\n\n    logging.info('Retrieving metadata')\n\n    while True:\n        logging.info('Retrieving page {}'.format(counter))\n\n        response = get_page(page)\n        results = results + response['results']\n\n        if response['next']:\n            page = response['next']\n        else:\n            break\n\n        counter += 1\n\n    logging.info('Downloading {} files'.format(len(results)))\n\n    download_url_partial = partial(download_url, directory=directory,\n                                   max_bytes=max_bytes)\n\n    with concurrent.futures.ProcessPoolExecutor(max_workers=4) as executor:\n        for value in executor.map(download_url_partial, results):\n            if value:\n                logging.info(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfunction returns which members have joined each activity.", "response": "def get_members_by_source(base_url=BASE_URL_API):\n    \"\"\"\n    Function returns which members have joined each activity.\n\n    :param base_url: It is URL: `https://www.openhumans.org/api/public-data`.\n    \"\"\"\n    url = '{}members-by-source/'.format(base_url)\n    response = get_page(url)\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_sources_by_member(base_url=BASE_URL_API, limit=LIMIT_DEFAULT):\n    url = '{}sources-by-member/'.format(base_url)\n    page = '{}?{}'.format(url, urlencode({'limit': limit}))\n    results = []\n    while True:\n        data = get_page(page)\n        results = results + data['results']\n        if data['next']:\n            page = data['next']\n        else:\n            break\n    return results", "response": "Function returns which activities each member has joined."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_member_file_data(member_data, id_filename=False):\n        file_data = {}\n        for datafile in member_data['data']:\n            if id_filename:\n                basename = '{}.{}'.format(datafile['id'], datafile['basename'])\n            else:\n                basename = datafile['basename']\n            if (basename not in file_data or\n                    arrow.get(datafile['created']) >\n                    arrow.get(file_data[basename]['created'])):\n                file_data[basename] = datafile\n        return file_data", "response": "Helper function to get file data related to a member of a project."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_data(self):\n        url = ('https://www.openhumans.org/api/direct-sharing/project/'\n               'members/?access_token={}'.format(self.master_access_token))\n        results = get_all_results(url)\n        self.project_data = dict()\n        for result in results:\n            self.project_data[result['project_member_id']] = result\n            if len(result['data']) < result['file_count']:\n                member_data = get_page(result['exchange_member'])\n                final_data = member_data['data']\n                while member_data['next']:\n                    member_data = get_page(member_data['next'])\n                    final_data = final_data + member_data['data']\n                self.project_data[\n                    result['project_member_id']]['data'] = final_data\n        return self.project_data", "response": "Returns data for all users including shared data files."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef download_member_project_data(cls, member_data, target_member_dir,\n                                     max_size=MAX_SIZE_DEFAULT,\n                                     id_filename=False):\n        \"\"\"\n        Download files to sync a local dir to match OH member project data.\n\n        :param member_data: This field is data related to member in a project.\n        :param target_member_dir: This field is the target directory where data\n            will be downloaded.\n        :param max_size: This field is the maximum file size. It's default\n            value is 128m.\n        \"\"\"\n        logging.debug('Download member project data...')\n        sources_shared = member_data['sources_shared']\n        file_data = cls._get_member_file_data(member_data,\n                                              id_filename=id_filename)\n        for basename in file_data:\n            # This is using a trick to identify a project's own data in an API\n            # response, without knowing the project's identifier: if the data\n            # isn't a shared data source, it must be the project's own data.\n            if file_data[basename]['source'] in sources_shared:\n                continue\n            target_filepath = os.path.join(target_member_dir, basename)\n            download_file(download_url=file_data[basename]['download_url'],\n                          target_filepath=target_filepath,\n                          max_bytes=parse_size(max_size))", "response": "Download the data related to a member in a project."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef download_member_shared(cls, member_data, target_member_dir, source=None,\n                               max_size=MAX_SIZE_DEFAULT, id_filename=False):\n        \"\"\"\n        Download files to sync a local dir to match OH member shared data.\n\n        Files are downloaded to match their \"basename\" on Open Humans.\n        If there are multiple files with the same name, the most recent is\n        downloaded.\n\n        :param member_data: This field is data related to member in a project.\n        :param target_member_dir: This field is the target directory where data\n            will be downloaded.\n        :param source: This field is the source from which to download data.\n        :param max_size: This field is the maximum file size. It's default\n            value is 128m.\n        \"\"\"\n        logging.debug('Download member shared data...')\n        sources_shared = member_data['sources_shared']\n        file_data = cls._get_member_file_data(member_data,\n                                              id_filename=id_filename)\n\n        logging.info('Downloading member data to {}'.format(target_member_dir))\n        for basename in file_data:\n\n            # If not in sources shared, it's the project's own data. Skip.\n            if file_data[basename]['source'] not in sources_shared:\n                continue\n\n            # Filter source if specified. Determine target directory for file.\n            if source:\n                if source == file_data[basename]['source']:\n                    target_filepath = os.path.join(target_member_dir, basename)\n                else:\n                    continue\n            else:\n                source_data_dir = os.path.join(target_member_dir,\n                                               file_data[basename]['source'])\n                if not os.path.exists(source_data_dir):\n                    os.mkdir(source_data_dir)\n                target_filepath = os.path.join(source_data_dir, basename)\n\n            download_file(download_url=file_data[basename]['download_url'],\n                          target_filepath=target_filepath,\n                          max_bytes=parse_size(max_size))", "response": "Download all files related to a member in a project that are shared by other users."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndownloads all users from the specified project and member list.", "response": "def download_all(self, target_dir, source=None, project_data=False,\n                     memberlist=None, excludelist=None,\n                     max_size=MAX_SIZE_DEFAULT, id_filename=False):\n        \"\"\"\n        Download data for all users including shared data files.\n\n        :param target_dir: This field is the target directory to download data.\n        :param source: This field is the data source. It's default value is\n            None.\n        :param project_data: This field is data related to particular project.\n            It's default value is False.\n        :param memberlist: This field is list of members whose data will be\n            downloaded. It's default value is None.\n        :param excludelist: This field is list of members whose data will be\n            skipped. It's default value is None.\n        :param max_size: This field is the maximum file size. It's default\n            value is 128m.\n        \"\"\"\n        members = self.project_data.keys()\n        for member in members:\n            if not (memberlist is None) and member not in memberlist:\n                logging.debug('Skipping {}, not in memberlist'.format(member))\n                continue\n            if excludelist and member in excludelist:\n                logging.debug('Skipping {}, in excludelist'.format(member))\n                continue\n            member_dir = os.path.join(target_dir, member)\n            if not os.path.exists(member_dir):\n                os.mkdir(member_dir)\n            if project_data:\n                self.download_member_project_data(\n                    member_data=self.project_data[member],\n                    target_member_dir=member_dir,\n                    max_size=max_size,\n                    id_filename=id_filename)\n            else:\n                self.download_member_shared(\n                    member_data=self.project_data[member],\n                    target_member_dir=member_dir,\n                    source=source,\n                    max_size=max_size,\n                    id_filename=id_filename)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupload files from a target directory to an Open Humans member s account.", "response": "def upload_member_from_dir(member_data, target_member_dir, metadata,\n                               access_token, mode='default',\n                               max_size=MAX_SIZE_DEFAULT):\n        \"\"\"\n        Upload files in target directory to an Open Humans member's account.\n\n        The default behavior is to overwrite files with matching filenames on\n        Open Humans, but not otherwise delete files.\n\n        If the 'mode' parameter is 'safe': matching filenames will not be\n        overwritten.\n\n        If the 'mode' parameter is 'sync': files on Open Humans that are not\n        in the local directory will be deleted.\n\n        :param member_data: This field is data related to member in a project.\n        :param target_member_dir: This field is the target directory from where\n            data will be uploaded.\n        :param metadata: This field is metadata for files to be uploaded.\n        :param access_token: This field is user specific access token.\n        :param mode: This field takes three value default, sync, safe. It's\n            default value is 'default'.\n        :param max_size: This field is the maximum file size. It's default\n            value is 128m.\n        \"\"\"\n        if not validate_metadata(target_member_dir, metadata):\n            raise ValueError('Metadata should match directory contents!')\n        project_data = {f['basename']: f for f in member_data['data'] if\n                        f['source'] not in member_data['sources_shared']}\n        for filename in metadata:\n            if filename in project_data and mode == 'safe':\n                logging.info('Skipping {}, remote exists with matching'\n                             ' name'.format(filename))\n                continue\n            filepath = os.path.join(target_member_dir, filename)\n            remote_file_info = (project_data[filename] if filename in\n                                project_data else None)\n            upload_aws(target_filepath=filepath,\n                       metadata=metadata[filename],\n                       access_token=access_token,\n                       project_member_id=member_data['project_member_id'],\n                       remote_file_info=remote_file_info)\n        if mode == 'sync':\n            for filename in project_data:\n                if filename not in metadata:\n                    logging.debug(\"Deleting {}\".format(filename))\n                    delete_file(\n                        file_basename=filename,\n                        access_token=access_token,\n                        project_member_id=member_data['project_member_id'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an OAuth2 authorization URL for a project, given Client ID. This function constructs an authorization URL for a user to follow. The user will be redirected to Authorize Open Humans data for our external application. An OAuth2 project on Open Humans is required for this to properly work. To learn more about Open Humans OAuth2 projects, go to: https://www.openhumans.org/direct-sharing/oauth2-features/ :param redirect_uri: This field is set to `None` by default. However, if provided, it appends it in the URL returned. :param client_id: This field is also set to `None` by default however, is a mandatory field for the final URL to work. It uniquely identifies a given OAuth2 project. :param base_url: It is this URL `https://www.openhumans.org`.", "response": "def oauth2_auth_url(redirect_uri=None, client_id=None, base_url=OH_BASE_URL):\n    \"\"\"\n    Returns an OAuth2 authorization URL for a project, given Client ID. This\n    function constructs an authorization URL for a user to follow.\n    The user will be redirected to Authorize Open Humans data for our external\n    application. An OAuth2 project on Open Humans is required for this to\n    properly work. To learn more about Open Humans OAuth2 projects, go to:\n    https://www.openhumans.org/direct-sharing/oauth2-features/\n\n    :param redirect_uri: This field is set to `None` by default. However, if\n        provided, it appends it in the URL returned.\n    :param client_id: This field is also set to `None` by default however,\n        is a mandatory field for the final URL to work. It uniquely identifies\n        a given OAuth2 project.\n    :param base_url: It is this URL `https://www.openhumans.org`.\n    \"\"\"\n    if not client_id:\n        client_id = os.getenv('OHAPI_CLIENT_ID')\n        if not client_id:\n            raise SettingsError(\n                \"Client ID not provided! Provide client_id as a parameter, \"\n                \"or set OHAPI_CLIENT_ID in your environment.\")\n    params = OrderedDict([\n        ('client_id', client_id),\n        ('response_type', 'code'),\n    ])\n    if redirect_uri:\n        params['redirect_uri'] = redirect_uri\n\n    auth_url = urlparse.urljoin(\n        base_url, '/direct-sharing/projects/oauth2/authorize/?{}'.format(\n            urlparse.urlencode(params)))\n\n    return auth_url"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexchanges code or refresh token for a new token and refresh token.", "response": "def oauth2_token_exchange(client_id, client_secret, redirect_uri,\n                          base_url=OH_BASE_URL, code=None, refresh_token=None):\n    \"\"\"\n    Exchange code or refresh token for a new token and refresh token. For the\n    first time when a project is created, code is required to generate refresh\n    token. Once the refresh token is obtained, it can be used later on for\n    obtaining new access token and refresh token. The user must store the\n    refresh token to obtain the new access token. For more details visit:\n    https://www.openhumans.org/direct-sharing/oauth2-setup/#setup-oauth2-authorization\n\n    :param client_id: This field is the client id of user.\n    :param client_secret: This field is the client secret of user.\n    :param redirect_uri: This is the user redirect uri.\n    :param base_url: It is this URL `https://www.openhumans.org`\n    :param code: This field is used to obtain access_token for the first time.\n        It's default value is none.\n    :param refresh_token: This field is used to obtain a new access_token when\n        the token expires.\n    \"\"\"\n    if not (code or refresh_token) or (code and refresh_token):\n        raise ValueError(\"Either code or refresh_token must be specified.\")\n    if code:\n        data = {\n            'grant_type': 'authorization_code',\n            'redirect_uri': redirect_uri,\n            'code': code,\n        }\n    elif refresh_token:\n        data = {\n            'grant_type': 'refresh_token',\n            'refresh_token': refresh_token,\n        }\n    token_url = urlparse.urljoin(base_url, '/oauth2/token/')\n    req = requests.post(\n        token_url, data=data,\n        auth=requests.auth.HTTPBasicAuth(client_id, client_secret))\n    handle_error(req, 200)\n    data = req.json()\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_page(url):\n    response = requests.get(url)\n    handle_error(response, 200)\n    data = response.json()\n    return data", "response": "Get a single page of results."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_results(starting_page):\n    logging.info('Retrieving all results for {}'.format(starting_page))\n    page = starting_page\n    results = []\n\n    while True:\n        logging.debug('Getting data from: {}'.format(page))\n        data = get_page(page)\n        logging.debug('JSON data: {}'.format(data))\n        results = results + data['results']\n\n        if data['next']:\n            page = data['next']\n        else:\n            break\n\n    return results", "response": "Iterate to get all results from Open Humans API query for Open Humans."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef exchange_oauth2_member(access_token, base_url=OH_BASE_URL,\n                           all_files=False):\n    \"\"\"\n    Returns data for a specific user, including shared data files.\n\n    :param access_token: This field is the user specific access_token.\n    :param base_url: It is this URL `https://www.openhumans.org`.\n    \"\"\"\n    url = urlparse.urljoin(\n        base_url,\n        '/api/direct-sharing/project/exchange-member/?{}'.format(\n            urlparse.urlencode({'access_token': access_token})))\n    member_data = get_page(url)\n\n    returned = member_data.copy()\n\n    # Get all file data if all_files is True.\n    if all_files:\n        while member_data['next']:\n            member_data = get_page(member_data['next'])\n            returned['data'] = returned['data'] + member_data['data']\n\n    logging.debug('JSON data: {}'.format(returned))\n    return returned", "response": "Get data for a specific user including shared data files."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_file(access_token, project_member_id=None, base_url=OH_BASE_URL,\n                file_basename=None, file_id=None, all_files=False):\n    \"\"\"\n    Delete project member files by file_basename, file_id, or all_files. To\n        learn more about Open Humans OAuth2 projects, go to:\n        https://www.openhumans.org/direct-sharing/oauth2-features/.\n\n    :param access_token: This field is user specific access_token.\n    :param project_member_id: This field is the project member id of user. It's\n        default value is None.\n    :param base_url: It is this URL `https://www.openhumans.org`.\n    :param file_basename: This field is the name of the file to delete for the\n        particular user for the particular project.\n    :param file_id: This field is the id of the file to delete for the\n        particular user for the particular project.\n    :param all_files: This is a boolean field to delete all files for the\n        particular user for the particular project.\n    \"\"\"\n    url = urlparse.urljoin(\n        base_url, '/api/direct-sharing/project/files/delete/?{}'.format(\n            urlparse.urlencode({'access_token': access_token})))\n    if not(project_member_id):\n        response = exchange_oauth2_member(access_token, base_url=base_url)\n        project_member_id = response['project_member_id']\n    data = {'project_member_id': project_member_id}\n    if file_basename and not (file_id or all_files):\n        data['file_basename'] = file_basename\n    elif file_id and not (file_basename or all_files):\n        data['file_id'] = file_id\n    elif all_files and not (file_id or file_basename):\n        data['all_files'] = True\n    else:\n        raise ValueError(\n            \"One (and only one) of the following must be specified: \"\n            \"file_basename, file_id, or all_files is set to True.\")\n    response = requests.post(url, data=data)\n    handle_error(response, 200)\n    return response", "response": "Delete a file from the specified project member."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend an email to the user or group of users.", "response": "def message(subject, message, access_token, all_members=False,\n            project_member_ids=None, base_url=OH_BASE_URL):\n    \"\"\"\n    Send an email to individual users or in bulk. To learn more about Open\n    Humans OAuth2 projects, go to:\n    https://www.openhumans.org/direct-sharing/oauth2-features/\n\n    :param subject: This field is the subject of the email.\n    :param message: This field is the body of the email.\n    :param access_token: This is user specific access token/master token.\n    :param all_members: This is a boolean field to send email to all members of\n        the project.\n    :param project_member_ids: This field is the list of project_member_id.\n    :param base_url: It is this URL `https://www.openhumans.org`.\n    \"\"\"\n    url = urlparse.urljoin(\n        base_url, '/api/direct-sharing/project/message/?{}'.format(\n            urlparse.urlencode({'access_token': access_token})))\n    if not(all_members) and not(project_member_ids):\n        response = requests.post(url, data={'subject': subject,\n                                            'message': message})\n        handle_error(response, 200)\n        return response\n    elif all_members and project_member_ids:\n        raise ValueError(\n            \"One (and only one) of the following must be specified: \"\n            \"project_members_id or all_members is set to True.\")\n    else:\n        r = requests.post(url, data={'all_members': all_members,\n                                     'project_member_ids': project_member_ids,\n                                     'subject': subject,\n                                     'message': message})\n        handle_error(r, 200)\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupload a file object to the specified keystone.", "response": "def upload_stream(stream, filename, metadata, access_token,\n                  base_url=OH_BASE_URL, remote_file_info=None,\n                  project_member_id=None, max_bytes=MAX_FILE_DEFAULT,\n                  file_identifier=None):\n    \"\"\"\n    Upload a file object using the \"direct upload\" feature, which uploads to\n    an S3 bucket URL provided by the Open Humans API. To learn more about this\n    API endpoint see:\n    * https://www.openhumans.org/direct-sharing/on-site-data-upload/\n    * https://www.openhumans.org/direct-sharing/oauth2-data-upload/\n\n    :param stream: This field is the stream (or file object) to be\n        uploaded.\n    :param metadata: This field is the metadata associated with the file.\n        Description and tags are compulsory fields of metadata.\n    :param access_token: This is user specific access token/master token.\n    :param base_url: It is this URL `https://www.openhumans.org`.\n    :param remote_file_info: This field is for for checking if a file with\n        matching name and file size already exists. Its default value is none.\n    :param project_member_id: This field is the list of project member id of\n        all members of a project. Its default value is None.\n    :param max_bytes: This field is the maximum file size a user can upload.\n        Its default value is 128m.\n    :param max_bytes: If provided, this is used in logging output. Its default\n        value is None (in which case, filename is used).\n    \"\"\"\n    if not file_identifier:\n        file_identifier = filename\n\n    # Determine a stream's size using seek.\n    # f is a file-like object.\n    old_position = stream.tell()\n    stream.seek(0, os.SEEK_END)\n    filesize = stream.tell()\n    stream.seek(old_position, os.SEEK_SET)\n    if filesize == 0:\n        raise Exception('The submitted file is empty.')\n\n    # Check size, and possibly remote file match.\n    if _exceeds_size(filesize, max_bytes, file_identifier):\n        raise ValueError(\"Maximum file size exceeded\")\n    if remote_file_info:\n        response = requests.get(remote_file_info['download_url'], stream=True)\n        remote_size = int(response.headers['Content-Length'])\n        if remote_size == filesize:\n            info_msg = ('Skipping {}, remote exists with matching '\n                        'file size'.format(file_identifier))\n            logging.info(info_msg)\n            return(info_msg)\n\n    url = urlparse.urljoin(\n        base_url,\n        '/api/direct-sharing/project/files/upload/direct/?{}'.format(\n            urlparse.urlencode({'access_token': access_token})))\n\n    if not(project_member_id):\n        response = exchange_oauth2_member(access_token, base_url=base_url)\n        project_member_id = response['project_member_id']\n\n    data = {'project_member_id': project_member_id,\n            'metadata': json.dumps(metadata),\n            'filename': filename}\n    r1 = requests.post(url, data=data)\n    handle_error(r1, 201)\n    r2 = requests.put(url=r1.json()['url'], data=stream)\n    handle_error(r2, 200)\n    done = urlparse.urljoin(\n        base_url,\n        '/api/direct-sharing/project/files/upload/complete/?{}'.format(\n            urlparse.urlencode({'access_token': access_token})))\n\n    r3 = requests.post(done, data={'project_member_id': project_member_id,\n                                   'file_id': r1.json()['id']})\n    handle_error(r3, 200)\n    logging.info('Upload complete: {}'.format(file_identifier))\n    return r3"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nuploading a file from a local filepath using the direct upload API.", "response": "def upload_file(target_filepath, metadata, access_token, base_url=OH_BASE_URL,\n                remote_file_info=None, project_member_id=None,\n                max_bytes=MAX_FILE_DEFAULT):\n    \"\"\"\n    Upload a file from a local filepath using the \"direct upload\" API.\n    To learn more about this API endpoint see:\n    * https://www.openhumans.org/direct-sharing/on-site-data-upload/\n    * https://www.openhumans.org/direct-sharing/oauth2-data-upload/\n\n    :param target_filepath: This field is the filepath of the file to be\n        uploaded\n    :param metadata: This field is a python dictionary with keys filename,\n        description and tags for single user upload and filename,\n        project member id, description and tags for multiple user upload.\n    :param access_token: This is user specific access token/master token.\n    :param base_url: It is this URL `https://www.openhumans.org`.\n    :param remote_file_info: This field is for for checking if a file with\n        matching name and file size already exists. Its default value is none.\n    :param project_member_id: This field is the list of project member id of\n        all members of a project. Its default value is None.\n    :param max_bytes: This field is the maximum file size a user can upload.\n        It's default value is 128m.\n    \"\"\"\n    with open(target_filepath, 'rb') as stream:\n        filename = os.path.basename(target_filepath)\n        return upload_stream(stream, filename, metadata, access_token,\n                             base_url, remote_file_info, project_member_id,\n                             max_bytes, file_identifier=target_filepath)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef upload_aws(target_filepath, metadata, access_token, base_url=OH_BASE_URL,\n               remote_file_info=None, project_member_id=None,\n               max_bytes=MAX_FILE_DEFAULT):\n    \"\"\"\n    Upload a file from a local filepath using the \"direct upload\" API.\n    Equivalent to upload_file. To learn more about this API endpoint see:\n    * https://www.openhumans.org/direct-sharing/on-site-data-upload/\n    * https://www.openhumans.org/direct-sharing/oauth2-data-upload/\n\n    :param target_filepath: This field is the filepath of the file to be\n        uploaded\n    :param metadata: This field is the metadata associated with the file.\n        Description and tags are compulsory fields of metadata.\n    :param access_token: This is user specific access token/master token.\n    :param base_url: It is this URL `https://www.openhumans.org`.\n    :param remote_file_info: This field is for for checking if a file with\n        matching name and file size already exists. Its default value is none.\n    :param project_member_id: This field is the list of project member id of\n        all members of a project. Its default value is None.\n    :param max_bytes: This field is the maximum file size a user can upload.\n        It's default value is 128m.\n    \"\"\"\n    return upload_file(target_filepath, metadata, access_token, base_url,\n                       remote_file_info, project_member_id, max_bytes)", "response": "Uploads a file from a local filepath using the direct upload API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npacking a list of items into a wire format.", "response": "def pack_list(from_, pack_type):\n    \"\"\" Return the wire packed version of `from_`. `pack_type` should be some\n    subclass of `xcffib.Struct`, or a string that can be passed to\n    `struct.pack`. You must pass `size` if `pack_type` is a struct.pack string.\n    \"\"\"\n    # We need from_ to not be empty\n    if len(from_) == 0:\n        return bytes()\n\n    if pack_type == 'c':\n        if isinstance(from_, bytes):\n            # Catch Python 3 bytes and Python 2 strings\n            # PY3 is \"helpful\" in that when you do tuple(b'foo') you get\n            # (102, 111, 111) instead of something more reasonable like\n            # (b'f', b'o', b'o'), so we rebuild from_ as a tuple of bytes\n            from_ = [six.int2byte(b) for b in six.iterbytes(from_)]\n        elif isinstance(from_, six.string_types):\n            # Catch Python 3 strings and Python 2 unicode strings, both of\n            # which we encode to bytes as utf-8\n            # Here we create the tuple of bytes from the encoded string\n            from_ = [six.int2byte(b) for b in bytearray(from_, 'utf-8')]\n        elif isinstance(from_[0], six.integer_types):\n            # Pack from_ as char array, where from_ may be an array of ints\n            # possibly greater than 256\n            def to_bytes(v):\n                for _ in range(4):\n                    v, r = divmod(v, 256)\n                    yield r\n            from_ = [six.int2byte(b) for i in from_ for b in to_bytes(i)]\n\n    if isinstance(pack_type, six.string_types):\n        return struct.pack(\"=\" + pack_type * len(from_), *from_)\n    else:\n        buf = six.BytesIO()\n        for item in from_:\n            # If we can't pack it, you'd better have packed it yourself. But\n            # let's not confuse things which aren't our Probobjs for packable\n            # things.\n            if isinstance(item, Protobj) and hasattr(item, \"pack\"):\n                buf.write(item.pack())\n            else:\n                buf.write(item)\n        return buf.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ensure_connected(f):\n        @functools.wraps(f)\n        def wrapper(*args):\n            self = args[0]\n            self.invalid()\n            try:\n                return f(*args)\n            finally:\n                self.invalid()\n        return wrapper", "response": "Decorator that ensures that the connection is valid."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the xcb_screen_t for every screen useful for other bindings", "response": "def get_screen_pointers(self):\n        \"\"\"\n        Returns the xcb_screen_t for every screen\n        useful for other bindings\n        \"\"\"\n        root_iter = lib.xcb_setup_roots_iterator(self._setup)\n\n        screens = [root_iter.data]\n        for i in range(self._setup.roots_len - 1):\n            lib.xcb_screen_next(ffi.addressof((root_iter)))\n            screens.append(root_iter.data)\n        return screens"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hoist_event(self, e):\n        if e.response_type == 0:\n            return self._process_error(ffi.cast(\"xcb_generic_error_t *\", e))\n\n        # We mask off the high bit here because events sent with SendEvent have\n        # this bit set. We don't actually care where the event came from, so we\n        # just throw this away. Maybe we could expose this, if anyone actually\n        # cares about it.\n        event = self._event_offsets[e.response_type & 0x7f]\n\n        buf = CffiUnpacker(e)\n        return event(buf)", "response": "Hoist an xcb_generic_event_t to the right xcffib structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef serialize(self, value, greedy=True):\n\n        if greedy and not isinstance(value, Column):\n            value = self.normalize(value)\n\n        if isinstance(value, Column):\n            return value.id\n        else:\n            return value", "response": "Serialize the value into a column or a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a query by describing it.", "response": "def describe(profile, description):\n    \"\"\"\n    Generate a query by describing it as a series of actions\n    and parameters to those actions. These map directly\n    to Query methods and arguments to those methods.\n\n    This is an alternative to the chaining interface.\n    Mostly useful if you'd like to put your queries\n    in a file, rather than in Python code.\n    \"\"\"\n    api_type = description.pop('type', 'core')\n    api = getattr(profile, api_type)\n    return refine(api.query, description)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef refine(query, description):\n\n    for attribute, arguments in description.items():\n        if hasattr(query, attribute):\n            attribute = getattr(query, attribute)\n        else:\n            raise ValueError(\"Unknown query method: \" + attribute)\n\n        # query descriptions are often automatically generated, and\n        # may include empty calls, which we skip\n        if utils.isempty(arguments):\n            continue\n\n        if callable(attribute):\n            method = attribute\n            if isinstance(arguments, dict):\n                query = method(**arguments)\n            elif isinstance(arguments, list):\n                query = method(*arguments)\n            else:\n                query = method(arguments)\n        else:\n            setattr(attribute, arguments)\n\n    return query", "response": "Refine a query from a dictionary of parameters that describes it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the raw properties of the current object.", "response": "def set(self, key=None, value=None, **kwargs):\n        \"\"\"\n        `set` is a way to add raw properties to the request,\n        for features that this module does not\n        support or supports incompletely. For convenience's\n        sake, it will serialize Column objects but will\n        leave any other kind of value alone.\n        \"\"\"\n\n        serialize = partial(self.api.columns.serialize, greedy=False)\n\n        if key and value:\n            self.raw[key] = serialize(value)\n        elif key or kwargs:\n            properties = key or kwargs\n            for key, value in properties.items():\n                self.raw[key] = serialize(value)\n        else:\n            raise ValueError(\n                \"Query#set requires a key and value, a properties dictionary or keyword arguments.\")\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new query which will produce results sorted by the specified columns or all other columns.", "response": "def sort(self, *columns, **options):\n        \"\"\"\n        Return a new query which will produce results sorted by\n        one or more metrics or dimensions. You may use plain\n        strings for the columns, or actual `Column`, `Metric`\n        and `Dimension` objects.\n\n        Add a minus in front of the metric (either the string or\n        the object) to sort in descending order.\n\n        ```python\n        # sort using strings\n        query.sort('pageviews', '-device type')\n        # alternatively, ask for a descending sort in a keyword argument\n        query.sort('pageviews', descending=True)\n\n        # sort using metric, dimension or column objects\n        pageviews = profile.core.metrics['pageviews']\n        query.sort(-pageviews)\n        ```\n        \"\"\"\n\n        sorts = self.meta.setdefault('sort', [])\n\n        for column in columns:\n            if isinstance(column, Column):\n                identifier = column.id\n            elif isinstance(column, utils.basestring):\n                descending = column.startswith('-') or options.get('descending', False)\n                identifier = self.api.columns[column.lstrip('-')].id\n            else:\n                raise ValueError(\"Can only sort on columns or column strings. Received: {}\".format(column))\n\n            if descending:\n                sign = '-'\n            else:\n                sign = ''\n\n            sorts.append(sign + identifier)\n\n        self.raw['sort'] = \",\".join(sorts)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter(self, value=None, exclude=False, **selection):\n        filters = self.meta.setdefault('filters', [])\n\n        if value and len(selection):\n            raise ValueError(\"Cannot specify a filter string and a filter keyword selection at the same time.\")\n        elif value:\n            value = [value]\n        elif len(selection):\n            value = select(self.api.columns, selection, invert=exclude)\n\n        filters.append(value)\n        self.raw['filters'] = utils.paste(filters, ',', ';')\n        return self", "response": "Filters the metadata dictionary by the specified value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef precision(self, precision):\n\n        if isinstance(precision, int):\n            precision = self.PRECISION_LEVELS[precision]\n\n        if precision not in self.PRECISION_LEVELS:\n            levels = \", \".join(self.PRECISION_LEVELS)\n            raise ValueError(\"Precision should be one of: \" + levels)\n\n        if precision != 'DEFAULT':\n            self.raw.update({'samplingLevel': precision})\n\n        return self", "response": "Set the precision of the log entries for this instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a new interval to the internal data structure.", "response": "def interval(self, granularity):\n        \"\"\"\n        Note that if you don't specify a granularity (either through the `interval`\n        method or through the `hourly`, `daily`, `weekly`, `monthly` or `yearly`\n        shortcut methods) you will get only a single result, encompassing the\n        entire date range, per metric.\n        \"\"\"\n\n        if granularity == 'total':\n            return self\n\n        if not isinstance(granularity, int):\n            if granularity in self.GRANULARITY_LEVELS:\n                granularity = self.GRANULARITY_LEVELS.index(granularity)\n            else:\n                levels = \", \".join(self.GRANULARITY_LEVELS)\n                raise ValueError(\"Granularity should be one of: lifetime, \" + levels)\n\n        dimension = self.GRANULARITY_DIMENSIONS[granularity]\n        self.raw['dimensions'].insert(0, dimension)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a new query that fetches metrics within a certain date range.", "response": "def range(self, start=None, stop=None, months=0, days=0):\n        \"\"\"\n        Return a new query that fetches metrics within a certain date range.\n\n        ```python\n        query.range('2014-01-01', '2014-06-30')\n        ```\n\n        If you don't specify a `stop` argument, the date range will end today. If instead\n        you meant to fetch just a single day's results, try:\n\n        ```python\n        query.range('2014-01-01', days=1)\n        ```\n\n        More generally, you can specify that you'd like a certain number of days,\n        starting from a certain date:\n\n        ```python\n        query.range('2014-01-01', months=3)\n        query.range('2014-01-01', days=28)\n        ```\n\n        Note that if you don't specify a granularity (either through the `interval`\n        method or through the `hourly`, `daily`, `weekly`, `monthly` or `yearly`\n        shortcut methods) you will get only a single result, encompassing the\n        entire date range, per metric.\n\n        **Note:** it is currently not possible to easily specify that you'd like\n        to query the last last full week(s), month(s) et cetera.\n        This will be added sometime in the future.\n        \"\"\"\n\n        start, stop = utils.date.range(start, stop, months, days)\n\n        self.raw.update({\n            'start_date': start,\n            'end_date': stop,\n        })\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a new query limited to a certain number of results.", "response": "def limit(self, *_range):\n        \"\"\"\n        Return a new query, limited to a certain number of results.\n\n        ```python\n        # first 100\n        query.limit(100)\n        # 50 to 60\n        query.limit(50, 10)\n        ```\n\n        Please note carefully that Google Analytics uses\n        1-indexing on its rows.\n        \"\"\"\n\n        # uses the same argument order as\n        # LIMIT in a SQL database\n        if len(_range) == 2:\n            start, maximum = _range\n        else:\n            start = 1\n            maximum = _range[0]\n\n        self.meta['limit'] = maximum\n\n        self.raw.update({\n            'start_index': start,\n            'max_results': maximum,\n        })\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef segment(self, value=None, scope=None, metric_scope=None, **selection):\n\n        \"\"\"\n        Technical note to self about segments:\n\n        * users or sessions\n        * sequence or condition\n        * scope (perHit, perSession, perUser -- gte primary scope)\n\n        Multiple conditions can be ANDed or ORed together; these two are equivalent\n\n            users::condition::ga:revenue>10;ga:sessionDuration>60\n            users::condition::ga:revenue>10;users::condition::ga:sessionDuration>60\n\n        For sequences, prepending ^ means the first part of the sequence has to match\n        the first session/hit/...\n\n        * users and sessions conditions can be combined (but only with AND)\n        * sequences and conditions can also be combined (but only with AND)\n\n        sessions::sequence::ga:browser==Chrome;\n        condition::perHit::ga:timeOnPage>5\n        ->>\n        ga:deviceCategory==mobile;ga:revenue>10;\n\n        users::sequence::ga:deviceCategory==desktop\n        ->>\n        ga:deviceCategory=mobile;\n        ga:revenue>100;\n        condition::ga:browser==Chrome\n\n        Problem: keyword arguments are passed as a dictionary, not an ordered dictionary!\n        So e.g. this is risky\n\n            query.sessions(time_on_page__gt=5, device_category='mobile', followed_by=True)\n        \"\"\"\n\n        SCOPES = {\n            'hits': 'perHit',\n            'sessions': 'perSession',\n            'users': 'perUser',\n            }\n        segments = self.meta.setdefault('segments', [])\n\n        if value and len(selection):\n            raise ValueError(\"Cannot specify a filter string and a filter keyword selection at the same time.\")\n        elif value:\n            value = [self.api.segments.serialize(value)]\n        elif len(selection):\n            if not scope:\n                raise ValueError(\"Scope is required. Choose from: users, sessions.\")\n\n            if metric_scope:\n                metric_scope = SCOPES[metric_scope]\n\n            value = select(self.api.columns, selection)\n            value = [[scope, 'condition', metric_scope, condition] for condition in value]\n            value = ['::'.join(filter(None, condition)) for condition in value]\n\n        segments.append(value)\n        self.raw['segment'] = utils.paste(segments, ',', ';')\n        return self", "response": "Return a new query limited to a segment of all users or sessions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a new query with a modified start_index.", "response": "def next(self):\n        \"\"\"\n        Return a new query with a modified `start_index`.\n        Mainly used internally to paginate through results.\n        \"\"\"\n        step = self.raw.get('max_results', 1000)\n        start = self.raw.get('start_index', 1) + step\n        self.raw['start_index'] = start\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self):\n\n        cursor = self\n        report = None\n        is_complete = False\n        is_enough = False\n\n        while not (is_enough or is_complete):\n            chunk = cursor.execute()\n\n            if report:\n                report.append(chunk.raw[0], cursor)\n            else:\n                report = chunk\n\n            is_enough = len(report.rows) >= self.meta.get('limit', float('inf'))\n            is_complete = chunk.is_complete\n            cursor = cursor.next()\n\n        return report", "response": "Run the query and return a Report instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef limit(self, maximum):\n\n        self.meta['limit'] = maximum\n        self.raw.update({\n            'max_results': maximum,\n        })\n        return self", "response": "Return a new query limited to a certain number of results."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if the credentials are not necessarily correct and False otherwise.", "response": "def valid(self):\n        \"\"\" Valid credentials are not necessarily correct, but\n        they contain all necessary information for an\n        authentication attempt. \"\"\"\n        two_legged = self.client_email and self.private_key\n        three_legged = self.client_id and self.client_secret\n        return two_legged or three_legged or False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncompletes credentials are valid and include a token.", "response": "def complete(self):\n        \"\"\" Complete credentials are valid and are either two-legged or include a token. \"\"\"\n        return self.valid and (self.access_token or self.refresh_token or self.type == 2)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nauthenticate the user with Google Analytics API.", "response": "def authenticate(\n        client_id=None, client_secret=None,\n        client_email=None, private_key=None,\n        access_token=None, refresh_token=None,\n        account=None, webproperty=None, profile=None,\n        identity=None, prefix=None, suffix=None,\n        interactive=False, save=False):\n    \"\"\"\n    The `authenticate` function will authenticate the user with the Google Analytics API,\n    using a variety of strategies: keyword arguments provided to this function, credentials\n    stored in in environment variables, credentials stored in the keychain and, finally, by\n    asking for missing information interactively in a command-line prompt.\n\n    If necessary (but only if `interactive=True`) this function will also allow the user\n    to authorize this Python module to access Google Analytics data on their behalf,\n    using an OAuth2 token.\n    \"\"\"\n\n    credentials = oauth.Credentials.find(\n        valid=True,\n        interactive=interactive,\n        prefix=prefix,\n        suffix=suffix,\n        client_id=client_id,\n        client_secret=client_secret,\n        client_email=client_email,\n        private_key=private_key,\n        access_token=access_token,\n        refresh_token=refresh_token,\n        identity=identity,\n        )\n\n    if credentials.incomplete:\n        if interactive:\n            credentials = authorize(\n                client_id=credentials.client_id,\n                client_secret=credentials.client_secret,\n                save=save,\n                identity=credentials.identity,\n                prefix=prefix,\n                suffix=suffix,\n                )\n        elif credentials.type == 2:\n            credentials = authorize(\n                client_email=credentials.client_email,\n                private_key=credentials.private_key,\n                identity=credentials.identity,\n                save=save,\n                )\n        else:\n            raise KeyError(\"Cannot authenticate: enable interactive authorization, pass a token or use a service account.\")\n    \n    accounts = oauth.authenticate(credentials)\n    scope = navigate(accounts, account=account, webproperty=webproperty, profile=profile)\n    return scope"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrevoking OAuth access to Google Analytics data.", "response": "def revoke(client_id, client_secret,\n        client_email=None, private_key=None,\n        access_token=None, refresh_token=None,\n        identity=None, prefix=None, suffix=None):\n\n    \"\"\"\n    Given a client id, client secret and either an access token or a refresh token,\n    revoke OAuth access to the Google Analytics data and remove any stored credentials\n    that use these tokens.\n    \"\"\"\n\n    if client_email and private_key:\n        raise ValueError('Two-legged OAuth does not use revokable tokens.')\n    \n    credentials = oauth.Credentials.find(\n        complete=True,\n        interactive=False,\n        identity=identity,\n        client_id=client_id,\n        client_secret=client_secret,\n        access_token=access_token,\n        refresh_token=refresh_token,\n        prefix=prefix,\n        suffix=suffix,\n        )\n\n    retval = credentials.revoke()\n    keyring.delete(credentials.identity)\n    return retval"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef query(scope, blueprint, debug, output, with_metadata, realtime, **description):\n\n    if realtime:\n        description['type'] = 'realtime'\n\n    if blueprint:\n        queries = from_blueprint(scope, blueprint)\n    else:\n        if not isinstance(scope, ga.account.Profile):\n            raise ValueError(\"Account and webproperty needed for query.\")\n\n        queries = from_args(scope, **description)\n\n    for query in queries:\n        if debug:\n            click.echo(query.build())\n\n        report = query.serialize(format=output, with_metadata=with_metadata)\n        click.echo(report)", "response": "Query the pageviews for the specified scope."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef vectorize(fn):\n\n    @functools.wraps(fn)\n    def vectorized_method(self, values, *vargs, **kwargs):\n        wrap = not isinstance(values, (list, tuple))\n        should_unwrap = not kwargs.setdefault('wrap', False)\n        unwrap = wrap and should_unwrap\n        del kwargs['wrap']\n        \n        if wrap:\n            values = [values]\n\n        results = [fn(self, value, *vargs, **kwargs) for value in values]\n\n        if unwrap:\n            results = results[0]\n\n        return results\n\n    return vectorized_method", "response": "A method that accepts one or more values and returns a list or a single item depending on what is desired."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef profiles(self):\n        raw_profiles = self.account.service.management().profiles().list(\n            accountId=self.account.id,\n            webPropertyId=self.id).execute()['items']\n        profiles = [Profile(raw, self) for raw in raw_profiles]\n        return addressable.List(profiles, indices=['id', 'name'], insensitive=True)", "response": "A list of all profiles on this web property."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_output_input(*popenargs, **kwargs):\n    if 'stdout' in kwargs:\n        raise ValueError('stdout argument not allowed, it will be overridden.')\n    if 'input' in kwargs:\n        if 'stdin' in kwargs:\n            raise ValueError('stdin and input arguments may not both be used.')\n        inputdata = kwargs['input']\n        del kwargs['input']\n        kwargs['stdin'] = PIPE\n    else:\n        inputdata = None\n    process = Popen(*popenargs, stdout=PIPE, **kwargs)\n    try:\n        output, unused_err = process.communicate(inputdata)\n    except:\n        process.kill()\n        process.wait()\n        raise\n    retcode = process.poll()\n    if retcode:\n        cmd = kwargs.get(\"args\")\n        if cmd is None:\n            cmd = popenargs[0]\n        raise CalledProcessError(retcode, cmd, output=output)\n    return output", "response": "Run a command with arguments and return its output as a byte string."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate token indices for the given tokens.", "response": "def create_token_indices(self, tokens):\n        \"\"\"If `apply_encoding_options` is inadequate, one can retrieve tokens from `self.token_counts`, filter with\n        a desired strategy and regenerate `token_index` using this method. The token index is subsequently used\n        when `encode_texts` or `decode_texts` methods are called.\n        \"\"\"\n        start_index = len(self.special_token)\n        indices = list(range(len(tokens) + start_index))\n        # prepend because the special tokens come in the beginning\n        tokens_with_special = self.special_token + list(tokens)\n        self._token2idx = dict(list(zip(tokens_with_special, indices)))\n        self._idx2token = dict(list(zip(indices, tokens_with_special)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\napply the given settings for subsequent calls to encode_texts and decode_texts.", "response": "def apply_encoding_options(self, min_token_count=1, limit_top_tokens=None):\n        \"\"\"Applies the given settings for subsequent calls to `encode_texts` and `decode_texts`. This allows you to\n        play with different settings without having to re-run tokenization on the entire corpus.\n\n        Args:\n            min_token_count: The minimum token count (frequency) in order to include during encoding. All tokens\n                below this frequency will be encoded to `0` which corresponds to unknown token. (Default value = 1)\n            limit_top_tokens: The maximum number of tokens to keep, based their frequency. Only the most common `limit_top_tokens`\n                tokens will be kept. Set to None to keep everything. (Default value: None)\n        \"\"\"\n        if not self.has_vocab:\n            raise ValueError(\"You need to build the vocabulary using `build_vocab` \"\n                             \"before using `apply_encoding_options`\")\n        if min_token_count < 1:\n            raise ValueError(\"`min_token_count` should atleast be 1\")\n\n        # Remove tokens with freq < min_token_count\n        token_counts = list(self._token_counts.items())\n        token_counts = [x for x in token_counts if x[1] >= min_token_count]\n\n        # Clip to max_tokens.\n        if limit_top_tokens is not None:\n            token_counts.sort(key=lambda x: x[1], reverse=True)\n            filtered_tokens = list(zip(*token_counts))[0]\n            filtered_tokens = filtered_tokens[:limit_top_tokens]\n        else:\n            filtered_tokens = zip(*token_counts)[0]\n\n        # Generate indices based on filtered tokens.\n        self.create_token_indices(filtered_tokens)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nencode the given texts using internal vocabulary with optionally applied encoding options.", "response": "def encode_texts(self, texts, unknown_token=\"<UNK>\", verbose=1, **kwargs):\n        \"\"\"Encodes the given texts using internal vocabulary with optionally applied encoding options. See\n        ``apply_encoding_options` to set various options.\n\n        Args:\n            texts: The list of text items to encode.\n            unknown_token: The token to replace words that out of vocabulary. If none, those words are omitted.\n            verbose: The verbosity level for progress. Can be 0, 1, 2. (Default value = 1)\n            **kwargs: The kwargs for `token_generator`.\n\n        Returns:\n            The encoded texts.\n        \"\"\"\n        if not self.has_vocab:\n            raise ValueError(\n                \"You need to build the vocabulary using `build_vocab` before using `encode_texts`\")\n\n        if unknown_token and unknown_token not in self.special_token:\n            raise ValueError(\n                \"Your special token (\" + unknown_token + \") to replace unknown words is not in the list of special token: \" + self.special_token)\n\n        progbar = Progbar(len(texts), verbose=verbose, interval=0.25)\n        encoded_texts = []\n        for token_data in self.token_generator(texts, **kwargs):\n            indices, token = token_data[:-1], token_data[-1]\n\n            token_idx = self._token2idx.get(token)\n            if token_idx is None and unknown_token:\n                token_idx = self.special_token.index(unknown_token)\n\n            if token_idx is not None:\n                utils._append(encoded_texts, indices, token_idx)\n\n            # Update progressbar per document level.\n            progbar.update(indices[0])\n\n        # All done. Finalize progressbar.\n        progbar.update(len(texts))\n        return encoded_texts"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndecode the texts using internal vocabulary.", "response": "def decode_texts(self, encoded_texts, unknown_token=\"<UNK>\", inplace=True):\n        \"\"\"Decodes the texts using internal vocabulary. The list structure is maintained.\n\n        Args:\n            encoded_texts: The list of texts to decode.\n            unknown_token: The placeholder value for unknown token. (Default value: \"<UNK>\")\n            inplace: True to make changes inplace. (Default value: True)\n\n        Returns:\n            The decoded texts.\n        \"\"\"\n        if len(self._token2idx) == 0:\n            raise ValueError(\n                \"You need to build vocabulary using `build_vocab` before using `decode_texts`\")\n\n        if not isinstance(encoded_texts, list):\n            # assume it's a numpy array\n            encoded_texts = encoded_texts.tolist()\n\n        if not inplace:\n            encoded_texts = deepcopy(encoded_texts)\n        utils._recursive_apply(encoded_texts,\n                               lambda token_id: self._idx2token.get(token_id) or unknown_token)\n        return encoded_texts"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds the internal vocabulary and computes various statistics.", "response": "def build_vocab(self, texts, verbose=1, **kwargs):\n        \"\"\"Builds the internal vocabulary and computes various statistics.\n\n        Args:\n            texts: The list of text items to encode.\n            verbose: The verbosity level for progress. Can be 0, 1, 2. (Default value = 1)\n            **kwargs: The kwargs for `token_generator`.\n        \"\"\"\n        if self.has_vocab:\n            logger.warn(\n                \"Tokenizer already has existing vocabulary. Overriding and building new vocabulary.\")\n\n        progbar = Progbar(len(texts), verbose=verbose, interval=0.25)\n        count_tracker = utils._CountTracker()\n\n        self._token_counts.clear()\n        self._num_texts = len(texts)\n\n        for token_data in self.token_generator(texts, **kwargs):\n            indices, token = token_data[:-1], token_data[-1]\n            count_tracker.update(indices)\n            self._token_counts[token] += 1\n\n            # Update progressbar per document level.\n            progbar.update(indices[0])\n\n        # Generate token2idx and idx2token.\n        self.create_token_indices(self._token_counts.keys())\n\n        # All done. Finalize progressbar update and count tracker.\n        count_tracker.finalize()\n        self._counts = count_tracker.counts\n        progbar.update(len(texts))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npad each sequence in the list of sequences to the same fixed length.", "response": "def pad_sequences(self, sequences, fixed_sentences_seq_length=None, fixed_token_seq_length=None,\n                      padding='pre', truncating='post', padding_token=\"<PAD>\"):\n        \"\"\"Pads each sequence to the same fixed length (length of the longest sequence or provided override).\n\n        Args:\n            sequences: list of list (samples, words) or list of list of list (samples, sentences, words)\n            fixed_sentences_seq_length: The fix sentence sequence length to use. If None, largest sentence length is used.\n            fixed_token_seq_length: The fix token sequence length to use. If None, largest word length is used.\n            padding: 'pre' or 'post', pad either before or after each sequence.\n            truncating: 'pre' or 'post', remove values from sequences larger than fixed_sentences_seq_length or fixed_token_seq_length\n                either in the beginning or in the end of the sentence or word sequence respectively.\n            padding_token: The token to add for padding.\n\n        Returns:\n            Numpy array of (samples, max_sentences, max_tokens) or (samples, max_tokens) depending on the sequence input.\n\n        Raises:\n            ValueError: in case of invalid values for `truncating` or `padding`.\n        \"\"\"\n        value = self.special_token.index(padding_token)\n        if value < 0:\n            raise ValueError('The padding token \"' + padding_token +\n                             \" is not in the special tokens of the tokenizer.\")\n        # Determine if input is (samples, max_sentences, max_tokens) or not.\n        if isinstance(sequences[0][0], list):\n            x = utils._pad_sent_sequences(sequences, fixed_sentences_seq_length,\n                                          fixed_token_seq_length, padding, truncating, value)\n        else:\n            x = utils._pad_token_sequences(\n                sequences, fixed_token_seq_length, padding, truncating, value)\n        return np.array(x, dtype='int32')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_stats(self, i):\n        # OrderedDict to always show same order if printed.\n        result = OrderedDict()\n        result['min'] = np.min(self._counts[i])\n        result['max'] = np.max(self._counts[i])\n        result['std'] = np.std(self._counts[i])\n        result['mean'] = np.mean(self._counts[i])\n        return result", "response": "Gets the standard statistics for aux_index i."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_embedding_weights(word_index, embeddings_index):\n    logger.info('Loading embeddings for all words in the corpus')\n    embedding_dim = list(embeddings_index.values())[0].shape[-1]\n\n    # setting special tokens such as UNK and PAD to 0\n    # all other words are also set to 0.\n    embedding_weights = np.zeros((len(word_index), embedding_dim))\n\n    for word, i in word_index.items():\n        word_vector = embeddings_index.get(word)\n        if word_vector is not None:\n            embedding_weights[i] = word_vector\n\n    return embedding_weights", "response": "Builds an embedding matrix for all words in vocab using embeddings_index\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild a dictionary with the URL and filename used later on for downloading the file.", "response": "def build_fasttext_wiki_embedding_obj(embedding_type):\n    \"\"\"FastText pre-trained word vectors for 294 languages, with 300 dimensions, trained on Wikipedia. It's recommended to use the same tokenizer for your data that was used to construct the embeddings. It's implemented as 'FasttextWikiTokenizer'. More information: https://fasttext.cc/docs/en/pretrained-vectors.html.\n\n    Args:\n        embedding_type: A string in the format `fastext.wiki.$LANG_CODE`. e.g. `fasttext.wiki.de` or `fasttext.wiki.es`\n    Returns:\n        Object with the URL and filename used later on for downloading the file.\n    \"\"\"\n    lang = embedding_type.split('.')[2]\n    return {\n        'file': 'wiki.{}.vec'.format(lang),\n        'url': 'https://dl.fbaipublicfiles.com/fasttext/vectors-wiki/wiki.{}.vec'.format(lang),\n        'extract': False,\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_fasttext_cc_embedding_obj(embedding_type):\n    lang = embedding_type.split('.')[2]\n    return {\n        'file': 'cc.{}.300.vec.gz'.format(lang),\n        'url': 'https://dl.fbaipublicfiles.com/fasttext/vectors-crawl/cc.{}.300.vec.gz'.format(lang),\n        'extract': False\n    }", "response": "Build a dictionary with the URL and filename used later on for downloading the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_embeddings_index(embedding_type='glove.42B.300d', embedding_dims=None, embedding_path=None, cache=True):\n\n    if embedding_path is not None:\n        embedding_type = embedding_path  # identify embedding by path\n\n    embeddings_index = _EMBEDDINGS_CACHE.get(embedding_type)\n    if embeddings_index is not None:\n        return embeddings_index\n\n    if embedding_path is None:\n        embedding_type_obj = get_embedding_type(embedding_type)\n\n        # some very rough wrangling of zip files with the keras util `get_file`\n        # a special problem: when multiple files are in one zip file\n        extract = embedding_type_obj.get('extract', True)\n        file_path = get_file(\n            embedding_type_obj['file'], origin=embedding_type_obj['url'], extract=extract, cache_subdir='embeddings', file_hash=embedding_type_obj.get('file_hash',))\n\n        if 'file_in_zip' in embedding_type_obj:\n            zip_folder = file_path.split('.zip')[0]\n            with ZipFile(file_path, 'r') as zf:\n                zf.extractall(zip_folder)\n            file_path = os.path.join(\n                zip_folder, embedding_type_obj['file_in_zip'])\n        else:\n            if extract:\n                if file_path.endswith('.zip'):\n                    file_path = file_path.split('.zip')[0]\n                # if file_path.endswith('.gz'):\n                #     file_path = file_path.split('.gz')[0]\n    else:\n        file_path = embedding_path\n\n    embeddings_index = _build_embeddings_index(file_path, embedding_dims)\n\n    if cache:\n        _EMBEDDINGS_CACHE[embedding_type] = embeddings_index\n    return embeddings_index", "response": "Retrieves embeddings index from embedding name or path. Will automatically download and cache as needed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef token_generator(self, texts, **kwargs):\n        for text_idx, text in enumerate(texts):\n            if self.lower:\n                text = text.lower()\n            for char in text:\n                yield text_idx, char", "response": "Yields tokens from texts as tuples."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nyields tokens from texts as tuples.", "response": "def token_generator(self, texts, **kwargs):\n        \"\"\"Yields tokens from texts as `(text_idx, sent_idx, character)`\n\n        Args:\n            texts: The list of texts.\n            **kwargs: Supported args include:\n                n_threads/num_threads: Number of threads to use. Uses num_cpus - 1 by default.\n                batch_size: The number of texts to accumulate into a common working set before processing.\n                    (Default value: 1000)\n        \"\"\"\n        # Perf optimization. Only process what is necessary.\n        n_threads, batch_size = utils._parse_spacy_kwargs(**kwargs)\n        nlp = spacy.load(self.lang)\n\n        kwargs = {\n            'batch_size': batch_size,\n            'n_threads': n_threads,\n            'disable': ['ner']\n        }\n\n        # Perf optimization: Lower the entire text instead of individual tokens.\n        texts_gen = utils._apply_generator(\n            texts, lambda x: x.lower()) if self.lower else texts\n        for text_idx, doc in enumerate(nlp.pipe(texts_gen, **kwargs)):\n            for sent_idx, sent in enumerate(doc.sents):\n                for word in sent:\n                    for char in word:\n                        yield text_idx, sent_idx, char"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef equal_distribution_folds(y, folds=2):\n    n, classes = y.shape\n\n    # Compute sample distribution over classes\n    dist = y.sum(axis=0).astype('float')\n    dist /= dist.sum()\n\n    index_list = []\n    fold_dist = np.zeros((folds, classes), dtype='float')\n    for _ in range(folds):\n        index_list.append([])\n    for i in range(n):\n        if i < folds:\n            target_fold = i\n        else:\n            normed_folds = fold_dist.T / fold_dist.sum(axis=1)\n            how_off = normed_folds.T - dist\n            target_fold = np.argmin(\n                np.dot((y[i] - .5).reshape(1, -1), how_off.T))\n        fold_dist[target_fold] += y[i]\n        index_list[target_fold].append(i)\n\n    logger.debug(\"Fold distributions:\")\n    logger.debug(fold_dist)\n    return index_list", "response": "Creates a list of indices that have roughly balanced multi - label distributions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild a model that encodes all words within sentences using token_encoder_model followed by sentence_encoder_model.", "response": "def build_model(self, token_encoder_model, sentence_encoder_model,\n                    trainable_embeddings=True, output_activation='softmax'):\n        \"\"\"Builds a model that first encodes all words within sentences using `token_encoder_model`, followed by\n        `sentence_encoder_model`.\n\n        Args:\n            token_encoder_model: An instance of `SequenceEncoderBase` for encoding tokens within sentences. This model\n                will be applied across all sentences to create a sentence encoding.\n            sentence_encoder_model: An instance of `SequenceEncoderBase` operating on sentence encoding generated by\n                `token_encoder_model`. This encoding is then fed into a final `Dense` layer for classification.\n            trainable_embeddings: Whether or not to fine tune embeddings.\n            output_activation: The output activation to use. (Default value: 'softmax')\n                Use:\n                - `softmax` for binary or multi-class.\n                - `sigmoid` for multi-label classification.\n                - `linear` for regression output.\n\n        Returns:\n            The model output tensor.\n        \"\"\"\n        if not isinstance(token_encoder_model, SequenceEncoderBase):\n            raise ValueError(\"`token_encoder_model` should be an instance of `{}`\".format(\n                SequenceEncoderBase))\n        if not isinstance(sentence_encoder_model, SequenceEncoderBase):\n            raise ValueError(\"`sentence_encoder_model` should be an instance of `{}`\".format(\n                SequenceEncoderBase))\n\n        if not sentence_encoder_model.allows_dynamic_length() and self.max_sents is None:\n            raise ValueError(\"Sentence encoder model '{}' requires padding. \"\n                             \"You need to provide `max_sents`\")\n\n        if self.embeddings_index is None:\n            # The +1 is for unknown token index 0.\n            embedding_layer = Embedding(len(self.token_index),\n                                        self.embedding_dims,\n                                        input_length=self.max_tokens,\n                                        mask_zero=token_encoder_model.allows_dynamic_length(),\n                                        trainable=trainable_embeddings)\n        else:\n            embedding_layer = Embedding(len(self.token_index),\n                                        self.embedding_dims,\n                                        weights=[build_embedding_weights(\n                                            self.token_index, self.embeddings_index)],\n                                        input_length=self.max_tokens,\n                                        mask_zero=token_encoder_model.allows_dynamic_length(),\n                                        trainable=trainable_embeddings)\n\n        word_input = Input(shape=(self.max_tokens,), dtype='int32')\n        x = embedding_layer(word_input)\n        word_encoding = token_encoder_model(x)\n        token_encoder_model = Model(\n            word_input, word_encoding, name='word_encoder')\n\n        doc_input = Input(\n            shape=(self.max_sents, self.max_tokens), dtype='int32')\n        sent_encoding = TimeDistributed(token_encoder_model)(doc_input)\n        x = sentence_encoder_model(sent_encoding)\n\n        x = Dense(self.num_classes, activation=output_activation)(x)\n        return Model(doc_input, x)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses text and save as Dataset", "response": "def process_save(X, y, tokenizer, proc_data_path, max_len=400, train=False, ngrams=None, limit_top_tokens=None):\n    \"\"\"Process text and save as Dataset\n    \"\"\"\n    if train and limit_top_tokens is not None:\n        tokenizer.apply_encoding_options(limit_top_tokens=limit_top_tokens)\n\n    X_encoded = tokenizer.encode_texts(X)\n\n    if ngrams is not None:\n        X_encoded = tokenizer.add_ngrams(X_encoded, n=ngrams, train=train)\n\n    X_padded = tokenizer.pad_sequences(\n        X_encoded, fixed_token_seq_length=max_len)\n\n    if train:\n        ds = Dataset(X_padded,\n                     y, tokenizer=tokenizer)\n    else:\n        ds = Dataset(X_padded, y)\n\n    ds.save(proc_data_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef split_data(X, y, ratio=(0.8, 0.1, 0.1)):\n    assert(sum(ratio) == 1 and len(ratio) == 3)\n    X_train, X_rest, y_train, y_rest = train_test_split(\n        X, y, train_size=ratio[0])\n    X_val, X_test, y_val, y_test = train_test_split(\n        X_rest, y_rest, train_size=ratio[1])\n    return X_train, X_val, X_test, y_train, y_val, y_test", "response": "Splits data into training validation and test set."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_data_split(proc_data_dir):\n    ds_train = Dataset.load(path.join(proc_data_dir, 'train.bin'))\n    ds_val = Dataset.load(path.join(proc_data_dir, 'val.bin'))\n    ds_test = Dataset.load(path.join(proc_data_dir, 'test.bin'))\n    return ds_train, ds_val, ds_test", "response": "Loads a split dataset\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_model(self, token_encoder_model, trainable_embeddings=True, output_activation='softmax'):\n        if not isinstance(token_encoder_model, SequenceEncoderBase):\n            raise ValueError(\"`token_encoder_model` should be an instance of `{}`\".format(\n                SequenceEncoderBase))\n\n        if not token_encoder_model.allows_dynamic_length() and self.max_tokens is None:\n            raise ValueError(\"The provided `token_encoder_model` does not allow variable length mini-batches. \"\n                             \"You need to provide `max_tokens`\")\n\n        if self.embeddings_index is None:\n            # The +1 is for unknown token index 0.\n            embedding_layer = Embedding(len(self.token_index),\n                                        self.embedding_dims,\n                                        input_length=self.max_tokens,\n                                        mask_zero=token_encoder_model.allows_dynamic_length(),\n                                        trainable=trainable_embeddings)\n        else:\n            embedding_layer = Embedding(len(self.token_index),\n                                        self.embedding_dims,\n                                        weights=[build_embedding_weights(\n                                            self.token_index, self.embeddings_index)],\n                                        input_length=self.max_tokens,\n                                        mask_zero=token_encoder_model.allows_dynamic_length(),\n                                        trainable=trainable_embeddings)\n\n        sequence_input = Input(shape=(self.max_tokens,), dtype='int32')\n        x = embedding_layer(sequence_input)\n        x = token_encoder_model(x)\n        x = Dense(self.num_classes, activation=output_activation)(x)\n        return Model(sequence_input, x)", "response": "Builds a model for classification."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute the softmax along a specified dim.", "response": "def _softmax(x, dim):\n    \"\"\"Computes softmax along a specified dim. Keras currently lacks this feature.\n    \"\"\"\n\n    if K.backend() == 'tensorflow':\n        import tensorflow as tf\n        return tf.nn.softmax(x, dim)\n    elif K.backend() is 'cntk':\n        import cntk\n        return cntk.softmax(x, dim)\n    elif K.backend() == 'theano':\n        # Theano cannot softmax along an arbitrary dim.\n        # So, we will shuffle `dim` to -1 and un-shuffle after softmax.\n        perm = np.arange(K.ndim(x))\n        perm[dim], perm[-1] = perm[-1], perm[dim]\n        x_perm = K.permute_dimensions(x, perm)\n        output = K.softmax(x_perm)\n\n        # Permute back\n        perm[dim], perm[-1] = perm[-1], perm[dim]\n        output = K.permute_dimensions(x, output)\n        return output\n    else:\n        raise ValueError(\"Backend '{}' not supported\".format(K.backend()))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\napplying various filtering and processing options on token.", "response": "def _apply_options(self, token):\n        \"\"\"Applies various filtering and processing options on token.\n\n        Returns:\n            The processed token. None if filtered.\n        \"\"\"\n        # Apply work token filtering.\n        if token.is_punct and self.remove_punct:\n            return None\n        if token.is_stop and self.remove_stop_words:\n            return None\n        if token.is_digit and self.remove_digits:\n            return None\n        if token.is_oov and self.exclude_oov:\n            return None\n        if token.pos_ in self.exclude_pos_tags:\n            return None\n        if token.ent_type_ in self.exclude_entities:\n            return None\n\n        # Lemmatized ones are already lowered.\n        if self.lemmatize:\n            return token.lemma_\n        if self.lower:\n            return token.lower_\n        return token.orth_"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nyield tokens from texts as tuples.", "response": "def token_generator(self, texts, **kwargs):\n        \"\"\"Yields tokens from texts as `(text_idx, word)`\n\n        Args:\n            texts: The list of texts.\n            **kwargs: Supported args include:\n                n_threads/num_threads: Number of threads to use. Uses num_cpus - 1 by default.\n                batch_size: The number of texts to accumulate into a common working set before processing.\n                    (Default value: 1000)\n        \"\"\"\n        # Perf optimization. Only process what is necessary.\n        n_threads, batch_size = utils._parse_spacy_kwargs(**kwargs)\n        nlp = spacy.load(self.lang)\n\n        disabled = ['parser']\n        if len(self.exclude_entities) > 0:\n            disabled.append('ner')\n\n        kwargs = {\n            'batch_size': batch_size,\n            'n_threads': n_threads,\n            'disable': disabled\n        }\n\n        for text_idx, doc in enumerate(nlp.pipe(texts, **kwargs)):\n            for word in doc:\n                processed_word = self._apply_options(word)\n                if processed_word is not None:\n                    yield text_idx, processed_word"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd value to list indexed by indices. Will create sub lists as required.", "response": "def _append(lst, indices, value):\n    \"\"\"Adds `value` to `lst` list indexed by `indices`. Will create sub lists as required.\n    \"\"\"\n    for i, idx in enumerate(indices):\n        # We need to loop because sometimes indices can increment by more than 1 due to missing tokens.\n        # Example: Sentence with no words after filtering words.\n        while len(lst) <= idx:\n            # Update max counts whenever a new sublist is created.\n            # There is no need to worry about indices beyond `i` since they will end up creating new lists as well.\n            lst.append([])\n        lst = lst[idx]\n\n    # Add token and update token max count.\n    lst.append(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the spacy kwargs and return the number of threads and batch size.", "response": "def _parse_spacy_kwargs(**kwargs):\n    \"\"\"Supported args include:\n\n    Args:\n        n_threads/num_threads: Number of threads to use. Uses num_cpus - 1 by default.\n        batch_size: The number of texts to accumulate into a common working set before processing.\n            (Default value: 1000)\n    \"\"\"\n    n_threads = kwargs.get('n_threads') or kwargs.get('num_threads')\n    batch_size = kwargs.get('batch_size')\n\n    if n_threads is None or n_threads is -1:\n        n_threads = cpu_count() - 1\n    if batch_size is None or batch_size is -1:\n        batch_size = 1000\n    return n_threads, batch_size"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, indices):\n        # Initialize various lists for the first time based on length of indices.\n        if self._prev_indices is None:\n            self._prev_indices = indices\n\n            # +1 to track token counts in the last index.\n            self._local_counts = np.full(len(indices) + 1, 1)\n            self._local_counts[-1] = 0\n            self.counts = [[] for _ in range(len(self._local_counts))]\n\n        has_reset = False\n        for i in range(len(indices)):\n            # index value changed. Push all local values beyond i to count and reset those local_counts.\n            # For example, if document index changed, push counts on sentences and tokens and reset their local_counts\n            # to indicate that we are tracking those for new document. We need to do this at all document hierarchies.\n            if indices[i] > self._prev_indices[i]:\n                self._local_counts[i] += 1\n                has_reset = True\n                for j in range(i + 1, len(self.counts)):\n                    self.counts[j].append(self._local_counts[j])\n                    self._local_counts[j] = 1\n\n        # If none of the aux indices changed, update token count.\n        if not has_reset:\n            self._local_counts[-1] += 1\n        self._prev_indices = indices[:]", "response": "Updates the counts based on indices. The algorithm tracks the index change at i and\n        update global counts for all indices beyond i with local counts tracked so far."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread text files in directory and returns them as array", "response": "def read_folder(directory):\n    \"\"\"read text files in directory and returns them as array\n\n    Args:\n        directory: where the text files are\n\n    Returns:\n        Array of text\n    \"\"\"\n    res = []\n    for filename in os.listdir(directory):\n        with io.open(os.path.join(directory, filename), encoding=\"utf-8\") as f:\n            content = f.read()\n            res.append(content)\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns array with positive and negative examples", "response": "def read_pos_neg_data(path, folder, limit):\n    \"\"\"returns array with positive and negative examples\"\"\"\n    training_pos_path = os.path.join(path, folder, 'pos')\n    training_neg_path = os.path.join(path, folder, 'neg')\n\n    X_pos = read_folder(training_pos_path)\n    X_neg = read_folder(training_neg_path)\n\n    if limit is None:\n        X = X_pos + X_neg\n    else:\n        X = X_pos[:limit] + X_neg[:limit]\n\n    y = [1] * int(len(X) / 2) + [0] * int(len(X) / 2)\n\n    return X, y"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndownload and caches IMDB Moview Reviews. 25k training data 25k test data 25k test data", "response": "def imdb(limit=None, shuffle=True):\n    \"\"\"Downloads (and caches) IMDB Moview Reviews. 25k training data, 25k test data\n\n    Args:\n        limit: get only first N items for each class\n\n    Returns:\n        [X_train, y_train, X_test, y_test]\n    \"\"\"\n\n    movie_review_url = 'http://ai.stanford.edu/~amaas/data/sentiment/aclImdb_v1.tar.gz'\n\n    # download and extract, thus remove the suffix '.tar.gz'\n    path = keras.utils.get_file(\n        'aclImdb.tar.gz', movie_review_url, extract=True)[:-7]\n\n    X_train, y_train = read_pos_neg_data(path, 'train', limit)\n    X_test, y_test = read_pos_neg_data(path, 'test', limit)\n\n    if shuffle:\n        X_train, y_train = sklearn.utils.shuffle(X_train, y_train)\n        X_test, y_test = sklearn.utils.shuffle(X_test, y_test)\n\n    return X_train, X_test, y_train, y_test"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_absolute(self, x, y):\n        return x + self.size/2, y + self.size/2", "response": "Converts coordinates provided with reference to the center of the canvas object to absolute coordinates which are used by the canvas object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_value(self, number: (float, int)):\n        self.canvas.delete('all')\n        self.canvas.create_image(0, 0, image=self.image, anchor='nw')\n\n        number = number if number <= self.max_value else self.max_value\n        number = 0.0 if number < 0.0 else number\n\n        radius = 0.9 * self.size/2.0\n        angle_in_radians = (2.0 * cmath.pi / 3.0) \\\n            + number / self.max_value * (5.0 * cmath.pi / 3.0)\n\n        center = cmath.rect(0, 0)\n        outer = cmath.rect(radius, angle_in_radians)\n        if self.needle_thickness == 0:\n            line_width = int(5 * self.size / 200)\n            line_width = 1 if line_width < 1 else line_width\n        else:\n            line_width = self.needle_thickness\n\n        self.canvas.create_line(\n            *self.to_absolute(center.real, center.imag),\n            *self.to_absolute(outer.real, outer.imag),\n            width=line_width,\n            fill=self.needle_color\n        )\n\n        self.readout['text'] = '{}{}'.format(number, self.unit)", "response": "Sets the value of the graphic containing the specified number."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _draw_background(self, divisions=10):\n        self.canvas.create_arc(2, 2, self.size-2, self.size-2,\n                               style=tk.PIESLICE, start=-60, extent=30,\n                               fill='red')\n        self.canvas.create_arc(2, 2, self.size-2, self.size-2,\n                               style=tk.PIESLICE, start=-30, extent=60,\n                               fill='yellow')\n        self.canvas.create_arc(2, 2, self.size-2, self.size-2,\n                               style=tk.PIESLICE, start=30, extent=210,\n                               fill='green')\n\n        # find the distance between the center and the inner tick radius\n        inner_tick_radius = int(self.size * 0.4)\n        outer_tick_radius = int(self.size * 0.5)\n\n        for tick in range(divisions):\n            angle_in_radians = (2.0 * cmath.pi / 3.0) \\\n                               + tick/divisions * (5.0 * cmath.pi / 3.0)\n            inner_point = cmath.rect(inner_tick_radius, angle_in_radians)\n            outer_point = cmath.rect(outer_tick_radius, angle_in_radians)\n\n            self.canvas.create_line(\n                *self.to_absolute(inner_point.real, inner_point.imag),\n                *self.to_absolute(outer_point.real, outer_point.imag),\n                width=1\n            )", "response": "Draw the background of the dialtonical time area."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef draw_axes(self):\n        self.canvas.delete('all')\n        rect = 50, 50, self.w - 50, self.h - 50\n\n        self.canvas.create_rectangle(rect, outline=\"black\")\n\n        for x in self.frange(0, self.x_max - self.x_min + 1, self.x_tick):\n            value = Decimal(self.x_min + x)\n            if self.x_min <= value <= self.x_max:\n                x_step = (self.px_x * x) / self.x_tick\n                coord = 50 + x_step, self.h - 50, 50 + x_step, self.h - 45\n                self.canvas.create_line(coord, fill=\"black\")\n                coord = 50 + x_step, self.h - 40\n\n                label = round(Decimal(self.x_min + x), 1)\n                self.canvas.create_text(coord, fill=\"black\", text=label)\n\n        for y in self.frange(0, self.y_max - self.y_min + 1, self.y_tick):\n            value = Decimal(self.y_max - y)\n\n            if self.y_min <= value <= self.y_max:\n                y_step = (self.px_y * y) / self.y_tick\n                coord = 45, 50 + y_step, 50, 50 + y_step\n                self.canvas.create_line(coord, fill=\"black\")\n                coord = 35, 50 + y_step\n\n                label = round(value, 1)\n                self.canvas.create_text(coord, fill=\"black\", text=label)", "response": "Draws the axes for the current series."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_point(self, x, y, visible=True, color='black', size=5):\n        xp = (self.px_x * (x - self.x_min)) / self.x_tick\n        yp = (self.px_y * (self.y_max - y)) / self.y_tick\n        coord = 50 + xp, 50 + yp\n\n        if visible:\n            # divide down to an appropriate size\n            size = int(size/2) if int(size/2) > 1 else 1\n            x, y = coord\n\n            self.canvas.create_oval(\n                x-size, y-size,\n                x+size, y+size,\n                fill=color\n            )\n\n        return coord", "response": "Plots a single point on the grid."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_line(self, points: list, color='black', point_visibility=False):\n        last_point = ()\n        for point in points:\n            this_point = self.plot_point(point[0], point[1],\n                                         color=color, visible=point_visibility)\n\n            if last_point:\n                self.canvas.create_line(last_point + this_point, fill=color)\n            last_point = this_point", "response": "Plot a line of points with the given color."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef frange(start, stop, step, digits_to_round=3):\n        while start < stop:\n            yield round(start, digits_to_round)\n            start += step", "response": "A generator that yields the value of the key - value pair in the range [ start stop )."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload a new image.", "response": "def _load_new(self, img_data: str):\n        \"\"\"\n        Load a new image.\n\n        :param img_data: the image data as a base64 string\n        :return: None\n        \"\"\"\n        self._image = tk.PhotoImage(data=img_data)\n        self._image = self._image.subsample(int(200 / self._size),\n                                            int(200 / self._size))\n        self._canvas.delete('all')\n        self._canvas.create_image(0, 0, image=self._image, anchor='nw')\n\n        if self._user_click_callback is not None:\n            self._user_click_callback(self._on)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_grey(self, on: bool=False):\n        self._on = False\n        self._load_new(led_grey)", "response": "Change the LED to grey."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_green(self, on: bool=False):\n        self._on = on\n        if on:\n            self._load_new(led_green_on)\n\n            if self._toggle_on_click:\n                self._canvas.bind('<Button-1>', lambda x: self.to_green(False))\n        else:\n            self._load_new(led_green)\n\n            if self._toggle_on_click:\n                self._canvas.bind('<Button-1>', lambda x: self.to_green(True))", "response": "Change the LED to green."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nchange the LED to red.", "response": "def to_red(self, on: bool=False):\n        \"\"\"\n        Change the LED to red (on or off)\n        :param on: True or False\n        :return: None\n        \"\"\"\n        self._on = on\n        if on:\n            self._load_new(led_red_on)\n\n            if self._toggle_on_click:\n                self._canvas.bind('<Button-1>', lambda x: self.to_red(False))\n        else:\n            self._load_new(led_red)\n\n            if self._toggle_on_click:\n                self._canvas.bind('<Button-1>', lambda x: self.to_red(True))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_yellow(self, on: bool=False):\n        self._on = on\n        if on:\n            self._load_new(led_yellow_on)\n\n            if self._toggle_on_click:\n                self._canvas.bind('<Button-1>',\n                                  lambda x: self.to_yellow(False))\n        else:\n            self._load_new(led_yellow)\n\n            if self._toggle_on_click:\n                self._canvas.bind('<Button-1>',\n                                  lambda x: self.to_yellow(True))", "response": "Change the LED to yellow."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _redraw(self):\n        for row in self._rows:\n            for widget in row:\n                widget.grid_forget()\n\n        offset = 0 if not self.headers else 1\n        for i, row in enumerate(self._rows):\n            for j, widget in enumerate(row):\n                widget.grid(row=i+offset, column=j)", "response": "Forgets the current layout and redraws with the most recent information"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_row(self, row_number: int=-1):\n        if len(self._rows) == 0:\n            return\n\n        row = self._rows.pop(row_number)\n        for widget in row:\n            widget.destroy()", "response": "Removes a specified row of data\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_row(self, data: list):\n        # validation\n        if self.headers:\n            if len(self.headers) != len(data):\n                raise ValueError\n\n        if len(data) != self.num_of_columns:\n            raise ValueError\n\n        offset = 0 if not self.headers else 1\n        row = list()\n        for i, element in enumerate(data):\n            label = ttk.Label(self, text=str(element), relief=tk.GROOVE,\n                              padding=self.padding)\n            label.grid(row=len(self._rows) + offset, column=i, sticky='E,W')\n            row.append(label)\n\n        self._rows.append(row)", "response": "Adds a row of data to the current widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a row of data to the current widget and sets the focus at the beginning of the next row.", "response": "def add_row(self, data: list=None):\n        \"\"\"\n        Add a row of data to the current widget, add a <Tab> \\\n        binding to the last element of the last row, and set \\\n        the focus at the beginning of the next row.\n\n        :param data: a row of data\n        :return: None\n        \"\"\"\n        # validation\n        if self.headers and data:\n            if len(self.headers) != len(data):\n                raise ValueError\n\n        offset = 0 if not self.headers else 1\n        row = list()\n\n        if data:\n            for i, element in enumerate(data):\n                contents = '' if element is None else str(element)\n                entry = ttk.Entry(self)\n                entry.insert(0, contents)\n                entry.grid(row=len(self._rows) + offset,\n                           column=i,\n                           sticky='E,W')\n                row.append(entry)\n        else:\n            for i in range(self.num_of_columns):\n                entry = ttk.Entry(self)\n                entry.grid(row=len(self._rows) + offset,\n                           column=i,\n                           sticky='E,W')\n                row.append(entry)\n\n        self._rows.append(row)\n\n        # clear all bindings\n        for row in self._rows:\n            for widget in row:\n                widget.unbind('<Tab>')\n\n        def add(e):\n            self.add_row()\n\n        last_entry = self._rows[-1][-1]\n        last_entry.bind('<Tab>', add)\n\n        e = self._rows[-1][0]\n        e.focus_set()\n\n        self._redraw()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread the data contained in all entries as a list of dicts with the headers as the dictionary keys", "response": "def _read_as_dict(self):\n        \"\"\"\n        Read the data contained in all entries as a list of\n        dictionaries with the headers as the dictionary keys\n\n        :return: list of dicts containing all tabular data\n        \"\"\"\n        data = list()\n        for row in self._rows:\n            row_data = OrderedDict()\n            for i, header in enumerate(self.headers):\n                row_data[header.cget('text')] = row[i].get()\n\n            data.append(row_data)\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading the data contained in all entries as a list of dicts containing all of the data", "response": "def _read_as_table(self):\n        \"\"\"\n        Read the data contained in all entries as a list of\n        lists containing all of the data\n\n        :return: list of dicts containing all tabular data\n        \"\"\"\n        rows = list()\n\n        for row in self._rows:\n            rows.append([row[i].get() for i in range(self.num_of_columns)])\n\n        return rows"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_row(self, data: list):\n\n        # validation\n        if self.headers and data:\n            if len(self.headers) != len(data):\n                raise ValueError\n\n        offset = 0 if not self.headers else 1\n        row = list()\n\n        for i, e in enumerate(data):\n            if not isinstance(e, tuple):\n                raise ValueError('all elements must be a tuple '\n                                 'consisting of (\"label\", <command>)')\n\n            label, command = e\n            button = tk.Button(self, text=str(label), relief=tk.RAISED,\n                               command=command,\n                               padx=self.padding,\n                               pady=self.padding)\n\n            button.grid(row=len(self._rows) + offset, column=i, sticky='ew')\n            row.append(button)\n\n        self._rows.append(row)", "response": "Adds a row of buttons each with their own callbacks to the current widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a row to the list and re - draw as necessary.", "response": "def add_row(self, key: str, default: str=None,\n                unit_label: str=None, enable: bool=None):\n        \"\"\"\n        Add a single row and re-draw as necessary\n\n        :param key: the name and dict accessor\n        :param default: the default value\n        :param unit_label: the label that should be \\\n        applied at the right of the entry\n        :param enable: the 'enabled' state (defaults to True)\n        :return:\n        \"\"\"\n        self.keys.append(ttk.Label(self, text=key))\n\n        self.defaults.append(default)\n        self.unit_labels.append(\n            ttk.Label(self, text=unit_label if unit_label else '')\n        )\n        self.enables.append(enable)\n        self.values.append(ttk.Entry(self))\n\n        row_offset = 1 if self.title is not None else 0\n\n        for i in range(len(self.keys)):\n            self.keys[i].grid_forget()\n\n            self.keys[i].grid(row=row_offset, column=0, sticky='e')\n            self.values[i].grid(row=row_offset, column=1)\n\n            if self.unit_labels[i]:\n                self.unit_labels[i].grid(row=row_offset, column=3, sticky='w')\n\n            if self.defaults[i]:\n                self.values[i].config(state=tk.NORMAL)\n                self.values[i].delete(0, tk.END)\n                self.values[i].insert(0, self.defaults[i])\n\n            if self.enables[i] in [True, None]:\n                self.values[i].config(state=tk.NORMAL)\n            elif self.enables[i] is False:\n                self.values[i].config(state=tk.DISABLED)\n\n            row_offset += 1\n\n            # strip <Return> and <Tab> bindings, add callbacks to all entries\n            self.values[i].unbind('<Return>')\n            self.values[i].unbind('<Tab>')\n\n            if self.callback is not None:\n                def callback(event):\n                    self.callback()\n\n                self.values[i].bind('<Return>', callback)\n                self.values[i].bind('<Tab>', callback)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreset all entries in the list to their default values.", "response": "def reset(self):\n        \"\"\"\n        Clears all entries.\n\n        :return: None\n        \"\"\"\n        for i in range(len(self.values)):\n            self.values[i].delete(0, tk.END)\n\n            if self.defaults[i] is not None:\n                self.values[i].insert(0, self.defaults[i])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef change_enables(self, enables_list: list):\n        for i, entry in enumerate(self.values):\n            if enables_list[i]:\n                entry.config(state=tk.NORMAL)\n            else:\n                entry.config(state=tk.DISABLED)", "response": "Change the enable states of all key - related items in the archive."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load(self, data: dict):\n        for i, label in enumerate(self.keys):\n            key = label.cget('text')\n            if key in data.keys():\n                entry_was_enabled = True if \\\n                    self.values[i].cget('state') == 'normal' else False\n                if not entry_was_enabled:\n                    self.values[i].config(state='normal')\n\n                self.values[i].delete(0, tk.END)\n                self.values[i].insert(0, str(data[key]))\n\n                if not entry_was_enabled:\n                    self.values[i].config(state='disabled')", "response": "Load values into the key - value store via dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves the GUI elements for program use.", "response": "def get(self):\n        \"\"\"\n        Retrieve the GUI elements for program use.\n\n        :return: a dictionary containing all \\\n        of the data from the key/value entries\n        \"\"\"\n        data = dict()\n        for label, entry in zip(self.keys, self.values):\n            data[label.cget('text')] = entry.get()\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls when the calendar is clicked.", "response": "def _pressed(self, evt):\n        \"\"\"\n        Clicked somewhere in the calendar.\n        \"\"\"\n        x, y, widget = evt.x, evt.y, evt.widget\n        item = widget.identify_row(y)\n        column = widget.identify_column(x)\n\n        if not column or not (item in self._items):\n            # clicked in the weekdays row or just outside the columns\n            return\n\n        item_values = widget.item(item)['values']\n        if not len(item_values):  # row is empty for this month\n            return\n\n        text = item_values[int(column[1]) - 1]\n        if not text:  # date is empty\n            return\n\n        bbox = widget.bbox(item, column)\n        if not bbox:  # calendar not visible yet\n            return\n\n        # update and then show selection\n        text = '%02d' % text\n        self._selection = (text, item, column)\n        self._show_selection(text, bbox)\n\n        if self.callback is not None:\n            self.callback()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding the contents of string to the entry field and clears the contents of the entry field and inserts the contents of string.", "response": "def add(self, string: (str, list)):\n        \"\"\"\n        Clear the contents of the entry field and\n        insert the contents of string.\n\n        :param string: an str containing the text to display\n        :return:\n        \"\"\"\n        if len(self._entries) == 1:\n            self._entries[0].delete(0, 'end')\n            self._entries[0].insert(0, string)\n        else:\n            if len(string) != len(self._entries):\n                raise ValueError('the \"string\" list must be '\n                                 'equal to the number of entries')\n\n            for i, e in enumerate(self._entries):\n                self._entries[i].delete(0, 'end')\n                self._entries[i].insert(0, string[i])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes itself. :return: None", "response": "def remove(self):\n        \"\"\"\n        Deletes itself.\n        :return: None\n        \"\"\"\n        for e in self._entries:\n            e.grid_forget()\n            e.destroy()\n\n        self._remove_btn.grid_forget()\n        self._remove_btn.destroy()\n\n        self.deleted = True\n\n        if self._remove_callback:\n            self._remove_callback()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the value for the slot.", "response": "def get(self):\n        \"\"\"\n        Returns the value for the slot.\n        :return: the entry value\n        \"\"\"\n        values = [e.get() for e in self._entries]\n        if len(self._entries) == 1:\n            return values[0]\n        else:\n            return values"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclear the current layout and re - draw all elements in self. _slots", "response": "def _redraw(self):\n        \"\"\"\n        Clears the current layout and re-draws all elements in self._slots\n        :return:\n        \"\"\"\n        if self._blank_label:\n            self._blank_label.grid_forget()\n            self._blank_label.destroy()\n            self._blank_label = None\n\n        for slot in self._slots:\n            slot.grid_forget()\n\n        self._slots = [slot for slot in self._slots if not slot.deleted]\n\n        max_per_col = 8\n        for i, slot in enumerate(self._slots):\n            slot.grid(row=i % max_per_col,\n                      column=int(i / max_per_col), sticky='ew')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add(self, string: (str, list)):\n        slot = _SlotFrame(self,\n                          remove_callback=self._redraw,\n                          entries=self._slot_columns)\n        slot.add(string)\n\n        self._slots.append(slot)\n\n        self._redraw()", "response": "Adds a new slot to the multi - frame containing the string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clear(self):\n        for slot in self._slots:\n            slot.grid_forget()\n            slot.destroy()\n\n        self._slots = []", "response": "Clear out the multi - frame cache."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclear the current color of all the active frames.", "response": "def clear(self):\n        \"\"\"\n        Clear the segment.\n        :return: None\n        \"\"\"\n        for _, frame in self._segments.items():\n            frame.configure(background=self._bg_color)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_value(self, value: str):\n\n        self.clear()\n\n        if '.' in value:\n            self._segments['period'].configure(background=self._color)\n\n        if value in ['0', '0.']:\n            self._segments['a'].configure(background=self._color)\n            self._segments['b'].configure(background=self._color)\n            self._segments['c'].configure(background=self._color)\n            self._segments['d'].configure(background=self._color)\n            self._segments['e'].configure(background=self._color)\n            self._segments['f'].configure(background=self._color)\n        elif value in ['1', '1.']:\n            self._segments['b'].configure(background=self._color)\n            self._segments['c'].configure(background=self._color)\n        elif value in ['2', '2.']:\n            self._segments['a'].configure(background=self._color)\n            self._segments['b'].configure(background=self._color)\n            self._segments['g'].configure(background=self._color)\n            self._segments['e'].configure(background=self._color)\n            self._segments['d'].configure(background=self._color)\n        elif value in ['3', '3.']:\n            self._segments['a'].configure(background=self._color)\n            self._segments['b'].configure(background=self._color)\n            self._segments['g'].configure(background=self._color)\n            self._segments['c'].configure(background=self._color)\n            self._segments['d'].configure(background=self._color)\n        elif value in ['4', '4.']:\n            self._segments['f'].configure(background=self._color)\n            self._segments['g'].configure(background=self._color)\n            self._segments['b'].configure(background=self._color)\n            self._segments['c'].configure(background=self._color)\n        elif value in ['5', '5.']:\n            self._segments['a'].configure(background=self._color)\n            self._segments['f'].configure(background=self._color)\n            self._segments['g'].configure(background=self._color)\n            self._segments['c'].configure(background=self._color)\n            self._segments['d'].configure(background=self._color)\n        elif value in ['6', '6.']:\n            self._segments['f'].configure(background=self._color)\n            self._segments['g'].configure(background=self._color)\n            self._segments['c'].configure(background=self._color)\n            self._segments['d'].configure(background=self._color)\n            self._segments['e'].configure(background=self._color)\n        elif value in ['7', '7.']:\n            self._segments['a'].configure(background=self._color)\n            self._segments['b'].configure(background=self._color)\n            self._segments['c'].configure(background=self._color)\n        elif value in ['8', '8.']:\n            self._segments['a'].configure(background=self._color)\n            self._segments['b'].configure(background=self._color)\n            self._segments['c'].configure(background=self._color)\n            self._segments['d'].configure(background=self._color)\n            self._segments['e'].configure(background=self._color)\n            self._segments['f'].configure(background=self._color)\n            self._segments['g'].configure(background=self._color)\n        elif value in ['9', '9.']:\n            self._segments['a'].configure(background=self._color)\n            self._segments['b'].configure(background=self._color)\n            self._segments['c'].configure(background=self._color)\n            self._segments['f'].configure(background=self._color)\n            self._segments['g'].configure(background=self._color)\n        elif value in ['-']:\n            self._segments['g'].configure(background=self._color)\n\n        else:\n            raise ValueError('unsupported character: {}'.format(value))", "response": "Sets the value of the 7 - segment display."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _group(self, value: str):\n        reversed_v = value[::-1]\n\n        parts = []\n\n        has_period = False\n        for c in reversed_v:\n            if has_period:\n                parts.append(c + '.')\n                has_period = False\n            elif c == '.':\n                has_period = True\n            else:\n                parts.append(c)\n\n        parts = parts[:len(self._digits)]\n\n        return parts", "response": "Takes a string and groups it appropriately with any appropriate punctuation so that it is a log entry."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the displayed digits based on the value string.", "response": "def set_value(self, value: str):\n        \"\"\"\n        Sets the displayed digits based on the value string.\n        :param value: a string containing an integer or float value\n        :return: None\n        \"\"\"\n        [digit.clear() for digit in self._digits]\n\n        grouped = self._group(value)  # return the parts, reversed\n        digits = self._digits[::-1]  # reverse the digits\n\n        # fill from right to left\n        has_period = False\n        for i, digit_value in enumerate(grouped):\n            try:\n                if has_period:\n                    digits[i].set_value(digit_value + '.')\n                    has_period = False\n\n                elif grouped[i] == '.':\n                    has_period = True\n\n                else:\n                    digits[i].set_value(digit_value)\n            except IndexError:\n                raise ValueError('the value \"{}\" contains too '\n                                 'many digits'.format(value))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a callback on change", "response": "def add_callback(self, callback: callable):\n        \"\"\"\n        Add a callback on change\n\n        :param callback: callable function\n        :return: None\n        \"\"\"\n        def internal_callback(*args):\n            try:\n                callback()\n            except TypeError:\n                callback(self.get())\n\n        self._var.trace('w', internal_callback)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set(self, value: int):\n        max_value = int(''.join(['1' for _ in range(self._bit_width)]), 2)\n\n        if value > max_value:\n            raise ValueError('the value {} is larger than '\n                             'the maximum value {}'.format(value, max_value))\n\n        self._value = value\n        self._text_update()", "response": "Set the current value of the current locale."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the bit value at the specified position", "response": "def get_bit(self, position: int):\n        \"\"\"\n        Returns the bit value at position\n\n        :param position: integer between 0 and <width>, inclusive\n        :return: the value at position as a integer\n        \"\"\"\n\n        if position > (self._bit_width - 1):\n            raise ValueError('position greater than the bit width')\n\n        if self._value & (1 << position):\n            return 1\n        else:\n            return 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntoggling the value at position", "response": "def toggle_bit(self, position: int):\n        \"\"\"\n        Toggles the value at position\n\n        :param position: integer between 0 and 7, inclusive\n        :return: None\n        \"\"\"\n        if position > (self._bit_width - 1):\n            raise ValueError('position greater than the bit width')\n\n        self._value ^= (1 << position)\n        self._text_update()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the value at the specified position in the bit string.", "response": "def set_bit(self, position: int):\n        \"\"\"\n        Sets the value at position\n\n        :param position: integer between 0 and 7, inclusive\n        :return: None\n        \"\"\"\n        if position > (self._bit_width - 1):\n            raise ValueError('position greater than the bit width')\n\n        self._value |= (1 << position)\n        self._text_update()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nclearing the bit at the specified position.", "response": "def clear_bit(self, position: int):\n        \"\"\"\n        Clears the value at position\n\n        :param position: integer between 0 and 7, inclusive\n        :return: None\n        \"\"\"\n        if position > (self._bit_width - 1):\n            raise ValueError('position greater than the bit width')\n\n        self._value &= ~(1 << position)\n        self._text_update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npopulates this list by calling populate but only once.", "response": "def _populate(self):\n        \"\"\" Populate this list by calling populate(), but only once. \"\"\"\n        if not self._populated:\n            logging.debug(\"Populating lazy list %d (%s)\" % (id(self), self.__class__.__name__))\n            try:\n                self.populate()\n                self._populated = True\n            except Exception, e:\n                logging.debug(\"Currently unable to populate lazy list: %s\" % e)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _register_admin(admin_site, model, admin_class):\n    try:\n        admin_site.register(model, admin_class)\n    except admin.sites.AlreadyRegistered:\n        pass", "response": "Register model in the admin."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of core choice fields.", "response": "def core_choice_fields(metadata_class):\n    \"\"\" If the 'optional' core fields (_site and _language) are required, \n        list them here. \n    \"\"\"\n    fields = []\n    if metadata_class._meta.use_sites:\n        fields.append('_site')\n    if metadata_class._meta.use_i18n:\n        fields.append('_language')\n    return fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _monkey_inline(model, admin_class_instance, metadata_class, inline_class, admin_site):\n    if model in metadata_class._meta.seo_models:\n        # *Not* adding to the class attribute \"inlines\", as this will affect\n        # all instances from this class. Explicitly adding to instance attribute.\n        admin_class_instance.__dict__['inlines'] = admin_class_instance.inlines + [inline_class]\n\n        # Because we've missed the registration, we need to perform actions\n        # that were done then (on admin class instantiation)\n        inline_instance = inline_class(admin_class_instance.model, admin_site)\n        admin_class_instance.inline_instances.append(inline_instance)", "response": "Monkey patch the inline onto the given admin_class instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _with_inline(func, admin_site, metadata_class, inline_class):\n\n    def register(model_or_iterable, admin_class=None, **options):\n        # Call the (bound) function we were given.\n        # We have to assume it will be bound to admin_site\n        func(model_or_iterable, admin_class, **options)\n        _monkey_inline(model_or_iterable, admin_site._registry[model_or_iterable], metadata_class, inline_class, admin_site)\n\n    return register", "response": "Decorator for register function that adds an appropriate inline."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_linked_metadata(obj, name=None, context=None, site=None, language=None):\n    # XXX Check that 'modelinstance' and 'model' metadata are installed in backends\n    # I believe that get_model() would return None if not\n    Metadata = _get_metadata_model(name)\n    InstanceMetadata = Metadata._meta.get_model('modelinstance')\n    ModelMetadata = Metadata._meta.get_model('model')\n    content_type = ContentType.objects.get_for_model(obj)\n    instances = []\n    if InstanceMetadata is not None:\n        try:\n            instance_md = InstanceMetadata.objects.get(_content_type=content_type, _object_id=obj.pk)\n        except InstanceMetadata.DoesNotExist:\n            instance_md = InstanceMetadata(_content_object=obj)\n        instances.append(instance_md)\n    if ModelMetadata is not None:\n        try:\n            model_md = ModelMetadata.objects.get(_content_type=content_type)\n        except ModelMetadata.DoesNotExist:\n            model_md = ModelMetadata(_content_type=content_type)\n        instances.append(model_md)    \n    return FormattedMetadata(Metadata, instances, '', site, language)", "response": "Gets the metadata linked to the given object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef populate_metadata(model, MetadataClass):\n    content_type = ContentType.objects.get_for_model(model)\n    for instance in model.objects.all():\n        create_metadata_instance(MetadataClass, instance)", "response": "Populates the metadata class with the metadata for every object in the given model."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __instances(self):\n        for instance in self.__instances_cache:\n            yield instance\n        for instance in self.__instances_original:\n            self.__instances_cache.append(instance)\n            yield instance", "response": "Yields all the instances in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _resolve_value(self, name):\n        for instance in self.__instances():\n            value = instance._resolve_value(name)\n            if value:\n                return value\n\n        # Otherwise, return an appropriate default value (populate_from)\n        # TODO: This is duplicated in meta_models. Move this to a common home.\n        if name in self.__metadata._meta.elements:\n            populate_from = self.__metadata._meta.elements[name].populate_from\n            if callable(populate_from):\n                return populate_from(None)\n            elif isinstance(populate_from, Literal):\n                return populate_from.value\n            elif populate_from is not NotSet:\n                return self._resolve_value(populate_from)", "response": "Resolves the value for the given name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_formatted_data(cls, path, context=None, site=None, language=None):\n        return FormattedMetadata(cls(), cls._get_instances(path, context, site, language), path, site, language)", "response": "Return an object to conveniently access the appropriate values."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_instances(cls, path, context=None, site=None, language=None):\n        backend_context = {'view_context': context }\n\n        for model in cls._meta.models.values():\n            for instance in model.objects.get_instances(path, site, language, backend_context) or []:\n                if hasattr(instance, '_process_context'):\n                    instance._process_context(backend_context)\n                yield instance", "response": "A generator that yields all instances from each backend that are available for the given path."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _resolve(value, model_instance=None, context=None):\n\n    if isinstance(value, basestring) and \"{\" in value:\n        if context is None:\n            context = Context()\n        if model_instance is not None:\n            context[model_instance._meta.module_name] = model_instance\n        value = Template(value).render(context)\n    return value", "response": "Resolves any template references in the given value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate(options):\n        try:\n            if options.backends.index('modelinstance') > options.backends.index('model'):\n                raise Exception(\"Metadata backend 'modelinstance' must come before 'model' backend\")\n        except ValueError:\n            raise Exception(\"Metadata backend 'modelinstance' must be installed in order to use 'model' backend\")", "response": "Validates the application of this backend to a given metadata \n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake elements from the metadata class and creates a base model for all backend models.", "response": "def _register_elements(self, elements):\n        \"\"\" Takes elements from the metadata class and creates a base model for all backend models .\n        \"\"\"\n        self.elements = elements\n\n        for key, obj in elements.items():\n            obj.contribute_to_class(self.metadata, key)\n\n        # Create the common Django fields\n        fields = {}\n        for key, obj in elements.items():\n            if obj.editable:\n                field = obj.get_field()\n                if not field.help_text:\n                    if key in self.bulk_help_text:\n                        field.help_text = self.bulk_help_text[key]\n                fields[key] = field\n\n        # 0. Abstract base model with common fields\n        base_meta = type('Meta', (), self.original_meta)\n        class BaseMeta(base_meta):\n            abstract = True\n            app_label = 'seo'\n        fields['Meta'] = BaseMeta\n        # Do we need this?\n        fields['__module__'] = __name__ #attrs['__module__']\n        self.MetadataBaseModel = type('%sBase' % self.name, (models.Model,), fields)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _add_backend(self, backend):\n        md_type = backend.verbose_name\n        base = backend().get_model(self)\n        # TODO: Rename this field\n        new_md_attrs = {'_metadata': self.metadata, '__module__': __name__ }\n\n        new_md_meta = {}\n        new_md_meta['verbose_name'] = '%s (%s)' % (self.verbose_name, md_type)\n        new_md_meta['verbose_name_plural'] = '%s (%s)' % (self.verbose_name_plural, md_type)\n        new_md_meta['unique_together'] = base._meta.unique_together\n        new_md_attrs['Meta'] = type(\"Meta\", (), new_md_meta)\n        new_md_attrs['_metadata_type'] = backend.name\n        model = type(\"%s%s\"%(self.name,\"\".join(md_type.split())), (base, self.MetadataBaseModel), new_md_attrs.copy())\n        self.models[backend.name] = model\n        # This is a little dangerous, but because we set __module__ to __name__, the model needs tobe accessible here\n        globals()[model.__name__] = model", "response": "Adds a backend to the metadata base model"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the list of models to be used.", "response": "def _set_seo_models(self, value):\n        \"\"\" Gets the actual models to be used. \"\"\"\n        seo_models = []\n        for model_name in value:\n            if \".\" in model_name:\n                app_label, model_name = model_name.split(\".\", 1)\n                model = models.get_model(app_label, model_name)\n                if model:\n                    seo_models.append(model)\n            else:\n                app = models.get_app(model_name)\n                if app:\n                    seo_models.extend(models.get_models(app))\n    \n        self.seo_models = seo_models"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate(self):\n        if not self.editable:\n            assert self.populate_from is not NotSet, u\"If field (%s) is not editable, you must set populate_from\" % self.name", "response": "Validate that the field is valid."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef populate_all_metadata():\n    for Metadata in registry.values():\n        InstanceMetadata = Metadata._meta.get_model('modelinstance')\n        if InstanceMetadata is not None:\n            for model in Metadata._meta.seo_models:\n                populate_metadata(model, InstanceMetadata)", "response": "Populate all metadata instances for all models in seo_models."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npopulates this list with all views that take no arguments.", "response": "def populate(self):\n        \"\"\" Populate this list with all views that take no arguments.\n        \"\"\"\n        from django.conf import settings\n        from django.core import urlresolvers\n\n        self.append((\"\", \"\"))\n        urlconf = settings.ROOT_URLCONF\n        resolver = urlresolvers.RegexURLResolver(r'^/', urlconf)\n        # Collect base level views\n        for key, value in resolver.reverse_dict.items():\n            if isinstance(key, basestring):\n                args = value[0][0][1]\n                url = \"/\" + value[0][0][0]\n                self.append((key, \" \".join(key.split(\"_\"))))\n        # Collect namespaces (TODO: merge these two sections into one)\n        for namespace, url in resolver.namespace_dict.items():\n            for key, value in url[1].reverse_dict.items():\n                if isinstance(key, basestring):\n                    args = value[0][0][1]\n                    full_key = '%s:%s' % (namespace, key)\n                    self.append((full_key, \"%s: %s\" % (namespace, \" \".join(key.split(\"_\")))))\n        self.sort()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a generator that yields a list of blocks of size block_size.", "response": "def block_splitter(data, block_size):\n    \"\"\"\n    Creates a generator by slicing ``data`` into chunks of ``block_size``.\n\n    >>> data = range(10)\n    >>> list(block_splitter(data, 2))\n    [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]\n\n    If ``data`` cannot be evenly divided by ``block_size``, the last block will\n    simply be the remainder of the data. Example:\n\n    >>> data = range(10)\n    >>> list(block_splitter(data, 3))\n    [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n\n    If the ``block_size`` is greater than the total length of ``data``, a\n    single block will be generated:\n\n    >>> data = range(3)\n    >>> list(block_splitter(data, 4))\n    [[0, 1, 2]]\n\n    :param data:\n        Any iterable. If ``data`` is a generator, it will be exhausted,\n        obviously.\n    :param int block_site:\n        Desired (maximum) block size.\n    \"\"\"\n    buf = []\n    for i, datum in enumerate(data):\n        buf.append(datum)\n        if len(buf) == block_size:\n            yield buf\n            buf = []\n\n    # If there's anything leftover (a partial block),\n    # yield it as well.\n    if buf:\n        yield buf"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef round_geom(geom, precision=None):\n    if geom['type'] == 'Point':\n        x, y = geom['coordinates']\n        xp, yp = [x], [y]\n        if precision is not None:\n            xp = [round(v, precision) for v in xp]\n            yp = [round(v, precision) for v in yp]\n        new_coords = tuple(zip(xp, yp))[0]\n    if geom['type'] in ['LineString', 'MultiPoint']:\n        xp, yp = zip(*geom['coordinates'])\n        if precision is not None:\n            xp = [round(v, precision) for v in xp]\n            yp = [round(v, precision) for v in yp]\n        new_coords = tuple(zip(xp, yp))\n    elif geom['type'] in ['Polygon', 'MultiLineString']:\n        new_coords = []\n        for piece in geom['coordinates']:\n            xp, yp = zip(*piece)\n            if precision is not None:\n                xp = [round(v, precision) for v in xp]\n                yp = [round(v, precision) for v in yp]\n            new_coords.append(tuple(zip(xp, yp)))\n    elif geom['type'] == 'MultiPolygon':\n        parts = geom['coordinates']\n        new_coords = []\n        for part in parts:\n            inner_coords = []\n            for ring in part:\n                xp, yp = zip(*ring)\n                if precision is not None:\n                    xp = [round(v, precision) for v in xp]\n                    yp = [round(v, precision) for v in yp]\n                inner_coords.append(tuple(zip(xp, yp)))\n            new_coords.append(inner_coords)\n    return {'type': geom['type'], 'coordinates': new_coords}", "response": "Round coordinates of a geometric object to given precision."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef flatten_multi_dim(sequence):\n    for x in sequence:\n        if (isinstance(x, collections.Iterable)\n                and not isinstance(x, six.string_types)):\n            for y in flatten_multi_dim(x):\n                yield y\n        else:\n            yield x", "response": "Flatten a multi - dimensional array - like to a single dimensional sequence - like."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts text read from the first positional argument stdin or a file to GeoJSON and write to stdout.", "response": "def cli(input, verbose, quiet, output_format, precision, indent):\n    \"\"\"Convert text read from the first positional argument, stdin, or\n    a file to GeoJSON and write to stdout.\"\"\"\n\n    verbosity = verbose - quiet\n    configure_logging(verbosity)\n    logger = logging.getLogger('geomet')\n\n    # Handle the case of file, stream, or string input.\n    try:\n        src = click.open_file(input).readlines()\n    except IOError:\n        src = [input]\n\n    stdout = click.get_text_stream('stdout')\n\n    # Read-write loop.\n    try:\n        for line in src:\n            text = line.strip()\n            logger.debug(\"Input: %r\", text)\n            output = translate(\n                text,\n                output_format=output_format,\n                indent=indent,\n                precision=precision\n            )\n            logger.debug(\"Output: %r\", output)\n            stdout.write(output)\n            stdout.write('\\n')\n        sys.exit(0)\n    except Exception:\n        logger.exception(\"Failed. Exception caught\")\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_geom_type(type_bytes):\n    # slice off the high byte, which may contain the SRID flag\n    high_byte = type_bytes[0]\n    if six.PY3:\n        high_byte = bytes([high_byte])\n    has_srid = high_byte == b'\\x20'\n    if has_srid:\n        # replace the high byte with a null byte\n        type_bytes = as_bin_str(b'\\x00' + type_bytes[1:])\n    else:\n        type_bytes = as_bin_str(type_bytes)\n\n    # look up the geometry type\n    geom_type = _BINARY_TO_GEOM_TYPE.get(type_bytes)\n    return geom_type, type_bytes, has_srid", "response": "Get the GeoJSON geometry type label from a WKB type byte string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndumping a GeoJSON - like dict to a WKB string.", "response": "def dumps(obj, big_endian=True):\n    \"\"\"\n    Dump a GeoJSON-like `dict` to a WKB string.\n\n    .. note::\n        The dimensions of the generated WKB will be inferred from the first\n        vertex in the GeoJSON `coordinates`. It will be assumed that all\n        vertices are uniform. There are 4 types:\n\n        - 2D (X, Y): 2-dimensional geometry\n        - Z (X, Y, Z): 3-dimensional geometry\n        - M (X, Y, M): 2-dimensional geometry with a \"Measure\"\n        - ZM (X, Y, Z, M): 3-dimensional geometry with a \"Measure\"\n\n        If the first vertex contains 2 values, we assume a 2D geometry.\n        If the first vertex contains 3 values, this is slightly ambiguous and\n        so the most common case is chosen: Z.\n        If the first vertex contains 4 values, we assume a ZM geometry.\n\n        The WKT/WKB standards provide a way of differentiating normal (2D), Z,\n        M, and ZM geometries (http://en.wikipedia.org/wiki/Well-known_text),\n        but the GeoJSON spec does not. Therefore, for the sake of interface\n        simplicity, we assume that geometry that looks 3D contains XYZ\n        components, instead of XYM.\n\n        If the coordinates list has no coordinate values (this includes nested\n        lists, for example, `[[[[],[]], []]]`, the geometry is considered to be\n        empty. Geometries, with the exception of points, have a reasonable\n        \"empty\" representation in WKB; however, without knowing the number of\n        coordinate values per vertex, the type is ambigious, and thus we don't\n        know if the geometry type is 2D, Z, M, or ZM. Therefore in this case\n        we expect a `ValueError` to be raised.\n\n    :param dict obj:\n        GeoJson-like `dict` object.\n    :param bool big_endian:\n        Defaults to `True`. If `True`, data values in the generated WKB will\n        be represented using big endian byte order. Else, little endian.\n\n    TODO: remove this\n\n    :param str dims:\n        Indicates to WKB representation desired from converting the given\n        GeoJSON `dict` ``obj``. The accepted values are:\n\n        * '2D': 2-dimensional geometry (X, Y)\n        * 'Z': 3-dimensional geometry (X, Y, Z)\n        * 'M': 3-dimensional geometry (X, Y, M)\n        * 'ZM': 4-dimensional geometry (X, Y, Z, M)\n\n    :returns:\n        A WKB binary string representing of the ``obj``.\n    \"\"\"\n    geom_type = obj['type']\n    meta = obj.get('meta', {})\n\n    exporter = _dumps_registry.get(geom_type)\n    if exporter is None:\n        _unsupported_geom_type(geom_type)\n\n    # Check for empty geometries. GeometryCollections have a slightly different\n    # JSON/dict structure, but that's handled.\n    coords_or_geoms = obj.get('coordinates', obj.get('geometries'))\n    if len(list(flatten_multi_dim(coords_or_geoms))) == 0:\n        raise ValueError(\n            'Empty geometries cannot be represented in WKB. Reason: The '\n            'dimensionality of the WKB would be ambiguous.'\n        )\n\n    return exporter(obj, big_endian, meta)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntakes a WKB string and returns a GeoJSON dict.", "response": "def loads(string):\n    \"\"\"\n    Construct a GeoJSON `dict` from WKB (`string`).\n\n    The resulting GeoJSON `dict` will include the SRID as an integer in the\n    `meta` object. This was an arbitrary decision made by `geomet, the\n    discussion of which took place here:\n    https://github.com/geomet/geomet/issues/28.\n\n    In order to be consistent with other libraries [1] and (deprecated)\n    specifications [2], also include the same information in a `crs`\n    object. This isn't ideal, but the `crs` member is no longer part of\n    the GeoJSON standard, according to RFC7946 [3]. However, it's still\n    useful to include this information in GeoJSON payloads because it\n    supports conversion to EWKT/EWKB (which are canonical formats used by\n    PostGIS and the like).\n\n    Example:\n\n        {'type': 'Point',\n         'coordinates': [0.0, 1.0],\n         'meta': {'srid': 4326},\n         'crs': {'type': 'name', 'properties': {'name': 'EPSG4326'}}}\n\n    NOTE(larsbutler): I'm not sure if it's valid to just prefix EPSG\n    (European Petroluem Survey Group) to an SRID like this, but we'll\n    stick with it for now until it becomes a problem.\n\n    NOTE(larsbutler): Ideally, we should use URNs instead of this\n    notation, according to the new GeoJSON spec [4]. However, in\n    order to be consistent with [1], we'll stick with this approach\n    for now.\n\n    References:\n\n    [1] - https://github.com/bryanjos/geo/issues/76\n    [2] - http://geojson.org/geojson-spec.html#coordinate-reference-system-objects\n    [3] - https://tools.ietf.org/html/rfc7946#appendix-B.1\n    [4] - https://tools.ietf.org/html/rfc7946#section-4\n    \"\"\"  # noqa\n    string = iter(string)\n    # endianness = string[0:1]\n    endianness = as_bin_str(take(1, string))\n    if endianness == BIG_ENDIAN:\n        big_endian = True\n    elif endianness == LITTLE_ENDIAN:\n        big_endian = False\n    else:\n        raise ValueError(\"Invalid endian byte: '0x%s'. Expected 0x00 or 0x01\"\n                         % binascii.hexlify(endianness.encode()).decode())\n\n    endian_token = '>' if big_endian else '<'\n    # type_bytes = string[1:5]\n    type_bytes = as_bin_str(take(4, string))\n    if not big_endian:\n        # To identify the type, order the type bytes in big endian:\n        type_bytes = type_bytes[::-1]\n\n    geom_type, type_bytes, has_srid = _get_geom_type(type_bytes)\n    srid = None\n    if has_srid:\n        srid_field = as_bin_str(take(4, string))\n        [srid] = struct.unpack('%si' % endian_token, srid_field)\n\n    # data_bytes = string[5:]  # FIXME: This won't work for GeometryCollections\n    data_bytes = string\n\n    importer = _loads_registry.get(geom_type)\n\n    if importer is None:\n        _unsupported_geom_type(geom_type)\n\n    data_bytes = iter(data_bytes)\n    result = importer(big_endian, type_bytes, data_bytes)\n    if has_srid:\n        # As mentioned in the docstring above, include both approaches to\n        # indicating the SRID.\n        result['meta'] = {'srid': int(srid)}\n        result['crs'] = {\n            'type': 'name',\n            'properties': {'name': 'EPSG%s' % srid},\n        }\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _header_bytefmt_byteorder(geom_type, num_dims, big_endian, meta=None):\n    dim = _INT_TO_DIM_LABEL.get(num_dims)\n    if dim is None:\n        pass  # TODO: raise\n\n    type_byte_str = _WKB[dim][geom_type]\n    srid = meta.get('srid')\n    if srid is not None:\n        # Add the srid flag\n        type_byte_str = SRID_FLAG + type_byte_str[1:]\n\n    if big_endian:\n        header = BIG_ENDIAN\n        byte_fmt = b'>'\n        byte_order = '>'\n    else:\n        header = LITTLE_ENDIAN\n        byte_fmt = b'<'\n        byte_order = '<'\n        # reverse the byte ordering for little endian\n        type_byte_str = type_byte_str[::-1]\n\n    header += type_byte_str\n    if srid is not None:\n        srid = int(srid)\n\n        if big_endian:\n            srid_header = struct.pack('>i', srid)\n        else:\n            srid_header = struct.pack('<i', srid)\n        header += srid_header\n    byte_fmt += b'd' * num_dims\n\n    return header, byte_fmt, byte_order", "response": "Utility function to get the header byte format string and byte order string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _dump_point(obj, big_endian, meta):\n    coords = obj['coordinates']\n    num_dims = len(coords)\n\n    wkb_string, byte_fmt, _ = _header_bytefmt_byteorder(\n        'Point', num_dims, big_endian, meta\n    )\n\n    wkb_string += struct.pack(byte_fmt, *coords)\n    return wkb_string", "response": "Dump a GeoJSON - like dict to a point WKB string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndumping a GeoJSON - like dict to a linestring WKB string.", "response": "def _dump_linestring(obj, big_endian, meta):\n    \"\"\"\n    Dump a GeoJSON-like `dict` to a linestring WKB string.\n\n    Input parameters and output are similar to :func:`_dump_point`.\n    \"\"\"\n    coords = obj['coordinates']\n    vertex = coords[0]\n    # Infer the number of dimensions from the first vertex\n    num_dims = len(vertex)\n\n    wkb_string, byte_fmt, byte_order = _header_bytefmt_byteorder(\n        'LineString', num_dims, big_endian, meta\n    )\n    # append number of vertices in linestring\n    wkb_string += struct.pack('%sl' % byte_order, len(coords))\n\n    for vertex in coords:\n        wkb_string += struct.pack(byte_fmt, *vertex)\n\n    return wkb_string"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndumps a GeoJSON - like dict to a multipoint WKB string.", "response": "def _dump_multipoint(obj, big_endian, meta):\n    \"\"\"\n    Dump a GeoJSON-like `dict` to a multipoint WKB string.\n\n    Input parameters and output are similar to :funct:`_dump_point`.\n    \"\"\"\n    coords = obj['coordinates']\n    vertex = coords[0]\n    num_dims = len(vertex)\n\n    wkb_string, byte_fmt, byte_order = _header_bytefmt_byteorder(\n        'MultiPoint', num_dims, big_endian, meta\n    )\n\n    point_type = _WKB[_INT_TO_DIM_LABEL.get(num_dims)]['Point']\n    if big_endian:\n        point_type = BIG_ENDIAN + point_type\n    else:\n        point_type = LITTLE_ENDIAN + point_type[::-1]\n\n    wkb_string += struct.pack('%sl' % byte_order, len(coords))\n    for vertex in coords:\n        # POINT type strings\n        wkb_string += point_type\n        wkb_string += struct.pack(byte_fmt, *vertex)\n\n    return wkb_string"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndumps a GeoJSON - like dict to a multilinestring WKB string.", "response": "def _dump_multilinestring(obj, big_endian, meta):\n    \"\"\"\n    Dump a GeoJSON-like `dict` to a multilinestring WKB string.\n\n    Input parameters and output are similar to :funct:`_dump_point`.\n    \"\"\"\n    coords = obj['coordinates']\n    vertex = coords[0][0]\n    num_dims = len(vertex)\n\n    wkb_string, byte_fmt, byte_order = _header_bytefmt_byteorder(\n        'MultiLineString', num_dims, big_endian, meta\n    )\n\n    ls_type = _WKB[_INT_TO_DIM_LABEL.get(num_dims)]['LineString']\n    if big_endian:\n        ls_type = BIG_ENDIAN + ls_type\n    else:\n        ls_type = LITTLE_ENDIAN + ls_type[::-1]\n\n    # append the number of linestrings\n    wkb_string += struct.pack('%sl' % byte_order, len(coords))\n\n    for linestring in coords:\n        wkb_string += ls_type\n        # append the number of vertices in each linestring\n        wkb_string += struct.pack('%sl' % byte_order, len(linestring))\n        for vertex in linestring:\n            wkb_string += struct.pack(byte_fmt, *vertex)\n\n    return wkb_string"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndumps a GeoJSON - like dict to a multipolygon WKB string.", "response": "def _dump_multipolygon(obj, big_endian, meta):\n    \"\"\"\n    Dump a GeoJSON-like `dict` to a multipolygon WKB string.\n\n    Input parameters and output are similar to :funct:`_dump_point`.\n    \"\"\"\n    coords = obj['coordinates']\n    vertex = coords[0][0][0]\n    num_dims = len(vertex)\n\n    wkb_string, byte_fmt, byte_order = _header_bytefmt_byteorder(\n        'MultiPolygon', num_dims, big_endian, meta\n    )\n\n    poly_type = _WKB[_INT_TO_DIM_LABEL.get(num_dims)]['Polygon']\n    if big_endian:\n        poly_type = BIG_ENDIAN + poly_type\n    else:\n        poly_type = LITTLE_ENDIAN + poly_type[::-1]\n\n    # apped the number of polygons\n    wkb_string += struct.pack('%sl' % byte_order, len(coords))\n\n    for polygon in coords:\n        # append polygon header\n        wkb_string += poly_type\n        # append the number of rings in this polygon\n        wkb_string += struct.pack('%sl' % byte_order, len(polygon))\n        for ring in polygon:\n            # append the number of vertices in this ring\n            wkb_string += struct.pack('%sl' % byte_order, len(ring))\n            for vertex in ring:\n                wkb_string += struct.pack(byte_fmt, *vertex)\n\n    return wkb_string"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _load_point(big_endian, type_bytes, data_bytes):\n    endian_token = '>' if big_endian else '<'\n\n    if type_bytes == WKB_2D['Point']:\n        coords = struct.unpack('%sdd' % endian_token,\n                               as_bin_str(take(16, data_bytes)))\n    elif type_bytes == WKB_Z['Point']:\n        coords = struct.unpack('%sddd' % endian_token,\n                               as_bin_str(take(24, data_bytes)))\n    elif type_bytes == WKB_M['Point']:\n        # NOTE: The use of XYM types geometries is quite rare. In the interest\n        # of removing ambiguity, we will treat all XYM geometries as XYZM when\n        # generate the GeoJSON. A default Z value of `0.0` will be given in\n        # this case.\n        coords = list(struct.unpack('%sddd' % endian_token,\n                                    as_bin_str(take(24, data_bytes))))\n        coords.insert(2, 0.0)\n    elif type_bytes == WKB_ZM['Point']:\n        coords = struct.unpack('%sdddd' % endian_token,\n                               as_bin_str(take(32, data_bytes)))\n\n    return dict(type='Point', coordinates=list(coords))", "response": "Convert byte data for a Point into a GeoJSON dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndumps a GeoJSON - like dict to a WKT string.", "response": "def dumps(obj, decimals=16):\n    \"\"\"\n    Dump a GeoJSON-like `dict` to a WKT string.\n    \"\"\"\n    try:\n        geom_type = obj['type']\n        exporter = _dumps_registry.get(geom_type)\n\n        if exporter is None:\n            _unsupported_geom_type(geom_type)\n\n        # Check for empty cases\n        if geom_type == 'GeometryCollection':\n            if len(obj['geometries']) == 0:\n                return 'GEOMETRYCOLLECTION EMPTY'\n        else:\n            # Geom has no coordinate values at all, and must be empty.\n            if len(list(util.flatten_multi_dim(obj['coordinates']))) == 0:\n                return '%s EMPTY' % geom_type.upper()\n    except KeyError:\n        raise geomet.InvalidGeoJSONException('Invalid GeoJSON: %s' % obj)\n\n    result = exporter(obj, decimals)\n    # Try to get the SRID from `meta.srid`\n    meta_srid = obj.get('meta', {}).get('srid')\n    # Also try to get it from `crs.properties.name`:\n    crs_srid = obj.get('crs', {}).get('properties', {}).get('name')\n    if crs_srid is not None:\n        # Shave off the EPSG prefix to give us the SRID:\n        crs_srid = crs_srid.replace('EPSG', '')\n\n    if (meta_srid is not None and\n            crs_srid is not None and\n            str(meta_srid) != str(crs_srid)):\n        raise ValueError(\n            'Ambiguous CRS/SRID values: %s and %s' % (meta_srid, crs_srid)\n        )\n    srid = meta_srid or crs_srid\n\n    # TODO: add tests for CRS input\n    if srid is not None:\n        # Prepend the SRID\n        result = 'SRID=%s;%s' % (srid, result)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loads(string):\n    sio = StringIO.StringIO(string)\n    # NOTE: This is not the intended purpose of `tokenize`, but it works.\n    tokens = (x[1] for x in tokenize.generate_tokens(sio.readline))\n    tokens = _tokenize_wkt(tokens)\n    geom_type_or_srid = next(tokens)\n    srid = None\n    geom_type = geom_type_or_srid\n    if geom_type_or_srid == 'SRID':\n        # The geometry WKT contains an SRID header.\n        _assert_next_token(tokens, '=')\n        srid = int(next(tokens))\n        _assert_next_token(tokens, ';')\n        # We expected the geometry type to be next:\n        geom_type = next(tokens)\n    else:\n        geom_type = geom_type_or_srid\n\n    importer = _loads_registry.get(geom_type)\n\n    if importer is None:\n        _unsupported_geom_type(geom_type)\n\n    peek = six.advance_iterator(tokens)\n    if peek == 'EMPTY':\n        if geom_type == 'GEOMETRYCOLLECTION':\n            return dict(type='GeometryCollection', geometries=[])\n        else:\n            return dict(type=_type_map_caps_to_mixed[geom_type],\n                        coordinates=[])\n\n    # Put the peeked element back on the head of the token generator\n    tokens = itertools.chain([peek], tokens)\n    result = importer(tokens, string)\n    if srid is not None:\n        result['meta'] = dict(srid=srid)\n    return result", "response": "Construct a GeoJSON dict from a WKT string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _tokenize_wkt(tokens):\n    negative = False\n    for t in tokens:\n        if t == '-':\n            negative = True\n            continue\n        else:\n            if negative:\n                yield '-%s' % t\n            else:\n                yield t\n            negative = False", "response": "Yields a list of tokens from the WKT."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nround the input value to decimals places and pad with 0 s", "response": "def _round_and_pad(value, decimals):\n    \"\"\"\n    Round the input value to `decimals` places, and pad with 0's\n    if the resulting value is less than `decimals`.\n\n    :param value:\n        The value to round\n    :param decimals:\n        Number of decimals places which should be displayed after the rounding.\n    :return:\n        str of the rounded value\n    \"\"\"\n    if isinstance(value, int) and decimals != 0:\n        # if we get an int coordinate and we have a non-zero value for\n        # `decimals`, we want to create a float to pad out.\n        value = float(value)\n\n    elif decimals == 0:\n        # if get a `decimals` value of 0, we want to return an int.\n        return repr(int(round(value, decimals)))\n\n    rounded = repr(round(value, decimals))\n    rounded += '0' * (decimals - len(rounded.split('.')[1]))\n    return rounded"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _dump_point(obj, decimals):\n    coords = obj['coordinates']\n    pt = 'POINT (%s)' % ' '.join(_round_and_pad(c, decimals)\n                                 for c in coords)\n    return pt", "response": "Dump a GeoJSON - like Point object to WKT."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _dump_linestring(obj, decimals):\n    coords = obj['coordinates']\n    ls = 'LINESTRING (%s)'\n    ls %= ', '.join(' '.join(_round_and_pad(c, decimals)\n                             for c in pt) for pt in coords)\n    return ls", "response": "Dump a GeoJSON - like LineString object to WKT."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndumping a GeoJSON - like Polygon object to WKT.", "response": "def _dump_polygon(obj, decimals):\n    \"\"\"\n    Dump a GeoJSON-like Polygon object to WKT.\n\n    Input parameters and return value are the POLYGON equivalent to\n    :func:`_dump_point`.\n    \"\"\"\n    coords = obj['coordinates']\n    poly = 'POLYGON (%s)'\n    rings = (', '.join(' '.join(_round_and_pad(c, decimals)\n                                for c in pt) for pt in ring)\n             for ring in coords)\n    rings = ('(%s)' % r for r in rings)\n    poly %= ', '.join(rings)\n    return poly"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndump a GeoJSON - like MultiPoint object to WKT.", "response": "def _dump_multipoint(obj, decimals):\n    \"\"\"\n    Dump a GeoJSON-like MultiPoint object to WKT.\n\n    Input parameters and return value are the MULTIPOINT equivalent to\n    :func:`_dump_point`.\n    \"\"\"\n    coords = obj['coordinates']\n    mp = 'MULTIPOINT (%s)'\n    points = (' '.join(_round_and_pad(c, decimals)\n                       for c in pt) for pt in coords)\n    # Add parens around each point.\n    points = ('(%s)' % pt for pt in points)\n    mp %= ', '.join(points)\n    return mp"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _dump_multilinestring(obj, decimals):\n    coords = obj['coordinates']\n    mlls = 'MULTILINESTRING (%s)'\n    linestrs = ('(%s)' % ', '.join(' '.join(_round_and_pad(c, decimals)\n                for c in pt) for pt in linestr) for linestr in coords)\n    mlls %= ', '.join(ls for ls in linestrs)\n    return mlls", "response": "Dump a GeoJSON - like MultiLineString object to WKT."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndumps a GeoJSON - like MultiPolygon object to WKT.", "response": "def _dump_multipolygon(obj, decimals):\n    \"\"\"\n    Dump a GeoJSON-like MultiPolygon object to WKT.\n\n    Input parameters and return value are the MULTIPOLYGON equivalent to\n    :func:`_dump_point`.\n    \"\"\"\n    coords = obj['coordinates']\n    mp = 'MULTIPOLYGON (%s)'\n\n    polys = (\n        # join the polygons in the multipolygon\n        ', '.join(\n            # join the rings in a polygon,\n            # and wrap in parens\n            '(%s)' % ', '.join(\n                # join the points in a ring,\n                # and wrap in parens\n                '(%s)' % ', '.join(\n                    # join coordinate values of a vertex\n                    ' '.join(_round_and_pad(c, decimals) for c in pt)\n                    for pt in ring)\n                for ring in poly)\n            for poly in coords)\n    )\n    mp %= polys\n    return mp"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndumping a GeoJSON - like GeometryCollection object to WKT.", "response": "def _dump_geometrycollection(obj, decimals):\n    \"\"\"\n    Dump a GeoJSON-like GeometryCollection object to WKT.\n\n    Input parameters and return value are the GEOMETRYCOLLECTION equivalent to\n    :func:`_dump_point`.\n\n    The WKT conversions for each geometry in the collection are delegated to\n    their respective functions.\n    \"\"\"\n    gc = 'GEOMETRYCOLLECTION (%s)'\n    geoms = obj['geometries']\n    geoms_wkt = []\n    for geom in geoms:\n        geom_type = geom['type']\n        geoms_wkt.append(_dumps_registry.get(geom_type)(geom, decimals))\n    gc %= ','.join(geoms_wkt)\n    return gc"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _load_point(tokens, string):\n    if not next(tokens) == '(':\n        raise ValueError(INVALID_WKT_FMT % string)\n\n    coords = []\n    try:\n        for t in tokens:\n            if t == ')':\n                break\n            else:\n                coords.append(float(t))\n    except tokenize.TokenError:\n        raise ValueError(INVALID_WKT_FMT % string)\n\n    return dict(type='Point', coordinates=coords)", "response": "Load a point from a WKT string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _load_linestring(tokens, string):\n    if not next(tokens) == '(':\n        raise ValueError(INVALID_WKT_FMT % string)\n\n    # a list of lists\n    # each member list represents a point\n    coords = []\n    try:\n        pt = []\n        for t in tokens:\n            if t == ')':\n                coords.append(pt)\n                break\n            elif t == ',':\n                # it's the end of the point\n                coords.append(pt)\n                pt = []\n            else:\n                pt.append(float(t))\n    except tokenize.TokenError:\n        raise ValueError(INVALID_WKT_FMT % string)\n\n    return dict(type='LineString', coordinates=coords)", "response": "Loads a WKT string into a GeoJSON dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _load_polygon(tokens, string):\n    open_parens = next(tokens), next(tokens)\n    if not open_parens == ('(', '('):\n        raise ValueError(INVALID_WKT_FMT % string)\n\n    # coords contains a list of rings\n    # each ring contains a list of points\n    # each point is a list of 2-4 values\n    coords = []\n\n    ring = []\n    on_ring = True\n    try:\n        pt = []\n        for t in tokens:\n            if t == ')' and on_ring:\n                # The ring is finished\n                ring.append(pt)\n                coords.append(ring)\n                on_ring = False\n            elif t == ')' and not on_ring:\n                # it's the end of the polygon\n                break\n            elif t == '(':\n                # it's a new ring\n                ring = []\n                pt = []\n                on_ring = True\n            elif t == ',' and on_ring:\n                # it's the end of a point\n                ring.append(pt)\n                pt = []\n            elif t == ',' and not on_ring:\n                # there's another ring.\n                # do nothing\n                pass\n            else:\n                pt.append(float(t))\n    except tokenize.TokenError:\n        raise ValueError(INVALID_WKT_FMT % string)\n\n    return dict(type='Polygon', coordinates=coords)", "response": "Parses a WKT string and returns a GeoJSON Polygon representation of the WKT string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a WKT string and returns a GeoJSON MultiPoint representation of the WKT string.", "response": "def _load_multipoint(tokens, string):\n    \"\"\"\n    Has similar inputs and return value to to :func:`_load_point`, except is\n    for handling MULTIPOINT geometry.\n\n    :returns:\n        A GeoJSON `dict` MultiPoint representation of the WKT ``string``.\n    \"\"\"\n    open_paren = next(tokens)\n    if not open_paren == '(':\n        raise ValueError(INVALID_WKT_FMT % string)\n\n    coords = []\n    pt = []\n\n    paren_depth = 1\n    try:\n        for t in tokens:\n            if t == '(':\n                paren_depth += 1\n            elif t == ')':\n                paren_depth -= 1\n                if paren_depth == 0:\n                    break\n            elif t == '':\n                pass\n            elif t == ',':\n                # the point is done\n                coords.append(pt)\n                pt = []\n            else:\n                pt.append(float(t))\n    except tokenize.TokenError:\n        raise ValueError(INVALID_WKT_FMT % string)\n\n    # Given the way we're parsing, we'll probably have to deal with the last\n    # point after the loop\n    if len(pt) > 0:\n        coords.append(pt)\n\n    return dict(type='MultiPoint', coordinates=coords)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _load_multipolygon(tokens, string):\n    open_paren = next(tokens)\n    if not open_paren == '(':\n        raise ValueError(INVALID_WKT_FMT % string)\n\n    polygons = []\n    while True:\n        try:\n            poly = _load_polygon(tokens, string)\n            polygons.append(poly['coordinates'])\n            t = next(tokens)\n            if t == ')':\n                # we're done; no more polygons.\n                break\n        except StopIteration:\n            # If we reach this, the WKT is not valid.\n            raise ValueError(INVALID_WKT_FMT % string)\n\n    return dict(type='MultiPolygon', coordinates=polygons)", "response": "Loads a MULTIPOLYGON geometry from a WKT string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads a MULTILINESTRING geometry from a WKT string.", "response": "def _load_multilinestring(tokens, string):\n    \"\"\"\n    Has similar inputs and return value to to :func:`_load_point`, except is\n    for handling MULTILINESTRING geometry.\n\n    :returns:\n        A GeoJSON `dict` MultiLineString representation of the WKT ``string``.\n    \"\"\"\n    open_paren = next(tokens)\n    if not open_paren == '(':\n        raise ValueError(INVALID_WKT_FMT % string)\n\n    linestrs = []\n    while True:\n        try:\n            linestr = _load_linestring(tokens, string)\n            linestrs.append(linestr['coordinates'])\n            t = next(tokens)\n            if t == ')':\n                # we're done; no more linestrings.\n                break\n        except StopIteration:\n            # If we reach this, the WKT is not valid.\n            raise ValueError(INVALID_WKT_FMT % string)\n\n    return dict(type='MultiLineString', coordinates=linestrs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a WKT string and returns a GeoJSON GeometryCollection representation of the WKT.", "response": "def _load_geometrycollection(tokens, string):\n    \"\"\"\n    Has similar inputs and return value to to :func:`_load_point`, except is\n    for handling GEOMETRYCOLLECTIONs.\n\n    Delegates parsing to the parsers for the individual geometry types.\n\n    :returns:\n        A GeoJSON `dict` GeometryCollection representation of the WKT\n        ``string``.\n    \"\"\"\n    open_paren = next(tokens)\n    if not open_paren == '(':\n        raise ValueError(INVALID_WKT_FMT % string)\n\n    geoms = []\n    result = dict(type='GeometryCollection', geometries=geoms)\n    while True:\n        try:\n            t = next(tokens)\n            if t == ')':\n                break\n            elif t == ',':\n                # another geometry still\n                continue\n            else:\n                geom_type = t\n                load_func = _loads_registry.get(geom_type)\n                geom = load_func(tokens, string)\n                geoms.append(geom)\n        except StopIteration:\n            raise ValueError(INVALID_WKT_FMT % string)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_request_params(self, **kwargs):\n        request_params = copy.deepcopy(self._shared_request_params)\n        for key, value in iteritems(kwargs):\n            if isinstance(value, dict) and key in request_params:\n                # ensure we don't lose dict values like headers or cookies\n                request_params[key].update(value)\n            else:\n                request_params[key] = value\n        return request_params", "response": "Merge shared params and new params."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove keyword arguments not used by requests", "response": "def _sanitize_request_params(self, request_params):\n        \"\"\"Remove keyword arguments not used by `requests`\"\"\"\n        if 'verify_ssl' in request_params:\n            request_params['verify'] = request_params.pop('verify_ssl')\n        return dict((key, val) for key, val in request_params.items()\n                    if key in self._VALID_REQUEST_ARGS)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef request(self, method, path, **kwargs):\n        if path:\n            url = '%s/%s' % (self.url.rstrip('/'), path.lstrip('/'))\n        else:\n            url = self.url\n\n        request_params = self._get_request_params(method=method,\n                                                  url=url, **kwargs)\n        request_params = self.pre_send(request_params)\n\n        sanitized_params = self._sanitize_request_params(request_params)\n        start_time = time.time()\n        response = super(HTTPServiceClient, self).request(**sanitized_params)\n\n        # Log request and params (without passwords)\n        log.debug(\n            '%s HTTP [%s] call to \"%s\" %.2fms',\n            response.status_code, method, response.url,\n            (time.time() - start_time) * 1000)\n        auth = sanitized_params.pop('auth', None)\n        log.debug('HTTP request params: %s', sanitized_params)\n        if auth:\n            log.debug('Authentication via HTTP auth as \"%s\"', auth[0])\n\n        response.is_ok = response.status_code < 300\n        if not self.is_acceptable(response, request_params):\n            raise HTTPServiceError(response)\n        response = self.post_send(response, **request_params)\n        return response", "response": "Send a HTTP request and demand a\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\noverride this method to modify sent request parameters", "response": "def pre_send(self, request_params):\n        \"\"\"Override this method to modify sent request parameters\"\"\"\n        for adapter in itervalues(self.adapters):\n            adapter.max_retries = request_params.get('max_retries', 0)\n\n        return request_params"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if the response is acceptable for the current request.", "response": "def is_acceptable(self, response, request_params):\n        \"\"\"\n        Override this method to create a different definition of\n        what kind of response is acceptable.\n        If `bool(the_return_value) is False` then an `HTTPServiceError`\n        will be raised.\n\n        For example, you might want to assert that the body must be empty,\n        so you could return `len(response.content) == 0`.\n\n        In the default implementation, a response is acceptable\n        if and only if the response code is either\n        less than 300 (typically 200, i.e. OK) or if it is in the\n        `expected_response_codes` parameter in the constructor.\n        \"\"\"\n        expected_codes = request_params.get('expected_response_codes', [])\n        return response.is_ok or response.status_code in expected_codes"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _roundSlist(slist):\n    slist[-1] = 60 if slist[-1] >= 30 else 0\n    for i in range(len(slist)-1, 1, -1):\n        if slist[i] == 60:\n            slist[i] = 0\n            slist[i-1] += 1\n    return slist[:-1]", "response": "Rounds a signed list over the last element."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting angle string to signed list.", "response": "def strSlist(string):\n    \"\"\" Converts angle string to signed list. \"\"\"\n    sign = '-' if string[0] == '-' else '+'\n    values = [abs(int(x)) for x in string.split(':')]\n    return _fixSlist(list(sign) + values)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting signed list to angle string.", "response": "def slistStr(slist):\n    \"\"\" Converts signed list to angle string. \"\"\"\n    slist = _fixSlist(slist)\n    string = ':'.join(['%02d' % x for x in slist[1:]])\n    return slist[0] + string"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert signed list to float.", "response": "def slistFloat(slist):\n    \"\"\" Converts signed list to float. \"\"\"\n    values = [v / 60**(i) for (i,v) in enumerate(slist[1:])]\n    value = sum(values)\n    return -value if slist[0] == '-' else value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef floatSlist(value):\n    slist = ['+', 0, 0, 0, 0]\n    if value < 0:\n        slist[0] = '-'\n    value = abs(value)\n    for i in range(1,5):\n        slist[i] = math.floor(value)\n        value = (value - slist[i]) * 60\n    return _roundSlist(slist)", "response": "Converts float to signed list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef toFloat(value):\n    if isinstance(value, str):\n        return strFloat(value)\n    elif isinstance(value, list):\n        return slistFloat(value)\n    else:\n        return value", "response": "Converts string or signed list to float."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef inDignities(self, idA, idB):\n        objA = self.chart.get(idA)\n        info = essential.getInfo(objA.sign, objA.signlon)\n        # Should we ignore exile and fall?\n        return [dign for (dign, ID) in info.items() if ID == idB]", "response": "Returns the dignities of A which belong to B."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mutualReceptions(self, idA, idB):\n        AB = self.receives(idA, idB)\n        BA = self.receives(idB, idA)\n        # Returns a product of both lists\n        return [(a,b) for a in AB for b in BA]", "response": "Returns all pairs of dignities in mutual reception."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns ruler and exaltation mutual receptions.", "response": "def reMutualReceptions(self, idA, idB):\n        \"\"\" Returns ruler and exaltation mutual receptions. \"\"\"\n        mr = self.mutualReceptions(idA, idB)\n        filter_ = ['ruler', 'exalt']\n        # Each pair of dignities must be 'ruler' or 'exalt'\n        return [(a,b) for (a,b) in mr if (a in filter_ and b in filter_)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validAspects(self, ID, aspList):\n        obj = self.chart.getObject(ID)\n        res = []\n        \n        for otherID in const.LIST_SEVEN_PLANETS:\n            if ID == otherID:\n                continue\n            \n            otherObj = self.chart.getObject(otherID)\n            aspType = aspects.aspectType(obj, otherObj, aspList)\n            if aspType != const.NO_ASPECT:\n                res.append({\n                    'id': otherID,\n                    'asp': aspType,\n                })\n        return res", "response": "Returns a list with the aspects an object \n        makes with the other six planets considering a\n        list of possible aspects."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef aspectsByCat(self, ID, aspList):\n        res = {\n            const.APPLICATIVE: [],\n            const.SEPARATIVE: [],\n            const.EXACT: [],\n            const.NO_MOVEMENT: []\n        }\n        \n        objA = self.chart.getObject(ID)\n        valid = self.validAspects(ID, aspList)\n        for elem in valid:\n            objB = self.chart.getObject(elem['id'])\n            asp = aspects.getAspect(objA, objB, aspList)\n            role = asp.getRole(objA.id)\n            if role['inOrb']:\n                movement = role['movement']\n                res[movement].append({\n                    'id': objB.id,\n                    'asp': asp.type,\n                    'orb': asp.orb\n                })\n\n        return res", "response": "Returns the aspects an object makes with the highest priority."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the last separation and next application based on a list of possible aspects.", "response": "def immediateAspects(self, ID, aspList):\n        \"\"\" Returns the last separation and next application\n        considering a list of possible aspects.\n\n        \"\"\"\n        asps = self.aspectsByCat(ID, aspList)\n\n        applications = asps[const.APPLICATIVE]\n        separations = asps[const.SEPARATIVE]\n        exact = asps[const.EXACT]\n\n        # Get applications and separations sorted by orb\n\n        applications = applications + [val for val in exact if val['orb'] >= 0]\n\n        applications = sorted(applications, key=lambda var: var['orb'])\n        separations = sorted(separations, key=lambda var: var['orb'])\n\n        return (\n            separations[0] if separations else None,\n            applications[0] if applications else None\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef isVOC(self, ID):\n        asps = self.aspectsByCat(ID, const.MAJOR_ASPECTS)\n        applications = asps[const.APPLICATIVE]\n        exacts = asps[const.EXACT]\n        return len(applications) == 0 and len(exacts) == 0", "response": "Returns if a planet is VOC of Course."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef singleFactor(factors, chart, factor, obj, aspect=None):\n    \n    objID = obj if type(obj) == str else obj.id\n    res = {\n        'factor': factor,\n        'objID': objID,\n        'aspect': aspect\n    }\n    \n    # For signs (obj as string) return sign element\n    if type(obj) == str:\n        res['element'] = props.sign.element[obj]\n        \n    # For Sun return sign and sunseason element\n    elif objID == const.SUN:\n        sunseason = props.sign.sunseason[obj.sign]\n        res['sign'] = obj.sign\n        res['sunseason'] = sunseason\n        res['element'] = props.base.sunseasonElement[sunseason]\n        \n    # For Moon return phase and phase element\n    elif objID == const.MOON:\n        phase = chart.getMoonPhase()\n        res['phase'] = phase\n        res['element'] = props.base.moonphaseElement[phase]\n        \n    # For regular planets return element or sign/sign element\n    # if there's an aspect involved\n    elif objID in const.LIST_SEVEN_PLANETS:\n        if aspect:\n            res['sign'] = obj.sign\n            res['element'] = props.sign.element[obj.sign]\n        else:\n            res['element'] = obj.element()\n            \n    try:\n        # If there's element, insert into list\n        res['element']\n        factors.append(res)\n    except KeyError:\n        pass\n    \n    return res", "response": "Single factor for the table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute a factor for a modifier.", "response": "def modifierFactor(chart, factor, factorObj, otherObj, aspList):\n    \"\"\" Computes a factor for a modifier. \"\"\"\n    \n    asp = aspects.aspectType(factorObj, otherObj, aspList)\n    if asp != const.NO_ASPECT:\n        return {\n            'factor': factor,\n            'aspect': asp,\n            'objID': otherObj.id,\n            'element': otherObj.element()\n        }\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the list of factors for the temperament.", "response": "def getFactors(chart):\n    \"\"\" Returns the factors for the temperament. \"\"\"\n    \n    factors = []\n    \n    # Asc sign\n    asc = chart.getAngle(const.ASC)\n    singleFactor(factors, chart, ASC_SIGN, asc.sign)\n    \n    # Asc ruler\n    ascRulerID = essential.ruler(asc.sign)\n    ascRuler = chart.getObject(ascRulerID)\n    singleFactor(factors, chart, ASC_RULER, ascRuler)\n    singleFactor(factors, chart, ASC_RULER_SIGN, ascRuler.sign)\n    \n    # Planets in House 1\n    house1 = chart.getHouse(const.HOUSE1)\n    planetsHouse1 = chart.objects.getObjectsInHouse(house1)\n    for obj in planetsHouse1:\n        singleFactor(factors, chart, HOUSE1_PLANETS_IN, obj)\n        \n    # Planets conjunct Asc\n    planetsConjAsc = chart.objects.getObjectsAspecting(asc, [0])\n    for obj in planetsConjAsc:\n        # Ignore planets already in house 1\n        if obj not in planetsHouse1:\n            singleFactor(factors, chart, ASC_PLANETS_CONJ, obj)\n            \n    # Planets aspecting Asc cusp\n    aspList = [60, 90, 120, 180]\n    planetsAspAsc = chart.objects.getObjectsAspecting(asc, aspList)\n    for obj in planetsAspAsc:\n        aspect = aspects.aspectType(obj, asc, aspList)\n        singleFactor(factors, chart, ASC_PLANETS_ASP, obj, aspect)\n    \n    # Moon sign and phase\n    moon = chart.getObject(const.MOON)\n    singleFactor(factors, chart, MOON_SIGN, moon.sign)\n    singleFactor(factors, chart, MOON_PHASE, moon)\n    \n    # Moon dispositor\n    moonRulerID = essential.ruler(moon.sign)\n    moonRuler = chart.getObject(moonRulerID)\n    moonFactor = singleFactor(factors, chart, MOON_DISPOSITOR_SIGN, moonRuler.sign)\n    moonFactor['planetID'] = moonRulerID  # Append moon dispositor ID\n    \n    # Planets conjunct Moon\n    planetsConjMoon = chart.objects.getObjectsAspecting(moon, [0])\n    for obj in planetsConjMoon:\n        singleFactor(factors, chart, MOON_PLANETS_CONJ, obj)\n            \n    # Planets aspecting Moon\n    aspList = [60, 90, 120, 180]\n    planetsAspMoon = chart.objects.getObjectsAspecting(moon, aspList)\n    for obj in planetsAspMoon:\n        aspect = aspects.aspectType(obj, moon, aspList)\n        singleFactor(factors, chart, MOON_PLANETS_ASP, obj, aspect)\n    \n    # Sun season\n    sun = chart.getObject(const.SUN)\n    singleFactor(factors, chart, SUN_SEASON, sun)\n    \n    return factors"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the factors of the temperament modifiers.", "response": "def getModifiers(chart):\n    \"\"\" Returns the factors of the temperament modifiers. \"\"\"\n    \n    modifiers = []\n    \n    # Factors which can be affected\n    asc = chart.getAngle(const.ASC)\n    ascRulerID = essential.ruler(asc.sign)\n    ascRuler = chart.getObject(ascRulerID)\n    moon = chart.getObject(const.MOON)\n    factors = [\n        [MOD_ASC, asc],\n        [MOD_ASC_RULER, ascRuler],\n        [MOD_MOON, moon]\n    ]\n    \n    # Factors of affliction\n    mars = chart.getObject(const.MARS)\n    saturn = chart.getObject(const.SATURN)\n    sun = chart.getObject(const.SUN)\n    affect = [\n        [mars, [0, 90, 180]],\n        [saturn, [0, 90, 180]],\n        [sun, [0]]     \n    ]\n    \n    # Do calculations of afflictions\n    for affectingObj, affectingAsps in affect:\n        for factor, affectedObj in factors:\n            modf = modifierFactor(chart, \n                                  factor, \n                                  affectedObj, \n                                  affectingObj, \n                                  affectingAsps)\n            if modf:\n                modifiers.append(modf)\n    \n    return modifiers"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scores(factors):\n    temperaments = {\n        const.CHOLERIC: 0,\n        const.MELANCHOLIC: 0,\n        const.SANGUINE: 0,\n        const.PHLEGMATIC: 0                \n    }\n    \n    qualities = {\n        const.HOT: 0,\n        const.COLD: 0,\n        const.DRY: 0,\n        const.HUMID: 0\n    }\n    \n    for factor in factors:\n        element = factor['element']\n        \n        # Score temperament\n        temperament = props.base.elementTemperament[element]\n        temperaments[temperament] += 1\n        \n        # Score qualities\n        tqualities = props.base.temperamentQuality[temperament]\n        qualities[tqualities[0]] += 1\n        qualities[tqualities[1]] += 1\n        \n    return {\n        'temperaments': temperaments,\n        'qualities': qualities\n    }", "response": "Computes the score of temperaments and qualities of the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getObject(ID, date, pos):\n    obj = eph.getObject(ID, date.jd, pos.lat, pos.lon)\n    return Object.fromDict(obj)", "response": "Returns an ephemeris object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getObjectList(IDs, date, pos):\n    objList = [getObject(ID, date, pos) for ID in IDs]\n    return ObjectList(objList)", "response": "Returns a list of objects."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the lists of houses and angles.", "response": "def getHouses(date, pos, hsys):\n    \"\"\" Returns the lists of houses and angles.\n    \n    Since houses and angles are computed at the\n    same time, this function should be fast.\n    \n    \"\"\"\n    houses, angles = eph.getHouses(date.jd, pos.lat, pos.lon, hsys)\n    hList = [House.fromDict(house) for house in houses]\n    aList = [GenericObject.fromDict(angle) for angle in angles]\n    return (HouseList(hList), GenericList(aList))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a fixed star from the ephemeris.", "response": "def getFixedStar(ID, date):\n    \"\"\" Returns a fixed star from the ephemeris. \"\"\"\n    star = eph.getFixedStar(ID, date.jd)\n    return FixedStar.fromDict(star)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getFixedStarList(IDs, date):\n    starList = [getFixedStar(ID, date) for ID in IDs]\n    return FixedStarList(starList)", "response": "Returns a list of fixed stars."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the next date when sun is at longitude lon.", "response": "def nextSolarReturn(date, lon):\n    \"\"\" Returns the next date when sun is at longitude 'lon'. \"\"\"\n    jd = eph.nextSolarReturn(date.jd, lon)\n    return Datetime.fromJD(jd, date.utcoffset)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prevSolarReturn(date, lon):\n    jd = eph.prevSolarReturn(date.jd, lon)\n    return Datetime.fromJD(jd, date.utcoffset)", "response": "Returns the previous date when sun is at longitude lon."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the date of the next sunrise.", "response": "def nextSunrise(date, pos):\n    \"\"\" Returns the date of the next sunrise. \"\"\"\n    jd = eph.nextSunrise(date.jd, pos.lat, pos.lon)\n    return Datetime.fromJD(jd, date.utcoffset)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the aproximate date of the next station.", "response": "def nextStation(ID, date):\n    \"\"\" Returns the aproximate date of the next station. \"\"\"\n    jd = eph.nextStation(ID, date.jd)\n    return Datetime.fromJD(jd, date.utcoffset)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef prevSolarEclipse(date):\n\n    eclipse = swe.solarEclipseGlobal(date.jd, backward=True)\n    return Datetime.fromJD(eclipse['maximum'], date.utcoffset)", "response": "Returns the Datetime of the maximum phase of the previous global solar eclipse."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nextSolarEclipse(date):\n\n    eclipse = swe.solarEclipseGlobal(date.jd, backward=False)\n    return Datetime.fromJD(eclipse['maximum'], date.utcoffset)", "response": "Returns the Datetime of the maximum phase of the next global solar eclipse."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef prevLunarEclipse(date):\n\n    eclipse = swe.lunarEclipseGlobal(date.jd, backward=True)\n    return Datetime.fromJD(eclipse['maximum'], date.utcoffset)", "response": "Returns the Datetime of the maximum phase of the previous global lunar eclipse."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nextLunarEclipse(date):\n\n    eclipse = swe.lunarEclipseGlobal(date.jd, backward=False)\n    return Datetime.fromJD(eclipse['maximum'], date.utcoffset)", "response": "Returns the Datetime of the maximum phase of the next global lunar eclipse."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nplots the tropical solar length by year.", "response": "def plot(hdiff, title):\n    \"\"\" Plots the tropical solar length\n    by year.\n    \n    \"\"\"\n    import matplotlib.pyplot as plt\n    years = [elem[0] for elem in hdiff]\n    diffs = [elem[1] for elem in hdiff]\n    plt.plot(years, diffs)\n    plt.ylabel('Distance in minutes')\n    plt.xlabel('Year')\n    plt.title(title)\n    plt.axhline(y=0, c='red')\n    plt.show()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ascdiff(decl, lat):\n    delta = math.radians(decl)\n    phi = math.radians(lat)\n    ad = math.asin(math.tan(delta) * math.tan(phi))\n    return math.degrees(ad)", "response": "Returns the Ascensional Difference of a point."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the diurnal and nocturnal arcs of a point.", "response": "def dnarcs(decl, lat):\n    \"\"\" Returns the diurnal and nocturnal arcs of a point. \"\"\"\n    dArc = 180 + 2 * ascdiff(decl, lat)\n    nArc = 360 - dArc\n    return (dArc, nArc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if an object s ra and decl is above the horizon at a specific latitude.", "response": "def isAboveHorizon(ra, decl, mcRA, lat):\n    \"\"\" Returns if an object's 'ra' and 'decl' \n    is above the horizon at a specific latitude, \n    given the MC's right ascension.\n    \n    \"\"\"\n    # This function checks if the equatorial distance from \n    # the object to the MC is within its diurnal semi-arc.\n    \n    dArc, _ = dnarcs(decl, lat)\n    dist = abs(angle.closestdistance(mcRA, ra))\n    return dist <= dArc/2.0 + 0.0003"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef eqCoords(lon, lat):\n    # Convert to radians\n    _lambda = math.radians(lon)\n    _beta = math.radians(lat)\n    _epson = math.radians(23.44)  # The earth's inclination\n    \n    # Declination in radians\n    decl = math.asin(math.sin(_epson) * math.sin(_lambda) * math.cos(_beta) + \\\n           math.cos(_epson) * math.sin(_beta))\n    \n    # Equatorial Distance in radians\n    ED = math.acos(math.cos(_lambda) * math.cos(_beta) / math.cos(decl))\n    \n    # RA in radians\n    ra = ED if lon < 180 else math.radians(360) - ED\n    \n    # Correctness of RA if longitude is close to 0\u00ba or 180\u00ba in a radius of 5\u00ba\n    if (abs(angle.closestdistance(lon, 0)) < 5 or \n        abs(angle.closestdistance(lon, 180)) < 5):\n            a = math.sin(ra) * math.cos(decl)\n            b = math.cos(_epson) * math.sin(_lambda) * math.cos(_beta) - \\\n                math.sin(_epson) * math.sin(_beta)\n            if (math.fabs(a-b) > 0.0003):\n                ra = math.radians(360) - ra\n                \n    return (math.degrees(ra), math.degrees(decl))", "response": "Converts from ecliptical to equatorial coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an object s relation with the sun.", "response": "def sunRelation(obj, sun):\n    \"\"\" Returns an object's relation with the sun. \"\"\"\n    if obj.id == const.SUN:\n        return None\n    dist = abs(angle.closestdistance(sun.lon, obj.lon))\n    if dist < 0.2833: return CAZIMI\n    elif dist < 8.0: return COMBUST\n    elif dist < 16.0: return UNDER_SUN\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns if an object is augmenting or diminishing light.", "response": "def light(obj, sun):\n    \"\"\" Returns if an object is augmenting or diminishing light. \"\"\"\n    dist = angle.distance(sun.lon, obj.lon)\n    faster = sun if sun.lonspeed > obj.lonspeed else obj\n    if faster == sun:\n        return LIGHT_DIMINISHING if dist < 180 else LIGHT_AUGMENTING\n    else:\n        return LIGHT_AUGMENTING if dist < 180 else LIGHT_DIMINISHING"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef orientality(obj, sun):\n    dist = angle.distance(sun.lon, obj.lon)\n    return OCCIDENTAL if dist < 180 else ORIENTAL", "response": "Returns if an object is oriental or \n    occidental to the sun."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning if an object is in Haiz.", "response": "def haiz(obj, chart):\n    \"\"\" Returns if an object is in Haiz. \"\"\"\n    objGender = obj.gender()\n    objFaction = obj.faction()\n    \n    if obj.id == const.MERCURY:\n        # Gender and faction of mercury depends on orientality\n        sun = chart.getObject(const.SUN)\n        orientalityM = orientality(obj, sun)\n        if orientalityM == ORIENTAL:\n            objGender = const.MASCULINE\n            objFaction = const.DIURNAL\n        else:\n            objGender = const.FEMININE\n            objFaction = const.NOCTURNAL\n            \n    # Object gender match sign gender?\n    signGender = props.sign.gender[obj.sign]\n    genderConformity = (objGender == signGender)\n    \n    # Match faction\n    factionConformity = False\n    diurnalChart = chart.isDiurnal()\n    \n    if obj.id == const.SUN and not diurnalChart:\n        # Sun is in conformity only when above horizon\n        factionConformity = False\n    else:\n        # Get list of houses in the chart's diurnal faction\n        if diurnalChart:\n            diurnalFaction = props.house.aboveHorizon\n            nocturnalFaction = props.house.belowHorizon\n        else:\n            diurnalFaction = props.house.belowHorizon\n            nocturnalFaction = props.house.aboveHorizon\n        \n        # Get the object's house and match factions\n        objHouse = chart.houses.getObjectHouse(obj)\n        if (objFaction == const.DIURNAL and objHouse.id in diurnalFaction or\n            objFaction == const.NOCTURNAL and objHouse.id in nocturnalFaction):\n                factionConformity = True\n        \n    # Match things\n    if (genderConformity and factionConformity):\n        return HAIZ\n    elif (not genderConformity and not factionConformity):\n        return CHAIZ\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the object s house.", "response": "def house(self):\n        \"\"\" Returns the object's house. \"\"\"\n        house = self.chart.houses.getObjectHouse(self.obj)\n        return house"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sunRelation(self):\n        sun = self.chart.getObject(const.SUN)\n        return sunRelation(self.obj, sun)", "response": "Returns the relation of the object with the sun."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns if object is augmenting or diminishing its", "response": "def light(self):\n        \"\"\" Returns if object is augmenting or diminishing its \n        light.\n        \n        \"\"\"\n        sun = self.chart.getObject(const.SUN)\n        return light(self.obj, sun)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the orientality of the object.", "response": "def orientality(self):\n        \"\"\" Returns the orientality of the object. \"\"\"\n        sun = self.chart.getObject(const.SUN)\n        return orientality(self.obj, sun)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if the object is in its house of joy.", "response": "def inHouseJoy(self):\n        \"\"\" Returns if the object is in its house of joy. \"\"\"\n        house = self.house()\n        return props.object.houseJoy[self.obj.id] == house.id"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if the object is in its sign of joy.", "response": "def inSignJoy(self):\n        \"\"\" Returns if the object is in its sign of joy. \"\"\"\n        return props.object.signJoy[self.obj.id] == self.obj.sign"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reMutualReceptions(self):\n        planets = copy(const.LIST_SEVEN_PLANETS)\n        planets.remove(self.obj.id)\n        mrs = {}\n        for ID in planets:\n            mr = self.dyn.reMutualReceptions(self.obj.id, ID)\n            if mr:\n                mrs[ID] = mr\n        return mrs", "response": "Returns all mutual receptions with the object\n        and other planets indexed by planet ID."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef eqMutualReceptions(self):\n        mrs = self.reMutualReceptions()\n        res = []\n        for ID, receptions in mrs.items():\n            for pair in receptions:\n                if pair[0] == pair[1]:\n                    res.append(pair[0])\n        return res", "response": "Returns a list with all mutual receptions with the \n        object and other planets when the reception is the \n        same for both ruler and both exaltation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list with the aspects that the object makes to the objects in IDs. It considers only conjunctions and other exact or applicative aspects are returned.", "response": "def __aspectLists(self, IDs, aspList):\n        \"\"\" Returns a list with the aspects that the object\n        makes to the objects in IDs. It considers only\n        conjunctions and other exact/applicative aspects\n        if in aspList.\n        \n        \"\"\"\n        res = []\n        \n        for otherID in IDs:\n            # Ignore same \n            if otherID == self.obj.id:\n                continue\n            \n            # Get aspects to the other object\n            otherObj = self.chart.getObject(otherID)\n            asp = aspects.getAspect(self.obj, otherObj, aspList)\n            \n            if asp.type == const.NO_ASPECT:\n                continue\n            elif asp.type == const.CONJUNCTION:\n                res.append(asp.type)\n            else:\n                # Only exact or applicative aspects\n                movement = asp.movement()\n                if movement in [const.EXACT, const.APPLICATIVE]:\n                    res.append(asp.type)\n        \n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of good aspects the object makes to the benefics.", "response": "def aspectBenefics(self):\n        \"\"\" Returns a list with the good aspects the object \n        makes to the benefics.\n        \n        \"\"\"\n        benefics = [const.VENUS, const.JUPITER]\n        return self.__aspectLists(benefics, aspList=[0, 60, 120])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef aspectMalefics(self):\n        malefics = [const.MARS, const.SATURN]\n        return self.__aspectLists(malefics, aspList=[0, 90, 180])", "response": "Returns a list with the bad aspects the object\n        \n        makes to the malefics."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns true if the object last and next movement are separations and applications to objects in list IDs.", "response": "def __sepApp(self, IDs, aspList):\n        \"\"\" Returns true if the object last and next movement are\n        separations and applications to objects in list IDs.\n        It only considers aspects in aspList.\n        \n        This function is static since it does not test if the next\n        application will be indeed perfected. It considers only\n        a snapshot of the chart and not its astronomical movement.\n        \n        \"\"\"\n        sep, app = self.dyn.immediateAspects(self.obj.id, aspList)\n        if sep is None or app is None:\n            return False\n        else:\n            sepCondition = sep['id'] in IDs\n            appCondition = app['id'] in IDs\n            return sepCondition == appCondition == True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if the object is separating and applying to a benefic considering good aspects.", "response": "def isAuxilied(self):\n        \"\"\" Returns if the object is separating and applying to \n        a benefic considering good aspects.\n        \n        \"\"\"\n        benefics = [const.VENUS, const.JUPITER]\n        return self.__sepApp(benefics, aspList=[0, 60, 120])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if the object is separating and applying to a malefic considering bad aspects.", "response": "def isSurrounded(self):\n        \"\"\" Returns if the object is separating and applying to \n        a malefic considering bad aspects.\n        \n        \"\"\"\n        malefics = [const.MARS, const.SATURN]\n        return self.__sepApp(malefics, aspList=[0, 90, 180])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning if object is conjunct north node.", "response": "def isConjNorthNode(self):\n        \"\"\" Returns if object is conjunct north node. \"\"\"\n        node = self.chart.getObject(const.NORTH_NODE)\n        return aspects.hasAspect(self.obj, node, aspList=[0])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn if object is conjunct south node.", "response": "def isConjSouthNode(self):\n        \"\"\" Returns if object is conjunct south node. \"\"\"\n        node = self.chart.getObject(const.SOUTH_NODE)\n        return aspects.hasAspect(self.obj, node, aspList=[0])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns true if the object has any as well as any .", "response": "def isFeral(self):\n        \"\"\" Returns true if the object does not have any \n        aspects.\n        \n        \"\"\"\n        planets = copy(const.LIST_SEVEN_PLANETS)\n        planets.remove(self.obj.id)\n        for otherID in planets:\n            otherObj = self.chart.getObject(otherID)\n            if aspects.hasAspect(self.obj, otherObj, const.MAJOR_ASPECTS):\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getScoreProperties(self):\n        obj = self.obj\n        score = {}\n        \n        # Peregrine\n        isPeregrine = essential.isPeregrine(obj.id, obj.sign, obj.signlon)\n        score['peregrine'] = -5 if isPeregrine else 0\n        \n        # Ruler-Ruler and Exalt-Exalt mutual receptions\n        mr = self.eqMutualReceptions()\n        score['mr_ruler'] = +5 if 'ruler' in mr else 0\n        score['mr_exalt'] = +4 if 'exalt' in mr else 0\n        \n        # House scores\n        score['house'] = self.houseScore()\n        \n        # Joys\n        score['joy_sign'] = +3 if self.inSignJoy() else 0\n        score['joy_house'] = +2 if self.inHouseJoy() else 0\n        \n        # Relations with sun\n        score['cazimi'] = +5 if self.isCazimi() else 0\n        score['combust'] = -6 if self.isCombust() else 0\n        score['under_sun'] = -4 if self.isUnderSun() else 0\n        score['no_under_sun'] = 0\n        if obj.id != const.SUN and not self.sunRelation():\n            score['no_under_sun'] = +5\n        \n        # Light\n        score['light'] = 0\n        if obj.id != const.SUN:\n            score['light'] = +1 if self.isAugmentingLight() else -1\n            \n        # Orientality\n        score['orientality'] = 0\n        if obj.id in [const.SATURN, const.JUPITER, const.MARS]:\n            score['orientality'] = +2 if self.isOriental() else -2\n        elif obj.id in [const.VENUS, const.MERCURY, const.MOON]:\n            score['orientality'] = -2 if self.isOriental() else +2\n        \n        # Moon nodes\n        score['north_node'] = -3 if self.isConjNorthNode() else 0\n        score['south_node'] = -5 if self.isConjSouthNode() else 0\n        \n        # Direction and speed\n        score['direction'] = 0\n        if obj.id not in [const.SUN, const.MOON]:\n            score['direction'] = +4 if obj.isDirect() else -5\n        score['speed'] = +2 if obj.isFast() else -2\n        \n        # Aspects to benefics\n        aspBen = self.aspectBenefics()\n        score['benefic_asp0'] = +5 if const.CONJUNCTION in aspBen else 0\n        score['benefic_asp120'] = +4 if const.TRINE in aspBen else 0\n        score['benefic_asp60'] = +3 if const.SEXTILE in aspBen else 0\n        \n        # Aspects to malefics\n        aspMal = self.aspectMalefics()\n        score['malefic_asp0'] = -5 if const.CONJUNCTION in aspMal else 0\n        score['malefic_asp180'] = -4 if const.OPPOSITION in aspMal else 0\n        score['malefic_asp90'] = -3 if const.SQUARE in aspMal else 0\n        \n        # Auxily and Surround\n        score['auxilied'] = +5 if self.isAuxilied() else 0\n        score['surround'] = -5 if self.isSurrounded() else 0\n        \n        # Voc and Feral\n        score['feral'] = -3 if self.isFeral() else 0\n        score['void'] = -2 if (self.isVoc() and score['feral'] == 0) else 0\n        \n        # Haiz\n        haiz = self.haiz()\n        score['haiz'] = 0\n        if haiz == HAIZ:\n            score['haiz'] = +3\n        elif haiz == CHAIZ:\n            score['haiz'] = -2\n            \n        # Moon via combusta\n        score['viacombusta'] = 0\n        if obj.id == const.MOON and viaCombusta(obj):\n            score['viacombusta'] = -2\n            \n        return score", "response": "Returns the accidental dignity score of the object \n        as dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getActiveProperties(self):\n        score = self.getScoreProperties()\n        return {key: value for (key, value) in score.items()\n                if value != 0}", "response": "Returns the non - zero accidental dignities."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the sum of the accidental dignities clf.", "response": "def score(self):\n        \"\"\" Returns the sum of the accidental dignities\n        score.\n        \n        \"\"\"\n        if not self.scoreProperties:\n            self.scoreProperties = self.getScoreProperties()\n        return sum(self.scoreProperties.values())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding an object from a dictionary of properties.", "response": "def fromDict(cls, _dict):\n        \"\"\" Builds instance from dictionary of properties. \"\"\"\n        obj = cls()\n        obj.__dict__.update(_dict)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the Equatorial Coordinates of this object.", "response": "def eqCoords(self, zerolat=False):\n        \"\"\" Returns the Equatorial Coordinates of this object. \n        Receives a boolean parameter to consider a zero latitude. \n        \n        \"\"\"\n        lat = 0.0 if zerolat else self.lat\n        return utils.eqCoords(self.lon, lat)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrelocate this object to a new longitude.", "response": "def relocate(self, lon):\n        \"\"\" Relocates this object to a new longitude. \"\"\"\n        self.lon = angle.norm(lon)\n        self.signlon = self.lon % 30\n        self.sign = const.LIST_SIGNS[int(self.lon / 30.0)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef antiscia(self):\n        obj = self.copy()\n        obj.type = const.OBJ_GENERIC\n        obj.relocate(360 - obj.lon + 180)\n        return obj", "response": "Returns an antiscia object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef movement(self):\n        if abs(self.lonspeed) < 0.0003:\n            return const.STATIONARY\n        elif self.lonspeed > 0:\n            return const.DIRECT\n        else:\n            return const.RETROGRADE", "response": "Returns if this object is direct retrograde \n        or stationary. Otherwise returns direct retrograde \n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef inHouse(self, lon):\n        dist = angle.distance(self.lon + House._OFFSET, lon)\n        return dist < self.size", "response": "Returns True if a longitude belongs to this house."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef orb(self):\n        for (mag, orb) in FixedStar._ORBS:\n            if self.mag < mag:\n                return orb\n        return 0.5", "response": "Returns the orb of this fixed star."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning true if this star aspects another object.", "response": "def aspects(self, obj):\n        \"\"\" Returns true if this star aspects another object.\n        Fixed stars only aspect by conjunctions. \n        \n        \"\"\"\n        dist = angle.closestdistance(self.lon, obj.lon)\n        return abs(dist) < self.orb()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list with all objects in a house.", "response": "def getObjectsInHouse(self, house):\n        \"\"\" Returns a list with all objects in a house. \"\"\"\n        res = [obj for obj in self if house.hasObject(obj)]\n        return ObjectList(res)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getObjectsAspecting(self, point, aspList):\n        res = []\n        for obj in self:\n            if obj.isPlanet() and aspects.isAspecting(obj, point, aspList):\n                res.append(obj)\n        return ObjectList(res)", "response": "Returns a list of objects aspecting a point \n        considering a list of possible aspects."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef arc(pRA, pDecl, sRA, sDecl, mcRA, lat):\n    pDArc, pNArc = utils.dnarcs(pDecl, lat)\n    sDArc, sNArc = utils.dnarcs(sDecl, lat)\n    \n    # Select meridian and arcs to be used\n    # Default is MC and Diurnal arcs\n    mdRA = mcRA\n    sArc = sDArc\n    pArc = pDArc\n    if not utils.isAboveHorizon(sRA, sDecl, mcRA, lat):\n        # Use IC and Nocturnal arcs\n        mdRA = angle.norm(mcRA + 180)\n        sArc = sNArc\n        pArc = pNArc\n        \n    # Promissor and Significator distance to meridian\n    pDist = angle.closestdistance(mdRA, pRA)\n    sDist = angle.closestdistance(mdRA, sRA)\n    \n    # Promissor should be after significator (in degrees)\n    if pDist < sDist:\n        pDist += 360\n        \n    # Meridian distances proportional to respective semi-arcs\n    sPropDist = sDist / (sArc / 2.0)\n    pPropDist = pDist / (pArc / 2.0)\n    \n    # The arc is how much of the promissor's semi-arc is\n    # needed to reach the significator\n    return (pPropDist - sPropDist) * (pArc / 2.0)", "response": "Returns the arc of direction between a promissor and significator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the arc of direction between a promissor and a significator.", "response": "def getArc(prom, sig, mc, pos, zerolat):\n    \"\"\" Returns the arc of direction between a promissor\n    and a significator. Arguments are also the MC, the\n    geoposition and zerolat to assume zero ecliptical \n    latitudes.\n    \n    ZeroLat true => inZodiaco, false => inMundo\n    \n    \"\"\"\n    pRA, pDecl = prom.eqCoords(zerolat)\n    sRa, sDecl = sig.eqCoords(zerolat)\n    mcRa, mcDecl = mc.eqCoords()\n    return arc(pRA, pDecl, sRa, sDecl, mcRa, pos.lat)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild a data structure indexing the terms longitude by sign and object.", "response": "def _buildTerms(self):\n        \"\"\" Builds a data structure indexing the terms\n        longitude by sign and object.\n        \n        \"\"\"\n        termLons = tables.termLons(tables.EGYPTIAN_TERMS)\n        res = {}\n        for (ID, sign, lon) in termLons:\n            try:\n                res[sign][ID] = lon\n            except KeyError:\n                res[sign] = {}\n                res[sign][ID] = lon\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef G(self, ID, lat, lon):\n        \n        # Equatorial coordinates\n        eqM = utils.eqCoords(lon, lat)\n        eqZ = eqM\n        if lat != 0:\n            eqZ = utils.eqCoords(lon, 0)\n        \n        return {\n            'id': ID,\n            'lat': lat,\n            'lon': lon,\n            'ra': eqM[0],\n            'decl': eqM[1],\n            'raZ': eqZ[0],\n            'declZ': eqZ[1],\n        }", "response": "Creates a generic entry for an object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef T(self, ID, sign):\n        lon = self.terms[sign][ID]\n        ID = 'T_%s_%s' % (ID, sign)\n        return self.G(ID, 0, lon)", "response": "Returns the term of an object in a sign."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef A(self, ID):\n        obj = self.chart.getObject(ID).antiscia()\n        ID = 'A_%s' % (ID)\n        return self.G(ID, obj.lat, obj.lon)", "response": "Returns the Antiscia of an object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef C(self, ID):\n        obj = self.chart.getObject(ID).cantiscia()\n        ID = 'C_%s' % (ID)\n        return self.G(ID, obj.lat, obj.lon)", "response": "Returns the CAntiscia of an object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the dexter aspect of an object.", "response": "def D(self, ID, asp):\n        \"\"\" Returns the dexter aspect of an object. \"\"\"\n        obj = self.chart.getObject(ID).copy()\n        obj.relocate(obj.lon - asp)\n        ID = 'D_%s_%s' % (ID, asp)\n        return self.G(ID, obj.lat, obj.lon)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the conjunction or opposition aspect of an object.", "response": "def N(self, ID, asp=0):\n        \"\"\" Returns the conjunction or opposition aspect \n        of an object. \n        \n        \"\"\"\n        obj = self.chart.get(ID).copy()\n        obj.relocate(obj.lon + asp)\n        ID = 'N_%s_%s' % (ID, asp)\n        return self.G(ID, obj.lat, obj.lon)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _arc(self, prom, sig):\n        arcm = arc(prom['ra'], prom['decl'], \n                   sig['ra'], sig['decl'], \n                   self.mcRA, self.lat)\n        arcz = arc(prom['raZ'], prom['declZ'], \n                   sig['raZ'], sig['declZ'], \n                   self.mcRA, self.lat)\n        return {\n            'arcm': arcm,\n            'arcz': arcz\n        }", "response": "Computes the in - zodiaco and in - mundo arcs \n        between a promissor and a significator."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getArc(self, prom, sig):\n        res = self._arc(prom, sig)\n        res.update({\n            'prom': prom['id'],\n            'sig': sig['id']\n        })\n        return res", "response": "Returns the arcs between a promissor and a significator."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _elements(self, IDs, func, aspList):\n        res = []\n        for asp in aspList:\n            if (asp in [0, 180]):\n                # Generate func for conjunctions and oppositions\n                if func == self.N:\n                    res.extend([func(ID, asp) for ID in IDs])\n                else:\n                    res.extend([func(ID) for ID in IDs])\n            else:\n                # Generate Dexter and Sinister for others\n                res.extend([self.D(ID, asp) for ID in IDs])\n                res.extend([self.S(ID, asp) for ID in IDs])\n        return res", "response": "Returns the IDs as objects considering the aspList and the function."}
