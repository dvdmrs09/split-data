{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, section, key):\n        line = self._make_line(key)\n        for line in self.get_line(section, line):\n            yield line.value", "response": "Get the value of all lines matching the section and key."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves the first value for a given section and key. Raises KeyError if no such key exists in the given section.", "response": "def get_one(self, section, key):\n        \"\"\"Retrieve the first value for a section/key.\n\n        Raises:\n            KeyError: If no line match the given section/key.\n        \"\"\"\n        lines = iter(self.get(section, key))\n        try:\n            return next(lines)\n        except StopIteration:\n            raise KeyError(\"Key %s not found in %s\" % (key, section))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_or_update(self, section, key, value):\n        updates = self.update(section, key, value)\n        if updates == 0:\n            self.add(section, key, value)\n        return updates", "response": "Update the key or add it."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwrapping for cache. set.", "response": "def cache_set(key, value, timeout=None, refreshed=False):\n    \"\"\"\n    Wrapper for ``cache.set``. Stores the cache entry packed with\n    the desired cache expiry time. When the entry is retrieved from\n    cache, the packed expiry time is also checked, and if past,\n    the stale cache entry is stored again with an expiry that has\n    ``CACHE_SET_DELAY_SECONDS`` added to it. In this case the entry\n    is not returned, so that a cache miss occurs and the entry\n    should be set by the caller, but all other callers will still get\n    the stale entry, so no real cache misses ever occur.\n    \"\"\"\n    if timeout is None:\n        timeout = settings.CACHE_MIDDLEWARE_SECONDS\n    refresh_time = timeout + time()\n    real_timeout = timeout + settings.CACHE_SET_DELAY_SECONDS\n    packed = (value, refresh_time, refreshed)\n    return cache.set(_hashed_key(key), packed, real_timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrap for cache. get.", "response": "def cache_get(key):\n    \"\"\"\n    Wrapper for ``cache.get``. The expiry time for the cache entry\n    is stored with the entry. If the expiry time has past, put the\n    stale entry back into cache, and don't return it to trigger a\n    fake cache miss.\n    \"\"\"\n    packed = cache.get(_hashed_key(key))\n    if packed is None:\n        return None\n    value, refresh_time, refreshed = packed\n    if (time() > refresh_time) and not refreshed:\n        cache_set(key, value, settings.CACHE_SET_DELAY_SECONDS, True)\n        return None\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cache_installed():\n    has_key = bool(getattr(settings, \"NEVERCACHE_KEY\", \"\"))\n\n    def flatten(seqs):\n        return (item for seq in seqs for item in seq)\n\n    middleware_classes = map(import_string, get_middleware_setting())\n    middleware_ancestors = set(flatten(map(getmro, middleware_classes)))\n\n    yacms_cache_middleware_classes = {\n        import_string(\"yacms.core.middleware.UpdateCacheMiddleware\"),\n        import_string(\"yacms.core.middleware.FetchFromCacheMiddleware\"),\n    }\n\n    return (has_key and settings.CACHES and not settings.TESTING and\n            yacms_cache_middleware_classes.issubset(middleware_ancestors))", "response": "Returns True if a cache backend is configured and the\n    middleware classes or subclasses thereof are present."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cache_key_prefix(request):\n    cache_key = \"%s.%s.%s.\" % (\n        settings.CACHE_MIDDLEWARE_KEY_PREFIX,\n        current_site_id(),\n        device_from_request(request) or \"default\",\n    )\n    return _i18n_cache_key_suffix(request, cache_key)", "response": "Returns the cache key for yacms s cache middleware."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding the current time to the querystring of the URL to force a cache reload. Used for when a form post redirects back to a page that has changed content.", "response": "def add_cache_bypass(url):\n    \"\"\"\n    Adds the current time to the querystring of the URL to force a\n    cache reload. Used for when a form post redirects back to a\n    page that should display updated content, such as new comments or\n    ratings.\n    \"\"\"\n    if not cache_installed():\n        return url\n    hash_str = \"\"\n    if \"#\" in url:\n        url, hash_str = url.split(\"#\", 1)\n        hash_str = \"#\" + hash_str\n    url += \"?\" if \"?\" not in url else \"&\"\n    return url + \"t=\" + str(time()).replace(\".\", \"\") + hash_str"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _dbus_get_object(bus_name, object_name):\n\n    try:\n        bus = dbus.SessionBus()\n        obj = bus.get_object(bus_name, object_name)\n        return obj\n\n    except (NameError, dbus.exceptions.DBusException):\n        return None", "response": "Fetches the DBUS proxy object given the specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches the DBUS interface proxy object given the specified parameters.", "response": "def _dbus_get_interface(bus_name, object_name, interface_name):\n    \"\"\" Fetches DBUS interface proxy object given the specified parameters.\n\n        `bus_name`\n            Name of the bus interface.\n        `object_name`\n            Object path related to the interface.\n        `interface_name`\n            Name of the interface.\n\n        Returns object or ``None``.\n        \"\"\"\n\n    try:\n        obj = _dbus_get_object(bus_name, object_name)\n        if not obj:\n            raise NameError\n        return dbus.Interface(obj, interface_name)\n\n    except (NameError, dbus.exceptions.DBusException):\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates status and message for a given status code.", "response": "def _pidgin_status(status, message):\n    \"\"\" Updates status and message for Pidgin IM application.\n\n        `status`\n            Status type.\n        `message`\n            Status message.\n        \"\"\"\n\n    try:\n        iface = _dbus_get_interface('im.pidgin.purple.PurpleService',\n                                    '/im/pidgin/purple/PurpleObject',\n                                    'im.pidgin.purple.PurpleInterface')\n        if iface:\n\n            # create new transient status\n            code = PIDGIN_CODE_MAP[status]\n            saved_status = iface.PurpleSavedstatusNew('', code)\n\n            # set the message, if provided\n            iface.PurpleSavedstatusSetMessage(saved_status, message)\n\n            # activate status\n            iface.PurpleSavedstatusActivate(saved_status)\n\n    except dbus.exceptions.DBusException:\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating status and message for Adium IM application.", "response": "def _adium_status(status, message):\n    \"\"\" Updates status and message for Adium IM application.\n\n        `status`\n            Status type.\n        `message`\n            Status message.\n        \"\"\"\n\n    # map status code\n    code = ADIUM_CODE_MAP[status]\n\n    # get message\n    if not message:\n        default_messages = {\n            'busy': 'Busy',\n            'long_away': 'Extended away'\n        }\n        message = default_messages.get(status, '')\n    else:\n        message = message.replace('\"', '\\\\\"')  # escape message\n\n    # build applescript\n    #  if adium is running:\n    #  * set status\n    #  * also set status message, if provided\n    script = \"\"\"\n     tell application \"System Events\"\n      if exists process \"Adium\" then\n       tell application \"Adium\" to go {0}\"\"\".format(code)\n\n    if message:\n        # set status message\n        script += ' with message \"{0}\"'.format(message)\n\n    script += \"\"\"\n      end if\n     end tell\"\"\"\n\n    # run it\n    common.shell_process(['osascript', '-e', script])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating status and message for Empathy IM application.", "response": "def _empathy_status(status, message):\n    \"\"\" Updates status and message for Empathy IM application.\n\n        `status`\n            Status type.\n        `message`\n            Status message.\n        \"\"\"\n\n    ACCT_IFACE = 'org.freedesktop.Telepathy.Account'\n    DBUS_PROP_IFACE = 'org.freedesktop.DBus.Properties'\n    ACCT_MAN_IFACE = 'org.freedesktop.Telepathy.AccountManager'\n    ACCT_MAN_PATH = '/org/freedesktop/Telepathy/AccountManager'\n    SP_IFACE = ('org.freedesktop.Telepathy.'\n                'Connection.Interface.SimplePresence')\n\n    # fetch main account manager interface\n    am_iface = _dbus_get_interface(ACCT_MAN_IFACE, ACCT_MAN_PATH,\n                                   DBUS_PROP_IFACE)\n\n    if am_iface:\n        account_paths = am_iface.Get(ACCT_MAN_IFACE, 'ValidAccounts')\n\n        for account_path in account_paths:\n            try:\n                # fetch account interface\n                account = _dbus_get_object(ACCT_MAN_IFACE, account_path)\n\n                # skip disconnected, disabled, etc.\n                if account.Get(ACCT_IFACE, 'ConnectionStatus') != 0:\n                    continue\n\n                # fetch simple presence interface for account connection\n                conn_path = account.Get(ACCT_IFACE, 'Connection')\n                conn_iface = conn_path.replace(\"/\", \".\")[1:]\n                sp_iface = _dbus_get_interface(conn_iface, conn_path,\n                                               SP_IFACE)\n\n            except dbus.exceptions.DBusException:\n                continue\n\n            # set status and message\n            for code in EMPATHY_CODE_MAP[status]:\n                try:\n                    sp_iface.SetPresence(code, message)\n                except dbus.exceptions.DBusException:\n                    pass\n                else:\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates status and message for Skype IM application on Linux.", "response": "def _linux_skype_status(status, message):\n    \"\"\" Updates status and message for Skype IM application on Linux.\n\n        `status`\n            Status type.\n        `message`\n            Status message.\n        \"\"\"\n\n    try:\n        iface = _dbus_get_interface('com.Skype.API',\n                                    '/com/Skype',\n                                    'com.Skype.API')\n        if iface:\n            # authenticate\n            if iface.Invoke('NAME focus') != 'OK':\n                msg = 'User denied authorization'\n                raise dbus.exceptions.DbusException(msg)\n            iface.Invoke('PROTOCOL 5')\n\n            # set status\n            iface.Invoke('SET USERSTATUS {0}'.format(SKYPE_CODE_MAP[status]))\n\n            # set the message, if provided\n            iface.Invoke('SET PROFILE MOOD_TEXT {0}'\n                         .format(message))\n\n    except dbus.exceptions.DBusException:\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate status and message for Skype IM application on Mac OS X.", "response": "def _osx_skype_status(status, message):\n    \"\"\" Updates status and message for Skype IM application on Mac OSX.\n\n        `status`\n            Status type.\n        `message`\n            Status message.\n        \"\"\"\n\n    # XXX: Skype has a bug with it's applescript support on Snow Leopard\n    # where it will ignore the \"not exists process\" expression when\n    # combined with \"tell application Skype\" and thus launches Skype if\n    # it's not running. Obviously, this is what we're trying to avoid.\n    #\n    # The workaround here is to scan the user process list for Skype and\n    # bail if we don't find it.\n\n    uid = os.getuid()\n\n    for proc in psutil.process_iter():\n        try:\n            if proc.uids.real == uid and proc.name == 'Skype':\n                skype_running = True\n                break\n        except (psutil.AccessDenied, psutil.NoSuchProcess):\n            pass\n    else:\n        skype_running = False\n\n    if skype_running:\n        code = SKYPE_CODE_MAP[status]  # map status code\n        message = message.replace('\"', '\\\\\"')  # escape message\n\n        # build applescript\n        #   auto-approve skype security dialog\n        #   * hide dialog by setting app hidden\n        #   * select allow radio button and click OK on dialog\n        #   * restore original app visibility\n\n        #   main loop\n        #   * while security dialog is shown or app is loading\n        #   ** fetch user status to determine if in pending state\n        #   ** run auto-approve if still in pending state\n\n        #   set status command\n        #   set status message (mood)\n\n        script = \"\"\"\n         on approve()\n          tell application \"System Events\"\n            set vis to the visible of process \"Skype\"\n            set visible of process \"Skype\" to false\n            tell process \"Skype\"\n              set winName to \"Skype API Security\"\n              set rdoBtn to \"Allow this application to use Skype\"\n              if exists (radio button rdoBtn of radio group 1 of window {LC}\n              winName) then\n                click radio button rdoBtn of radio group 1 of window winName\n                delay 0.5\n                click button \"OK\" of window winName\n              end if\n            end tell\n            set visible of process \"Skype\" to vis\n          end tell\n         end approve\n\n         tell application \"Skype\"\n          set stat to \"COMMAND_PENDING\"\n          repeat until stat is not equal to \"COMMAND_PENDING\"\n           set stat to send command \"GET USERSTATUS\" script name \"focus\"\n           if stat is equal to \"COMMAND_PENDING\" then my approve()\n           delay 0.5\n          end repeat\n\n          send command \"SET USERSTATUS {code}\" script name \"focus\"\n          send command \"SET PROFILE MOOD_TEXT {mood}\" script name \"focus\"\n         end tell\"\"\".format(**{\n            'code': code,\n            'mood': message,\n            'LC': \"\\xc2\\xac\"\n        })\n\n        # run it\n        common.shell_process(['osascript', '-e', script])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _set_status(self, status, message=''):\n\n        message = message.strip()\n\n        # fetch away message from provided id\n        if message.startswith(':'):\n            msg_id = message[1:]\n            message = self.messages.get(msg_id, '')\n\n        message = message.encode('utf-8', 'replace')\n\n        # attempt to set status for each supported application\n        for func in self.set_status_funcs:\n            func(status, message)", "response": "Updates the status and message on all supported IM apps."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the option and store the values in the self. statuses and self. messages.", "response": "def parse_option(self, option, block_name, *values):\n        \"\"\" Parse status, end_status, timer_status and status_msg options.\n            \"\"\"\n\n        if option.endswith('status'):\n            status = values[0]\n            if status not in self.VALID_STATUSES:\n                raise ValueError(u'Invalid IM status \"{0}\"'.format(status))\n\n            if len(values) > 2:\n                raise TypeError\n\n            if option == 'status':\n                option = 'start_' + option\n\n            key = option.split('_', 1)[0]\n            self.statuses[key] = values[:2]\n\n        elif option == 'status_msg':\n            if len(values) != 2:\n                raise TypeError\n\n            name, msg = values\n            self.messages[name] = msg"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrying a function or method until it returns True. delay sets the initial delay in seconds, and backoff sets the factor by which the delay should lengthen after each failure. backoff must be greater than 1, or else it isn't really a backoff. tries must be at least 0, and delay greater than 0.", "response": "def RetryUntilReturnsTrue(tries, delay=2, backoff=1.5):\n  '''Retries a function or method until it returns True.\n\n  delay sets the initial delay in seconds, and backoff sets the factor by which\n  the delay should lengthen after each failure. backoff must be greater than 1,\n  or else it isn't really a backoff. tries must be at least 0, and delay\n  greater than 0.'''\n\n  if backoff <= 1:\n    raise ValueError(\"backoff must be greater than 1\")\n\n  tries = math.floor(tries)\n  if tries < 0:\n    raise ValueError(\"tries must be 0 or greater\")\n\n  if delay <= 0:\n    raise ValueError(\"delay must be greater than 0\")\n\n  def deco_retry(f):\n    def f_retry(*args, **kwargs):\n      mtries, mdelay = tries, delay # make mutable\n\n      rv = f(*args, **kwargs) # first attempt\n      while mtries > 0:\n        if rv: # Done on success\n          return rv\n\n        mtries -= 1      # consume an attempt\n        time.sleep(mdelay) # wait...\n        mdelay *= backoff  # make future wait longer\n       \n        rv = f(*args, **kwargs) # Try again\n\n      return False # Ran out of tries :-(\n\n    return f_retry # true decorator -> decorated function\n  return deco_retry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef GetNumCoresOnHosts(hosts, private_key):\n  results = runner.Runner(host_list=hosts, private_key=private_key,\n                          module_name='setup').run()\n  num_cores_list = []\n  for _, props in results['contacted'].iteritems():\n    cores = props['ansible_facts']['ansible_processor_cores']\n    val = 0\n    try:\n      val = int(cores)\n    except ValueError:\n      pass\n    num_cores_list.append(val)\n  return num_cores_list", "response": "Returns the number of cores for each host requested in hosts."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the playbook on the given hosts.", "response": "def RunPlaybookOnHosts(playbook_path, hosts, private_key, extra_vars=None):\n  \"\"\" Runs the playbook and returns True if it completes successfully on all\n  hosts. \"\"\"\n  inventory = ansible_inventory.Inventory(hosts)\n  if not inventory.list_hosts():\n    raise RuntimeError(\"Host list is empty.\")\n  stats = callbacks.AggregateStats()\n  verbose = 0\n  playbook_cb = ansible.callbacks.PlaybookCallbacks(verbose=verbose)\n  runner_cb = ansible.callbacks.PlaybookRunnerCallbacks(stats, verbose=verbose)\n  pb = playbook.PlayBook(playbook=playbook_path,\n                                  host_list=hosts,\n                                  remote_user='ubuntu',\n                                  private_key_file=None,\n                                  private_key=private_key,\n                                  stats=stats,\n                                  callbacks=playbook_cb,\n                                  runner_callbacks=runner_cb,\n                                  extra_vars=extra_vars)\n  results = pb.run()\n  # Check if all hosts completed playbook without error\n  success = True\n  if 'dark' in results:\n    if len(results['dark']) > 0:\n      print \"Contact failures:\"\n      for host, reason in results['dark'].iteritems():\n        print \"  %s (%s)\" % (host, reason['msg'])\n      success = False\n  for host, status in results.iteritems():\n      if host == 'dark':\n        continue\n      failures = status['failures']\n      if failures:\n        logging.info( '%s %s' % (host, status))\n        success = False\n  return success"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef RunPlaybookOnHost(playbook_path, host, private_key, extra_vars=None):\n  return RunPlaybookOnHosts(playbook_path, [host], private_key, extra_vars)", "response": "Runs the playbook on a single host."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ExecuteCmd(cmd, quiet=False):\n  result = None\n  if quiet:\n    with open(os.devnull, \"w\") as fnull:\n      result = subprocess.call(cmd, shell=True, stdout=fnull, stderr=fnull)\n  else:\n    result = subprocess.call(cmd, shell=True)\n  return result", "response": "Execute a command in a shell."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef CheckOutput(*popenargs, **kwargs):\n  process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)\n  output, _ = process.communicate()\n  retcode = process.poll()\n  if retcode:\n      cmd = kwargs.get(\"args\")\n      if cmd is None:\n          cmd = popenargs[0]\n      error = subprocess.CalledProcessError(retcode, cmd)\n      error.output = output\n      raise error\n  return retcode, output", "response": "Runs a command with arguments and return its output as a byte string."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves content from a given URL.", "response": "def UrlGet(url, timeout=10, retries=0):\n  \"\"\" Retrieve content from the given URL. \"\"\"\n   # in Python 2.6 we can pass timeout to urllib2.urlopen\n  socket.setdefaulttimeout(timeout)\n  attempts = 0\n  content = None\n  while not content:\n      try:\n          content = urllib2.urlopen(url).read()\n      except urllib2.URLError:\n          attempts = attempts + 1\n          if attempts > retries:\n              raise IOError('Failed to fetch url: %s' % url)\n  return content"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes a command on a list of hosts.", "response": "def RunCommandOnHosts(cmd, hostnames, ssh_key):\n  \"\"\" Executes a command via ssh and sends back the exit status code. \"\"\"\n  if not hostnames:\n    return\n  p = multiprocessing.Pool(1)\n  remote_command_args = [(cmd, hostname, ssh_key) for hostname in hostnames]\n  #print remote_command_args\n  result = None\n  while not result:\n    try:    \n      result = p.map_async(__RemoteExecuteHelper, remote_command_args).get(999999) # allows for keyboard interrupt\n    except paramiko.SSHException as e:      \n      logging.info( 'failure in RunCommandOnHosts: %s' % (e))\n      time.sleep(5)\n    \n  p.close()\n  p.join()\n  return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef RunCommandOnHost(cmd, hostname, ssh_key):\n  hostnames = [hostname]\n  results = RunCommandOnHosts(cmd, hostnames, ssh_key)\n  assert(len(results) == 1)\n  return results[0]", "response": "Runs a command on a given host."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ReadRemoteFile(remote_file_path, hostname, ssh_key):\n  cmd = 'sudo cat %s' % remote_file_path\n  exit_code, output = RunCommandOnHost(cmd, hostname, ssh_key)\n  if exit_code:\n    raise IOError('Can not read remote path: %s' % (remote_file_path))\n  return output", "response": "Reads a remote file into a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting command in a separate thread.", "response": "def __RemoteExecuteHelper(args):\n  \"\"\" Helper for multiprocessing. \"\"\"\n  cmd, hostname, ssh_key = args\n  #Random.atfork()  # needed to fix bug in old python 2.6 interpreters\n  private_key = paramiko.RSAKey.from_private_key(StringIO.StringIO(ssh_key))\n  client = paramiko.SSHClient()\n  client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n  while True:\n      try:\n          client.connect(hostname, username='ubuntu', pkey=private_key, \n                         allow_agent=False, look_for_keys=False)\n          break\n      except socket.error as e:\n          print '.'\n          time.sleep(5)\n      except paramiko.AuthenticationException as e:\n          print e\n          time.sleep(5)\n  channel = client.get_transport().open_session()\n  channel.exec_command(cmd)\n  exit_code = channel.recv_exit_status()\n  output = channel.recv(1000000)\n  client.close()\n  return exit_code, output"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef WaitForHostsReachable(hostnames, ssh_key):\n  while True:\n    unreachable = GetUnreachableHosts(hostnames, ssh_key)\n    if unreachable:\n      print 'waiting for unreachable hosts: %s' % unreachable\n      time.sleep(5)\n    else:\n      break\n  return", "response": "Blocks until the given host is reachable via ssh."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef GetUnreachableInstances(instances, ssh_key):\n  hostnames = [i.private_ip for i in instances]\n  ssh_status = AreHostsReachable(hostnames, ssh_key)\n  assert(len(hostnames) == len(ssh_status))\n  nonresponsive_instances = [instance for (instance, ssh_ok) in\n                             zip(instances, ssh_status) if not ssh_ok]\n  return nonresponsive_instances", "response": "Returns list of instances unreachable via ssh."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef GetUnreachableHosts(hostnames, ssh_key):\n  ssh_status = AreHostsReachable(hostnames, ssh_key)\n  assert(len(hostnames) == len(ssh_status))\n  nonresponsive_hostnames = [host for (host, ssh_ok) in\n                             zip(hostnames, ssh_status) if not ssh_ok]\n  return nonresponsive_hostnames", "response": "Returns a list of hosts unreachable via ssh."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef AreHostsReachable(hostnames, ssh_key):\n  # validate input\n  for hostname in hostnames:\n    assert(len(hostname))\n  ssh_ok = [exit_code == 0 for (exit_code, _) in\n            RunCommandOnHosts('echo test > /dev/null', hostnames, ssh_key)]\n  return ssh_ok", "response": "Returns list of bools indicating if host reachable via ssh."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef AmiName(ami_release_name, ubuntu_release_name, virtualization_type,\n            mapr_version, role):\n  \"\"\" Returns AMI name using Cirrus ami naming convention. \"\"\"\n  if not role in valid_instance_roles:\n    raise RuntimeError('Specified role (%s) not a valid role: %s' %\n                         (role, valid_instance_roles))\n  if virtualization_type not in valid_virtualization_types:\n    raise RuntimeError('Specified virtualization type (%s) not valid: %s' %\n                         (virtualization_type, valid_virtualization_types))\n  ami_name = 'cirrus-%s-ubuntu-%s-%s-mapr%s-%s' % (ami_release_name,\n                                                   ubuntu_release_name,\n                                                   virtualization_type,\n                                                   mapr_version, role)\n  return ami_name", "response": "Returns AMI name using Cirrus ami naming convention."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef LookupCirrusAmi(ec2, instance_type, ubuntu_release_name, mapr_version, role,\n                    ami_release_name,\n                    ami_owner_id):  \n  \"\"\" Returns AMI satisfying provided constraints. \"\"\"\n  if not role in valid_instance_roles:\n    raise RuntimeError('Specified role (%s) not a valid role: %s' % (role, \n                       valid_instance_roles))\n  virtualization_type = 'paravirtual'\n  if IsHPCInstanceType(instance_type):\n    virtualization_type = 'hvm'\n  assert(ami_owner_id)  \n  images = ec2.get_all_images(owners=[ami_owner_id])\n  ami = None\n  ami_name = AmiName(ami_release_name, ubuntu_release_name, virtualization_type,\n                     mapr_version, role)\n  for image in images:\n    if image.name == ami_name:\n        ami = image\n        break\n  return ami", "response": "Lookup AMI from EC2 instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a region name string into a boto Region object.", "response": "def GetRegion(region_name):\n  \"\"\" Converts region name string into boto Region object. \"\"\"\n  regions = boto_ec2.regions()\n  region = None\n  valid_region_names = []\n  for r in regions:\n    valid_region_names.append(r.name)\n    if r.name == region_name:\n        region = r\n        break\n  if not region:\n    logging.info( 'invalid region name: %s ' % (region_name))\n    logging.info( 'Try one of these:\\n %s' % ('\\n'.join(valid_region_names)))\n    assert(False)\n  return  region"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the OpenSSH public key format given a private key.", "response": "def PrivateToPublicOpenSSH(key, host):\n  \"\"\" Computes the OpenSSH public key format given a private key. \"\"\"\n  # Create public key from private key.\n  ssh_rsa = '00000007' + base64.b16encode('ssh-rsa')\n  # Exponent.\n  exponent = '%x' % (key.e,)\n  if len(exponent) % 2:\n      exponent = '0' + exponent\n  ssh_rsa += '%08x' % (len(exponent) / 2,)\n  ssh_rsa += exponent\n  modulus = '%x' % (key.n,)\n  if len(modulus) % 2:\n      modulus = '0' + modulus\n  if modulus[0] in '89abcdef':\n      modulus = '00' + modulus\n  ssh_rsa += '%08x' % (len(modulus) / 2,)\n  ssh_rsa += modulus\n  hash_string = base64.b64encode(base64.b16decode(ssh_rsa.upper()))\n  public_key = 'ssh-rsa %s %s' % (hash_string, host)\n  return public_key"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef InitKeypair(aws_id, aws_secret, ec2, s3, keypair_name, src_region, \n                dst_regions):\n  \"\"\" \n  Returns the ssh private key for the given keypair name Cirrus created bucket.\n  Creates the keypair if it doesn't yet exist and stores private key in S3. \n  \"\"\"\n  # check if a keypair has been created\n  metadata = CirrusAccessIdMetadata(s3, aws_id)\n  keypair = ec2.get_key_pair(keypair_name)\n  ssh_key = None\n  if keypair:\n    # if created, check that private key is available in s3\n    ssh_key = metadata.GetSshKey(keypair_name)\n  \n  # if the private key is not created or not available in s3, recreate it\n  if not ssh_key:\n    if keypair:\n      ec2.delete_key_pair(keypair_name)\n\n    print 'Recreating keypair: %s' % (keypair_name)\n    # create new key in current region_name\n    keypair = ec2.create_key_pair(keypair_name)\n    ssh_key = keypair.material\n    metadata.SetSshKey(keypair_name, ssh_key)\n    DistributeKeyToRegions(src_region, dst_regions, keypair, aws_id, aws_secret)\n  assert(keypair)\n  assert(ssh_key)\n  return ssh_key", "response": "Creates a new keypair and stores it in S3."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef DistributeKeyToRegions(src_region, dst_regions, private_keypair,\n                           aws_id, aws_secret):\n  \"\"\"\n  Copies the keypair from the src to the dst regions. \n  Note: keypair must be a newly created key... that is the key material is \n  the private key not the public key.\n  \"\"\"\n  private_key = RSA.importKey(private_keypair.material)\n  public_key_material = PrivateToPublicOpenSSH(private_key,\n                                               private_keypair.name)\n  for dst_region in dst_regions:\n    if dst_region == src_region:\n      continue\n    logging.info( 'distributing key %s to region %s' % (private_keypair.name,\n                                                        dst_region))\n    dst_region_ec2 = CreateTestedEc2Connection(aws_id, aws_secret,\n                                                    dst_region)\n    try:\n      dst_region_ec2.delete_key_pair(private_keypair.name)\n    except:\n      raise\n    dst_region_ec2.import_key_pair(private_keypair.name, public_key_material)\n  return", "response": "Distributes a keypair from one region to another."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __WaitForVolume(volume, desired_state):\n  print 'Waiting for volume %s to be %s...' % (volume.id, desired_state)\n  while True:\n    volume.update()\n    sys.stdout.write('.')\n    sys.stdout.flush()\n    #print 'status is: %s' % volume.status\n    if volume.status == desired_state:\n        break\n    time.sleep(5)  \n  return", "response": "Blocks until the EBS volume is in desired state."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef WaitForSnapshotCompleted(snapshot):\n  print 'Waiting for snapshot %s to be completed...' % (snapshot)\n  while True:\n      snapshot.update()\n      sys.stdout.write('.')\n      sys.stdout.flush()\n      #print 'status is: %s' % snapshot.status\n      if snapshot.status == 'completed':\n          break\n      time.sleep(5)\n  return", "response": "Blocks until snapshot is complete."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nblocks until the instance is in the desired state.", "response": "def __WaitForInstance(instance, desired_state):\n  \"\"\" Blocks until instance is in desired_state. \"\"\"\n  print 'Waiting for instance %s to change to %s' % (instance.id, desired_state)\n  while True:\n      try:\n          instance.update()\n          state = instance.state\n          sys.stdout.write('.')\n          sys.stdout.flush()\n          if state == desired_state:\n              break\n      except boto_exception.EC2ResponseError as e:\n          logging.info(e)\n      #except boto_exception.ResponseError as e:  # This is an alias\n      #    logging.info(e)\n      time.sleep(5)  \n  return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch Ubuntu AMI database for a given release.", "response": "def SearchUbuntuAmiDatabase(release_name, region_name, root_store_type,\n                            virtualization_type):\n  \"\"\" Returns the ubuntu created ami matching the given criteria. \"\"\"\n  ami_list_url = 'http://cloud-images.ubuntu.com/query/%s/server/released.txt' \\\n   % (release_name)\n  url_file = urllib2.urlopen(ami_list_url)\n  # The mapping of columns names to col ids in the ubuntu release txt file.\n  release_name_col = 0\n  release_tag_col = 2\n  release_date_col = 3\n  root_store_type_col = 4\n  arch_col = 5\n  region_col = 6\n  ami_col = 7\n  matching_amis = []  # list of tuples (ami_id, tokens)\n  \n  for line in url_file:\n    tokens = line.split()\n    # lines have different number of columns (one fewer for hvm)\n    if (len(tokens) == 9):\n      virtualization_type_col = 8\n    elif (len(tokens) == 10):\n      virtualization_type_col = 9\n    else:\n      raise RuntimeError('invalid line format: %s' % line)\n    if tokens[release_name_col] == release_name \\\n       and tokens[release_tag_col] == 'release' \\\n       and tokens[root_store_type_col] == root_store_type \\\n       and tokens[arch_col] == 'amd64' \\\n       and tokens[region_col] == region_name \\\n       and tokens[virtualization_type_col] == virtualization_type: \n       matching_amis.append((tokens[ami_col], tokens))\n  matching_amis.sort(key=lambda (ami, tokens) : tokens[release_date_col], \n                     reverse=True)  # order newest first  \n  if not matching_amis:\n    params = [release_name, root_store_type, region_name,  virtualization_type]\n    raise RuntimeError('Failed to find matching ubuntu ami: %s', params)\n  selected_ami = matching_amis[0][0]\n  return selected_ami"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexpecting the method handler to return the context for the template.", "response": "def render(self, request, context, status=codes.ok, content_type=None,\n            args=None, kwargs=None):\n        \"Expects the method handler to return the `context` for the template.\"\n\n        if isinstance(self.template_name, (list, tuple)):\n            template = loader.select_template(self.template_name)\n        elif self.template_name:\n            template = loader.get_template(self.template_name)\n        else:\n            template = loader.Template(self.template_string)\n\n        context = RequestContext(request, context)\n        content = template.render(context)\n\n        return HttpResponse(content, status=status, content_type=content_type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprompts a string with autocompletion.", "response": "def prompt_autocomplete(prompt, complete, default=None, contains_spaces=True, \n                        show_default=True, prompt_suffix=': ', color=None):\n    \"\"\"\n    Prompt a string with autocompletion\n\n    :param complete: A function that returns a list of possible strings that\n        should be completed on a given text.\n        def complete(text: str) -> List[str]: ...\n    \"\"\"\n\n    def real_completer(text, state):\n        possibilities = complete(text) + [None]\n\n        if possibilities:\n            return possibilities[state]\n        return None\n\n    readline.set_completer_delims('\\t\\n' + ' ' * (not contains_spaces))\n    readline.parse_and_bind(\"tab: complete\")\n    readline.set_completer(real_completer)\n    \n    if default is not None and show_default:\n        prompt += ' [%s]' % default\n\n    prompt += prompt_suffix\n\n    colors = {\n        'red': Fore.RED,\n        'blue': Fore.BLUE,\n        'green': Fore.GREEN,\n        'cyan': Fore.CYAN,\n        'magenta': Fore.MAGENTA,\n        'yellow': Fore.YELLOW,\n        'white': Fore.WHITE,\n        'black': Fore.LIGHTBLACK_EX\n    }\n\n    if color:\n        prompt = colors[color.lower()] + prompt + Fore.RESET\n\n    if default is not None:\n        r = input(prompt)\n    else:\n        while True:\n            r = input(prompt)\n            if r:\n                break\n\n    r = r or default\n\n    # remove the autocompletion before quitting for future input()\n    readline.parse_and_bind('tab: self-insert')\n    readline.set_completer(None)\n\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprompting a file using glob for autocompetion.", "response": "def prompt_file(prompt, default=None, must_exist=True, is_dir=False, \n                show_default=True, prompt_suffix=': ', color=None):\n    \"\"\"\n    Prompt a filename using using glob for autocompetion.\n\n    If must_exist is True (default) then you can be sure that the value returned\n    is an existing filename or directory name.\n    If is_dir is True, this will show only the directories for the completion.\n    \"\"\"\n\n    if must_exist:\n        while True:\n            r = prompt_autocomplete(prompt, path_complete(is_dir), default, show_default=show_default,\n                                    prompt_suffix=prompt_suffix, color=color)\n            if os.path.exists(r):\n                break\n            print('This path does not exist.')\n    else:\n        r = prompt_autocomplete(prompt, path_complete(is_dir), default, show_default=show_default,\n                                prompt_suffix=prompt_suffix, color=color)\n\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprompts a user for a string in a given range of possibilities.", "response": "def prompt_choice(prompt, possibilities, default=None, only_in_poss=True, \n                  show_default=True, prompt_suffix=': ', color=None):\n    \"\"\"\n    Prompt for a string in a given range of possibilities.\n\n    This also sets the history to the list of possibilities so\n    the user can scroll is with the arrow to find  what he wants,\n    If only_in_poss is False, you are not guaranteed that this\n    will return one of the possibilities.\n    \"\"\"\n\n    assert len(possibilities) >= 1\n    assert not only_in_poss or default is None or default in possibilities, '$s not in possibilities' % default\n\n    contains_spaces = any(' ' in poss for poss in possibilities)\n\n    possibilities = sorted(possibilities)\n\n    readline.clear_history()\n    for kw in possibilities:\n        readline.add_history(kw)\n\n    def complete(text):\n        return [t for t in possibilities if t.startswith(text)]\n\n    while 1:\n        r = prompt_autocomplete(prompt, complete, default, contains_spaces=contains_spaces, \n                                show_default=show_default, prompt_suffix=prompt_suffix, color=color)\n        if not only_in_poss or r in possibilities:\n            break\n        print('%s is not a possibility.' % r)\n        \n    readline.clear_history()\n\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef plot_glide_depths(depths, mask_tag_filt):\n    '''Plot depth at glides\n\n    Args\n    ----\n    depths: ndarray\n        Depth values at each sensor sampling\n    mask_tag_filt: ndarray\n        Boolean mask to slice filtered sub-glides from tag data\n    '''\n    import numpy\n\n    from . import plotutils\n\n    fig, ax = plt.subplots()\n\n    ax = plotutils.plot_noncontiguous(ax, depths, numpy.where(mask_tag_filt)[0])\n    ax.invert_yaxis()\n\n    plt.show()\n\n    return None", "response": "Plot depth at glides\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef plot_sgls(mask_exp, depths, mask_tag_filt, sgls, mask_sgls_filt, Az_g_hf,\n        idx_start=None, idx_end=None, path_plot=None, linewidth=0.5,\n        leg_bbox=(1.23,1), clip_x=False):\n    '''Plot sub-glides over depth and high-pass filtered accelerometer signal\n\n    Args\n    ----\n    mask_exp: ndarray\n        Boolean mask array to slice tag data to experimtal period\n    depths: ndarray\n        Depth values at each sensor sampling\n    mask_tag_filt: ndarray\n        Boolean mask to slice filtered sub-glides from tag data\n    sgls: pandas.DataFrame\n        Sub-glide summary information defined by `SGL` start/stop indices\n    mask_sgls_filt: ndarray\n        Boolean mask to slice filtered sub-glides from sgls data\n    Az_g_hf: ndarray\n        High-pass filtered, calibrated z-axis accelerometer data\n    idx_start: int\n        Sample index position where plot should begin\n    idx_stop: int\n        Sample index position where plot should stop\n    path_plot: str\n        Path and filename for figure to be saved\n    linewidth: float\n        Width of plot lines (Default: 0.5)\n    clip_x: bool\n        Swith to clip x-axis to the experimental period\n    '''\n    import matplotlib.pyplot as plt\n    from matplotlib.ticker import FuncFormatter, ScalarFormatter\n    import numpy\n\n    from . import plotutils\n    from .. import utils\n\n    # Create experiment mask from specified start/end indices if passed\n    if idx_start or idx_end:\n        mask_exp = numpy.zeros(len(depths), dtype=bool)\n        if idx_start and idx_end:\n            mask_exp[idx_start:idx_end] = True\n        elif idx_start:\n            mask_exp[idx_start:ind_exp[-1]] = True\n        elif idx_end:\n            mask_exp[ind_exp[0]:idx_end] = True\n\n    # Filter passed data to experimental period\n    depths  = depths[mask_exp]\n    Az_g_hf = Az_g_hf[mask_exp]\n\n    # Create subglide indice groups for plotting\n    sgl_ind    = numpy.where(mask_tag_filt & mask_exp)[0]\n    notsgl_ind = numpy.where((~mask_tag_filt) & mask_exp)[0]\n    # Create experiment indices from `mask_exp`\n    ind_exp = numpy.where(mask_exp)[0]\n    offset = 0\n    plt_offset = ind_exp[0]\n\n    # Clip values to within experimental period\n    if clip_x:\n        offset = ind_exp[0]\n        ind_exp = ind_exp - offset\n        sgl_ind    = sgl_ind - offset\n        notsgl_ind = notsgl_ind - offset\n        plt_offset = 0\n\n    fig, (ax1, ax2) = plt.subplots(2, 1)\n\n    # Plot glides\n    c0, c1 = _colors[0:2]\n    ax1 = plotutils.plot_noncontiguous(ax1, depths, sgl_ind, c0, 'Glides',\n                                       offset=plt_offset,\n                                       linewidth=linewidth*2)\n    ax1 = plotutils.plot_noncontiguous(ax1, depths, notsgl_ind, c1, 'Stroking',\n                                       offset=plt_offset, linewidth=linewidth,\n                                       linestyle='--')\n\n    # Plot HF Z-axis\n    c0 = _colors[2]\n    ax2.plot(ind_exp, Az_g_hf, color=c0, label='Z-axis HF Acc.',\n            linewidth=linewidth)\n\n    # Get dives within mask\n    gg = sgls[mask_sgls_filt]\n\n    # Get midpoint of dive occurance\n    x = (gg['start_idx'] + (gg['stop_idx'] - gg['start_idx'])/2)\n    x = x.values.astype(float)\n    x_mask = (x-offset > ind_exp[0]) & (x-offset< ind_exp[-1])\n    x = x[x_mask]\n\n    # Get depth at midpoint\n    if clip_x:\n        x = x - offset\n        ind_x = numpy.round(x).astype(int)\n    else:\n        ind_x = numpy.round(x - plt_offset).astype(int)\n    y = depths[ind_x]\n\n    # For each dive_id, sgl_id pair, create annotation string, apply\n    dids = gg['dive_id'].values.astype(int)\n    sids = numpy.array(gg.index)\n    dids = dids[x_mask]\n    sids = sids[x_mask]\n    n = ['Dive:{}, SGL:{}'.format(did, sid) for did, sid in zip(dids, sids)]\n\n    diff = ind_exp[1] - ind_exp[0]\n    for i, txt in enumerate(n):\n        # TODO semi-hardcoded dist for annotation\n        ax1.annotate(txt, (x[i]+int(diff*16),y[i]))\n\n    # Plot shaded areas where not sub-glides\n    ax1 = plotutils.plot_shade_mask(ax1, ind_exp, ~mask_tag_filt[mask_exp],\n            facecolor='#d9d9d9')\n    ax2 = plotutils.plot_shade_mask(ax2, ind_exp, ~mask_tag_filt[mask_exp],\n            facecolor='#d9d9d9')\n\n    # Set x-axes limits\n    for ax in [ax1, ax2]:\n        ticks = ax.get_yticks()\n        ax.set_ylim((ticks[0], ticks[-1]))\n        if idx_start:\n            xmin = idx_start\n        else:\n            xmin = ax.get_xlim()[0]\n        if idx_end:\n            xmax = idx_end\n        else:\n            xmax = ax.get_xlim()[1]\n        if clip_x:\n            xmin, xmax = xmin-offset, xmax-offset\n        ax.set_xlim(xmin, xmax)\n        for tick in ax.get_xticklabels():\n            tick.set_rotation(45)\n            tick.set_ha('right')\n\n    # Update Depth subplot y-axis labels, limits, invert depth\n    ax1.set_ylabel('Depth ($m$)')\n    ymin = depths.min() - (depths.max()*0.01)\n    ymax = depths.max() + (depths.max()*0.01)\n    ax1.set_ylim((ymin, ymax))\n    ax1.invert_yaxis()\n    ax1.get_yaxis().set_label_coords(-0.09,0.5)\n\n    # Update PRH subplot y labels, limits\n    ax2.set_ylabel('Z-axis acceleration ($g$)')\n    ax2.set_ylim((Az_g_hf.min(), Az_g_hf.max()))\n    ax2.get_yaxis().set_label_coords(-0.09,0.5)\n\n    # Scientific notation for ax1 `n_samples`\n    ax1.set_xlabel('No. sensor samples')\n    mf1 = ScalarFormatter(useMathText=True)\n    mf1.set_powerlimits((-2,2))\n    ax1.xaxis.set_major_formatter(mf1)\n\n    # Convert n_samples to hourmin labels\n    ax2.set_xlabel('Experiment duration ($min \\, sec$)')\n    mf2 = FuncFormatter(plotutils.nsamples_to_minsec)\n    ax2.xaxis.set_major_formatter(mf2)\n\n    # Create legends outside plot area\n    leg1 = ax1.legend(bbox_to_anchor=leg_bbox)\n    plt.tight_layout(rect=[0,0,0.8,1])\n\n    # Save plot if `path_plot` passed\n    if path_plot:\n        import os\n        fname = 'subglide_highlight'\n        if idx_start:\n            fname += '_start{}'.format(idx_start)\n        if idx_end:\n            fname+= '_stop{}'.format(idx_end)\n        ext = '.eps'\n        file_fig = os.path.join(path_plot, fname+ext)\n        plt.savefig(file_fig, box='tight')\n\n    plt.show()\n\n    return None", "response": "Plot sub - glides over depth and high - pass filtered accelerometer signal."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nverifies that the public and private key combination is valid ; raises MollomAuthenticationError otherwise", "response": "def verify_keys(self):\n        \"\"\"Verify that the public and private key combination is valid; raises MollomAuthenticationError otherwise\"\"\"\n        verify_keys_endpoint = Template(\"${rest_root}/site/${public_key}\")\n        url = verify_keys_endpoint.substitute(rest_root=self._rest_root, public_key=self._public_key)\n        \n        data = { \"clientName\": \"mollom_python\", \"clientVersion\": \"1.0\" }\n\n        self._client.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n\n        response = self._client.post(url, data, timeout=self._timeout)\n        if response.status_code != 200:\n            raise MollomAuthenticationError\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_content(self, \n                      content_id=None,\n                      post_title=None, \n                      post_body=None, \n                      author_name=None, \n                      author_url=None, \n                      author_mail=None, \n                      author_ip=None, \n                      author_id=None, \n                      author_open_id=None,\n                      author_created=None,\n                      allow_unsure=None,\n                      strictness=None,\n                      content_type=None,\n                      honeypot=None\n                      ):\n        \"\"\"Requests a ham/spam/unsure classification for content.\n        \n        If rechecking or updating previously checked content, the content_id must be passed in.\n        An example of this usage:\n            * checking the subsequent post after previewing the content\n            * checking the subsequent post after solving a CAPTCHA\n        \n        Keyword arguments:\n        content_id -- Unique identifier of the content to recheck/update.\n        post_title -- The title of the content.\n        post_body -- The body of the content.\n        author_name -- The name of the content author.\n        author_url -- The homepage/website URL of the content author.\n        author_mail -- The e-mail address of the content author.\n        author_ip -- The IP address of the content author.\n        author_id -- The local user ID on the client site of the content author.\n        author_open_id -- List of Open IDs of the content author.\n        author_created -- When the author's account was created.\n            Can be raw UNIX timestamp, or a Python date or datetime (in UTC).\n        allow_unsure -- If false, Mollom will only return ham or spam. Defaults to true.\n        strictness -- A string denoting the strictness of Mollom checks to perform. \n            Can be \"strict\", \"normal\" or \"relaxed\". Defaults to \"normal\".\n        content_type -- Type of content submitted. A type of \"user\" indicates user registration content.\n        honeypot -- The value of a client-side honeypot form element, if non-empty.\n        \n        Returns:\n        content_id -- Unique identifier if the content checked.\n        spam_classification -- \"ham\", \"spam\" or \"unsure\".\n        \"\"\"\n        if content_id:\n            recheck_content_endpoint = Template(\"${rest_root}/content/${content_id}\")\n            url = recheck_content_endpoint.substitute(rest_root=self._rest_root, content_id=content_id)\n        else:\n            check_content_endpoint = Template(\"${rest_root}/content\")\n            url = check_content_endpoint.substitute(rest_root=self._rest_root)\n        \n        data = {\"checks\": \"spam\"}\n        if post_title:\n            data[\"postTitle\"] = post_title\n        if post_body:\n            data[\"postBody\"] = post_body\n        if author_name:\n            data[\"authorName\"] = author_name\n        if author_url:\n            data[\"authorUrl\"] = author_url\n        if author_mail:\n            data[\"authorMail\"] = author_mail\n        if author_ip:\n            data[\"authorIp\"] = author_ip\n        if author_id:\n            data[\"authorId\"] = author_id\n        if author_open_id:\n            data[\"authorOpenId\"] = \" \".join(author_open_id)\n        if author_created:\n            if isinstance(author_created, datetime.date):  # and datetime.datetime is a subclass of datetime.date\n                data[\"authorCreated\"] = calendar.timegm(author_created.timetuple())\n            else:\n                data[\"authorCreated\"] = author_created\n        if allow_unsure:\n            data[\"unsure\"] = 1 if allow_unsure else 0\n        if strictness:\n            data[\"strictness\"] = strictness\n        if content_type:\n            data[\"contentType\"] = content_type\n        if honeypot:\n            data[\"honeypot\"] = honeypot\n            \n        return self.__post_request(url, data)", "response": "Checks the content of a given content_id."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a CAPTCHA to be served to the end - user.", "response": "def create_captcha(self, captcha_type=\"image\", ssl=None, content_id=None):\n        \"\"\"Creates a CAPTCHA to be served to the end-user.\n        \n        Keyword arguments:\n        captcha_type -- Type of CAPTCHA to create: \"image\" or \"audio\". Defaults to \"image\".\n        ssl -- True for a CAPTCHA served over https. Defaults to False.\n        content_id -- Unique identifier of the content to link the CAPTCHA to, in case the content was unsure.\n        \n        Returns:\n        captcha_id -- Unique identifier of the CAPTCHA created.\n        url -- Path to the CAPTCHA resource to be served to the end-user.\n        \"\"\"\n        create_captcha_endpoint = Template(\"${rest_root}/captcha\")\n        url = create_captcha_endpoint.substitute(rest_root=self._rest_root)\n        \n        data = {\"type\": captcha_type}\n        if ssl:\n            data[\"ssl\"] = 1 if ssl else 0\n        if content_id:\n            data[\"contentId\"] = content_id\n        \n        response = self.__post_request(url, data)\n        return response[\"captcha\"][\"id\"], response[\"captcha\"][\"url\"]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck a CAPTCHA that was solved by the end - user.", "response": "def check_captcha(self,\n                      captcha_id,\n                      solution,\n                      author_name=None, \n                      author_url=None, \n                      author_mail=None, \n                      author_ip=None, \n                      author_id=None, \n                      author_open_id=None,\n                      honeypot=None\n                      ):\n        \"\"\"Checks a CAPTCHA that was solved by the end-user.\n\n        Keyword arguments:\n        captcha_id -- Unique identifier of the CAPTCHA solved.\n        solution -- Solution provided by the end-user for the CAPTCHA.\n        author_name -- The name of the content author.\n        author_url -- The homepage/website URL of the content author.\n        author_mail -- The e-mail address of the content author.\n        author_ip -- The IP address of the content author.\n        author_id -- The local user ID on the client site of the content author.\n        author_open_id -- List of Open IDs of the content author.\n        honeypot -- The value of a client-side honeypot form element, if non-empty.\n        \n        Returns:\n        solved -- Boolean whether or not the CAPTCHA was solved correctly. \n            If the CAPTCHA is associated with an unsure contents, it is recommended to recheck the content.\n        \"\"\"\n        check_catpcha_endpoint = Template(\"${rest_root}/captcha/${captcha_id}\")\n        url = check_catpcha_endpoint.substitute(rest_root=self._rest_root, captcha_id=captcha_id)\n        \n        data = {\"solution\": solution}\n        \n        response = self.__post_request(url, data)\n        # Mollom returns \"1\" for success and \"0\" for failure\n        return response[\"captcha\"][\"solved\"] == \"1\""}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends feedback to Mollom.", "response": "def send_feedback(\n        self,\n        reason,\n        type=None,\n        author_ip=None,\n        author_id=None,\n        author_open_id=None,\n        content_id=None,\n        captcha_id=None,\n        source=None\n        ):\n        \"\"\"Sends feedback to Mollom in the case of false negative or false positives. \n        \n        Keyword arguments:\n        reason -- Feedback to give. Can be: \"approve\", \"spam\", \"unwanted\".\n            \"approve\" -- Report a false positive (legitimate content that was incorrectly classified as spam).\n            \"spam\" -- Report a false negative (spam that was incorrectly classified as ham).\n            \"unwanted\" -- Report content that isn't spam, but still unwanted on the site (e.g. offensive, profane, etc)\n        type -- A string denoting the type of feedback submitted: flag for end users flagging content to submit feedback; moderate for administrative moderation. Can be \"flag\" or \"moderate\". Defaults to \"moderate\".\n        author_ip -- The IP address of the content author.\n        author_id -- The local user ID on the client site of the content author.\n        author_open_id -- Open IDs of the content author, separated by whitespace.\n        content_id -- Existing content ID.\n        captcha_id -- Existing CAPTCHA ID.\n        source -- A single word string identifier for the user interface source. This is tracked along with the feedback to provide a more complete picture of how feedback is used and submitted on the site.\n        \"\"\"\n        send_feedback_endpoint = Template(\"${rest_root}/feedback\")\n        url = send_feedback_endpoint.substitute(rest_root=self._rest_root)\n        \n        data = {\"contentId\": content_id, \"reason\": reason}\n\n        if type:\n            data[\"type\"] = type\n        if author_ip:\n            data[\"authorIp\"] = author_ip\n        if author_id:\n            data[\"authorId\"] = author_id\n        if author_open_id:\n            data[\"authorOpenId\"] = author_open_id\n        if content_id:\n            data[\"contentId\"] = content_id\n        if captcha_id:\n            data[\"captchaId\"] = captcha_id\n        if source:\n            data[\"source\"] = source\n        \n        self.__post_request(url, data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_blacklist_entry(self, \n                               value, \n                               reason=\"unwanted\", \n                               context=\"allFields\", \n                               exact_match = False, \n                               enabled = True\n                               ):\n        \"\"\"Creates a new blacklist entry.\n        \n        Keyword arguments:\n        value -- The string value to blacklist.\n        reason -- The reason for why the value is blacklisted. Can be: \"spam\", \"unwanted\".\n        context -- The context where the entry's value may match. Can be:\n            allFields -- Match can be made in any field.\n            author -- Match can be made in any author related field.\n            authorName -- Match can be made in the author name of the content.\n            authorMail -- Match can be made in the author email of the content.\n            authorIp -- Match can be made in the author ip address of the content.\n            authorId -- Match can be made in the author id of the content.\n            links -- Match can be made in any of the links of the content.\n            postTitle -- Match can be made in the post title of the content.\n            post -- Match can be made in the post title or the post body of the content.\n        exact_match -- Whether there has to be an exact word match. Can be: \"exact\", \"contains\".\n            e.g. for a value of \"call\", \"caller\" would be a contains match, but not an exact match.\n        enabled -- Whether or not this blacklist entry is enabled.\n        \n        Returns:\n        blacklist_entry_id -- The unique identifier of the blacklist entry created.\n        \"\"\"\n        create_blacklist_endpoint = Template(\"${rest_root}/blacklist/${public_key}\")\n        url = create_blacklist_endpoint.substitute(rest_root=self._rest_root, public_key=self._public_key)\n        \n        data = {\"value\": value,\n                \"reason\": reason,\n                \"context\": context,\n                \"match\": \"exact\" if exact_match else \"contains\",\n                \"status\": 1 if enabled else 0\n                }\n        \n        response = self.__post_request(url, data)\n        return response[\"entry\"][\"id\"]", "response": "Creates a new blacklist entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_blacklist_entry(self, blacklist_entry_id):\n        delete_blacklist_endpoint = Template(\"${rest_root}/blacklist/${public_key}/${blacklist_entry_id}/delete\")\n        url = delete_blacklist_endpoint.substitute(rest_root=self._rest_root, public_key=self._public_key, blacklist_entry_id=blacklist_entry_id)\n        \n        self.__post_request(url, {})", "response": "Delete an existing blacklist entry."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a list of all blacklist entries.", "response": "def get_blacklist_entries(self):\n        \"\"\"Get a list of all blacklist entries.\n\n        \"\"\"\n        get_blacklist_entries_endpoint = Template(\"${rest_root}/blacklist/${public_key}/\")\n        url = get_blacklist_entries_endpoint.substitute(rest_root=self._rest_root, public_key=self._public_key)\n\n        response = self.__get_request(url)\n        return response[\"list\"][\"entry\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a single blacklist entry", "response": "def get_blacklist_entry(self, blacklist_entry_id):\n        \"\"\"Get a single blacklist entry\n\n        Keyword arguments:\n        blacklist_entry_id -- The unique identifier of the blacklist entry to get.\n        \"\"\"\n        get_blacklist_entries_endpoint = Template(\"${rest_root}/blacklist/${public_key}/${blacklist_entry_id}\")\n        url = get_blacklist_entries_endpoint.substitute(rest_root=self._rest_root, public_key=self._public_key, blacklist_entry_id=blacklist_entry_id)\n\n        response = self.__get_request(url)\n        return response[\"entry\"]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a deployment with the specified name", "response": "def create_deployment(deployment_name,\n                      token_manager=None,\n                      app_url=defaults.APP_URL):\n    \"\"\"\n    create a deployment with the specified name\n\n    \"\"\"\n    headers = token_manager.get_access_token_headers()\n\n    payload = {\n        'name': deployment_name,\n        'isAdmin': True\n    }\n\n    deployment_url = environment.get_deployment_url(app_url=app_url)\n    response = requests.post('%s/api/v1/deployments' % deployment_url,\n                             data=json.dumps(payload),\n                             headers=headers)\n\n    if response.status_code == 201:\n        return response.json()\n\n    else:\n        raise JutException('Error %s: %s' % (response.status_code, response.text))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the list of deployments that the current access_token gives you access to", "response": "def get_deployments(token_manager=None,\n                    app_url=defaults.APP_URL):\n    \"\"\"\n    return the list of deployments that the current access_token gives you\n    access to\n\n    \"\"\"\n    headers = token_manager.get_access_token_headers()\n    deployment_url = environment.get_deployment_url(app_url=app_url)\n    response = requests.get('%s/api/v1/deployments' % deployment_url,\n                            headers=headers)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise JutException('Error %s: %s' % (response.status_code, response.text))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the deployment id for the specified deployment name", "response": "def get_deployment_id(deployment_name,\n                      token_manager=None,\n                      app_url=defaults.APP_URL):\n    \"\"\"\n    return the deployment id for the deployment with the specified name\n\n    \"\"\"\n\n    headers = token_manager.get_access_token_headers()\n    deployment_url = environment.get_deployment_url(app_url=app_url)\n    response = requests.get('%s/api/v1/deployments' % deployment_url,\n                            headers=headers)\n\n    if response.status_code == 200:\n        deployments = response.json()\n\n        for deployment in deployments:\n            if deployment['name'] == deployment_name:\n                return deployment['deployment_id']\n\n        raise JutException('Unable to find deployment with name %s' % deployment_name)\n    else:\n        raise JutException('Error %s: %s' % (response.status_code, response.text))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the space id that relates to the space name provided WorkItem", "response": "def get_space_id(deployment_name,\n                 space_name,\n                 token_manager=None,\n                 app_url=defaults.APP_URL):\n    \"\"\"\n    get the space id that relates to the space name provided\n\n    \"\"\"\n    spaces = get_spaces(deployment_name,\n                        token_manager=token_manager,\n                        app_url=app_url)\n\n    for space in spaces:\n        if space['name'] == space_name:\n            return space['id']\n\n    raise JutException('Unable to find space \"%s\" within deployment \"%s\"' %\n                    (space_name, deployment_name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_space(deployment_name,\n                 space_name,\n                 security_policy='public',\n                 events_retention_days=0,\n                 metrics_retention_days=0,\n                 token_manager=None,\n                 app_url=defaults.APP_URL):\n    \"\"\"\n    create a space within the deployment specified and with the various\n    rentention values set\n\n    \"\"\"\n    deployment_id = get_deployment_id(deployment_name,\n                                      token_manager=token_manager,\n                                      app_url=app_url)\n\n    payload = {\n        'name': space_name,\n        'security_policy': security_policy,\n        'events_retention_days': events_retention_days,\n        'metrics_retention_days': metrics_retention_days,\n    }\n\n    headers = token_manager.get_access_token_headers()\n    deployment_url = environment.get_deployment_url(app_url=app_url)\n    response = requests.post('%s/api/v1/deployments/%s/spaces' %\n                             (deployment_url, deployment_id),\n                             data=json.dumps(payload),\n                             headers=headers)\n\n    if response.status_code == 201:\n        return response.json()\n    else:\n        raise JutException('Error %s: %s' % (response.status_code, response.text))", "response": "create a new space within the deployment"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting all users in the deployment", "response": "def get_users(deployment_name,\n              token_manager=None,\n              app_url=defaults.APP_URL):\n    \"\"\"\n    get all users in the deployment specified\n\n    \"\"\"\n    deployment_id = get_deployment_id(deployment_name,\n                                      token_manager=token_manager,\n                                      app_url=app_url)\n\n    headers = token_manager.get_access_token_headers()\n    deployment_url = environment.get_deployment_url(app_url=app_url)\n    response = requests.get('%s/api/v1/deployments/%s/accounts' %\n                            (deployment_url, deployment_id),\n                            headers=headers)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise JutException('Error %s: %s' % (response.status_code, response.text))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_user(username,\n             deployment_name,\n             token_manager=None,\n             app_url=defaults.APP_URL):\n    \"\"\"\n    add user to deployment\n\n    \"\"\"\n    deployment_id = get_deployment_id(deployment_name,\n                                      token_manager=token_manager,\n                                      app_url=app_url)\n\n    account_id = accounts.get_account_id(username,\n                                         token_manager=token_manager,\n                                         app_url=app_url)\n\n    headers = token_manager.get_access_token_headers()\n    deployment_url = environment.get_deployment_url(app_url=app_url)\n    response = requests.put('%s/api/v1/deployments/%s/accounts/%s' %\n                            (deployment_url, deployment_id, account_id),\n                            headers=headers)\n\n    if response.status_code == 204:\n        return response.text\n    else:\n        raise JutException('Error %s: %s' % (response.status_code, response.text))", "response": "add user to a deployment"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef as_string(self, chars, current_linkable=False, class_current=\"active_link\"):\n        return self.__do_menu(\"as_string\", current_linkable, class_current, chars)", "response": "It returns menu as string"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef as_p(self, show_leaf=True, current_linkable=False, class_current=\"active_link\"):\n        return self.__do_menu(\"as_p\", show_leaf, current_linkable, class_current)", "response": "It returns the current page as a link"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_call(self, func, params, extra_kwargs):\n        if hasattr(func, '__name__'):\n            uri = '/%s/%s' % (self.call_name, func.__name__[2:])\n        else:\n            uri = '/%s' % self.call_name\n        control_kwargs = self._update_params(\n            params, extra_kwargs, getattr(func, 'control_keywords', None))\n        if not self._api.silent:\n            unrecognized_params = set(params) - set(func.allowed_params)\n            if unrecognized_params:\n                err_msg = (\n                    \"At least one of the parameters to the api call: '%s' is \"\n                    \"unrecognized. Allowed parameters are: '%s'. Unrecognized \"\n                    \"parameters are: '%s'.\" % (uri, ', '.join(func.allowed_params), \n                                               ', '.join(unrecognized_params)))\n                if self._api.production and self._api.silent is None:\n                    warnings.warn(err_msg, WePayWarning)\n                else:\n                    raise WePayWarning(err_msg)\n        \n        # in case if param is Decimal\n        for name in self.floating:\n            if name in params:\n                params[name] = float(params[name])\n        if control_kwargs.pop('batch_mode', False):\n            call = {\n                'call': uri\n            }\n            access_token = control_kwargs.get('access_token', None)\n            if access_token is not None:\n                call['authorization'] = access_token\n            if params:\n                call['parameters'] = params\n            if control_kwargs.get('reference_id', None) is not None:\n                call['reference_id'] = control_kwargs['reference_id']\n            return call\n        return self._api.call(uri, params=params, **control_kwargs)", "response": "This method is used to make a call to a specific item in a list of items. It will check validity of params and then performs a call."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_config(filename, header):\n\n    parser = SettingParser(filename)\n    if parser.header != header:\n        header_value = parser.header or ''\n        raise ParseError(u\"Unexpected header '{0}', expecting '{1}'\"\n                         .format(common.from_utf8(header_value), header))\n\n    return parser", "response": "Parses the provided filename and returns a SettingParser instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef print_variable(obj, **kwargs):\n    variable_print_length = kwargs.get(\"variable_print_length\", 1000)\n    s = str(obj)\n    if len(s) < 300:\n        return \"Printing the object:\\n\" + str(obj)\n    else:\n        return \"Printing the object:\\n\" + str(obj)[:variable_print_length] + ' ...'", "response": "Print the variable out. Limit the string length to 300 characters."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of the set of entries that intersect this set and the given set of entries.", "response": "def lintersects(self, span):\n        \"\"\"\n        If this span intersects the left (starting) side of the given span.\n        \"\"\"\n        if isinstance(span, list):\n            return [sp for sp in span if self._lintersects(sp)]\n\n        return self._lintersects(span)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of the items that intersect this span.", "response": "def rintersects(self, span):\n        \"\"\"\n        If this span intersects the right (ending) side of the given span.\n        \"\"\"\n        if isinstance(span, list):\n            return [sp for sp in span if self._rintersects(sp)]\n\n        return self._rintersects(span)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ltouches(self, span):\n        if isinstance(span, list):\n            return [sp for sp in span if self._ltouches(sp)]\n\n        return self._ltouches(span)", "response": "Returns true if the end of this span touches the left ( starting ) side of the given span."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rtouches(self, span):\n        if isinstance(span, list):\n            return [sp for sp in span if self._rtouches(sp)]\n\n        return self._rtouches(span)", "response": "Returns true if the start of this span touches the right ( ending ) side of the given span."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning true if the given span fits inside this one", "response": "def encompasses(self, span):\n        \"\"\"\n        Returns true if the given span fits inside this one\n        \"\"\"\n        if isinstance(span, list):\n            return [sp for sp in span if self._encompasses(sp)]\n\n        return self._encompasses(span)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef encompassed_by(self, span):\n        if isinstance(span, list):\n            return [sp for sp in span if sp.encompasses(self)]\n\n        return span.encompasses(self)", "response": "Returns true if the given span encompasses this span."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef adds(self, string):\n        if isinstance(string, unicode):\n            string = string.encode(\"utf-8\")\n\n        self.children.append((STRING, str(string)))", "response": "Add a string child."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef random_redshift_array(\n        log,\n        sampleNumber,\n        lowerRedshiftLimit,\n        upperRedshiftLimit,\n        redshiftResolution,\n        pathToOutputPlotDirectory,\n        plot=False):\n    \"\"\"\n    *Generate a NumPy array of random distances given a sample number and distance limit*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``sampleNumber`` -- the sample number, i.e. array size\n        - ``lowerRedshiftLimit`` -- the lower redshift limit of the volume to be included\n        - ``upperRedshiftLimit`` -- the upper redshift limit of the volume to be included\n        - ``redshiftResolution`` -- the resolution of the redshift distribution\n        - ``pathToOutputPlotDirectory`` -- path to the output directory (provided by the user)\n        - ``plot`` -- generate plot?\n\n    **Return:**\n        - ``redshiftArray`` -- an array of random redshifts within the volume limit\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import numpy.random as npr\n    ## LOCAL APPLICATION ##\n    import dryxPython.astrotools as da\n\n    redshiftDistribution = np.arange(\n        0., upperRedshiftLimit, redshiftResolution)\n    closestNumber = lambda n, l: min(l, key=lambda x: abs(x - n))\n\n    # GIVEN THE REDSHIFT LIMIT - DETERMINE THE VOLUME LIMIT\n    distanceDictionary = da.convert_redshift_to_distance(upperRedshiftLimit)\n    upperMpcLimit = distanceDictionary[\"dl_mpc\"]\n    upperVolumeLimit = (4. / 3.) * np.pi * upperMpcLimit ** 3\n\n    if lowerRedshiftLimit == 0.:\n        lowerVolumeLimit = 0.\n    else:\n        distanceDictionary = da.convert_redshift_to_distance(\n            lowerRedshiftLimit)\n        lowerMpcLimit = distanceDictionary[\"dl_mpc\"]\n        lowerVolumeLimit = (4. / 3.) * np.pi * lowerMpcLimit ** 3\n\n    volumeShell = upperVolumeLimit - lowerVolumeLimit\n\n    # GENERATE A LIST OF RANDOM DISTANCES\n    redshiftList = []\n    for i in range(sampleNumber):\n        randomVolume = lowerVolumeLimit + npr.random() * volumeShell\n        randomDistance = (randomVolume * (3. / 4.) / np.pi) ** (1. / 3.)\n        randomRedshift = da.convert_mpc_to_redshift(randomDistance)\n        randomRedshift = closestNumber(randomRedshift, redshiftDistribution)\n        # log.debug('randomDistance %s' % (randomDistance,))\n        redshiftList.append(randomRedshift)\n\n    redshiftArray = np.array(redshiftList)\n    # log.info('redshiftArray %s' % (redshiftArray,))\n\n    if plot:\n        # FORCE SQUARE FIGURE AND SQUARE AXES LOOKS BETTER FOR POLAR\n        fig = plt.figure(\n            num=None,\n            figsize=(8, 8),\n            dpi=None,\n            facecolor=None,\n            edgecolor=None,\n            frameon=True)\n\n        ax = fig.add_axes(\n            [0.1, 0.1, 0.8, 0.8],\n            polar=True)\n\n        thetaList = []\n        twoPi = 2. * np.pi\n        for i in range(sampleNumber):\n            thetaList.append(twoPi * npr.random())\n        thetaArray = np.array(thetaList)\n\n        plt.scatter(\n            thetaArray,\n            redshiftArray,\n            s=10,\n            c='b',\n            marker='o',\n            cmap=None,\n            norm=None,\n            vmin=None,\n            vmax=None,\n            alpha=None,\n            linewidths=None,\n            edgecolor='w',\n            verts=None,\n            hold=None)\n\n        title = \"SN Redshift Distribution\"\n        plt.title(title)\n        fileName = pathToOutputPlotDirectory + title.replace(\" \", \"_\") + \".png\"\n        plt.savefig(fileName)\n        plt.clf()  # clear figure\n\n    return redshiftArray", "response": "Generate a NumPy array of random redshifts given a sample number and distance limit."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates random supernova types from the weighted distributions set in the simulation settings file.", "response": "def random_sn_types_array(\n        log,\n        sampleNumber,\n        relativeSNRates,\n        pathToOutputPlotDirectory,\n        plot=False):\n    \"\"\"\n    *Generate random supernova types from the weighted distributions set in the simulation settings file*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``sampleNumber`` -- the sample number, i.e. array size\n        - ``relativeSNRates`` -- dictionary of the rates\n        - ``pathToOutputPlotDirectory`` -- path to the output directory (provided by the user)\n        - ``plot`` -- generate plot?\n\n    **Return:**\n        - ``snTypesArray`` -- numpy array of the random SN types\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    ## LOCAL APPLICATION ##\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    ################ > VARIABLE SETTINGS ######\n\n    ################ >ACTION(S) ################\n    randomSNTypeList = []\n    # CREATE COUNTERS FOR PLOTTING\n    counters = {}\n    for k, v in relativeSNRates.iteritems():\n        counters[k] = 0\n\n    for i in range(sampleNumber):\n        randNum = np.random.rand()\n        cumulative = 0.\n        for k, v in relativeSNRates.iteritems():\n            cumulative = cumulative + v\n            if (randNum <= cumulative):\n                randType = k\n                counters[k] += 1\n                break\n        randomSNTypeList.append(randType)\n\n    # for k, v in relativeSNRates.iteritems():\n    #     log.debug('%s = %s' % (k, counters[k]))\n\n    snTypeArray = np.array(randomSNTypeList)\n\n    if plot:\n        numTypes = len(relativeSNRates)\n        x = np.arange(1, numTypes + 1, 1)\n\n        heights = []\n        xticks = []\n        for k, v in relativeSNRates.iteritems():\n            xticks.append(k)\n            heights.append(counters[k])\n\n        fig = plt.figure(\n            num=None,\n            figsize=(8, 8),\n            dpi=None,\n            facecolor=None,\n            edgecolor=None,\n            frameon=True)\n\n        ax = fig.add_axes(\n            [0.1, 0.1, 0.8, 0.8])\n\n        ax.bar(\n            x,\n            heights,\n            width=0.8,\n            bottom=0)\n\n        plt.xticks(x + 0.5,  xticks)\n\n        ax.set_xlabel('SN Type')\n        ax.set_ylabel('Number of SNe')\n        ax.grid(True)\n\n        title = \"Weighted SN Distribution\"\n        plt.title(title)\n        fileName = pathToOutputPlotDirectory + title.replace(\" \", \"_\") + \".png\"\n        plt.savefig(fileName)\n        plt.clf()  # clear figure\n\n    return snTypeArray"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef random_host_extinction(\n        log,\n        sampleNumber,\n        extinctionType,\n        extinctionConstant,\n        hostExtinctionDistributions,\n        plot=False):\n    \"\"\"\n    *Generate a Numpy array of random host extinctions*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``sampleNumber`` -- the sample number, i.e. array size\n        - ``extinctionType`` -- constant or random?\n        - ``extinctionConstant`` -- the constant value (when extinctionType is constant)\n        - ``hostExtinctionDistributions`` -- the host extinction distribution (when extinctionType is random)\n        - ``plot`` -- generate plot?\n\n    **Return:**\n        - ``hostExtinctionArray``\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    import numpy as np\n    ## LOCAL APPLICATION ##\n\n    ################ > VARIABLE SETTINGS #######\n\n    ################ >ACTION(S) ################\n    # xxx come back here and add in the random extinctions generation -- will\n    # need to account for what type of SN we have ##\n    if extinctionType == \"constant\":\n        hostExtinctionArray = np.zeros(sampleNumber) * extinctionConstant\n    else:\n        log.error('host extiction distributions not included yet')\n\n    return hostExtinctionArray", "response": "Generate a Numpy array of random host extinctions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a Numpy array of random galactic extinctions for a particular set of extensions", "response": "def random_galactic_extinction(\n        log,\n        sampleNumber,\n        extinctionType,\n        extinctionConstant,\n        galacticExtinctionDistributions,\n        plot=False):\n    \"\"\"\n    *Generate a Numpy array of random galactic extinctions*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``sampleNumber`` -- the sample number, i.e. array size\n        - ``extinctionType`` -- constant or random?\n        - ``extinctionConstant`` -- the constant value (when extinctionType is constant)\n        - ``galacticExtinctionDistributions`` -- the galactic extinction distribution (when extinctionType is random)\n        - ``plot`` -- generate plot?\n\n    **Return:**\n        - ``galacticExtinctionArray``\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    import numpy as np\n    ## LOCAL APPLICATION ##\n\n    ################ > VARIABLE SETTINGS #######\n\n    ################ >ACTION(S) ################\n    # xxx come back here and add in the random extinctions generation -- will\n    # need to account for what type of SN we have ##\n    if extinctionType == \"constant\":\n        galacticExtinctionArray = np.ones(sampleNumber) * extinctionConstant\n    else:\n        log.error('galactic extiction distributions not included yet')\n\n    # log.debug('galacticExtinctionArray %s' % (galacticExtinctionArray,))\n\n    return galacticExtinctionArray"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a numpy polynomial of the curves for the given set of SN Lightcurves.", "response": "def generate_numpy_polynomial_lightcurves(\n        log,\n        snLightCurves,\n        pathToOutputDirectory,\n        pathToOutputPlotDirectory,\n        plot=False):\n    \"\"\"\n    *Given a the yaml input of the SN Lightcurves generate a numpy polynomial of the curves.*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``snLightCurves`` -- some info on sn LightCurves\n        - ``pathToOutputDirectory`` -- path to the output directory (provided by the user)\n        - ``pathToOutputPlotDirectory`` -- path to the output plots directory\n        - ``plot`` -- generate plot?\n\n    **Return:**\n        - ``polynomialDict`` -- { snType, polynomialLightcurve }\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    import numpy as np\n    import matplotlib.pyplot as plt\n    import yaml\n    ## LOCAL APPLICATION ##\n    import dryxPython.plotting as dp\n\n    ################ >ACTION(S) ################\n    # EXTRACT THE MODEL LIGHTCURVE POLYNOMIALS\n    fileName = pathToOutputDirectory + \"/transient_light_curves.yaml\"\n    stream = file(fileName, 'r')\n    yamlContent = yaml.load(stream)\n    generatedLCs = yamlContent\n    stream.close()\n\n    log.info('fileName: %s' % (fileName,))\n    log.debug('generatedLCs: %s' % (generatedLCs,))\n\n    rawLightCurveDict = {}\n    for model, filterData in generatedLCs.iteritems():\n        thisModel = model\n        rawLightCurveDict[thisModel] = {}\n        for ffilter, modelData in filterData.iteritems():\n            rawLightCurveDict[thisModel][ffilter] = {}\n            plotDict = {}\n\n            if modelData[\"poly\"] is None:\n                log.warning(\n                    'cound not plot the raw lightcurve for the %s object in rest frame %s-band - probably insufficient spectral coverage' %\n                    (model, ffilter))\n                rawLightCurveDict[thisModel][ffilter]['poly'] = None\n                rawLightCurveDict[thisModel][ffilter][\n                    'Explosion Day Relative to Peak'] = None\n                rawLightCurveDict[thisModel][ffilter][\n                    'End of lightcurve relative to peak'] = None\n                continue\n\n            # explosionDay = snLightCurves[model]['Explosion Day Relative to Peak']\n            endOfLightcurveDay = snLightCurves[model][\n                'End of lightcurve relative to peak']\n            explosionDay = modelData['Explosion Day Relative to Peak']\n            log.info(\n                'explosionDay, endOfLightcurveDay for raw Light Curve: %s, %s' %\n                (explosionDay, endOfLightcurveDay))\n            # endOfLightcurveDay = snLightCurves[model]['End of lightcurve relative to peak']\n            # log.info('endOfLightcurveDay %s' % (endOfLightcurveDay,))\n            # log.info('explosionDay %s' % (explosionDay,))\n            poly = modelData['poly']\n            peakMag = modelData['Peak Magnitude']\n            peakMagPoly = np.poly1d([peakMag, ])\n            polyLightCurve = np.poly1d(poly)\n            polyLightCurve = polyLightCurve - peakMagPoly\n            polyLightCurve = np.poly1d(polyLightCurve)\n            rawLightCurveDict[thisModel][ffilter]['poly'] = polyLightCurve\n            rawLightCurveDict[thisModel][ffilter][\n                'Explosion Day Relative to Peak'] = explosionDay\n\n            log.debug(\n                'rawLightCurveDict[thisModel][ffilter][Explosion Day Relative to Peak]: %s' %\n                (rawLightCurveDict[thisModel][ffilter]['Explosion Day Relative to Peak'],))\n            rawLightCurveDict[thisModel][ffilter][\n                'End of lightcurve relative to peak'] = endOfLightcurveDay\n            plotDict[model] = polyLightCurve\n\n            if plot:\n                plot_polynomial(\n                    log,\n                    title=\"00 raw lightcurve for %s, filter %s\" % (\n                        model, ffilter),\n                    polynomialDict=plotDict,\n                    orginalDataDictionary=False,\n                    pathToOutputPlotsFolder=pathToOutputPlotDirectory,\n                    xRange=[explosionDay, endOfLightcurveDay],\n                    xlabel=False,\n                    ylabel=False,\n                    xAxisLimits=False,\n                    yAxisLimits=False,\n                    yAxisInvert=True,\n                    prependNum=False)\n\n    return rawLightCurveDict"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef random_peak_magnitudes(\n        log,\n        peakMagnitudeDistributions,\n        snTypesArray,\n        plot=True):\n    \"\"\"\n    *Generate a numpy array of random (distribution weighted) peak magnitudes for the given sn types.*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``peakMagnitudeDistributions`` -- yaml style dictionary of peak magnitude distributions\n        - ``snTypesArray`` -- the pre-generated array of random sn types\n        - ``plot`` -- generate plot?\n\n    **Return:**\n        - None\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    import matplotlib.pyplot as plt\n    import numpy as np\n    ## LOCAL APPLICATION ##\n\n    ################ >ACTION(S) ################\n    magDistributions = {}\n    for snType, peakMag in peakMagnitudeDistributions['magnitude'].iteritems():\n        sigma = peakMagnitudeDistributions['sigma'][snType]\n        magDistributions[snType] = [peakMag, sigma]\n\n    peakMagList = []\n    for item in snTypesArray:\n        thisPeak = magDistributions[item][\n            1] * np.random.randn() + magDistributions[item][0]\n        peakMagList.append(thisPeak)\n\n    peakMagArray = np.array(peakMagList)\n    # log.debug('peakMagArray %s' % (peakMagArray,))\n\n    return peakMagArray", "response": "Generate a numpy array of random peak magnitudes for the given sn types."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_kcorrection_array(\n        log,\n        redshiftArray,\n        snTypesArray,\n        snLightCurves,\n        pathToOutputDirectory,\n        plot=True):\n    \"\"\"\n    *Given the random redshiftArray and snTypeArray, generate a dictionary of k-correction polynomials (one for each filter) for every object.*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``redshiftArray`` -- the pre-generated redshift array\n        - ``snTypesArray`` -- the pre-generated array of random sn types\n        - ``snLightCurves`` -- yaml style dictionary of SN lightcurve info\n        - ``pathToOutputDirectory`` -- path to the output directory (provided by the user)\n        - ``plot`` -- generate plot?\n\n    **Return:**\n        - None\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    import yaml\n    import numpy as np\n    ## LOCAL APPLICATION ##\n\n    ################ >ACTION(S) ################\n    dataDir = pathToOutputDirectory + \"/k_corrections/\"\n    filters = ['g', 'r', 'i', 'z']\n    fileName = pathToOutputDirectory + \"/transient_light_curves.yaml\"\n    stream = file(fileName, 'r')\n    generatedLCs = yaml.load(stream)\n    models = generatedLCs.keys()\n    kCorList = []\n\n    for i in range(len(redshiftArray)):\n        redshift = redshiftArray[i]\n        kCorDict = {}\n        for model in models:\n            for ffilter in filters:\n                filterDir = dataDir + model + \"/\" + ffilter\n                strRed = \"%0.3f\" % (redshift,)\n                fileName = filterDir + \"/z\" + \\\n                    str(strRed).replace(\".\", \"pt\") + \"_poly.yaml\"\n                try:\n                    stream = file(fileName, 'r')\n                    yamlContent = yaml.load(stream)\n                    # log.info('yamlContent %s' % (yamlContent,))\n                    stream.close()\n                    flatPoly = np.poly1d(yamlContent['polyCoeffs'])\n                except:\n                    flatPoly = None\n                kCorDict[ffilter] = flatPoly\n                kCorList.append(kCorDict)\n\n    kCorArray = np.array(kCorList)\n    return kCorArray", "response": "This function builds a k - correction array from the given redshift array and SN light curves."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convert_lightcurves_to_observered_frame(\n        log,\n        snLightCurves,\n        rawLightCurveDict,\n        redshiftArray,\n        snTypesArray,\n        peakMagnitudesArray,\n        hostExtinctionArray,\n        kCorrectionArray,\n        galacticExtinctionArray,\n        restFrameFilter,\n        pathToOutputDirectory,\n        pathToOutputPlotDirectory,\n        polyOrder,\n        plot=True):\n    \"\"\"\n    *Given all the randomly generated parameters of the survey, generate a dictionary of lightcurves for each object (one lightcurve per filter)*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``snLightCurves`` -- the sn lightcurve dictionary (with explosion / extinction dates)\n        - ``rawLightCurveDict`` -- dictionary of the raw lightcurves (all peaking at mag = 0)\n        - ``redshiftArray`` -- array of random redshifts,\n        - ``snTypesArray`` --  array of random sn types,\n        - ``peakMagnitudesArray`` --  array of random peak mags,\n        - ``kCorrectionArray`` -- array of k-corrections,\n        - ``hostExtinctionArray`` --  array of random host extinctions,\n        - ``galacticExtinctionArray`` --  array of random galactic extinctions,\n        - ``restFrameFilter`` -- the observed frame filter with which to calculate k-corrections with\n        - ``pathToOutputDirectory`` -- path to the output directory (provided by the user)\n        - ``pathToOutputPlotDirectory`` -- path to the output plot directory\n        - ``polyOrder`` -- order of the polynomial used to fit the lightcurve\n        - ``plot`` -- generate plots?\n\n    **Return:**\n        - None\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    import numpy as np\n    import matplotlib.pyplot as plt\n    import math\n    import yaml\n    ## LOCAL APPLICATION ##\n    import dryxPython.astrotools as da\n    import dryxPython.plotting as dp\n\n    ################ >ACTION(S) ################\n    filters = ['g', 'r', 'i', 'z']\n    fileName = pathToOutputDirectory + \"/transient_light_curves.yaml\"\n    stream = file(fileName, 'r')\n    generatedLCs = yaml.load(stream)\n    models = generatedLCs.keys()\n    ebvConverters = {'g': 3.793, 'r': 2.751, 'i': 2.086, 'z': 1.479}\n    stepNum = 0\n\n    ###########################################################\n    # STEP 1 - CONVERT RAW LIGHTCURVES TO ABSOLUTE MAG CURVES #\n    ###########################################################\n    stepNum += 1\n    stepStr = \"%02d\" % stepNum\n    # CONVERT PEAK MAGS TO POLYNOMIALS\n    peakMagPolyList = []\n    for item in peakMagnitudesArray:\n        thisPoly = np.poly1d([item, ])\n        peakMagPolyList.append(thisPoly)\n\n    # CONVERT RAW LIGHTCURVES TO ABSOLUTE MAG CURVES\n    absLightCurveList = []\n    exampleDictionary = {}\n\n    for item in range(len(snTypesArray)):\n        thisModel = snTypesArray[item]\n        # explosionDay = snLightCurves[thisModel]['Explosion Day Relative to Peak']\n        log.debug('thisModel, restFrameFilter: %s, %s' %\n                  (thisModel, restFrameFilter,))\n        explosionDay = rawLightCurveDict[thisModel][\n            restFrameFilter]['Explosion Day Relative to Peak']\n        endOfLightcurveDay = snLightCurves[thisModel][\n            'End of lightcurve relative to peak']\n        log.info(\n            'explosionDay, endOfLightcurveDay for absolute Light Curve: %s, %s' %\n            (explosionDay, endOfLightcurveDay))\n        absLightCurve = rawLightCurveDict[thisModel][\n            restFrameFilter]['poly'] + peakMagPolyList[item]\n        absLightCurve = np.poly1d(absLightCurve)\n        absLightCurveList.append(absLightCurve)\n        exampleDictionary['SN %02d @ z = %04.3f' %\n                          (item, redshiftArray[item])] = absLightCurve\n    if plot:\n        plot_polynomial(\n            log,\n            title=\"Absoulte Magnitude Lightcurves - random sample\",\n            polynomialDict=exampleDictionary,\n            orginalDataDictionary=False,\n            pathToOutputPlotsFolder=pathToOutputPlotDirectory,\n            xRange=[explosionDay, endOfLightcurveDay],\n            xlabel=\"Days Relative to Peak (Rest Frame)\",\n            ylabel=\"Absolute Magnitude\",\n            xAxisLimits=False,\n            yAxisLimits=False,\n            yAxisInvert=True,\n            prependNum=stepNum)\n\n    ################################################################\n    # STEP 2 - CONVERT ABSOLUTE LIGHTCURVES TO APPARENT MAG CURVES #\n    ################################################################\n    stepNum += 1\n    stepStr = \"%02d\" % stepNum\n    # CONVERT DISTANCE MOD TO POLYNOMIALS\n    distanceModPolyList = []\n    for item in redshiftArray:\n        log.debug('redshift: %s' % (item,))\n        if item == 0.0:\n            item = 0.01\n        distanceDictionary = da.convert_redshift_to_distance(item)\n        distanceMpc = distanceDictionary[\"dl_mpc\"]\n        distanceModulus = distanceDictionary[\"dmod\"]\n        # log.debug('distanceMpc %s' % (distanceMpc,))\n        # log.info('redshift %s = distanceModulus %s' % (item, distanceModulus,))\n        thisPoly = np.poly1d([distanceModulus, ])\n        distanceModPolyList.append(thisPoly)\n\n    # CONVERT ABSOLUTE LIGHTCURVES TO APPARENT MAG CURVES\n    apparentLightCurveList = []\n    for item in range(len(snTypesArray)):\n        thisModel = snTypesArray[item]\n        # explosionDay = snLightCurves[thisModel]['Explosion Day Relative to Peak']\n        explosionDay = rawLightCurveDict[thisModel][\n            restFrameFilter]['Explosion Day Relative to Peak']\n        endOfLightcurveDay = snLightCurves[thisModel][\n            'End of lightcurve relative to peak']\n        log.info(\n            'explosionDay, endOfLightcurveDay for apparent Light Curve: %s, %s' %\n            (explosionDay, endOfLightcurveDay))\n        apparentLightCurve = absLightCurveList[\n            item] + distanceModPolyList[item]\n        # log.debug('apparentLightCurve %s' % (apparentLightCurve,))\n        apparentLightCurve = np.poly1d(apparentLightCurve)\n        apparentLightCurveList.append(apparentLightCurve)\n        exampleDictionary['SN %02d @ z = %04.3f' %\n                          (item, redshiftArray[item])] = apparentLightCurve\n        #log.info('absLightCurveDictionary %s' % (absLightCurveDictionary,))\n    if plot:\n        plot_polynomial(\n            log,\n            title=\"Pre-KCorrection Apparent Magnitude Lightcurves - random sample\",\n            polynomialDict=exampleDictionary,\n            orginalDataDictionary=False,\n            pathToOutputPlotsFolder=pathToOutputPlotDirectory,\n            xRange=[explosionDay, endOfLightcurveDay],\n            xlabel=\"Days Relative to Peak (Rest Frame)\",\n            ylabel=\"Apparent Magnitude\",\n            xAxisLimits=False,\n            yAxisLimits=False,\n            yAxisInvert=True,\n            prependNum=stepNum)\n\n    ###########################################################\n    # STEP 3 - (UN) K-CORRECT THE APPARENT LIGHTCURVES        #\n    ###########################################################\n    stepNum += 1\n    stepStr = \"%02d\" % stepNum\n    # (UN) K-CORRECT THE APPARENT LIGHTCURVES\n    kCorApparentLightCurveList = []\n    for i in range(len(apparentLightCurveList)):\n        thisModel = snTypesArray[i]\n        # explosionDay = snLightCurves[thisModel]['Explosion Day Relative to Peak']\n        explosionDay = rawLightCurveDict[thisModel][\n            restFrameFilter]['Explosion Day Relative to Peak']\n        endOfLightcurveDay = snLightCurves[thisModel][\n            'End of lightcurve relative to peak']\n        log.info(\n            'explosionDay, endOfLightcurveDay for unkcor apparent Light Curve: %s, %s' %\n            (explosionDay, endOfLightcurveDay))\n        kCorDict = kCorrectionArray[i]\n        lcDict = {}\n        plotLcDict = {}\n        for ffilter, poly in kCorDict.iteritems():\n            if poly is None:\n                kcorLightCurve = None\n            else:\n                kcorLightCurve = apparentLightCurveList[i] - poly\n                plotLcDict[ffilter] = kcorLightCurve\n            lcDict[ffilter] = kcorLightCurve\n            if plot:\n                plot_polynomial(\n                    log,\n                    title=\"K(un)corrected Apparent Magnitude Lightcurves - SN Number %s\" % (\n                        i),\n                    polynomialDict=plotLcDict,\n                    orginalDataDictionary=False,\n                    pathToOutputPlotsFolder=pathToOutputPlotDirectory,\n                    xRange=[explosionDay, endOfLightcurveDay],\n                    xlabel=\"Days Relative to Peak (Rest Frame)\",\n                    ylabel=\"Apparent Magnitude\",\n                    xAxisLimits=False,\n                    yAxisLimits=False,\n                    yAxisInvert=True,\n                    prependNum=stepNum)\n\n        kCorApparentLightCurveList.append(lcDict)\n\n    ###########################################################\n    # STEP 4 - INCLUDE GALACTIC EXTINCTION IN LIGHTCURVES     #\n    ###########################################################\n    stepNum += 1\n    stepStr = \"%02d\" % stepNum\n    # INCLUDE GALACTIC EXTINCTION\n    # CONVERT EXT TO POLYNOMIALS\n    galExtPolyList = []\n    for ext in galacticExtinctionArray:\n        extDict = {}\n        for ffilter in filters:\n            thisExt = ext * ebvConverters[ffilter]\n            # log.info('ext %s, filter %s' % (thisExt, ffilter))\n            thisPoly = np.poly1d([thisExt, ])\n            extDict[ffilter] = thisPoly\n        galExtPolyList.append(extDict)\n\n    # INCLUDE GALAXTIC EXTINTION IN LIGHTCURVES\n    galExtLightCurveList = []\n    for item in range(len(kCorApparentLightCurveList)):\n        thisModel = snTypesArray[item]\n        # explosionDay = snLightCurves[thisModel]['Explosion Day Relative to Peak']\n        explosionDay = rawLightCurveDict[thisModel][\n            restFrameFilter]['Explosion Day Relative to Peak']\n        endOfLightcurveDay = snLightCurves[thisModel][\n            'End of lightcurve relative to peak']\n        log.info(\n            'explosionDay, endOfLightcurveDay for galatic extinction corr Frame Light Curve: %s, %s' %\n            (explosionDay, endOfLightcurveDay))\n        lcDict = {}\n        plotLcDict = {}\n        for ffilter in filters:\n            if kCorApparentLightCurveList[item][ffilter] is not None:\n                galExtLightCurve = kCorApparentLightCurveList[\n                    item][ffilter] + galExtPolyList[item][ffilter]\n                # log.debug('apparentLightCurve %s' % (apparentLightCurve,))\n                galExtPoly = np.poly1d(galExtLightCurve)\n                plotLcDict[ffilter] = galExtPoly\n            else:\n                galExtPoly = None\n            lcDict[ffilter] = galExtPoly\n        if plot:\n            plot_polynomial(\n                log,\n                title=\"Galactic Extinction Corrected Lightcurves - SN Number %s\" % (\n                    item),\n                polynomialDict=plotLcDict,\n                orginalDataDictionary=False,\n                pathToOutputPlotsFolder=pathToOutputPlotDirectory,\n                xRange=[explosionDay, endOfLightcurveDay],\n                xlabel=\"Days Relative to Peak (Rest Frame)\",\n                ylabel=\"Apparent Magnitude\",\n                xAxisLimits=False,\n                yAxisLimits=False,\n                yAxisInvert=True,\n                prependNum=stepNum)\n\n        galExtLightCurveList.append(lcDict)\n\n    ###########################################################\n    # STEP 5 - TIME-DILATE LIGHTCURVES                        #\n    ###########################################################\n    stepNum += 1\n    stepStr = \"%02d\" % stepNum\n    observedFrameLightCurveInfo = []\n    peakAppMagList = []\n    for item in range(len(redshiftArray)):\n        timeDilation = 1. + redshiftArray[item]\n        thisModel = snTypesArray[item]\n        # explosionDay = snLightCurves[thisModel]['Explosion Day Relative to Peak']*timeDilation\n        explosionDay = rawLightCurveDict[thisModel][restFrameFilter][\n            'Explosion Day Relative to Peak'] * timeDilation\n        endOfLightcurveDay = snLightCurves[thisModel][\n            'End of lightcurve relative to peak'] * timeDilation\n        log.info(\n            'explosionDay, endOfLightcurveDay for observed time dil Frame Light Curve: %s, %s' %\n            (explosionDay, endOfLightcurveDay))\n        polyDict = {}\n        lcPolyDict = {}\n        peakMagDict = {}\n        floatPeakMagDict = {}\n\n        for ffilter in filters:\n            if galExtLightCurveList[item][ffilter] is not None:\n                xList = []\n                yList = []\n                for x in range(int(explosionDay), int(endOfLightcurveDay)):\n                    xList.append(x * timeDilation)\n                    y = galExtLightCurveList[item][ffilter](x)\n                    yList.append(y)\n\n                x = np.array(xList)\n                y = np.array(yList)\n                thisPoly = np.polyfit(x, y, polyOrder)\n                flatPoly = np.poly1d(thisPoly)\n                peakMag = flatPoly(0)\n                floatPeakMag = float(peakMag)\n                polyDict[ffilter] = flatPoly\n                peakMagDict[ffilter] = peakMag\n                floatPeakMagDict[ffilter] = floatPeakMag\n                lcPolyDict[ffilter] = flatPoly\n            else:\n                polyDict[ffilter] = None\n                peakMagDict[ffilter] = None\n                floatPeakMagDict[ffilter] = None\n\n        if plot:\n            plot_polynomial(\n                log,\n                title=\"Observed Lightcurves - SN Number %s\" % (item, ),\n                polynomialDict=lcPolyDict,\n                orginalDataDictionary=False,\n                pathToOutputPlotsFolder=pathToOutputPlotDirectory,\n                xRange=[explosionDay, endOfLightcurveDay],\n                xlabel=\"Days Relative to Peak (Observed Frame)\",\n                ylabel=\"Apparent Magnitude\",\n                xAxisLimits=False,\n                yAxisLimits=False,\n                yAxisInvert=True,\n                prependNum=stepNum,\n                legend=True)\n\n        thisData = {\n            'lightCurves': polyDict,\n            'peakMags': peakMagDict,\n            'explosionDay': explosionDay,\n            'endOfLightcurveDay': endOfLightcurveDay}\n        # log.info('peakMagDict %s' % (peakMagDict,))\n        observedFrameLightCurveInfo.append(thisData)\n        peakAppMagList.append(floatPeakMagDict)\n\n    return observedFrameLightCurveInfo, peakAppMagList", "response": "This function converts the lightcurves from the original format to the observed frame format."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_dict(cls, **kwargs):\n        # Create the object\n        obj = cls()\n        # By default, objects are initialized with attribute values of None\n        # We need to clear those out so that we get AttributeError on access\n        for attr in cls.__all_attributes__:\n            delattr(obj, \"_\" + attr)\n        del obj._id\n        # Set the attributes that were passed\n        for attr, val in kwargs.items():\n            setattr(obj, \"_\" + attr, val)\n        return obj", "response": "Construct an object from a dictionary of attributes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, **kwargs):\n        for attr, val in kwargs.items():\n            if attr in (list(self.__class__.__attributes__) + \\\n                        list(associations.associations_for(self.__class__))):\n                setattr(self, attr, val)", "response": "Update the attributes of the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting this record without deleting any dependent or child records.", "response": "def delete(self):\n        \"\"\"\n        Delete this record without deleting any dependent or child records.\n        This can orphan records, so use with care.\n        \"\"\"\n        if self.id:\n            with Repo.db:\n                Repo(self.__table).where(id=self.id).delete()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave a record to the database creating it if needed updating it if needed.", "response": "def save(self):\n        \"\"\"\n        Save a record to the database, creating it if needed, updating it\n        otherwise. Also saves related records (children and dependents) as\n        needed.\n        \"\"\"\n        with Repo.db:\n            self._do_save()\n            our_name = inflector.singularize(Repo.table_name(self.__class__))\n            for record in self._related_records:\n                if not self._id:\n                    related_key = associations.foreign_keys_for(\n                        record.__class__)[our_name]\n                    setattr(record, related_key, self.__id)\n                record._do_save()\n            for record in self._delete_related_records:\n                record._do_destroy()\n        self._finish_save()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef shorten(string, max_length=80, trailing_chars=3):\n    ''' trims the 'string' argument down to 'max_length' to make previews to long string values '''\n    assert type(string).__name__ in {'str', 'unicode'}, 'shorten needs string to be a string, not {}'.format(type(string))\n    assert type(max_length) == int, 'shorten needs max_length to be an int, not {}'.format(type(max_length))\n    assert type(trailing_chars) == int, 'shorten needs trailing_chars to be an int, not {}'.format(type(trailing_chars))\n    assert max_length > 0, 'shorten needs max_length to be positive, not {}'.format(max_length)\n    assert trailing_chars >= 0, 'shorten needs trailing_chars to be greater than or equal to 0, not {}'.format(trailing_chars)\n\n    return (\n        string\n    ) if len(string) <= max_length else (\n        '{before:}...{after:}'.format(\n            before=string[:max_length-(trailing_chars+3)],\n            after=string[-trailing_chars:] if trailing_chars>0 else ''\n        )\n    )", "response": "shortens the string argument down to max_length to make previews to long string values"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn true if the input looks like a prettytable", "response": "def is_prettytable(string):\n    \"\"\" returns true if the input looks like a prettytable \"\"\"\n    return type(string).__name__ in {'str','unicode'} and (\n        len(string.splitlines()) > 1\n    ) and (\n        all(string[i] == string[-i-1] for i in range(3))\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a list of all published ships and their basic information.", "response": "def get_all_published_ships_basic(db_connection):\n    \"\"\" Gets a list of all published ships and their basic information.\n\n    :return: Each result has a tuple of (typeID, typeName, groupID, groupName, categoryID, and categoryName).\n    :rtype: list\n    \"\"\"\n\n    if not hasattr(get_all_published_ships_basic, '_results'):\n        sql = 'CALL get_all_published_ships_basic();'\n        results = execute_sql(sql, db_connection)\n        get_all_published_ships_basic._results = results\n\n    return get_all_published_ships_basic._results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_ships_that_have_variations(db_connection):\n\n    if not hasattr(get_ships_that_have_variations, '_results'):\n        sql = 'CALL get_ships_that_have_variations();'\n        results = execute_sql(sql, db_connection)\n        get_ships_that_have_variations._results = results\n\n    return get_ships_that_have_variations._results", "response": "Gets a list of all published ship type IDs that have at least 3 variations."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef c14n(xml):\n    '''\n    Applies c14n to the xml input\n    @param xml: str\n    @return: str\n    '''\n    tree = etree.parse(StringIO(xml))\n    output = StringIO()\n    tree.write_c14n(output, exclusive=False, with_comments=True, compression=0)\n    output.flush()\n    c14nized = output.getvalue()\n    output.close()\n    return c14nized", "response": "Applies c14n to the xml input\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsign XML string from xml_string of XML.", "response": "def sign(xml, private, public):\n    '''\n    Return xmldsig XML string from xml_string of XML.\n    @param xml: str of bytestring xml to sign\n    @param private: publicKey Private key\n    @param public: publicKey Public key\n    @return str: signed XML byte string\n    '''\n    xml = xml.encode('utf-8', 'xmlcharrefreplace')\n    signed_info_xml = _generate_signed_info(xml)\n\n    signer = PKCS1_v1_5.PKCS115_SigScheme(private)\n    signature_value = signer.sign(SHA.new(c14n(signed_info_xml)))\n\n    signature_xml = PTN_SIGNATURE_XML % {\n        'signed_info_xml': signed_info_xml,\n        'signature_value': binascii.b2a_base64(signature_value)[:-1],\n        'key_info_xml': _generate_key_info_xml_rsa(public.key.n, public.key.e)\n    }\n\n    position = xml.rfind('</')\n    return xml[0:position] + signature_xml + xml[position:]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef verify(xml):\n    '''Verifies whether the validity of the signature contained in an XML\n    document following the XMLDSig standard'''\n    try:\n        from cStringIO import cStringIO as StringIO \n    except ImportError:\n        from StringIO import StringIO\n    \n    xml = xml.encode('utf-8', 'xmlcharrefreplace')\n    tree = etree.parse(StringIO(xml))\n    \n    try:\n        '''Isolating the Signature element'''\n        signature_tree = tree.xpath('xmldsig:Signature',\n                                    namespaces=NAMESPACES)[0]\n    \n        '''Removing the Signature element from the main tree to compute a new \n        digest value with the actual content of the XML.'''\n        signature_tree.getparent().remove(signature_tree)\n        signed_info = _generate_signed_info(etree.tostring(tree))\n        \n        '''Constructing the key from the Modulus and Exponent stored in the\n        Signature/KeyInfo/KeyValue/RSAKeyValue element'''                                 \n        from Crypto.PublicKey import RSA\n        modulus = signature_tree.xpath(KEY_INFO_PATH + '/xmldsig:Modulus',\n                                       namespaces=NAMESPACES)[0].text\n        exponent = signature_tree.xpath(KEY_INFO_PATH + '/xmldsig:Exponent',\n                                        namespaces=NAMESPACES)[0].text        \n        public_key = RSA.construct((b64d(modulus), b64d(exponent)))\n    \n        '''Isolating the signature value to verify'''\n        signature = signature_tree.xpath('xmldsig:SignatureValue',\n                                         namespaces=NAMESPACES)[0].text\n    except IndexError:\n        raise RuntimeError('XML does not contain a properly formatted ' \\\n                           ' Signature element')\n    \n    verifier = PKCS1_v1_5.PKCS115_SigScheme(public_key)\n    return verifier.verify(SHA.new(c14n(signed_info)),\n                           binascii.a2b_base64(signature))", "response": "Verifies whether the validity of the signature contained in an XML file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef autodiscover():\n    for app in settings.INSTALLED_APPS:\n        try:\n            import_module('.'.join((app, 'api')))\n        except ImportError as e:\n            if e.msg != \"No module named '{0}.api'\".format(app):\n                print(e.msg)", "response": "Autodiscover the api. py file in the installed apps to generate the routes of the registered viewsets."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nimports and return the Python module named in arg.", "response": "def identify_module(arg):\n    \"\"\"Import and return the Python module named in `arg`.\n\n    If the module cannot be imported, a `pywhich.ModuleNotFound` exception is\n    raised.\n\n    \"\"\"\n    try:\n        __import__(arg)\n    except Exception:\n        exc = sys.exc_info()[1]\n        raise ModuleNotFound(\"%s: %s\" % (type(exc).__name__, str(exc)))\n\n    mod = sys.modules[arg]\n    return mod"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef identify_filepath(arg, real_path=None, show_directory=None,\n    find_source=None, hide_init=None):\n    \"\"\"Discover and return the disk file path of the Python module named in\n    `arg` by importing the module and returning its ``__file__`` attribute.\n\n    If `find_source` is `True`, the named module is a ``pyc`` or ``pyo`` file,\n    and a corresponding ``.py`` file exists on disk, the path to the ``.py``\n    file is returned instead.\n\n    If `show_directory` is `True`, the path to the directory containing the\n    discovered module file is returned. Similarly, if `hide_init` is `True` and\n    the named module is the ``__init__`` module of a package, the function\n    returns the path to the package directory containing the ``__init__.py``\n    filename.\n\n    If `real_path` is `True` and the discovered module was loaded via symlink,\n    the real path (as determined by `os.path.realpath()`) is returned.\n\n    If the named module cannot be imported or its path on disk determined, this\n    function raises a `pywhich.ModuleNotFound` exception.\n\n    \"\"\"\n    mod = identify_module(arg)  # raises ModuleNotFound\n    try:\n        filename = mod.__file__\n    except AttributeError:\n        raise ModuleNotFound(\"module has no '__file__' attribute; is it a \"\n            \"built-in or C module?\")\n\n    if find_source and (filename.endswith('.pyc') or filename.endswith('.pyo')):\n        log.debug(\"Filename ends in pyc or pyo, so looking for the .py file\")\n        sourcefile = filename[:-1]\n        if os.access(sourcefile, os.F_OK):\n            filename = sourcefile\n        else:\n            log.debug(\"Did not find .py file for path %r, using as-is\",\n                filename)\n\n    if real_path:\n        filename = os.path.realpath(filename)\n\n    if show_directory or (hide_init and\n        os.path.basename(filename).startswith('__init__.')):\n        log.debug(\"Showing directories or hiding __init__s, so returning \"\n            \"directory of %r\", filename)\n        filename = os.path.dirname(filename)\n\n    return filename", "response": "Discover and return the disk file path of the named Python module named in\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the disk locations of the given named modules and print them to stdout and errors discovering paths to stderr.", "response": "def identify_modules(*args, **kwargs):\n    \"\"\"Find the disk locations of the given named modules, printing the\n    discovered paths to stdout and errors discovering paths to stderr.\n\n    Any provided keyword arguments are passed to `identify_filepath()`.\n\n    \"\"\"\n    if len(args) == 1:\n        path_template = \"%(file)s\"\n        error_template = \"Module '%(mod)s' not found (%(error)s)\"\n    else:\n        path_template = \"%(mod)s: %(file)s\"\n        error_template = \"%(mod)s: not found (%(error)s)\"\n\n    for modulename in args:\n        try:\n            filepath = identify_filepath(modulename, **kwargs)\n        except ModuleNotFound:\n            exc = sys.exc_info()[1]\n            sys.stderr.write(error_template % {\n                'mod': modulename,\n                'error': str(exc),\n            })\n            sys.stderr.write('\\n')\n        else:\n            print(path_template % {\n                'mod': modulename,\n                'file': filepath\n            })"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_version(*args):\n    if len(args) == 1:\n        ver_template = \"%(version)s\"\n        error_template = \"Distribution/module '%(mod)s' not found (%(error)s)\"\n    else:\n        ver_template = \"%(mod)s: %(version)s\"\n        error_template = \"%(mod)s: not found (%(error)s)\"\n\n    import pkg_resources\n    for modulename in args:\n        try:\n\n            try:\n                dist = pkg_resources.get_distribution(modulename)\n            except pkg_resources.DistributionNotFound:\n\n                mod = identify_module(modulename)  # raises ModuleNotFound\n                if not hasattr(mod, '__version__'):\n                    raise ModuleNotFound('module has no __version__')\n                version = mod.__version__\n\n            else:\n                version = dist.version\n\n        except ModuleNotFound:\n            exc = sys.exc_info()[1]\n            sys.stderr.write(error_template % {\n                'mod': modulename,\n                'error': str(exc),\n            })\n            sys.stderr.write('\\n')\n        else:\n            print(ver_template % {\n                'mod': modulename,\n                'version': version,\n            })", "response": "Find the versions of the given named modules printing the discovered versions to stdout and errors discovering versions to stderr."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main(argv=None):\n    if argv is None:\n        argv = sys.argv\n\n    parser = OptionParser()\n\n    parser.add_option('-v', '--verbose', dest=\"verbose\", action=\"count\",\n        default=2, help=\"be chattier (stackable)\")\n    def quiet(option, opt_str, value, parser):\n        parser.values.verbose -= 1\n    parser.add_option('-q', '--quiet', action=\"callback\", callback=quiet,\n        help=\"be less chatty (stackable)\")\n\n    parser.add_option('-r', action=\"store_true\", dest=\"real_path\",\n        default=False, help=\"dereference symlinks\")\n    parser.add_option('-b', action=\"store_true\", dest=\"show_directory\",\n        default=False, help=\"show directory instead of filename\")\n    parser.add_option('-i', '--hide-init', action=\"store_true\", dest=\"hide_init\",\n        default=False, help=\"show directory if the module ends in __init__.py\")\n    parser.add_option('-s', '--source', action=\"store_true\", dest=\"find_source\",\n        default=False, help=\"find .py files for .pyc/.pyo files\")\n    parser.add_option('--ver', action=\"store_true\", dest=\"find_version\",\n        default=False, help=\"find the version of the named package, not the location on disk\")\n\n    opts, args = parser.parse_args()\n\n    verbose = max(0, min(4, opts.verbose))\n    log_levels = (logging.CRITICAL, logging.ERROR, logging.WARNING, logging.INFO, logging.DEBUG)\n    logging.basicConfig()\n    log.setLevel(log_levels[verbose])\n\n    if opts.find_version:\n        find_version(*args)\n    else:\n        kwargs = dict((fld, getattr(opts, fld)) for fld\n            in ('real_path', 'show_directory', 'find_source', 'hide_init'))\n        identify_modules(*args, **kwargs)\n\n    return 0", "response": "Run the pywhich command as if invoked with arguments argv."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_dict(cls, d):\n        assert isinstance(d, dict)\n        init_args = dict()\n        for key, is_required in cls.dictionary_attributes.iteritems():\n            try:\n                init_args[key] = d[key]\n            except KeyError:\n                if is_required:\n                    raise DictConvertible.Error('missing key in dictionary', cls, missing_key=key)\n        return cls(**init_args)", "response": "Create an instance from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread an instance from a JSON - formatted file.", "response": "def read_json_file(cls, path):\n        \"\"\"\n        Read an instance from a JSON-formatted file.\n\n        :return: A new instance\n        \"\"\"\n        with open(path, 'r') as f:\n            return cls.from_dict(json.load(f))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_json_file(self, path):\n        with open(path, 'w') as f:\n            json.dump(self.to_dict(), f, indent=2)", "response": "Write the instance in JSON format to a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate an instance from a dictionary.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Create an instance from a dictionary.\n        \"\"\"\n        execution_request = super(ExecutionRequest, cls).from_dict(d)\n        if isinstance(execution_request.simulation_group, dict):\n            execution_request.simulation_group = SimulationGroup.from_dict(execution_request.simulation_group)\n        return execution_request"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate an instance from a dictionary.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Create an instance from a dictionary.\n        \"\"\"\n        instance = super(SimulationGroup, cls).from_dict(d)\n        #  instance.simulations is a list of dictionaries; convert each dictionary to a Simulation instance\n        instance.simulations = [Simulation.from_dict(x) for x in instance.simulations]\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates an instance from a dictionary.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Create an instance from a dictionary.\n        \"\"\"\n        instance = super(Simulation, cls).from_dict(d)\n        #  The instance's input_files and cmd_line_args members still point to data structures in the original\n        #  dictionary.  Copy them to avoid surprises if they are changed in the original dictionary.\n        instance.input_files = dict(instance.input_files)\n        instance.cmd_line_args = list(instance.cmd_line_args)\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef value(self):\n        if self._value is None:\n            raise ValueError(\"%s's 'value' is not set.\" % type(self).__name__)\n        return self._value", "response": "Property to be used when saving a custom field into a document instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if the given email address is correct.", "response": "def is_valid(email):\n        \"\"\"Email address validation method.\n\n        :param email: Email address to be saved.\n        :type email: basestring\n        :returns: True if email address is correct, False otherwise.\n        :rtype: bool\n        \"\"\"\n        if isinstance(email, basestring) and EMAIL_RE.match(email):\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate the given raw password against the intance s encrypted one.", "response": "def check_password(self, raw_password):\n        \"\"\"Validates the given raw password against the intance's encrypted one.\n\n        :param raw_password: Raw password to be checked against.\n        :type raw_password: unicode\n        :returns: True if comparison was successful, False otherwise.\n        :rtype: bool\n        :raises: :exc:`ImportError` if `py-bcrypt` was not found.\n        \"\"\"\n        bcrypt = self.get_bcrypt()\n        return bcrypt.hashpw(raw_password, self.value)==self.value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_archlinux():\n    if platform.system().lower() == 'linux':\n        if platform.linux_distribution() == ('', '', ''):\n            # undefined distribution. Fixed in python 3.\n            if os.path.exists('/etc/arch-release'):\n                return True\n    return False", "response": "return True if the current distribution is running on arch Linux"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_or_clear(self, path, **kwargs):\n\n        try:\n            yield self.create(path, **kwargs)\n        except NodeExistsException:\n            children = yield self.get_children(path)\n            for name in children:\n                yield self.recursive_delete(path + \"/\" + name)", "response": "Create path and recursively clear contents."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_path(self, path, **kwargs):\n\n        i = 0\n        while i < len(path):\n            i = path.find(\"/\", i)\n\n            if i < 0:\n                return\n\n            subpath = path[:i]\n\n            if i > 0:\n                try:\n                    yield self.create(subpath, **kwargs)\n                except NodeExistsException:\n                    pass\n\n            i += 1", "response": "Create nodes required to complete path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the data of a node at the given path or creates it.", "response": "def set_or_create(self, path, *args, **kwargs):\n        \"\"\"Sets the data of a node at the given path, or creates it.\"\"\"\n\n        d = self.set(path, *args, **kwargs)\n\n        @d.addErrback\n        def _error(result):\n            return self.create(path, *args, **kwargs)\n\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_or_wait(self, path, name):\n\n        # First, get children and watch folder.\n        d, watch = self.get_children_and_watch(path)\n\n        deferred = Deferred()\n        path += \"/\" + name\n\n        @watch.addCallback\n        def _notify(event):\n            if event.type_name == \"child\":\n                d = self.get(path)\n                d.addCallback(deferred.callback)\n\n        # Retrieve children.\n        children = yield d\n\n        if name in children:\n            watch.cancel()\n            deferred = self.get(path)\n\n        result = yield deferred\n        returnValue(result)", "response": "Get data of node under path or wait for it."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds contiguous True regions of the boolean array condition.", "response": "def contiguous_regions(condition):\n    '''Finds contiguous True regions of the boolean array 'condition'.\n\n    Args\n    ----\n    condition: numpy.ndarray, dtype bool\n        boolean mask array, but can pass the condition itself (e.g. x > 5)\n\n    Returns\n    -------\n    start_ind: numpy.ndarray, dtype int\n        array with the start indices for each contiguous region\n    stop_ind: numpy.ndarray, dtype int\n        array with the stop indices for each contiguous region\n\n    Notes\n    -----\n    This function is adpated from Joe Kington's answer on StackOverflow:\n    http://stackoverflow.com/a/4495197/943773\n    '''\n    import numpy\n\n    if condition.ndim > 1:\n        raise IndexError('contiguous_regions(): condition must be 1-D')\n\n    # Find the indicies of changes in 'condition'\n    idx = numpy.diff(condition).nonzero()[0]\n\n    if condition[0]:\n        # If the start of condition is True prepend a 0\n        idx = numpy.r_[0, idx]\n\n    if condition[-1]:\n        # If the end of condition is True, append the length of the array\n        idx = numpy.r_[idx, condition.size] # Edit\n\n    # Reshape the result into two columns\n    idx.shape = (-1,2)\n\n    # We need to start things after the change in 'condition'. Therefore,\n    # we'll shift the index by 1 to the right.\n    start_ind = idx[:,0] + 1\n    # keep the stop ending just before the change in condition\n    stop_ind  = idx[:,1]\n\n    # remove reversed or same start/stop index\n    good_vals = (stop_ind-start_ind) > 0\n    start_ind = start_ind[good_vals]\n    stop_ind = stop_ind[good_vals]\n\n    return start_ind, stop_ind"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rm_regions(a, b, a_start_ind, a_stop_ind):\n    '''Remove contiguous regions in `a` before region `b`\n\n    Boolean arrays `a` and `b` should have alternating occuances of regions of\n    `True` values. This routine removes additional contiguous regions in `a`\n    that occur before a complimentary region in `b` has occured\n\n    Args\n    ----\n    a: ndarray\n        Boolean array with regions of contiguous `True` values\n    b: ndarray\n        Boolean array with regions of contiguous `True` values\n    a_start_ind: ndarray\n        indices of start of `a` regions\n    a_stop_ind: ndarray\n        indices of stop of `a` regions\n\n    Returns\n    -------\n    a: ndarray\n        Boolean array with regions for which began before a complimentary\n        region in `b` have occured\n    '''\n\n    import numpy\n\n    for i in range(len(a_stop_ind)):\n        next_a_start = numpy.argmax(a[a_stop_ind[i]:])\n        next_b_start = numpy.argmax(b[a_stop_ind[i]:])\n        if  next_b_start > next_a_start:\n            a[a_start_ind[i]:a_stop_ind[i]] = False\n\n        return a", "response": "This routine removes contiguous regions in a before region b."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning path indices of directory list from user input", "response": "def get_dir_indices(msg, dirs):\n    '''Return path(s) indices of directory list from user input\n\n    Args\n    ----\n    msg: str\n        String with message to display before pass selection input\n    dir_list: array-like\n        list of paths to be displayed and selected from\n\n    Return\n    ------\n    input_dir_indices: array-like\n        list of index positions of user selected path from input\n    '''\n    import os\n\n    # Get user input for paths to process\n    usage = ('\\nEnter numbers preceeding paths seperated by commas (e.g. '\n             '`0,2,3`).\\nTo select all paths type `all`.\\nSingle directories '\n             'can also be entered (e.g.  `0`)\\n\\n')\n\n    # Generate paths text to display\n    dirs_str = ['{:2} {:60}\\n'.format(i, p) for i, p in enumerate(dirs)]\n    dirs_str = ''.join(dirs_str)\n\n    # Concatenate `msg`, usage txt, and paths list for display before input\n    input_dirs   = recursive_input(''.join([msg, usage, dirs_str, '\\n']), str)\n\n    # Determine type of input\n    if ',' in input_dirs:\n        input_dir_indices = [int(x.strip()) for x in input_dirs.split(',')]\n    elif 'all' in input_dirs:\n        input_dir_indices = range(len(dirs))\n    else:\n        try:\n            input_dir_indices = [int(input_dirs.strip()),]\n        except:\n            raise ValueError('Could not determine input type for input: '\n                             '{}'.format(input_dirs))\n\n    return input_dir_indices"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of child pages for the given parent.", "response": "def page_menu(context, token):\n    \"\"\"\n    Return a list of child pages for the given parent, storing all\n    pages in a dict in the context when first called using parents as keys\n    for retrieval on subsequent recursive calls from the menu template.\n    \"\"\"\n    # First arg could be the menu template file name, or the parent page.\n    # Also allow for both to be used.\n    template_name = None\n    parent_page = None\n    parts = token.split_contents()[1:]\n    for part in parts:\n        part = Variable(part).resolve(context)\n        if isinstance(part, str):\n            template_name = part\n        elif isinstance(part, Page):\n            parent_page = part\n    if template_name is None:\n        try:\n            template_name = context[\"menu_template_name\"]\n        except KeyError:\n            error = \"No template found for page_menu in: %s\" % parts\n            raise TemplateSyntaxError(error)\n    context[\"menu_template_name\"] = template_name\n    if \"menu_pages\" not in context:\n        try:\n            user = context[\"request\"].user\n            slug = context[\"request\"].path\n        except KeyError:\n            user = None\n            slug = \"\"\n        num_children = lambda id: lambda: len(context[\"menu_pages\"][id])\n        has_children = lambda id: lambda: num_children(id)() > 0\n        rel = [m.__name__.lower()\n               for m in Page.get_content_models()\n               if not m._meta.proxy]\n        published = Page.objects.published(for_user=user).select_related(*rel)\n        # Store the current page being viewed in the context. Used\n        # for comparisons in page.set_menu_helpers.\n        if \"page\" not in context:\n            try:\n                context.dicts[0][\"_current_page\"] = published.exclude(\n                    content_model=\"link\").get(slug=slug)\n            except Page.DoesNotExist:\n                context.dicts[0][\"_current_page\"] = None\n        elif slug:\n            context.dicts[0][\"_current_page\"] = context[\"page\"]\n        # Some homepage related context flags. on_home is just a helper\n        # indicated we're on the homepage. has_home indicates an actual\n        # page object exists for the homepage, which can be used to\n        # determine whether or not to show a hard-coded homepage link\n        # in the page menu.\n        home = home_slug()\n        context.dicts[0][\"on_home\"] = slug == home\n        context.dicts[0][\"has_home\"] = False\n        # Maintain a dict of page IDs -> parent IDs for fast\n        # lookup in setting page.is_current_or_ascendant in\n        # page.set_menu_helpers.\n        context.dicts[0][\"_parent_page_ids\"] = {}\n        pages = defaultdict(list)\n        for page in published.order_by(\"_order\"):\n            page.set_helpers(context)\n            context[\"_parent_page_ids\"][page.id] = page.parent_id\n            setattr(page, \"num_children\", num_children(page.id))\n            setattr(page, \"has_children\", has_children(page.id))\n            pages[page.parent_id].append(page)\n            if page.slug == home:\n                context.dicts[0][\"has_home\"] = True\n        # Include menu_pages in all contexts, not only in the\n        # block being rendered.\n        context.dicts[0][\"menu_pages\"] = pages\n    # ``branch_level`` must be stored against each page so that the\n    # calculation of it is correctly applied. This looks weird but if we do\n    # the ``branch_level`` as a separate arg to the template tag with the\n    # addition performed on it, the addition occurs each time the template\n    # tag is called rather than once per level.\n    context[\"branch_level\"] = 0\n    parent_page_id = None\n    if parent_page is not None:\n        context[\"branch_level\"] = getattr(parent_page, \"branch_level\", 0) + 1\n        parent_page_id = parent_page.id\n\n    # Build the ``page_branch`` template variable, which is the list of\n    # pages for the current parent. Here we also assign the attributes\n    # to the page object that determines whether it belongs in the\n    # current menu template being rendered.\n    context[\"page_branch\"] = context[\"menu_pages\"].get(parent_page_id, [])\n    context[\"page_branch_in_menu\"] = False\n    for page in context[\"page_branch\"]:\n        page.in_menu = page.in_menu_template(template_name)\n        page.num_children_in_menu = 0\n        if page.in_menu:\n            context[\"page_branch_in_menu\"] = True\n        for child in context[\"menu_pages\"].get(page.id, []):\n            if child.in_menu_template(template_name):\n                page.num_children_in_menu += 1\n        page.has_children_in_menu = page.num_children_in_menu > 0\n        page.branch_level = context[\"branch_level\"]\n        page.parent = parent_page\n        context[\"parent_page\"] = page.parent\n\n        # Prior to pages having the ``in_menus`` field, pages had two\n        # boolean fields ``in_navigation`` and ``in_footer`` for\n        # controlling menu inclusion. Attributes and variables\n        # simulating these are maintained here for backwards\n        # compatibility in templates, but will be removed eventually.\n        page.in_navigation = page.in_menu\n        page.in_footer = not (not page.in_menu and \"footer\" in template_name)\n        if page.in_navigation:\n            context[\"page_branch_in_navigation\"] = True\n        if page.in_footer:\n            context[\"page_branch_in_footer\"] = True\n\n    t = get_template(template_name)\n    return t.render(Context(context))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of all the models that subclass Page.", "response": "def models_for_pages(*args):\n    \"\"\"\n    Create a select list containing each of the models that subclass the\n    ``Page`` model.\n    \"\"\"\n    from warnings import warn\n    warn(\"template tag models_for_pages is deprectaed, use \"\n        \"PageAdmin.get_content_models instead\")\n    from yacms.pages.admin import PageAdmin\n    return PageAdmin.get_content_models()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_model_permissions(context, token):\n    model = context[token.split_contents()[1]]\n    opts = model._meta\n    perm_name = opts.app_label + \".%s_\" + opts.object_name.lower()\n    request = context[\"request\"]\n    setattr(model, \"perms\", {})\n    for perm_type in (\"add\", \"change\", \"delete\"):\n        model.perms[perm_type] = request.user.has_perm(perm_name % perm_type)\n    return \"\"", "response": "Assigns a permissions dict to the given model"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_page_permissions(context, token):\n    page = context[token.split_contents()[1]]\n    model = page.get_content_model()\n    try:\n        opts = model._meta\n    except AttributeError:\n        if model is None:\n            error = _(\"Could not load the model for the following page, \"\n                      \"was it removed?\")\n            obj = page\n        else:\n            # A missing inner Meta class usually means the Page model\n            # hasn't been directly subclassed.\n            error = _(\"An error occured with the following class. Does \"\n                      \"it subclass Page directly?\")\n            obj = model.__class__.__name__\n        raise ImproperlyConfigured(error + \" '%s'\" % obj)\n    perm_name = opts.app_label + \".%s_\" + opts.object_name.lower()\n    request = context[\"request\"]\n    setattr(page, \"perms\", {})\n    for perm_type in (\"add\", \"change\", \"delete\"):\n        perm = request.user.has_perm(perm_name % perm_type)\n        perm = perm and getattr(model, \"can_%s\" % perm_type)(request)\n        page.perms[perm_type] = perm\n    return \"\"", "response": "Assign a permissions dict to the given page instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, *args, **kwargs):\n        if kwargs.has_key('author'):\n            kwargs['created_by'] = kwargs['author']\n            kwargs['last_modified_by'] = kwargs['author']\n            del kwargs['author']\n        return super(CMSPageManager, self).create(*args, **kwargs)", "response": "Create a new CMS Page."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of all templates that can be used for CMS pages.", "response": "def get_template_options():\n        \"\"\"\n        Returns a list of all templates that can be used for CMS pages.\n        The paths that are returned are relative to TURRENTINE_TEMPLATE_ROOT.\n        \"\"\"\n        template_root = turrentine_settings.TURRENTINE_TEMPLATE_ROOT\n        turrentine_dir = turrentine_settings.TURRENTINE_TEMPLATE_SUBDIR\n        output = []\n        for root, dirs, files in os.walk(turrentine_dir):\n            for file_name in files: \n                full_path = os.path.join(root, file_name)\n                relative_path = os.path.relpath(full_path, template_root)\n                output.append(relative_path)\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlaunches an ssh shell", "response": "def launch_shell(username, hostname, password, port=22):\n    \"\"\"\n    Launches an ssh shell\n    \"\"\"\n    if not username or not hostname or not password:\n        return False\n\n    with tempfile.NamedTemporaryFile() as tmpFile:\n        os.system(sshCmdLine.format(password, tmpFile.name, username, hostname,\n                                    port))\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a MatchObject for the given key.", "response": "def _get_match(self, key):\n        \"\"\"\n        Gets a MatchObject for the given key.\n\n        Args:\n            key (str): Key of the property to look-up.\n\n        Return:\n            MatchObject: The discovered match.\n        \"\"\"\n\n        return self._get_string_match(key=key) or \\\n            self._get_non_string_match(key=key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_non_string_match(self, key):\n\n        expression = r'(?:\\s*)'.join([\n            '^',\n            'define',\n            r'\\(',\n            '\\'{}\\''.format(key),\n            ',',\n            r'(.*)',\n            r'\\)',\n            ';'\n        ])\n\n        pattern = re.compile(expression, re.MULTILINE)\n        return pattern.search(self._content)", "response": "Returns a MatchObject for the given key assuming a non - string value."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a MatchObject for the given key assuming a string value.", "response": "def _get_string_match(self, key):\n        \"\"\"\n        Gets a MatchObject for the given key, assuming a string value.\n\n        Args:\n            key (str): Key of the property to look-up.\n\n        Return:\n            MatchObject: The discovered match.\n        \"\"\"\n\n        expression = r'(?:\\s*)'.join([\n            '^',\n            'define',\n            r'\\(',\n            '\\'{}\\''.format(key),\n            ',',\n            r'\\'(.*)\\'',\n            r'\\)',\n            ';'\n        ])\n\n        pattern = re.compile(expression, re.MULTILINE)\n        return pattern.search(self._content)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_value_from_match(self, key, match):\n\n        value = match.groups(1)[0]\n        clean_value = str(value).lstrip().rstrip()\n\n        if clean_value == 'true':\n            self._log.info('Got value of \"%s\" as boolean true.', key)\n            return True\n\n        if clean_value == 'false':\n            self._log.info('Got value of \"%s\" as boolean false.', key)\n            return False\n\n        try:\n            float_value = float(clean_value)\n            self._log.info('Got value of \"%s\" as float \"%f\".',\n                           key,\n                           float_value)\n            return float_value\n        except ValueError:\n            self._log.info('Got value of \"%s\" as string \"%s\".',\n                           key,\n                           clean_value)\n            return clean_value", "response": "Gets the value of the property in the given MatchObject."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, key):\n\n        match = self._get_match(key=key)\n\n        if not match:\n            return None\n\n        return self._get_value_from_match(key=key, match=match)", "response": "Gets the value of the property of the given key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set(self, key, value):\n\n        match = self._get_match(key=key)\n\n        if not match:\n            self._log.info('\"%s\" does not exist, so it will be added.', key)\n\n            if isinstance(value, str):\n                self._log.info('\"%s\" will be added as a PHP string value.',\n                               key)\n                value_str = '\\'{}\\''.format(value)\n            else:\n                self._log.info('\"%s\" will be added as a PHP object value.',\n                               key)\n                value_str = str(value).lower()\n\n            new = 'define(\\'{key}\\', {value});'.format(\n                key=key,\n                value=value_str)\n\n            self._log.info('\"%s\" will be added as: %s', key, new)\n\n            replace_this = '<?php\\n'\n            replace_with = '<?php\\n' + new + '\\n'\n            self._content = self._content.replace(replace_this, replace_with)\n            self._log.info('Content string has been updated.')\n            return True\n\n        if self._get_value_from_match(key=key, match=match) == value:\n            self._log.info('\"%s\" is already up-to-date.', key)\n            return False\n\n        self._log.info('\"%s\" exists and will be updated.', key)\n\n        start_index = match.start(1)\n        end_index = match.end(1)\n\n        if isinstance(value, bool):\n            value = str(value).lower()\n            self._log.info('\"%s\" will be updated with boolean value: %s',\n                           key,\n                           value)\n        else:\n            self._log.info('\"%s\" will be updated with string value: %s',\n                           key,\n                           value)\n\n        start = self._content[:start_index]\n        end = self._content[end_index:]\n\n        self._content = start + value + end\n        return True", "response": "Updates the value of the given key in the loaded content string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_buildout_config(buildout_filename):\n    print(\"[localhost] get_buildout_config: {0:s}\".format(buildout_filename))\n    buildout = Buildout(buildout_filename, [('buildout', 'verbosity', '-100')])\n    while True:\n        try:\n            len(buildout.items())\n            break\n        except OSError:\n            pass\n    return buildout", "response": "Parse buildout config with zc. buildout ConfigParser\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning buildout parts matching the given query", "response": "def get_buildout_parts(buildout, query=None):\n    \"\"\"Return buildout parts matching the given query\n    \"\"\"\n    parts = names = (buildout['buildout'].get('parts') or '').split('\\n')\n    for name in names:\n        part = buildout.get(name) or {}\n        for key, value in (query or {}).items():\n            if value not in (part.get(key) or ''):\n                parts.remove(name)\n                break\n    return parts"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of buildout eggs matching the parts for the given query", "response": "def get_buildout_eggs(buildout, query=None):\n    \"\"\"Return buildout eggs matching the parts for the given query\n    \"\"\"\n    eggs = set()\n    for name in get_buildout_parts(buildout, query=query):\n        if name == 'buildout':\n            continue  # skip eggs from the buildout script itself\n        path = os.path.join(buildout['buildout'].get('bin-directory'), name)\n        if os.path.isfile(path):\n            eggs.update(parse_eggs_list(path))\n    return list(eggs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_eggs_list(path):\n    with open(path, 'r') as script:\n        data = script.readlines()\n        start = 0\n        end = 0\n        for counter, line in enumerate(data):\n            if not start:\n                if 'sys.path[0:0]' in line:\n                    start = counter + 1\n            if counter >= start and not end:\n                if ']' in line:\n                    end = counter\n        script_eggs = tidy_eggs_list(data[start:end])\n    return script_eggs", "response": "Parse eggs list from the script at the given path"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tidy_eggs_list(eggs_list):\n    tmp = []\n    for line in eggs_list:\n        line = line.lstrip().rstrip()\n        line = line.replace('\\'', '')\n        line = line.replace(',', '')\n        if line.endswith('site-packages'):\n            continue\n        tmp.append(line)\n    return tmp", "response": "Tidy the given eggs list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef download(self, filename=None):\n        tmp_file, f_suffix = download_file(self.url)\n        if not filename is None:\n            shutil.move(tmp_file, filename)\n            return filename\n        else:\n            return tmp_file", "response": "Download an attachment. The files are currently not cached since they\n        can be overwritten on the server.\n\n        Parameters\n        ----------\n        filename : string, optional\n            Optional name for the file on local disk.\n\n        Returns\n        -------\n        string\n            Path to downloaded temporary file on disk"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef attach_file(self, filename, resource_id=None):\n        # Use file base name as resource identifier if none given\n        if resource_id is None:\n            resource_id = os.path.basename(filename)\n        # Need to append resource identifier to base attachment Url\n        upload_url = self.links[REF_MODEL_RUN_ATTACHMENTS] + '/' + resource_id\n        # Upload model output\n        response = requests.post(\n            upload_url,\n            files={'file': open(filename, 'rb')}\n        )\n        if response.status_code != 200:\n            try:\n                raise ValueError(json.loads(response.text)['message'])\n            except KeyError as ex:\n                raise ValueError('invalid state change: ' + str(response.text))\n        # Returned refreshed verion of the handle\n        return self.refresh()", "response": "Uploads an attachment to the model run."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(url, model_id, name, arguments, properties=None):\n        # Create list of model run arguments. Catch TypeErrors if arguments is\n        # not a list.\n        obj_args = []\n        try:\n            for arg in arguments:\n                obj_args.append({'name' : arg, 'value' : arguments[arg]})\n        except TypeError as ex:\n            raise ValueError('invalid argument set')\n        # Create request body and send POST request to given Url\n        body = {\n            'model' : model_id,\n            'name' : name,\n            'arguments' : obj_args,\n        }\n        # Create list of properties if given.  Catch TypeErrors if properties is\n        # not a list.\n        if not properties is None:\n            obj_props = []\n            try:\n                for key in properties:\n                    if key != 'name':\n                        obj_props.append({'key':key, 'value':properties[key]})\n            except TypeError as ex:\n                raise ValueError('invalid property set')\n            body['properties'] =  obj_props\n        # POST create model run request\n        try:\n            req = urllib2.Request(url)\n            req.add_header('Content-Type', 'application/json')\n            response = urllib2.urlopen(req, json.dumps(body))\n        except urllib2.URLError as ex:\n            raise ValueError(str(ex))\n        # Get model run self reference from successful response\n        return references_to_dict(json.load(response)['links'])[REF_SELF]", "response": "Create a new model run using the given SCO - API create model run Url."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_state(url, state_obj):\n        # POST update run state request\n        try:\n            req = urllib2.Request(url)\n            req.add_header('Content-Type', 'application/json')\n            response = urllib2.urlopen(req, json.dumps(state_obj))\n        except urllib2.URLError as ex:\n            raise ValueError(str(ex))\n        # Throw exception if resource was unknown or update request failed\n        if response.code == 400:\n            raise ValueError(response.message)\n        elif response.code == 404:\n            raise ValueError('unknown model run')", "response": "Update the state of a given model run."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the state of the model run to active.", "response": "def update_state_active(self):\n        \"\"\"Update the state of the model run to active.\n\n        Raises an exception if update fails or resource is unknown.\n\n        Returns\n        -------\n        ModelRunHandle\n            Refreshed run handle.\n        \"\"\"\n        # Update state to active\n        self.update_state(self.links[REF_UPDATE_STATE_ACTIVE], {'type' : RUN_ACTIVE})\n        # Returned refreshed verion of the handle\n        return self.refresh()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_state_error(self, errors):\n        # Update state to active\n        self.update_state(\n            self.links[REF_UPDATE_STATE_ERROR],\n            {'type' : RUN_FAILED, 'errors' : errors}\n        )\n        # Returned refreshed verion of the handle\n        return self.refresh()", "response": "Updates the state of the run to FAILED. Expects a list of error messages. Raises an exception if update fails or resource is unknown."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the state of the model run to SUCCESS. Expects a model run output file. Will upload the file before changing the model run state. Raises an exception if the update fails.", "response": "def update_state_success(self, model_output):\n        \"\"\"Update the state of the model run to 'SUCCESS'. Expects a model\n        output result file. Will upload the file before changing the model\n        run state.\n\n        Raises an exception if update fails or resource is unknown.\n\n        Parameters\n        ----------\n        model_output : string\n            Path to model run output file\n\n        Returns\n        -------\n        ModelRunHandle\n            Refreshed run handle.\n        \"\"\"\n        # Upload model output\n        response = requests.post(\n            self.links[REF_UPDATE_STATE_SUCCESS],\n            files={'file': open(model_output, 'rb')}\n        )\n        if response.status_code != 200:\n            try:\n                raise ValueError(json.loads(response.text)['message'])\n            except ValueError as ex:\n                raise ValueError('invalid state change: ' + str(response.text))\n        # Returned refreshed verion of the handle\n        return self.refresh()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if the IAM credentials are ready to use.", "response": "def CirrusIamUserReady(iam_aws_id, iam_aws_secret):\n  \"\"\" Returns true if provided IAM credentials are ready to use. \"\"\"\n  is_ready = False\n  try:\n    s3 = core.CreateTestedS3Connection(iam_aws_id, iam_aws_secret)\n    if s3:\n      if core.CirrusAccessIdMetadata(s3, iam_aws_id).IsInitialized():\n        is_ready = True            \n  except boto.exception.BotoServerError as e:\n    print e \n    \n  return is_ready"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn true if IAM user initialization has completed.", "response": "def __IsInitialized(self):      \n    \"\"\" Returns true if IAM user initialization has completed. \"\"\"  \n    is_initialized = False\n    iam_id = self.GetAccessKeyId()\n    if iam_id:\n      if core.CirrusAccessIdMetadata(self.s3, iam_id).IsInitialized():\n        is_initialized = True\n    return is_initialized"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __WaitForCredentialsLive(self, iam_aws_id, iam_aws_secret):\n    print 'waiting for credentials to go live...'\n    for region in core.tested_region_names:\n      core.WaitForEc2Connection(iam_aws_id, iam_aws_secret, region)\n    core.WaitForS3Connection(iam_aws_id, iam_aws_secret)\n    \n    print 'done'\n    return", "response": "Wait until all new credentials are accepted in all regions and for S3 connections."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef AddNewVolumeToInstance(self, instance_id, vol_size_gb):\n    assert(vol_size_gb >= 1)\n    if vol_size_gb > 1000: # probably spending too much if you go bigger\n      raise RuntimeError('Adding volumes this large has not been tested.')\n    instance = self.__GetInstanceById(instance_id)\n    assert(instance)\n    # select an unused device\n    # see http://askubuntu.com/questions/47617/\n    # how-to-attach-new-ebs-volume-to-ubuntu-machine-on-aws\n    potential_device_names = ['/dev/xvdf',\n                              '/dev/xvdg',\n                              '/dev/xvdh', \n                              '/dev/xvdi']\n    device_name = None\n    for name in potential_device_names:\n      if not self.DeviceExists(name, instance):\n        device_name = name\n        break\n    if not device_name:\n      raise RuntimeError('No suitable device names available')\n    # Attach volume\n    volume = self.ec2.create_volume(vol_size_gb, instance.placement)\n    volume.attach(instance.id, device_name)\n    # wait for volume to attach\n    core.WaitForVolumeAttached(volume)\n    while not self.DeviceExists(device_name, instance):\n        logging.info( 'waiting for device to be attached...')\n        time.sleep(5)\n    assert(volume.id)\n    assert(volume.attach_data.device == device_name)\n    # format file system, mount the file system, update fstab to automount\n    hostname = instance.dns_name\n    add_ebs_volume_playbook = pkg_resources.resource_filename(__name__,\n      'ami/playbooks/workstation/add_ebs_volume.yml')\n    extra_vars = {}\n    extra_vars['volume_name'] = volume.id\n    extra_vars['volume_device'] = device_name\n    assert(core.RunPlaybookOnHost(add_ebs_volume_playbook, hostname, \n                                  self.ssh_key, extra_vars))      \n    return volume.id", "response": "Adds a new volume to an EC2 instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget all the instances in a group filtered by state.", "response": "def __GetInstances(self, group_name = None, state_filter=None):\n    \"\"\"\n    Get all the instances in a group, filtered by state.\n\n    @param group_name: the name of the group\n    @param state_filter: the state that the instance should be in\n      (e.g. \"running\"), or None for all states\n    \"\"\"\n    all_instances = self.ec2.get_all_instances()\n    instances = []\n    for res in all_instances:\n      for group in res.groups:\n        if group_name and group.name != group_name:\n          continue\n        for instance in res.instances:\n          if state_filter == None or instance.state == state_filter:\n            instances.append(instance)\n    return instances"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stage(self, name, clean=False):\n        '''\n        Switch stage\n\n        :param name:\n            Filename of new meta file. |filelocate|\n\n            * File must not already exist, will be created in 'data_dir' \\\n            from :func:`util.locations.get_locations`\n\n            * Can also be a full path to place it anywhere desired\n\n        :param clean: What to do with preexisting meta files?\n\n            * ``False``: Merge current meta with preexisting one\n            * ``True``: Replace preexisting meta with current one\n        '''\n\n        name = search_location(name, create_in='data_dir')\n        if not clean:\n            self.load('stage', name, merge=True)\n\n        self.__meta['header'].update({'stage': name})\n        self.log = shell_notify(\n            '%s stage' % ('new clean' if clean else 'loaded'),\n            more=dict(meta=name, clean=clean),\n            verbose=self.__verbose\n        )", "response": "Switches to the new meta file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(self, mkey, mdesc, mdict=None, merge=False):\n        '''\n        Loads a dictionary into current meta\n\n        :param mkey:\n            Type of data to load.\n            Is be used to reference the data from the 'header' within meta\n        :param mdesc:\n            Either filename of json-file to load or further description\n            of imported data when `mdict` is used\n        :param dict mdict:\n            Directly pass data as dictionary instead of\n            loading it from a json-file.\n            Make sure to set `mkey` and `mdesc` accordingly\n        :param merge:\n            Merge received data into current meta or place it\n            under 'import' within meta\n        :returns:\n            The loaded (or directly passed) content\n        '''\n\n        j = mdict if mdict else read_json(mdesc)\n        if j and isinstance(j, dict):\n            self.__meta['header'].update({mkey: mdesc})\n            if merge:\n                self.__meta = dict_merge(self.__meta, j)\n            else:\n                self.__meta['import'][mkey] = j\n            self.log = shell_notify(\n                'load %s data and %s it into meta' % (\n                    'got' if mdict else 'read',\n                    'merged' if merge else 'imported'\n                ),\n                more=dict(mkey=mkey, mdesc=mdesc, merge=merge),\n                verbose=self.__verbose\n            )\n        return j", "response": "Loads a dictionary into current meta or creates a new one if not already loaded"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the log of the current object.", "response": "def log(self, elem):\n        '''\n        .. seealso:: :attr:`log`\n        '''\n\n        if elem:\n            self.__meta['log'].update({get_timestamp(precice=True): elem})\n        mfile = self.__meta['header']['stage']\n\n        self.__lock.acquire()\n        try:\n            j = read_json(mfile)\n            if j != self.__meta:\n                write_json(mfile, self.__meta)\n        finally:\n            self.__lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_urls(self):\n        urls = super(FormAdmin, self).get_urls()\n        extra_urls = [\n            url(\"^(?P<form_id>\\d+)/entries/$\",\n                self.admin_site.admin_view(self.entries_view),\n                name=\"form_entries\"),\n            url(\"^file/(?P<field_entry_id>\\d+)/$\",\n                self.admin_site.admin_view(self.file_view),\n                name=\"form_file\"),\n        ]\n        return extra_urls + urls", "response": "Add the entries view to urls."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndisplay the form entries in a HTML table with option to export as CSV file.", "response": "def entries_view(self, request, form_id):\n        \"\"\"\n        Displays the form entries in a HTML table with option to\n        export as CSV file.\n        \"\"\"\n        if request.POST.get(\"back\"):\n            change_url = admin_url(Form, \"change\", form_id)\n            return HttpResponseRedirect(change_url)\n        form = get_object_or_404(Form, id=form_id)\n        entries_form = EntriesForm(form, request, request.POST or None)\n        delete_entries_perm = \"%s.delete_formentry\" % FormEntry._meta.app_label\n        can_delete_entries = request.user.has_perm(delete_entries_perm)\n        submitted = entries_form.is_valid()\n        if submitted:\n            if request.POST.get(\"export\"):\n                response = HttpResponse(content_type=\"text/csv\")\n                timestamp = slugify(datetime.now().ctime())\n                fname = \"%s-%s.csv\" % (form.slug, timestamp)\n                header = \"attachment; filename=%s\" % fname\n                response[\"Content-Disposition\"] = header\n                queue = StringIO()\n                delimiter = settings.FORMS_CSV_DELIMITER\n                try:\n                    csv = writer(queue, delimiter=delimiter)\n                    writerow = csv.writerow\n                except TypeError:\n                    queue = BytesIO()\n                    delimiter = bytes(delimiter, encoding=\"utf-8\")\n                    csv = writer(queue, delimiter=delimiter)\n                    writerow = lambda row: csv.writerow([c.encode(\"utf-8\")\n                        if hasattr(c, \"encode\") else c for c in row])\n                writerow(entries_form.columns())\n                for row in entries_form.rows(csv=True):\n                    writerow(row)\n                data = queue.getvalue()\n                response.write(data)\n                return response\n            elif request.POST.get(\"delete\") and can_delete_entries:\n                selected = request.POST.getlist(\"selected\")\n                if selected:\n                    entries = FormEntry.objects.filter(id__in=selected)\n                    count = entries.count()\n                    if count > 0:\n                        entries.delete()\n                        message = ungettext(\"1 entry deleted\",\n                                            \"%(count)s entries deleted\", count)\n                        info(request, message % {\"count\": count})\n        template = \"admin/forms/entries.html\"\n        context = {\"title\": _(\"View Entries\"), \"entries_form\": entries_form,\n                   \"opts\": self.model._meta, \"original\": form,\n                   \"can_delete_entries\": can_delete_entries,\n                   \"submitted\": submitted}\n        return render(request, template, context)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_user(self, user_id=None, user_name=None):\n\n        if user_id:\n            endpoint = '/api/user_id/{0}'.format(user_id)\n        elif user_name:\n            endpoint = '/api/user_name/{0}'.format(user_name)\n        else:\n            # Return currently authorized user\n            endpoint = '/api/user'\n\n        data = self._make_request(verb=\"GET\", endpoint=endpoint)\n\n        try:\n            return User.NewFromJSON(data)\n        except:\n            return data", "response": "Get a user object from the API."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a list of Shake objects for the currently authenticated user.", "response": "def get_user_shakes(self):\n        \"\"\" Get a list of Shake objects for the currently authenticated user.\n\n        Returns:\n            A list of Shake objects.\n        \"\"\"\n        endpoint = '/api/shakes'\n        data = self._make_request(verb=\"GET\", endpoint=endpoint)\n\n        shakes = [Shake.NewFromJSON(shk) for shk in data['shakes']]\n        return shakes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_shared_files_from_shake(self,\n                                    shake_id=None,\n                                    before=None,\n                                    after=None):\n        \"\"\"\n        Returns a list of SharedFile objects from a particular shake.\n\n        Args:\n            shake_id (int): Shake from which to get a list of SharedFiles\n            before (str): get 10 SharedFile objects before (but not including)\n                the SharedFile given by `before` for the given Shake.\n            after (str): get 10 SharedFile objects after (but not including)\n                the SharedFile give by `after' for the given Shake.\n\n        Returns:\n            List (list) of SharedFiles.\n        \"\"\"\n        if before and after:\n            raise Exception(\"You cannot specify both before and after keys\")\n\n        endpoint = '/api/shakes'\n\n        if shake_id:\n            endpoint += '/{0}'.format(shake_id)\n\n        if before:\n            endpoint += '/before/{0}'.format(before)\n        elif after:\n            endpoint += '/after/{0}'.format(after)\n\n        data = self._make_request(verb=\"GET\", endpoint=endpoint)\n        return [SharedFile.NewFromJSON(f) for f in data['sharedfiles']]", "response": "Returns a list of SharedFiles from a particular Shake."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a SharedFile object given by the sharekey.", "response": "def get_shared_file(self, sharekey=None):\n        \"\"\"\n        Returns a SharedFile object given by the sharekey.\n\n        Args:\n            sharekey (str): Sharekey of the SharedFile you want to retrieve.\n\n        Returns:\n            SharedFile\n        \"\"\"\n        if not sharekey:\n            raise Exception(\"You must specify a sharekey.\")\n        endpoint = '/api/sharedfile/{0}'.format(sharekey)\n        data = self._make_request('GET', endpoint)\n        return SharedFile.NewFromJSON(data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef like_shared_file(self, sharekey=None):\n\n        if not sharekey:\n            raise Exception(\n                \"You must specify a sharekey of the file you\"\n                \"want to 'like'.\")\n\n        endpoint = '/api/sharedfile/{sharekey}/like'.format(sharekey=sharekey)\n        data = self._make_request(\"POST\", endpoint=endpoint, data=None)\n\n        try:\n            sf = SharedFile.NewFromJSON(data)\n            sf.liked = True\n            return sf\n        except:\n            raise Exception(\"{0}\".format(data['error']))", "response": "'Like' a SharedFile. mlkshk doesn't allow you to unlike a\n        sharedfile, so this is ~~permanent~~.\n\n        Args:\n            sharekey (str): Sharekey for the file you want to 'like'.\n\n        Returns:\n            Either a SharedFile on success, or an exception on error."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_shared_file(self, sharekey=None):\n        endpoint = '/api/sharedfile/{sharekey}/save'.format(sharekey=sharekey)\n        data = self._make_request(\"POST\", endpoint=endpoint, data=None)\n\n        try:\n            sf = SharedFile.NewFromJSON(data)\n            sf.saved = True\n            return sf\n        except:\n            raise Exception(\"{0}\".format(data['error']))", "response": "Save a SharedFile to your Shake."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the 10 most recent files accepted by the magic file selection algorithm.", "response": "def get_magic_shake(self, before=None, after=None):\n        \"\"\"\n        From the API:\n\n        Returns the 10 most recent files accepted by the 'magic' file selection\n        algorithm. Currently any files with 10 or more likes are magic.\n\n        Returns:\n            List of SharedFile objects\n        \"\"\"\n        if before and after:\n            raise Exception(\"You cannot specify both before and after keys\")\n\n        endpoint = '/api/magicfiles'\n\n        if before:\n            endpoint += '/before/{key}'.format(key=before)\n        elif after:\n            endpoint += '/after/{key}'.format(key=after)\n\n        data = self._make_request(\"GET\", endpoint=endpoint)\n        return [SharedFile.NewFromJSON(sf) for sf in data['magicfiles']]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of comments on a SharedFile.", "response": "def get_comments(self, sharekey=None):\n        \"\"\"\n        Retrieve comments on a SharedFile\n\n        Args:\n            sharekey (str): Sharekey for the file from which you want to return\n                the set of comments.\n\n        Returns:\n            List of Comment objects.\n        \"\"\"\n        if not sharekey:\n            raise Exception(\n                \"You must specify a sharekey of the file you\"\n                \"want to 'like'.\")\n\n        endpoint = '/api/sharedfile/{0}/comments'.format(sharekey)\n\n        data = self._make_request(\"GET\", endpoint=endpoint)\n\n        return [Comment.NewFromJSON(c) for c in data['comments']]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nposting a comment on behalf of the current user to the SharedFile with the given sharekey.", "response": "def post_comment(self, sharekey=None, comment=None):\n        \"\"\"\n        Post a comment on behalf of the current user to the\n        SharedFile with the given sharekey.\n\n        Args:\n            sharekey (str): Sharekey of the SharedFile to which you'd like\n                to post a comment.\n            comment (str): Text of the comment to post.\n\n        Returns:\n            Comment object.\n        \"\"\"\n        endpoint = '/api/sharedfile/{0}/comments'.format(sharekey)\n\n        post_data = {'body': comment}\n\n        data = self._make_request(\"POST\", endpoint=endpoint, data=post_data)\n        return Comment.NewFromJSON(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupload an image to a specific shake.", "response": "def post_shared_file(self,\n                         image_file=None,\n                         source_link=None,\n                         shake_id=None,\n                         title=None,\n                         description=None):\n        \"\"\" Upload an image.\n\n        TODO:\n        Don't have a pro account to test (or even write) code to upload a\n        shared filed to a particular shake.\n\n        Args:\n            image_file (str): path to an image (jpg/gif) on your computer.\n            source_link (str): URL of a source (youtube/vine/etc.)\n            shake_id (int): shake to which to upload the file or\n                source_link [optional]\n            title (str): title of the SharedFile [optional]\n            description (str): description of the SharedFile\n\n        Returns:\n            SharedFile key.\n        \"\"\"\n        if image_file and source_link:\n            raise Exception('You can only specify an image file or '\n                            'a source link, not both.')\n        if not image_file and not source_link:\n            raise Exception('You must specify an image file or a source link')\n\n        content_type = self._get_image_type(image_file)\n\n        if not title:\n            title = os.path.basename(image_file)\n\n        f = open(image_file, 'rb')\n        endpoint = '/api/upload'\n\n        files = {'file': (title, f, content_type)}\n        data = self._make_request('POST', endpoint=endpoint, files=files)\n\n        f.close()\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the editable details of a SharedFile.", "response": "def update_shared_file(self,\n                           sharekey=None,\n                           title=None,\n                           description=None):\n        \"\"\"\n        Update the editable details (just the title and description) of a\n        SharedFile.\n\n        Args:\n            sharekey (str): Sharekey of the SharedFile to update.\n            title (Optional[str]): Title of the SharedFile.\n            description (Optional[str]): Description of the SharedFile\n\n        Returns:\n            SharedFile on success, 404 on Sharekey not found, 403 on\n            unauthorized.\n        \"\"\"\n        if not sharekey:\n            raise Exception(\n                \"You must specify a sharekey for the sharedfile\"\n                \"you wish to update.\")\n\n        if not (title or description):\n            raise Exception(\"You must specify a title or description.\")\n\n        post_data = {}\n\n        if title:\n            post_data['title'] = title\n        if description:\n            post_data['description'] = description\n\n        endpoint = '/api/sharedfile/{0}'.format(sharekey)\n\n        data = self._make_request('POST', endpoint=endpoint, data=post_data)\n\n        return SharedFile.NewFromJSON(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the modules directory.", "response": "def init(script=sys.argv[0], base='lib', append=True, ignore=['/','/usr'], realpath=False, pythonpath=False, throw=False):\n    \"\"\"\n    Parameters:\n        * `script`: Path to script file. Default is currently running script file\n        * `base`: Name of base module directory to add to sys.path. Default is \"lib\".\n        * `append`: Append module directory to the end of sys.path, or insert at the beginning? Default is to append.\n        * `ignore`: List of directories to ignore during the module search. Default is to ignore \"/\" and \"/usr\".\n        * `realpath`: Should symlinks be resolved first? Default is False.\n        * `pythonpath`: Should the modules directory be added to the PYTHONPATH environment variable? Default is False.\n        * `throw`: Should an exception be thrown if no modules directory was found? Default is False.\n    Returns:\n        * The path to the modules directory if it was found, otherwise None.\n    \"\"\"\n    if type(ignore) is str: ignore = [ignore]\n    script = os.path.realpath(script) if realpath else os.path.abspath(script)\n    path = os.path.dirname(script)\n\n    while os.path.dirname(path) != path and (path in ignore or not os.path.isdir(os.path.join(path, base))):\n        path = os.path.dirname(path)\n\n    modules_dir = os.path.join(path, base)\n    if path not in ignore and os.path.isdir(modules_dir):\n        if append: sys.path.append(modules_dir)\n        else: sys.path.insert(1, modules_dir)\n\n        if pythonpath:\n            if 'PYTHONPATH' not in os.environ: os.environ['PYTHONPATH'] = ''\n            if not append: os.environ['PYTHONPATH'] += modules_dir\n            if os.environ['PYTHONPATH'] != '': os.environ['PYTHONPATH'] += os.pathsep\n            if append: os.environ['PYTHONPATH'] += modules_dir\n        return modules_dir\n    elif throw:\n        raise Exception(\"Could not find modules directory {} relative to {}\" % (base, script))\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a vertex and update the attributes of the node.", "response": "def add_vertex(self, vertex, **attr):\r\n        \"\"\"\r\n        Add vertex and update vertex attributes\r\n        \"\"\"\r\n        self.vertices[vertex] = []\r\n        if attr:\r\n            self.nodes[vertex] = attr"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding an edge between vertices u and v and update edge attributes", "response": "def add_edge(self, u, v, **attr):\r\n        \"\"\"\r\n        Add an edge between vertices u and v and update edge attributes\r\n        \"\"\"\r\n        if u not in self.vertices:\r\n            self.vertices[u] = []\r\n        if v not in self.vertices:\r\n            self.vertices[v] = []\r\n        vertex = (u, v)\r\n        self.edges[vertex] = {}\r\n        if attr:\r\n            self.edges[vertex].update(attr)\r\n        self.vertices[u].append(v)\r\n        self.vertices[v].append(u)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_vertex(self, vertex):\r\n        try:\r\n            self.vertices.pop(vertex)\r\n        except KeyError:\r\n            raise GraphInsertError(\"Vertex %s doesn't exist.\" % (vertex,))\r\n        if vertex in self.nodes:\r\n            self.nodes.pop(vertex)\r\n        for element in self.vertices:\r\n            if vertex in self.vertices[element]:\r\n                self.vertices[element].remove(vertex)\r\n        edges = []  # List for edges that include vertex\r\n        for element in self.edges:\r\n            if vertex in element:\r\n                edges.append(element)\r\n        for element in edges:\r\n            del self.edges[element]", "response": "Removes a vertex from the graph."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove the edge between vertices u and v.", "response": "def remove_edge(self, u, v):\r\n        \"\"\"\r\n        Remove the edge between vertices u and v\r\n        \"\"\"\r\n        try:\r\n            self.edges.pop((u, v))\r\n        except KeyError:\r\n            raise GraphInsertError(\"Edge %s-%s doesn't exist.\" % (u, v))\r\n        self.vertices[u].remove(v)\r\n        self.vertices[v].remove(u)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the degree of a vertex.", "response": "def degree(self, vertex):\r\n        \"\"\"\r\n        Return the degree of a vertex\r\n        \"\"\"\r\n        try:\r\n            return len(self.vertices[vertex])\r\n        except KeyError:\r\n            raise GraphInsertError(\"Vertex %s doesn't exist.\" % (vertex,))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconsoling script for certify_int", "response": "def cli_certify_core_integer(\n    config, min_value, max_value, value,\n):\n    \"\"\"Console script for certify_int\"\"\"\n\n    def parser(v):\n        # Attempt a json/pickle decode:\n        try:\n            v = load_json_pickle(v, config)\n        except Exception:\n            pass\n\n        # Attempt a straight conversion to integer:\n        try:\n            return int(v)\n        except Exception as err:\n            six.raise_from(\n                CertifierTypeError(\n                    message='Not integer: {x}'.format(\n                        x=v,\n                    ),\n                    value=v,\n                ),\n                err,\n            )\n\n    execute_cli_command(\n        'integer',\n        config,\n        parser,\n        certify_int,\n        value[0] if value else None,\n        min_value=min_value,\n        max_value=max_value,\n        required=config['required'],\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses sub - arguments between [ and ] recursively.", "response": "def parse(argv, level=0):\n    \"\"\"\n    Parse sub-arguments between `[` and `]` recursively.\n\n    Examples\n    --------\n    ```\n    >>> argv = ['--foo', 'bar', '--buz', '[', 'qux', '--quux', 'corge', ']']\n    >>> subarg.parse(argv)\n    ['--foo', 'bar', '--buz', ['qux', '--quux', 'corge']]\n    ```\n\n    Parameters\n    ----------\n    argv : list of strings\n        list of arguments strings like `sys.argv`.\n\n    Returns\n    -------\n    nested list of arguments strings.\n    \"\"\"\n\n    nargs = []\n\n    for i in range(len(argv)):\n\n        if argv[i] == '[':\n            level += 1\n\n            if level == 1:\n                index = i + 1\n\n        elif argv[i] == ']':\n            level -= 1\n            sub = argv[index:i]\n\n            if level == 0:\n                nargs.append(parse(sub, level))\n\n        elif level == 0:\n            nargs.append(argv[i])\n\n    return nargs"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwarning about duplicate keys.", "response": "def _warn_dupkey(self, k):\n        \"\"\"\n        Really odd function - used to help ensure we actually warn for duplicate\n        keys.\n        \"\"\"\n        if self._privflags & PYCBC_CONN_F_WARNEXPLICIT:\n            warnings.warn_explicit(\n                'Found duplicate keys! {0}'.format(k), RuntimeWarning,\n                __file__, -1, module='couchbase_ffi.bucket', registry={})\n        else:\n            warnings.warn('Found duplicate keys!', RuntimeWarning)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_text(self, xml, name):\n        nodes = xml.getElementsByTagName(\"wp:comment_\" + name)[0].childNodes\n        accepted_types = [Node.CDATA_SECTION_NODE, Node.TEXT_NODE]\n        return \"\".join([n.data for n in nodes if n.nodeType in accepted_types])", "response": "Gets the element s text value from the XML object provided."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef handle_import(self, options):\n\n        url = options.get(\"url\")\n        if url is None:\n            raise CommandError(\"Usage is import_wordpress %s\" % self.args)\n        try:\n            import feedparser\n        except ImportError:\n            raise CommandError(\"Could not import the feedparser library.\")\n        feed = feedparser.parse(url)\n\n        # We use the minidom parser as well because feedparser won't\n        # interpret WXR comments correctly and ends up munging them.\n        # xml.dom.minidom is used simply to pull the comments when we\n        # get to them.\n        xml = parse(url)\n        xmlitems = xml.getElementsByTagName(\"item\")\n\n        for (i, entry) in enumerate(feed[\"entries\"]):\n            # Get a pointer to the right position in the minidom as well.\n            xmlitem = xmlitems[i]\n            content = linebreaks(self.wp_caption(entry.content[0][\"value\"]))\n\n            # Get the time struct of the published date if possible and\n            # the updated date if we can't.\n            pub_date = getattr(entry, \"published_parsed\", entry.updated_parsed)\n            if pub_date:\n                pub_date = datetime.fromtimestamp(mktime(pub_date))\n                pub_date -= timedelta(seconds=timezone)\n\n            # Tags and categories are all under \"tags\" marked with a scheme.\n            terms = defaultdict(set)\n            for item in getattr(entry, \"tags\", []):\n                terms[item.scheme].add(item.term)\n\n            if entry.wp_post_type == \"post\":\n                post = self.add_post(title=entry.title, content=content,\n                                     pub_date=pub_date, tags=terms[\"tag\"],\n                                     categories=terms[\"category\"],\n                                     old_url=entry.id)\n\n                # Get the comments from the xml doc.\n                for c in xmlitem.getElementsByTagName(\"wp:comment\"):\n                    name = self.get_text(c, \"author\")\n                    email = self.get_text(c, \"author_email\")\n                    url = self.get_text(c, \"author_url\")\n                    body = self.get_text(c, \"content\")\n                    pub_date = self.get_text(c, \"date_gmt\")\n                    fmt = \"%Y-%m-%d %H:%M:%S\"\n                    pub_date = datetime.strptime(pub_date, fmt)\n                    pub_date -= timedelta(seconds=timezone)\n                    self.add_comment(post=post, name=name, email=email,\n                                     body=body, website=url,\n                                     pub_date=pub_date)\n\n            elif entry.wp_post_type == \"page\":\n                old_id = getattr(entry, \"wp_post_id\")\n                parent_id = getattr(entry, \"wp_post_parent\")\n                self.add_page(title=entry.title, content=content,\n                              tags=terms[\"tag\"], old_id=old_id,\n                              old_parent_id=parent_id)", "response": "Handles the import wordpress command."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfilters a Wordpress Post for Image Captions and renders to match HTML.", "response": "def wp_caption(self, post):\n        \"\"\"\n        Filters a Wordpress Post for Image Captions and renders to\n        match HTML.\n        \"\"\"\n        for match in re.finditer(r\"\\[caption (.*?)\\](.*?)\\[/caption\\]\", post):\n            meta = '<div '\n            caption = ''\n            for imatch in re.finditer(r'(\\w+)=\"(.*?)\"', match.group(1)):\n                if imatch.group(1) == 'id':\n                    meta += 'id=\"%s\" ' % imatch.group(2)\n                if imatch.group(1) == 'align':\n                    meta += 'class=\"wp-caption %s\" ' % imatch.group(2)\n                if imatch.group(1) == 'width':\n                    width = int(imatch.group(2)) + 10\n                    meta += 'style=\"width: %spx;\" ' % width\n                if imatch.group(1) == 'caption':\n                    caption = imatch.group(2)\n            parts = (match.group(2), caption)\n            meta += '>%s<p class=\"wp-caption-text\">%s</p></div>' % parts\n            post = post.replace(match.group(0), meta)\n        return post"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the contents of a list of json objects and combines them into one large json object.", "response": "def read_emote_mappings(json_obj_files=[]):\n    \"\"\" Reads the contents of a list of files of json objects and combines\n    them into one large json object. \"\"\"\n    super_json = {}\n    for fname in json_obj_files:\n        with open(fname) as f:\n            super_json.update(json.loads(f.read().decode('utf-8')))\n    return super_json"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef shop(self, index):\n        return UserShopFront(self.usr, item.owner, item.id, str(item.price))", "response": "Returns the UserShopFront object for the indexed item"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef buy(self, index):\n        item = self.items[index]\n        us = UserShopFront(self.usr, item.owner, item.id, str(item.price))\n        us.load()\n        \n        if not item.name in us.inventory:\n            return False\n        \n        if not us.inventory[item.name].buy():\n            return False\n                \n        return True", "response": "Attempts to buy indexed item returns result\n           \n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a class - wide instance property with a thread - specific value.", "response": "def make_tls_property(default=None):\n    \"\"\"Creates a class-wide instance property with a thread-specific value.\"\"\"\n    class TLSProperty(object):\n        def __init__(self):\n            from threading import local\n            self.local = local()\n\n        def __get__(self, instance, cls):\n            if not instance:\n                return self\n            return self.value\n\n        def __set__(self, instance, value):\n            self.value = value\n\n        def _get_value(self):\n            return getattr(self.local, 'value', default)\n        def _set_value(self, value):\n            self.local.value = value\n        value = property(_get_value, _set_value)\n\n    return TLSProperty()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_domain_and_port(self):\n        host = self.request.get_host()\n        if ':' in host:\n            domain, port = host.split(':')\n        else:\n            domain = host\n            port = self.request.META.get('SERVER_PORT')\n        if self.SITE_ALIASES and domain in self.SITE_ALIASES:\n            domain = self.SITE_ALIASES[domain]\n        return (domain.lower(), port)", "response": "Returns the requested domain and port number."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef lookup(self):\n\n        # check to see if this hostname is actually a env hostname\n        if self.domain:\n            if self.subdomain:\n                self.domain_unsplit = '%s.%s' % (self.subdomain, self.domain)\n            else:\n                self.domain_unsplit = self.domain\n            self.domain_requested = self.domain_unsplit\n\n        # check cache\n        cache_key = 'site_id:%s' % self.domain_unsplit\n        site_id = cache.get(cache_key)\n        if site_id:\n            SITE_ID.value = site_id\n            try:\n                self.site = Site.objects.get(id=site_id)\n            except Site.DoesNotExist:\n                # This might happen if the Site object was deleted from the\n                # database after it was cached.  Remove from cache and act\n                # as if the cache lookup failed.\n                cache.delete(cache_key)\n            else:\n                return None\n\n        # check database\n        try:\n            self.site = Site.objects.get(domain=self.domain)\n        except Site.DoesNotExist:\n            return False\n        if not self.site:\n            return False\n\n        SITE_ID.value = self.site.pk\n        cache.set(cache_key, SITE_ID.value, 5*60)\n        return None", "response": "This method is used to lookup a Site object by domain and subdomain."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef theme_lookup(self):\n\n        # check cache\n        cache_key = 'theme:%s' % self.domain_unsplit\n        theme = cache.get(cache_key)\n        if theme:\n            THEME.value = theme\n            return None\n\n        # check database\n        if hasattr(self.site, 'themes'):\n            try:\n                themes = [theme.name for theme in self.site.themes.all()]\n                THEME.value = themes[0]\n                cache.set(cache_key, THEME.value, 5*60)\n            except:\n                return False\n        return None", "response": "Returns theme based on site."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search_evaluations(domain, **kwargs):\n    url = \"{}?{}\".format(IAS_PREFIX, urlencode(kwargs))\n    data = get_resource(url, domain)\n    evaluations = _json_to_evaluation(data)\n\n    return evaluations", "response": "Search for evaluations in a given domain."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert JSON data to an Evaluation object.", "response": "def _json_to_evaluation(data):\n    \"\"\"\n    Only keep the data for online evaluations.\n    Two scenarios for multiple instructors:\n    1) all of the co-instructors may be evaluated online as a group,\n       sharing the eval URL.\n    2) each co-instructor may be evaluated individually,\n       with separate eval URLs.\n    \"\"\"\n    if data is None:\n        return None\n\n    evaluations = []\n    collection_items = data.get('collection').get('items')\n    for item in collection_items:\n        item_meta = item.get('meta')\n        type = _get_item_type(item_meta)\n        if type == \"evaluation\":\n            delivery_data = item.get('data')\n\n            evaluation = Evaluation()\n            evaluation.domain = get_domain(item.get('href'))\n            evaluation.eval_status = \\\n                get_value_by_name(delivery_data, 'status')\n            evaluation.eval_open_date = get_open_date(delivery_data)\n            evaluation.eval_close_date = get_close_date(delivery_data)\n            evaluation.report_available_date = get_report_available_date(\n                delivery_data)\n            evaluation.eval_url = get_eval_url(item.get('links'))\n            evaluation.report_url = get_report_url(item.get('links'))\n            section, instructors, completion =\\\n                _get_child_items(_get_child_ids(item_meta),\n                                 collection_items)\n            evaluation.section_sln = get_section_sln(section)\n            evaluation.instructor_ids = instructors\n            evaluation.is_completed = get_is_complete(completion)\n            evaluation.response_rate = get_response_rate(delivery_data)\n            evaluation.delivery_method = get_value_by_name(\n                delivery_data, 'deliveryMethod')\n            evaluations.append(evaluation)\n\n    return evaluations"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef age(self, as_at_date=None):\n        if self.date_of_death != None or self.is_deceased == True:\n            return None\n\n        as_at_date = date.today() if as_at_date == None else as_at_date\n        \n        if self.date_of_birth != None:\n            if (as_at_date.month >= self.date_of_birth.month) and (as_at_date.day >= self.date_of_birth.day):\n                return (as_at_date.year - self.date_of_birth.year)\n            else:\n                return ((as_at_date.year - self.date_of_birth.year) -1)\n        else:\n            return None", "response": "Compute the person s age in the specified date."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef name(self):\n        if self.title in [\"DR\", \"SIR\", \"LORD\"]:\n            return \"%s %s %s\" % (self.get_title_display(), self.first_name, self.last_name)\n        else:\n            return \"%s %s\" % (self.first_name, self.last_name)", "response": "Return the person s name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef full_name(self):\n        return \"%s %s %s %s\" % (self.get_title_display(), \n                                self.first_name,\n                                self.other_names.replace(\",\", \"\"),\n                                self.last_name)", "response": "Return the title and full name of the entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(self, *args, **kwargs):\n        if self.date_of_death != None:\n            self.is_deceased = True\n            \n        # Since we often copy and paste names from strange sources, do some basic cleanup\n        self.first_name = self.first_name.strip()\n        self.last_name = self.last_name.strip()\n        self.other_names = self.other_names.strip()\n        \n        # Call save method\n        super(Person, self).save(*args, **kwargs)", "response": "Save the person in the database."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstore the state of the current credolib workspace in a pickle file.", "response": "def storedata(filename=None):\n    \"\"\"Store the state of the current credolib workspace in a pickle file.\"\"\"\n    if filename is None:\n        filename = 'credolib_state.pickle'\n    ns = get_ipython().user_ns\n    with open(filename, 'wb') as f:\n        d = {}\n        for var in ['_headers', '_loaders', '_data1d', '_data2d', '_data1dunited',\n                    'allsamplenames', '_headers_sample', 'badfsns', '_rowavg',\n                    'saveto_dir',\n                    'badfsns_datcmp', 'auximages_dir', 'subtractedsamplenames', 'outputpath', 'saveto_dir_rel',\n                    'auximages_dir_rel', 'crd_prefix']:\n            try:\n                d[var] = ns[var]\n            except KeyError:\n                warnings.warn('Skipping storage of unavailable variable \"%s\"' % var)\n        pickle.dump(d, f)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef restoredata(filename=None):\n    if filename is None:\n        filename = 'credolib_state.pickle'\n    ns = get_ipython().user_ns\n    with open(filename, 'rb') as f:\n        d = pickle.load(f)\n    for k in d.keys():\n        ns[k] = d[k]", "response": "Restore the state of the credolib workspace from a pickle file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef autocorrect(query, possibilities, delta=0.75):\n\n    # TODO: Make this way more robust and awesome using probability, n-grams?\n\n    possibilities = [possibility.lower() for possibility in possibilities]\n\n    # Don't waste time for exact matches\n    if query in possibilities:\n        return query\n\n    # Complete query as much as possible\n    options = [word for word in possibilities if word.startswith(query)]\n    if len(options) > 0:\n        possibilities = options\n        query = max_substring(options)\n\n    # Identify possible matches and return best match\n    matches = get_close_matches(query, possibilities, cutoff=delta)\n\n    # Raise error if no matches\n    try:\n        assert len(matches) > 0\n    except AssertionError:\n        raise AssertionError('No matches for \"{0}\" found'.format(query))\n\n    return matches[0]", "response": "Attempts to figure out what possibility the query is."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating the service files.", "response": "def generate(self, overwrite):\n        \"\"\"Generate service files.\n\n        This exposes several comforts.\n\n        `self.files` is a list into which all generated file paths will be\n        appended. It is later returned by `generate` to be consumed by any\n        program that wants to do something with it.\n\n        `self.templates` is the directory in which all templates are\n        stored. New init system implementations can use this to easily\n        pull template files.\n\n        `self.template_prefix` is a prefix for all template files.\n        Since all template files should be named\n        `<INIT_SYS_NAME>*`, this will basically just\n        provide the prefix before the * for you to use.\n\n        `self.generate_into_prefix` is a prefix for the path into which\n        files will be generated. This is NOT the destination path for the\n        file when deploying the service.\n\n        `self.overwrite` automatically deals with overwriting files so that\n        the developer doesn't have to address this. It is provided by the API\n        or by the CLI and propagated.\n        \"\"\"\n        self.files = []\n        tmp = utils.get_tmp_dir(self.init_system, self.name)\n        self.templates = os.path.join(os.path.dirname(__file__), 'templates')\n        self.template_prefix = self.init_system\n        self.generate_into_prefix = os.path.join(tmp, self.name)\n        self.overwrite = overwrite"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef status(self, **kwargs):\n        self.services = dict(\n            init_system=self.init_system,\n            services=[]\n        )", "response": "Retrieve the status of a service name or all services\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_file_from_template(self, template, destination):\n        # We cast the object to a string before passing it on as py3.x\n        # will fail on Jinja2 if there are ints/bytes (not strings) in the\n        # template which will not allow `env.from_string(template)` to\n        # take place.\n        templates = str(pkgutil.get_data(__name__, os.path.join(\n            'templates', template)))\n\n        pretty_params = json.dumps(self.params, indent=4, sort_keys=True)\n        self.logger.debug(\n            'Rendering %s with params: %s...', template, pretty_params)\n        generated = jinja2.Environment().from_string(\n            templates).render(self.params)\n        self.logger.debug('Writing generated file to %s...', destination)\n        self._should_overwrite(destination)\n        with open(destination, 'w') as f:\n            f.write(generated)\n        self.files.append(destination)", "response": "Generate a file from a Jinja2 template and writes it to the destination directory."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convert_value_to_es(value, ranges, obj, method=None):\n\n    def sub_convert(val):\n        \"\"\"\n        Returns the json value for a simple datatype or the subject uri if the\n        value is a rdfclass\n\n        args:\n            val: the value to convert\n        \"\"\"\n        if isinstance(val, BaseRdfDataType):\n            return val.to_json\n        elif isinstance(value, __MODULE__.rdfclass.RdfClassBase):\n            return val.subject.sparql_uri\n        return val\n\n    if method == \"missing_obj\":\n        rtn_obj = {\n            \"rdf_type\": [rng.sparql_uri for rng in ranges], # pylint: disable=no-member\n            \"label\": [getattr(obj, label)[0] \\\n                     for label in LABEL_FIELDS \\\n                     if hasattr(obj, label)][0]}\n        try:\n            rtn_obj['uri'] = value.sparql_uri\n            rtn_obj[\"rdfs_label\"] = NSM.nouri(value.sparql_uri)\n        except AttributeError:\n            rtn_obj['uri'] = \"None Specified\"\n            rtn_obj['rdfs_label'] = sub_convert(value)\n        rtn_obj['value'] = rtn_obj['rdfs_label']\n        return rtn_obj\n    return sub_convert(value)", "response": "Converts a value to an elasticsearch representation"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_idx_types(rng_def, ranges):\n    idx_types = rng_def.get('kds_esIndexType', []).copy()\n    if not idx_types:\n        nested = False\n        for rng in ranges:\n            if range_is_obj(rng, __MODULE__.rdfclass):\n                nested = True\n        if nested:\n            idx_types.append('es_Nested')\n    return idx_types", "response": "Returns the elasticsearch index types for the obj\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_prop_range_defs(class_names, def_list):\n\n    try:\n        cls_options = set(class_names + ['kdr_AllClasses'])\n        return [rng_def for rng_def in def_list \\\n                if not isinstance(rng_def, BlankNode) \\\n                and cls_options.difference(\\\n                        set(rng_def.get('kds_appliesToClass', []))) < \\\n                        cls_options]\n    except AttributeError:\n        return []", "response": "Filters the range defitions based on the bound classnames and the class_names list"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntesting to see if the class is an object or a litteral", "response": "def range_is_obj(rng, rdfclass):\n    \"\"\" Test to see if range for the class should be an object\n    or a litteral\n    \"\"\"\n    if rng == 'rdfs_Literal':\n        return False\n    if hasattr(rdfclass, rng):\n        mod_class = getattr(rdfclass, rng)\n        for item in mod_class.cls_defs['rdf_type']:\n            try:\n                if issubclass(getattr(rdfclass, item),\n                              rdfclass.rdfs_Literal):\n                    return False\n            except AttributeError:\n                pass\n        if isinstance(mod_class, rdfclass.RdfClassMeta):\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the value for an object that goes into the elacticsearch value field", "response": "def get_es_value(obj, def_obj):\n    \"\"\"\n    Returns the value for an object that goes into the elacticsearch 'value'\n    field\n\n    args:\n        obj: data object to update\n        def_obj: the class instance that has defintion values\n    \"\"\"\n    def get_dict_val(item):\n        \"\"\"\n        Returns the string representation of the dict item\n        \"\"\"\n        if isinstance(item, dict):\n            return str(item.get('value'))\n        return str(item)\n\n    value_flds = []\n    if def_obj.es_defs.get('kds_esValue'):\n        value_flds = def_obj.es_defs['kds_esValue'].copy()\n    else:\n        # pdb.set_trace()\n        value_flds = set(obj).difference(__ALL_IGN__)\n        value_flds = list(value_flds)\n    value_flds += __COMBINED__\n    try:\n        obj['value'] = [obj.get(label) for label in value_flds\n                        if obj.get(label)][0]\n    except IndexError:\n        obj['value'] = \", \".join([\"%s: %s\" % (value.get('label'),\n                                              value.get('value'))\n                                  for prop, value in obj.items()\n                                  if isinstance(value, dict) and \\\n                                  value.get('label')])\n\n    if isinstance(obj['value'], list):\n        obj['value'] = \", \".join([get_dict_val(item) for item in obj['value']])\n    else:\n        obj['value'] = get_dict_val(obj['value'])\n    if str(obj['value']).strip().endswith(\"/\"):\n        obj['value'] = str(obj['value']).strip()[:-1].strip()\n    if not obj['value']:\n        obj['value'] = obj.get('uri', '')\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_es_label(obj, def_obj):\n    label_flds = LABEL_FIELDS\n    if def_obj.es_defs.get('kds_esLabel'):\n        label_flds = def_obj.es_defs['kds_esLabel'] + LABEL_FIELDS\n    try:\n        for label in label_flds:\n            if def_obj.cls_defs.get(label):\n                 obj['label'] = def_obj.cls_defs[label][0]\n                 break\n        if not obj.get('label'):\n            obj['label'] = def_obj.__class__.__name__.split(\"_\")[-1]\n    except AttributeError:\n        # an attribute error is caused when the class is only\n        # an instance of the BaseRdfClass. We will search the rdf_type\n        # property and construct a label from rdf_type value\n        if def_obj.get('rdf_type'):\n            obj['label'] = def_obj['rdf_type'][-1].value[-1]\n        else:\n            obj['label'] = \"no_label\"\n    return obj", "response": "Returns object with label for an object that goes into the elacticsearch\n    field\naptcha"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the object updated with the id and uri fields for the elasticsearch document", "response": "def get_es_ids(obj, def_obj):\n    \"\"\"\n    Returns the object updated with the 'id' and 'uri' fields for the\n    elasticsearch document\n\n    args:\n        obj: data object to update\n        def_obj: the class instance that has defintion values\n    \"\"\"\n    try:\n        path = \"\"\n        for base in [def_obj.__class__] + list(def_obj.__class__.__bases__):\n\n            if hasattr(base, 'es_defs') and base.es_defs:\n                path = \"%s/%s/\" % (base.es_defs['kds_esIndex'][0],\n                                   base.es_defs['kds_esDocType'][0])\n                continue\n    except KeyError:\n        path = \"\"\n    if def_obj.subject.type == 'uri':\n        obj['uri'] = def_obj.subject.clean_uri\n        obj['id'] = path + make_es_id(obj['uri'])\n    elif def_obj.subject.type == 'bnode':\n        obj['id'] = path + def_obj.bnode_id()\n    else:\n        obj['id'] = path + make_es_id(str(obj['value']))\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate the id based off of the uri", "response": "def make_es_id(uri):\n    \"\"\"\n    Creates the id based off of the uri value\n\n    Args:\n    -----\n        uri: the uri to conver to an elasticsearch id\n    \"\"\"\n    try:\n        uri = uri.clean_uri\n    except AttributeError:\n        pass\n    return sha1(uri.encode()).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nplot background methods and S and B vs energy", "response": "def gp_background():\n    \"\"\" plot background methods and S/B vs energy \"\"\"\n    inDir, outDir = getWorkDirs()\n    data, REBIN = OrderedDict(), None\n    titles = [ 'SE_{+-}', 'SE@^{corr}_{/Symbol \\\\261\\\\261}', 'ME@^{N}_{+-}' ]\n    Apm = OrderedDict([\n        ('19', 0.026668), ('27', 0.026554), ('39', 0.026816), ('62', 0.026726)\n    ])\n    fake = np.array([[-1, 1, 0, 0, 0]])\n    lines = {'y=0.9': 'lc {} lt 2 lw 3'.format(default_colors[-4])}\n    for energy in ['19', '27', '39', '62']:\n        ekey = ' '.join([getEnergy4Key(energy), 'GeV'])\n        data[ekey] = [[], [], []]\n        for didx,dtype in enumerate(['epsPt', 'ngmPt_corr', 'epmPt']):\n            for idx,infile in enumerate(glob.glob(os.path.realpath(os.path.join(\n                inDir, 'rawdata', energy, 'pt-differential', '%s_*.dat' % dtype\n            )))):\n                file_url = os.path.realpath(os.path.join(inDir, infile))\n                data_import = np.loadtxt(open(file_url, 'rb'))\n                if REBIN is None: REBIN = int(data_import[-1][2]*2*1000) # MeV\n                data_import[:,4] = data_import[:,3]\n                data_import[:,(2,3)] = 0\n                if dtype == 'ngmPt_corr':\n                    data_import = data_import[data_import[:,0] <= 0.9]\n                if dtype == 'epmPt':\n                    data_import = data_import[data_import[:,0] > 0.9]\n                    data_import[:,(1,4)] *= Apm[energy]\n                col = colorscale(default_colors[didx], 1.+idx*0.2)\n                momrange =  os.path.basename(infile).split('_')[-1][:-4]\n                if idx < 1:\n                    data[ekey][0].append(fake)\n                    data[ekey][1].append('with lines lt 1 lw 5 lc %s' % col)\n                    data[ekey][2].append(titles[didx])\n                data[ekey][0].append(data_import)\n                data[ekey][1].append('lt 1 lw 3 lc %s pt 0' % col)\n                data[ekey][2].append('')\n    # unsubtracted background\n    make_panel(\n        name = '%s/methods' % outDir, dpt_dict = data,\n        xr = [0,3.35], yr = [0.9,2e5], ylog = True, lines = lines,\n        xlabel = 'dielectron invariant mass, M_{ee} (GeV/c^{2})',\n        ylabel = 'counts / %d MeV/c^{2}' % REBIN, layout = '2x2',\n        key = ['spacing 1.6', 'nobox'], gpcalls = ['boxwidth 0.002'],\n        labels = {\n            '{/=20 the lighter the color, the higher the p_{T}}': (1.5, 1e5)\n        }, key_subplot_id = 1,\n    )\n    return 'done'\n    # background ratio and acc.corr.\n    make_plot(\n        name = '%s/ratios%s' % (outDir, energy),\n        xr = [0,1.6], yr = [0.95,1.2],\n        data = graph_data[3:],\n        properties = [\n            'with filledcurves lt 1 lw 3 lc %s pt 0' % default_colors[i]\n            for i in xrange(2)\n        ],\n        titles = [\n            'SE_{/Symbol \\\\261\\\\261} / ME_{/Symbol \\\\261\\\\261}',\n            'f_{acc} = ME_{+-} / ME_{/Symbol \\\\261\\\\261}'\n        ],\n        xlabel = 'dielectron invariant mass, M_{ee} (GeV/c^{2})',\n        ylabel = '', key = [ 'width -2' ],\n        labels = { '%s GeV' % energy: (0.4, 0.97) }\n    )\n    # signal-to-background ratio in rho/omega region vs. energy\n    graph_data_sn = []\n    for infile in os.listdir(os.path.join(inDir, 'sn')):\n        energy = re.compile('\\d+').search(infile).group()\n        file_url = os.path.join(inDir, 'sn', infile)\n        data_import = np.loadtxt(open(file_url, 'rb'))\n        mask = (data_import[:,0] > 0.3) & (data_import[:,0] < 0.75)\n        data_import = data_import[mask]\n        weights = 1./data_import[:,3]\n        sn = np.average(data_import[:,1], weights = weights)\n        sn_err = np.average((data_import[:,1]-sn)**2, weights = weights)\n        graph_data_sn.append([float(getEnergy4Key(energy)), sn, 0, sn_err, 0])\n    graph_data_sn = np.array(graph_data_sn)\n    make_plot(\n        name = '%s/SNvsEnergy' % (outDir), xr = [15,210],\n        yr = [1e-3, .11], xlog = True, ylog = True,\n        data = [ np.array([[15,0.1,0,0,0],[210,0.1,0,0,0]]), graph_data_sn ],\n        properties = [\n            'with lines lt 2 lw 4 lc 0',\n            'lt 1 lw 3 lc %s pt 18 ps 2' % default_colors[0]\n        ],\n        titles = ['']*2,\n        xlabel = '{/Symbol \\326}s_{NN} (GeV)',\n        ylabel = 'S/B for 0.3 < M_{ee} < 0.75 GeV/c^{2}',\n        lmargin = 0.1, gpcalls = [\n            'nokey', 'format x \"%g\"',\n            'xtics (20,\"\" 30, 40,\"\" 50, 60,\"\" 70,\"\" 80,\"\" 90, 100, 200)',\n        ],\n        labels = { 'p+p': (100, 0.09) }\n    )\n    return 'done'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_ports(ports):\n    if '-' in ports:\n        # example: '10-15' at this point\n        start, stop = ports.split('-')\n        # start, stop = '10', '15'\n        # return range(10, 16) --> iter([10, 11, 12, 13, 14, 15])\n        return range(int(start), int(stop) + 1)\n    # Simply int each port that is split out:\n    # '10,11,12' --> ['10', '11', '12'] --> iter([10, 11, 12])\n    return (int(p) for p in ports.split(','))", "response": "Returns a list of tuples that can be used to create a new node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pyrdf(value, class_type=None, datatype=None, **kwargs):\n    if isinstance(value, BaseRdfDataType):\n        return value\n    if isinstance(value, dict):\n        value = value.copy()\n        class_type = value.pop('type')\n        try:\n            datatype = value.pop('datatype')\n        except KeyError:\n            datatype = __TYPE_MATCH__[class_type]\n        kwargs = value\n        value = kwargs.pop('value')\n    if not class_type:\n        class_type = 'literal'\n    if not datatype:\n        datatype = type(value)\n    try:\n        # print(\"pyrdf: \", value, \" class_type: \", class_type, \" datatype: \", datatype)\n        return __DT_LOOKUP__[class_type][datatype](value, **kwargs)\n    except KeyError:\n        rtn_val = BaseRdfDataType(value)\n        rtn_val.datatype = Uri(datatype)\n        return rtn_val", "response": "Coverts an input to one of the rdfdatatypes classes\n            class_type datatype lang"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _internal_add(self, other):\n        if hasattr(other, \"datatype\"):\n            if other.datatype == self.datatype:\n                rtn_val = self.value + other.value\n            else:\n                rtn_val = self.value + int(other.value)\n        else:\n            rtn_val = self.value + other\n        return XsdInteger(rtn_val)", "response": "Internal method to add the value of the object to the other object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _internal_sub(self, other, method=None):\n        if hasattr(other, \"datatype\"):\n            if other.datatype == self.datatype:\n                oval = other.value\n            else:\n                oval = int(other.value)\n        else:\n            oval = int(other)\n        if method == 'rsub':\n            rtn_val = oval - self.value\n        else:\n            rtn_val = self.value - oval\n        return XsdInteger(rtn_val)", "response": "Internal method for subtracting the value of this object from the other object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nusing for specifing addition methods for __add__, __iadd__, __radd__", "response": "def _internal_add(self, other):\n        \"\"\" Used for specifing addition methods for\n           __add__, __iadd__, __radd__\n        \"\"\"\n        if hasattr(other, \"datatype\"):\n            if other.datatype == \"xsd:decimal\":\n                rtn_val = self.value + Decimal(str(other.value))\n            else:\n                rtn_val = self.value + Decimal(str(other.value))\n        else:\n            rtn_val = self.value + Decimal(str(other))\n        return XsdDecimal(str(float(rtn_val)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_version():\n    with open('sj.py') as source:\n        for node in ast.walk(ast.parse(source.read(), 'sj.py')):\n            if node.__class__.__name__ == 'Assign' and \\\n               node.targets[0].__class__.__name__ == 'Name' and \\\n               node.targets[0].id == '__version__':\n                return node.value.s", "response": "Get the version from the source but without importing it."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _init_field(self, setting, field_class, name, code=None):\n        kwargs = {\n            \"label\": setting[\"label\"] + \":\",\n            \"required\": setting[\"type\"] in (int, float),\n            \"initial\": getattr(settings, name),\n            \"help_text\": self.format_help(setting[\"description\"]),\n        }\n        if setting[\"choices\"]:\n            field_class = forms.ChoiceField\n            kwargs[\"choices\"] = setting[\"choices\"]\n        field_instance = field_class(**kwargs)\n        code_name = ('_modeltranslation_' + code if code else '')\n        self.fields[name + code_name] = field_instance\n        css_class = field_class.__name__.lower()\n        field_instance.widget.attrs[\"class\"] = css_class\n        if code:\n            field_instance.widget.attrs[\"class\"] += \" modeltranslation\"", "response": "Initialize a field whether it is built with a custom name for a specific translation language or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save(self):\n        active_language = get_language()\n        for (name, value) in self.cleaned_data.items():\n            if name not in registry:\n                name, code = name.rsplit('_modeltranslation_', 1)\n            else:\n                code = None\n            setting_obj, created = Setting.objects.get_or_create(name=name)\n            if settings.USE_MODELTRANSLATION:\n                if registry[name][\"translatable\"]:\n                    try:\n                        activate(code)\n                    except:\n                        pass\n                    finally:\n                        setting_obj.value = value\n                        activate(active_language)\n                else:\n                    # Duplicate the value of the setting for every language\n                    for code in OrderedDict(settings.LANGUAGES):\n                        setattr(setting_obj,\n                                build_localized_fieldname('value', code),\n                                value)\n            else:\n                setting_obj.value = value\n            setting_obj.save()", "response": "Save each of the settings to the DB."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef format_help(self, description):\n        for bold in (\"``\", \"*\"):\n            parts = []\n            if description is None:\n                description = \"\"\n            for i, s in enumerate(description.split(bold)):\n                parts.append(s if i % 2 == 0 else \"<b>%s</b>\" % s)\n            description = \"\".join(parts)\n        description = urlize(description, autoescape=False)\n        return mark_safe(description.replace(\"\\n\", \"<br>\"))", "response": "Format the setting s description into HTML."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pdmerge_respeta_tz(func_merge, tz_ant=None, *args, **kwargs):\n    df_merged = func_merge(*args, **kwargs)\n    if tz_ant is not None and tz_ant != df_merged.index.tz:\n        # print_warn('Error pandas: join prevProg + demandaGeneracion pierde timezone (%s->%s)'\n        #            % (data_import[KEYS_DATA[0]].index.tz, tz_ant))\n        df_merged.index = df_merged.index.tz_convert(tz_ant)\n    return df_merged", "response": "puntero a funci\u00f3n de pandas merge_respeta_tz para pandas"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef merge_data(lista_dfs_o_dict, keys_merge=None):\n\n    def _merge_lista(lista_dfs):\n        if len(lista_dfs) == 2 and lista_dfs[0].index[-1] == lista_dfs[1].index[-1]:\n            df0 = lista_dfs[0]\n            df0.update(lista_dfs[1])\n        elif ((all([len(df_i) == 1 for df_i in lista_dfs])) or\n                (type(lista_dfs[0].index.freq) is Day and len(lista_dfs_o_dict) > 2)):\n            df0 = pd.DataFrame(pd.concat(lista_dfs))\n            if lista_dfs[0].index.freq and df0.index.freq is None:\n                df0.index.freq = lista_dfs[0].index.freq\n        else:\n            df0 = lista_dfs[0]\n            for df1 in lista_dfs[1:]:\n                df0 = df0.combine_first(df1)\n        return df0\n\n    if len(lista_dfs_o_dict) > 0 and type(lista_dfs_o_dict[0]) is dict:\n        if keys_merge is None:\n            keys_merge = lista_dfs_o_dict[0].keys()\n        dict_merge = dict()\n        for k in keys_merge:\n            lista_k = sorted([d[k] for d in lista_dfs_o_dict if (d is not None) and (d[k] is not None)],\n                             key=lambda item: item.index[0])\n            try:\n                dict_merge[k] = pdmerge_respeta_tz(_merge_lista, lista_k[0].index.tz, lista_k)\n            except AttributeError:\n                print('ERROR!')\n                dict_merge[k] = pdmerge_respeta_tz(_merge_lista, None, lista_k)\n        return dict_merge\n    elif len(lista_dfs_o_dict) > 0:\n        try:\n            lista_merge = sorted(lista_dfs_o_dict, key=lambda item: item.index[0])\n            return pdmerge_respeta_tz(_merge_lista, lista_merge[0].index.tz, lista_merge)\n        except AttributeError:\n            lista_dfs_o_dict = [l for l in lista_dfs_o_dict if l is not None]\n            if len(lista_dfs_o_dict) > 0:\n                lista_merge = sorted(lista_dfs_o_dict, key=lambda item: item.index[0])\n                return pdmerge_respeta_tz(_merge_lista, lista_merge[0].index.tz, lista_merge)\n        except TypeError as e:\n            print(e, e.__class__)\n            print(lista_dfs_o_dict)\n    return None", "response": "Merge dataframes in a lista de pandas DataFrame s."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bestfit_func(self, bestfit_x):\n        bestfit_x = np.array(bestfit_x)\n        if not self.done_bestfit:\n            raise KeyError(\"Do do_bestfit first\")\n        bestfit_y = 0\n        for idx, val in enumerate(self.fit_args):\n            bestfit_y += val * (bestfit_x **\n                                (self.args.get(\"degree\", 1) - idx))\n        return bestfit_y", "response": "Returns the bestfit y value for a given array of resources."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef login(request, template=\"accounts/account_login.html\",\n          form_class=LoginForm, extra_context=None):\n    \"\"\"\n    Login form.\n    \"\"\"\n    form = form_class(request.POST or None)\n    if request.method == \"POST\" and form.is_valid():\n        authenticated_user = form.save()\n        info(request, _(\"Successfully logged in\"))\n        auth_login(request, authenticated_user)\n        return login_redirect(request)\n    context = {\"form\": form, \"title\": _(\"Log in\")}\n    context.update(extra_context or {})\n    return TemplateResponse(request, template, context)", "response": "Log in the user."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef logout(request):\n    auth_logout(request)\n    info(request, _(\"Successfully logged out\"))\n    return redirect(next_url(request) or get_script_prefix())", "response": "Log the user out."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nviews for the link in verification email sent to a new user and is_active set to True. Activates the user and logs them in and redirects to the URL they tried to access when signing up.", "response": "def signup_verify(request, uidb36=None, token=None):\n    \"\"\"\n    View for the link in the verification email sent to a new user\n    when they create an account and ``ACCOUNTS_VERIFICATION_REQUIRED``\n    is set to ``True``. Activates the user and logs them in,\n    redirecting to the URL they tried to access when signing up.\n    \"\"\"\n    user = authenticate(uidb36=uidb36, token=token, is_active=False)\n    if user is not None:\n        user.is_active = True\n        user.save()\n        auth_login(request, user)\n        info(request, _(\"Successfully signed up\"))\n        return login_redirect(request)\n    else:\n        error(request, _(\"The link you clicked is no longer valid.\"))\n        return redirect(\"/\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef profile_update(request, template=\"accounts/account_profile_update.html\",\n                   extra_context=None):\n    \"\"\"\n    Profile update form.\n    \"\"\"\n    profile_form = get_profile_form()\n    form = profile_form(request.POST or None, request.FILES or None,\n                        instance=request.user)\n    if request.method == \"POST\" and form.is_valid():\n        user = form.save()\n        info(request, _(\"Profile updated\"))\n        try:\n            return redirect(\"profile\", username=user.username)\n        except NoReverseMatch:\n            return redirect(\"profile_update\")\n    context = {\"form\": form, \"title\": _(\"Update Profile\")}\n    context.update(extra_context or {})\n    return TemplateResponse(request, template, context)", "response": "View for updating a profile."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the SHA a branch points to.", "response": "def get_branch_sha(profile, name):\n    \"\"\"Get the SHA a branch's HEAD points to.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        name\n            The name of the branch.\n\n    Returns:\n        The requested SHA.\n\n    \"\"\"\n    ref = \"heads/\" + name\n    data = refs.get_ref(profile, ref)\n    head = data.get(\"head\")\n    sha = head.get(\"sha\")\n    return sha"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_branch(profile, name):\n    ref = \"heads/\" + name\n    data = refs.get_ref(profile, ref)\n    return data", "response": "Fetch a branch.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        name\n            The name of the branch to fetch.\n\n    Returns:\n        A dict with data baout the branch."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a branch. Args: profile A profile generated from ``simplygithub.authentication.profile``. Such profiles tell this module (i) the ``repo`` to connect to, and (ii) the ``token`` to connect with. name The name of the new branch. branch_off The name of a branch to create the new branch off of. Returns: A dict with data about the new branch.", "response": "def create_branch(profile, name, branch_off):\n    \"\"\"Create a branch.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        name\n            The name of the new branch.\n\n        branch_off\n            The name of a branch to create the new branch off of.\n\n    Returns:\n        A dict with data about the new branch.\n\n    \"\"\"\n    branch_off_sha = get_branch_sha(profile, branch_off)\n    ref = \"heads/\" + name\n    data = refs.create_ref(profile, ref, branch_off_sha)\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_branch(profile, name, sha):\n    ref = \"heads/\" + name\n    data = refs.update_ref(profile, ref, sha)\n    return data", "response": "Move a branch s HEAD to a new SHA."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete a branch. Args: profile A profile generated from ``simplygithub.authentication.profile``. Such profiles tell this module (i) the ``repo`` to connect to, and (ii) the ``token`` to connect with. name The name of the branch to delete. Returns: The response of the DELETE request.", "response": "def delete_branch(profile, name):\n    \"\"\"Delete a branch.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        name\n            The name of the branch to delete.\n\n    Returns:\n        The response of the DELETE request.\n\n    \"\"\"\n    ref = \"heads/\" + name\n    data = refs.delete_ref(profile, ref)\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge(profile, branch, merge_into):\n    data = merges.merge(profile, branch, merge_into)\n    return data", "response": "Merge a branch into another branch."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if there are callbacks attached to the specified event name.", "response": "def has_callbacks(self, name):\n        \"\"\"\n        Returns True if there are callbacks attached to the specified\n        event name.\n\n        Returns False if not\n        \"\"\"\n        r = self.event_listeners.get(name)\n        if not r:\n            return False\n        return len(r) > 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a callback to the event specified by name", "response": "def on(self, name, callback, once=False):\n        \"\"\"\n        Adds a callback to the event specified by name\n\n        once <bool> if True the callback will be removed once it's been\n        triggered\n        \"\"\"\n        if name not in self.event_listeners:\n            self.event_listeners[name] = []\n\n        self.event_listeners[name].append((callback, once))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves a callback to the event specified by name.", "response": "def off(self, name, callback, once=False):\n        \"\"\"\n        Removes callback to the event specified by name\n        \"\"\"\n\n        if name not in self.event_listeners:\n            return\n\n        self.event_listeners[name].remove((callback, once))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntriggers the event specified by name and passes self in keyword argument event_origin", "response": "def trigger(self, name, *args, **kwargs):\n        \"\"\"\n        Triggers the event specified by name and passes\n        self in keyword argument \"event_origin\"\n\n        All additional arguments and keyword arguments are passed\n        through as well\n        \"\"\"\n\n        mark_remove = []\n        for callback, once in self.event_listeners.get(name, []):\n            callback(event_origin=self, *args, **kwargs)\n            if once:\n                mark_remove.append( (callback, once) )\n\n        for callback, once in mark_remove:\n            self.off(name, callback, once=once)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def get_departures(self):\n        from .common import CommonFunctions\n        common = CommonFunctions(self.loop, self.session)\n        departures = []\n        endpoint = '{}/StopVisit/GetDepartures/{}'.format(BASE_URL,\n                                                          str(self.stopid))\n        data = await common.api_call(endpoint)\n        for entries in data or []:\n            try:\n                data = entries['MonitoredVehicleJourney']\n                if self.destination is not None:\n                    if data['DestinationName'] == self.destination:\n                        data = entries['MonitoredVehicleJourney']\n                        line = data['LineRef']\n                        destinationname = data['DestinationName']\n                        monitored = data['MonitoredCall']\n                        time = monitored['ExpectedDepartureTime']\n                        departures.append({\"time\": time,\n                                           \"line\": line,\n                                           \"destination\": destinationname})\n                else:\n                    data = entries['MonitoredVehicleJourney']\n                    line = data['LineRef']\n                    destinationname = data['DestinationName']\n                    monitored = data['MonitoredCall']\n                    time = monitored['ExpectedDepartureTime']\n                    departures.append({\"time\": time,\n                                       \"line\": line,\n                                       \"destination\": destinationname})\n            except (TypeError, KeyError, IndexError) as error:\n                LOGGER.error('Error connecting to Ruter, %s', error)\n        self._departures = await common.sort_data(departures, 'time')", "response": "Get departure info from stopid."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a list of final destinations for a stop.", "response": "async def get_final_destination(self):\n        \"\"\"Get a list of final destinations for a stop.\"\"\"\n        dest = []\n        await self.get_departures()\n        for departure in self._departures:\n            dep = {}\n            dep['line'] = departure.get('line')\n            dep['destination'] = departure.get('destination')\n            dest.append(dep)\n        return [dict(t) for t in {tuple(d.items()) for d in dest}]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef resolve_name(name, module=None):\n    parts = name.split('.')\n    parts_copy = parts[:]\n    if module is None:\n        while parts_copy:  # pragma: no cover\n            try:\n                module = __import__('.'.join(parts_copy))\n                break\n            except ImportError:\n                del parts_copy[-1]\n                if not parts_copy:\n                    raise\n        parts = parts[1:]\n    obj = module\n    for part in parts:\n        obj = getattr(obj, part)\n    return obj", "response": "Resolve a dotted name to a module and its parts. This is stolen\n    wholesale from unittest. TestLoader. loadTestByName."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall when an SSHClient receives a server key for a server that doesn t have a known host key.", "response": "def missing_host_key(self, client, hostname, key):\n        \"\"\"\n        Called when an `.SSHClient` receives a server key for a server that\n        isn't in either the system or local `.HostKeys` object.  To accept\n        the key, simply return.  To reject, raised an exception (which will\n        be passed to the calling application).\n        \"\"\"\n        self.host_key = key.get_base64()\n        print(\"Fetched key is: %s\" % self.host_key)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef repeat_masker_iterator(fh, alignment_index=None,\n                           header=True, verbose=False):\n  \"\"\"\n  Iterator for repeatmasker coordinate annotation files. These files describe\n  the location of repeat occurrences. There is (optionally) a two-line header\n  with the names of the fields (ignored by the iterator, if present). Each line\n  is a record of an occurrence. The description of fields for each line is\n  given in from_repeat_masker_string.\n\n  :param fh:              stream-like object, or string filename, to load the\n                          annotations from\n  :param alignment_index: an IndexedFile for full alignments; keys should be\n                          repeat-masker IDs\n  :param header:          if True, expect and discard the two-line header;\n                          otherwise we will expect there is no header\n  :param verbose:         if True, output additional status messages about\n                          progress to stderr.\n  \"\"\"\n\n  strm = fh\n  if type(fh).__name__ == \"str\":\n    strm = open(fh)\n\n  # try to get an idea of how much data we have...\n  if verbose:\n    try:\n      total = os.path.getsize(strm.name)\n      pind = ProgressIndicator(totalToDo=total, messagePrefix=\"completed\",\n                               messageSuffix=\"of processing \" + strm.name)\n    except AttributeError as e:\n      sys.stderr.write(str(e))\n      sys.stderr.write(\"completed [unknown] of processing index\")\n      verbose = False\n\n  if header:\n    # chomp first 2 lines\n    next(strm)\n    next(strm)\n\n  for line in strm:\n    if verbose:\n      pind.done = strm.tell()\n      pind.showProgress()\n\n    line = line.strip()\n    if line == \"\":\n      continue\n    rto = retrotransposon.from_repeat_masker_string(line)\n    if alignment_index is not None:\n      rto.pairwise_alignment =\\\n          JustInTimePairwiseAlignment(alignment_index, rto.uniq_id)\n    yield rto", "response": "Iterator for repeat - masker coordinate annotation files."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef detect_mobile(view):\n\n    @wraps(view)\n    def detected(request, *args, **kwargs):\n        MobileDetectionMiddleware.process_request(request)\n        return view(request, *args, **kwargs)\n    detected.__doc__ = '%s\\n[Wrapped by detect_mobile which detects if the request is from a phone]' % view.__doc__\n    return detected", "response": "Decorator that detects if the request is from a small - screen device such as a small - screen device or a PDA."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef masked(a, b):\n\n    if np.any([a.dtype.kind.startswith(c) for c in ['i', 'u', 'f', 'c']]):\n        n = np.array([np.nan for i in range(len(a))])\n    else:\n        n = np.array([None for i in range(len(a))])\n        # a = a.astype(object)\n    return np.where(b, a, n)", "response": "Return a numpy array with values from a where elements in b are not False. Populate with numpy. nan where b is False."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmasking the parts in b being True but does not meet the duration rules. Return an updated copy of b with True or False elements.", "response": "def duration_bool(b, rule, samplerate=None):\n    \"\"\"\n    Mask the parts in b being True but does not meet the duration\n    rules. Return an updated copy of b.\n\n    b: 1d array with True or False elements.\n\n    rule: str\n        The rule including the string 'dur' to be evaled.\n\n    samplerate: None or float\n        Has an effect on the result.\n\n    For each part of b that is True, a variable ``dur`` is set to the\n    count of elements, or the result of (len(part) / samplerate). And then\n    eval is called on the rule.\n\n    \"\"\"\n    if rule is None:\n        return b\n\n    slicelst = slicelist(b)\n    b2 = np.array(b)\n\n    if samplerate is None:\n        samplerate = 1.0\n\n    for sc in slicelst:\n        dur = (sc.stop - sc.start) / samplerate  # NOQA\n        if not eval(rule):\n            b2[sc] = False\n\n    return b2"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef startstop_bool(pack):\n    b_TRUE = np.ones(pack.rec_cnt) == True  # NOQA\n\n    start_list = pack.conconf.conditions_list('startcond')\n    stop_list = pack.conconf.conditions_list('stopcond')\n\n    # Pre-check:\n    runflag = 'startstop'\n    if not start_list and not stop_list:\n        return b_TRUE\n    elif not start_list:\n        runflag = 'stoponly'\n    elif not stop_list:\n        runflag = 'start_only'\n\n    # startb:\n    if runflag == 'stoponly':\n        # all False (dummy assignment)\n        startb = b_TRUE == False  # NOQA\n    else:\n        startb = b_TRUE\n        for cond in start_list:\n            startb = startb & pack._mask_array(cond)\n\n    # stopb:\n    if runflag == 'startonly':\n        # all False (dummy assignment)\n        stopb = b_TRUE == False  # NOQA\n    else:\n        stopb = b_TRUE\n        for cond in stop_list:\n            stopb = stopb & pack._mask_array(cond)\n\n    stopextend = pack.conconf.get_stopextend()\n\n    return _startstop_bool(startb, stopb, runflag, stopextend)", "response": "Make a bool array based on start and stop conditions."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _startstop_bool(startb, stopb, runflag, stopextend):\n    # All false at start\n    res = np.zeros(len(startb)) == True  # NOQA\n\n    start_slices = slicelist(startb)\n    stop_slices = slicelist(stopb)\n\n    # Special case when there is a start but no stop slice or vice versa:\n    # if start_slices and not stop_slices:\n    if runflag == 'startonly':\n        try:\n            start = start_slices[0]\n            # Make True from first start and rest of array.\n            res[start.start:] = True\n            return res\n        except IndexError:\n            # Only start specified but no start condition\n            # fullfilled. Return all False.\n            return res\n\n    elif runflag == 'stoponly':\n        try:\n            stop = stop_slices[0]\n            res[:stop.start + stopextend] = True  # Make True up to first stop.\n            return res\n        except IndexError:\n            # Only stop specified but no stop condition fullfilled\n            # Return all True\n            return res == False  # NOQA\n\n    stop = slice(0, 0)           # For first check\n    start = slice(0, 0)          # For a possibly empty list start_slices.\n    for start in start_slices:\n        if start.start < stop.start:\n            continue\n        for stop in stop_slices:\n            if stop.start > start.start:\n                res[start.start: stop.start + stopextend] = True\n                break           # Next start\n        else:\n            # On a given start slice, the entire list of stop slices was\n            # exhausted, none being later than the given start. It must mean\n            # that from this given start, the rest is to be True:\n            break\n\n    # There was no stop for the last start in loop\n    if start.start > stop.start:\n        res[start.start:] = True\n\n    return res", "response": "Return boolean array based on start and stop conditions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nproduce a list of slices given the boolean array b. Start and stop in each slice describe the True sections in b.", "response": "def slicelist(b):\n    \"\"\"Produce a list of slices given the boolean array b.\n\n    Start and stop in each slice describe the True sections in b.\"\"\"\n\n    slicelst = []\n    started = False\n    for i, e in enumerate(b):\n        if e and not started:\n            start = i\n            started = True\n        elif not e and started:\n            slicelst.append(slice(start, i))\n            started = False\n\n    if e:\n        slicelst.append(slice(start, i + 1))  # True in the end.\n\n    return slicelst"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set( string, target_level, indent_string=\"    \", indent_empty_lines=False ):\r\n\r\n    lines = string.splitlines()\r\n    set_lines( lines, target_level, indent_string=indent_string, indent_empty_lines=indent_empty_lines )\r\n    result = \"\\n\".join(lines)\r\n    return result", "response": "Sets indentation of a single or multi - line string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_lines( lines, target_level, indent_string=\"    \", indent_empty_lines=False ):\r\n\r\n    first_non_empty_line_index = _get_first_non_empty_line_index( lines )\r\n    first_line_original_level =  get_line_level( lines[first_non_empty_line_index], indent_string )\r\n\r\n    for i in range(first_non_empty_line_index, len(lines)):\r\n        if not indent_empty_lines and lines[i] == \"\":\r\n            continue\r\n\r\n        line_i_unindented = get_line_unindented( lines[i], indent_string )\r\n        line_i_level =      get_line_level( lines[i], indent_string )\r\n\r\n        on_second_line_or_later = i > first_non_empty_line_index\r\n        if on_second_line_or_later:\r\n            first_line_final_level = get_line_level( lines[first_non_empty_line_index], indent_string )\r\n            relative_indent_move =   first_line_final_level - first_line_original_level\r\n            target_level =           line_i_level + relative_indent_move\r\n\r\n        if line_i_level == target_level:\r\n            continue\r\n\r\n        lines[i] = indent_string * target_level + line_i_unindented", "response": "Sets the indentation for the given set of lines."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_archive(archive):\n    _assert_obj_type(archive, obj_type=DBArchive)\n\n    _get_handler().store_object(archive)\n\n    return archive.to_comm(light_request=True)", "response": "Save the archive into database and into proper indexes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches for all archives with the given query.", "response": "def search_archives(query):\n    \"\"\"\n    Return list of :class:`.DBArchive` which match all properties that are\n    set (``not None``) using AND operator to all of them.\n\n    Example:\n        result = storage_handler.search_publications(\n            DBArchive(isbn=\"azgabash\")\n        )\n\n    Args:\n        query (obj): :class:`.DBArchive` with `some` of the properties set.\n\n    Returns:\n        list: List of matching :class:`.DBArchive` or ``[]`` if no match \\\n              was found.\n\n    Raises:\n        InvalidType: When the `query` is not instance of :class:`.DBArchive`.\n    \"\"\"\n    _assert_obj_type(query, name=\"query\", obj_type=DBArchive)\n\n    return _get_handler().search_objects(query)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef main(argv):\n\n    # Parse command line arguments\n    parser = argparse.ArgumentParser(\n        description=\"LifeSOSpy v{} - {}\".format(\n            PROJECT_VERSION, PROJECT_DESCRIPTION))\n    parser.add_argument(\n        '-H', '--host',\n        help=\"Hostname/IP Address for the LifeSOS server, if we are to run as a client.\",\n        default=None)\n    parser.add_argument(\n        '-P', '--port',\n        help=\"TCP port for the LifeSOS ethernet interface.\",\n        default=str(BaseUnit.TCP_PORT))\n    parser.add_argument(\n        '-p', '--password',\n        help=\"Password for the Master user, if remote access requires it.\",\n        default='')\n    parser.add_argument(\n        '-v', '--verbose',\n        help=\"Display all logging output.\",\n        action='store_true')\n    args = parser.parse_args()\n\n    # Configure logger\n    logging.basicConfig(\n        format=\"%(asctime)s %(levelname)-5s (%(threadName)s) [%(name)s] %(message)s\",\n        datefmt='%Y-%m-%d %H:%M:%S',\n        level=logging.DEBUG if args.verbose else logging.INFO)\n\n    # Create base unit instance and start up interface\n    print(\"LifeSOSpy v{} - {}\\n\".format(PROJECT_VERSION, PROJECT_DESCRIPTION))\n    loop = asyncio.get_event_loop()\n    baseunit = BaseUnit(args.host, args.port)\n    if args.password:\n        baseunit.password = args.password\n    baseunit.start()\n\n    # Provide interactive prompt for running test commands on another thread\n    loop.run_until_complete(\n        loop.run_in_executor(\n            None, _handle_interactive_baseunit_tests, baseunit, loop))\n\n    # Shut down interface and event loop\n    baseunit.stop()\n    loop.close()", "response": "Main function for testing library."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef datetime(self):\n        return dt.datetime(\n            self.year(), self.month(), self.day(),\n            self.hour(), self.minute(), self.second(),\n            int(self.millisecond() * 1e3))", "response": "Return datetime object from instance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrap command class in constructor.", "response": "def get_command(self, name):\n        \"\"\"Wrap command class in constructor.\"\"\"\n\n        def command(options):\n            client = ZookeeperClient(\n                \"%s:%d\" % (options.pop('host'), options.pop('port')),\n                session_timeout=1000\n                )\n\n            path = options.pop('path_prefix')\n            force = options.pop('force')\n            extra = options.pop('extra')\n\n            # Apply settings to options dictionary. While this does\n            # conflate arguments for the utility with command options,\n            # that's something we're willing to accept.\n            options.update(extra)\n\n            controller = Command(client, path, self.services, force)\n            method = getattr(controller, \"cmd_%s\" % name)\n            return method(**options)\n\n        return command"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_installed_version(vcs):\n    version_path = _get_version_path(vcs)\n    if not os.path.exists(version_path):\n        raise VersionNotInstalledError\n    with open(version_path, 'r') as f:\n        return f.read().strip()", "response": "Get the installed version for this project."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the installed version for this project.", "response": "def set_installed_version(vcs, version):\n    \"\"\"Set the installed version for this project.\n\n    Args:\n        vcs (easyci.vcs.base.Vcs)\n        version (str)\n    \"\"\"\n    version_path = _get_version_path(vcs)\n    with open(version_path, 'w') as f:\n        f.write(version)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_urls(self, **kwargs):\n        kwargs[\"site\"] = Site.objects.get(id=current_site_id())\n        return super(DisplayableSitemap, self).get_urls(**kwargs)", "response": "Ensure the correct host by injecting the current site."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef usernames(urls):\n    '''Take an iterable of `urls` of normalized URL or file paths and\n    attempt to extract usernames.  Returns a list.\n\n    '''\n    usernames = StringCounter()\n    for url, count in urls.items():\n        uparse = urlparse(url)\n        path = uparse.path\n        hostname = uparse.hostname\n        m = username_re.match(path)\n        if m:\n            usernames[m.group('username')] += count\n        elif hostname in ['twitter.com', 'www.facebook.com']:\n            usernames[path.lstrip('/')] += count\n    return usernames", "response": "Take an iterable of normalized URL or file paths and\n    attempt to extract usernames. Returns a list."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cleaned_data(self):\n        if not hasattr(self, \"_cleaned_data\"):\n            self._cleaned_data = {}\n            self.is_valid()\n        return self._cleaned_data", "response": "A dictionary of the data that can be used to store the data in the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search(self):\n        results = self.index.objects.all()\n        # reduce the results based on the q field\n        if self.cleaned_data.get(\"q\"):\n            results = results.query(\n                \"multi_match\",\n                query=self.cleaned_data['q'],\n                fields=self.get_fields(),\n                # this prevents ES from erroring out when a string is used on a\n                # number field (for example)\n                lenient=True\n            )\n\n        return results", "response": "This method returns an elasticsearch - DSL Search instance for the items in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef results(self):\n        if not self.in_search_mode():\n            return self.get_queryset()\n\n        # we are doing a search\n        objects = self.search()\n\n        # if objects isn't a Search object, just return it, since it's\n        # (hopefully) just a list or queryset.\n        if not isinstance(objects, Search):\n            return objects\n\n        if not self.is_valid_query(objects):\n            self.add_error(None, forms.ValidationError(\"Invalid Query\", code=\"invalid-query\"))\n            return []\n\n        # convert the search results to something that can be iterated over, and paged\n        return Pageable(objects, self.get_queryset())", "response": "Return a Pageable object that can be iterated over."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plug(self):\n        '''Add the actor's methods to the callback registry.'''\n        if self.__plugged:\n            return\n        for _, method in inspect.getmembers(self, predicate=inspect.ismethod):\n            if hasattr(method, '_callback_messages'):\n                for message in method._callback_messages:\n                    global_callbacks[message].add(method)\n        self.__plugged = True", "response": "Add the actor s methods to the callback registry."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the actor s methods from the callback registry.", "response": "def unplug(self):\n        '''Remove the actor's methods from the callback registry.'''\n        if not self.__plugged:\n            return\n        members = set([method for _, method\n                      in inspect.getmembers(self, predicate=inspect.ismethod)])\n        for message in global_callbacks:\n            global_callbacks[message] -= members\n        self.__plugged = False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun until there are no events to be processed.", "response": "def run(self):\n        '''Run until there are no events to be processed.'''\n        # We left-append rather than emit (right-append) because some message\n        # may have been already queued for execution before the director runs.\n        global_event_queue.appendleft((INITIATE, self, (), {}))\n        while global_event_queue:\n            self.process_event(global_event_queue.popleft())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef halt(self, message, emitter, *args, **kwargs):\n        '''Halt the execution of the loop.'''\n        self.process_event((FINISH, self, (), {}))\n        global_event_queue.clear()", "response": "Halt the execution of the loop."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun command specified by cmd and return stdout stderr and code.", "response": "def _run_cmd(cmd):\n    \"\"\"Run command specified by :cmd: and return stdout, stderr and code.\"\"\"\n    if not os.path.exists(cmd[0]):\n        cmd[0] = shutil.which(cmd[0])\n        assert cmd[0] is not None\n\n    shebang_parts = parseshebang.parse(cmd[0])\n\n    proc = subprocess.Popen(shebang_parts + cmd,\n                            stdout=subprocess.PIPE,\n                            stderr=subprocess.PIPE)\n    stdout, stderr = proc.communicate()\n    return {\n        \"stdout\": stdout,\n        \"stderr\": stderr,\n        \"code\": proc.returncode\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_injector(param_name, fun_param_value):\n    '''Dependency injection with Bottle.\n\n    This creates a simple dependency injector that will map\n    ``param_name`` in routes to the value ``fun_param_value()``\n    each time the route is invoked.\n\n    ``fun_param_value`` is a closure so that it is lazily evaluated.\n    This is useful for handling thread local services like database\n    connections.\n\n    :param str param_name: name of function parameter to inject into\n    :param fun_param_value: the value to insert\n    :type fun_param_value: a closure that can be applied with zero\n                           arguments\n    '''\n    class _(object):\n        api = 2\n\n        def apply(self, callback, route):\n            if param_name not in inspect.getargspec(route.callback)[0]:\n                return callback\n\n            def _(*args, **kwargs):\n                pval = fun_param_value()\n                if pval is None:\n                    logger.error('service \"%s\" unavailable', param_name)\n                    bottle.abort(503, 'service \"%s\" unavailable' % param_name)\n                    return\n                kwargs[param_name] = pval\n                return callback(*args, **kwargs)\n            return _\n    return _()", "response": "Creates a simple dependency injector that will map the given parameter name to the given value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\neliminate the builder by producing a new Bottle application.", "response": "def get_app(self):\n        '''Eliminate the builder by producing a new Bottle application.\n\n        This should be the final call in your method chain. It uses all\n        of the built up options to create a new Bottle application.\n\n        :rtype: :class:`bottle.Bottle`\n        '''\n        if self.config is None:\n            # If the user never sets a config instance, then just create\n            # a default.\n            self.config = Config()\n        if self.mount_prefix is None:\n            self.mount_prefix = self.config.config.get('url_prefix')\n\n        self.inject('config', lambda: self.config)\n        self.inject('kvlclient', lambda: self.config.kvlclient)\n        self.inject('store', lambda: self.config.store)\n        self.inject('label_store', lambda: self.config.label_store)\n        self.inject('tags', lambda: self.config.tags)\n        self.inject('search_engines', lambda: self.search_engines)\n        self.inject('filters', lambda: self.filters)\n        self.inject('request', lambda: bottle.request)\n        self.inject('response', lambda: bottle.response)\n\n        # DEPRECATED. Remove. ---AG\n        self.inject('visid_to_dbid', lambda: self.visid_to_dbid)\n        self.inject('dbid_to_visid', lambda: self.dbid_to_visid)\n\n        # Also DEPRECATED.\n        self.inject('label_hooks', lambda: [])\n\n        # Load routes defined in entry points.\n        for extroute in self.config.config.get('external_routes', []):\n            mod, fun_name = extroute.split(':')\n            logger.info('Loading external route: %s', extroute)\n            fun = getattr(__import__(mod, fromlist=[fun_name]), fun_name)\n            self.add_routes(fun())\n\n        # This adds the `json=True` feature on routes, which always coerces\n        # the output to JSON. Bottle, by default, only permits dictionaries\n        # to be JSON, which is the correct behavior. (Because returning JSON\n        # arrays is a hazard.)\n        #\n        # So we should fix the routes and then remove this. ---AG\n        self.app.install(JsonPlugin())\n\n        # Throw away the app and return it. Because this is elimination!\n        app = self.app\n        self.app = None\n        if self.mount_prefix is not None:\n            root = bottle.Bottle()\n            root.mount(self.mount_prefix, app)\n            return root\n        else:\n            return app"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_search_engine(self, name, engine):\n        '''Adds a search engine with the given name.\n\n        ``engine`` must be the **class** object rather than\n        an instance. The class *must* be a subclass of\n        :class:`dossier.web.SearchEngine`, which should provide a means\n        of obtaining recommendations given a query.\n\n        The ``engine`` must be a class so that its dependencies can be\n        injected when the corresponding route is executed by the user.\n\n        If ``engine`` is ``None``, then it removes a possibly existing\n        search engine named ``name``.\n\n        :param str name: The name of the search engine. This appears\n                         in the list of search engines provided to the\n                         user, and is how the search engine is invoked\n                         via REST.\n        :param engine: A search engine *class*.\n        :type engine: `type`\n        :rtype: :class:`WebBuilder`\n        '''\n        if engine is None:\n            self.search_engines.pop(name, None)\n        self.search_engines[name] = engine\n        return self", "response": "Adds a search engine with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_filter(self, name, filter):\n        '''Adds a filter with the given name.\n\n        ``filter`` must be the **class** object rather than\n        an instance. The class *must* be a subclass of\n        :class:`dossier.web.Filter`, which should provide a means\n        of creating a predicate function.\n\n        The ``filter`` must be a class so that its dependencies can be\n        injected when the corresponding route is executed by the user.\n\n        If ``filter`` is ``None``, then it removes a possibly existing\n        filter named ``name``.\n\n        :param str name: The name of the filter. This is how the search engine\n                         is invoked via REST.\n        :param engine: A filter *class*.\n        :type engine: `type`\n        :rtype: :class:`WebBuilder`\n        '''\n        if name is None:\n            self.filters.pop(name, None)\n        self.filters[name] = filter\n        return self", "response": "Adds a filter with the given name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_routes(self, routes):\n        '''Merges a Bottle application into this one.\n\n        :param routes: A Bottle application or a sequence of routes.\n        :type routes: :class:`bottle.Bottle` or `[bottle route]`.\n        :rtype: :class:`WebBuilder`\n        '''\n        # Basically the same as `self.app.merge(routes)`, except this\n        # changes the owner of the route so that plugins on `self.app`\n        # apply to the routes given here.\n        if isinstance(routes, bottle.Bottle):\n            routes = routes.routes\n        for route in routes:\n            route.app = self.app\n            self.app.add_route(route)\n        return self", "response": "Merges a Bottle application into this one."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef inject(self, name, closure):\n        '''Injects ``closure()`` into ``name`` parameters in routes.\n\n        This sets up dependency injection for parameters named ``name``.\n        When a route is invoked that has a parameter ``name``, then\n        ``closure()`` is passed as that parameter's value.\n\n        (The closure indirection is so the caller can control the time\n        of construction for objects. For example, you may want to check\n        the health of a database connection.)\n\n        :param str name: Parameter name.\n        :param function closure: A function with no parameters.\n        :rtype: :class:`WebBuilder`\n        '''\n        self.app.install(create_injector(name, closure))\n        return self", "response": "Injects closure into name parameters in routes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nenables Cross Origin Resource Sharing. This enables the necessary headers to be set so that this web application can be accessed from other origins.", "response": "def enable_cors(self):\n        '''Enables Cross Origin Resource Sharing.\n\n        This makes sure the necessary headers are set so that this\n        web application's routes can be accessed from other origins.\n\n        :rtype: :class:`WebBuilder`\n        '''\n        def access_control_headers():\n            bottle.response.headers['Access-Control-Allow-Origin'] = '*'\n            bottle.response.headers['Access-Control-Allow-Methods'] = \\\n                'GET, POST, PUT, DELETE, OPTIONS'\n            bottle.response.headers['Access-Control-Allow-Headers'] = \\\n                'Origin, X-Requested-With, Content-Type, Accept, Authorization'\n\n        def options_response(res):\n            if bottle.request.method == 'OPTIONS':\n                new_res = bottle.HTTPResponse()\n                new_res.headers['Access-Control-Allow-Origin'] = '*'\n                new_res.headers['Access-Control-Allow-Methods'] = \\\n                    bottle.request.headers.get(\n                        'Access-Control-Request-Method', '')\n                new_res.headers['Access-Control-Allow-Headers'] = \\\n                    bottle.request.headers.get(\n                        'Access-Control-Request-Headers', '')\n                return new_res\n            res.headers['Allow'] += ', OPTIONS'\n            return bottle.request.app.default_error_handler(res)\n\n        self.app.add_hook('after_request', access_control_headers)\n        self.app.error_handler[int(405)] = options_response\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_properties(self) -> 'PygalleBaseClass':\n        self._pigalle = {\n            PygalleBaseClass.__KEYS.INTERNALS: dict(),\n            PygalleBaseClass.__KEYS.PUBLIC: dict()\n        }\n        return self", "response": "Initialize the Pigalle properties."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndefining a public property.", "response": "def set(self, key: str, value: Any) -> 'PygalleBaseClass':\n        \"\"\" Define a public property.\n\n        :param key:\n        :param value:\n        :return:\n        \"\"\"\n        self.public()[key] = value\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_class_name(self) -> 'PygalleBaseClass':\n        return self.set_internal(PygalleBaseClass.__KEYS.CLASSNAME, self.__class__.__name__)", "response": "Stores the class name of the current instance of this class into internal property."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndefine the category of the class.", "response": "def set_category(self, category: str = None) -> 'PygalleBaseClass':\n        \"\"\" Define the category of the class.\n\n        # Arguments\n            category: The name of category.\n\n        # Returns:\n            PygalleBaseClass: An instance of :class:`PygalleBaseClass`\n        \"\"\"\n        return self.set_internal(PygalleBaseClass.__KEYS.CATEGORY, category)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef instance_of(self, kls: Any) -> bool:\n        if not kls:\n            raise ValueError\n        return isinstance(self, kls)", "response": "Return True if the current object is an instance of passed type."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns true if the passed object as argument is a class being to the Pigalle framework.", "response": "def is_pigalle_class(kls: ClassVar) -> bool:\n        \"\"\" Return true if the passed object as argument is a class being to the Pigalle framework.\n\n        # Arguments\n            kls: The class to check.\n\n        # Returns:\n            bool:\n                * True if class is Pigalle.\n                * False else.\n        \"\"\"\n        return (kls is PygalleBaseClass) or (issubclass(type(kls), PygalleBaseClass))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns true if the passed object is a class or an analyzed object of class Pigalle.", "response": "def is_pigalle(obj: Any) -> bool:\n        \"\"\" Return true if the passed object as argument is a class or an\n        instance of class being to the Pigalle framework.\n\n        # Arguments\n            obj: The class or object to test.\n\n        # Returns:\n            bool:\n                * True if class or object is Pigalle.\n                * False else.\n\n        \"\"\"\n        return PygalleBaseClass.is_pigalle_class(obj) or PygalleBaseClass.is_pigalle_instance(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_method(self, key: str) -> bool:\n        return hasattr(self.__class__, key) and callable(getattr(self.__class__, key))", "response": "Return if a method exists for the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_context(lines, backwards=False):\n    tex_tag = re.compile(r\".*\\\\(\\w+).*\")\n    sentence = re.compile(r\"(?<=[.?!])[\\s]+(?=[A-Z])\")\n    context = []\n\n    word_list = lines.split()\n    if backwards:\n        word_list.reverse()\n\n    # For each word we do the following:\n    #   1. Check if we have reached word limit\n    #   2. If not, see if this is a TeX tag and see if its 'illegal'\n    #   3. Otherwise, add word to context\n    for word in word_list:\n        if len(context) >= CFG_PLOTEXTRACTOR_CONTEXT_WORD_LIMIT:\n            break\n        match = tex_tag.match(word)\n        if match and match.group(1) in CFG_PLOTEXTRACTOR_DISALLOWED_TEX:\n            # TeX Construct matched, return\n            if backwards:\n                # When reversed we need to go back and\n                # remove unwanted data within brackets\n                temp_word = \"\"\n                while len(context):\n                    temp_word = context.pop()\n                    if '}' in temp_word:\n                        break\n            break\n        context.append(word)\n\n    if backwards:\n        context.reverse()\n    text = \" \".join(context)\n    sentence_list = sentence.split(text)\n\n    if backwards:\n        sentence_list.reverse()\n\n    if len(sentence_list) > CFG_PLOTEXTRACTOR_CONTEXT_SENTENCE_LIMIT:\n        return \" \".join(\n            sentence_list[:CFG_PLOTEXTRACTOR_CONTEXT_SENTENCE_LIMIT])\n    else:\n        return \" \".join(sentence_list)", "response": "Get the context of a string from a TeX file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extract_context(tex_file, extracted_image_data):\n    if os.path.isdir(tex_file) or not os.path.exists(tex_file):\n        return []\n\n    lines = \"\".join(get_lines_from_file(tex_file))\n\n    # Generate context for each image and its assoc. labels\n    for data in extracted_image_data:\n        context_list = []\n\n        # Generate a list of index tuples for all matches\n        indicies = [match.span()\n                    for match in re.finditer(r\"(\\\\(?:fig|ref)\\{%s\\})\" %\n                                             (re.escape(data['label']),),\n                                             lines)]\n        for startindex, endindex in indicies:\n            # Retrive all lines before label until beginning of file\n            i = startindex - CFG_PLOTEXTRACTOR_CONTEXT_EXTRACT_LIMIT\n            if i < 0:\n                text_before = lines[:startindex]\n            else:\n                text_before = lines[i:startindex]\n            context_before = get_context(text_before, backwards=True)\n\n            # Retrive all lines from label until end of file and get context\n            i = endindex + CFG_PLOTEXTRACTOR_CONTEXT_EXTRACT_LIMIT\n            text_after = lines[endindex:i]\n            context_after = get_context(text_after)\n            context_list.append(\n                context_before + ' \\\\ref{' + data['label'] + '} ' +\n                context_after\n            )\n        data['contexts'] = context_list", "response": "This function extracts the context from a. tex file and a list of image data."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts captions from a TeX file and return a list of tuples representing the names of images and their captions and labels.", "response": "def extract_captions(tex_file, sdir, image_list, primary=True):\n    \"\"\"Extract captions.\n\n    Take the TeX file and the list of images in the tarball (which all,\n    presumably, are used in the TeX file) and figure out which captions\n    in the text are associated with which images\n    :param: lines (list): list of lines of the TeX file\n\n    :param: tex_file (string): the name of the TeX file which mentions\n        the images\n    :param: sdir (string): path to current sub-directory\n    :param: image_list (list): list of images in tarball\n    :param: primary (bool): is this the primary call to extract_caption?\n\n    :return: images_and_captions_and_labels ([(string, string, list),\n        (string, string, list), ...]):\n        a list of tuples representing the names of images and their\n        corresponding figure labels from the TeX file\n    \"\"\"\n    if os.path.isdir(tex_file) or not os.path.exists(tex_file):\n        return []\n\n    lines = get_lines_from_file(tex_file)\n\n    # possible figure lead-ins\n    figure_head = u'\\\\begin{figure'  # also matches figure*\n    figure_wrap_head = u'\\\\begin{wrapfigure'\n    figure_tail = u'\\\\end{figure'  # also matches figure*\n    figure_wrap_tail = u'\\\\end{wrapfigure'\n    picture_head = u'\\\\begin{picture}'\n    displaymath_head = u'\\\\begin{displaymath}'\n    subfloat_head = u'\\\\subfloat'\n    subfig_head = u'\\\\subfigure'\n    includegraphics_head = u'\\\\includegraphics'\n    epsfig_head = u'\\\\epsfig'\n    input_head = u'\\\\input'\n    # possible caption lead-ins\n    caption_head = u'\\\\caption'\n    figcaption_head = u'\\\\figcaption'\n    label_head = u'\\\\label'\n    rotate = u'rotate='\n    angle = u'angle='\n    eps_tail = u'.eps'\n    ps_tail = u'.ps'\n\n    doc_head = u'\\\\begin{document}'\n    doc_tail = u'\\\\end{document}'\n\n    extracted_image_data = []\n    cur_image = ''\n    caption = ''\n    labels = []\n    active_label = \"\"\n\n    # cut out shit before the doc head\n    if primary:\n        for line_index in range(len(lines)):\n            if lines[line_index].find(doc_head) < 0:\n                lines[line_index] = ''\n            else:\n                break\n\n    # are we using commas in filenames here?\n    commas_okay = False\n\n    for dummy1, dummy2, filenames in \\\n            os.walk(os.path.split(os.path.split(tex_file)[0])[0]):\n        for filename in filenames:\n            if filename.find(',') > -1:\n                commas_okay = True\n                break\n\n    # a comment is a % not preceded by a \\\n    comment = re.compile(\"(?<!\\\\\\\\)%\")\n\n    for line_index in range(len(lines)):\n        # get rid of pesky comments by splitting where the comment is\n        # and keeping only the part before the %\n        line = comment.split(lines[line_index])[0]\n        line = line.strip()\n        lines[line_index] = line\n\n    in_figure_tag = 0\n\n    for line_index in range(len(lines)):\n        line = lines[line_index]\n\n        if line == '':\n            continue\n        if line.find(doc_tail) > -1:\n            break\n\n        \"\"\"\n        FIGURE -\n        structure of a figure:\n        \\begin{figure}\n        \\formatting...\n        \\includegraphics[someoptions]{FILENAME}\n        \\caption{CAPTION}  %caption and includegraphics may be switched!\n        \\end{figure}\n        \"\"\"\n\n        index = max([line.find(figure_head), line.find(figure_wrap_head)])\n        if index > -1:\n            in_figure_tag = 1\n            # some punks don't like to put things in the figure tag.  so we\n            # just want to see if there is anything that is sitting outside\n            # of it when we find it\n            cur_image, caption, extracted_image_data = put_it_together(\n                cur_image, caption,\n                active_label, extracted_image_data,\n                line_index, lines)\n\n        # here, you jerks, just make it so that it's fecking impossible to\n        # figure out your damn inclusion types\n\n        index = max([line.find(eps_tail), line.find(ps_tail),\n                     line.find(epsfig_head)])\n        if index > -1:\n            if line.find(eps_tail) > -1 or line.find(ps_tail) > -1:\n                ext = True\n            else:\n                ext = False\n            filenames = intelligently_find_filenames(line, ext=ext,\n                                                     commas_okay=commas_okay)\n\n            # try to look ahead!  sometimes there are better matches after\n            if line_index < len(lines) - 1:\n                filenames.extend(intelligently_find_filenames(\n                    lines[line_index + 1],\n                    commas_okay=commas_okay))\n            if line_index < len(lines) - 2:\n                filenames.extend(intelligently_find_filenames(\n                    lines[line_index + 2],\n                    commas_okay=commas_okay))\n\n            for filename in filenames:\n                filename = filename.encode('utf-8', 'ignore')\n                if cur_image == '':\n                    cur_image = filename\n                elif type(cur_image) == list:\n                    if type(cur_image[SUB_CAPTION_OR_IMAGE]) == list:\n                        cur_image[SUB_CAPTION_OR_IMAGE].append(filename)\n                    else:\n                        cur_image[SUB_CAPTION_OR_IMAGE] = [filename]\n                else:\n                    cur_image = ['', [cur_image, filename]]\n\n        \"\"\"\n        Rotate and angle\n        \"\"\"\n        index = max(line.find(rotate), line.find(angle))\n        if index > -1:\n            # which is the image associated to it?\n            filenames = intelligently_find_filenames(line,\n                                                     commas_okay=commas_okay)\n            # try the line after and the line before\n            if line_index + 1 < len(lines):\n                filenames.extend(intelligently_find_filenames(\n                    lines[line_index + 1],\n                    commas_okay=commas_okay))\n            if line_index > 1:\n                filenames.extend(intelligently_find_filenames(\n                    lines[line_index - 1],\n                    commas_okay=commas_okay))\n            already_tried = []\n            for filename in filenames:\n                if filename != 'ERROR' and filename not in already_tried:\n                    if rotate_image(filename, line, sdir, image_list):\n                        break\n                    already_tried.append(filename)\n\n        \"\"\"\n        INCLUDEGRAPHICS -\n        structure of includegraphics:\n        \\includegraphics[someoptions]{FILENAME}\n        \"\"\"\n        index = line.find(includegraphics_head)\n        if index > -1:\n            open_curly, open_curly_line, close_curly, dummy = \\\n                find_open_and_close_braces(line_index, index, '{', lines)\n            filename = lines[open_curly_line][open_curly + 1:close_curly]\n            if cur_image == '':\n                cur_image = filename\n            elif type(cur_image) == list:\n                if type(cur_image[SUB_CAPTION_OR_IMAGE]) == list:\n                    cur_image[SUB_CAPTION_OR_IMAGE].append(filename)\n                else:\n                    cur_image[SUB_CAPTION_OR_IMAGE] = [filename]\n            else:\n                cur_image = ['', [cur_image, filename]]\n\n        \"\"\"\n        {\\input{FILENAME}}\n        \\caption{CAPTION}\n\n        This input is ambiguous, since input is also used for things like\n        inclusion of data from other LaTeX files directly.\n        \"\"\"\n        index = line.find(input_head)\n        if index > -1:\n            new_tex_names = intelligently_find_filenames(\n                line, TeX=True,\n                commas_okay=commas_okay)\n            for new_tex_name in new_tex_names:\n                if new_tex_name != 'ERROR':\n                    new_tex_file = get_tex_location(new_tex_name, tex_file)\n                    if new_tex_file and primary:  # to kill recursion\n                        extracted_image_data.extend(extract_captions(\n                            new_tex_file, sdir,\n                            image_list,\n                            primary=False\n                        ))\n\n        \"\"\"PICTURE\"\"\"\n\n        index = line.find(picture_head)\n        if index > -1:\n            # structure of a picture:\n            # \\begin{picture}\n            # ....not worrying about this now\n            # print('found picture tag')\n            # FIXME\n            pass\n\n        \"\"\"DISPLAYMATH\"\"\"\n\n        index = line.find(displaymath_head)\n        if index > -1:\n            # structure of a displaymath:\n            # \\begin{displaymath}\n            # ....not worrying about this now\n            # print('found displaymath tag')\n            # FIXME\n            pass\n\n        \"\"\"\n        CAPTIONS -\n        structure of a caption:\n        \\caption[someoptions]{CAPTION}\n        or\n        \\caption{CAPTION}\n        or\n        \\caption{{options}{CAPTION}}\n        \"\"\"\n\n        index = max([line.find(caption_head), line.find(figcaption_head)])\n        if index > -1:\n            open_curly, open_curly_line, close_curly, close_curly_line = \\\n                find_open_and_close_braces(line_index, index, '{', lines)\n\n            cap_begin = open_curly + 1\n\n            cur_caption = assemble_caption(\n                open_curly_line, cap_begin,\n                close_curly_line, close_curly, lines)\n\n            if caption == '':\n                caption = cur_caption\n            elif type(caption) == list:\n                if type(caption[SUB_CAPTION_OR_IMAGE]) == list:\n                    caption[SUB_CAPTION_OR_IMAGE].append(cur_caption)\n                else:\n                    caption[SUB_CAPTION_OR_IMAGE] = [cur_caption]\n            elif caption != cur_caption:\n                caption = ['', [caption, cur_caption]]\n\n        \"\"\"\n        SUBFLOATS -\n        structure of a subfloat (inside of a figure tag):\n        \\subfloat[CAPTION]{options{FILENAME}}\n\n        also associated with the overall caption of the enclosing figure\n        \"\"\"\n\n        index = line.find(subfloat_head)\n        if index > -1:\n            # if we are dealing with subfloats, we need a different\n            # sort of structure to keep track of captions and subcaptions\n            if not isinstance(cur_image, list):\n                cur_image = [cur_image, []]\n            if not isinstance(caption, list):\n                caption = [caption, []]\n\n            open_square, open_square_line, close_square, close_square_line = \\\n                find_open_and_close_braces(line_index, index, '[', lines)\n            cap_begin = open_square + 1\n\n            sub_caption = assemble_caption(\n                open_square_line,\n                cap_begin, close_square_line, close_square, lines)\n            caption[SUB_CAPTION_OR_IMAGE].append(sub_caption)\n\n            open_curly, open_curly_line, close_curly, dummy = \\\n                find_open_and_close_braces(close_square_line,\n                                           close_square, '{', lines)\n            sub_image = lines[open_curly_line][open_curly + 1:close_curly]\n\n            cur_image[SUB_CAPTION_OR_IMAGE].append(sub_image)\n\n        \"\"\"\n        SUBFIGURES -\n        structure of a subfigure (inside a figure tag):\n        \\subfigure[CAPTION]{\n        \\includegraphics[options]{FILENAME}}\n\n        also associated with the overall caption of the enclosing figure\n        \"\"\"\n\n        index = line.find(subfig_head)\n        if index > -1:\n            # like with subfloats, we need a different structure for keepin\n            # track of this stuff\n            if type(cur_image) != list:\n                cur_image = [cur_image, []]\n            if type(caption) != list:\n                caption = [caption, []]\n\n            open_square, open_square_line, close_square, close_square_line = \\\n                find_open_and_close_braces(line_index, index, '[', lines)\n            cap_begin = open_square + 1\n\n            sub_caption = assemble_caption(open_square_line,\n                                           cap_begin, close_square_line,\n                                           close_square, lines)\n            caption[SUB_CAPTION_OR_IMAGE].append(sub_caption)\n\n            index_cpy = index\n\n            # find the graphics tag to get the filename\n            # it is okay if we eat lines here\n            index = line.find(includegraphics_head)\n            while index == -1 and (line_index + 1) < len(lines):\n                line_index += 1\n                line = lines[line_index]\n                index = line.find(includegraphics_head)\n            if line_index == len(lines):\n                # didn't find the image name on line\n                line_index = index_cpy\n\n            open_curly, open_curly_line, close_curly, dummy = \\\n                find_open_and_close_braces(line_index,\n                                           index, '{', lines)\n            sub_image = lines[open_curly_line][open_curly + 1:close_curly]\n\n            cur_image[SUB_CAPTION_OR_IMAGE].append(sub_image)\n\n        \"\"\"\n        LABELS -\n        structure of a label:\n        \\label{somelabelnamewhichprobablyincludesacolon}\n\n        Labels are used to tag images and will later be used in ref tags\n        to reference them.  This is interesting because in effect the refs\n        to a plot are additional caption for it.\n\n        Notes: labels can be used for many more things than just plots.\n        We'll have to experiment with how to best associate a label with an\n        image.. if it's in the caption, it's easy.  If it's in a figure, it's\n        still okay... but the images that aren't in figure tags are numerous.\n        \"\"\"\n        index = line.find(label_head)\n        if index > -1 and in_figure_tag:\n            open_curly, open_curly_line, close_curly, dummy =\\\n                find_open_and_close_braces(line_index,\n                                           index, '{', lines)\n            label = lines[open_curly_line][open_curly + 1:close_curly]\n            if label not in labels:\n                active_label = label\n            labels.append(label)\n\n        \"\"\"\n        FIGURE\n\n        important: we put the check for the end of the figure at the end\n        of the loop in case some pathological person puts everything in one\n        line\n        \"\"\"\n        index = max([\n            line.find(figure_tail),\n            line.find(figure_wrap_tail),\n            line.find(doc_tail)\n        ])\n        if index > -1:\n            in_figure_tag = 0\n            cur_image, caption, extracted_image_data = \\\n                put_it_together(cur_image, caption, active_label,\n                                extracted_image_data,\n                                line_index, lines)\n        \"\"\"\n        END DOCUMENT\n\n        we shouldn't look at anything after the end document tag is found\n        \"\"\"\n\n        index = line.find(doc_tail)\n        if index > -1:\n            break\n\n    return extracted_image_data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nputting it together in the current image and caption and extracted_image_data list.", "response": "def put_it_together(cur_image, caption, context, extracted_image_data,\n                    line_index, lines):\n    \"\"\"Put it together.\n\n    Takes the current image(s) and caption(s) and assembles them into\n    something useful in the extracted_image_data list.\n\n    :param: cur_image (string || list): the image currently being dealt with,\n        or the list of images, in the case of subimages\n    :param: caption (string || list): the caption or captions currently in\n        scope\n    :param: extracted_image_data ([(string, string), (string, string), ...]):\n        a list of tuples of images matched to captions from this document.\n    :param: line_index (int): the index where we are in the lines (for\n        searchback and searchforward purposes)\n    :param: lines ([string, string, ...]): the lines in the TeX\n\n    :return: (cur_image, caption, extracted_image_data): the same arguments it\n        was sent, processed appropriately\n    \"\"\"\n    if type(cur_image) == list:\n        if cur_image[MAIN_CAPTION_OR_IMAGE] == 'ERROR':\n            cur_image[MAIN_CAPTION_OR_IMAGE] = ''\n        for image in cur_image[SUB_CAPTION_OR_IMAGE]:\n            if image == 'ERROR':\n                cur_image[SUB_CAPTION_OR_IMAGE].remove(image)\n\n    if cur_image != '' and caption != '':\n\n        if type(cur_image) == list and type(caption) == list:\n\n            if cur_image[MAIN_CAPTION_OR_IMAGE] != '' and\\\n                    caption[MAIN_CAPTION_OR_IMAGE] != '':\n                extracted_image_data.append(\n                    (cur_image[MAIN_CAPTION_OR_IMAGE],\n                     caption[MAIN_CAPTION_OR_IMAGE],\n                     context))\n            if type(cur_image[MAIN_CAPTION_OR_IMAGE]) == list:\n                # why is the main image a list?\n                # it's a good idea to attach the main caption to other\n                # things, but the main image can only be used once\n                cur_image[MAIN_CAPTION_OR_IMAGE] = ''\n\n            if type(cur_image[SUB_CAPTION_OR_IMAGE]) == list:\n                if type(caption[SUB_CAPTION_OR_IMAGE]) == list:\n                    for index in \\\n                            range(len(cur_image[SUB_CAPTION_OR_IMAGE])):\n                        if index < len(caption[SUB_CAPTION_OR_IMAGE]):\n                            long_caption = \\\n                                caption[MAIN_CAPTION_OR_IMAGE] + ' : ' + \\\n                                caption[SUB_CAPTION_OR_IMAGE][index]\n                        else:\n                            long_caption = \\\n                                caption[MAIN_CAPTION_OR_IMAGE] + ' : ' + \\\n                                'Caption not extracted'\n                        extracted_image_data.append(\n                            (cur_image[SUB_CAPTION_OR_IMAGE][index],\n                             long_caption, context))\n\n                else:\n                    long_caption = caption[MAIN_CAPTION_OR_IMAGE] + \\\n                        ' : ' + caption[SUB_CAPTION_OR_IMAGE]\n                    for sub_image in cur_image[SUB_CAPTION_OR_IMAGE]:\n                        extracted_image_data.append(\n                            (sub_image, long_caption, context))\n\n            else:\n                if type(caption[SUB_CAPTION_OR_IMAGE]) == list:\n                    long_caption = caption[MAIN_CAPTION_OR_IMAGE]\n                    for sub_cap in caption[SUB_CAPTION_OR_IMAGE]:\n                        long_caption = long_caption + ' : ' + sub_cap\n                    extracted_image_data.append(\n                        (cur_image[SUB_CAPTION_OR_IMAGE], long_caption,\n                         context))\n                else:\n                    # wtf are they lists for?\n                    extracted_image_data.append(\n                        (cur_image[SUB_CAPTION_OR_IMAGE],\n                         caption[SUB_CAPTION_OR_IMAGE], context))\n\n        elif type(cur_image) == list:\n            if cur_image[MAIN_CAPTION_OR_IMAGE] != '':\n                extracted_image_data.append(\n                    (cur_image[MAIN_CAPTION_OR_IMAGE], caption, context))\n            if type(cur_image[SUB_CAPTION_OR_IMAGE]) == list:\n                for image in cur_image[SUB_CAPTION_OR_IMAGE]:\n                    extracted_image_data.append((image, caption, context))\n            else:\n                extracted_image_data.append(\n                    (cur_image[SUB_CAPTION_OR_IMAGE], caption, context))\n\n        elif type(caption) == list:\n            if caption[MAIN_CAPTION_OR_IMAGE] != '':\n                extracted_image_data.append(\n                    (cur_image, caption[MAIN_CAPTION_OR_IMAGE], context))\n            if type(caption[SUB_CAPTION_OR_IMAGE]) == list:\n                # multiple caps for one image:\n                long_caption = caption[MAIN_CAPTION_OR_IMAGE]\n                for subcap in caption[SUB_CAPTION_OR_IMAGE]:\n                    if long_caption != '':\n                        long_caption += ' : '\n                    long_caption += subcap\n                extracted_image_data.append((cur_image, long_caption, context))\n            else:\n                extracted_image_data.append(\n                    (cur_image, caption[SUB_CAPTION_OR_IMAGE]. context))\n\n        else:\n            extracted_image_data.append((cur_image, caption, context))\n\n    elif cur_image != '' and caption == '':\n        # we may have missed the caption somewhere.\n        REASONABLE_SEARCHBACK = 25\n        REASONABLE_SEARCHFORWARD = 5\n        curly_no_tag_preceding = '(?<!\\\\w){'\n\n        for searchback in range(REASONABLE_SEARCHBACK):\n            if line_index - searchback < 0:\n                continue\n\n            back_line = lines[line_index - searchback]\n            m = re.search(curly_no_tag_preceding, back_line)\n            if m:\n                open_curly = m.start()\n                open_curly, open_curly_line, close_curly, \\\n                    close_curly_line = find_open_and_close_braces(\n                        line_index - searchback, open_curly, '{', lines)\n\n                cap_begin = open_curly + 1\n\n                caption = assemble_caption(open_curly_line, cap_begin,\n                                           close_curly_line, close_curly,\n                                           lines)\n\n                if type(cur_image) == list:\n                    extracted_image_data.append(\n                        (cur_image[MAIN_CAPTION_OR_IMAGE], caption, context))\n                    for sub_img in cur_image[SUB_CAPTION_OR_IMAGE]:\n                        extracted_image_data.append(\n                            (sub_img, caption, context))\n                else:\n                    extracted_image_data.append((cur_image, caption, context))\n                    break\n\n        if caption == '':\n            for searchforward in range(REASONABLE_SEARCHFORWARD):\n                if line_index + searchforward >= len(lines):\n                    break\n\n                fwd_line = lines[line_index + searchforward]\n                m = re.search(curly_no_tag_preceding, fwd_line)\n\n                if m:\n                    open_curly = m.start()\n                    open_curly, open_curly_line, close_curly,\\\n                        close_curly_line = find_open_and_close_braces(\n                            line_index + searchforward, open_curly, '{', lines)\n\n                    cap_begin = open_curly + 1\n\n                    caption = assemble_caption(open_curly_line,\n                                               cap_begin, close_curly_line,\n                                               close_curly, lines)\n\n                    if type(cur_image) == list:\n                        extracted_image_data.append(\n                            (cur_image[MAIN_CAPTION_OR_IMAGE],\n                             caption, context))\n                        for sub_img in cur_image[SUB_CAPTION_OR_IMAGE]:\n                            extracted_image_data.append(\n                                (sub_img, caption, context))\n                    else:\n                        extracted_image_data.append(\n                            (cur_image, caption, context))\n                    break\n\n        if caption == '':\n            if type(cur_image) == list:\n                extracted_image_data.append(\n                    (cur_image[MAIN_CAPTION_OR_IMAGE], 'No caption found',\n                     context))\n                for sub_img in cur_image[SUB_CAPTION_OR_IMAGE]:\n                    extracted_image_data.append(\n                        (sub_img, 'No caption', context))\n            else:\n                extracted_image_data.append(\n                    (cur_image, 'No caption found', context))\n\n    elif caption != '' and cur_image == '':\n        if type(caption) == list:\n            long_caption = caption[MAIN_CAPTION_OR_IMAGE]\n            for subcap in caption[SUB_CAPTION_OR_IMAGE]:\n                long_caption = long_caption + ': ' + subcap\n        else:\n            long_caption = caption\n        extracted_image_data.append(('', 'noimg' + long_caption, context))\n\n    # if we're leaving the figure, no sense keeping the data\n    cur_image = ''\n    caption = ''\n\n    return cur_image, caption, extracted_image_data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef intelligently_find_filenames(line, TeX=False, ext=False,\n                                 commas_okay=False):\n    \"\"\"Intelligently find filenames.\n\n    Find the filename in the line.  We don't support all filenames!  Just eps\n    and ps for now.\n\n    :param: line (string): the line we want to get a filename out of\n\n    :return: filename ([string, ...]): what is probably the name of the file(s)\n    \"\"\"\n    files_included = ['ERROR']\n\n    if commas_okay:\n        valid_for_filename = '\\\\s*[A-Za-z0-9\\\\-\\\\=\\\\+/\\\\\\\\_\\\\.,%#]+'\n    else:\n        valid_for_filename = '\\\\s*[A-Za-z0-9\\\\-\\\\=\\\\+/\\\\\\\\_\\\\.%#]+'\n\n    if ext:\n        valid_for_filename += '\\.e*ps[texfi2]*'\n\n    if TeX:\n        valid_for_filename += '[\\.latex]*'\n\n    file_inclusion = re.findall('=' + valid_for_filename + '[ ,]', line)\n\n    if len(file_inclusion) > 0:\n        # right now it looks like '=FILENAME,' or '=FILENAME '\n        for file_included in file_inclusion:\n            files_included.append(file_included[1:-1])\n\n    file_inclusion = re.findall('(?:[ps]*file=|figure=)' +\n                                valid_for_filename + '[,\\\\]} ]*', line)\n\n    if len(file_inclusion) > 0:\n        # still has the =\n        for file_included in file_inclusion:\n            part_before_equals = file_included.split('=')[0]\n            if len(part_before_equals) != file_included:\n                file_included = file_included[\n                    len(part_before_equals) + 1:].strip()\n            if file_included not in files_included:\n                files_included.append(file_included)\n\n    file_inclusion = re.findall(\n        '[\"\\'{\\\\[]' + valid_for_filename + '[}\\\\],\"\\']',\n        line)\n\n    if len(file_inclusion) > 0:\n        # right now it's got the {} or [] or \"\" or '' around it still\n        for file_included in file_inclusion:\n            file_included = file_included[1:-1]\n            file_included = file_included.strip()\n            if file_included not in files_included:\n                files_included.append(file_included)\n\n    file_inclusion = re.findall('^' + valid_for_filename + '$', line)\n\n    if len(file_inclusion) > 0:\n        for file_included in file_inclusion:\n            file_included = file_included.strip()\n            if file_included not in files_included:\n                files_included.append(file_included)\n\n    file_inclusion = re.findall('^' + valid_for_filename + '[,\\\\} $]', line)\n\n    if len(file_inclusion) > 0:\n        for file_included in file_inclusion:\n            file_included = file_included.strip()\n            if file_included not in files_included:\n                files_included.append(file_included)\n\n    file_inclusion = re.findall('\\\\s*' + valid_for_filename + '\\\\s*$', line)\n\n    if len(file_inclusion) > 0:\n        for file_included in file_inclusion:\n            file_included = file_included.strip()\n            if file_included not in files_included:\n                files_included.append(file_included)\n\n    if files_included != ['ERROR']:\n        files_included = files_included[1:]  # cut off the dummy\n\n    for file_included in files_included:\n        if file_included == '':\n            files_included.remove(file_included)\n        if ' ' in file_included:\n            for subfile in file_included.split(' '):\n                if subfile not in files_included:\n                    files_included.append(subfile)\n        if ',' in file_included:\n            for subfile in file_included.split(' '):\n                if subfile not in files_included:\n                    files_included.append(subfile)\n\n    return files_included", "response": "Intelligently find filenames in the line."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_lines_from_file(filepath, encoding=\"UTF-8\"):\n    try:\n        fd = codecs.open(filepath, 'r', encoding)\n        lines = fd.readlines()\n    except UnicodeDecodeError:\n        # Fall back to 'ISO-8859-1'\n        fd = codecs.open(filepath, 'r', 'ISO-8859-1')\n        lines = fd.readlines()\n    finally:\n        fd.close()\n    return lines", "response": "Return an iterator over lines from a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nturns debug mode on or off.", "response": "def debug_mode(self, toggle):\n        \"\"\"\n        Toggle debug mode for more detailed output\n          obj.debug_mode(True) - Turn debug mode on\n          obj.debug_mode(False) - Turn debug mode off\n        \"\"\"\n        if toggle:\n            self.log.setLevel(logging.DEBUG)\n        else:\n            self.log.setLevel(logging.ERROR)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake a request to the API and return the data in a pythonic object", "response": "def _make_request(self, conf, post_params={}):\n        \"\"\"Make a request to the API and return data in a pythonic object\"\"\"\n        endpoint, requires_auth = conf\n\n        # setup the url and the request objects\n        url = '%s%s.php' % (self.api_url, endpoint)\n        log.debug('Setting url to %s' % url)\n        request = urllib2.Request(url)\n\n        # tack on authentication if needed\n        log.debug('Post params: %s' % post_params)\n        if requires_auth:\n            post_params.update({\n                'user': self.username,\n                'pass': self.password\n            })\n\n        # url encode all parameters\n        data = urlencode(post_params).encode('utf-8')\n\n        # gimme some bitcoins!\n        try:\n            log.debug('Requesting data from %s' % url)\n            response = urllib2.urlopen(request, data)\n            return json.loads(response.read())\n        except urllib2.URLError as e:\n            log.debug('Full error: %s' % e)\n            if hasattr(e, 'reason'):\n                self.log.error('Could not reach host. Reason: %s' % e.reason)\n            elif hasattr(e, 'code'):\n                self.log.error('Could not fulfill request. Error Code: %s' % e.code)\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating all api endpoints using self. endpoint and partial from functools.", "response": "def _create_endpoints(self):\n        \"\"\"Create all api endpoints using self.endpoint and partial from functools\"\"\"\n        for k, v in self.endpoints.items():\n            _repr = '%s.%s' % (self.__class__.__name__, k)\n            self.__dict__[k] = EndPointPartial(self._make_request, v, _repr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nturns a ZIP file into a frozen sample.", "response": "def parse(binary, **params):\n    \"\"\"Turns a ZIP file into a frozen sample.\"\"\"\n    binary = io.BytesIO(binary)\n    collection = list()\n    with zipfile.ZipFile(binary, 'r') as zip_:\n        for zip_info in zip_.infolist():\n            content_type, encoding = mimetypes.guess_type(zip_info.filename)\n            content = zip_.read(zip_info)\n            content = content_encodings.get(encoding).decode(content)\n            content = content_types.get(content_type).parse(content, **params)\n            collection.apppend((zip_info.filename, content))\n    return collection"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef keywords_for(*args):\n\n    # Handle a model instance.\n    if isinstance(args[0], Model):\n        obj = args[0]\n        if getattr(obj, \"content_model\", None):\n            obj = obj.get_content_model()\n        keywords_name = obj.get_keywordsfield_name()\n        keywords_queryset = getattr(obj, keywords_name).all()\n        # Keywords may have been prefetched already. If not, we\n        # need select_related for the actual keywords.\n        prefetched = getattr(obj, \"_prefetched_objects_cache\", {})\n        if keywords_name not in prefetched:\n            keywords_queryset = keywords_queryset.select_related(\"keyword\")\n        return [assigned.keyword for assigned in keywords_queryset]\n\n    # Handle a model class.\n    try:\n        app_label, model = args[0].split(\".\", 1)\n    except ValueError:\n        return []\n\n    content_type = ContentType.objects.get(app_label=app_label, model=model)\n    assigned = AssignedKeyword.objects.filter(content_type=content_type)\n    keywords = Keyword.objects.filter(assignments__in=assigned)\n    keywords = keywords.annotate(item_count=Count(\"assignments\"))\n    if not keywords:\n        return []\n    counts = [keyword.item_count for keyword in keywords]\n    min_count, max_count = min(counts), max(counts)\n    factor = (settings.TAG_CLOUD_SIZES - 1.)\n    if min_count != max_count:\n        factor /= (max_count - min_count)\n    for kywd in keywords:\n        kywd.weight = int(round((kywd.item_count - min_count) * factor)) + 1\n    return keywords", "response": "Return a list of Keyword objects for the given model instance or model class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef flag(request, comment_id, next=None):\n    comment = get_object_or_404(comments.get_model(), pk=comment_id, site__pk=settings.SITE_ID)\n\n    # Flag on POST\n    if request.method == 'POST':\n        perform_flag(request, comment)\n        return next_redirect(request, fallback=next or 'comments-flag-done',\n            c=comment.pk)\n\n    # Render a form on GET\n    else:\n        return render_to_response('comments/flag.html',\n            {'comment': comment, \"next\": next},\n            template.RequestContext(request)\n        )", "response": "Flag a comment on the order of the comments."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef perform_flag(request, comment):\n    flag, created = comments.models.CommentFlag.objects.get_or_create(\n        comment = comment,\n        user    = request.user,\n        flag    = comments.models.CommentFlag.SUGGEST_REMOVAL\n    )\n    signals.comment_was_flagged.send(\n        sender  = comment.__class__,\n        comment = comment,\n        flag    = flag,\n        created = created,\n        request = request,\n    )", "response": "Actually perform the flagging of a comment from a request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling when a client opens a websocket connection", "response": "def onConnect(self, request):\n        \"\"\"\n        Called when a client opens a websocket connection\n        \"\"\"\n        logger.debug(\"Connection opened ({peer})\".format(peer=self.peer))\n\n        self.storage = {}\n        self._client_id = str(uuid1())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling when a client has opened a websocket connection", "response": "def onOpen(self):\n        \"\"\"\n        Called when a client has opened a websocket connection\n        \"\"\"\n        self.factory.add_client(self)\n\n        # Publish ON_OPEN message\n        self.factory.mease.publisher.publish(\n            message_type=ON_OPEN, client_id=self._client_id, client_storage=self.storage)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall when a client closes a websocket connection", "response": "def onClose(self, was_clean, code, reason):\n        \"\"\"\n        Called when a client closes a websocket connection\n        \"\"\"\n        logger.debug(\"Connection closed ({peer})\".format(peer=self.peer))\n\n        # Publish ON_CLOSE message\n        self.factory.mease.publisher.publish(\n            message_type=ON_CLOSE, client_id=self._client_id, client_storage=self.storage)\n\n        self.factory.remove_client(self)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef onMessage(self, payload, is_binary):\n        if not is_binary:\n            payload = payload.decode('utf-8')\n\n            logger.debug(\"Incoming message ({peer}) : {message}\".format(\n                peer=self.peer, message=payload))\n\n            # Publish ON_RECEIVE message\n            self.factory.mease.publisher.publish(\n                message_type=ON_RECEIVE,\n                client_id=self._client_id,\n                client_storage=self.storage,\n                message=payload)", "response": "Called when a client sends a message"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends a message to the peer.", "response": "def sendMessage(self, payload, *args, **kwargs):\n        \"\"\"\n        Logs message\n        \"\"\"\n        logger.debug(\"Outgoing message for ({peer}) : {message}\".format(\n            peer=self.peer, message=payload))\n\n        WebSocketServerProtocol.sendMessage(self, payload, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send(self, payload, *args, **kwargs):\n        if isinstance(payload, (list, dict)):\n            payload = json.dumps(payload)\n\n        self.sendMessage(payload.encode(), *args, **kwargs)", "response": "A convenience method to send a message to the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns the WebSocket server", "response": "def run_server(self):\n        \"\"\"\n        Runs the WebSocket server\n        \"\"\"\n        self.protocol = MeaseWebSocketServerProtocol\n\n        reactor.listenTCP(port=self.port, factory=self, interface=self.host)\n\n        logger.info(\"Websocket server listening on {address}\".format(\n            address=self.address))\n\n        reactor.run()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nopening a file possibly relative to a base directory.", "response": "def open(self, name, *args, **kwargs):\n        \"\"\"Open file, possibly relative to a base directory.\"\"\"\n        if self.basedir is not None:\n            name = os.path.join(self.basedir, name)\n\n        return em.Subsystem.open(self, name, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef apply(self, mapping):\n        self.output.seek(0)\n        self.output.truncate(0)\n        self.interpreter.string(self.template, locals=mapping)\n        return self.output.getvalue()", "response": "Apply a mapping of name - value - pairs to a template."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_live_weather(lat, lon, writer):\n    requrl = FORECAST_BASE_URL+forecast_api_token+'/'+str(lat)+','+str(lon)\n    req = requests.get(requrl)\n    if req.status_code == requests.codes.ok:\n        weather = req.json()\n        if not weather['currently']:\n            click.secho(\"No live weather currently\", fg=\"red\", bold=True)\n            return\n        writer.live_weather(weather)\n    else:\n        click.secho(\"There was problem getting live weather\", fg=\"red\", bold=True)", "response": "Gets the live weather via lat and long"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_same_as_file(self):\n\n        def find_preferred_uri(uri_list):\n            index = None\n            for i, uri in enumerate(uri_list):\n                if uri.startswith(\"<http://id.loc.gov/authorities/subjects/\"):\n                        index = i\n                        print(uri)\n                        break\n            if not index:\n                for i, uri in enumerate(uri_list):\n                    if uri.startswith(\\\n                            \"<http://id.loc.gov/authorities/childrensSubjects/\"):\n                        index = i\n                        print(uri)\n                        break\n            if not index:\n                index = 0\n            return (uri_list.pop(index), uri_list)\n\n\n        with open(os.path.join(CFG.LOCAL_DATA_PATH, self.local_filename),\n                  \"w\") as file_obj:\n            file_obj.write(NSM.prefix(\"turtle\"))\n            for item in self.uri_list:\n                uris = item['uris']['value'].split(\",\")\n                new_list = find_preferred_uri(uris)\n                uris = uris[1:]\n                for uir in new_list[1]:\n                    file_obj.write(\"%s kds:mergeWith %s .\\n\" % (uir,\n                                                                new_list[0]))", "response": "Creates a local data file with all of the owl : sameAs tags."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef preprocess(string):\n    string = unicode(string, encoding=\"utf-8\")\n    # convert diacritics to simpler forms\n    string = regex1.sub(lambda x: accents[x.group()], string)\n    # remove all rest of the unwanted characters\n    return regex2.sub('', string).encode('utf-8')", "response": "Preprocess string to transform all diacritics and remove other special characters than appropriate\n    \n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nswap characters from script to transliterated version and vice versa.", "response": "def convert(string, sanitize=False):\n    \"\"\"\n    Swap characters from script to transliterated version and vice versa.\n    Optionally sanitize string by using preprocess function.\n\n    :param sanitize:\n    :param string:\n    :return:\n    \"\"\"\n    return r.convert(string, (preprocess if sanitize else False))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading a YAML - formatted file.", "response": "def load_yaml(filename):\n    \"\"\"\n    Loads a YAML-formatted file.\n    \"\"\"\n    with open(filename) as f:\n        ydoc = yaml.safe_load(f.read())\n    return (ydoc, serialize_tojson(ydoc))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nserializing a K8S resource to YAML - formatted file.", "response": "def serialize_yaml_tofile(filename, resource):\n    \"\"\"\n    Serializes a K8S resource to YAML-formatted file.\n    \"\"\"\n    stream = file(filename, \"w\")\n    yaml.dump(resource, stream, default_flow_style=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse(binary, **params):\n    encoding = params.get('charset', 'UTF-8')\n    return json.loads(binary, encoding=encoding)", "response": "Turns a JSON structure into a python object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef key(string):\n    # The multi-level key is a nested tuple containing strings and ints.\n    # The tuple contains sub-keys that roughly correspond to levels in\n    # UTS #10 (http://unicode.org/reports/tr10/). Except for fallback strings\n    # at the end, each contains a tuple of typically one key per element/letter.\n    # - Alphabet:\n    #    Separators (0, p, l, w)\n    #       p: -no. of paragraph separators\n    #       l: -no. of line separators\n    #       w: -no. of word separators (spaces)\n    #    Letters (1, l); l is the base letter, lowercased\n    #       Special letters: '\u010d' shows up as 'cx'; '\u0159' as 'rx', etc.\n    #                        the 'ch' digraph becomes 'hx'\n    #    Numbers (2, n); n is int(numeric value * 100)\n    #    Missing for non-letters\n    # - Diacritics (p, n, s)\n    #    p: position (above, below, behind, in front, in/over/around, unknown)\n    #       (as a sorted tuple of indices)\n    #    s: shape (dot, grave, breve, ..., unknown)\n    #       (as a sorted tuple of indices)\n    #    Missing for non-letters; empty if diacritics included in base (e.g. \u0159)\n    # - Case: True for uppercased letters\n    #    Missing for non-letters\n    # - Punctuation: see PUNCTUATION_MAP below\n    # - (fallback) NFKD-normalized string\n    # - (fallback) original string\n\n    subkeys = [], [], [], []\n    add_alphabet = subkeys[0].append\n    add_diacritic = subkeys[1].append\n    add_case = subkeys[2].append\n    add_punctuation = subkeys[3].append\n    skip = 0\n    normal = nfkd(string).rstrip()\n    diacritics = []\n    for i, char in enumerate(normal):\n        if skip > 0:\n            skip -= 1\n            continue\n        category = get_category(char)\n        cat0, cat1 = category\n        if cat0 == 'L':\n            # Letter (Lowercase, Modifier, Other, Titlecase, Uppercase)\n            char_lower = char.lower()\n            found = False\n            if char_lower in DECOMPOSING_EXTRAS:\n                # stuff like \u0141 doesn't decompose in Unicode; do it manually\n                char_lower, _extra_diacritics = DECOMPOSING_EXTRAS[char]\n                diacritics.extend(_extra_diacritics)\n            for next in normal[i+1:]:\n                if next == HACEK and char_lower in ('c', 'r', 's', 'z'):\n                    skip += 1\n                    char_lower = char_lower + 'x'\n                elif char_lower == 'c' and next.lower() == 'h':\n                    skip += 1\n                    char_lower = 'hx'\n                    break\n                elif next in DIACRITICS_MAP:\n                    skip += 1\n                    diacritics.extend(DIACRITICS_MAP[next])\n                elif unicodedata.category(char)[0] == 'M':\n                    skip += 1\n                    diacritics.append((POS_UNKNOWN, SH_UNKNOWN))\n                else:\n                    break\n            add_alphabet((1, char_lower))\n            if diacritics:\n                add_diacritic(make_diacritics_key(diacritics))\n            else:\n                add_diacritic(())\n            add_case(cat1 in ('u', 't'))  # upper & title case\n            add_punctuation((0, ))\n            diacritics = []\n        elif cat0 == 'Z':\n            # Separator (Line, Paragraph, Space)\n            counts = {'Zp': 0, 'Zl': 0, 'Zs': 0}\n            counts[category] = 1\n            for next in normal[i+1:]:\n                next_cat = get_category(next)\n                if next_cat[0] == 'Z':\n                    counts[next_cat] += 1\n                    skip += 1\n                else:\n                    break\n            add_alphabet((0, -counts['Zp'], -counts['Zl'], -counts['Zs']))\n            add_diacritic(())\n            add_case(False)\n            add_punctuation((0, ))\n        elif char in DIACRITICS_BEFORE_MAP:\n            diacritics.extend(DIACRITICS_BEFORE_MAP[char])\n        elif char in DIACRITICS_MAP:\n            diacritics.extend(DIACRITICS_MAP[char])\n        elif char in PUNCTUATION_MAP:\n            add_punctuation(PUNCTUATION_MAP[char])\n        elif cat0 == 'P':\n            # Punctuation (Connector, Dash, Open/Close, Final/Initial Quote, Other)\n            add_punctuation((3, ))\n        elif cat0 == 'N':\n            # Number (Decimal digit, Letter, Other)\n            add_alphabet((2, int(unicodedata.numeric(char, 0)) * 100))\n            add_diacritic(())\n            add_case(False)\n            add_punctuation((0, ))\n        elif cat0 == 'S':\n            # Symbol (Currency, Modifier, Math)\n            add_punctuation((3, ))\n        elif cat0 == 'C':\n            # Other (Control, Format, Not Assigned, Private Use, Surrogate)\n            pass\n        elif cat0 == 'M':\n            # Mark (Spacing Combining, Enclosing, Nonspacing)\n            # TODO\n            diacritics.append((POS_FRONT, SH_UNKNOWN))\n        else:\n            raise ValueError('Unknown Unicode category')\n    if diacritics:\n        add_diacritic(make_diacritics_key(diacritics))\n        diacritics = []\n    return tuple(tuple(k) for k in subkeys) + (normal, string)", "response": "Returns a Czech sort key for the given string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving the results matching patterns at result_path.", "response": "def save_results(vcs, signature, result_path, patterns):\n    \"\"\"Save results matching `patterns` at `result_path`.\n\n    Args:\n        vcs (easyci.vcs.base.Vcs) - the VCS object for the actual project\n                                    (not the disposable copy)\n        signature (str) - the project state signature\n        result_path (str) - the path containing the result, usually\n                            a disposable copy of the project\n        patterns (str) - `rsync`-compatible patterns matching test results\n                         to save.\n    \"\"\"\n    results_directory = _get_results_directory(vcs, signature)\n    if not os.path.exists(results_directory):\n        os.makedirs(results_directory)\n    with open(os.path.join(results_directory, 'patterns'), 'w') as f:\n        f.write('\\n'.join(patterns))\n    if not os.path.exists(os.path.join(results_directory, 'results')):\n        os.mkdir(os.path.join(results_directory, 'results'))\n    includes = ['--include={}'.format(x)\n                for x in patterns]\n    cmd = ['rsync', '-r'] + includes + ['--exclude=*',\n                                        os.path.join(result_path, ''),\n                                        os.path.join(results_directory, 'results', '')]\n    subprocess.check_call(cmd)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sync_results(vcs, signature):\n    results_directory = _get_results_directory(vcs, signature)\n    if not os.path.exists(results_directory):\n        raise ResultsNotFoundError\n    with open(os.path.join(results_directory, 'patterns'), 'r') as f:\n        patterns = f.read().strip().split()\n    includes = ['--include={}'.format(x)\n                for x in patterns]\n    cmd = ['rsync', '-r'] + includes + ['--exclude=*',\n                                        os.path.join(\n                                            results_directory, 'results', ''),\n                                        os.path.join(vcs.path, '')]\n    subprocess.check_call(cmd)", "response": "Sync the saved results for signature back to the project."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove saved results for this signature from the results directory.", "response": "def remove_results(vcs, signature):\n    \"\"\"Removed saved results for this signature\n\n    Args:\n        vcs (easyci.vcs.base.Vcs)\n        signature (str)\n    Raises:\n        ResultsNotFoundError\n    \"\"\"\n    results_directory = _get_results_directory(vcs, signature)\n    if not os.path.exists(results_directory):\n        raise ResultsNotFoundError\n    shutil.rmtree(results_directory)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the list of signatures for which test results are saved.", "response": "def get_signatures_with_results(vcs):\n    \"\"\"Returns the list of signatures for which test results are saved.\n\n    Args:\n        vcs (easyci.vcs.base.Vcs)\n\n    Returns:\n        List[str]\n    \"\"\"\n    results_dir = os.path.join(vcs.private_dir(), 'results')\n    if not os.path.exists(results_dir):\n        return []\n    rel_paths = os.listdir(results_dir)\n    return [p for p in rel_paths if os.path.isdir(os.path.join(results_dir, p))]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nub(it):\n    '''Dedups an iterable in arbitrary order.\n\n    Uses memory proportional to the number of unique items in ``it``.\n    '''\n    seen = set()\n    for v in it:\n        h = hash(v)\n        if h in seen:\n            continue\n        seen.add(h)\n        yield v", "response": "Dedups an iterable in arbitrary order."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nyield an unordered generator for all available folders.", "response": "def folders(self, ann_id=None):\n        '''Yields an unordered generator for all available folders.\n\n        By default (with ``ann_id=None``), folders are shown for all\n        anonymous users. Optionally, ``ann_id`` can be set to a username,\n        which restricts the list to only folders owned by that user.\n\n        :param str ann_id: Username\n        :rtype: generator of folder_id\n        '''\n        ann_id = self._annotator(ann_id)\n        if len(self.prefix) > 0:\n            prefix = '|'.join([urllib.quote(self.prefix, safe='~'),\n                               'topic', ann_id, ''])\n        else:\n            prefix = '|'.join(['topic', ann_id, ''])\n        logger.info('Scanning for folders with prefix %r', prefix)\n        return imap(lambda id: self.unwrap_folder_content_id(id)['folder_id'],\n                    self.store.scan_prefix_ids(prefix))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nyields an unodered generator of subfolders in a folder.", "response": "def subfolders(self, folder_id, ann_id=None):\n        '''Yields an unodered generator of subfolders in a folder.\n\n        By default (with ``ann_id=None``), subfolders are shown for all\n        anonymous users. Optionally, ``ann_id`` can be set to a username,\n        which restricts the list to only subfolders owned by that user.\n\n        :param str folder_id: Folder id\n        :param str ann_id: Username\n        :rtype: generator of subfolder_id\n        '''\n        self.assert_valid_folder_id(folder_id)\n        ann_id = self._annotator(ann_id)\n        folder_cid = self.wrap_folder_content_id(ann_id, folder_id)\n        if self.store.get(folder_cid) is None:\n            raise KeyError(folder_id)\n        all_labels = self.label_store.directly_connected(folder_cid)\n        return nub(la.subtopic_for(folder_cid) for la in all_labels)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parent_subfolders(self, ident, ann_id=None):\n        '''An unordered generator of parent subfolders for ``ident``.\n\n        ``ident`` can either be a ``content_id`` or a tuple of\n        ``(content_id, subtopic_id)``.\n\n        Parent subfolders are limited to the annotator id given.\n\n        :param ident: identifier\n        :type ident: ``str`` or ``(str, str)``\n        :param str ann_id: Username\n        :rtype: generator of ``(folder_id, subfolder_id)``\n        '''\n        ann_id = self._annotator(ann_id)\n        cid, _ = normalize_ident(ident)\n        for lab in self.label_store.directly_connected(ident):\n            folder_cid = lab.other(cid)\n            subfolder_sid = lab.subtopic_for(folder_cid)\n            if not folder_cid.startswith('topic|'):\n                continue\n            folder = self.unwrap_folder_content_id(folder_cid)\n            subfolder = self.unwrap_subfolder_subtopic_id(subfolder_sid)\n            if folder['annotator_id'] != ann_id:\n                continue\n            yield (folder['folder_id'], subfolder)", "response": "An unordered generator of parent subfolders for ident."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield an unodered generator of items in a subfolder.", "response": "def items(self, folder_id, subfolder_id, ann_id=None):\n        '''Yields an unodered generator of items in a subfolder.\n\n        The generator yields items, which are represented by a tuple\n        of ``content_id`` and ``subtopic_id``. The format of these\n        identifiers is unspecified.\n\n        By default (with ``ann_id=None``), subfolders are shown for all\n        anonymous users. Optionally, ``ann_id`` can be set to a username,\n        which restricts the list to only subfolders owned by that user.\n\n        :param str folder_id: Folder id\n        :param str subfolder_id: Subfolder id\n        :param str ann_id: Username\n        :rtype: generator of ``(content_id, subtopic_id)``\n        '''\n        self.assert_valid_folder_id(folder_id)\n        self.assert_valid_folder_id(subfolder_id)\n        ann_id = self._annotator(ann_id)\n        folder_cid = self.wrap_folder_content_id(ann_id, folder_id)\n        subfolder_sid = self.wrap_subfolder_subtopic_id(subfolder_id)\n        ident = (folder_cid, subfolder_sid)\n\n        if self.store.get(folder_cid) is None:\n            raise KeyError(folder_id)\n        for lab in self.label_store.directly_connected(ident):\n            cid = lab.other(folder_cid)\n            subid = lab.subtopic_for(cid)\n            yield (cid, subid)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef grouped_items(self, folder_id, subfolder_id, ann_id=None):\n        '''Returns a dictionary from content ids to subtopic ids.\n\n        Namely, the mapping is ``content_id |--> list of subtopic id``.\n\n        By default (with ``ann_id=None``), subfolders are shown for all\n        anonymous users. Optionally, ``ann_id`` can be set to a username,\n        which restricts the list to only subfolders owned by that user.\n\n        :param str folder_id: Folder id\n        :param str subfolder_id: Subfolder id\n        :param str ann_id: Username\n        :rtype: ``dict`` of ``content_id |--> [subtopic_id]``\n        '''\n        d = defaultdict(list)\n        for cid, subid in self.items(folder_id, subfolder_id, ann_id=ann_id):\n            d[cid].append(subid)\n        return d", "response": "Returns a dictionary from content ids to subtopic ids."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_folder(self, folder_id, ann_id=None):\n        '''Add a folder.\n\n        If ``ann_id`` is set, then the folder is owned by the given user.\n        Otherwise, the folder is owned and viewable by all anonymous\n        users.\n\n        :param str folder_id: Folder id\n        :param str ann_id: Username\n        '''\n        self.assert_valid_folder_id(folder_id)\n        ann_id = self._annotator(ann_id)\n        cid = self.wrap_folder_content_id(ann_id, folder_id)\n        self.store.put([(cid, FeatureCollection())])\n        logger.info('Added folder %r with content id %r', folder_id, cid)", "response": "Add a folder.\n\n        If ``ann_id`` is set, then the folder is owned by the given user.\n        Otherwise, the folder is owned and viewable by all anonymous\n        users.\n\n        :param str folder_id: Folder id\n        :param str ann_id: Username"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_item(self, folder_id, subfolder_id, content_id, subtopic_id=None,\n                 ann_id=None):\n        '''Add an item to a subfolder.\n\n        The format of ``content_id`` and ``subtopic_id`` is\n        unspecified. It is application specific.\n\n        If ``ann_id`` is set, then the item is owned by the given user.\n        Otherwise, the item is owned and viewable by all anonymous\n        users.\n\n        :param str folder_id: Folder id\n        :param str subfolder_id: Folder id\n        :param str content_id: content identifier\n        :param str subtopic_id: subtopic identifier\n        :param str ann_id: Username\n        '''\n        self.assert_valid_folder_id(folder_id)\n        self.assert_valid_folder_id(subfolder_id)\n        ann_id = self._annotator(ann_id)\n        folder_cid = self.wrap_folder_content_id(ann_id, folder_id)\n        subfolder_sid = self.wrap_subfolder_subtopic_id(subfolder_id)\n\n        if self.store.get(folder_cid) is None:\n            raise KeyError(folder_id)\n\n        lab = Label(folder_cid, content_id,\n                    ann_id, CorefValue.Positive,\n                    subtopic_id1=subfolder_sid,\n                    subtopic_id2=subtopic_id)\n        self.label_store.put(lab)\n        logger.info('Added subfolder item: %r', lab)", "response": "Add an item to a subfolder."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef status(self, *args, **kwargs):\n        resp = {}\n        available = True\n        fail_count = 0\n\n        for component_name, checker in self._component_checkers.items():\n            status_data = self._check_status(checker, self.read_exception, *args, **kwargs)\n            status_data['status'] = self._status_english(status_data['available'])\n            available = available and status_data['available']\n            if not status_data['available']:\n                fail_count += 1\n            resp[component_name] = status_data\n\n        return dict(status=self._status_english(available),\n                    available=available,\n                    components=resp,\n                    failure_count=fail_count)", "response": "This method returns a dictionary that contains the status of all the components in the cluster."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_status(func, read_exception, *args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            _LOG.exception(e)\n            message = str(e) if read_exception else 'An error occurred while checking the status'\n            return dict(message=message, available=False)", "response": "Calls the function with the args and returns the status of the key - value pair."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse command line arguments.", "response": "def parse_args():\n  \"\"\"Parses command line arguments.\"\"\"\n  parser = ArgumentParser(description=\"ModelBase builder\")\n  subparsers = parser.add_subparsers()\n\n  sql_parser = subparsers.add_parser(\n    \"get-query\",\n    description=\"Usage: e.g. psql -c \\\"copy ($(python3 lib/generate_models.py get-query)) to \" +\n                \"stdout with csv header\\\" DB_NAME postgres\")\n  sql_parser.set_defaults(func=print_sql_query)\n\n  gen_parser = subparsers.add_parser(\"generate\")\n  gen_parser.add_argument(\"filename\", nargs=\"?\", help=\"Read this file for input, or STDIN if not \" \\\n                                                      \"given\")\n  gen_parser.add_argument(\"-i\", \"--indent\", default=\"  \")\n  gen_parser.add_argument(\"-c\", \"--created-at-col-name\", default=\"created_at\")\n  gen_parser.add_argument(\"-u\", \"--updated-at-col-name\", default=\"updated_at\")\n  gen_parser.set_defaults(func=generate_models)\n\n  args = parser.parse_args()\n\n  if hasattr(args, \"func\"):\n    return args\n  else:\n    arg_parser.print_help()\n    sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_models(args):\n  data_table = get_data_table(args.filename)\n  tables = to_tables(data_table.rows_to_dicts())\n  attr_indent = \"\\n\" + args.indent * 2\n  attr_sep = \",\" + attr_indent\n\n  for tname, cols in tables.items():\n    model_name = table_to_model_name(tname, list(cols.values())[0][\"table_schema\"])\n    pk_cols, oth_cols = split_pks(cols)\n    timestamps = get_timestamps(cols, args.created_at_col_name, args.updated_at_col_name)\n    is_auto = len(pk_cols) == 1 and cols[pk_cols[0]][\"is_auto\"] == \"t\"\n\n    attrs = OrderedDict()\n    for cname in oth_cols:\n      if cname not in timestamps:\n        attrs[cname] = None\n\n    print(_MODEL_SOURCE.format(\n      class_name=model_name,\n      base_class_name=\"ModelBase\",\n      indent=args.indent,\n      table_name=repr(tname),\n      pk_name=repr(pk_cols[0] if len(pk_cols) == 1 else pk_cols),\n      pk_is_auto=is_auto,\n      timestamps=timestamps,\n      attrs=\"dict(\" + attr_indent + attr_sep.join(\"{0}={1}\".format(k, v) for k, v in attrs.items()) + \")\"))\n    print()", "response": "Generates models from the script input."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a DataTable instance built from either the filename or STDIN.", "response": "def get_data_table(filename):\n  \"\"\"Returns a DataTable instance built from either the filename, or STDIN if filename is None.\"\"\"\n  with get_file_object(filename, \"r\") as rf:\n    return DataTable(list(csv.reader(rf)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_tables(cols):\n  tables = OrderedDict()\n  for col in cols:\n    tname = col[\"table_name\"]\n    if tname not in tables:\n      tables[tname] = OrderedDict()\n    tables[tname][col[\"column_name\"]] = col\n  return tables", "response": "Builds and returns a Dictionary whose keys are table names and values are OrderedDicts whose keys are column names and values are the col objects from which the definition is derived."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef snake_to_pascal(name, singularize=False):\n  parts = name.split(\"_\")\n  if singularize:\n    return \"\".join(p.upper() if p in _ALL_CAPS else to_singular(p.title()) for p in parts)\n  else:\n    return \"\".join(p.upper() if p in _ALL_CAPS else p.title() for p in parts)", "response": "Converts snake_case to PascalCase."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nattempt to singularize a word.", "response": "def to_singular(word):\n  \"\"\"Attempts to singularize a word.\"\"\"\n  if word[-1] != \"s\":\n    return word\n  elif word.endswith(\"ies\"):\n    return word[:-3] + \"y\"\n  elif word.endswith(\"ses\"):\n    return word[:-2]\n  else:\n    return word[:-1]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a 2 - tuple of tuples of ( primary_key_cols non_primary_key_cols ).", "response": "def split_pks(cols):\n  \"\"\"Returns a 2-tuple of tuples of ((primary_key_cols), (non_primary_key_cols)).\"\"\"\n  pks = []\n  others = []\n  for name, col in cols.items():\n    if col[\"is_primary_key\"] == \"t\":\n      pks.append(name)\n    else:\n      others.append(name)\n\n  return (tuple(pks), tuple(others))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_timestamps(cols, created_name, updated_name):\n  has_created = created_name in cols\n  has_updated = updated_name in cols\n  return (created_name if has_created else None, updated_name if has_updated else None)", "response": "Returns a 2 - tuple of the timestamp columns that were found on the table definition."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pull_from_origin(repo_path):\n    LOG.info(\"Pulling from origin at %s.\" % repo_path)\n    command = GIT_PULL_CMD.format(repo_path)\n    resp = envoy.run(command)\n    if resp.status_code != 0:\n        LOG.exception(\"Pull failed.\")\n        raise GitException(resp.std_err)\n    else:\n        LOG.info(\"Pull successful.\")", "response": "Execute git pull at the provided repo_path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the remote origin URL from the given git repo.", "response": "def read_remote_origin(repo_dir):\n    \"\"\"Read the remote origin URL from the given git repo, or None if unset.\"\"\"\n    conf = ConfigParser()\n    conf.read(os.path.join(repo_dir, '.git/config'))\n    return conf.get('remote \"origin\"', 'url')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clone_from(repo_url, repo_dir):\n    repo_url = _fix_repo_url(repo_url)\n    LOG.info(\"Cloning %s into %s.\" % (repo_url, repo_dir))\n    cmd = GIT_CLONE_CMD.format(repo_url, repo_dir)\n    resp = envoy.run(cmd)\n    if resp.status_code != 0:\n        LOG.error(\"Cloned failed: %s\" % resp.std_err)\n        raise GitException(resp.std_err)\n    LOG.info(\"Clone successful.\")", "response": "Clone a remote git repo into a local directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfixes the repo URL if not set.", "response": "def _fix_repo_url(repo_url):\n    \"\"\"Add empty credentials to a repo URL if not set, but only for HTTP/HTTPS.\n\n       This is to make git not hang while trying to read the username and\n       password from standard input.\"\"\"\n    parsed = urlparse.urlparse(repo_url)\n    \n    if parsed.scheme not in ('http', 'https'):\n        # Fix only for http and https.\n        return repo_url\n\n    username = parsed.username or \"\"\n    password = parsed.password or \"\"\n    port = \":\" + parsed.port if parsed.port else \"\"\n    netloc = \"\".join((username, \":\", password, \"@\", parsed.hostname, port))\n    part_list = list(parsed)\n    part_list[1] = netloc\n    return urlparse.urlunparse(part_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates test dependencies First do a topological sorting based on the dependencies. Then sort the different dependency groups based on priorities.", "response": "def calculate_dependencies():\n        \"\"\"Calculate test dependencies\n        First do a topological sorting based on the dependencies.\n        Then sort the different dependency groups based on priorities.\n        \"\"\"\n        order = []\n        for group in toposort(dependencies):\n            priority_sorted_group = sorted(group, key=lambda x: (priorities[x], x))\n            order.extend(priority_sorted_group)\n\n        return order"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an error string if any of the dependencies failed", "response": "def dependency_failed(test, results):\n        \"\"\"Returns an error string if any of the dependencies failed\"\"\"\n        for d in (NoseDepUtils.test_name(i) for i in dependencies[test]):\n            if results.get(d) and results.get(d) != 'passed':\n                return \"Required test '{}' {}\".format(d, results.get(d).upper())\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef survey_cadence_arrays(\n        log,\n        surveyCadenceSettings,\n        pathToOutputDirectory,\n        pathToOutputPlotDirectory,\n        plot=False):\n    \"\"\"\n    *Generate the survey cadence arrays for each filter*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``surveyCadenceSettings`` -- the survey cadence parameters as set in the simulation settings file\n        - ``pathToOutputDirectory`` -- path to the output directory (provided by the user)\n        - ``pathToOutputPlotDirectory`` -- path to add plots to\n        - ``plot`` -- generate plot?\n\n    **Return:**\n        - ``cadenceDictionary`` -- a dictionary of { band : observedDayList }\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    ## LOCAL APPLICATION ##\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    ################ > VARIABLE SETTINGS ######\n    lunarMonth = 29.3\n    surveyYear = 12. * lunarMonth\n    ################ >ACTION(S) ################\n    cadenceDictionary = {}\n    obsFraction = surveyCadenceSettings['Observable Fraction of Year']\n    lossFraction = surveyCadenceSettings[\n        'Fraction of Year Lost to Weather etc']\n    for thisFilter in surveyCadenceSettings['Filters']:\n        # READ THE CADENCE PARAMETERS\n        band = thisFilter['band']\n        firstDay = thisFilter['day of year of first scheduled observation']\n        repeatEvery = thisFilter['repeat every ? days']\n        moonFraction = thisFilter['Fraction of Lunar Month Lost to Moon']\n\n        # DETERMINE DAYS LOST DUE TO MOON CYCLE\n        finalObsDayOfMonth = lunarMonth * (1. - moonFraction)\n        monthCount = 0\n        day = 1\n        monthDay = 1\n        moonDayList = []\n        while day < surveyYear:\n            while monthDay < int(lunarMonth):\n                if monthDay <= finalObsDayOfMonth:\n                    moonDayList.append(day)\n                monthDay += 1\n                day += 1\n            monthCount += 1\n            day = int(lunarMonth * monthCount)\n            # log.debug('month # %s starts on day %s' % (monthCount, day))\n            monthDay = 0\n\n        # DETERMINE THE DAYS THE TELESCOPE OBSERVES IN THIS FILTER\n        day = firstDay\n        nextObs = firstDay\n        obsDaysList = []\n        finalObsDayOfYear = obsFraction * surveyYear\n        while day <= finalObsDayOfYear:\n            randNum = np.random.rand()\n            if day == nextObs:\n                if day in moonDayList and randNum > lossFraction:\n                    obsDaysList.append(day)\n                nextObs = day + repeatEvery\n            day += 1\n            # log.debug('day # %s' % (day,))\n\n        # ADD THE BAND & OBS ARRAY TO THE DICTIONARY\n        cadenceDictionary[band] = obsDaysList\n\n    if plot:\n        fig = plt.figure(\n            num=None,\n            figsize=(8, 8),\n            dpi=600,\n            facecolor=None,\n            edgecolor=None,\n            frameon=True)\n\n        ax = fig.add_axes(\n            [0.1, 0.1, 0.8, 0.8],\n            polar=True,\n            frameon=False)\n        # ax.set_xlabel('label')\n        # ax.set_ylabel('label')\n        # ax.set_title('title')\n        # ax.set_xlim(0, 10)\n        ax.set_ylim(0, 12)\n\n        for k, v in cadenceDictionary.iteritems():\n            # log.debug('k %s' % (k,))\n            x = 2 * np.pi * np.array(v) / surveyYear\n            y = np.ones(len(x)) * 10.\n\n            if k in ['g', 'B']:\n                color = '#268bd2'\n            elif k in ['r', 'V']:\n                color = '#859900'\n            elif k in ['R', 'i']:\n                color = '#cb4b16'\n            elif k in ['I', 'z']:\n                color = '#dc322f'\n            # elif k in ['', '']\n            #     color = ''\n            else:\n                color = '#b58900'\n\n            plt.scatter(\n                x,\n                y,\n                s=50,\n                c=color,\n                marker='o',\n                cmap=None,\n                norm=None,\n                vmin=None,\n                vmax=None,\n                alpha=0.5,\n                linewidths=None,\n                edgecolor='w',\n                verts=None,\n                hold=True)\n\n        circleTicks = np.arange(0, 350, 30)\n        tickLabels = []\n        for tick in circleTicks:\n            tickLabels.append(\"%s days\" % (tick,))\n\n        plt.xticks(2 * np.pi * circleTicks / surveyYear, tickLabels)\n        plt.yticks([])\n\n        title = \"Cadence Wheel for Simulated Survey\"\n        plt.title(title)\n        fileName = pathToOutputPlotDirectory + title.replace(\" \", \"_\") + \".png\"\n        plt.savefig(fileName)\n        plt.clf()  # clear figure\n\n    return cadenceDictionary", "response": "Generate the survey cadence arrays for the given species."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef determine_if_sne_are_discoverable(\n        log,\n        redshiftArray,\n        limitingMags,\n        observedFrameLightCurveInfo,\n        pathToOutputDirectory,\n        pathToOutputPlotDirectory,\n        plot=True):\n    \"\"\"\n    *Given the observe frame lightcurve, determine if the SNe are discoverable by the survey or not.*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``redshiftArray`` -- the array of random redshifts\n        - ``observedFrameLightCurveInfo`` -- the observed franme lightcurve info (dictionary)\n        - ``pathToOutputDirectory`` -- path to the output directory (provided by the user)\n        - ``pathToOutputPlotDirectory`` -- path to add plots to\n        - ``plot`` -- generate plots?\n\n    **Return:**\n        - ``discoverableList`` -- a list of dictionaries describing if the object is discoverable in each filter and finally if it is discoverable in any filter.\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    import numpy as np\n    import matplotlib.pyplot as plt\n    ## LOCAL APPLICATION ##\n    import dryxPython.plotting as dp\n\n    ################ >ACTION(S) ################\n    filters = ['g', 'r', 'i', 'z']\n    models = ['he80', 'he100', 'he130']\n\n    discoverableList = []\n    for i in range(len(observedFrameLightCurveInfo)):\n        discoveryDict = {}\n        for ffilter in filters:\n            if observedFrameLightCurveInfo[i]['peakMags'][ffilter] > limitingMags[ffilter]:\n                discoveryDict[ffilter] = False\n            else:\n                discoveryDict[ffilter] = True\n        discoveryDict['any'] = False\n        for k, v in discoveryDict.iteritems():\n            if v is True:\n                discoveryDict['any'] = True\n                break\n\n        discoverableList.append(discoveryDict)\n\n    maxVal = np.max(redshiftArray) * 1.1\n\n    if plot:\n        hitList = []\n        missList = []\n        faintList = []\n        for i in range(len(discoverableList)):\n            discoveryDict = discoverableList[i]\n            if discoveryDict['any'] is True:\n                hitList.append(redshiftArray[i])\n            else:\n                missList.append(redshiftArray[i])\n\n        hitArray = np.array(hitList)\n        missArray = np.array(missList)\n        faintArray = np.array(faintList)\n\n        dataDictionary = {'Discoverable': hitArray,\n                          'Undiscoverable': missArray}\n        plot_polar(\n            log,\n            title=\"Discoverable SN Redshift Distribution\",\n            dataDictionary=dataDictionary,\n            pathToOutputPlotsFolder=pathToOutputPlotDirectory,\n            dataRange=False,\n            ylabel=False,\n            radius=maxVal,\n            circumference=False,\n            prependNum=False)\n\n    return discoverableList", "response": "This function determines if the SNe is discoverable by the survey or not."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef determine_when_sne_are_ripe_for_discovery(\n        log,\n        redshiftArray,\n        limitingMags,\n        observedFrameLightCurveInfo,\n        discoverableList,\n        plot=True):\n    \"\"\"\n    *Given the observe frame lightcurve, determine if the SNe are discoverable by the survey or not.*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``redshiftArray`` -- the array of random redshifts\n        - ``observedFrameLightCurveInfo`` -- the observed franme lightcurve info (dictionary)\n        - ``discoverableList`` -- a list of dictionaries describing if the object is discoverable in each filter and finally if it is discoverable in any filter.\n        - ``plot`` -- generate plots?\n\n    **Return:**\n        - ``ripeDayList`` -- a list of dictionaries describing the time relative to peak that the SN reaches the limiting mag of the survey\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    import math\n    ## THIRD PARTY ##\n    ## LOCAL APPLICATION ##\n\n    ################ >ACTION(S) ################\n    filters = ['g', 'r', 'i', 'z']\n    models = ['he80', 'he100', 'he130']\n\n    ripeDayList = []\n    for item in range(len(redshiftArray)):\n        #log.info(\"I AM HERE %s\" % (item,))\n        ripeDayDict = {}\n        if not discoverableList[item][\"any\"]:\n            ripeDayDict[\"any\"] = False\n            for ffilter in filters:\n                ripeDayDict[ffilter] = False\n        else:\n            for ffilter in filters:\n                if not discoverableList[item][ffilter]:\n                    ripeDayDict[ffilter] = False\n                elif observedFrameLightCurveInfo[item]['lightCurves'][ffilter] is None:\n                    ripeDayDict[ffilter] = False\n                else:\n                    explosionDay = observedFrameLightCurveInfo[\n                        item]['explosionDay']\n                    lowerLimit = explosionDay\n                    upperLimit = 0.\n                    ripeDay = lowerLimit\n                    magGuess = observedFrameLightCurveInfo[\n                        item]['lightCurves'][ffilter](ripeDay)\n                    magDiff = limitingMags[ffilter] - magGuess\n\n                    if magGuess > limitingMags[ffilter]:\n                        while math.fabs(magDiff) > 0.01:\n                            if magGuess > limitingMags[ffilter]:\n                                #log.info('item %s ripeDay %s magGuess %s - going higher' % (item, ripeDay, magGuess))\n                                lowerLimit = ripeDay\n                                ripeDay = lowerLimit + \\\n                                    (upperLimit - lowerLimit) / 2.\n                                magGuess = observedFrameLightCurveInfo[\n                                    item]['lightCurves'][ffilter](ripeDay)\n                            elif magGuess < limitingMags[ffilter]:\n                                #log.info('item %s ripeDay %s' % (item, ripeDay))\n                                upperLimit = ripeDay\n                                ripeDay = lowerLimit + \\\n                                    (upperLimit - lowerLimit) / 2.\n                                magGuess = observedFrameLightCurveInfo[\n                                    item]['lightCurves'][ffilter](ripeDay)\n                            magDiff = limitingMags[ffilter] - magGuess\n\n                    ripeDay = float(\"%5.3f\" % (ripeDay,))\n                    # log.info('SN#%s, filter %s, ripeDay %s' % (item, ffilter,\n                    # ripeDay,))\n                    ripeDayDict[ffilter] = ripeDay\n            ripeDayDict[\"any\"] = False\n            for ffilter in filters:\n                if ripeDayDict[ffilter]:\n                    ripeDayDict[\"any\"] = True\n        ripeDayList.append(ripeDayDict)\n\n    # log.info('ripeDayList %s' % (ripeDayList,))\n\n    return ripeDayList", "response": "This function determines when the SNe is discoverable by the survey or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a routing rule", "response": "def route(method, pattern, handler=None):\n    \"\"\"register a routing rule\n\n    Example:\n\n         route('GET', '/path/<param>', handler)\n\n    \"\"\"\n    if handler is None:\n        return partial(route, method, pattern)\n    return routes.append(method, pattern, handler)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef spawn(self, owner, *args, **kwargs):\n        return (self._spawn(owner, self.factory, *args, **kwargs)\n                if self.factory else\n                self._spawn(owner, *args, **kwargs))", "response": "Spawns a new subordinate actor of owner and stores it in this container."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwatching the directory for changes. Automatically run tests.", "response": "def watch(ctx):\n    \"\"\"Watch the directory for changes. Automatically run tests.\n    \"\"\"\n    vcs = ctx.obj['vcs']\n\n    event_handler = TestsEventHandler(vcs)\n\n    observer = Observer()\n    observer.schedule(event_handler, vcs.path, recursive=True)\n    observer.start()\n    click.echo('Watching directory `{path}`. Use ctrl-c to stop.'.format(path=vcs.path))\n    while observer.isAlive():\n        observer.join(timeout=1)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwaiting for the thread to finish and return the value returned by the target function.", "response": "def join(self, timeout=None):\n        \"\"\"\n        Wait for the thread to finish, may raise an\n        exception (if any is uncaught during execution),\n        and return the value returned by the target\n        function.\n        \"\"\"\n        rv = self.thread.join(timeout)\n        if self.err:\n            raise self.err\n        return self.val"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef settings(request=None):\n    from yacms.conf import settings\n\n    allowed_settings = settings.TEMPLATE_ACCESSIBLE_SETTINGS\n\n    template_settings = TemplateSettings(settings, allowed_settings)\n    template_settings.update(DEPRECATED)\n\n    # This is basically the same as the old ADMIN_MEDIA_PREFIX setting,\n    # we just use it in a few spots in the admin to optionally load a\n    # file from either grappelli or Django admin if grappelli isn't\n    # installed. We don't call it ADMIN_MEDIA_PREFIX in order to avoid\n    # any confusion.\n    admin_prefix = \"grappelli/\" if settings.GRAPPELLI_INSTALLED else \"admin/\"\n    template_settings[\"YACMS_ADMIN_PREFIX\"] = admin_prefix\n\n    return {\"settings\": template_settings}", "response": "Returns the settings object for the current template context."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate(self, value):\n        \"Check if value consists only of valid emails.\"\n\n        # Use the parent's handling of required fields, etc.\n        super(MultiEmailField, self).validate(value)\n\n        for email in value:\n            validate_email(email)", "response": "Check if value consists only of valid emails."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions to create a logfile name for the current script.", "response": "def log_file_name(ext=False):\n  \"\"\"\n  Function : Creates a logfile name, named after this script and includes the number of seconds since the Epoch.\n             An optional extension can be specified to make the logfile name more meaningful regarding its purpose.\n  Args     : ext - The extension to add to the log file name to indicate its purpose, i.e. ERR for error messages.\n  Returns  : str.\n  \"\"\"\n  script_name = os.path.splitext(os.path.basename(sys.argv[0]))[0]\n  val = script_name + \"_\" + str(int(time.time())) + \"_LOG\"\n  if ext:\n    val += \"_\" + ext\n  val += \".txt\"\n  return val"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlist all programs that belong to the authenticated user", "response": "def list(options):\n    \"\"\"\n    list programs that belong to the authenticated user\n\n    \"\"\"\n    configuration = config.get_default()\n    app_url = configuration['app_url']\n\n    if options.deployment != None:\n        deployment_name = options.deployment\n    else:\n        deployment_name = configuration['deployment_name']\n\n    client_id = configuration['client_id']\n    client_secret = configuration['client_secret']\n\n    token_manager = auth.TokenManager(client_id=client_id,\n                                      client_secret=client_secret,\n                                      app_url=app_url)\n\n    if options.all == True:\n        account_id = None\n\n    else:\n        account_id = accounts.get_logged_in_account_id(token_manager=token_manager,\n                                                       app_url=app_url)\n\n    programs_details = programs.get_programs(deployment_name,\n                                             token_manager=token_manager,\n                                             created_by=account_id,\n                                             app_url=app_url)\n\n    account_ids = set()\n    for program in programs_details:\n        account_ids.add(program['createdBy'])\n\n    accounts_details = accounts.get_accounts(account_ids,\n                                             token_manager=token_manager,\n                                             app_url=app_url)\n\n    account_lookup = {}\n    for account in accounts_details['accounts']:\n        account_lookup[account['id']] = account\n\n    headers = ['Name', 'Last Saved', 'Created By']\n    table = []\n\n    for program in programs_details:\n        username = account_lookup[program['createdBy']]['username']\n        program_name = program['name']\n        last_edited = program['lastEdited']\n        table.append([program_name, last_edited, username])\n\n    if options.format == 'table':\n        info(tabulate.tabulate(table, headers, tablefmt='orgtbl'))\n\n    elif options.format == 'text':\n        info(tabulate.tabulate(table, headers, tablefmt='orgtbl', stralign='center'))\n\n    else:\n        raise JutException('Unsupported format \"%s\"' % options.format)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npulling all remote programs to a local directory", "response": "def pull(options):\n    \"\"\"\n    pull all remote programs to a local directory\n\n    \"\"\"\n    configuration = config.get_default()\n    app_url = configuration['app_url']\n\n    if options.deployment != None:\n        deployment_name = options.deployment\n    else:\n        deployment_name = configuration['deployment_name']\n\n    client_id = configuration['client_id']\n    client_secret = configuration['client_secret']\n\n    token_manager = auth.TokenManager(client_id=client_id,\n                                      client_secret=client_secret,\n                                      app_url=app_url)\n\n    if options.all == True:\n        account_id = None\n\n    else:\n        account_id = accounts.get_logged_in_account_id(token_manager=token_manager,\n                                                       app_url=app_url)\n\n    programs_details = programs.get_programs(deployment_name,\n                                             token_manager=token_manager,\n                                             created_by=account_id,\n                                             app_url=app_url)\n\n    if not os.path.exists(options.directory):\n        os.mkdir(options.directory)\n\n    account_ids = set()\n    for program in programs_details:\n        account_ids.add(program['createdBy'])\n\n    accounts_details = accounts.get_accounts(account_ids,\n                                             token_manager=token_manager,\n                                             app_url=app_url)\n\n    account_lookup = {}\n    for account in accounts_details['accounts']:\n        account_lookup[account['id']] = account\n\n    decision = None\n    for program in programs_details:\n        program_name = program['name']\n        juttle_filename = '%s.juttle' % escape_filename(program_name)\n\n        if options.per_user_directory:\n            username = account_lookup[program['createdBy']]['username']\n            userdir = os.path.join(options.directory, username)\n\n            if not os.path.exists(userdir):\n                os.mkdir(userdir)\n\n            juttle_filepath = os.path.join(userdir, juttle_filename)\n\n        else:\n            juttle_filepath = os.path.join(options.directory, juttle_filename)\n\n        if os.path.exists(juttle_filepath) and decision != 'A':\n            program_code = None\n            with codecs.open(juttle_filepath, 'r', encoding='UTF-8') as program_file:\n                program_code = program_file.read()\n\n            local_last_edited = int(os.stat(juttle_filepath).st_mtime)\n            remote_last_edited = dates.iso8601_to_epoch(program['lastEdited'])\n\n            if local_last_edited != remote_last_edited:\n                info('Juttle changed since last pull for \"%s\"' % program_name)\n                decision = console.prompt('Would you like to '\n                                          '(O - Override,'\n                                          ' S - Skip,'\n                                          ' R - Review Changes,'\n                                          ' A - override All)?')\n\n                if decision == 'R':\n                    info('Following is what would change if we overrode using your copy:')\n                    info('*'*80)\n                    for line in difflib.ndiff(program['code'].split('\\n'),\n                                              program_code.split('\\n')):\n                        info(line)\n                    info('*'*80)\n                    decision = console.prompt('Would you like to '\n                                              '(O - Override,'\n                                              ' S - Skip)?')\n\n                if decision == 'S':\n                    # jump to the next file\n                    continue\n\n                elif decision == 'O':\n                    pass\n\n                elif decision == 'A':\n                    pass\n\n                else:\n                    raise JutException('Unexpected option \"%s\"' % decision)\n\n        info('importing program \"%s\" to %s' % (program['name'], juttle_filepath))\n        with codecs.open(juttle_filepath, 'w', encoding='UTF-8') as program_file:\n            program_file.write(program['code'])\n\n        # update creation time to match the lastEdited field\n        epoch = dates.iso8601_to_epoch(program['lastEdited'])\n        os.utime(juttle_filepath, (epoch, epoch))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate an image group at given SCO - API by uploading a local file to the given url.", "response": "def create(url, filename, options, properties):\n        \"\"\"Create new image group at given SCO-API by uploading local file.\n        Expects an tar-archive containing images in the image group. Allows to\n        update properties of created resource.\n\n        Parameters\n        ----------\n        url : string\n            Url to POST image group create request\n        filename : string\n            Path to tar-archive on local disk\n        options : Dictionary, optional\n            Values for image group options. Argument may be None.\n        properties : Dictionary\n            Set of additional properties for image group (may be None)\n\n        Returns\n        -------\n        string\n            Url of created image group resource\n        \"\"\"\n        # Ensure that the file has valid suffix\n        if not has_tar_suffix(filename):\n            raise ValueError('invalid file suffix: ' + filename)\n        # Upload file to create image group. If response is not 201 the uploaded\n        # file is not a valid tar file\n        files = {'file': open(filename, 'rb')}\n        response = requests.post(url, files=files)\n        if response.status_code != 201:\n            raise ValueError('invalid file: ' + filename)\n        # Get image group HATEOAS references from successful response\n        links = references_to_dict(response.json()['links'])\n        resource_url = links[REF_SELF]\n        # Update image group options if given\n        if not options is None:\n            obj_ops = []\n            # Catch TypeErrors if properties is not a list.\n            try:\n                for opt in options:\n                    obj_ops.append({'name' : opt, 'value' : options[opt]})\n            except TypeError as ex:\n                raise ValueError('invalid option set')\n            try:\n                req = urllib2.Request(links[REF_UPDATE_OPTIONS])\n                req.add_header('Content-Type', 'application/json')\n                response = urllib2.urlopen(\n                    req,\n                    json.dumps({'options' : obj_ops})\n                )\n            except urllib2.URLError as ex:\n                raise ValueError(str(ex))\n        # Update image group properties if given\n        if not properties is None:\n            obj_props = []\n            # Catch TypeErrors if properties is not a list.\n            try:\n                for key in properties:\n                    obj_props.append({'key':key, 'value':properties[key]})\n            except TypeError as ex:\n                raise ValueError('invalid property set')\n            try:\n                req = urllib2.Request(links[REF_UPSERT_PROPERTIES])\n                req.add_header('Content-Type', 'application/json')\n                response = urllib2.urlopen(\n                    req,\n                    json.dumps({'properties' : obj_props})\n                )\n            except urllib2.URLError as ex:\n                raise ValueError(str(ex))\n        return resource_url"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if passed m - function is indeed a valid m - function.", "response": "def check_m(pm):\n    '''\n    Shared helper function for all :ref:`tools` to check if the passed\n    m-function is indeed :func:`photon.Photon.m`\n\n    :params pm:\n        Suspected m-function\n    :returns:\n        Now to be proven correct m-function,\n        tears down whole application otherwise.\n    '''\n\n    if not any([\n        callable(pm),\n        pm.__name__ != Photon.m.__name__,\n        pm.__doc__ != Photon.m.__doc__\n    ]):\n        shell_notify(\n            'wrong \"m-function\" passed!',\n            state=True,\n            more=pm.__name__\n        )\n    return pm"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef m(self, msg,\n          state=False, more=None, cmdd=None, critical=True, verbose=None):\n        '''\n        Mysterious mega method managing multiple meshed modules magically\n\n        .. note:: If this function is used, the code contains facepalms: ``m(``\n\n        * It is possible to just show a message, \\\n        or to run a command with message.\n\n        * But it is not possible to run a command without a message, \\\n        use the `verbose`-flag to hide your debug message.\n\n        :param msg:\n            Add a message. Shown depending on `verbose` (see below)\n        :param state:\n            Pass `state` down to :func:`util.system.shell_notify`\n        :param more:\n            Pass `more` down to :func:`util.system.shell_notify`\n        :param dict cmdd:\n            If given, :func:`util.system.shell_run` is launched with\n            it's values\n        :param critical:\n            If set to ``True``: |appteardown| on failure of `cmdd` contents.\n\n            * Similar to :func:`util.system.shell_run` `critical`-flag\n\n        :param verbose:\n            Overrules parent's class `verbose`-flag.\n\n            * If left to ``None``, the verbose value Photon \\\n            was started with is used\n\n            * Messages are shown/hidden if explicitly set to ``True``/``False``\n\n        :returns:\n            A dictionary specified the following:\n\n            * 'more':\n                `more` if it is not a dictionary otherwise \\\n                it gets merged in if `more` is specified\n\n            * The output of :func:`util.system.shell_run` gets merged in \\\n            if `cmdd` is specified\n\n            * 'failed': ``True`` if command failed\n\n            :func:`util.system.shell_notify` is used with this dictionary\n            to pipe it's output into :func:`meta.Meta.log` before returning.\n        '''\n\n        if verbose is None:\n            verbose = self.__verbose\n\n        res = dict()\n        if more:\n            res.update(more if isinstance(more, dict) else dict(more=more))\n\n        if cmdd and isinstance(cmdd, dict) and cmdd.get('cmd'):\n            res.update(shell_run(\n                cmdd.get('cmd'),\n                cin=cmdd.get('cin'),\n                cwd=cmdd.get('cwd'),\n                timeout=cmdd.get('timeout', 120),\n                critical=False,\n                verbose=cmdd.get('verbose', verbose)\n            ))\n\n            if res.get('returncode', -1) != 0:\n                res.update(dict(failed=True))\n\n        if state or critical and res.get('failed'):\n            self.meta.log = dict(message=msg, more=res, verbose=verbose)\n            shell_notify(msg, more=res, state=True)\n        self.meta.log = shell_notify(msg, more=res,\n                                     state=state, verbose=verbose)\n        return res", "response": "Mysterious mega method managing multiple meshed modules."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nimports settings to meta", "response": "def s2m(self):\n        '''\n        Imports settings to meta\n        '''\n\n        m = '%s settings' % (IDENT)\n        self.meta.load(m, 'import %s' % (m), mdict=self.settings.get)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new mail handler for the given naculian s log entry.", "response": "def mail_handler(self,\n                     punchline=None, add_meta=False, add_settings=True,\n                     *args, **kwargs):\n        '''\n        :param punchline:\n            Adds a punchline before further text\n        :param add_meta:\n            Appends current meta to the mail\n        :param add_settings:\n            Appends current settings to the mail\n        :returns:\n            A new mail handler\n\n        .. seealso:: :ref:`tools_mail`\n        '''\n\n        m = Mail(self.m, *args, **kwargs)\n        if punchline:\n            m.text = '-> %s <-' % (punchline)\n        if add_meta:\n            m.text = self.meta.log\n        if add_settings:\n            m.text = self.settings.get\n        return m"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef file_to_base64(path_or_obj, max_mb=None):\n    if not hasattr(path_or_obj, 'read'):\n        rt = read_file(path_or_obj)\n    else:\n        rt = path_or_obj.read()\n    if max_mb:\n        len_mb = len(rt) / (10024.0 * 1000)\n        if len_mb > max_mb:\n            raise ErrorFileTooBig(\"File is too big ({.2f} MBytes)\" (len_mb))\n    return b64encode(rt)", "response": "converts contents of a file to base64 encoding"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dict_clip(a_dict, inlude_keys_lst=[]):\n    return dict([[i[0], i[1]] for i in list(a_dict.items()) if i[0] in inlude_keys_lst])", "response": "returns a new dict with keys not in included in inlude_keys_lst clipped off"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_pp(ll, separator='|', header_line=True, autonumber=True):\n    if autonumber:\n        for cnt, i in enumerate(ll):\n            i.insert(0, cnt if cnt > 0 or not header_line else '#')\n\n    def lenlst(l):\n        return [len(str(i)) for i in l]\n\n    lst_len = [lenlst(i) for i in ll]\n    lst_rot = zip(*lst_len[::-1])\n    lst_len = [max(i) for i in lst_rot]\n    frmt = separator + separator.join([\"{!s:\"+str(i)+\"}\" for i in lst_len]) + separator\n    if header_line:\n        header_line = '-' * len(frmt.format(*ll[0]))\n    for cnt, l in enumerate(ll):\n        if cnt < 2 and header_line:\n            print(header_line)\n        print(frmt.format(*l))\n    if header_line:\n        print(header_line)\n    return lst_len", "response": "pretty print list of lists ll"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an id that is expanded with the id of the object.", "response": "def obj_id_expanded(obj=None, size=99):\n    \"\"\"\n    :param obj (objectj): optional\n    :param size (int): optional size of id(obj) to include defaults to 99\n\n    :Returns: id: (str) an id that of the form machine-name|ppid|pid|id(obj)\n    \"\"\"\n    return \"{}|{}|{}{}\".format(os.uname()[1], os.getppid(), os.getpid(), \"\" if obj is None else \"|\" + str(id(obj))[-size:])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a directory ignoring errors if it already exists.", "response": "def _safe_mkdir(directory):\n    \"\"\"Create a directory, ignoring errors if it already exists.\"\"\"\n    try:\n        os.makedirs(directory)\n    except OSError as error:\n        if error.errno != errno.EEXIST:\n            raise error"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstoring the repr of the return value of func in stampfile.", "response": "def _stamp(stampfile, func, *args, **kwargs):\n    \"\"\"Store the repr() of the return value of func in stampfile.\"\"\"\n    value = func(*args, **kwargs)\n    with open(stampfile, \"wb\") as stamp:\n        stamp.truncate()\n        pickle.dump(value, stamp)\n\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _stamp_and_update_hook(method,  # suppress(too-many-arguments)\n                           dependencies,\n                           stampfile,\n                           func,\n                           *args,\n                           **kwargs):\n    \"\"\"Write stamp and call update_stampfile_hook on method.\"\"\"\n    result = _stamp(stampfile, func, *args, **kwargs)\n    method.update_stampfile_hook(dependencies)\n    return result", "response": "Write stamp and call update_stampfile_hook on method."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns sha1 for contents of filename.", "response": "def _sha1_for_file(filename):\n    \"\"\"Return sha1 for contents of filename.\"\"\"\n    with open(filename, \"rb\") as fileobj:\n        contents = fileobj.read()\n        return hashlib.sha1(contents).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _out_of_date(func, *args, **kwargs):\n    storage_directory = os.path.join(tempfile.gettempdir(), \"jobstamps\")\n    stamp_input = \"\".join([func.__name__] +\n                          [repr(v) for v in args] +\n                          [repr(kwargs[k])\n                           for k in sorted(kwargs.keys())]).encode(\"utf-8\")\n\n    dependencies = kwargs.pop(\"jobstamps_dependencies\", None) or list()\n    expected_output_files = (kwargs.pop(\"jobstamps_output_files\", None) or\n                             list())\n    cache_output_directory = kwargs.pop(\"jobstamps_cache_output_directory\",\n                                        None) or storage_directory\n    method_class = _determine_method(kwargs.pop(\"jobstamps_method\", None))\n\n    stamp_file_name = os.path.join(cache_output_directory,\n                                   hashlib.md5(stamp_input).hexdigest())\n\n    detail = _OutOfDateActionDetail(stamp=stamp_file_name,\n                                    dependencies=dependencies,\n                                    method=method_class(stamp_file_name),\n                                    kwargs=kwargs)\n\n    if os.environ.get(\"JOBSTAMPS_DISABLED\", None):\n        return \"JOBSTAMPS_DISABLED\", detail\n\n    _safe_mkdir(cache_output_directory)\n\n    if not os.path.isdir(cache_output_directory):\n        raise IOError(\"\"\"{} exists and is \"\"\"\n                      \"\"\"not a directory.\"\"\".format(cache_output_directory))\n\n    if not os.path.exists(stamp_file_name):\n        return stamp_file_name, detail\n\n    for expected_output_file in expected_output_files:\n        if not os.path.exists(expected_output_file):\n            return expected_output_file, detail\n\n    for dependency in dependencies:\n        if (not os.path.exists(dependency) or\n                not detail.method.check_dependency(dependency)):\n            return dependency, detail\n\n    return None, detail", "response": "Return out of date file and detail to run job."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if mtime of dependency_path is greater than stored mtime.", "response": "def check_dependency(self, dependency_path):\n        \"\"\"Check if mtime of dependency_path is greater than stored mtime.\"\"\"\n        stored_hash = self._stamp_file_hashes.get(dependency_path)\n\n        # This file was newly added, or we don't have a file\n        # with stored hashes yet. Assume out of date.\n        if not stored_hash:\n            return False\n\n        return stored_hash == _sha1_for_file(dependency_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the stamp file hashes for each of the dependencies.", "response": "def update_stampfile_hook(self, dependencies):  # suppress(no-self-use)\n        \"\"\"Loop over all dependencies and store hash for each of them.\"\"\"\n        hashes = {d: _sha1_for_file(d) for d in dependencies\n                  if os.path.exists(d)}\n        with open(self._stamp_file_hashes_path, \"wb\") as hashes_file:\n            hashes_file.write(json.dumps(hashes).encode(\"utf-8\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unicode_value(self, string):\n        result = 0\n        # don't accept strings that contain numbers\n        if self.regex_has_numbers.search(string):\n            raise AbnumException(error_msg % string)\n        else:\n            num_str = self.regex_values.sub(lambda x: '%s ' % self.values[x.group()],\n                                            string)\n            # don't accept strings, that contains letters which haven't been be converted to numbers\n            try:\n                result = sum([int(i) for i in num_str.split()])\n            except Exception as e:\n                raise AbnumException(error_msg % string)\n        return result", "response": "Convert a unicode string to an integer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_app_submodules(submodule_name):\n    for name, module in get_app_modules():\n        if module_has_submodule(module, submodule_name):\n            yield name, import_module('%s.%s' % (name, submodule_name))", "response": "Yields all app modules that have a submodule named submodule_name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncopy of rest_framework. settings. import_from_string", "response": "def import_from_string(value):\n    \"\"\"Copy of rest_framework.settings.import_from_string\"\"\"\n    value = value.replace('-', '_')\n    try:\n        module_path, class_name = value.rsplit('.', 1)\n        module = import_module(module_path)\n        return getattr(module, class_name)\n    except (ImportError, AttributeError) as ex:\n        raise ImportError(\"Could not import '{}'. {}: {}.\".format(\n            value, ex.__class__.__name__, ex))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_args(args):\n\n    parser = argparse.ArgumentParser(prog='nibble',\n                                     description='Speed, distance and time '\n                                                 'calculations around '\n                                                 'quantities of digital '\n                                                 'information.')\n    parser.add_argument('-V', '--version',\n                        action='version',\n                        version='%(prog)s ' + nibble.__version__)\n    parser.add_argument('-v', '--verbosity',\n                        help='increase output verbosity',\n                        action='count',\n                        default=0)\n    parser.add_argument('expression',\n                        type=util.decode_cli_arg,\n                        nargs='+',\n                        help='the calculation to execute')\n    return parser.parse_args(args[1:])", "response": "Interpret command line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef main(args):\n\n    args = _parse_args(args)\n\n    # sort out logging output and level\n    level = util.log_level_from_vebosity(args.verbosity)\n    root = logging.getLogger()\n    root.setLevel(level)\n    handler = logging.StreamHandler(sys.stdout)\n    handler.setLevel(level)\n    handler.setFormatter(logging.Formatter('%(levelname)s %(message)s'))\n    root.addHandler(handler)\n\n    logger.debug(args)\n\n    expression = ' '.join(args.expression)\n    try:\n        print(Parser().parse(expression))\n    except (LexingError, ParsingError) as e:\n        util.print_error(e)\n        return 1\n\n    return 0", "response": "Nibble s entry point."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, conn, tmp, module_name, module_args, inject):\n        ''' transfer & execute a module that is not 'copy' or 'template' '''\n\n        # shell and command are the same module\n        if module_name == 'shell':\n            module_name = 'command'\n            module_args += \" #USE_SHELL\"\n\n        vv(\"REMOTE_MODULE %s %s\" % (module_name, module_args), host=conn.host)\n        return self.runner._execute_module(conn, tmp, module_name, module_args, inject=inject)", "response": "transfer & execute a module that is not copy or template"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_models(args):\n    if args:\n        models = []\n        for arg in args:\n            match_found = False\n            for model in registry.get_models():\n                if model._meta.app_label == arg:\n                    models.append(model)\n                    match_found = True\n                elif '%s.%s' % (model._meta.app_label, model._meta.model_name) == arg:\n                    models.append(model)\n                    match_found = True\n\n            if not match_found:\n                raise ValueError(\"No model or app named %s\" % arg)\n    else:\n        models = registry.get_models()\n\n    return set(models)", "response": "Parse a list of ModelName appname.ModelName list and return\n    the list of models in the IndexRegistry."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef main():\n    import jsonschema\n    parser = argparse.ArgumentParser(version=__version__)\n    parser.add_argument(\n        '--verbose', action='store_true', default=False,\n        help='Turn on verbose output.')\n    parser.add_argument(\n        '--header', action='store_true', default=False,\n        help='Turn on header.')\n    parser.add_argument(\n        'playbooks', metavar='PLAYBOOKS', type=str, nargs='+',\n        help='The playbook(s) to lint.')\n\n    args = parser.parse_args()\n\n    validation_results = {}\n    all_valid = True\n    # Load the playbook schema\n    with open(resource_filename(\n            'relent', 'schemas/playbook_schema.json'), 'r') as schema_fp:\n        schema = json.load(schema_fp)\n        # Do checks against playbooks\n        for playbook in args.playbooks:\n            try:\n                with open(playbook, 'r') as pb:\n                    # Schema check\n                    jsonschema.validate(json.load(pb), schema)\n            except jsonschema.ValidationError, e:\n                all_valid = False\n                validation_results[playbook] = (\n                    False, e.message, list(e.schema_path), str(e))\n            except ValueError, e:\n                all_valid = False\n                validation_results[playbook] = (\n                    False, 'JSON is invalid.', str(e), str(e))\n\n    # If all_valid is True then return back happy results\n    if all_valid is True:\n        if args.verbose or args.header:\n            parser._print_message('Found 0 issues.\\n')\n        raise SystemExit(0)\n    else:\n        if args.verbose or args.header:\n            parser._print_message('Found %s issues.\\n\\n' % len(\n                validation_results))\n        for problem_playbook in validation_results.keys():\n            parser._print_message('%s: E: %s %s\\n' % (\n                problem_playbook,\n                validation_results[problem_playbook][1],\n                validation_results[problem_playbook][2]))\n            if args.verbose:\n                parser._print_message(\n                    validation_results[problem_playbook][3] + '\\n--\\n')\n        raise SystemExit(1)", "response": "Entry point for the\n ArcGIS command line interface."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plot_dives(dv0, dv1, p, dp, t_on, t_off):\n    '''Plots depths and delta depths with dive start stop markers\n\n    Args\n    ----\n    dv0: int\n        Index position of dive start in cue array\n    dv1: int\n        Index position of dive stop in cue array\n    p: ndarray\n        Depth values\n    dp: ndarray\n        Delta depths\n    t_on: ndarray\n        Cue array with start index position of dives\n    t_off: ndarray\n        Cue array with stop index postition of dives\n    '''\n\n    fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\n\n    x0   = t_on[dv0:dv1] - t_on[dv0]\n    x1   = t_off[dv0:dv1] - t_on[dv0]\n\n    # Extract start end depths\n    y0_p = p[t_on[dv0:dv1]]\n    y1_p = p[t_off[dv0:dv1]]\n\n    # Extract start end delta depths\n    y0_dp = dp[t_on[dv0:dv1]]\n    y1_dp = dp[t_off[dv0:dv1]]\n\n    start = t_on[dv0]\n    stop  = t_off[dv1]\n\n    ax1.title.set_text('Dives depths')\n    ax1.plot(range(len(p[start:stop])), p[start:stop])\n    ax1.scatter(x0, y0_p, label='start')\n    ax1.scatter(x1, y1_p, label='stop')\n    ax1.set_ylabel('depth (m)')\n\n    ax1.title.set_text('Depth rate of change')\n    ax2.plot(range(len(dp[start:stop])), dp[start:stop])\n    ax2.scatter(x0, y0_dp, label='start')\n    ax2.scatter(x1, y1_dp, label='stop')\n    ax2.set_ylabel('depth (dm/t)')\n    ax2.set_xlabel('sample')\n\n    for ax in [ax1, ax2]:\n        ax.legend(loc='upper right')\n        ax.set_xlim([-50, len(dp[start:stop])+50])\n\n    plt.show()\n\n    return None", "response": "Plots depths and delta depths with dive start stop markers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nplot dives with phase and associated pitch angle with HF signal.", "response": "def plot_dives_pitch(depths, dive_mask, des, asc, pitch, pitch_lf):\n    '''Plot dives with phase and associated pitch angle with HF signal\n\n    Args\n    ----\n    depths: ndarray\n        Depth values at each sensor sampling\n    dive_mask: ndarray\n        Boolean mask slicing dives from the tag data\n    des: ndarray\n        boolean mask for slicing descent phases of dives from tag dta\n    asc: ndarray\n        boolean mask for slicing asccent phases of dives from tag dta\n    pitch: ndarray\n        Pitch angle derived from acceleromter data\n    pitch_lf: ndarray\n        Low-pass filtered derived pitch angle data\n    '''\n    import copy\n    import numpy\n\n    from . import plotutils\n\n    fig, (ax1, ax2) = plt.subplots(2,1, sharex=True)\n\n    des_ind = numpy.where(dive_mask & des)[0]\n    asc_ind = numpy.where(dive_mask & asc)[0]\n\n    ax1.title.set_text('Dive descents and ascents')\n    ax1 = plotutils.plot_noncontiguous(ax1, depths, des_ind, _colors[0],\n                                       'descents')\n    ax1 = plotutils.plot_noncontiguous(ax1, depths, asc_ind, _colors[1],\n                                       'ascents')\n\n    ax1.legend(loc='upper right')\n    ax1.invert_yaxis()\n    ax1.yaxis.label.set_text('depth (m)')\n    ax1.xaxis.label.set_text('samples')\n\n\n    ax2.title.set_text('Pitch and Low-pass filtered pitch')\n    ax2.plot(range(len(pitch)), pitch, color=_colors[2], linewidth=_linewidth,\n            label='pitch')\n    ax2.plot(range(len(pitch_lf)), pitch_lf, color=_colors[3],\n            linewidth=_linewidth, label='pitch filtered')\n    ax2.legend(loc='upper right')\n    ax2.yaxis.label.set_text('Radians')\n    ax2.yaxis.label.set_text('Samples')\n\n    plt.show()\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nplot depth data for whole deployment descents and ascents", "response": "def plot_depth_descent_ascent(depths, dive_mask, des, asc):\n    '''Plot depth data for whole deployment, descents, and ascents\n\n    Args\n    ----\n    depths: ndarray\n        Depth values at each sensor sampling\n    dive_mask: ndarray\n        Boolean mask slicing dives from the tag data\n    des: ndarray\n        boolean mask for slicing descent phases of dives from tag dta\n    asc: ndarray\n        boolean mask for slicing asccent phases of dives from tag dta\n    '''\n    import numpy\n\n    from . import plotutils\n\n    # Indices where depths are descents or ascents\n    des_ind = numpy.where(dive_mask & des)[0]\n    asc_ind = numpy.where(dive_mask & asc)[0]\n\n    fig, ax1 = plt.subplots()\n\n    ax1.title.set_text('Dive descents and ascents')\n    ax1 = plotutils.plot_noncontiguous(ax1, depths, des_ind, _colors[0],\n                                       'descents')\n    ax1 = plotutils.plot_noncontiguous(ax1, depths, asc_ind, _colors[1],\n                                       'ascents')\n\n    ax1.legend(loc='upper right')\n    ax1.invert_yaxis()\n    ax1.yaxis.label.set_text('depth (m)')\n    ax1.xaxis.label.set_text('samples')\n\n    plt.show()\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nplot triaxial accelerometer data for whole deployment descents and ascents and ascents of the top - level of the tree tree.", "response": "def plot_triaxial_depths_speed(tag):\n    '''Plot triaxial accelerometer data for whole deployment, descents, and\n    ascents\n\n    Only x and z axes are ploted since these are associated with stroking\n\n    Args\n    ----\n    tag: pandas.DataFrame\n        Tag dataframe with acceleromter, depth, and propeller columns\n    '''\n    import numpy\n\n    from . import plotutils\n\n    # TODO return to multiple inputs rather than dataframe\n\n    fig, axes = plt.subplots(3, 3, sharex='col', sharey='row')\n    ((ax1, ax4, ax7), (ax2, ax5, ax8), (ax3, ax6, ax9)) = axes\n\n    # Create mask of all True for length of depths\n    all_ind = numpy.arange(0, len(tag), dtype=int)\n\n    cols = [('x', tag['Ax_g'], [ax1, ax2, ax3]),\n            ('y', tag['Ay_g'], [ax4, ax5, ax6]),\n            ('z', tag['Az_g'], [ax7, ax8, ax9])]\n\n    for label, y, axes in cols:\n        axes[0].title.set_text('Accelerometer {}-axis'.format(label))\n        axes[0].plot(range(len(y)), y, color=_colors[0],\n                     linewidth=_linewidth, label='x')\n\n        axes[1].title.set_text('Depths')\n        axes[1] = plotutils.plot_noncontiguous(axes[1], tag['depth'], all_ind,\n                                               color=_colors[1])\n        axes[1].invert_yaxis()\n\n        axes[2] = plotutils.plot_noncontiguous(axes[2], tag['propeller'],\n                                               all_ind, color=_colors[2],\n                                               label='propeller')\n\n    plt.show()\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nplot triaxial accelerometer data for whole deployment descents and ascents", "response": "def plot_triaxial_descent_ascent(Ax, Az, des, asc):\n    '''Plot triaxial accelerometer data for whole deployment, descents, and\n    ascents\n\n    Only x and z axes are ploted since these are associated with stroking\n\n    Args\n    ----\n    Ax: ndarray\n        X-axis acclerometer data array\n    Az: ndarray\n        Z-axis acclerometer data array\n    des: ndarray\n        boolean mask for slicing descent phases of dives from tag dta\n    asc: ndarray\n        boolean mask for slicing asccent phases of dives from tag dta\n    '''\n    import numpy\n\n    from . import plotutils\n\n    fig, ((ax1, ax3), (ax2, ax4)) = plt.subplots(2, 2, sharex=True, sharey=True)\n\n    # Convert boolean mask to indices\n    des_ind = numpy.where(des)[0]\n    asc_ind = numpy.where(asc)[0]\n\n    cols = [('x', Ax, [ax1, ax2]),\n            ('z', Az, [ax3, ax4])]\n\n    for label, data, axes in cols:\n        axes[0].title.set_text('Whole {}'.format(label))\n        axes[0].plot(range(len(data)), data, color=_colors[0],\n                     linewidth=_linewidth, label='{}'.format(label))\n\n        axes[1].title.set_text('Descents & Ascents {}'.format(label))\n        axes[1] = plotutils.plot_noncontiguous(axes[1], data, des_ind,\n                                               color=_colors[1],\n                                               label='descents')\n        axes[1] = plotutils.plot_noncontiguous(axes[1], data, asc_ind,\n                                               color=_colors[2],\n                                               label='ascents')\n        axes[1].legend(loc='upper right')\n\n    plt.show()\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntriggers this event. Any passed in args/kwargs are passed to the event handlers - if the event handlers cannot accept those arguments then they will cause an exception!", "response": "def trigger(self, *args, **kwargs):\r\n\t\t\"\"\"Trigger this event.\r\n\r\n\t\tAny passed in args/kwargs are passed to the event handlers - if the event\r\n\t\thandlers cannot accept those arguments then they will cause an exception!\r\n\t\t\"\"\"\r\n\t\tcurrent = self.name.split('/')\r\n\t\twhile current:\r\n\t\t\tname = '/'.join(current)\r\n\t\t\tcurrent.pop()\r\n\t\t\tif name in self.context.handlers:\r\n\t\t\t\tself.all_handlers += [(name, h) for h in self.context.handlers[name]] \r\n\t\t\t\tif name == self.name:\r\n\t\t\t\t\tself.handlers += self.context.handlers[name]\r\n\r\n\t\tfor name, handler in self.all_handlers:\r\n\t\t\tres = handler(self, *args, **kwargs)\r\n\t\t\tself.all_executed += 1\r\n\t\t\tself.all_result.append(res)\r\n\t\t\tif name == self.name:\r\n\t\t\t\tself.executed += 1\r\n\t\t\t\tself.result.append(res)\r\n\t\t\tif self.stopped:\r\n\t\t\t\tbreak\r\n\r\n\t\tself.all_handlers = [h for name, h in self.all_handlers]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a context by name create the default context if it does not exist", "response": "def getContext(self, context_name = 'default'):\r\n\t\t\"\"\"Get a context by name, create the default context if it does not exist\r\n\r\n\t\tParams:\r\n\t\t\tcontext_name (string):\r\n\t\t\t\tContext name\r\n\r\n\t\tRaises:\r\n\t\t\tKeyError:\r\n\t\t\t\tIf the context name does not exist\r\n\r\n\t\tReturns:\r\n\t\t\tbubbler.Bubbler:\r\n\t\t\t\tNamed context\r\n\t\t\"\"\"\r\n\t\tif context_name == 'default' and 'default' not in self.contexts:\r\n\t\t\tself('default')\r\n\r\n\t\treturn self.contexts[context_name]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbinding a callback to an event", "response": "def bind(self, event_name, callback, first = False):\r\n\t\t\"\"\"Bind a callback to an event\r\n\r\n\t\tParams:\r\n\t\t\tevent_name (string):\r\n\t\t\t\tName of the event to bind to\r\n\t\t\tcallback (callable):\r\n\t\t\t\tCallback that will be called when the event is triggered\r\n\t\t\tfirst (boolean):\r\n\t\t\t\tIf True, this callback is placed before all the other events already\r\n\t\t\t\tregistered for this event, otherwise it is placed at the end.\r\n\t\t\"\"\"\r\n\t\tif event_name not in self.handlers:\r\n\t\t\tself.handlers[event_name] = []\r\n\r\n\t\tif first:\r\n\t\t\tself.handlers[event_name].insert(0, callback)\r\n\t\telse:\r\n\t\t\tself.handlers[event_name].append(callback)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nunbinding a callback from an event", "response": "def unbind(self, callback, event_name = None):\r\n\t\t\"\"\"Unbind a callback from an event\r\n\r\n\t\tParams:\r\n\t\t\tcallback (callable):\r\n\t\t\t\tCallback to unbind\r\n\t\t\tevent_name (string):\r\n\t\t\t\tIf None (default) this callback is removed from every event to\r\n\t\t\t\twhich it's bound.  If a name is given then it is only removed from\r\n\t\t\t\tthat event, if it is bound to that event.\r\n\t\t\"\"\"\r\n\t\tif event_name is None:\r\n\t\t\tfor name in self.handlers.keys():\r\n\t\t\t\tself.unbind(callback, name)\r\n\t\t\treturn\r\n\r\n\t\tif callback in self.handlers[event_name]:\r\n\t\t\tself.handlers[event_name].remove(callback)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef trigger(self, event_name, *args, **kwargs):\r\n\t\tev = Event(event_name, self)\r\n\t\tev.trigger(*args, **kwargs)\r\n\t\treturn ev", "response": "Trigger an event on this context."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef result_key_for(self, op_name):\n        ops = self.resource_data.get('operations', {})\n        op = ops.get(op_name, {})\n        key = op.get('result_key', None)\n        return key", "response": "Returns the key for the result_key of the given operation name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the docstrings of the resource methods.", "response": "def _update_docstrings(self):\n        \"\"\"\n        Runs through the operation methods & updates their docstrings if\n        necessary.\n\n        If the method has the default placeholder docstring, this will replace\n        it with the docstring from the underlying connection.\n        \"\"\"\n        ops = self._details.resource_data['operations']\n\n        for method_name in ops.keys():\n            meth = getattr(self.__class__, method_name, None)\n\n            if not meth:\n                continue\n\n            if meth.__doc__ != DEFAULT_DOCSTRING:\n                # It already has a custom docstring. Leave it alone.\n                continue\n\n            # Needs updating. So there's at least *something* vaguely useful\n            # there, use the docstring from the underlying ``Connection``\n            # method.\n            # FIXME: We need to figure out a way to make this more useful, if\n            #        possible.\n            api_name = ops[method_name]['api_name']\n            conn_meth = getattr(self._connection, to_snake_case(api_name))\n\n            # We need to do detection here, because Py2 treats ``.__doc__``\n            # as a special read-only attribute. :/\n            if six.PY3:\n                meth.__doc__ = conn_meth.__doc__\n            else:\n                meth.__func__.__doc__ = conn_meth.__doc__"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_identifiers(self, data):\n        for id_info in self._details.identifiers:\n            var_name = id_info['var_name']\n            self._data[var_name] = data.get(var_name)\n\n        # FIXME: This needs to likely kick off invalidating/rebuilding\n        #        relations.\n        #        For now, just remove them all. This is potentially inefficient\n        #        but is nicely lazy if we don't need them & prevents stale data\n        #        for the moment.\n        self._relations = {}", "response": "Sets the identifiers within the instance data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconstruct a related object from a resource or collection.", "response": "def build_relation(self, name, klass=None):\n        \"\"\"\n        Constructs a related ``Resource`` or ``Collection``.\n\n        This allows for construction of classes with information prepopulated\n        from what the current instance has. This enables syntax like::\n\n            bucket = Bucket(bucket='some-bucket-name')\n\n            for obj in bucket.objects.each():\n                print(obj.key)\n\n        :param name: The name of the relation from the ResourceJSON\n        :type name: string\n\n        :param klass: (Optional) An overridable class to construct. Typically\n            only useful if you need a custom subclass used in place of what\n            kotocore provides.\n        :type klass: class\n\n        :returns: An instantiated related object\n        \"\"\"\n        try:\n            rel_data = self._details.relations[name]\n        except KeyError:\n            msg = \"No such relation named '{0}'.\".format(name)\n            raise NoRelation(msg)\n\n        if klass is None:\n            # This is the typical case, where we're not explicitly given a\n            # class to build with. Hit the session & look up what we should\n            # be loading.\n            if rel_data['class_type'] == 'collection':\n                klass = self._details.session.get_collection(\n                    self._details.service_name,\n                    rel_data['class']\n                )\n            elif rel_data['class_type'] == 'resource':\n                klass = self._details.session.get_resource(\n                    self._details.service_name,\n                    rel_data['class']\n                )\n            else:\n                msg = \"Unknown class '{0}' for '{1}'.\".format(\n                    rel_data['class_type'],\n                    name\n                )\n                raise NoRelation(msg)\n\n        # Instantiate & return it.\n        kwargs = {}\n        # Just populating identifiers is enough for the 1-M case.\n        kwargs.update(self.get_identifiers())\n\n        if rel_data.get('rel_type', '1-M') == '1-1':\n            # FIXME: If it's not a collection, we might have some instance data\n            #        (i.e. ``bucket``) in ``self._data`` to populate as well.\n            #        This seems like a can of worms, so ignore for the moment.\n            pass\n\n        return klass(connection=self._connection, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef post_process_get(self, result):\n        if not hasattr(result, 'items'):\n            # If it's not a dict, give up & just return whatever you get.\n            return result\n\n        # We need to possibly drill into the response & get out the data here.\n        # Check for a result key.\n        result_key = self._details.result_key_for('get')\n\n        if not result_key:\n            # There's no result_key. Just use the top-level data.\n            data = result\n        else:\n            data = result[result_key]\n\n        for key, value in data.items():\n            self._data[to_snake_case(key)] = value\n\n        return result", "response": "This method is called when the service is post - processing a get response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconstructing a new class that is part of a given service and resource.", "response": "def construct_for(self, service_name, resource_name, base_class=None):\n        \"\"\"\n        Builds a new, specialized ``Resource`` subclass as part of a given\n        service.\n\n        This will load the ``ResourceJSON``, determine the correct\n        mappings/methods & constructs a brand new class with those methods on\n        it.\n\n        :param service_name: The name of the service to construct a resource\n            for. Ex. ``sqs``, ``sns``, ``dynamodb``, etc.\n        :type service_name: string\n\n        :param resource_name: The name of the ``Resource``. Ex.\n            ``Queue``, ``Notification``, ``Table``, etc.\n        :type resource_name: string\n\n        :returns: A new resource class for that service\n        \"\"\"\n        details = self.details_class(\n            self.session,\n            service_name,\n            resource_name,\n            loader=self.loader\n        )\n\n        attrs = {\n            '_details': details,\n        }\n\n        # Determine what we should call it.\n        klass_name = self._build_class_name(resource_name)\n\n        # Construct what the class ought to have on it.\n        attrs.update(self._build_methods(details))\n\n        if base_class is None:\n            base_class = self.base_resource_class\n\n        # Create the class.\n        return type(\n            klass_name,\n            (base_class,),\n            attrs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef filter_headers(criterion):\n    ip = get_ipython()\n    for headerkind in ['processed', 'raw']:\n        for h in ip.user_ns['_headers'][headerkind][:]:\n            if not criterion(h):\n                ip.user_ns['_headers'][headerkind].remove(h)\n    ip.user_ns['allsamplenames'] = {h.title for h in ip.user_ns['_headers']['processed']}", "response": "Filter already loaded headers against some criterion."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading header files into user_ns", "response": "def load_headers(fsns:List[int]):\n    \"\"\"Load header files\n    \"\"\"\n    ip = get_ipython()\n    ip.user_ns['_headers'] = {}\n    for type_ in ['raw', 'processed']:\n        print(\"Loading %d headers (%s)\" % (len(fsns), type_), flush=True)\n        processed = type_ == 'processed'\n        headers = []\n        for f in fsns:\n            for l in [l_ for l_ in ip.user_ns['_loaders'] if l_.processed == processed]:\n                try:\n                    headers.append(l.loadheader(f))\n                    break\n                except FileNotFoundError:\n                    continue\n        allsamplenames = {h.title for h in headers}\n        if not headers:\n            print('NO HEADERS READ FOR TYPE \"%s\"' % type_)\n        else:\n            print(\"%d headers (%s) out of %d have been loaded successfully.\" % (len(headers), type_, len(fsns)))\n            print('Read FSN range:', min([h.fsn for h in headers]), 'to', max([h.fsn for h in headers]))\n            print(\"Samples covered by these headers:\")\n            print(\"    \" + \"\\n    \".join(sorted(allsamplenames)), flush=True)\n        if processed:\n            ip.user_ns['allsamplenames'] = allsamplenames\n        ip.user_ns['_headers'][type_] = headers"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the size of path in bytes if it exists and can be determined.", "response": "def get_size(path):\n    '''Return the size of path in bytes if it exists and can be determined.'''\n    size = os.path.getsize(path)\n    for item in os.walk(path):\n        for file in item[2]:\n            size += os.path.getsize(os.path.join(item[0], file))\n    return size"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prefix_size(size, base=1024):\n    '''Return size in B (bytes), kB, MB, GB or TB.'''\n    if ARGS.prefix == 'None':\n        for i, prefix in enumerate(['', 'ki', 'Mi', 'Gi', 'Ti']):\n            if size < pow(base, i + 1):\n                return '{0} {1}B'.format(round(float(size) / pow(base, i), 1),\n                                         prefix)\n    else:\n        try:\n            prefix = {'': 0, 'k': 1, 'M': 2, 'G': 3, 'T': 4}[ARGS.prefix]\n        except KeyError:\n            exit('Invalid prefix.')\n        return '{0} {1}B'.format(round(float(size) / pow(base, prefix), 1),\n                                 ARGS.prefix)", "response": "Return size in B ( bytes kB MB GB or TB."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create():\n    if not all(map(os.path.isdir, ARGS.directory)):\n        exit('Error: One or more of the specified directories does not exist.')\n    with sqlite3.connect(ARGS.database) as connection:\n        connection.text_factory = str\n        cursor = connection.cursor()\n        cursor.execute('DROP TABLE IF EXISTS Movies')\n        cursor.execute('''CREATE TABLE Movies(name TEXT, path TEXT, size TEXT,\n                          files BLOB)''')\n        for dir in ARGS.directory:\n            cursor.executemany('INSERT INTO Movies VALUES(?, ?, ?, ?)',\n                               local_data(dir))", "response": "Create a new database with information about the films in the specified directories."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists all items in the database in a predefined format.", "response": "def ls():\n    \"\"\"List all items in the database in a predefined format.\"\"\"\n    if not os.path.exists(ARGS.database):\n        exit('Error: The database does not exist; you must create it first.')\n    with sqlite3.connect(ARGS.database) as connection:\n        connection.text_factory = str\n        cursor = connection.cursor()\n        if ARGS.pattern:\n            if not ARGS.strict:\n                ARGS.pattern = '%{0}%'.format(ARGS.pattern)\n            cursor.execute('SELECT * FROM Movies WHERE Name LIKE (?)',\n                           [ARGS.pattern])\n        else:\n            cursor.execute('SELECT * FROM Movies')\n        movies = sorted([row for row in cursor])\n    if ARGS.name:\n        print '\\n'.join([movie[0] for movie in movies])\n    elif ARGS.location:\n        print '\\n'.join([movie[1] for movie in movies])\n    elif ARGS.size:\n        print '\\n'.join([prefix_size(int(movie[2])) for movie in movies])\n    elif ARGS.files:\n        for movie in movies:\n            print ', '.join(movie[3].split('##'))\n    else:\n        for i, movie in enumerate(movies):\n            print 'Name:\\t\\t{0}'.format(movie[0])\n            print 'Location:\\t{0}'.format(movie[1])\n            print 'Size:\\t\\t{0}'.format(prefix_size(int(movie[2])))\n            print 'Files:\\t\\t{0}'.format(', '.join(movie[3].split('##')))\n            if not i == len(movies) - 1:\n                print"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nopen the matched movie with a media player.", "response": "def play():\n    \"\"\"Open the matched movie with a media player.\"\"\"\n    with sqlite3.connect(ARGS.database) as connection:\n        connection.text_factory = str\n        cursor = connection.cursor()\n        if ARGS.pattern:\n            if not ARGS.strict:\n                ARGS.pattern = '%{0}%'.format(ARGS.pattern)\n            cursor.execute('SELECT * FROM Movies WHERE Name LIKE (?)',\n                           [ARGS.pattern])\n            try:\n                path = sorted([row for row in cursor])[0][1]\n                replace_map = {' ': '\\\\ ', '\"': '\\\\\"', \"'\": \"\\\\'\"}\n                for key, val in replace_map.iteritems():\n                    path = path.replace(key, val)\n                os.system('{0} {1} &'.format(ARGS.player, path))\n            except IndexError:\n                exit('Error: Movie not found.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a random string of length equal to the length parameter", "response": "def random_string(length, numeric_only=False):\n    \"\"\"\n    Generates a random string of length equal to the length parameter\n    \"\"\"\n    choices = string.digits if numeric_only else string.ascii_uppercase + string.digits\n    return ''.join(random.choice(choices) for _ in range(length))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef random_date(start_year=2000, end_year=2020):\n    return date(random.randint(start_year, end_year), random.randint(1, 12), random.randint(1, 28))", "response": "Generates a random sensible date for use in a tree of issues."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the nth bound - state energy for a finite - potential quantum well with the given well - strength parameter P.", "response": "def _finite_well_energy(P, n=1, atol=1e-6):\n    '''\n    Returns the nth bound-state energy for a finite-potential quantum well\n    with the given well-strength parameter, `P`.\n    '''\n    assert n > 0 and n <= _finite_well_states(P)\n    pi_2 = pi / 2.\n    r = (1 / (P + pi_2)) * (n * pi_2)\n    eta = n * pi_2 - arcsin(r) - r * P\n    w = 1  # relaxation parameter (for succesive relaxation)\n    while True:\n        assert r <= 1\n        if abs(eta) < atol:\n            break\n        r2 = r ** 2.\n        sqrt_1mr2 = sqrt(1. - r2)\n        denom = (1. + P * sqrt_1mr2)\n        t1 = P * sqrt_1mr2 / denom * eta\n#         t2 = -r * P / (2 * (1. + P * sqrt_1mr2) ** 3) * eta ** 2\n        while True:\n            next_r = (1 - w) * r + w * (r + t1)\n#             next_r = (1 - w) * r + w * (r + t1 + t2)\n            next_eta = n * pi_2 - arcsin(next_r) - next_r * P\n            # decrease w until eta is converging\n            if abs(next_eta / eta) < 1:\n                r = next_r\n                eta = next_eta\n                break\n            else:\n                w *= 0.5\n\n    alpha = P * r\n    E = 2 * (alpha) ** 2  # hbar**2 / (m * L**2)\n    return E"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the finite confinement energy in the well in units of meters.", "response": "def finite_well_energy(a, m, U, n=1):\n    '''\n    a : float\n        thickness of the well in units of meters\n    m : float\n        effective mass in the well as a fraction of the electron mass\n    U : float\n        the potential in eV\n    n : int\n        the quantum number of the desired state\n\n    If U <= 0, returns 0. Otherwise, returns the confinement energy in\n    units of eV.\n\n    Reference:\n    D.L. Aronstein and C.R. Stroud, Jr., Am. J. Phys. 68, 943 (2000).\n    '''\n    if U <= 0.:\n        return 0\n    P = prefactor * a * sqrt(m * U)\n    print P, _finite_well_energy(P, n)\n    return _finite_well_energy(P, n) * 7.61996e-20 / m / a ** 2."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind the most popular torrents.", "response": "def top(self, n=10, cache=None, prefetch=False):\n        \"\"\"Find the most popular torrents.\n\n        Return an array of Torrent objects representing the top n torrents. If\n        the cache option is non-None, override the Scraper's default caching\n        settings.\n\n        Use the prefetch option to hit each Torrent's info page up front\n        (instead of lazy fetching the info on-demand later).\n\n        \"\"\"\n        use_cache = self._use_cache(cache)\n        if use_cache and len(self._top_cache) >= n:\n            return self._top_cache[:n]\n        soup = get(TOP).soup\n        links = soup.find_all(\"a\", class_=\"detLink\")[:n]\n        urls = [urlparse.urljoin(TOP, link.get('href')) for link in links]\n        torrents = [self.torrent_from_url(url, use_cache, prefetch)\n                for url in urls]\n        if use_cache:\n            self._top_cache = torrents\n            self._add_to_torrent_cache(torrents)\n        return torrents"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef torrent_from_url(self, url, cache=True, prefetch=False):\n        if self._use_cache(cache) and url in self._torrent_cache:\n            return self._torrent_cache[url]\n        torrent = Torrent(url, cache, prefetch)\n        if cache:\n            self._torrent_cache[url] = torrent\n        return torrent", "response": "Create a Torrent object from a given URL."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _send_command(self, command, immediate=False, timeout=1.0,\n                      check_echo=None):\n        \"\"\" Send a single command to the drive after sanitizing it.\n\n        Takes a single given `command`, sanitizes it (strips out\n        comments, extra whitespace, and newlines), sends the command to\n        the drive, and returns the sanitized command. The validity of\n        the command is **NOT** checked.\n\n        Parameters\n        ----------\n        command : str\n            The command to send to the Gemini drive.\n        immediate : bool, optional\n            Whether to make it so the command is executed immediately or\n            not.\n        timeout : number, optional\n            Optional timeout in seconds to use to get the command right\n            when we are doing echo checking. A negative value or\n            ``None`` indicates that the an infinite timeout should be\n            used.\n        check_echo : bool or None, optional\n            Whether the echoing of the command as it is being written to\n            the drive should be used to correct mistakes in what the\n            drive is seeing, or whether the default set when the\n            instance of this class was created should be used\n            (``None``).\n\n        Returns\n        -------\n        sanitized_command : str\n            The sanitized command that was sent to the drive.\n\n        \"\"\"\n        # Use the default echo checking if None was given.\n        if check_echo is None:\n            check_echo = self._check_echo\n\n        # Convert to bytes and then strip comments, whitespace, and\n        # newlines.\n        if sys.hexversion >= 0x03000000:\n            c = bytes(command, encoding='ASCII')\n        else:\n            c = command\n        c = c.split(b';')[0].strip()\n\n        # If the command is supposed to be immediate, insure that it\n        # starts with an '!'.\n        if immediate and not c.startswith(b'!'):\n            c = b'!' + c\n\n        # Read out any junk on the serial port before we start.\n        self._ser.read(self._ser.inWaiting())\n\n        # The command needs to be written a character at a time with\n        # pauses between them to make sure nothing gets lost or\n        # corrupted. This is a simple loop if we are not checking the\n        # echo. If we are, it is more complicated.\n        if not check_echo:\n            for i in range(0, len(c)):\n                self._ser.write(bytes([c[i]]))\n                time.sleep(0.01)\n        else:\n            # Infinite timeouts need to be converted to None. Finite\n            # ones need to be checked to make sure they are not too big,\n            # which is threading.TIMEOUT_MAX on Python 3.x and not\n            # specified on Python 2.x (lets use a week).\n            if timeout is None or timeout <= 0:\n                timeout = None\n            else:\n                if sys.hexversion >= 0x03000000:\n                    maxtimeout = threading.TIMEOUT_MAX\n                else:\n                    maxtimeout = 7*24*3600\n                timeout = min(timeout, maxtimeout)\n\n            # A timer will be made that takes timeout to finish. Then,\n            # it is a matter of checking whether it is alive or not to\n            # know whether the timeout was exceeded or not. Then, the\n            # timer is started.\n            tm = threading.Timer(timeout, lambda : None)\n            tm.start()\n\n            # Each character needs to be written one by one while the\n            # echo is collected. If any mistakes occur, they need to be\n            # corrected with backspaces b'\\x08'. The echo starts out\n            # empty. We go until either the echo is identical to the\n            # command or the timeout is exceeded.\n            echo = b''\n            while c != echo and tm.is_alive():\n                # If there are no mistakes, then echo will be the\n                # beginning of c meaning the next character can be\n                # written. Otherwise, there is a mistake and a backspace\n                # needs to be written.\n                if c.startswith(echo):\n                    self._ser.write(bytes([c[len(echo)]]))\n                else:\n                    self._ser.write(b'\\x08')\n\n                # Pause for a bit to make sure nothing gets lost. Then\n                # read the drive's output add it to the echo.\n                time.sleep(0.01)\n                echo += self._ser.read(self._ser.inWaiting())\n\n                # All backspaces in echo need to be processed. Each\n                # backspace deletes itself and the character before it\n                # (if any).\n                while b'\\x08' in echo:\n                    index = echo.index(b'\\x08')\n                    if index == 0:\n                        echo = echo[1:]\n                    else:\n                        echo = echo[0:(index-1)] + echo[(index+1):]\n\n            # Turn off the timer in the case that it is still running\n            # (command completely written before timeout).\n            tm.cancel()\n\n        # Write the carriage return to enter the command and then return\n        # the sanitized command.\n        self._ser.write(b'\\r')\n        if sys.hexversion >= 0x03000000:\n            return c.decode(errors='replace')\n        else:\n            return c", "response": "Send a single command to the Gemini drive."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_response(self, timeout=1.0, eor=('\\n', '\\n- ')):\n        # If no timeout is given or it is invalid and we are using '\\n'\n        # as the eor, use the wrapper to read a line with an infinite\n        # timeout. Otherwise, the reading and timeout must be\n        # implemented manually.\n        if (timeout is None or timeout < 0) and eor == '\\n':\n            return self._sio.readline()\n        else:\n            # A timer will be made that takes timeout to finish. Then,\n            # it is a matter of checking whether it is alive or not to\n            # know whether the timeout was exceeded or not. They need to\n            # be checked to make sure they are not too big, which is\n            # threading.TIMEOUT_MAX on Python 3.x and not specified on\n            # Python 2.x (lets use a week). Then, the timer is started.\n            if sys.hexversion >= 0x03000000:\n                maxtimeout = threading.TIMEOUT_MAX\n            else:\n                maxtimeout = 7*24*3600\n            timeout = min(timeout, maxtimeout)\n            tm = threading.Timer(timeout, lambda : None)\n            tm.start()\n\n            # eor needs to be converted to bytes. If it is just an str,\n            # it needs to be wrapped in a tuple.\n            if isinstance(eor, str):\n                eor = tuple([eor])\n            if sys.hexversion >= 0x03000000:\n                eor = [s.encode(encoding='ASCII') for s in eor]\n\n            # Read from the serial port into buf until the EOR is found\n            # or the timer has stopped. A small pause is done each time\n            # so that this thread doesn't hog the CPU.\n            buf = b''\n            while not any([(x in buf) for x in eor]) and tm.is_alive():\n                time.sleep(0.001)\n                buf += self._ser.read(self._ser.inWaiting())\n\n            # Just in case the timer has not stopped (EOR was found),\n            # stop it.\n            tm.cancel()\n\n            # Remove anything after the EOR if there is one. First, a\n            # set of matches (index, eor_str) for each string in eor\n            # needs to be constructed. Sorting the matches by their\n            # index puts all the ones that were not found (index of -1)\n            # at the front. Then a list of bools that are True for each\n            # index that isn't -1 is made, converted to a bytes (True\n            # goes to b'\\x01' and False goes to b'\\x00'), and then the\n            # index of the first True value found. If it is not -1, then\n            # there was a successful match and  all the characters are\n            # dropped after that eor_str.\n            matches = [(buf.find(x), x) for x in eor]\n            matches.sort(key=lambda x: x[0])\n            index = bytes([x[0] != -1 for x in matches]).find(b'\\x01')\n            if index != -1:\n                buf = buf[:(matches[index][0] + len(matches[index][1]))]\n\n            # Convert to an str before returning.\n            if sys.hexversion >= 0x03000000:\n                return buf.decode(errors='replace')\n            else:\n                return buf", "response": "Reads a response from the drive and returns it as a string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _process_response(self, response):\n        # Strip the trailing newline and split the response into lines\n        # by carriage returns.\n        rsp_lines = response.rstrip('\\r\\n').split('\\r')\n\n        # If we have at least one line, the first one is the echoed\n        # command. If available, it needs to be grabbed and that line\n        # removed from rsp_lines since it is just the echoing, not the\n        # actual response to the command. None will be used to denote a\n        # non-existent echo.\n        if len(rsp_lines) > 0:\n            echoed_command = rsp_lines[0]\n            del rsp_lines[0]\n        else:\n            echoed_command = None\n\n        # If the next line is one of the different possible error\n        # strings, then there was an error that must be grabbed (leading\n        # '*' is stripped). If there was an error, remove that line from\n        # the response. None will be used to denote the lack of an error.\n        if len(rsp_lines) > 0 and \\\n                rsp_lines[0] in ('*INVALID_ADDRESS', '*INVALID_DATA', \\\n                '*INVALID_DATA_HIGH', '*INVALID_DATA_LOW', \\\n                '*UNDEFINED_LABEL'):\n            err = rsp_lines[0][1:]\n            del rsp_lines[0]\n        else:\n            err = None\n\n        return [response, echoed_command, err, rsp_lines]", "response": "Processes a response from the drive and returns a list of the entries in the response."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_command(self, command, immediate=False, timeout=1.0,\n                     max_retries=0, eor=('\\n', '\\n- ')):\n        \"\"\" Sends a single command to the drive and returns output.\n\n        Takes a single given `command`, sanitizes it, sends it to the\n        drive, reads the response, and returns the processed response.\n        The command is first sanitized by removing comments, extra\n        whitespace, and newline characters. If `immediate` is set, the\n        command is made to be an immediate command. Note, the command is\n        **NOT** checked for validity. If the drive returns an error, the\n        command is re-executed up to `max_tries` more times. The\n        response from the final execution is processed and returned. The\n        response from the drive is broken down into the echoed command\n        (drive echoes it back), any error returned by the drive (leading\n        '*' is stripped), and the different lines of the response; which\n        are all returned.\n\n        Parameters\n        ----------\n        command : str\n            The command to send to the Gemini drive.\n        immediate : bool, optional\n            Whether to make it so the command is executed immediately or\n            not.\n        timeout : float or None, optional\n            Optional timeout in seconds to use when reading the\n            response. A negative value or ``None`` indicates that the\n            an infinite timeout should be used.\n        max_retries : int, optional\n            Maximum number of retries to do per command in the case of\n            errors.\n        eor : str or iterable of str, optional\n            ``str`` or an iterable of ``str`` that denote the allowed\n            End Of Response. For most commands, it should be\n            ``('\\\\n', '\\\\n- ')``, but for running a program, it should\n            be ``'*END\\\\n'``. The default is ``('\\\\n', '\\\\n- ')``.\n\n        Returns\n        -------\n        output : list\n            A 5-element ``list``. The elements, in order, are the\n            sanitized command (``str``), the full response (``str``),\n            the echoed command (``str``), any error response (``None``\n            if none, or the ``str`` of the error), and the lines of the\n            response that are not the echo or error line (``list`` of\n            ``str`` with newlines stripped).\n\n        See Also\n        --------\n        send_commands : Send multiple commands.\n\n        Examples\n        --------\n\n        Simple command energizing the motor with no response and no\n        errors.\n\n        >>> from GeminiMotorDrive.drivers import ASCII_RS232\n        >>> ar = ASCII_RS232('/dev/ttyS1')\n        >>> ar.send_command('DRIVE1', immediate=False, timeout=1.0)\n        ['DRIVE1', 'DRIVE1\\\\r\\\\r\\\\n', 'DRIVE1', None, []]\n\n        Same command but made immediate.\n\n        >>> from GeminiMotorDrive.drivers import ASCII_RS232\n        >>> ar = ASCII_RS232('/dev/ttyS1')\n        >>> ar.send_command('DRIVE1', immediate=True, timeout=1.0)\n        ['!DRIVE1', '!DRIVE1\\\\r\\\\r\\\\n', '!DRIVE1', None, []]\n\n        Same command with a typo.\n\n        >>> from GeminiMotorDrive.drivers import ASCII_RS232\n        >>> ar = ASCII_RS232('/dev/ttyS1')\n        >>> ar.send_command('DRIV1', immediate=False, timeout=1.0)\n        ['DRIV1', 'DRIV1\\\\r*UNDEFINED_LABEL\\\\r\\\\r\\\\n', 'DRIV1',\n         'UNDEFINED_LABEL', []]\n\n        Simple command asking whether the motor is energized or not.\n\n        >>> from GeminiMotorDrive.drivers import ASCII_RS232\n        >>> ar = ASCII_RS232('/dev/ttyS1')\n        >>> ar.send_command('DRIVE', immediate=False, timeout=1.0)\n        ['DRIVE', 'DRIVE\\\\r*DRIVE1\\\\r\\\\r\\\\n', 'DRIVE', None,\n         ['*DRIVE1']]\n\n        \"\"\"\n        # Execute the command till it either doesn't have an error or\n        # the maximum number of retries is exceeded.\n        for i in range(0, max_retries+1):\n            # Send the command and stuff the sanitized version in a\n            # list. Then process the response and add it to the list.\n            response = [self._send_command(command,\n                        immediate=immediate)]\n            output = self._get_response(timeout=timeout, eor=eor)\n            # If echo checking was done, the echo was already grabbed,\n            # is identical to the command, and needs to be placed back\n            # in front of the output so that it can be processed\n            # properly.\n            if self._check_echo:\n                output = response[0] + output\n            response.extend(self._process_response(output))\n            # We are done if there is no error.\n            if not self.command_error(response):\n                break\n            # Put in a slight pause so the drive has a bit of breathing\n            # time between retries.\n            time.sleep(0.25)\n        return response", "response": "Sends a single command to the Gemini drive and returns the output."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a sequence of commands to the drive and returns the output of the last command.", "response": "def send_commands(self, commands, timeout=1.0,\n                      max_retries=1, eor=('\\n', '\\n- ')):\n        \"\"\" Send a sequence of commands to the drive and collect output.\n\n        Takes a sequence of many commands and executes them one by one\n        till either all are executed or one runs out of retries\n        (`max_retries`). Retries are optionally performed if a command's\n        repsonse indicates that there was an error. Remaining commands\n        are not executed. The processed output of the final execution\n        (last try or retry) of each command that was actually executed\n        is returned.\n\n        This function basically feeds commands one by one to\n        ``send_command`` and collates the outputs.\n\n        Parameters\n        ----------\n        commands : iterable of str\n            Iterable of commands to send to the drive. Each command must\n            be an ``str``.\n        timeout : float or None, optional\n            Optional timeout in seconds to use when reading the\n            response. A negative value or ``None`` indicates that the\n            an infinite timeout should be used.\n        max_retries : int, optional\n            Maximum number of retries to do per command in the case of\n            errors.\n        eor : str or iterable of str, optional\n            End Of Resonse. An EOR is either a ``str`` or an iterable\n            of ``str`` that denote the possible endings of a response.\n            'eor' can be a single EOR, in which case it is used for all\n            commands, or it can be an iterable of EOR to use for each\n            individual command. For most commands, it should be\n            ``('\\\\n', '\\\\n- ')``, but for running a program, it should\n            be ``'*END\\\\n'``. The default is ``('\\\\n', '\\\\n- ')``.\n\n        Returns\n        -------\n        outputs : list of lists\n            ``list`` composed of the processed responses of each command\n            in the order that they were done up to and including the\n            last command executed. See ``send_command`` for the format\n            of processed responses.\n\n        See Also\n        --------\n        send_command : Send a single command.\n\n        Examples\n        --------\n\n        A sequence of commands to energize the motor, move it a bit away\n        from the starting position, and then do 4 forward/reverse\n        cycles, and de-energize the motor. **DO NOT** try these specific\n        movement distances without checking that the motion won't damage\n        something (very motor and application specific).\n\n        >>> from GeminiMotorDrive.drivers import ASCII_RS232\n        >>> ra = ASCII_RS232('/dev/ttyS1')\n        >>> ra.send_commands(['DRIVE1', 'D-10000', 'GO']\n        ...                  + ['D-10000','GO','D10000','GO']*4\n        ...                  + [ 'DRIVE0'])\n        [['DRIVE1', 'DRIVE1\\\\r', 'DRIVE1', None, []],\n         ['D-10000', 'D-10000\\\\r', 'D-10000', None, []],\n         ['GO', 'GO\\\\r', 'GO', None, []],\n         ['D-10000', 'D-10000\\\\r', 'D-10000', None, []],\n         ['GO', 'GO\\\\r', 'GO', None, []],\n         ['D10000', 'D10000\\\\r', 'D10000', None, []],\n         ['GO', 'GO\\\\r', 'GO', None, []],\n         ['D-10000', 'D-10000\\\\r', 'D-10000', None, []],\n         ['GO', 'GO\\\\r', 'GO', None, []],\n         ['D10000', 'D10000\\\\r', 'D10000', None, []],\n         ['GO', 'GO\\\\r', 'GO', None, []],\n         ['D-10000', 'D-10000\\\\r', 'D-10000', None, []],\n         ['GO', 'GO\\\\r', 'GO', None, []],\n         ['D10000', 'D10000\\\\r', 'D10000', None, []],\n         ['GO', 'GO\\\\r', 'GO', None, []],\n         ['D-10000', 'D-10000\\\\r', 'D-10000', None, []],\n         ['GO', 'GO\\\\r', 'GO', None, []],\n         ['D10000', 'D10000\\\\r', 'D10000', None, []],\n         ['GO', 'GO\\\\r', 'GO', None, []],\n         ['DRIVE0', 'DRIVE0\\\\r', 'DRIVE0', None, []]]\n\n        \"\"\"\n        # If eor is not a list, make a list of it replicated enough for\n        # every command.\n        if not isinstance(eor, list):\n            eor = [eor]*len(commands)\n        # Do every command one by one, collecting the responses and\n        # stuffing them in a list. Commands that failed are retried, and\n        # we stop if the last retry is exhausted.\n        responses = []\n        for i, command in enumerate(commands):\n            rsp = self.send_command(command, timeout=timeout,\n                                    max_retries=max_retries,\n                                    eor=eor[i])\n            responses.append(rsp)\n            if self.command_error(rsp):\n                break\n            # Put in a slight pause so the drive has a bit of breathing\n            # time between commands.\n            time.sleep(0.25)\n        return responses"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef low_level_scan(self, verification_resource, scan_profile_resource,\n                       path_list, notification_resource_list):\n        \"\"\"\n        Low level implementation of the scan launch which allows you to start\n        a new scan when you already know the ids for the required resources.\n\n        :param verification_resource: The verification associated with the\n                                      domain resource to scan\n        :param scan_profile_resource: The scan profile resource\n        :param path_list: A list with the paths\n        :param notification_resource_list: The notifications to use\n\n        All the *_resource* parameters are obtained by calling the respective\n        getters such as:\n            - get_email_notification\n            - get_scan_profile\n\n        And are expected to be of Resource type\n\n        This method's last step is to send a POST request to /1.0/scans/ using\n        a post-data similar to:\n\n            {\"verification_href\": \"/1.0/verifications/6\",\n             \"profile_href\": \"/1.0/profiles/2\",\n             \"start_time\": \"now\",\n             \"email_notifications_href\": [],\n             \"path_list\": [\"/\"]}'\n\n        :return: The newly generated scan id\n        \"\"\"\n        data = {\"verification_href\": verification_resource.href,\n                \"profile_href\": scan_profile_resource.href,\n                \"start_time\": \"now\",\n                \"email_notifications_href\": [n.href for n in notification_resource_list],\n                \"path_list\": path_list}\n        url = self.build_full_url('/scans/')\n        return self.create_resource(url, data)", "response": "This method is used to start a new scan when you already know the ids for the required resources."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a POST to the verification add endpoint", "response": "def verification_add(self, domain_resource_id, port, is_ssl):\n        \"\"\"\n        Sends a POST to /1.0/verifications/ using this post-data:\n\n            {\"domain_href\": \"/1.0/domains/2\",\n             \"port\":80,\n             \"ssl\":false}\n\n        :param domain_resource_id: The domain id to verify\n        :param port: The TCP port\n        :param is_ssl: Boolean indicating if we should use ssl\n\n        :return: The newly created resource\n        \"\"\"\n        data = {\"domain_href\": self.build_api_path('domains',\n                                                   domain_resource_id),\n                \"port\": port,\n                \"ssl\": 'true' if is_ssl else 'false'}\n        url = self.build_full_url(self.VERIFICATIONS)\n        return self.create_resource(url, data)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter_resource(self, resource_name, field_name, field_value,\n                        result_handler=ONE_RESULT):\n        \"\"\"\n        :return: The resource (as json), or None\n        \"\"\"\n        return self.multi_filter_resource(resource_name,\n                                          {field_name: field_value},\n                                          result_handler=result_handler)", "response": "Filter the resource by field name and value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef email_notification_add(self, notif_email, first_name='None',\n                               last_name='None', description=DESCRIPTION):\n        \"\"\"\n        Sends a POST to /1.0/notifications/email/ using this post-data:\n\n            {\"email\": \"andres.riancho@gmail.com\",\n             \"first_name\": \"Andres\",\n             \"last_name\": \"Riancho\",\n             \"description\": \"Notification email\"}\n\n        :return: The id of the newly created email notification resource\n        \"\"\"\n        data = {\"email\": notif_email,\n                \"first_name\": first_name,\n                \"last_name\": last_name,\n                \"description\": description}\n        url = self.build_full_url('/notifications/email/')\n        return self.create_resource(url, data)", "response": "Sends a POST to the email notification email endpoint and returns the id of the created email notification resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a new domain to the tagcube - api.", "response": "def domain_add(self, domain, description=DESCRIPTION):\n        \"\"\"\n        Sends a POST to /1.0/domains/ using this post-data:\n\n            {\"domain\": \"www.fogfu.com\",\n             \"description\":\"Added by tagcube-api\"}\n\n        :param domain: The domain name to add as a new resource\n        :return: The newly created resource\n        \"\"\"\n        data = {\"domain\": domain,\n                \"description\": description}\n        url = self.build_full_url(self.DOMAINS)\n        return self.create_resource(url, data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_scan(self, scan_id):\n        url = self.build_full_url('%s%s' % (self.SCANS, scan_id))\n        _, json_data = self.send_request(url)\n        return Resource(json_data)", "response": "Get the scan information for a given scan ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef handle_api_errors(self, status_code, json_data):\n        error_list = []\n\n        if 'error' in json_data and len(json_data) == 1 \\\n        and isinstance(json_data, dict) and isinstance(json_data['error'], list):\n            error_list = json_data['error']\n\n        elif status_code == 400:\n            for main_error_key in json_data:\n                for sub_error_key in json_data[main_error_key]:\n                    error_list.extend(json_data[main_error_key][sub_error_key])\n\n        # Only raise an exception if we had any errors\n        if error_list:\n            error_string = u' '.join(error_list)\n            raise TagCubeAPIException(error_string)", "response": "This method parses the HTTP response body and raises an exception if required."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setAsApplication(myappid):\n\n    if os.name == 'nt':\n        import ctypes\n        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)", "response": "Tells Windows this is an independent application with an unique icon on task bar."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getBestTranslation(basedir, lang=None):\n    if not lang:\n        lang = QtCore.QLocale.system().uiLanguages()\n\n    for l in lang:\n\n        l = l.translate({ord('_'): '-'})\n        f = os.path.join(basedir, l+'.qm')\n        if os.path.isfile(f): break\n\n        l = l.translate({ord('-'): '_'})\n        f = os.path.join(basedir, l+'.qm')\n        if os.path.isfile(f): break\n\n        l = l.split('_')[0]\n        f = os.path.join(basedir, l+'.qm')\n        if os.path.isfile(f): break\n\n    else:\n        return None\n\n    translator = QtCore.QTranslator()\n    translator.load(f)\n    return translator", "response": "Find the best translation available in the given basedir."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef interpretValue(value,*args,**kwargs):\n    if callable(value): return value(*args,**kwargs)\n    if isinstance(value,tuple) or isinstance(value,list) or isinstance(value,dict):\n        if len(args)==1 and kwargs=={}:\n            return value[args[0]]\n    return value", "response": "Interprets a passed value."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninterprets a passed value.", "response": "def specialInterpretValue(value,index,*args,**kwargs):\n    \"\"\"Interprets a passed value. In this order:\n     - If it's callable, call it with the parameters provided\n     - If it's a tuple/list/dict and index is not None, look up index within the tuple/list/dict\n     - Else, just return it\n     \"\"\"\n    if callable(value): return value(*args,**kwargs)\n    if index is not None and (isinstance(value,tuple) or isinstance(value,list) or isinstance(value,dict)): return value[index]\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef normalize(cls, name):\n        name = name.lower() # lower-case\n        for _replace in [' ','-','(',')','?']:\n            name = name.replace(_replace,'')\n        return name", "response": "Return string in all lower case with spaces and question marks removed"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a Python datetime object based on the dateTimeString", "response": "def manage(self, dateTimeString):\n        \"\"\"Return a Python datetime object based on the dateTimeString\n        \n        This will handle date times in the following formats:\n            YYYY/MM/DD HH:MM:SS\n            2014/11/05 21:47:28\n            2014/11/5 21:47:28\n            11/05/2014\n            11/5/2014\n            11/05/2014 16:28:00\n            11/05/2014 16:28\n            11/5/2014 16:28:00\n            11/5/2014 16:28\n        It can also handle these formats when using a - instead of a / for a \n        date separator.\n        \"\"\"\n        dateTime = None\n        dateTimeString = dateTimeString.replace('-', '/')\n        \n        _date_time_split = dateTimeString.split(' ') # [0] = date, [1] = time (if exists)\n        _date = _date_time_split[0]\n        _time = '00:00:00' # default\n        if len(_date_time_split) > 1:\n            _time = _date_time_split[1]\n        \n        if dateTimeString.find('/') == 4: # YYYY/MM/DD...\n            dateList = _date.split('/') + _time.split(':')\n            dateTime = datetime(*map(lambda x: int(x), dateList))\n        elif 1 <= dateTimeString.find('/') <= 2: # MM/DD/YYYY or M/D?/YYYY\n            _date_split = _date.split('/')\n            dateList = [_date_split[2], _date_split[0], _date_split[1]] + _time.split(':')\n            dateTime = datetime(*map(lambda x: int(x), dateList))\n        if not dateTime:\n            raise ValueError(\"unable to manage unsupported string format: %s\"%(dateTimeString))\n        \n        return dateTime"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef nein(x):\n    \"this is 'not' but not is a keyword so it's 'nein'\"\n    if not isinstance(x,(bool,ThreeVL)): raise TypeError(type(x))\n    return not x if isinstance(x,bool) else ThreeVL(dict(t='f',f='t',u='u')[x.value])", "response": "this is not but not is a keyword so it s nein"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef login(request, signature):\n    signer = TimestampSigner()\n    try:\n        pk = signer.unsign(signature, max_age=MAX_AGE_OF_SIGNATURE_IN_SECONDS)\n    except (BadSignature, SignatureExpired) as e:\n        return HttpResponseForbidden(\"Can't log you in\")\n\n    user = get_object_or_404(get_user_model(), pk=pk)\n    # we *have* to set the backend for this user, so we just use the first one\n    user.backend = settings.AUTHENTICATION_BACKENDS[0]\n    django_login(request, user)\n\n    return HttpResponseRedirect(settings.LOGIN_REDIRECT_URL)", "response": "Log in a user based on a signed PK."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmasquerades as a particular user and redirect based on the REDIRECT_FIELD_NAME parameter, or the LOGIN_REDIRECT_URL. Callers can either pass the pk of the user in the URL itself, or as a POST param.", "response": "def cloak(request, pk=None):\n    \"\"\"\n    Masquerade as a particular user and redirect based on the\n    REDIRECT_FIELD_NAME parameter, or the LOGIN_REDIRECT_URL.\n\n    Callers can either pass the pk of the user in the URL itself, or as a POST\n    param.\n    \"\"\"\n    pk = request.POST.get('pk', pk)\n    if pk is None:\n        return HttpResponse(\"You need to pass a pk POST parameter, or include it in the URL\")\n\n    user = get_object_or_404(get_user_model(), pk=pk)\n\n    if not can_cloak_as(request.user, user):\n        return HttpResponseForbidden(\"You are not allowed to cloak as this user\")\n\n    request.session[SESSION_USER_KEY] = user.pk\n    # save the referer information so when uncloaking, we can redirect the user\n    # back to where they were\n    request.session[SESSION_REDIRECT_KEY] = request.META.get(\"HTTP_REFERER\", settings.LOGIN_REDIRECT_URL)\n\n    # redirect the cloaked user to the URL specified in the \"next\" parameter,\n    # or to the default redirect URL\n    return HttpResponseRedirect(request.POST.get(REDIRECT_FIELD_NAME, settings.LOGIN_REDIRECT_URL))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nundoes a masquerade session and redirect the user to where they started", "response": "def uncloak(request):\n    \"\"\"\n    Undo a masquerade session and redirect the user back to where they started\n    cloaking from (or where ever the \"next\" POST parameter points)\n    \"\"\"\n    try:\n        del request.session[SESSION_USER_KEY]\n    except KeyError:\n        pass # who cares\n\n    # figure out where to redirect\n    next = request.POST.get(REDIRECT_FIELD_NAME) or request.session.get(SESSION_REDIRECT_KEY)\n    if next and is_safe_url(next, request.get_host()):\n        return HttpResponseRedirect(next)\n    return HttpResponseRedirect(settings.LOGIN_REDIRECT_URL)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(self):\n        client = None\n\n        if self.cmd_args.subcommand in self.API_SUBCOMMAND:\n            email, api_key = TagCubeCLI.get_credentials(self.cmd_args)\n            client = TagCubeClient(email, api_key, verbose=self.cmd_args.verbose)\n\n        subcommands = {'auth': do_auth_test,\n                       'scan': do_scan_start,\n                       'batch': do_batch_scan,\n                       'version': do_version}\n\n        try:\n            subcommands.get(self.cmd_args.subcommand)(client, self.cmd_args)\n\n        except ConnectionError, ce:\n            msg = 'Failed to connect to TagCube REST API: \"%s\"'\n            cli_logger.error(msg % ce)\n            return 3\n\n        except TagCubeAPIException, tae:\n            cli_logger.error('%s' % tae)\n            return 4\n\n        return 0", "response": "This method handles the command line arguments for example if\n            is set to True we will open it and read the contents of it and then run the scan using the command line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_args(args=None):\n        #\n        #   The main parser\n        #\n        parser = argparse.ArgumentParser(prog='tagcube',\n                                         description=DESCRIPTION,\n                                         epilog=EPILOG)\n\n        #\n        #   Parser for the common arguments\n        #\n        common_parser = argparse.ArgumentParser(add_help=False)\n\n        common_parser.add_argument('--email',\n                                   required=False,\n                                   dest='email',\n                                   type=argparse_email_type,\n                                   help='The email address (user) to use when'\n                                        ' sending requests to TagCube\\'s REST'\n                                        ' API')\n\n        common_parser.add_argument('--key',\n                                   required=False,\n                                   dest='key',\n                                   type=argparse_uuid_type,\n                                   help='The API key to authenticate with'\n                                        ' TagCube\\'s REST API')\n\n        common_parser.add_argument('-v',\n                                   required=False,\n                                   dest='verbose',\n                                   action='store_true',\n                                   help='Enables verbose output')\n\n        #\n        #   Parser for common scan arguments\n        #\n        scan_common = argparse.ArgumentParser(add_help=False)\n\n        scan_common.add_argument('--scan-profile',\n                                 required=False,\n                                 dest='scan_profile',\n                                 default='full_audit',\n                                 help='The web application scan profile to use.'\n                                      ' A complete list of scan profiles can be'\n                                      ' retrieved from the API or Web UI.')\n\n        scan_common.add_argument('--email-notify',\n                                 required=False,\n                                 dest='email_notify',\n                                 type=argparse_email_type,\n                                 help='Email address to notify when application'\n                                      ' scan finishes')\n\n        #\n        #   Handle subcommands\n        #\n        subparsers = parser.add_subparsers(help='TagCube sub-commands',\n                                           dest='subcommand')\n\n        #\n        #   Auth test subcommand\n        #\n        _help = ('Test configured authentication credentials and exit. No'\n                 ' target URL nor email notifications need to be configured'\n                 ' to verify the credentials.')\n        auth_parser = subparsers.add_parser('auth',\n                                            help=_help,\n                                            parents=[common_parser])\n\n        #\n        #   Scan\n        #\n        scan_parser = subparsers.add_parser('scan',\n                                            help='Web application security'\n                                                 ' scan using TagCube',\n                                            parents=[common_parser,\n                                                     scan_common])\n\n        scan_parser.add_argument('--root-url',\n                                 required=True,\n                                 dest='root_url',\n                                 type=argparse_url_type,\n                                 help='Root URL for web application security'\n                                      ' scan (e.g. https://www.target.com/)')\n\n        scan_parser.add_argument('--path-file',\n                                 required=False,\n                                 dest='path_file',\n                                 default=['/'],\n                                 type=argparse_path_list_type,\n                                 help='A file specifying the URL paths (without'\n                                      ' the domain name) which TagCube will use'\n                                      ' to bootstrap the web crawler. The \"/\"'\n                                      ' path is used when no'\n                                      ' --path-file parameter is specified.')\n\n        #\n        #   Batch scan subcommand\n        #\n        _help = ('Scan multiple domains and URLs in one command, one scan will'\n                 ' be started for each unique protocol-domain-port tuple, the'\n                 ' URLs paths are processed and sent in the scan configuration')\n        batch_parser = subparsers.add_parser('batch',\n                                             help=_help,\n                                             parents=[common_parser,\n                                                      scan_common])\n\n        batch_parser.add_argument('--urls-file',\n                                  required=True,\n                                  dest='urls_file',\n                                  type=argparse.FileType('r'),\n                                  help='Text file containing one URL per line')\n\n        #\n        #   Version subcommand\n        #\n        _help = 'Print the tagcube-cli version'\n        version_parser = subparsers.add_parser('version', help=_help)\n\n        cmd_args = parser.parse_args(args)\n\n        handlers = {'scan': TagCubeCLI.handle_scan_args,\n                    'auth': TagCubeCLI.handle_auth_args,\n                    'batch': TagCubeCLI.handle_batch_args,\n                    'version': TagCubeCLI.handle_version_args,}\n\n        handler = handlers.get(cmd_args.subcommand)\n        return handler(parser, cmd_args)", "response": "Parse the arguments and return the result of applying argparse to sys. argv."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_credentials(cmd_args):\n        # Check the cmd args, return if we have something here\n        cmd_credentials = cmd_args.email, cmd_args.key\n        if cmd_credentials != (None, None):\n            cli_logger.debug('Using command line configured credentials')\n            return cmd_credentials\n\n        env_email, env_api_key = get_config_from_env()\n        if env_email is not None:\n            if env_api_key is not None:\n                cli_logger.debug('Using environment configured credentials')\n                return env_email, env_api_key\n\n        cfg_email, cfg_api_key = parse_config_file()\n        if cfg_email is not None:\n            if cfg_api_key is not None:\n                cli_logger.debug('Using .tagcube file configured credentials')\n                return cfg_email, cfg_api_key\n\n        raise ValueError(NO_CREDENTIALS_ERROR)", "response": "This function will try to get the credentials from the command line environment variables and configuration files."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the path of this config value as a string", "response": "def path(self) -> str:\n        \"\"\"\n        :return: path of this config value as a string\n        \"\"\"\n        path: str = ELIBConfig.config_sep_str.join(self._raw_path)\n        if ELIBConfig.root_path:\n            prefix = ELIBConfig.config_sep_str.join(ELIBConfig.root_path)\n            path = ELIBConfig.config_sep_str.join((prefix, path))\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the raw value of the key.", "response": "def raw_value(self) -> typing.Optional[object]:\n        \"\"\"\n        :return: raw value\n        \"\"\"\n        raw_value = self._from_environ()\n        if raw_value is None:\n            raw_value = self._from_config_file()\n        if raw_value is None:\n            raw_value = self._from_default()\n        return raw_value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nselect a template from a string which can include multiple template paths separated by commas.", "response": "def select_template_from_string(arg):\n    \"\"\"\n    Select a template from a string, which can include multiple\n    template paths separated by commas.\n    \n    \"\"\"\n    if ',' in arg:\n        tpl = loader.select_template(\n            [tn.strip() for tn in arg.split(',')])\n    else:\n        tpl = loader.get_template(arg)\n    return tpl"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_package_path(self):\n        if not self.package:\n            return []\n        if not hasattr(self, 'package_path'):\n            m = __import__(self.package)\n            parts = self.package.split('.')[1:]\n            self.package_path = os.path.join(os.path.dirname(m.__file__), *parts)\n        return [self.package_path]", "response": "Gets the path of a Python package"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of paths to search for plugins in The list is searched in order.", "response": "def _get_paths(self):\n        \"\"\"Return a list of paths to search for plugins in\n\n        The list is searched in order.\"\"\"\n        ret = []\n        ret += ['%s/library/' % os.path.dirname(os.path.dirname(__file__))]        \n        \n        ret += self._extra_dirs\n        for basedir in _basedirs:\n            fullpath = os.path.join(basedir, self.subdir)\n            if fullpath not in ret:\n                ret.append(fullpath)\n        ret += self.config.split(os.pathsep)\n        ret += self._get_package_path()\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a string suitable for printing of the search path", "response": "def print_paths(self):\n        \"\"\"Returns a string suitable for printing of the search path\"\"\"\n        # Uses a list to get the order right\n        ret = []\n        for i in self._get_paths():\n            if i not in ret:\n                ret.append(i)\n        return os.pathsep.join(ret)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_plugin(self, name):\n        suffix = \".py\"\n        if not self.class_name:\n            suffix = \"\"\n        for i in self._get_paths():\n            path = os.path.join(i, \"%s%s\" % (name, suffix))\n            if os.path.exists(path):\n                return path\n        return None", "response": "Find a plugin named name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_xml(xml):\n        hasAcquisitionFields = False\n        acquisitionFields = []\n        isClosed = False\n        isSummaryRecord = False\n        contentOfFMT = \"\"\n        parsedSummaryRecordSysNumber = \"\"\n        summaryRecordSysNumber = \"\"\n\n        parsed = xml\n        if not isinstance(xml, MARCXMLRecord):\n            parsed = MARCXMLRecord(str(xml))\n\n        # handle FMT record\n        if \"FMT\" in parsed.controlfields:\n            contentOfFMT = parsed[\"FMT\"]\n\n            if contentOfFMT == \"SE\":\n                isSummaryRecord = True\n\n        if \"HLD\" in parsed.datafields or \"HLD\" in parsed.controlfields:\n            hasAcquisitionFields = True\n\n            if \"STZ\" in parsed.datafields:\n                acquisitionFields.extend(parsed[\"STZa\"])\n                acquisitionFields.extend(parsed[\"STZb\"])\n\n        def sign_and_author(sign):\n            \"\"\"\n            Sign is stored in ISTa, author's name is in ISTb.\n\n            Sign is MarcSubrecord obj with pointers to other subrecords, so it\n            is possible to pick references to author's name from signs.\n            \"\"\"\n            return [sign.replace(\" \", \"\")] + sign.other_subfields.get(\"b\", [])\n\n        # look for catalogization fields\n        for orig_sign in parsed[\"ISTa\"]:\n            sign = orig_sign.replace(\" \", \"\")  # remove spaces\n\n            if sign.startswith(\"sk\"):\n                hasAcquisitionFields = True\n                acquisitionFields.extend(sign_and_author(orig_sign))\n\n        # look whether the record was 'closed' by catalogizators\n        for status in parsed[\"BASa\"]:\n            if status == \"90\":\n                isClosed = True\n\n        # if multiple PJM statuses are present, join them together\n        status = \"\\n\".join([x for x in parsed[\"PJMa\"]])\n\n        # detect link to 'new' record, if the old one was 'closed'\n        if status.strip():\n            summaryRecordSysNumber = status\n            parsedSummaryRecordSysNumber = _parse_summaryRecordSysNumber(\n                summaryRecordSysNumber\n            )\n\n        return EPeriodicalSemanticInfo(\n            hasAcquisitionFields=hasAcquisitionFields,\n            acquisitionFields=acquisitionFields,\n            isClosed=isClosed,\n            isSummaryRecord=isSummaryRecord,\n            contentOfFMT=contentOfFMT,\n            parsedSummaryRecordSysNumber=parsedSummaryRecordSysNumber,\n            summaryRecordSysNumber=summaryRecordSysNumber,\n        )", "response": "Returns a new instance of the class. SemanticInfo class with information from the given MarcXML."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getMonitors(self, apikey, monitors='none'):\n        data= 'api_key=' + apikey + '&format=json'\n        if monitors != 'none':\n            data += '&monitors=' + monitors\n        fetchUrl = self.BASE_URL\n        fetchUrl += 'getMonitors'\n        try:\n            monitors = requests.post(fetchUrl,\n                headers=self.headers, data=data, timeout=3)\n        except:\n            return False\n        else:\n            if monitors:\n                return monitors.json()\n            else:\n                return False", "response": "Get departure info from stopid."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_reporting_args(parser):\n    g = parser.add_argument_group('Reporting options')\n\n    g.add_argument('-l', '--log-file', default=None,\n            type = str_type, metavar = file_mv, help = textwrap.dedent(\"\"\"\\\n                Path of log file (if specified, report to stdout AND file.\"\"\"))\n\n    g.add_argument('-q', '--quiet', action='store_true',\n            help = 'Only output errors and warnings.')\n\n    g.add_argument('-v', '--verbose', action='store_true',\n            help = 'Enable verbose output. Ignored if --quiet is specified.')\n\n    return parser", "response": "Adds reporting arguments to an argument parser."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the contents of a message from the file.", "response": "def getMessage(self, message):\n        '''\n        Conveniently retrieves message contents from a batch file. Can throw a\n        :class:`python:RuntimeError` if the message batch filename doesn't\n        match this batch filename.\n        '''\n        if message.filename != self._filename:\n            raise RuntimeError(\n                'Message filename ({:}) does not match batch filename ({:}).'\n                .format(message.filename, self._filename))\n        self._file.seek(message.offset)\n        self._logger.debug(\n            'Retrieved message offset={:}, size={:}'\n            .format(message.offset, message.size))\n        return self._file.read(message.size)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef utc_offset_by_timezone(timezone_name):\n    return int(pytz.timezone(timezone_name).utcoffset(\n        utc_time()).total_seconds()/SECONDS_IN_HOUR)", "response": "Returns the UTC offset of the given timezone in hours."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlocalize the given UTC - aligned datetime by the given timezone.", "response": "def localize_datetime(datetime_obj, timezone_name):\n    \"\"\"Localizes the given UTC-aligned datetime by the given timezone.\n\n    Arguments\n    ---------\n    datetime_obj : datetime.datetime\n        A datetime object decipting a specific point in time, aligned by UTC.\n    timezone_name: str\n        A string with a name of a timezone.\n\n    Returns\n    -------\n    datetime.datetime\n        An datetime object aligned by the given timezone.\n    \"\"\"\n    return datetime_obj.replace(tzinfo=pytz.utc).astimezone(\n        pytz.timezone(timezone_name))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _load_build(self):\n        # if the ctor. function (penultimate on the stack) is the `Ref` class...\n        if isinstance(self.stack[-2], Ref):\n            # Ref.__setstate__ will know it's a remote ref if the state is a tuple\n            self.stack[-1] = (self.stack[-1], self.node)\n\n            self.load_build()  # continue with the default implementation\n\n            # detect our own refs sent back to us\n            ref = self.stack[-1]\n            if ref.uri.node == self.node.nid:\n                ref.is_local = True\n                ref._cell = self.node.guardian.lookup_cell(ref.uri)\n                # dbg((\"dead \" if not ref._cell else \"\") + \"local ref detected\")\n                del ref.node  # local refs never need access to the node\n        else:  # pragma: no cover\n            self.load_build()", "response": "Load the build from the stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef path_to_zip(path):\n    if not os.path.exists(path):\n        raise IOError(\"%s doesn't exists!\" % path)\n\n    with tempfile.NamedTemporaryFile(delete=False) as ntf:\n        zip_fn = ntf.name\n\n    with zipfile.ZipFile(zip_fn, mode=\"w\") as zip_file:\n        for root, dirs, files in os.walk(path):\n            for fn in files:\n                zip_file.write(os.path.join(root, fn))\n\n    return zip_fn", "response": "Compress path to the ZIP."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts given fn to base64 and return it.", "response": "def read_as_base64(fn):\n    \"\"\"\n    Convert given `fn` to base64 and return it. This method does the process\n    in not-so-much memory consuming way.\n\n    Args:\n        fn (str): Path to the file which should be converted.\n\n    Returns:\n        str: File encoded as base64.\n    \"\"\"\n    with open(fn) as unpacked_file:\n        with tempfile.TemporaryFile() as b64_file:\n            base64.encode(unpacked_file, b64_file)\n            b64_file.flush()\n\n            b64_file.seek(0)\n            return b64_file.read()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _pad_input(incoming):\n    incoming_expanded = incoming.replace('{', '{{').replace('}', '}}')\n    for key in _BASE_CODES:\n        before, after = '{{%s}}' % key, '{%s}' % key\n        if before in incoming_expanded:\n            incoming_expanded = incoming_expanded.replace(before, after)\n    return incoming_expanded", "response": "Avoid IndexError and KeyError by ignoring un - related fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_input(incoming):\n    codes = dict((k, v) for k, v in _AutoCodes().items() if '{%s}' % k in incoming)\n    color_codes = dict((k, '' if _AutoCodes.DISABLE_COLORS else '\\033[{0}m'.format(v)) for k, v in codes.items())\n    incoming_padded = _pad_input(incoming)\n    output_colors = incoming_padded.format(**color_codes)\n\n    # Simplify: '{b}{red}' -> '\\033[1m\\033[31m' -> '\\033[1;31m'\n    groups = sorted(set(_RE_GROUP_SEARCH.findall(output_colors)), key=len, reverse=True)  # Get codes, grouped adjacent.\n    groups_simplified = [[x for n in _RE_NUMBER_SEARCH.findall(i) for x in n.split(';')] for i in groups]\n    groups_compiled = ['\\033[{0}m'.format(';'.join(g)) for g in groups_simplified]  # Final codes.\n    assert len(groups_compiled) == len(groups)  # For testing.\n    output_colors_simplified = output_colors\n    for i in range(len(groups)):\n        output_colors_simplified = output_colors_simplified.replace(groups[i], groups_compiled[i])\n    output_no_colors = _RE_SPLIT.sub('', output_colors_simplified)\n\n    # Strip any remaining color codes.\n    if _AutoCodes.DISABLE_COLORS:\n        output_colors_simplified = _RE_NUMBER_SEARCH.sub('', output_colors_simplified)\n\n    return output_colors_simplified, output_no_colors", "response": "Performs the actual conversion of tags to ANSI escaped codes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist the available tags.", "response": "def list_tags():\n    \"\"\"Lists the available tags.\n\n    Returns:\n    Tuple of tuples. Child tuples are four items: ('opening tag', 'closing tag', main ansi value, closing ansi value).\n    \"\"\"\n    codes = _AutoCodes()\n    grouped = set([(k, '/{0}'.format(k), codes[k], codes['/{0}'.format(k)]) for k in codes if not k.startswith('/')])\n\n    # Add half-tags like /all.\n    found = [c for r in grouped for c in r[:2]]\n    missing = set([('', r[0], None, r[1]) if r[0].startswith('/') else (r[0], '', r[1], None)\n                   for r in _AutoCodes().items() if r[0] not in found])\n    grouped |= missing\n\n    # Sort.\n    payload = sorted([i for i in grouped if i[2] is None], key=lambda x: x[3])  # /all /fg /bg\n    grouped -= set(payload)\n    payload.extend(sorted([i for i in grouped if i[2] < 10], key=lambda x: x[2]))  # b i u flash\n    grouped -= set(payload)\n    payload.extend(sorted([i for i in grouped if i[0].startswith('auto')], key=lambda x: x[2]))  # auto colors\n    grouped -= set(payload)\n    payload.extend(sorted([i for i in grouped if not i[0].startswith('hi')], key=lambda x: x[2]))  # dark colors\n    grouped -= set(payload)\n    payload.extend(sorted(grouped, key=lambda x: x[2]))  # light colors\n    return tuple(payload)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrestore sys. stderr and sys. stdout to their original objects. Resets colors to their original values.", "response": "def disable():\n        \"\"\"Restore sys.stderr and sys.stdout to their original objects. Resets colors to their original values.\"\"\"\n        if os.name != 'nt' or not Windows.is_enabled():\n            return False\n\n        getattr(sys.stderr, '_reset_colors', lambda: False)()\n        getattr(sys.stdout, '_reset_colors', lambda: False)()\n\n        if isinstance(sys.stderr, _WindowsStream):\n            sys.stderr = getattr(sys.stderr, 'original_stream')\n        if isinstance(sys.stderr, _WindowsStream):\n            sys.stdout = getattr(sys.stdout, 'original_stream')\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nenabling color text with sys. stdout. write or sys. stderr.", "response": "def enable(auto_colors=False, reset_atexit=False):\n        \"\"\"Enables color text with print() or sys.stdout.write() (stderr too).\n\n        Keyword arguments:\n        auto_colors -- automatically selects dark or light colors based on current terminal's background color. Only\n            works with {autored} and related tags.\n        reset_atexit -- resets original colors upon Python exit (in case you forget to reset it yourself with a closing\n            tag).\n        \"\"\"\n        if os.name != 'nt':\n            return False\n\n        # Overwrite stream references.\n        if not isinstance(sys.stderr, _WindowsStream):\n            sys.stderr.flush()\n            sys.stderr = _WindowsStream(stderr=True)\n        if not isinstance(sys.stdout, _WindowsStream):\n            sys.stdout.flush()\n            sys.stdout = _WindowsStream(stderr=False)\n        if not isinstance(sys.stderr, _WindowsStream) and not isinstance(sys.stdout, _WindowsStream):\n            return False\n\n        # Automatically select which colors to display.\n        bg_color = getattr(sys.stdout, 'default_bg', getattr(sys.stderr, 'default_bg', None))\n        if auto_colors and bg_color is not None:\n            set_light_background() if bg_color in (112, 96, 240, 176, 224, 208, 160) else set_dark_background()\n\n        # Reset on exit if requested.\n        if reset_atexit:\n            atexit.register(lambda: Windows.disable())\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a tuple of two integers representing current colors.", "response": "def _get_colors(self):\n        \"\"\"Returns a tuple of two integers representing current colors: (foreground, background).\"\"\"\n        try:\n            csbi = _WindowsCSBI.get_info(self.win32_stream_handle)\n            return csbi['fg_color'], csbi['bg_color']\n        except IOError:\n            return 7, 0"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _set_color(self, color_code):\n        # Get current color code.\n        current_fg, current_bg = self._get_colors()\n\n        # Handle special negative codes. Also determine the final color code.\n        if color_code == -39:\n            final_color_code = self.default_fg | current_bg  # Reset the foreground only.\n        elif color_code == -49:\n            final_color_code = current_fg | self.default_bg  # Reset the background only.\n        elif color_code == -33:\n            final_color_code = self.default_fg | self.default_bg  # Reset both.\n        elif color_code == -8:\n            final_color_code = current_fg  # Black background.\n        else:\n            new_is_bg = color_code in self.ALL_BG_CODES\n            final_color_code = color_code | (current_fg if new_is_bg else current_bg)\n\n        # Set new code.\n        _WindowsCSBI.WINDLL.kernel32.SetConsoleTextAttribute(self.win32_stream_handle, final_color_code)", "response": "Sets the foreground and background color for subsequently printed characters."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_mimetype(self):\n        template_name = self.get_template_names()[0]\n        for extension, mimetype in turrentine_settings.TURRENTINE_MIMETYPE_EXTENSIONS:\n            if template_name.endswith(extension):\n                return mimetype\n        return 'text/html'", "response": "Return the mimetype of the response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, request, *args, **kwargs):\n        try:\n            page = self.object = self.get_object()\n        except Http404:\n            # If APPEND_SLASH is set and our url has no trailing slash,\n            # look for a CMS page at the alternate url:\n            if settings.APPEND_SLASH and not self.kwargs.get('path', '/').endswith('/'):\n                return self._try_url_with_appended_slash()\n            else:\n                raise Http404\n\n        # Check request.user's credentials in accessing this page:\n        if page.staff_only and not request.user.is_staff:\n            # Block out non-staff users on restricted pages.\n            # Django 1.4 will introduce better HTTP 403 support, but until then\n            # we'll just render a plain \"permission denied\" template (which can be overridden):\n            return render(request, 'turrentine/403.html', status=403)\n        if page.login_required and request.user.is_anonymous():\n            redirect_url = '%s?next=%s' % (settings.LOGIN_URL, self.kwargs.get('path', ''))\n            return HttpResponseRedirect(redirect_url)\n        else:\n            self.object = self._mark_html_fields_as_safe(self.object)\n            context = self.get_context_data(object=self.object)\n            return self.render_to_response(context, content_type=self.get_mimetype())", "response": "This method is called by the get method of the CMS page."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntrying our URL with an appended slash.", "response": "def _try_url_with_appended_slash(self):\n        \"\"\"\n        Try our URL with an appended slash. If a CMS page is found at that URL, redirect to it.\n        If no page is found at that URL, raise Http404.\n        \"\"\"\n        new_url_to_try = self.kwargs.get('path', '') + '/'\n        if not new_url_to_try.startswith('/'):\n            new_url_to_try = '/' + new_url_to_try\n        if CMSPage.objects.published().filter(url=new_url_to_try).exists():\n            return HttpResponsePermanentRedirect(new_url_to_try)\n        else:\n            raise Http404"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmarking the html content as safe so we don t have to use the safe template tag in all cms templates.", "response": "def _mark_html_fields_as_safe(self, page):\n        \"\"\"\n        Mark the html content as safe so we don't have to use the safe\n        template tag in all cms templates:\n        \"\"\"\n        page.title = mark_safe(page.title)\n        page.content = mark_safe(page.content)\n        return page"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates rule name. Arguments: name (string): Rule name. Returns: bool: ``True`` if rule name is valid.", "response": "def validate_rule_name(self, name):\n        \"\"\"\n        Validate rule name.\n\n        Arguments:\n            name (string): Rule name.\n\n        Returns:\n            bool: ``True`` if rule name is valid.\n        \"\"\"\n        if not name:\n            raise SerializerError(\"Rule name is empty\".format(name))\n\n        if name[0] not in RULE_ALLOWED_START:\n            msg = \"Rule name '{}' must starts with a letter\"\n            raise SerializerError(msg.format(name))\n\n        for item in name:\n            if item not in RULE_ALLOWED_CHARS:\n                msg = (\"Invalid rule name '{}': it must only contains \"\n                       \"letters, numbers and '_' character\")\n                raise SerializerError(msg.format(name))\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate_variable_name(self, name):\n        if not name:\n            raise SerializerError(\"Variable name is empty\".format(name))\n\n        if name[0] not in PROPERTY_ALLOWED_START:\n            msg = \"Variable name '{}' must starts with a letter\"\n            raise SerializerError(msg.format(name))\n\n        for item in name:\n            if item not in PROPERTY_ALLOWED_CHARS:\n                msg = (\"Invalid variable name '{}': it must only contains \"\n                       \"letters, numbers and '_' character\")\n                raise SerializerError(msg.format(name))\n\n        return True", "response": "Validate a variable name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsplitting a string into a list of items.", "response": "def value_splitter(self, reference, prop, value, mode):\n        \"\"\"\n        Split a string into a list items.\n\n        Default behavior is to split on white spaces.\n\n\n        Arguments:\n            reference (string): Reference name used when raising possible\n                error.\n            prop (string): Property name used when raising possible error.\n            value (string): Property value to split.\n            mode (string): Splitter mode. Default should come from\n                ``ManifestSerializer._DEFAULT_SPLITTER``.\n\n                Available splitter are:\n\n                * ``white-space``: Simply split a string on white spaces;\n                * ``json-list``: Assume the string is a JSON list to parse;\n\n        Returns:\n            list:\n        \"\"\"\n        items = []\n\n        if mode == 'json-list':\n            try:\n                items = json.loads(value)\n            except json.JSONDecodeError as e:\n                print(value)\n                msg = (\"Reference '{ref}' raised JSON decoder error when \"\n                       \"splitting values from '{prop}': {err}'\")\n                raise SerializerError(msg.format(ref=reference, prop=prop,\n                                                 err=e))\n        else:\n            if len(value) > 0:\n                items = value.split(\" \")\n\n        return items"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nserializes given datas to any object from assumed JSON string.", "response": "def serialize_to_json(self, name, datas):\n        \"\"\"\n        Serialize given datas to any object from assumed JSON string.\n\n        Arguments:\n            name (string): Name only used inside possible exception message.\n            datas (dict): Datas to serialize.\n\n        Returns:\n            object: Object depending from JSON content.\n        \"\"\"\n        data_object = datas.get('object', None)\n\n        if data_object is None:\n            msg = (\"JSON reference '{}' lacks of required 'object' variable\")\n            raise SerializerError(msg.format(name))\n\n        try:\n            content = json.loads(data_object, object_pairs_hook=OrderedDict)\n        except json.JSONDecodeError as e:\n            msg = \"JSON reference '{}' raised error from JSON decoder: {}\"\n            raise SerializerError(msg.format(name, e))\n        else:\n            return content"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nserialize given datas to a nested structure where each key create anCOOKIE item and each other variable create anCOOKIE value.", "response": "def serialize_to_nested(self, name, datas):\n        \"\"\"\n        Serialize given datas to a nested structure where each key create an\n        item and each other variable is stored as a subitem with corresponding\n        value (according to key index position).\n\n        Arguments:\n            name (string): Name only used inside possible exception message.\n            datas (dict): Datas to serialize.\n\n        Returns:\n            dict: Nested dictionnary of serialized reference datas.\n       \"\"\"\n        keys = datas.get('keys', None)\n        splitter = datas.get('splitter', self._DEFAULT_SPLITTER)\n\n        if not keys:\n            msg = (\"Nested reference '{}' lacks of required 'keys' variable \"\n                   \"or is empty\")\n            raise SerializerError(msg.format(name))\n        else:\n            keys = self.value_splitter(name, 'keys', keys, mode=splitter)\n\n        # Initialize context dict with reference keys\n        context = OrderedDict()\n        for k in keys:\n            context[k] = OrderedDict()\n\n        # Tidy each variable value to its respective item\n        for k, v in datas.items():\n            # Ignore reserved internal keywords\n            if k not in ('keys', 'structure', 'splitter'):\n                values = self.value_splitter(name, 'values', v, mode=splitter)\n\n                if len(values) != len(keys):\n                    msg = (\"Nested reference '{}' has different length for \"\n                           \"values of '{}' and 'keys'\")\n                    raise SerializerError(msg.format(name, k))\n\n                # Put each value to its respective key using position index.\n                for i, item in enumerate(values):\n                    ref = keys[i]\n                    context[ref][k] = item\n\n        return context"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nserializing given datas to a flat structure.", "response": "def serialize_to_flat(self, name, datas):\n        \"\"\"\n        Serialize given datas to a flat structure ``KEY:VALUE`` where ``KEY``\n        comes from ``keys`` variable and ``VALUE`` comes from ``values``\n        variable.\n\n        This means both ``keys`` and ``values`` are required variable to be\n        correctly filled (each one is a string of item separated with an empty\n        space). Both resulting list must be the same length.\n\n        Arguments:\n            name (string): Name only used inside possible exception message.\n            datas (dict): Datas to serialize.\n\n        Returns:\n            dict: Flat dictionnay of serialized reference datas.\n        \"\"\"\n        keys = datas.get('keys', None)\n        values = datas.get('values', None)\n        splitter = datas.get('splitter', self._DEFAULT_SPLITTER)\n\n        if not keys:\n            msg = (\"Flat reference '{}' lacks of required 'keys' variable or \"\n                   \"is empty\")\n            raise SerializerError(msg.format(name))\n        else:\n            keys = self.value_splitter(name, 'keys', keys, mode=splitter)\n\n        if not values:\n            msg = (\"Flat reference '{}' lacks of required 'values' variable \"\n                   \"or is empty\")\n            raise SerializerError(msg.format(name))\n        else:\n            values = self.value_splitter(name, 'values', values, mode=splitter)\n\n        if len(values) != len(keys):\n            msg = (\"Flat reference have different length of 'keys' ands \"\n                   \"'values' variable\")\n            raise SerializerError(msg.format(name))\n\n        return OrderedDict(zip(keys, values))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef serialize_to_list(self, name, datas):\n        items = datas.get('items', None)\n        splitter = datas.get('splitter', self._DEFAULT_SPLITTER)\n\n        if items is None:\n            msg = (\"List reference '{}' lacks of required 'items' variable \"\n                   \"or is empty\")\n            raise SerializerError(msg.format(name))\n        else:\n            items = self.value_splitter(name, 'items', items, mode=splitter)\n\n        return items", "response": "Serialize given datas to a list structure."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef serialize_to_string(self, name, datas):\n        value = datas.get('value', None)\n\n        if value is None:\n            msg = (\"String reference '{}' lacks of required 'value' variable \"\n                   \"or is empty\")\n            raise SerializerError(msg.format(name))\n\n        return value", "response": "Serialize given datas to a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of meta - reference names for the specified entry in the manifest.", "response": "def get_meta_references(self, datas):\n        \"\"\"\n        Get manifest enabled references declaration\n\n        This required declaration is readed from\n        ``styleguide-metas-references`` rule that require either a ``--names``\n        or ``--auto`` variable, each one define the mode to enable reference:\n\n        Manually\n            Using ``--names`` which define a list of names to enable, every\n            other non enabled rule will be ignored.\n\n            Section name (and so Reference name also) must not contains special\n            character nor ``-`` so they still be valid variable name for almost\n            any languages. For word separator inside name, use ``_``.\n        Automatic\n            Using ``--auto`` variable every reference rules will be enabled.\n            The value of this variable is not important since it is not empty.\n\n        If both of these variables are defined, the manual enable mode is used.\n\n        Arguments:\n            datas (dict): Data where to search for meta references declaration.\n                This is commonly the fully parsed manifest.\n\n        Returns:\n            list: A list of reference names.\n        \"\"\"\n        rule = datas.get(RULE_META_REFERENCES, {})\n\n        if not rule:\n            msg = \"Manifest lacks of '.{}' or is empty\"\n            raise SerializerError(msg.format(RULE_META_REFERENCES))\n        else:\n            if rule.get('names', None):\n                names = rule.get('names').split(\" \")\n            elif rule.get('auto', None):\n                names = self.get_available_references(datas)\n            else:\n                msg = (\"'.{}' either require '--names' or '--auto' variable \"\n                       \"to be defined\")\n                raise SerializerError(msg.format(RULE_META_REFERENCES))\n\n        for item in names:\n            self.validate_rule_name(item)\n\n        return names"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_reference(self, datas, name):\n        rule_name = '-'.join((RULE_REFERENCE, name))\n        structure_mode = 'nested'\n\n        if rule_name not in datas:\n            msg = \"Unable to find enabled reference '{}'\"\n            raise SerializerError(msg.format(name))\n\n        properties = datas.get(rule_name)\n\n        # Search for \"structure\" variable\n        if 'structure' in properties:\n            if properties['structure'] == 'flat':\n                structure_mode = 'flat'\n            elif properties['structure'] == 'list':\n                structure_mode = 'list'\n            elif properties['structure'] == 'string':\n                structure_mode = 'string'\n            elif properties['structure'] == 'json':\n                structure_mode = 'json'\n            elif properties['structure'] == 'nested':\n                pass\n            else:\n                msg = \"Invalid structure mode name '{}' for reference '{}'\"\n                raise SerializerError(msg.format(structure_mode, name))\n            del properties['structure']\n\n        # Validate variable names\n        for item in properties.keys():\n            self.validate_variable_name(item)\n\n        # Perform serialize according to structure mode\n        if structure_mode == 'flat':\n            context = self.serialize_to_flat(name, properties)\n        elif structure_mode == 'list':\n            context = self.serialize_to_list(name, properties)\n        elif structure_mode == 'string':\n            context = self.serialize_to_string(name, properties)\n        elif structure_mode == 'nested':\n            context = self.serialize_to_nested(name, properties)\n        elif structure_mode == 'json':\n            context = self.serialize_to_json(name, properties)\n\n        return context", "response": "Get serialized manifest for a reference."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_available_references(self, datas):\n        names = []\n\n        for k, v in datas.items():\n            if k.startswith(RULE_REFERENCE):\n                names.append(k[len(RULE_REFERENCE)+1:])\n\n        return names", "response": "Returns a list of all available manifest reference names."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting enabled references declarations.", "response": "def get_enabled_references(self, datas, meta_references):\n        \"\"\"\n        Get enabled manifest references declarations.\n\n        Enabled references are defined through meta references declaration,\n        every other references are ignored.\n\n        Arguments:\n            datas (dict): Data where to search for reference declarations.\n                This is commonly the fully parsed manifest.\n            meta_references (list): List of enabled reference names.\n\n        Returns:\n            collections.OrderedDict: Serialized enabled references datas.\n        \"\"\"\n        references = OrderedDict()\n\n        for section in meta_references:\n            references[section] = self.get_reference(datas, section)\n\n        return references"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nserializes datas to manifest structure with metas and references.", "response": "def serialize(self, datas):\n        \"\"\"\n        Serialize datas to manifest structure with metas and references.\n\n        Only references are returned, metas are assigned to attribute\n        ``ManifestSerializer._metas``.\n\n        Arguments:\n            datas (dict): Data where to search for reference declarations. This\n                is commonly the fully parsed manifest.\n\n        Returns:\n            collections.OrderedDict: Serialized enabled references datas.\n        \"\"\"\n        self._metas = OrderedDict({\n            'references': self.get_meta_references(datas),\n        })\n\n        return self.get_enabled_references(datas, self._metas['references'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the contents of the configuration file with default values.", "response": "def update_with_default_values(self):\n        \"\"\" Goes through all the configuration fields and predefines empty ones with default values\n\n        Top level:\n            `dir` field is predefined with current working directory value, in case of empty string or `None`\n            `io_silent_fail` field if predefined with :attr:`Configuration.DEFAULT_IOSF` in case of None or empty string\n\n        Logger section:\n            `name` field is predefined with :attr:`Configuration.DEFAULT_LOGGER_NAME`. Field is set to str() of itself\n            `level` field is predefined with :attr:`Configuration.DEFAULT_LOGGER_LEVEL`. Field is set to str() of itself\n            `format` field is predefined with :attr:`Configuration.DEFAULT_LOGGER_LEVEL`. Field is set to str() of itself\n            `destination` field if predefined with\n\n        Input section:\n            `dir` field is predefined with a relative path constructed with top level `dir` field and :attr:`Configuration.DEFAULT_INPUT_DIR`\n            `source` field is predefined with an empty list\n            `io_silent_fail` if predefined with a top level `io_silent_fail`\n            `logger` subsection if predefined by a top level `logger` section it substitutes all the missing values in `input` `logger` subsection\n\n        Algorithm section:\n            `io_silent_fail` is predefined with a top level `io_silent_fail` value\n            `logger` is predefined with top level `logger` configuration\n            `tasks` section:\n                `paths` is predefined by [:attr:`Configuration.DEFAULT_ALGORITHM_TASKS_PATH`]. If value is supplied,\n                        :attr:`Configuration.DEFAULT_ALGORITHM_TASKS_PATH` is prepended  to the supplied list\n            `stages` section: (is predefined with [])\n                if any values are predefined, such fields as `io_silent_fail`, `logger` are propagated to stages entries\n                `self_loop` value is predefined by :attr:`Configuration.DEFAULT_ALGORITHM_STAGES_SELF_LOOP`\n            `rounds` section: (is predefined with [])\n                if any values are predefined, such fields as `io_silent_fail`, `logger` are propagated to stages entries\n                `self_loop` value is predefined by :attr:`Configuration.DEFAULT_ALGORITHM_ROUNDS_SELF_LOOP`\n            `pipeline` section:\n                `self_loop` if predefined by :attr:`Configuration.DEFAULT_ALGORITHM_PIPELINE_SELF_LOOP`\n                `logger` if predefined with an algorithm->logger configuration. All non specified value are propagated respectively\n                `rounds` is predefined with []\n\n        Output section:\n            `dir` field is predefined with :attr:`Configuration.DEFAULT_OUTPUT_DIR`\n            `io_silent_fail` field is predefined with top level `io_silent_fail`\n            `logger` subsection is predefined with a top level logger section, which substitutes all of missing values from top level `logger` section\n            `stats` section\n                `io_silent_fail` field is predefined with `output->io_silent_fail` value\n                `dir` is predefined with :attr:`Configuration.DEFAULT_OUTPUT_STATS_DIR`\n                `file` is predefined with :attr:`Configuration.DEFAULT_OUTPUT_STATS_FILE`\n                `logger` is defaulted (all, or just missing parts) bu `output->logger` section\n\n            `assembly_points` section\n                `io_silent_fail` field is predefined with `output->io_silent_fail` value\n                `dir` is predefined with :attr:`Configuration.DEFAULT_OUTPUT_AP_DIR`\n                `file` is predefined with :attr:`Configuration.DEFAULT_OUTPUT_AP_FILE`\n                `logger` is defaulted (all, or just missing parts) bu `output->logger` section\n                `genome_specific` is predefined with :attr:`Configuration.DEFAULT_OUTPUT_AP_GENOME_SPECIFIC`\n                `genome_specific_file_name_pattern` is predefined with :attr:`Configuration.DEFAULT_OUTPUT_AP_GSFNP`\n\n            `genomes` section\n                `io_silent_fail` field is predefined with `output->io_silent_fail` value\n                `dir` is predefined with :attr:`Configuration.DEFAULT_OUTPUT_GENOMES_DIR`\n                `logger` is defaulted (all, or just missing parts) bu `output->logger` section\n                `output_non_glued_fragments` is predefined with :attr:`Configuration.DEFAULT_OUTPUT_GENOMES_ONGF`\n\n        :return: Nothing, performs inplace changes\n        :rtype: `None`\n        \"\"\"\n        if self[self.DIR] in (\"\", None):\n            self[self.DIR] = os.getcwd()\n        if self[self.IOSF] in (\"\", None):\n            self[self.IOSF] = self.DEFAULT_IOSF\n\n        # logger section\n        if self[self.LOGGER][self.NAME] in (\"\", None):\n            self[self.LOGGER][self.NAME] = self.DEFAULT_LOGGER_NAME\n        self[self.LOGGER][self.NAME] = str(self[self.LOGGER][self.NAME])\n        if self[self.LOGGER][self.LEVEL] in (\"\", None):\n            self[self.LOGGER][self.LEVEL] = self.DEFAULT_LOGGER_LEVEL\n        self[self.LOGGER][self.LEVEL] = str(self[self.LOGGER][self.LEVEL])\n        if self[self.LOGGER][self.FORMAT] in (\"\", None):\n            self[self.LOGGER][self.FORMAT] = self.DEFAULT_LOGGER_FORMAT\n        self[self.LOGGER][self.FORMAT] = str(self[self.LOGGER][self.FORMAT])\n        if self[self.LOGGER][self.DESTINATION] in ([], \"\", None):\n            self[self.LOGGER][self.DESTINATION] = self.DEFAULT_LOGGER_DESTINATION\n\n        # input section\n        if self[self.INPUT][self.SOURCE] in (\"\", None):\n            self[self.INPUT][self.SOURCE] = []\n        if self[self.INPUT][self.DIR] in (\"\", None):\n            self[self.INPUT][self.DIR] = self.DEFAULT_INPUT_DIR\n        if self[self.INPUT][self.IOSF] in (\"\", None):\n            self[self.INPUT][self.IOSF] = self[self.IOSF]\n        self._update_logger_config(logger_to_update=self[self.INPUT][self.LOGGER],\n                                   source_logger=self[self.LOGGER])\n\n        # algorithm section\n        if self.LOGGER not in self[self.ALGORITHM] or self[self.ALGORITHM][self.LOGGER] in (\"\", None):\n            self[self.ALGORITHM][self.LOGGER] = {}\n        self._update_logger_config(logger_to_update=self[self.ALGORITHM][self.LOGGER],\n                                   source_logger=self[self.LOGGER])\n        if self.IOSF not in self[self.ALGORITHM] or self[self.ALGORITHM][self.IOSF] in (\"\", None):\n            self[self.ALGORITHM][self.IOSF] = self[self.IOSF]\n        if self.TASKS not in self[self.ALGORITHM]:\n            self[self.ALGORITHM][self.TASKS] = {}\n        if self.EXECUTABLE_CONTAINERS not in self[self.ALGORITHM]:\n            self[self.ALGORITHM][self.EXECUTABLE_CONTAINERS] = []\n\n        if self.PATHS not in self[self.ALGORITHM][self.TASKS] or self[self.ALGORITHM][self.TASKS][self.PATHS] in (\"\", None):\n            self[self.ALGORITHM][self.TASKS][self.PATHS] = []\n        self[self.ALGORITHM][self.TASKS][self.PATHS] = [self.DEFAULT_ALGORITHM_TASKS_PATH] + self[self.ALGORITHM][self.TASKS][self.PATHS]\n\n        for ecs in self[self.ALGORITHM][self.EXECUTABLE_CONTAINERS]:\n            if self.REFERENCE not in ecs:\n                ecs[self.REFERENCE] = ecs[self.NAME] + \"s\"\n            if ecs[self.REFERENCE] not in self[self.ALGORITHM]:\n                self[self.ALGORITHM][ecs[self.REFERENCE]] = []\n            for executable_container in self[self.ALGORITHM][ecs[self.REFERENCE]]:\n                if self.SELF_LOOP not in executable_container:\n                    executable_container[self.SELF_LOOP] = self.DEFAULT_ALGORITHM_EC_SELF_LOOP\n                if self.ENTRIES not in executable_container:\n                    executable_container[self.ENTRIES] = []\n\n        if self.PIPELINE not in self[self.ALGORITHM]:\n            self[self.ALGORITHM][self.PIPELINE] = {}\n        if self.LOGGER not in self[self.ALGORITHM][self.PIPELINE] or self[self.ALGORITHM][self.PIPELINE][self.LOGGER] in (\"\", None):\n            self[self.ALGORITHM][self.PIPELINE][self.LOGGER] = {}\n        self._update_logger_config(logger_to_update=self[self.ALGORITHM][self.PIPELINE][self.LOGGER],\n                                   source_logger=self[self.ALGORITHM][self.LOGGER])\n        if self.IOSF not in self[self.ALGORITHM][self.PIPELINE] or self[self.ALGORITHM][self.PIPELINE][self.IOSF] in (\"\", None):\n            self[self.ALGORITHM][self.PIPELINE][self.IOSF] = self[self.ALGORITHM][self.IOSF]\n        if self.ENTRIES not in self[self.ALGORITHM][self.PIPELINE] or self[self.ALGORITHM][self.PIPELINE][self.ENTRIES] in (\"\", None):\n            self[self.ALGORITHM][self.PIPELINE][self.ENTRIES] = []\n        if self.SELF_LOOP not in self[self.ALGORITHM][self.PIPELINE] or self[self.ALGORITHM][self.PIPELINE][self.SELF_LOOP] in (\"\", None):\n            self[self.ALGORITHM][self.PIPELINE][self.SELF_LOOP] = self.DEFAULT_ALGORITHM_PIPELINE_SELF_LOOP\n\n        # output section\n        if self[self.OUTPUT][self.DIR] in (\"\", None):\n            self[self.OUTPUT][self.DIR] = os.path.join(self[self.DIR], self.DEFAULT_OUTPUT_DIR)\n        if self[self.OUTPUT][self.IOSF] in (\"\", None):\n            self[self.OUTPUT][self.IOSF] = self[self.IOSF]\n        self._update_logger_config(logger_to_update=self[self.OUTPUT][self.LOGGER],\n                                   source_logger=self[self.LOGGER])\n\n        # output -> stats section\n        if self.DIR not in self[self.OUTPUT][self.STATS] or self[self.OUTPUT][self.STATS][self.DIR] in (\"\", None):\n            self[self.OUTPUT][self.STATS][self.DIR] = self.DEFAULT_OUTPUT_STATS_DIR\n        if self.IOSF not in self[self.OUTPUT][self.STATS] or self[self.OUTPUT][self.STATS][self.IOSF] in (\"\", None):\n            self[self.OUTPUT][self.STATS][self.IOSF] = self[self.OUTPUT][self.IOSF]\n        if self.FILE not in self[self.OUTPUT][self.STATS] or self[self.OUTPUT][self.STATS][self.FILE] in (\"\", None):\n            self[self.OUTPUT][self.STATS][self.FILE] = self.DEFAULT_OUTPUT_STATS_FILE\n        if self.LOGGER not in self[self.OUTPUT][self.STATS]:\n            self[self.OUTPUT][self.STATS][self.LOGGER] = {}\n        self._update_logger_config(logger_to_update=self[self.OUTPUT][self.STATS][self.LOGGER],\n                                   source_logger=self[self.OUTPUT][self.LOGGER])\n\n        # output -> assembly_points section\n        if self.DIR not in self[self.OUTPUT][self.ASSEMBLY_POINTS] or self[self.OUTPUT][self.ASSEMBLY_POINTS][self.DIR] in (\"\", None):\n            self[self.OUTPUT][self.ASSEMBLY_POINTS][self.DIR] = self.DEFAULT_OUTPUT_AP_DIR\n        if self.IOSF not in self[self.OUTPUT][self.ASSEMBLY_POINTS] or self[self.OUTPUT][self.ASSEMBLY_POINTS][self.IOSF] in (\"\", None):\n            self[self.OUTPUT][self.ASSEMBLY_POINTS][self.IOSF] = self[self.OUTPUT][self.IOSF]\n        if self.FILE not in self[self.OUTPUT][self.ASSEMBLY_POINTS] or self[self.OUTPUT][self.ASSEMBLY_POINTS][self.FILE] in (\"\", None):\n            self[self.OUTPUT][self.ASSEMBLY_POINTS][self.FILE] = self.DEFAULT_OUTPUT_AP_FILE\n        if self.GENOME_SPECIFIC not in self[self.OUTPUT][self.ASSEMBLY_POINTS] or self[self.OUTPUT][self.ASSEMBLY_POINTS][\n            self.GENOME_SPECIFIC]:\n            self[self.OUTPUT][self.ASSEMBLY_POINTS][self.GENOME_SPECIFIC] = self.DEFAULT_OUTPUT_AP_GENOME_SPECIFIC\n        if self.GENOME_SPECIFIC_FNP not in self[self.OUTPUT][self.ASSEMBLY_POINTS] or self[self.OUTPUT][self.ASSEMBLY_POINTS][\n            self.GENOME_SPECIFIC_FNP]:\n            self[self.OUTPUT][self.ASSEMBLY_POINTS][self.GENOME_SPECIFIC_FNP] = self.DEFAULT_OUTPUT_AP_GSFNP\n        if self.LOGGER not in self[self.OUTPUT][self.ASSEMBLY_POINTS]:\n            self[self.OUTPUT][self.ASSEMBLY_POINTS][self.LOGGER] = {}\n        self._update_logger_config(logger_to_update=self[self.OUTPUT][self.ASSEMBLY_POINTS][self.LOGGER],\n                                   source_logger=self[self.OUTPUT][self.LOGGER])\n\n        # output -> genomes section\n        if self.DIR not in self[self.OUTPUT][self.GENOMES] or self[self.OUTPUT][self.GENOMES][self.DIR] in (\"\", None):\n            self[self.OUTPUT][self.GENOMES][self.DIR] = self.DEFAULT_OUTPUT_GENOMES_DIR\n        if self.IOSF not in self[self.OUTPUT][self.GENOMES] or self[self.OUTPUT][self.GENOMES][self.IOSF] in (\"\", None):\n            self[self.OUTPUT][self.GENOMES][self.IOSF] = self[self.OUTPUT][self.IOSF]\n        if self.OUTPUT_NG_FRAGMENTS not in self[self.OUTPUT][self.GENOMES] or self[self.OUTPUT][self.GENOMES][self.OUTPUT_NG_FRAGMENTS] in (\n        \"\", None):\n            self[self.OUTPUT][self.GENOMES][self.OUTPUT_NG_FRAGMENTS] = self.DEFAULT_OUTPUT_GENOMES_ONGF\n        if self.LOGGER not in self[self.OUTPUT][self.GENOMES]:\n            self[self.OUTPUT][self.GENOMES][self.LOGGER] = {}\n        self._update_logger_config(logger_to_update=self[self.OUTPUT][self.GENOMES][self.LOGGER],\n                                   source_logger=self[self.OUTPUT][self.LOGGER])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding each of the names and fields in the fields attribute of the related item to the model cls.", "response": "def contribute_to_class(self, cls, name):\n        \"\"\"\n        Add each of the names and fields in the ``fields`` attribute\n        to the model the relationship field is applied to, and set up\n        the related item save and delete signals for calling\n        ``related_items_changed``.\n        \"\"\"\n        for field in cls._meta.many_to_many:\n            if isinstance(field, self.__class__):\n                e = \"Multiple %s fields are not supported (%s.%s, %s.%s)\" % (\n                    self.__class__.__name__, cls.__name__, cls.__name__,\n                    name, field.name)\n                raise ImproperlyConfigured(e)\n        self.related_field_name = name\n        super(BaseGenericRelation, self).contribute_to_class(cls, name)\n        # Not applicable to abstract classes, and in fact will break.\n        if not cls._meta.abstract:\n            for (name_string, field) in self.fields.items():\n                if \"%s\" in name_string:\n                    name_string = name_string % name\n                extant_fields = cls._meta._forward_fields_map\n                if name_string in extant_fields:\n                    continue\n                if field.verbose_name is None:\n                    field.verbose_name = self.verbose_name\n                cls.add_to_class(name_string, copy(field))\n            # Add a getter function to the model we can use to retrieve\n            # the field/manager by name.\n            getter_name = \"get_%s_name\" % self.__class__.__name__.lower()\n            cls.add_to_class(getter_name, lambda self: name)\n\n            sender = self.rel.to\n            post_save.connect(self._related_items_changed, sender=sender)\n            post_delete.connect(self._related_items_changed, sender=sender)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _related_items_changed(self, **kwargs):\n        for_model = kwargs[\"instance\"].content_type.model_class()\n        if for_model and issubclass(for_model, self.model):\n            instance_id = kwargs[\"instance\"].object_pk\n            try:\n                instance = for_model.objects.get(id=instance_id)\n            except self.model.DoesNotExist:\n                # Instance itself was deleted - signals are irrelevant.\n                return\n            if hasattr(instance, \"get_content_model\"):\n                instance = instance.get_content_model()\n            related_manager = getattr(instance, self.related_field_name)\n            self.related_items_changed(instance, related_manager)", "response": "Called when the related items of the related item manager has changed."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the related_field_name of the related_item_name attribute of the related_item instance to reflect the number of comments.", "response": "def related_items_changed(self, instance, related_manager):\n        \"\"\"\n        Stores the number of comments. A custom ``count_filter``\n        queryset gets checked for, allowing managers to implement\n        custom count logic.\n        \"\"\"\n        try:\n            count = related_manager.count_queryset()\n        except AttributeError:\n            count = related_manager.count()\n        count_field_name = list(self.fields.keys())[0] % \\\n                           self.related_field_name\n        setattr(instance, count_field_name, count)\n        instance.save()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef formfield(self, **kwargs):\n        from yacms.generic.forms import KeywordsWidget\n        kwargs[\"widget\"] = KeywordsWidget\n        return super(KeywordsField, self).formfield(**kwargs)", "response": "Provide the custom form widget for the admin since there\n        isn t a form field mapped to GenericRelation model fields."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nswapping out any reference to ``KeywordsField`` with the ``KEYWORDS_FIELD_string`` field in ``search_fields``.", "response": "def contribute_to_class(self, cls, name):\n        \"\"\"\n        Swap out any reference to ``KeywordsField`` with the\n        ``KEYWORDS_FIELD_string`` field in ``search_fields``.\n        \"\"\"\n        super(KeywordsField, self).contribute_to_class(cls, name)\n        string_field_name = list(self.fields.keys())[0] % \\\n                            self.related_field_name\n        if hasattr(cls, \"search_fields\") and name in cls.search_fields:\n            try:\n                weight = cls.search_fields[name]\n            except TypeError:\n                # search_fields is a sequence.\n                index = cls.search_fields.index(name)\n                search_fields_type = type(cls.search_fields)\n                cls.search_fields = list(cls.search_fields)\n                cls.search_fields[index] = string_field_name\n                cls.search_fields = search_fields_type(cls.search_fields)\n            else:\n                del cls.search_fields[name]\n                cls.search_fields[string_field_name] = weight"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstore the keywords as a single string for searching.", "response": "def related_items_changed(self, instance, related_manager):\n        \"\"\"\n        Stores the keywords as a single string for searching.\n        \"\"\"\n        assigned = related_manager.select_related(\"keyword\")\n        keywords = \" \".join([str(a.keyword) for a in assigned])\n        string_field_name = list(self.fields.keys())[0] % \\\n                            self.related_field_name\n        if getattr(instance, string_field_name) != keywords:\n            setattr(instance, string_field_name, keywords)\n            instance.save()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef related_items_changed(self, instance, related_manager):\n        ratings = [r.value for r in related_manager.all()]\n        count = len(ratings)\n        _sum = sum(ratings)\n        average = _sum / count if count > 0 else 0\n        setattr(instance, \"%s_count\" % self.related_field_name, count)\n        setattr(instance, \"%s_sum\" % self.related_field_name, _sum)\n        setattr(instance, \"%s_average\" % self.related_field_name, average)\n        instance.save()", "response": "Calculates and saves the average rating."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_new_packages(apt_output, include_automatic=False):\n    pat = r'^The following NEW packages will be installed:[\\r\\n]+(.*?)[\\r\\n]\\w'\n    matcher = re.search(pat, apt_output, re.DOTALL | re.MULTILINE)\n    if not matcher:\n        return []\n    new_pkg_text = matcher.group(1)\n    raw_names = re.findall(r'[\\w{}\\.+-]+', new_pkg_text)\n    all_packages = list(map(PackageName.from_apt, raw_names))\n    manual_packages = [pack for pack in all_packages if not pack.automatic]\n    return all_packages if include_automatic else manual_packages", "response": "Given the output from an apt or aptitude command determine which packages are newly - installed."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating over a file and yield stripped lines. Optionally show progress.", "response": "def file_iterator(filehandle, verbose=False):\n  \"\"\"Iterate over a file and yield stripped lines. Optionally show progress.\"\"\"\n  if type(filehandle).__name__ == \"str\":\n    filehandle = open(filehandle)\n  if verbose:\n    try:\n      pind = ProgressIndicator(totalToDo=os.path.getsize(filehandle.name),\n                               messagePrefix=\"completed\",\n                               messageSuffix=\"of processing \" +\n                                             filehandle.name)\n    except AttributeError:\n      sys.stderr.write(\"BEDIterator -- warning: \" +\n                       \"unable to show progress for stream\")\n      verbose = False\n\n  for line in filehandle:\n    # chomp just the newline char, leave eveerything else alone, so we can\n    # handle empty columns in the first and last positions\n    line = line.rstrip('\\n')\n\n    if verbose:\n      pind.done = filehandle.tell()\n      pind.showProgress()\n    if line == \"\":\n      continue\n    yield line"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds and add an entry to the existing_list_d.", "response": "def _build_entry(parts, existing_list_d, key_value, key_field_num,\n                 key_is_field_number, header=None,\n                 output_type=OutputType.error_on_dups,\n                 ignore_missing_keys=False, keep_key_col=False):\n  \"\"\"\n  Build and add an entry to existing_list_d.\n\n  If the key is a field number, the entry added will be a list of lists. The\n  inner list contains one item per column. and the outer list allows more than\n  one entry to be stored per key (but if allow_duplicates is false, an\n  exception will be raised if more than one needs to be stored).\n\n  :param parts:               the (already tokenized) list of column entries.\n  :param existing_list_d:     a dictionary indexed by key value containing the\n                              the already processed entries. The new entry will\n                              be added to this using <key_value> as a key\n  :param key_value:           the key value to use to add the new entry to\n                              <existing_list_d>\n  :param key_field_num:       which column is the key_value from (number,\n                              indexed from 0)\n  :param key_is_field_number: True if the <key_value> is actually the column\n                              index, rather than a column name\n  :param header:              list giving the names of the columns. Can be None\n                              if columns have no names (no header)\n  :param dup_method:          ...\n  :param ignore_missing_keys: ...\n  \"\"\"\n  if key_value.strip() == \"\":\n    if ignore_missing_keys:\n      return\n    raise MissingKeyError(\"missing key value\")\n\n  if key_value in existing_list_d:\n    if output_type is OutputType.error_on_dups:\n      raise DuplicateKeyError(key_value + \" appears multiple times as key\")\n    elif (output_type is OutputType.all_pairwise_combinations or\n          output_type is OutputType.column_wise_join):\n      pass  # dups okay for these output methods\n    else:\n      raise ValueError(\"Unknown duplicate handling method\")\n  else:\n    existing_list_d[key_value] = []\n\n  if key_is_field_number:\n    # the entry in the dictionary is a list, minus the key field, in the\n    # order they occur.\n    ne = [parts[i] for i in range(0, len(parts))\n          if i != key_field_num or keep_key_col]\n    existing_list_d[key_value].append(ne)\n  else:\n    # the entry in the dictionary is another dictionary indexed by\n    # the header value\n    ne = {}\n    for i in range(0, len(parts)):\n      if i == key_field_num and not keep_key_col:\n        continue\n      else:\n        ne[header[i]] = parts[i]\n    existing_list_d[key_value].append(ne)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\noutput unpaired values from a list of dictionaries.", "response": "def __output_unpaired_vals(d_vals, used_ff_keys, f_f_header, sf_d, s_f_header,\n                           missing_val, out_handler, outfh, delim=\"\\t\"):\n  \"\"\"\n  Use an output handler to output keys that could not be paired.\n\n  Go over the keys in d_vals and for any that were not used (i.e. not in\n  used_ff_keys), build an output line using the values from d_vals,\n  populated the missing columns with missing_val, and output these using the\n  provided output hander.\n  \"\"\"\n  if missing_val is None:\n    raise MissingValueError(\"Need missing value to output \" +\n                            \" unpaired lines\")\n  for k in d_vals:\n    if k not in used_ff_keys:\n      f_f_flds = d_vals[k]\n      if s_f_header is not None:\n        s_f_flds = [dict(zip(s_f_header, [missing_val] * len(s_f_header)))]\n      else:\n        s_f_num_cols = len(sf_d[d_vals.keys()[0]][0])\n        s_f_flds = [[missing_val] * s_f_num_cols]\n      out_handler.write_output(outfh, delim, s_f_flds, f_f_flds,\n                               s_f_header, f_f_header)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_key_field(ui, ui_option_name, default_val=0, default_is_number=True):\n  key = default_val\n  key_is_field_number = default_is_number\n  if ui.optionIsSet(ui_option_name):\n    key = ui.getValue(ui_option_name)\n    try:\n      key = int(key) - 1\n      key_is_field_number = True\n    except ValueError:\n      key_is_field_number = False\n  return key, key_is_field_number", "response": "parse an option from a UI object as the name of a key field."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npopulating unpaired line fields.", "response": "def populate_unpaired_line(d_vals, f_f_header, missing_val=None):\n  \"\"\"\n  used when a value in d_vals doesn't match anything in the other file.\n\n  :return: a dictionary, indexed by key value, with the correct missing values\n           populated for the other file.\n  \"\"\"\n  if missing_val is None:\n    raise MissingValueError(\"Need missing value to output \" +\n                            \" unpaired lines\")\n  if f_f_header is not None:\n    f_f_flds = [dict(zip(f_f_header, [missing_val] * len(f_f_header)))]\n  else:\n    assert(len(d_vals) > 0)\n    f_f_num_cols = len(d_vals[d_vals.keys()[0]][0])\n    f_f_flds = [[missing_val] * f_f_num_cols]\n  return f_f_flds"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_key_value(parts, key_field_num, ignore_missing_keys, seen_keys,\n                  output_type):\n  \"\"\"\n  get the key value from the line and check it's not a dup. or missing. fields\n  with only whitespace are considered empty (missing).\n\n  :param ignore_missing_keys: if True, return None for missing keys. If false,\n                              missing keys cause an exception\n                              (MissingKeyError).\n  :param seen_keys: a set of keys already seen.\n\n  :return: the key value, or None if the field was empty.\n  \"\"\"\n  key_val = parts[key_field_num]\n  if key_val.strip() == \"\":\n    if not ignore_missing_keys:\n      raise MissingKeyError(\"missing key value\")\n    else:\n      return None\n\n  if key_val in seen_keys and \\\n     output_type is OutputType.error_on_dups:\n    raise DuplicateKeyError(key_val + \" appears multiple times as key\")\n\n  return key_val", "response": "Get the key value from the line and check it s not a duplicate."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_without_storing(d_vals, s_f_strm, s_f_key, output_type, outfh,\n                            f_f_header=None, s_f_has_header=False,\n                            missing_val=None, delim=None,\n                            ignore_missing_keys=False,\n                            output_unpaired=False, verbose=False):\n  \"\"\"\n    Given a dictionary of values and (optionally) a header for a file,\n    join with another file with a linear pass that does not store The\n    file's values\n\n    :param d_vals: dictionary of key-value pairs to match up with the lines\n                   in the second file. If header_f1 is None, the values should\n                   be ordered iterables --output will be in presentation order.\n                   If f1_header is not None, values should be dictionary-like\n                   objects accessible via a keys --output will be in the order\n                   that the keys appear in header_f1\n    :param s_f_strm: TODO\n    :param s_f_key: TODO\n    :param header: TODO\n    :param f2_has_header: TODO\n    :param missing_val: TODO\n    :param verbose: TODO\n  \"\"\"\n  used_d_val_keys = set()\n  key_field_num = s_f_key\n  s_f_header = None\n  seen_keys = set()\n  out_handler = output_type.get_handler()\n  expected_cols_per_line = None\n  first_element = True\n  for line in file_iterator(s_f_strm, verbose):\n    parts = __populated_missing_vals(line.split(delim), missing_val)\n\n    # on the first element, we might have to output a header..\n    if first_element:\n      regular_first, s_f_header, key_field_num =\\\n          process_without_storing_header(parts, d_vals, f_f_header,\n                                         s_f_has_header, s_f_header, s_f_key,\n                                         key_field_num, out_handler, outfh,\n                                         missing_val, delim)\n\n    # any line that is either not the first, or is the first but we decided\n    # it wasn't a header line...\n    if not first_element or regular_first:\n      if expected_cols_per_line is None:\n        expected_cols_per_line = (len(parts) if s_f_header is None\n                                  else len(s_f_header))\n      if expected_cols_per_line != len(parts):\n        raise RaggedInputError(\"Found line with \" + str(len(parts)) + \" \"\n                               \"columns, but was expecting \" +\n                               str(expected_cols_per_line) + \" columns\")\n\n      key_val = get_key_value(parts, key_field_num, ignore_missing_keys,\n                              seen_keys, output_type)\n      if key_val is None and ignore_missing_keys:\n        continue\n      seen_keys.add(key_val)\n\n      if key_val not in d_vals:\n        if not output_unpaired:\n          continue\n        f_f_flds = populate_unpaired_line(d_vals, f_f_header, missing_val)\n      else:\n        f_f_flds = d_vals[key_val]\n        used_d_val_keys.add(key_val)\n      s_f_flds = ([dict(zip(s_f_header, parts))]\n                  if s_f_header is not None else [parts])\n      out_handler.write_output(outfh, delim, s_f_flds, f_f_flds,\n                               s_f_header, f_f_header)\n    first_element = False\n\n  if output_unpaired:\n    __output_unpaired_vals(d_vals, used_d_val_keys, f_f_header, s_f_flds,\n                           s_f_header, missing_val, out_handler, outfh, delim)", "response": "This function is used to process a dictionary of values and a header for a file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_mock_open_side_effect(string_d, stream_d):\n  assert(len(set(string_d.keys()).intersection(set(stream_d.keys()))) == 0)\n\n  def mock_open_side_effect(*args, **kwargs):\n    if args[0] in string_d:\n      return StringIO.StringIO(string_d[args[0]])\n    elif args[0] in stream_d:\n      return stream_d[args[0]]\n    else:\n      raise IOError(\"No such file: \" + args[0])\n  return mock_open_side_effect", "response": "Build a mock open side effect using a dictionary of content for the files."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_header(self, out_strm, delim, f1_num_fields, f2_num_fields,\n                   f1_header=None, f2_header=None, missing_val=None):\n    \"\"\"\n    Write the header for a joined file. If headers are provided for one or more\n    of the input files, then a header is generated for the output file.\n    Otherwise, this does not output anything.\n\n    :param out_strm: write to this stream\n    :param delim:\n    :param f1_num_fields: the number of columns in the first file\n    :param f2_num_fields: the number of columns in the second file\n    :param f1_header:\n    :param f2_header:\n    :param missing_val:\n    \"\"\"\n    mm = f1_header != f2_header\n    one_none = f1_header is None or f2_header is None\n    if mm and one_none and missing_val is None:\n      raise InvalidHeaderError(\"Cannot generate output header when one \" +\n                               \"input file is missing a header and no \" +\n                               \"missing value was provided to replace \" +\n                               \"unknown entries.\")\n\n    if f1_header is not None and f2_header is not None:\n      out_strm.write(delim.join(f1_header) + delim +\n                     delim.join(f2_header) + \"\\n\")\n    elif f1_header is None and f2_header is not None:\n      dummy_h = f1_num_fields * [missing_val]\n      out_strm.write(delim.join(dummy_h) + delim +\n                     delim.join(f2_header) + \"\\n\")\n    elif f1_header is not None and f2_header is None:\n      dummy_h = f2_num_fields * [missing_val]\n      out_strm.write(delim.join(f1_header) + delim +\n                     delim.join(dummy_h) + \"\\n\")", "response": "This function writes the header for a joined file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_valid(self, attrs = None):\n        if attrs is None:\n            reason = {}\n        else:\n            reason = attrs\n        valid = True\n        for attr, validation in self.__class__.__validates__.items():\n            if validation.__class__ == validators.validation:\n                validation.name = attr\n            if not validation(self):\n                reason[attr] = getattr(self, attr)\n                valid = False\n        return valid", "response": "Checks if the object is valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites an object into a ftp URL.", "response": "def write(url, content, **args):\n    \"\"\"Put an object into a ftp URL.\"\"\"\n    relay = urlparse.urlparse(args.pop('relay', 'lmtp://localhot'))\n    try:\n        smtplib_SMTPS = functools.partial(smtplib.SMTP_SSL,\n                                          keyfile=args.pop('keyfile', None),\n                                          certfile=args.pop('certfile', None))\n    except AttributeError:\n        def smtplib_SMTPS():\n            raise ValueError(relay.geturl())\n    filename = args.pop('filename', '')\n    content_type, encoding = mimetypes.guess_type(filename)\n    content_type = args.pop('content_type', content_type)\n    encoding = args.pop('content_encoding', encoding)\n    maintype, subtype = content_type.split('/')\n    content = content_types.get(content_types).format(content, **args)\n    content = content_encodings.get(encoding).encode(content)\n    message = {\n        'application': application.MIMEApplication,\n        'text': text.MIMEText}[maintype](content, subtype)\n    if filename:\n        message.set_param('filename', ('UTF-8', '', filename.decode('UTF-8')))\n    if encoding:\n        message['Content-Encoding'] = encoding\n    message['To'] = urllib.unquote(url.path)\n    for name, value in urlparse.parse_qsl(url.query):\n        message[name.replace('_', '-')] = value\n    if message['From'] is None:\n        username = os.environ.get('USERNAME')\n        username = os.environ.get('LOGNAME', username)\n        username = os.environ.get('USER', username)\n        message['From'] = '{}@{}'.format(username, socket.getfqdn())\n\n    # ``mailto`` scheme allow for a body param. We don't.\n    del message['body']\n\n    # Send the email.\n    client = {'smtp': smtplib.SMTP,\n              'lmtp': smtplib.LMTP,\n              'smtps': smtplib_SMTPS}[relay.scheme]()\n    client.connect(''.join([relay.hostname, relay.path]), relay.port)\n    if relay.username and relay.password:\n        client.login(relay.username, relay.password)\n    client.sendmail(message['From'], [message['To']], message.as_string())\n    client.quit()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate the content of a resource element.", "response": "def clean_restructuredtext(form_instance, content):\n    \"\"\"\n    RST syntax validation\n    \"\"\"\n    if content:\n        errors = SourceReporter(content)\n        if errors:\n            raise ValidationError(map(map_parsing_errors, errors))\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef accepts(*checkers_args, **checkers_kws):\n    \n    @decorator\n    def run_checkers(func, *args, **kwargs):\n        all_args = inspect.getcallargs(func, *args, **kwargs)\n        \n        if checkers_args:\n            for idx, checker_function in enumerate(checkers_args):\n                if callable(checker_function):\n                    result = checker_function(args[idx])\n        if checkers_kws:\n            for key in checkers_kws.keys():\n                if key not in all_args:\n                    raise ValueError('Argument specified in @accepts is not found in decorated function')\n                else:\n                    df = all_args[key]\n                    result = checkers_kws[key](df)\n        return func(*args, **kwargs)\n    return run_checkers", "response": "Create a decorator for validating function parameters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a decorator for validating function return values.", "response": "def returns(*checkers_args):\n    \"\"\" Create a decorator for validating function return values.\n\n    Parameters\n    ----------\n    checkers_args: positional arguments\n        A single functions to apply to the output of the decorated function. If a tuple is returned \n        by the decorated function, multiple function can be listed and are assumed to match by \n        possition to the elements in the returned tuple.   \n\n    Examples\n    --------\n    @returns(df_checker)\n    def do_something_with_df(df, args*, kw**):\n        print(df.head())\n        return df\n\n    @returns(df_checker1, df_checker2)\n    def do_something_with_dfs(df1, df2, args*, kw**):\n        # Do somethign with both dfs\n        return (df1, df2)\n    \"\"\"\n    \n    @decorator\n    def run_checkers(func, *args, **kwargs):\n        ret = func(*args, **kwargs)\n        \n        if type(ret) != tuple:\n            ret = (ret, )\n        assert len(ret) == len(checkers_args)\n        \n        if checkers_args:\n            for idx, checker_function in enumerate(checkers_args):\n                if callable(checker_function):\n                    result = checker_function(ret[idx])\n        return ret\n    return run_checkers"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs-in to the WYU Me Me", "response": "def login(self):\n        \"\"\"\n        \u7528\u6237\u767b\u9646\n        :return: true if login successfully\n        \"\"\"\n        self._cookies = self.__get_rndnum_cookies()\n        # print self._cookies\n        UserCode, UserPwd = self._userid, self._userpsw\n        Validate = self._cookies['LogonNumber']\n        Submit = '%CC%E1+%BD%BB'\n        headers = {'Referer': 'http://jwc.wyu.edu.cn/student/body.htm'}\n        # save header\n        self._headers = headers\n        data = {\n            'UserCode': UserCode,\n            'UserPwd': UserPwd,\n            'Validate': Validate,\n            'Submit': Submit,\n\n        }\n        r = requests.post('http://jwc.wyu.edu.cn/student/logon.asp', data=data, headers=headers, cookies=self._cookies)\n        # print r.content.decode(_.get_charset(r.content))\n        return True if r.status_code == 200 else False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef regular_generic_msg(hostname, result, oneline, caption):\n    ''' output on the result of a module run that is not command '''\n\n    if not oneline:\n        return \"%s | %s >> %s\\n\" % (hostname, caption, utils.jsonify(result,format=True))\n    else:\n        return \"%s | %s >> %s\\n\" % (hostname, caption, utils.jsonify(result))", "response": "output on the result of a module run that is not command"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef command_generic_msg(hostname, result, oneline, caption):\n    ''' output the result of a command run '''\n\n    rc     = result.get('rc', '0')\n    stdout = result.get('stdout','')\n    stderr = result.get('stderr', '')\n    msg    = result.get('msg', '')\n\n    hostname = hostname.encode('utf-8')\n    caption  = caption.encode('utf-8')\n\n    if not oneline:\n        buf = \"%s | %s | rc=%s >>\\n\" % (hostname, caption, result.get('rc',0))\n        if stdout:\n            buf += stdout\n        if stderr:\n            buf += stderr\n        if msg:\n            buf += msg\n        return buf + \"\\n\"\n    else:\n        if stderr:\n            return \"%s | %s | rc=%s | (stdout) %s (stderr) %s\" % (hostname, caption, rc, stdout, stderr)\n        else:\n            return \"%s | %s | rc=%s | (stdout) %s\" % (hostname, caption, rc, stdout)", "response": "output the result of a command run"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef host_report_msg(hostname, module_name, result, oneline):\n    ''' summarize the JSON results for a particular host '''\n\n    failed = utils.is_failed(result)\n    msg = ''\n    if module_name in [ 'command', 'shell', 'raw' ] and 'ansible_job_id' not in result and result.get('parsed',True) != False:\n        if not failed:\n            msg = command_generic_msg(hostname, result, oneline, 'success')\n        else:\n            msg = command_generic_msg(hostname, result, oneline, 'FAILED')\n    else:\n        if not failed:\n            msg = regular_generic_msg(hostname, result, oneline, 'success')\n        else:\n            msg = regular_generic_msg(hostname, result, oneline, 'FAILED')\n    return msg", "response": "summarize the JSON results for a particular host"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _increment(self, what, host):\n        ''' helper function to bump a statistic '''\n\n        self.processed[host] = 1\n        prev = (getattr(self, what)).get(host, 0)\n        getattr(self, what)[host] = prev+1", "response": "helper function to bump a statistic"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef compute(self, runner_results, setup=False, poll=False, ignore_errors=False):\n        ''' walk through all results and increment stats '''\n\n        for (host, value) in runner_results.get('contacted', {}).iteritems():\n            if not ignore_errors and (('failed' in value and bool(value['failed'])) or\n                ('rc' in value and value['rc'] != 0)):\n                self._increment('failures', host)\n            elif 'skipped' in value and bool(value['skipped']):\n                self._increment('skipped', host)\n            elif 'changed' in value and bool(value['changed']):\n                if not setup and not poll:\n                    self._increment('changed', host)\n                self._increment('ok', host)\n            else:\n                if not poll or ('finished' in value and bool(value['finished'])):\n                    self._increment('ok', host)\n\n        for (host, value) in runner_results.get('dark', {}).iteritems():\n            self._increment('dark', host)", "response": "compute statistics for all the results"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns information about a particular host", "response": "def summarize(self, host):\n        ''' return information about a particular host '''\n\n        return dict(\n            ok          = self.ok.get(host, 0),\n            failures    = self.failures.get(host, 0),\n            unreachable = self.dark.get(host,0),\n            changed     = self.changed.get(host, 0),\n            skipped     = self.skipped.get(host, 0)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates the connection object is capable of read access to rethink returns a set of databases that are available to rethink", "response": "def validate_get_dbs(connection):\n    \"\"\"\n    validates the connection object is capable of read access to rethink\n\n    should be at least one test database by default\n\n    :param connection: <rethinkdb.net.DefaultConnection>\n    :return: <set> list of databases\n    :raises: ReqlDriverError AssertionError\n    \"\"\"\n    remote_dbs = set(rethinkdb.db_list().run(connection))\n    assert remote_dbs\n    return remote_dbs"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates the brain has the correct databases and tables", "response": "def validate_brain_requirements(connection, remote_dbs, requirements):\n    \"\"\"\n    validates the rethinkdb has the 'correct' databases and tables\n    should get remote_dbs from brain.connection.validate_get_dbs\n\n    :param connection: <rethinkdb.net.DefaultConnection>\n    :param remote_dbs: <set> database names present in remote database\n    :param requirements: <dict> example(brain.connection.SELF_TEST)\n    :return: <bool> True\n    :raises: AssertionError or Reql*Error\n    \"\"\"\n    for database in requirements:\n        assert (database in remote_dbs), \"database {} must exist\".format(database)\n        remote_tables = frozenset(rethinkdb.db(database).table_list().run(connection))\n        for table in requirements[database]:\n            assert (table in remote_tables), \"{} must exist in {}\".format(table, database)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate that the connection can write to rethink by creating a new table and adding a document to that table and destroying the new table.", "response": "def validate_write_access(connection):\n    \"\"\"\n    verifies connection can write to rethink by:\n        1. Creating a test table\n        2. Adding a document to that table\n        3. destroying the test table\n\n    :param connection: <rethinkdb.net.DefaultConnection>\n    :return: <bool> True\n    :raises: Reql*Error\n    \"\"\"\n    test_table = \"test_table_{}\".format(uuid4()).replace(\"-\", \"\")   # '-' is not valid\n    create_plugin(test_table, connection)\n    RPX.table(test_table).insert({\"test\": \"data\"}).run(connection)\n    destroy_plugin(test_table, connection)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef brain_post(connection, requirements=None):\n    assert isinstance(connection, DefaultConnection)\n    remote_dbs = validate_get_dbs(connection)\n    assert validate_brain_requirements(connection, remote_dbs, requirements)\n    assert validate_write_access(connection)\n    return connection", "response": "Power On Self Test for the brain."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconnecting to a rethinkdb server.", "response": "def connect(host=None,\n            port=rethinkdb.DEFAULT_PORT,\n            timeout=20,\n            verify=True,\n            **kwargs):\n    \"\"\"\n    RethinkDB semantic connection wrapper\n\n    raises <brain.connection.BrainNotReady> if connection verification fails\n\n    :param verify: <bool> (default True) whether to run POST\n    :param timeout: <int> max time (s) to wait for connection\n    :param kwargs:  <dict> passthrough rethinkdb arguments\n    :return:\n    \"\"\"\n    if not host:\n        host = DEFAULT_HOSTS.get(check_stage_env())\n    connection = None\n    tries = 0\n    time_quit = time() + timeout\n    while not connection and time() <= time_quit:\n        tries += 1\n        connection = _attempt_connect(host, port, timeout/3, verify, **kwargs)\n        if not connection:\n            sleep(0.5)\n    if not connection:\n        raise BrainNotReady(\n            \"Tried ({}:{}) {} times at {} second max timeout\".format(host,\n                                                                     port,\n                                                                     tries,\n                                                                     timeout))\n    return connection"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _attempt_connect(host, port, timeout, verify, **kwargs):\n    try:\n        connection = rethinkdb.connect(host,\n                                       port,\n                                       timeout=timeout,\n                                       **kwargs)\n        if verify:\n            brain_post(connection)\n    except (rethinkdb.errors.ReqlDriverError,\n            rethinkdb.errors.ReqlOpFailedError,\n            AssertionError):\n        connection = None\n    return connection", "response": "Attempts to connect to a set of tables in a set of tables."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef link_to_dashboard(self, dashboard_id=None, panel_id=None, **kwargs):\n\n        if self._dimensions == 1:\n            self._sensor_value.link_to_dashboard(dashboard_id, panel_id, **kwargs)\n        else:\n            for dimension in range(0, self._dimensions):\n                self._sub_sensors[dimension].link_to_dashboard(dashboard_id, panel_id, **kwargs)", "response": "r Links the sensor to a dashboard."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _new_sensor_reading(self, sensor_value):\n        if not self._active and not self._enabled:\n            return\n\n        if self._dimensions > 1:\n            for dimension in range(0, self._dimensions):\n                value = sensor_value[dimension]\n                self._sub_sensors[dimension]._new_sensor_reading(value)\n        else:\n            self._sensor_value.value = sensor_value", "response": "This method is called when a new sensor reading is received."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a function to be called when the value reach or pass the event_value.", "response": "def add_value_event(self, event_value, func, event_type=None, parameters=None, **kwargs):\n        \"\"\"\n        Add a function that is called when the value reach or pass the event_value.\n\n        :param event_value:\n            A single value or range specified as a tuple.\n\n            If it is a range the function specified in func is called when the value enters the range.\n\n        :type event_value: ``float``, ``string``, ``boolean`` or a tuple of these types.\n\n        :param func:\n            Function or lambda expression to be called.\n            This function will receive the dynamcic value as a parameter.\n\n        :param event_type:\n            String with the value \"warning\" of \"error\" or None (default).\n            If warning or error is specified the value or range are shown in UI.\n\n        :type event_type: ``str``\n\n        \"\"\"\n        self._sensor_value.add_value_event(event_value, func, event_type, parameters, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks and expand paths", "response": "def process_path(label, pth):\n   \"check and expand paths\"\n   \n   if pth is None:\n      sys.exit(\"no %s path given\" % label)\n      \n   if pth.startswith(\"/\"):\n      pass\n   elif pth[0] in (\".\", \"~\"):\n      pth = os.path.realpath(pth)\n   else:\n      pth = os.getcwd() + os.sep + pth\n   \n   if not os.path.exists(pth):\n      sys.exit(\"%s path %s does not exist\" % (label, pth))\n\n   return pth"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert to PDF or PNG", "response": "def convert_svg(svgstr, size, filepath, target):\n   \"convert to PDF or PNG\"\n   \n   # PREPARE CONVERSION PER TYPE\n   if target == \"PDF\":\n      img = cairo.PDFSurface(filepath, size, size)\n   \n   elif target == \"PNG\":\n      img = cairo.ImageSurface(cairo.FORMAT_ARGB32, size, size)\n  \n   else:\n      system.exit(\"unknown file type conversion\")\n\n   # PROCESS\n   ctx = cairo.Context(img)\n   handler= rsvg.Handle(None, svgstr)\n   iw,ih, fw,fh =  handler.get_dimension_data()\n   ctx.translate(0,0)\n   ctx.scale(size/fw, size/fh) # assumes bigger source SVG template\n   handler.render_cairo(ctx)\n\n   # FINALIZE PER TYPE\n   if target == \"PNG\":\n      img.write_to_png(filepath)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef var_dump(*obs):\n\ti = 0\n\tfor x in obs:\n\t\t\n\t\tstr = var_dump_output(x, 0, '  ', '\\n', True)\n\t\tprint (str.strip())\n\t\t\n\t\t#dump(x, 0, i, '', object)\n\t\ti += 1", "response": "shows structured information of a list tuple etc\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_call_no_output(args):\n    logger = logging.getLogger(__name__)\n    logger.debug(\"running %s\", args)\n    process = subprocess.Popen(\n        args,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n    (res_stdout, res_stderr) = process.communicate()\n    if process.returncode:\n        res_stdout = res_stdout\n        res_stderr = res_stderr\n        print(res_stdout, end='')\n        print(res_stderr, end='')\n        raise ValueError('exit code from [{}] was [{}]'.format(\" \".join(args), process.returncode))", "response": "Run a process and check that it returns an OK return code\n    and has no output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_config(self):\n        section = \"pypitools\"\n        # read setup.cfg config file\n        config = configparser.ConfigParser()\n        homedir_filename = os.path.expanduser(\"~/.setup.cfg\")\n        if os.path.isfile(homedir_filename):\n            config.read(homedir_filename)\n        local_filename = \"setup.cfg\"\n        if os.path.isfile(local_filename):\n            config.read(local_filename)\n        self.upload_method = config.get(section, \"upload_method\")\n        assert self.upload_method in [\"setup\", \"twine\", \"gemfury\"]\n        self.clean_before = config.getboolean(section, \"clean_before\")\n        self.clean_after = config.getboolean(section, \"clean_after\")\n        self.install_in_user_folder = config.getboolean(section, \"install_in_user_folder\")\n        self.use_sudo = config.getboolean(section, \"use_sudo\")\n        self.pip_quiet = config.getboolean(section, \"pip_quiet\")\n        self.setup_quiet = config.getboolean(section, \"setup_quiet\")\n        self.pip = config.get(section, \"pip\")\n        self.gemfury_user = config.get(section, \"gemfury_user\")\n        self.python = config.get(section, \"python\")\n        self.register_method = config.get(section, \"register_method\")\n        assert self.register_method in [\"setup\", \"twine\", \"upload\"]", "response": "Read all configuration data and store them in self."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the version of the package", "response": "def get_package_version(self):\n        \"\"\"\n        Get the version of the package\n        :return:\n        \"\"\"\n        output = subprocess.check_output([\n            '{}'.format(self.python),\n            'setup.py',\n            '--version',\n        ]).decode()\n        return output.rstrip()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef upload_by_twine(self):\n        check_call_no_output([\n            '{}'.format(self.python),\n            'setup.py',\n            'sdist',\n        ])\n        filename = self.get_package_filename()\n        check_call_no_output([\n            'twine',\n            'upload',\n            filename,\n            # '--config-file',\n            # common.config_file,\n        ])", "response": "Upload the current version of the twine package to the local file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuploads to gemfury :return:", "response": "def upload_by_gemfury(self):\n        \"\"\"\n        upload to gemfury\n        :return:\n        \"\"\"\n        check_call_no_output([\n            '{}'.format(self.python),\n            'setup.py',\n            'sdist',\n        ])\n        filename = self.get_package_filename()\n        # The command line is the one recommended by gemfury at\n        # https://manage.fury.io/dashboard/[username]/push\n        check_call_no_output([\n            'fury',\n            'push',\n            filename,\n            '--as={}'.format(self.gemfury_user),\n        ])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuploads the current locale to the server.", "response": "def upload(self):\n        \"\"\"\n        upload via the method configured\n        :return:\n        \"\"\"\n        if self.upload_method == \"setup\":\n            self.upload_by_setup()\n        if self.upload_method == \"twine\":\n            self.upload_by_twine()\n        if self.upload_method == \"gemfury\":\n            self.upload_by_gemfury()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering via the method configured", "response": "def register(self):\n        \"\"\"\n        Register via the method configured\n        :return:\n        \"\"\"\n        if self.register_method == \"twine\":\n            self.register_by_twine()\n        if self.register_method == \"setup\":\n            self.register_by_setup()\n        if self.register_method == \"upload\":\n            self.upload()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_by_twine(self):\n        check_call_no_output([\n            '{}'.format(self.python),\n            'setup.py',\n            'bdist_wheel',\n        ])\n\n        # at this point there should be only one file in the 'dist' folder\n        filename = self.get_package_filename()\n        check_call_no_output([\n            'twine',\n            'register',\n            filename,\n        ])", "response": "register via twine method\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets difficulties by voivodeship.", "response": "def difficulties_by_voivodeship(voivodeship, dt=datetime.now()):\n    \"\"\"\n    Get difficulties in voivodeship.\n\n    :param voivodeship: Voivodeship numeric value.\n    :param dt: Datetime for data. Default: datetime.now()\n\n    :return: List of difficulties by voivodeship.\n    \"\"\"\n    session = requests.Session()\n    session.headers.update({'User-Agent': USER_AGENT})\n    session.headers.update({'X-Requested-With': 'XMLHttpRequest'})\n    \n    session.get('{}/Mapa/'.format(HOST))\n    \n    url = '{}/Mapa/PodajUtrudnieniaWWojewodztwie?KodWojewodztwa={}&_={}'.format(HOST, str(voivodeship), _datetime_to_asp_date(dt))\n    response = session.get(url)\n    \n    json_data = response.json() if len(response.text) > 0 else []\n    return json_data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef table_to_string(headers, table, align=\"\", *, lines=(\"-\", \"-+-\", \" | \")):\n  header_separator, header_junction, row_separator = lines\n  align = (\"{0:<<\" + str(len(headers)) + \"}\").format(align or \"\")\n  all_lens = [tuple(len(c) for c in r) for r in table]\n\n  if headers:\n    all_lens.append(tuple(len(h) for h in headers))\n\n  max_lens = [max(r[i] for r in all_lens) for i in range(len(headers))]\n  col_outs = [\"{{{0}: {1}{2}}}\".format(i, align[i], w) for i, w in enumerate(max_lens)]\n  fmt_str = row_separator.join(col_outs)\n  if headers:\n    yield fmt_str.format(*headers)\n    yield header_junction.join((header_separator * ml for ml in max_lens))\n  for row in table:\n    yield fmt_str.format(*row)", "response": "Write a list of headers and a table to the terminal in a nice format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef increment(self, amount=1, output=True):\n    self._current += amount\n    if output:\n      # NOTE: This algorithm averages out the time it has taken to get to the current / total to\n      #       determine how much time is left. So this is best used with jobs that have steps whose\n      #       run time is roughly the same.\n\n      now = datetime.now()\n      elapsed_time = now - self._started_at\n      expected_finish = self._started_at + elapsed_time * (1 / (self._current / self._total))\n      remaining_time = expected_finish - now\n\n      if self._format_time_remaining:\n        remaining_time_str = self._format_time_remaining(remaining_time)\n      else:\n        remaining_time_str = str(remaining_time)\n\n      tab_count = self._message.count(\"\\t\")\n      sys.stdout.write(\"\\r\" + \"\\t\" * tab_count + \" \" * (len(self._message) - tab_count))\n\n      if isinstance(self._format, str):\n        self._message = self._format.format(self._current, self._total, remaining_time_str)\n      else:\n        self._message = self._format(self._current, self._total, remaining_time_str)\n\n      sys.stdout.write(\"\\r\" + self._message)\n      sys.stdout.flush()", "response": "Increment the current progress by a given amount and output the progress\n    status."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the progress ratio and percentage.", "response": "def ratio_and_percentage(current, total, time_remaining):\n    \"\"\"Returns the progress ratio and percentage.\"\"\"\n    return \"{} / {} ({}% completed)\".format(current, total, int(current / total * 100))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ratio_and_percentage_with_time_remaining(current, total, time_remaining):\n    return \"{} / {} ({}% completed) (~{} remaining)\".format(\n      current,\n      total,\n      int(current / total * 100),\n      time_remaining)", "response": "Returns the progress ratio percentage and time remaining."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef drange(start, stop, step):\n    x = start\n    if step > 0:\n        while x + step <= stop: # produces same behaviour as numpy.arange\n            yield x\n            x += step\n    elif step < 0:\n        while x + step >= stop: # produces same behaviour as numpy.arange\n            yield x\n            x += step\n    else:\n        raise ZeroDivisionError(\"Step must be non-zero\")", "response": "Returns generator that yields successive samples from start to stop in step intervals."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a generator for the frange object instance.", "response": "def get_generator(self):\n        \"\"\"\n        Returns a generator for the frange object instance.\n\n        Returns\n        -------\n        gen : generator\n            A generator that yields successive samples from start (inclusive)\n            to stop (exclusive) in step steps.\n        \"\"\"\n        s = self.slice\n        gen = drange(s.start, s.stop, s.step) # intialises the generator\n        return gen"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an array containing the values from start to stop in step steps.", "response": "def get_array(self):\n        \"\"\"\n        Returns an numpy array containing the values from start (inclusive)\n        to stop (exclusive) in step steps.\n\n        Returns\n        -------\n        array : ndarray\n            Array of values from start (inclusive)\n            to stop (exclusive) in step steps.\n        \"\"\"\n        s = self.slice        \n        array = _np.arange(s.start, s.stop, s.step)\n        return array"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_field_lookups(field_type, nullable):\n    return LOOKUP_TABLE.get(field_type) + ['isnull'] if nullable else LOOKUP_TABLE.get(field_type)", "response": "Return the list of lookup table values for a given field type."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the first match of the given field class.", "response": "def match_field(field_class):\n    \"\"\"\n    Iterates the field_classes and\n    returns the first match\n    \"\"\"\n    for cls in field_class.mro():\n        if cls in list(LOOKUP_TABLE.keys()):\n            return cls\n    # could not match the field class\n    raise Exception('{0} None Found '.format(field_class))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns list of available lookups for the passed in model field type", "response": "def class_lookups(model_field):\n    \"\"\"\n    Return list of available lookups for\n    the passed in (model) field type\n    \"\"\"\n    field_class = type(model_field)\n    field_type = match_field(field_class)\n    return get_field_lookups(field_type, model_field.null)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __modify(self, withdrawal_id, **kwargs):\n        params = {\n            'withdrawal_id': withdrawal_id\n        }\n        return self.make_call(self.__modify, params, kwargs)", "response": "Modify the related record in a withdrawal."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __create(self, account_id, **kwargs):\n        params = {\n            'account_id': account_id\n        }\n        return self.make_call(self.__create, params, kwargs)", "response": "This is the base method for creating a new record in a WePay account."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_template(template, target):\r\n c = ConfManager('')\r\n for section in template:\r\n  c.add_section(section)\r\n  for option, o in template[section].items():\r\n   try:\r\n    value = type(template[section][option]['value'])(target[section][option])\r\n   except KeyError:\r\n    value = o['value']\r\n   finally:\r\n    if 'value' in o:\r\n     del o['value']\r\n   c.set(section, option, value, **o)\r\n return c", "response": "Given a dictionary template containing at least most of the relevant information and a dictionary target containing sections options and values consolidate target into a new confmanager object and return it."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive a confmanager object and a dictionary object parse the values from the dictionary into the object.", "response": "def parse_json(target, json, create_sections = False, create_options = False):\r\n \"\"\"Given a confmanager object and a dictionary object, import the values from the dictionary into the object, optionally adding sections and options as it goes.\"\"\"\r\n is_dict = isinstance(json, dict)\r\n for o in json:\r\n  if is_dict:\r\n   section = o\r\n  else:\r\n   section = o[0]\r\n  if not target.has_section(section):\r\n   if create_sections:\r\n    target.add_section(section)\r\n   else:\r\n    continue\r\n  for k, v in (json[o].items() if is_dict else o[1]):\r\n   if target.has_option(section, k) or create_options:\r\n    target.set(section, k, v) # Don't add if it shouldn't be there.\r\n return target"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute(self, query, args, consistency):\n        start_seconds = self._clock.seconds()\n\n        def record_time(result):\n            seconds_taken = self._clock.seconds() - start_seconds\n            kwargs = dict(query=query, data=args, consistency=consistency,\n                          seconds_taken=seconds_taken)\n            if isinstance(result, Failure):\n                self._log.msg('CQL query execution failed',\n                              reason=result, **kwargs)\n            else:\n                self._log.msg('CQL query executed successfully', **kwargs)\n            return result\n\n        return self._client.execute(query, args, consistency).addBoth(record_time)", "response": "Execute a CQL query and record the time taken."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_sitemap(sitemap: typing.Mapping, prefix: list=None):\n    # Ensures all generated urls are prefixed with a the prefix string\n    if prefix is None:\n        prefix = []\n\n    for segment, sub_segment in sitemap.items():\n        if isinstance(sub_segment, collections.abc.Mapping):\n            yield from generate_sitemap(sub_segment, prefix + [segment])\n        elif isinstance(sub_segment, collections.abc.Callable):\n            if segment:\n                prefix = prefix + [segment]\n            yield (prefix, sub_segment)\n        else:\n            raise ValueError('Invalid datatype for sitemap')", "response": "Generates a sitemap template from a given sitemap."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef gen_find_method(ele_type, multiple=True, extra_maps=None):\n    _ = 'elements' if multiple else 'element'\n    d = {\n        'class': 'class_name'\n    }\n    if isinstance(extra_maps, dict):\n        d = dict(d, **extra_maps)\n    return 'find_{}_by_{}'.format(_, d.get(ele_type, ele_type))", "response": "generates find method name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if a set of elements exists in the database", "response": "def has_element(self, dat, skip_log=False):\n        \"\"\"\n        :param dat: dict like {'name': <the ele name>}\n        :type dat: dict\n        :param skip_log: skip log at your wish\n        :type skip_log:\n        :return:\n        :rtype:\n        \"\"\"\n        try:\n            if self.get_elements(dat, skip_log=skip_log):\n                return True\n        except Exception as _:\n            if not skip_log:\n                log.error(_)\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmocking human input :param target: the element to input to :param content: the content :return:", "response": "def _mock_input(self, target, content):\n        \"\"\"\n            mock human input\n\n        :param target: the element to input to\n        :param content: the content\n        :return:\n        \"\"\"\n        content = helper.to_str(content)\n        for w in content:\n            target.send_keys(w)\n            rand_block(0.01, 0.01)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mock_key_down(self, target, key_press_times):\n        key = Keys.DOWN\n        if key_press_times < 0:\n            key = Keys.UP\n\n        for i in range(abs(key_press_times)):\n            rand_block(0.1, 0.01)\n            target.send_keys(key)", "response": "mock_key_down - Sends a key down to the specified target."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mock_input(self, dat, term='', clear=True,\n                   mock_input_change='', submit=False, multiple=0):\n        \"\"\"\n            \u8f93\u5165 term \u5230 input:ele(dat) \u5143\u7d20\n            \u5982\u679c ``mock_input_change`` \u4e0d\u4e3a\u7a7a, \u5219\u8be5 input \u4e0d\u80fd\u4fdd\u7559\u539f\u59cb\u503c, \u53ef\u4ee5\u8f93\u5165\u4e00\u4e2a\u503c, \u7136\u540e\u6e05\u7a7a.\n\n        - clear \u6e05\u7a7ainput\u7684\u5143\u7d20\n        - submit \u63d0\u4ea4\n\n        :param dat:\n        :type dat: dict\n        :param term:\n        :type term: str\n        :param submit:\n        :type submit: bool\n        :param clear:\n        :type clear: bool\n        :param mock_input_change: \u9488\u5bf9\u4e0d\u80fd\u4fdd\u7559\u539f\u6765\u503c\u7684\u8f93\u5165\u6846\n        :type mock_input_change: str\n        :return:\n        :rtype:\n        \"\"\"\n        target = self.get_elements(dat, multiple)\n        if multiple:\n            target = target[multiple]\n\n        if clear:\n            target.clear()\n            self._mock_input(target, Keys.BACKSPACE * 50)\n\n        if mock_input_change:\n            self._mock_input(target, mock_input_change)\n            rand_block(0.01, 0.01)\n            self._mock_input(target, Keys.BACKSPACE * (len(mock_input_change) + 2))\n\n        if term:\n            self._mock_input(target, term)\n\n        if submit:\n            rand_block(0.01, 0.1)\n            target.send_keys(Keys.ENTER)\n            rand_block(0.01, 0.1)", "response": "mock_input - mock input for an element"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scroll_by_key_down(self, dat, distance_togo):\n        try:\n            target = self.get_elements(dat)\n            distance_done = 0\n            while distance_done < distance_togo:\n                chance = random.random()\n                if chance < 0.05:\n                    rand_block(0.5, 0.1)\n                    continue\n                distance = rand_pareto_float(100, 10)\n                if chance >= 0.95:\n                    distance = -distance\n                key_press_times_ = int(distance // PIXELS_PER_DOWN_KEY)\n                self.mock_key_down(target, key_press_times_)\n                distance_done += key_press_times_ * PIXELS_PER_DOWN_KEY\n        except Exception as _:\n            log.error(_)\n            raise", "response": "scroll_by_key_down \u6a21\u62df page_up or down"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a chrome driver with the given parameters.", "response": "def chrome_driver(self, **kwargs):\n        \"\"\"\n        supported:\n            to = timeout, 30\n            images = load images, 0\n        \"\"\"\n        options = webdriver.ChromeOptions()\n        options.add_argument('--no-sandbox')\n\n        prefs = {\"profile.managed_default_content_settings.images\": kwargs.get('images', 0)}\n        options.add_experimental_option(\"prefs\", prefs)\n        driver = webdriver.Chrome(chrome_options=options)\n        driver.set_window_size(1366, 700)\n        driver.set_window_position(32, 0)\n        driver.set_page_load_timeout(kwargs.get('to', 30))\n        return driver"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __has_next_page(self, current_page_num=0):\n        try:\n            next_page = self.robot.get_elements(\n                self.base.get('next_page'),\n                multiple=True\n            )\n            log.debug('<Site> has {} next page elems'.format(len(next_page)))\n            if not next_page:\n                return False\n            for i, ele in enumerate(next_page):\n                if ele.get_attribute('innerText') == 'Next':\n                    log.debug('<Site> {} is the right link'.format(i))\n                    self.next_page = ele\n                    break\n            return True\n        except Exception as _:\n            self.next_page = None\n            return False", "response": "check if next page is the right link"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _check_params(self, *args, **kwargs):\n        terms = kwargs.get('terms')\n        if not terms:\n            raise crawler.CrawlerParamsError('Terms needed!')\n\n        if not isinstance(terms, list):\n            terms = [terms]\n        if len(terms) != len(self.base['terms']):\n            # raise crawler.CrawlerParamsError('args length must match base[terms]')\n            log.debug('args length {} != {} must match base[terms]'.format(len(terms), len(self.base['terms'])))", "response": "Check if the parameters are correct."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndefaulting will fetch MAX_AP pages will return page_togo - 1", "response": "def response_result(self, **kwargs):\n        \"\"\" default will fetch MAX_AP pages\n        yield `self.driver.page_source, self.driver.current_url, 1`\n\n        after mock submit, the first page is crawled.\n        so start@ index of 1, and yield first page first\n        when running over, use else to yield the last page.\n\n        \u7a0b\u5e8f\u8fd0\u884c\u5230\u6b64, \u5df2\u7ecfload \u4e86\u7b2c\u4e00\u9875, \u6545\u5728\u8fdb\u884c\u64cd\u4f5c `\u70b9\u51fb\u4e0b\u4e00\u9875` \u4e4b\u524d, \u9700\u8981 yield\n        range(1, page_togo), \u5219\u5728 page_togo - 1\u65f6\u8df3\u51fa\u5faa\u73af,\n        \u6b64\u65f6\u7a0b\u5e8f \u5df2\u7ecf\u5b8c\u6210\u70b9\u51fb\u4e86\u4e0b\u4e00\u9875, \u6545 page_togo \u8fd9\u4e00\u9875\u5df2\u7ecf load \u5b8c\u6210, \u6545\u5728 else \u8df3\u51fa\u65f6 yield\n        \"\"\"\n        page_togo = kwargs.get('page_togo', self.max_page_togo)\n        if page_togo <= 1:\n            return self.robot.driver.page_source, self.robot.driver.current_url, 1\n\n        # \u4ece `1` \u5f00\u59cb\u662f\u7531\u4e8e\u5df2\u7ecf\u52a0\u8f7d\u4e86\u7b2c\u4e00\u9875\n        # \u5230 `page_togo` \u7ed3\u675f, \u662f\u56e0\u4e3a\u5728 `page_togo -1` \u65f6,\u5df2\u7ecf\u70b9\u51fb\u4e86\u4e0b\u4e00\u9875\n        # \u56e0\u6b64\u6b64\u5904\u4e0d\u80fd\u5199\u4e3a range(0, page_togo), \u6216\u8005(1, page_togo + 1)\n        yield_last = kwargs.get('yield_last', False)\n        start_yval = 0\n        for page_done in range(1, page_togo):\n            # log.debug(self.robot.driver.current_url)\n            if not yield_last:\n                yield self.robot.driver.page_source, self.robot.driver.current_url, page_done\n            # click any popups\n            self.mock_popovers()\n\n            if self.has_next_page(page_done):\n                start_yval = self.goto_next(start_yval)\n            else:\n                # \u5982\u679c\u65e0\u4e0b\u4e00\u9875, \u76f4\u63a5\u9000\u51fa\n                log.debug('page {} is the last result page!'.format(page_done))\n                break\n        else:\n            if not yield_last:\n                yield self.robot.driver.page_source, self.robot.driver.current_url, page_togo\n\n        if yield_last:\n            yield self.robot.driver.page_source, self.robot.driver.current_url, page_togo"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nflag approve remove some comments from an admin action.", "response": "def _bulk_flag(self, request, queryset, action, done_message):\n        \"\"\"\n        Flag, approve, or remove some comments from an admin action. Actually\n        calls the `action` argument to perform the heavy lifting.\n        \"\"\"\n        n_comments = 0\n        for comment in queryset:\n            action(request, comment)\n            n_comments += 1\n\n        msg = ungettext('1 comment was successfully %(action)s.',\n                        '%(count)s comments were successfully %(action)s.',\n                        n_comments)\n        self.message_user(request, msg % {'count': n_comments, 'action': done_message(n_comments)})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the value of the given key in the file.", "response": "def set(self, key, value):\n        \"\"\"\n        Updates the value of the given key in the file.\n\n        Args:\n            key (str): Key of the property to update.\n            value (str): New value of the property.\n\n        Return:\n            bool: Indicates whether or not a change was made.\n        \"\"\"\n\n        changed = super().set(key=key, value=value)\n\n        if not changed:\n            return False\n\n        self._log.info('Saving configuration to \"%s\"...', self._filename)\n\n        with open(self._filename, 'w') as stream:\n            stream.write(self.content)\n            self._log.info('Saved configuration to \"%s\".', self._filename)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the next color in the colorbrewer 11 - class diverging BrBG palette.", "response": "def next_color(self):\n        \"\"\"\n        Returns the next color. Currently returns a random\n        color from the Colorbrewer 11-class diverging BrBG palette.\n\n        Returns\n        -------\n        next_rgb_color: tuple of ImageColor\n\n        \"\"\"\n        next_rgb_color = ImageColor.getrgb(random.choice(BrBG_11.hex_colors))\n        return next_rgb_color"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npaint a cube at a certain position a color.", "response": "def paint_cube(self, x, y):\n        \"\"\"\n        Paints a cube at a certain position a color.\n\n        Parameters\n        ----------\n        x: int\n            Horizontal position of the upper left corner of the cube.\n        y: int\n            Vertical position of the upper left corner of the cube.\n\n        \"\"\"\n        # get the color\n        color = self.next_color()\n        # calculate the position\n        cube_pos = [x, y, x + self.cube_size, y + self.cube_size]\n        # draw the cube\n        draw = ImageDraw.Draw(im=self.image)\n        draw.rectangle(xy=cube_pos, fill=color)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef paint_pattern(self):\n        x = 0\n        while x < self.width:\n            y = 0\n            while y < self.height:\n                self.paint_cube(x, y)\n                y += self.cube_size\n            x += self.cube_size", "response": "Paints all the cubes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_key_files(kfiles, dirname, names):\n    for name in names:\n        fullname = os.path.join(dirname, name)\n        if os.path.isfile(fullname) and \\\n            fullname.endswith('_rsa') or \\\n                fullname.endswith('_dsa'):\n            kfiles.put(fullname)", "response": "Get key files from a list of names."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets SSH keys from a directory.", "response": "def get_ssh_keys(sshdir):\n    \"\"\"Get SSH keys\"\"\"\n    keys = Queue()\n    for root, _, files in os.walk(os.path.abspath(sshdir)):\n        if not files:\n            continue\n        for filename in files:\n            fullname = os.path.join(root, filename)\n            if (os.path.isfile(fullname) and fullname.endswith('_rsa') or\n                    fullname.endswith('_dsa')):\n                keys.put(fullname)\n    return keys"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_ssh_dir(config, username):\n    sshdir = config.get('ssh_config_dir')\n    if not sshdir:\n        sshdir = os.path.expanduser('~/.ssh')\n        if not os.path.isdir(sshdir):\n            pwentry = getpwnam(username)\n            sshdir = os.path.join(pwentry.pw_dir, '.ssh')\n            if not os.path.isdir(sshdir):\n                sshdir = None\n    return sshdir", "response": "Get the users ssh dir"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_local_user(username):\n    try:\n        _ = getpwnam(username)\n        luser = username\n    except KeyError:\n        luser = getuser()\n    return luser", "response": "Get the local username"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake a SFTP connection returns sftp client and connection objects", "response": "def get_sftp_conn(config):\n    \"\"\"Make a SFTP connection, returns sftp client and connection objects\"\"\"\n    remote = config.get('remote_location')\n    parts = urlparse(remote)\n\n    if ':' in parts.netloc:\n        hostname, port = parts.netloc.split(':')\n    else:\n        hostname = parts.netloc\n        port = 22\n    port = int(port)\n\n    username = config.get('remote_username') or getuser()\n    luser = get_local_user(username)\n    sshdir = get_ssh_dir(config, luser)\n    hostkey = get_host_keys(hostname, sshdir)\n\n    try:\n        sftp = None\n        keys = get_ssh_keys(sshdir)\n        transport = Transport((hostname, port))\n        while not keys.empty():\n            try:\n                key = PKey.from_private_key_file(keys.get())\n                transport.connect(\n                    hostkey=hostkey,\n                    username=username,\n                    password=None,\n                    pkey=key)\n                sftp = SFTPClient.from_transport(transport)\n                break\n            except (PasswordRequiredException, SSHException):\n                pass\n        if sftp is None:\n            raise SaChannelUpdateTransportError(\"SFTP connection failed\")\n        return sftp, transport\n    except BaseException as msg:\n        raise SaChannelUpdateTransportError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if there is currently at least one token and reduces it by one.", "response": "def check_and_consume(self):\n        \"\"\"Returns True if there is currently at least one token, and reduces\n        it by one.\n\n        \"\"\"\n\n        if self._count < 1.0:\n            self._fill()\n\n        consumable = self._count >= 1.0\n        if consumable:\n            self._count -= 1.0\n            self.throttle_count = 0\n        else:\n            self.throttle_count += 1\n\n        return consumable"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _fill(self):\n\n        right_now = time.time()\n        time_diff = right_now - self._last_fill\n        if time_diff < 0:\n            return\n\n        self._count = min(\n            self._count + self._fill_rate * time_diff,\n            self._capacity,\n        )\n        self._last_fill = right_now", "response": "Fills bucket with accrued tokens since last fill."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mysql_batch_and_fetch(mysql_config, *sql_queries):\n    # load modules\n    import MySQLdb as mydb\n    import sys\n    import gc\n\n    # ensure that `sqlqueries` is a list/tuple\n    # split a string into a list\n    if len(sql_queries) == 1:\n        if isinstance(sql_queries[0], str):\n            sql_queries = sql_queries[0].split(\";\")\n        if isinstance(sql_queries[0], (list, tuple)):\n            sql_queries = sql_queries[0]\n\n    # connect and execute queries\n    try:\n        conn = mydb.connect(**mysql_config)\n        curs = conn.cursor()\n        for sql_query in sql_queries:\n            if len(sql_query) > 0:\n                curs.execute(sql_query)\n        result_table = curs.fetchall()\n    except mydb.Error as err:\n        print(err)\n        gc.collect()\n        sys.exit(1)\n    else:\n        if conn:\n            conn.close()\n        gc.collect()\n        return result_table", "response": "Batch and fetch SQL queries and return a tuple of tuples."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert snake_cased_names to CamelCaseNames.", "response": "def to_camel_case(snake_case_name):\n    \"\"\"\n    Converts snake_cased_names to CamelCaseNames.\n\n    :param snake_case_name: The name you'd like to convert from.\n    :type snake_case_name: string\n\n    :returns: A converted string\n    :rtype: string\n    \"\"\"\n    bits = snake_case_name.split('_')\n    return ''.join([bit.capitalize() for bit in bits])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef html_to_rst(html):\n    doc = ReSTDocument()\n    doc.include_doc_string(html)\n    raw_doc = doc.getvalue()\n    return raw_doc.decode('utf-8')", "response": "Converts the service HTML docs to reStructured Text"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resize_image_folder(bucket, key_prefix, pil_size):\n    con = boto.connect_s3()\n    b = con.get_bucket(bucket)\n    for key in b.list(key_prefix):\n        key = b.get_key(key.name)\n        if 'image' not in key.content_type:\n            continue\n        size = key.get_metadata('size')\n        if size == str(pil_size):\n            continue\n        with tempfile.TemporaryFile() as big, tempfile.TemporaryFile() as small:\n            # download file and resize\n            key.get_contents_to_file(big)\n            big.flush()\n            big.seek(0)\n            img = Image.open(big)\n            img.thumbnail(pil_size, Image.ANTIALIAS)\n\n            img.save(small, img.format)\n            small.flush()\n            small.seek(0)\n            key.set_metadata('size', str(pil_size))\n            key.set_contents_from_file(small, headers={'Content-Type': key.content_type})", "response": "This function resizes all the images in a folder"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a section and optionally gives it a friendly name.", "response": "def add_section(self, section, friendly_name = None):\r\n  \"\"\"Adds a section and optionally gives it a friendly name..\"\"\"\r\n  if not isinstance(section, BASESTRING): # Make sure the user isn't expecting to use something stupid as a key.\r\n   raise ValueError(section)\r\n  # See if we've got this section already:\r\n  if section in self.config:\r\n   raise DuplicateSectionError(section) # Yep... Kick off.\r\n  else:\r\n   self.config[section] = OrderedDict() # Nope... Ad it\r\n   if friendly_name == None:\r\n    friendly_name = section.title()\r\n   if '&' not in friendly_name:\r\n    friendly_name = '&' + friendly_name\r\n   self.section_names[section] = friendly_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set(self, section, option, value = None, title = None, validate = None, help = None, control = None, args = None, kwargs = None, include = None):\r\n  if self.has_option(section, option):\r\n   oldValue = self.get(section, option) # Store for comparison.\r\n   v = self.config[section][option] # Don't alter anything but the value.\r\n  else:\r\n   oldValue = value # It's new, don't alert.\r\n   v = {} # The entry for self.config[section][value].\r\n  if title != None:\r\n   v['title'] = title\r\n  else:\r\n   v['title'] = v.get('title', option.title()) # Set default capitalised title\r\n  if help != None:\r\n   v['help'] = help\r\n  else:\r\n   v['help'] = v.get('help', '')\r\n  if validate != None:\r\n   v['validate'] = validate\r\n  else:\r\n   v['validate'] = v.get('validate', lambda value: None)\r\n  if control != None:\r\n   v['control'] = control\r\n  else:\r\n   ctrl = None\r\n   for x, y in self.control_types.items():\r\n    if issubclass(type(value), x):\r\n     ctrl = y\r\n     break\r\n   else:\r\n    raise TypeError('No control provided, and none found for type of value: %s.' % repr(value))\r\n   v['control'] = v.get('control', ctrl)\r\n  if args != None:\r\n   v['args'] = args\r\n  else:\r\n   v['args'] = v.get('args', [])\r\n  if kwargs != None:\r\n   v['kwargs'] = kwargs\r\n  else:\r\n   v['kwargs'] = v.get('kwargs', {})\r\n  if include != None:\r\n   v['include'] = include\r\n  else:\r\n   v['include'] = v.get('include', True)\r\n  v['value'] = value\r\n  # Add everything to self.config:\r\n  self.config[section][option] = v\r\n  if value != oldValue: # Then call self.updateFunc\r\n   self.updateFunc(self, section, option, value)", "response": "Set the value of an option in a section."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntoggling option in section.", "response": "def toggle(self, section, option):\r\n  \"\"\"Toggles option in section.\"\"\"\r\n  self.set(section, option, not self.get(section, option))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the option s value converted into it s intended type.", "response": "def get(self, section, option, default = None):\r\n  \"\"\"Returns the option's value converted into it's intended type. If default is specified, return that on failure, else raise NoOptionError.\"\"\"\r\n  if self.has_section(section):\r\n   try:\r\n    return self.config[section][option].get('value', None)\r\n   except KeyError:\r\n    if default == None:\r\n     raise NoOptionError(option)\r\n    else:\r\n     return default\r\n  else:\r\n   raise NoSectionError(section)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of all options and values.", "response": "def get_dump(self):\r\n  \"\"\"Returns options and values.\"\"\"\r\n  res = []\r\n  for section in self.sections():\r\n   sec = []\r\n   for option in self.options(section):\r\n    sec.append([option, self.get(section, option)])\r\n   res.append([section, sec])\r\n  return res"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _onError(self, error):\n        self.stop()\n        self._logModule.err(\n            error,\n            \"Unhandled error logging exception to %s\" % (self.airbrakeURL,))\n        self.start()", "response": "Stop observer raise exception then restart."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nappend a new row to a DataRange", "response": "def row_append(self, row_key, value_list):\n        \"\"\"\n        append a new row to a DataRange\n\n        :param row_key: a string\n        :param value_list: a list\n        \"\"\"\n        if row_key in self._row_keys:\n            raise KeyError('Key %s already exists in row keys.' % row_key)\n        if not len(value_list) == len(self._col_keys):\n            raise ValueError('Length of data to set does not meet expected row length of %i' % len(self._col_keys))\n        self._row_keys.append(row_key)\n        for c, v in zip(self._col_keys, value_list):\n            self[row_key, c] = v"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nappends a new row to a DataRange", "response": "def col_append(self, col_key, value_list):\n        \"\"\"\n        append a new row to a DataRange\n\n        :param row_key: a string\n        :param value_list: a list\n        \"\"\"\n        if col_key in self._col_keys:\n            raise KeyError('Key %s already exists col keys.' % col_key)\n        if not isinstance(value_list, (tuple, list)):\n            value_list = [value_list] * len(self._row_keys)\n        if not len(value_list) == len(self._row_keys):\n            raise ValueError('Length of data to set does not meet expected col length of %i' % len(self._row_keys))\n        self._col_keys.append(col_key)\n        for r, v in zip(self._row_keys, value_list):\n            self[r, col_key] = v"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_arguments():\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument('file', metavar=\"FILE\", nargs='+',\n                        help='file to be made executable')\n    parser.add_argument(\"-p\", \"--python\", metavar=\"VERSION\",\n                        help=\"python version (2 or 3)\")\n    parser.add_argument('-v', '--version', action='version',\n                        version='%(prog)s ' + __version__, help='show version')\n    parser.add_argument('-r', '--recursive', action='store_true',\n                        help='recursively iterate the directories')\n\n    args = parser.parse_args()\n    return args", "response": "Parses all the command line arguments using argparse and returns them."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef contains_shebang(f):\n    first_line = f.readline()\n    if first_line in shebangs.values():\n        return True\n    return False", "response": "Returns true if any shebang line is present in the first line of the file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef put_shebang(f, version):\n    if not contains_shebang(f):\n        f.seek(0)\n        original_text = f.read()\n        f.seek(0)\n        f.write(shebangs[version] + original_text)", "response": "Writes a shebang to the first line of the file according to the specified version."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites the shebang and makes the file executable.", "response": "def make_exec(fname, version):\n    \"\"\"\n    Writes the shebang and makes the file executable.\n    \"\"\"\n    # if no version is specified, use system default.\n    if version is None:\n        version = 'default'\n\n    # write the shebang and then make the file executable.\n    with open(fname, 'rb+') as f:\n        put_shebang(f, version)\n    # make the file\n    os.chmod(fname, os.stat(fname).st_mode | 0o0111)\n    print(\"{} is now executable\".format(fname))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the path to the original uploaded data file that the subject was created from.", "response": "def data_file(self):\n        \"\"\"Original uploaded data file the subject was created from.\n\n        Returns\n        -------\n        File-type object\n            Reference to file on local disk\n        \"\"\"\n        return os.path.join(self.upload_directory, self.properties[datastore.PROPERTY_FILENAME])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef upload_file(self, filename, file_type=FILE_TYPE_FREESURFER_DIRECTORY):\n        # We currently only support one file type (i.e., FREESURFER_DIRECTORY).\n        if file_type != FILE_TYPE_FREESURFER_DIRECTORY:\n            raise ValueError('Unsupported file type: ' + file_type)\n        return self.upload_freesurfer_archive(filename)", "response": "Uploads an anatomy file to the local disk."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nuploading an anatomy object from a Freesurfer file to the local disk.", "response": "def upload_freesurfer_archive(self, filename, object_identifier=None, read_only=False):\n        \"\"\"Create an anatomy object on local disk from a Freesurfer anatomy\n        tar file. If the given file is a Freesurfer file it will be copied to\n        the created subject's upload directory.\n\n        Parameters\n        ----------\n        filename : string\n            Name of the (uploaded) file\n        object_identifier : string\n            Unique object identifier, optional\n        read_only : boolean, optional\n            Optional value for the read-only property\n\n        Returns\n        -------\n        SubjectHandle\n            Handle for created subject in database\n        \"\"\"\n        # At this point we expect the file to be a (compressed) tar archive.\n        # Extract the archive contents into a new temporary directory\n        temp_dir = tempfile.mkdtemp()\n        try:\n            tf = tarfile.open(name=filename, mode='r')\n            tf.extractall(path=temp_dir)\n        except (tarfile.ReadError, IOError) as err:\n            # Clean up in case there is an error during extraction\n            shutil.rmtree(temp_dir)\n            raise ValueError(str(err))\n        # Find a folder that contains sub-folders 'surf' and 'mri'. These\n        # are the only folders we keep in the new anatomy folder. Raise an\n        # error if no such folder esists\n        freesurf_dir = get_freesurfer_dir(temp_dir)\n        if not freesurf_dir:\n            # Remove anatomy directory and extracted files\n            shutil.rmtree(temp_dir)\n            raise ValueError('not a valid subject directory')\n        # Create a new identifier. This identifier will be used as the\n        # directory name.\n        if object_identifier is None:\n            identifier = str(uuid.uuid4()).replace('-', '')\n        else:\n            identifier = object_identifier\n        subject_dir = os.path.join(self.directory, identifier)\n        # Create the initial set of properties for the new anatomy object. The\n        # name is derived from the filename minus any known extensions\n        prop_filename = os.path.basename(os.path.normpath(filename))\n        prop_name = prop_filename\n        # Based on the valid list of suffixes the file is either a tar-file\n        # or a zipped tar-file.\n        prop_mime = 'application/x-tar' if filename.endswith('.tar') else 'application/x-gzip'\n        for suffix in ['.tar', '.tgz', '.tar.gz']:\n            if prop_name.endswith(suffix):\n                prop_name = prop_name[:-len(suffix)]\n                break\n        properties = {\n            datastore.PROPERTY_FILENAME : prop_filename,\n            datastore.PROPERTY_FILESIZE : os.path.getsize(filename),\n            datastore.PROPERTY_FILETYPE : FILE_TYPE_FREESURFER_DIRECTORY,\n            datastore.PROPERTY_MIMETYPE : prop_mime,\n            datastore.PROPERTY_NAME : prop_name\n        }\n        if read_only:\n            properties[datastore.PROPERTY_READONLY] = True\n        # Create the directory for the anatomy object, the unpacked data files\n        # and the original uploaded file (for download).\n        os.mkdir(subject_dir)\n        data_dir = os.path.join(subject_dir, DATA_DIRECTORY)\n        os.mkdir(data_dir)\n        upload_dir = os.path.join(subject_dir, UPLOAD_DIRECTORY)\n        os.mkdir(upload_dir)\n        # Move all sub-folders from the Freesurfer directory to the new anatomy\n        # data directory\n        for f in os.listdir(freesurf_dir):\n            sub_folder = os.path.join(freesurf_dir, f)\n            if os.path.isdir(sub_folder):\n                shutil.move(sub_folder, data_dir)\n        # Move original upload file to upload directory\n        shutil.copyfile(filename, os.path.join(upload_dir, prop_filename))\n        # Remove the temp directory\n        shutil.rmtree(temp_dir)\n        # Use current time in UTC as the object's timestamp\n        obj = SubjectHandle(\n            identifier,\n            properties,\n            subject_dir\n        )\n        self.insert_object(obj)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding and return a UI object for this script.", "response": "def getUI(args):\n  \"\"\"\n  build and return a UI object for this script.\n\n  :param args: raw arguments to parse\n  \"\"\"\n  programName = os.path.basename(sys.argv[0])\n  longDescription = \"takes a file with a list of p-values and applies \" +\\\n                    \"Benjamini and Hochberg FDR to convert to q-values \"\n  shortDescription = \"takes a file with a list of p-values and applies \" +\\\n                     \"Benjamini and Hochberg FDR to convert to q-values \"\n\n  ui = CLI(programName, shortDescription, longDescription)\n  ui.minArgs = 2\n  ui.maxArgs = 2\n  ui.addOption(Option(short=\"o\", long=\"output\", argName=\"filename\",\n                      description=\"output to given file, else stdout\",\n                      required=False, type=str))\n  ui.addOption(Option(short=\"s\", long=\"stranded\",\n                      description=\"treat regions on separate strands as \" +\n                                  \"disjoint, even if they overlap\",\n                                  required=False))\n  ui.addOption(Option(short=\"v\", long=\"verbose\",\n                      description=\"output additional messages to stderr \" +\n                                  \"about run\", required=False))\n  ui.addOption(Option(short=\"h\", long=\"help\",\n                      description=\"show this help message \", special=True))\n  ui.addOption(Option(short=\"u\", long=\"test\",\n                      description=\"run unit tests \", special=True))\n\n  ui.parseCommandLine(args)\n  return ui"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main(args):\n  # get options and arguments\n  ui = getUI(args)\n\n  if ui.optionIsSet(\"test\"):\n    # just run unit tests\n    unittest.main(argv=[sys.argv[0]])\n  elif ui.optionIsSet(\"help\"):\n    # just show help\n    ui.usage()\n  else:\n    verbose = ui.optionIsSet(\"verbose\")\n\n    # stranded?\n    stranded = ui.optionIsSet(\"stranded\")\n    if stranded:\n      sys.stderr.write(\"Sorry, stranded mode hasn't been implemented yet.\")\n      sys.exit()\n\n    # get output handle\n    out_fh = sys.stdout\n    if ui.optionIsSet(\"output\"):\n      out_fh = open(ui.getValue(\"output\"), \"w\")\n\n    # get input file-handles -- we know we'll get exactly two, since we\n    # specified it in the UI definition\n    regions_1 = [x for x in BEDIterator(ui.getArgument(0), verbose=verbose)]\n    regions_2 = [x for x in BEDIterator(ui.getArgument(1), verbose=verbose)]\n\n    for r in regionsIntersection(regions_1, regions_2):\n      out_fh.write(str(r) + \"\\n\")", "response": "This is the main entry point for the GenomicIntIntersection script. It will run unit tests and run the intersection script."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets section name tuple", "response": "def getAsTuple(self, section):\n        \"\"\"Get section name tuple\n\n        :param section: section name\n        :return: tuple object\n        \"\"\"\n        keys = self.getKeys(section)\n        value_dict = self.getValues(section)\n        return namedtuple(section, keys)(**value_dict)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake a requirement and updates it based on a specific attribute key", "response": "def update_req(name, old_req, config={}):\n    \"\"\"\n    Takes a requirement and updates it based on a specific attribute key\n\n    args:\n        name: the name of the attribute\n        old_req: the requirement definition\n    \"\"\"\n    if not name:\n        return old_req\n    new_req = copy.deepcopy(old_req)\n    del_idxs = []\n    if \"req_items\" in old_req:\n        req_key = get_req_key(old_req['req_items'])\n        for i, item in enumerate(old_req['req_items']):\n            if name == item[req_key] and item.get(\"dict_params\"):\n                for param, value in item['dict_params'].items():\n                    new_req['item_dict'][param].update(value)\n            if item.get(\"remove_if\"):\n                test_val = get_attr(config, item['remove_if']['attr'])\n                if test_val == item['remove_if']['value']:\n                    del_idxs.append(i)\n        for idx in sorted(del_idxs, reverse=True):\n            del new_req['req_items'][idx]\n\n    return new_req"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of options from a python object string", "response": "def get_options_from_str(obj_str, **kwargs):\n    \"\"\"\n    Returns a list of options from a python object string\n\n    args:\n        obj_str: python list of options or a python object path\n                  Example: \"rdfframework.connections.ConnManager[{param1}]\"\n\n    kwargs:\n        * kwargs used to format the 'obj_str'\n    \"\"\"\n    if isinstance(obj_str, list):\n        return obj_str\n    try:\n        obj = get_obj_frm_str(obj_str, **kwargs)\n        if obj:\n            return list(obj)\n    except AttributeError:\n        pass\n    return []"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef strip_errors(obj):\n    rtn_obj = copy.deepcopy(obj)\n    try:\n        del rtn_obj[\"__error_keys__\"]\n    except KeyError:\n        pass\n    for key in obj.get('__error_keys__', []):\n        rtn_obj[key] = rtn_obj[key]['value']\n    return rtn_obj", "response": "Reads through and error object and replaces the error dict with the value of the\n    value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a string representation of the given datetime.", "response": "def past_datetime_str(adatetime):\n    \"\"\"\n    For adatetime is since 12:00AM, return: \"Today at H:MM [A]PM\"\n    For adatetime is between 12:00AM and 11:59PM on yesterday:\n                                    \"Yesterday at 6:23 PM\"\n    For adatetime is between 2 and 6 days ago: \"[2-6] days ago\"\n    For adatetime is 7 days ago: \"1 week ago\"\n    For adatetime is 8-14 days ago: \"Over 1 week ago\"\n    For adatetime is 15-21 days ago: \"Over 2 weeks ago\"\n    For adatetime is 22-28 days ago: \"Over 3 weeks ago\"\n    For adatetime is 29-56 days ago: \"Over 1 month ago\"\n    For adatetime is 57-84 days ago: \"Over 2 months ago\"\n    For adatetime is 85-112 days ago: \"Over 3 months ago\"\n    and so on, in increments of 28 days, until T-365,\n    at which point: \"Over 1 year ago\",\n    then after another 365 days \"Over 2 years ago\", etc\n    \"\"\"\n    if is_today(adatetime):\n        return \"today at {}\".format(time_str(adatetime))\n\n    if last_midnight() - adatetime <= timedelta(days=7):\n        for day in range(1, 8):\n            if is_days_ago(adatetime, day):\n                if day == 1:\n                    return \"yesterday at {}\".format(time_str(adatetime))\n                if day == 7:\n                    return \"1 week ago\"\n                return \"{:.0f} days ago\".format(day)\n\n    if last_midnight() - adatetime <= timedelta(days=28):\n        week = get_past_weeks_count(adatetime)\n        if week == 1:\n            return \"over {:.0f} week ago\".format(week)\n        else:\n            return \"over {:.0f} weeks ago\".format(week)\n\n    if last_midnight() - adatetime <= timedelta(days=365):\n        month = get_past_months_count(adatetime)\n        if month == 1:\n            return \"over {:.0f} month ago\".format(month)\n        else:\n            return \"over {:.0f} months ago\".format(month)\n\n    year = get_past_years_count(adatetime)\n    if year == 1:\n        return \"over {:.0f} year ago\".format(year)\n    else:\n        return \"over {:.0f} years ago\".format(year)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True if the adatetime is on the specified days ago", "response": "def is_days_ago(adatetime, days):\n    \"\"\"\n    :param days: a positive integer.\n    Return true if the adatetime is on the specified days ago\n    \"\"\"\n    if days == 1:\n        end_time = last_midnight()\n        start_time = end_time - timedelta(days=1)\n    else:\n        start_time = last_midnight() - timedelta(days=days)\n        end_time = start_time + timedelta(days=1)\n    return start_time <= adatetime <= end_time"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef last_midnight():\n    now = datetime.now()\n    return datetime(now.year, now.month, now.day)", "response": "Returns a datetime of the last mid -night of the sequence"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle(self, *args, **options):\n        user_model = get_user_model()\n\n        if len(args) == 0:\n            # find the first superuser, or staff member or user\n            filters = [{\"is_superuser\": True}, {\"is_staff\": True}, {}]\n            user = None\n            for f in filters:\n                try:\n                    user = user_model._default_manager.filter(**f).order_by(\"pk\").first()\n                    if user:\n                        break\n                except FieldError as e:\n                    pass\n\n            if user is None:\n                raise CommandError(\"No users found!\")\n\n        elif len(args) == 1:\n            # find the user with the USERNAME_FIELD equal to the command line\n            # argument\n            try:\n                user = user_model._default_manager.get_by_natural_key(args[0])\n            except user_model.DoesNotExist as e:\n                raise CommandError(\"The user does not exist\")\n        else:\n            raise CommandError(\"You passed me too many arguments\")\n\n        signer = TimestampSigner()\n        signature = signer.sign(str(user.pk))\n\n        self.stdout.write(reverse(login, args=(signature,)))", "response": "Handles the login command."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of model fields to include in the model", "response": "def get_model_fields(self):\n        \"\"\" List of model fields to include (defaults to all) \"\"\"\n\n        model_fields = getattr(self.Meta, 'fields', None)\n\n        if model_fields is not None:\n            model_fields = set(model_fields)\n\n        return model_fields"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading a config file into a dict with configuration from the supplied yaml file Invite", "response": "def load_config(configfile):\n    \"\"\"\n    Return a dict with configuration from the supplied yaml file\n    \"\"\"\n    try:\n        with open(configfile, 'r') as ymlfile:\n            try:\n                config = yaml.load(ymlfile)\n                return config\n            except yaml.parser.ParserError:\n                raise PyYAMLConfigError(\n                    'Could not parse config file: {}'.format(configfile),\n                )\n    except IOError:\n        raise PyYAMLConfigError(\n            'Could not open config file: {}'.format(configfile),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite dict to a file in yaml format", "response": "def write_config(configfile, content):\n    \"\"\"\n    Write dict to a file in yaml format\n    \"\"\"\n    with open(configfile, 'w+') as ymlfile:\n        yaml.dump(\n            content,\n            ymlfile,\n            default_flow_style=False,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start_record():\n    global record, playback, current\n    if record:\n        raise StateError(\"Already recording.\")\n    if playback:\n        raise StateError(\"Currently playing back.\")\n    record = True\n    current = ReplayData()\n    install(RecordingHTTPConnection, RecordingHTTPSConnection)", "response": "Install an httplib wrapper that records but does not modify calls."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_types(func):\n    call = PythonCall(func)\n\n    @wraps(func)\n    def decorator(*args, **kwargs):\n        parameters = call.bind(args, kwargs)\n        for arg_name, expected_type in func.__annotations__.items():\n            if not isinstance(parameters[arg_name], expected_type):\n                raise TypeError(\"{} must be a {}\".format(\n                    arg_name, expected_type))\n        return call.apply(args, kwargs)\n    return decorator", "response": "Check if annotated function arguments are of the correct type\nWorkItem"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_absolute_uri(self, uri):\n        request = self.context.get('request', None)\n\n        return (\n            request.build_absolute_uri(uri) if request is not None else uri\n        )", "response": "Build a fully qualified absolute url for the given uri."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_resource_uri(self, obj):\n        url = 'api:%s:%s-detail' % (\n            self.api_version,\n            getattr(\n                self, 'resource_view_name',\n                self.Meta.model._meta.model_name\n            )\n        )\n\n        return reverse(url, request=self.context.get('request', None), kwargs={\n            self.lookup_field: getattr(obj, self.lookup_field)\n        })", "response": "Return the uri of the given object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render(self, template: str, **vars) -> str:\n        vars.setdefault('ctx', self._ctx)\n        return self._renderer.render(template, **vars)", "response": "Render the named template."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render_string(self, source: str, **vars) -> str:\n        vars.setdefault('ctx', self._ctx)\n        return self._renderer.render_string(source, **vars)", "response": "Render the template contained in the given string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the AMF header from the stream.", "response": "def _read_header(stream, decoder, strict=False):\n    \"\"\"\n    Read AMF L{Message} header from the stream.\n\n    @type stream: L{BufferedByteStream<pyamf.util.BufferedByteStream>}\n    @param decoder: An AMF0 decoder.\n    @param strict: Use strict decoding policy. Default is C{False}. Will raise a\n        L{pyamf.DecodeError} if the data that was read from the stream does not\n        match the header length.\n    @return: A C{tuple} containing the name of the header, a C{bool}\n        determining if understanding this header is required and the decoded\n        data.\n    @note: Quite what understanding required headers actually means is unknown.\n    \"\"\"\n    name_len = stream.read_ushort()\n    name = stream.read_utf8_string(name_len)\n\n    required = bool(stream.read_uchar())\n\n    data_len = stream.read_ulong()\n    pos = stream.tell()\n\n    data = decoder.readElement()\n\n    if strict and pos + data_len != stream.tell():\n        raise pyamf.DecodeError(\n            \"Data read from stream does not match header length\")\n\n    return (name, required, data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites the header of the AMF message.", "response": "def _write_header(name, header, required, stream, encoder, strict=False):\n    \"\"\"\n    Write AMF message header.\n\n    @param name: Name of the header.\n    @param header: Header value.\n    @param required: Whether understanding this header is required (?).\n    @param stream: L{BufferedByteStream<pyamf.util.BufferedByteStream>} that\n        will receive the encoded header.\n    @param encoder: An encoder capable of encoding C{AMF0}.\n    @param strict: Use strict encoding policy. Default is C{False}. Will write\n        the correct header length after writing the header.\n    \"\"\"\n    stream.write_ushort(len(name))\n    stream.write_utf8_string(name)\n\n    stream.write_uchar(required)\n    write_pos = stream.tell()\n\n    stream.write_ulong(0)\n    old_pos = stream.tell()\n    encoder.writeElement(header)\n    new_pos = stream.tell()\n\n    if strict:\n        stream.seek(write_pos)\n        stream.write_ulong(new_pos - old_pos)\n        stream.seek(new_pos)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading an AMF message body from the stream.", "response": "def _read_body(stream, decoder, strict=False, logger=None):\n    \"\"\"\n    Read an AMF message body from the stream.\n\n    @type stream: L{BufferedByteStream<pyamf.util.BufferedByteStream>}\n    @param decoder: An AMF0 decoder.\n    @param strict: Use strict decoding policy. Default is `False`.\n    @param logger: Used to log interesting events whilst reading a remoting\n        body.\n    @type logger: A C{logging.Logger} instance or C{None}.\n    @return: A C{tuple} containing the C{id} of the request and the L{Request}\n        or L{Response}\n    \"\"\"\n    def _read_args():\n        # we have to go through this insanity because it seems that amf0\n        # does not keep the array of args in the object references lookup\n        type_byte = stream.peek(1)\n\n        if type_byte == '\\x11':\n            if not decoder.use_amf3:\n                raise pyamf.DecodeError(\n                    \"Unexpected AMF3 type with incorrect message type\")\n\n            return decoder.readElement()\n\n        if type_byte != '\\x0a':\n            raise pyamf.DecodeError(\"Array type required for request body\")\n\n        stream.read(1)\n        x = stream.read_ulong()\n\n        return [decoder.readElement() for i in xrange(x)]\n\n    target = stream.read_utf8_string(stream.read_ushort())\n    response = stream.read_utf8_string(stream.read_ushort())\n\n    status = STATUS_OK\n    is_request = True\n\n    for code, s in STATUS_CODES.iteritems():\n        if not target.endswith(s):\n            continue\n\n        is_request = False\n        status = code\n        target = target[:0 - len(s)]\n\n    if logger:\n        logger.debug('Remoting target: %r' % (target,))\n\n    data_len = stream.read_ulong()\n    pos = stream.tell()\n\n    if is_request:\n        data = _read_args()\n    else:\n        data = decoder.readElement()\n\n    if strict and pos + data_len != stream.tell():\n        raise pyamf.DecodeError(\"Data read from stream does not match body \"\n            \"length (%d != %d)\" % (pos + data_len, stream.tell(),))\n\n    if is_request:\n        return response, Request(target, body=data)\n\n    if status == STATUS_ERROR and isinstance(data, pyamf.ASObject):\n        data = get_fault(data)\n\n    return target, Response(data, status)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _write_body(name, message, stream, encoder, strict=False):\n    def _encode_body(message):\n        if isinstance(message, Response):\n            encoder.writeElement(message.body)\n\n            return\n\n        stream.write('\\x0a')\n        stream.write_ulong(len(message.body))\n        for x in message.body:\n            encoder.writeElement(x)\n\n    if not isinstance(message, (Request, Response)):\n        raise TypeError(\"Unknown message type\")\n\n    target = None\n\n    if isinstance(message, Request):\n        target = unicode(message.target)\n    else:\n        target = u\"%s%s\" % (name, _get_status(message.status))\n\n    target = target.encode('utf8')\n\n    stream.write_ushort(len(target))\n    stream.write_utf8_string(target)\n\n    response = 'null'\n\n    if isinstance(message, Request):\n        response = name\n\n    stream.write_ushort(len(response))\n    stream.write_utf8_string(response)\n\n    if not strict:\n        stream.write_ulong(0)\n        _encode_body(message)\n\n        return\n\n    write_pos = stream.tell()\n    stream.write_ulong(0)\n    old_pos = stream.tell()\n\n    _encode_body(message)\n    new_pos = stream.tell()\n\n    stream.seek(write_pos)\n    stream.write_ulong(new_pos - old_pos)\n    stream.seek(new_pos)", "response": "Writes the message body to the stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef decode(stream, strict=False, logger=None, timezone_offset=None):\n    if not isinstance(stream, util.BufferedByteStream):\n        stream = util.BufferedByteStream(stream)\n\n    if logger:\n        logger.debug('remoting.decode start')\n\n    msg = Envelope()\n    msg.amfVersion = stream.read_ushort()\n\n    # see http://osflash.org/documentation/amf/envelopes/remoting#preamble\n    # why we are doing this...\n    if msg.amfVersion > 0x09:\n        raise pyamf.DecodeError(\"Malformed stream (amfVersion=%d)\" %\n            msg.amfVersion)\n\n    decoder = pyamf.get_decoder(pyamf.AMF0, stream, strict=strict,\n        timezone_offset=timezone_offset)\n    context = decoder.context\n\n    decoder.use_amf3 = msg.amfVersion == pyamf.AMF3\n    header_count = stream.read_ushort()\n\n    for i in xrange(header_count):\n        name, required, data = _read_header(stream, decoder, strict)\n        msg.headers[name] = data\n\n        if required:\n            msg.headers.set_required(name)\n\n    body_count = stream.read_short()\n\n    for i in xrange(body_count):\n        context.clear()\n\n        target, payload = _read_body(stream, decoder, strict, logger)\n        msg[target] = payload\n\n    if strict and stream.remaining() > 0:\n        raise RuntimeError(\"Unable to fully consume the buffer\")\n\n    if logger:\n        logger.debug('remoting.decode end')\n\n    return msg", "response": "Decodes the incoming stream as a remoting message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nencode a message into an AMF - encoded stream.", "response": "def encode(msg, strict=False, logger=None, timezone_offset=None):\n    \"\"\"\n    Encodes and returns the L{msg<Envelope>} as an AMF stream.\n\n    @param strict: Enforce strict encoding. Default is C{False}. Specifically\n        header/body lengths will be written correctly, instead of the default 0.\n        Default is `False`. Introduced in 0.4.\n    @param logger: Used to log interesting events whilst decoding a remoting\n        message.\n    @type logger: U{logging.Logger<http://\n        docs.python.org/library/logging.html#loggers>}\n    @param timezone_offset: The difference between the current timezone and\n        UTC. Date/times should always be handled in UTC to avoid confusion but\n        this is required for legacy systems.\n    @type timezone_offset: U{datetime.datetime.timedelta<http://\n        docs.python.org/library/datetime.html#datetime.timedelta}\n    @rtype: L{BufferedByteStream<pyamf.util.BufferedByteStream>}\n    \"\"\"\n    stream = util.BufferedByteStream()\n\n    encoder = pyamf.get_encoder(pyamf.AMF0, stream, strict=strict,\n        timezone_offset=timezone_offset)\n\n    if msg.amfVersion == pyamf.AMF3:\n        encoder.use_amf3 = True\n\n    stream.write_ushort(msg.amfVersion)\n    stream.write_ushort(len(msg.headers))\n\n    for name, header in msg.headers.iteritems():\n        _write_header(name, header, int(msg.headers.is_required(name)),\n            stream, encoder, strict)\n\n    stream.write_short(len(msg))\n\n    for name, message in msg.iteritems():\n        encoder.context.clear()\n\n        _write_body(name, message, stream, encoder, strict)\n\n    stream.seek(0)\n\n    return stream"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef txtpack(fn, **kwargs):\n\n    loadfunc = pulltxt.loadtxt_asdict\n    cp = ChannelPack(loadfunc)\n    cp.load(fn, **kwargs)\n    names = pulltxt.PP.channel_names(kwargs.get('usecols', None))\n    cp.set_channel_names(names)\n    cp._patpull = pulltxt.PP    # Give a reference to the patternpull.\n    # cp.set_basefilemtime()\n    return cp", "response": "Return a ChannelPack instance loaded with text data file fn."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a ChannelPack instance loaded with dbf data file fn.", "response": "def dbfpack(fn, usecols=None):\n    \"\"\"Return a ChannelPack instance loaded with dbf data file fn.\n\n    This is a lazy function to get a loaded instance, using pulldbf\n    module.\"\"\"\n\n    loadfunc = pulldbf.dbf_asdict\n    cp = ChannelPack(loadfunc)\n    cp.load(fn, usecols)\n    names = pulldbf.channel_names(fn, usecols)\n    cp.set_channel_names(names)\n    # cp.set_basefilemtime()\n    return cp"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads a ChannelPack from a spread holding the file fn.", "response": "def sheetpack(fn, sheet=0, header=True, startcell=None, stopcell=None,\n              usecols=None):\n    \"\"\"Return a ChannelPack instance loaded with data from the spread\n    sheet file fn, (xls, xlsx).\n\n    fn: str\n        The file to read from.\n\n    sheet: int or str\n        If int, it is the index for the sheet 0-based. Else the sheet\n        name.\n\n    header: bool or str\n        True if the defined data range includes a header with field\n        names. Else False - the whole range is data. If a string, it is\n        a spread sheet style notation of the startcell for the header\n        (\"F9\"). The \"width\" of this record is the same as for the data.\n\n    startcell: str or None\n        If given, a spread sheet style notation of the cell where reading\n        start, (\"F9\").\n\n    stopcell: str or None\n        A spread sheet style notation of the cell where data end,\n        (\"F9\").\n\n    usecols: str or seqence of ints\n        The columns to use, 0-based. 0 is the spread sheet column\n        \"A\". Can be given as a string also - 'C:E, H' for columns C, D,\n        E and H.\n\n    Might not be a favorite, but the header row can be offset from the\n    data range. The meaning of usecols is then applied on both the data\n    range and the header row. However, usecols is always specified with\n    regards to the data range.\n    \"\"\"\n\n    cp = ChannelPack(pullxl.sheet_asdict)\n    chnames = []\n    cp.load(fn, sheet=sheet, header=header, startcell=startcell,\n            stopcell=stopcell, usecols=usecols, chnames_out=chnames)\n\n    cp.set_channel_names(chnames or None)\n    return cp"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads data from file into a dictionary.", "response": "def load(self, *args, **kwargs):\n        \"\"\"Load data using loadfunc.\n\n        args, kwargs:\n            forward to the loadfunc. args[0] must be the filename, so it\n            means that loadfunc must take the filename as it's first\n            argument.\n\n        Set the filename attribute.\n\n        .. note::\n           Updates the mask if not no_auto.\n\n        ChannelPack is assuming a need for loading data from disc. If\n        there is a desire to load some made-up data, a filename pointing\n        to some actual file is nevertheless required. Here is a\n        suggestion::\n\n            >>> import channelpack as cp\n            >>> import tempfile\n\n            >>> tf = tempfile.NamedTemporaryFile()\n\n            >>> d = {2: np.arange(5), 5: np.arange(10, 15)}\n            >>> def lf(fn):\n            ...     return d\n            ...\n\n            >>> pack = cp.ChannelPack(lf)\n            >>> pack.load(tf.name)\n            >>> pack.filename is not None\n            True\n            >>> pack.chnames_0\n            {2: 'ch2', 5: 'ch5'}\n\n        \"\"\"\n        D = self.loadfunc(*args, **kwargs)\n\n        if self.chnames is not None:\n            if set(D) - set(self.chnames):\n                raise ValueError('New data set have different keys')\n\n        self.D = D\n        self.keys = sorted(self.D.keys())\n        # If not all the same, there should have been an error already\n        self.rec_cnt = len(self.D[self.keys[0]])\n\n        fallnames = _fallback_names(self.keys)\n        self.chnames_0 = dict(zip(self.keys, fallnames))\n        self._set_filename(args[0])\n        self.set_basefilemtime()\n\n        self.args = args\n        self.kwargs = kwargs\n\n        if not self.no_auto:\n            # Called here if a reload is done on the current instance I guess.\n            self.make_mask()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append_load(self, *args, **kwargs):\n        if not self.D:\n            self.load(*args, **kwargs)\n            return\n\n        newD = self.loadfunc(*args, **kwargs)\n\n        s1, s2 = set(self.D.keys()), set(newD.keys())\n        offenders = s1 ^ s2\n        if offenders:\n            mess = ('Those keys (respectively) were in one of the dicts ' +\n                    'but not the other: {}.')\n            offs = ', '.join([str(n) for n in offenders])\n            raise KeyError(mess.format(offs))\n\n        # Append the data early to fail if fail before other actions.\n        for k, a in self.D.iteritems():\n            self.D[k] = np.append(a, newD.pop(k))\n\n        if not hasattr(self, 'metamulti'):\n            self.metamulti = dict(filenames=[], mtimestamps=[], mtimenames=[],\n                                  slices=[])\n\n            self.metamulti['filenames'].append(self.filename)\n            self.metamulti['mtimestamps'].append(self.mtimestamp)\n            self.metamulti['mtimenames'].append(self.mtimefs)\n            self.metamulti['slices'].append(slice(0, self.rec_cnt))\n\n        self.rec_cnt = len(self.D[self.keys[0]])\n        self._set_filename(args[0])\n        self.set_basefilemtime()\n\n        start = self.metamulti['slices'][-1].stop\n        stop = self.rec_cnt\n\n        self.metamulti['filenames'].append(self.filename)\n        self.metamulti['mtimestamps'].append(self.mtimestamp)\n        self.metamulti['mtimenames'].append(self.mtimefs)\n        self.metamulti['slices'].append(slice(start, stop))\n\n        if not self.no_auto:\n            self.make_mask()", "response": "Append data to the internal dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_filename(self, fn):\n        try:\n            self.filename = self.fs = self.fn = os.path.abspath(fn.name)\n        except AttributeError:\n            self.filename = self.fs = self.fn = os.path.abspath(fn)", "response": "Set the filename attributes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_samplerate(self, rate):\n\n        # Test and set value:\n        float(rate)\n        self.conconf.set_condition('samplerate', rate)\n        if not self.no_auto:\n            self.make_mask()", "response": "Set the samplerate of the record store."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_condition(self, conkey, cond):\n\n        # Audit:\n        if conkey == 'start' or conkey == 'stop':\n            conkey += 'cond'\n        if not any(conkey.startswith(addable) for addable in _ADDABLES):\n            raise KeyError(conkey)\n        if not self.conconf.valid_conkey(conkey):\n            raise KeyError(conkey)\n\n        self._parse_cond(cond)  # Checking\n\n        conkey = self.conconf.next_conkey(conkey)\n        self.conconf.set_condition(conkey, cond)\n\n        if not self.no_auto:\n            self.make_mask()", "response": "Add a condition to the internal state."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_cond(self, cond):\n\n        CHANNEL_RX = CHANNEL_FMT_RX.format(CHANNEL_IDENTIFIER_RX)\n\n        res = re.findall(CHANNEL_RX, cond)\n        for ident in res:\n            rx = CHANNEL_FMT_RX.format(ident)\n            i = self._key(ident)  # integer key\n\n            # repl = 'self(' + str(i) + ')'\n            # Cannot be. Calls (__call__) can be replaced by nan. So must call\n            # the array in the dict directly:\n\n            repl = 'self.D[' + str(i) + ']'\n            # %(<identifier>) replaced with self.D[i]\n            cond = re.sub(rx, repl, cond)\n        return cond", "response": "Parse the condition string and return the parsed string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites a config file based on this instance.", "response": "def spit_config(self, conf_file=None, firstwordonly=False):\n        \"\"\"Write a config_file based on this instance.\n\n        conf_file: str (or Falseish)\n            If conf_file is Falseish, write the file to the directory\n            where self.filename sits, if self is not already associated\n            with such a file. If associated, and conf_file is Falseish,\n            use self.conf_file. If conf_file is a file name, write to\n            that file and set self.conf_file to conf_file.\n\n        firstwordonly: bool or \"pattern\"\n            Same meaning as in name method, and applies to the channel\n            names spitted. There is no effect on the instance channel\n            names until eat_config is called.\n\n        Sections in the ini/cfg kind of file can be:\n\n            [channels]\n            A mapping of self.D integer keys to channel names. Options\n            are numbers corresponding to the keys. Values are the\n            channel names, being the fallback names if custom names are\n            not available (self.chnames). (When spitting that is).\n\n            [conditions]\n            Options correspond to the keys in self.conditions, values\n            correspond to the values in the same.\n        \"\"\"\n\n        chroot = os.path.dirname(self.filename)\n        chroot = os.path.abspath(chroot)\n\n        # Figure out file name of conf_file:\n        if hasattr(self, 'conf_file') and not conf_file:\n            cfgfn = self.conf_file\n        elif conf_file:\n            cfgfn = conf_file\n        else:\n            cfgfn = os.path.join(chroot, CONFIG_FILE)\n\n        with open(cfgfn, 'wb') as fo:\n            self.conconf.spit_config(fo, firstwordonly=firstwordonly)\n\n        self.conf_file = os.path.abspath(cfgfn)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef eat_config(self, conf_file=None):\n\n        chroot = os.path.dirname(self.filename)  # \"channels root dir\"\n        chroot = os.path.abspath(chroot)\n\n        # Figure out file name of conf_file:\n        if hasattr(self, 'conf_file') and not conf_file:\n            cfgfn = self.conf_file\n        elif conf_file:\n            cfgfn = conf_file\n        else:\n            cfgfn = os.path.join(chroot, CONFIG_FILE)\n\n        with open(cfgfn, 'r') as fo:\n            self.conconf.eat_config(fo)\n\n        # Update mask:\n        if not self.no_auto:\n            self.make_mask()\n        else:\n            self.make_mask(dry=True)", "response": "Read the conf_file and update self. chnames and self. chnames_0."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextend the True elements by n when setting the conditions based on a stopcond condition.", "response": "def set_stopextend(self, n):\n        \"\"\"Extend the True elements by n when setting the conditions\n        based on a 'stopcond' condition.\n\n        n is an integer >= 0.\n\n        .. note::\n           Updates the mask if not no_auto.\n        \"\"\"\n        self.conconf.set_condition('stopextend', n)\n        if not self.no_auto:\n            self.make_mask()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the duration according to rule.", "response": "def set_duration(self, rule):\n        \"\"\"Set the duration according to rule.\n\n        rule: str\n            The rule operating on the variable ``dur``.\n\n        rule is an expression like::\n\n            >>> rule = 'dur == 150 or dur > 822'\n\n        setting a duration rule assuming a pack sp::\n\n            >>> sp.set_duration(rule)\n\n        The identifier ``dur`` must be present or the rule will fail.\n\n        .. note::\n           The logical ``or`` and ``and`` operators must be used. ``dur`` is a\n           primitive, not an array.\n\n        .. note::\n           Updates the mask if not no_auto.\n\n        .. seealso::\n           :meth:`~channelpack.ChannelPack.set_samplerate`\n           :meth:`~channelpack.ChannelPack.add_condition`\n           :meth:`~channelpack.ChannelPack.pprint_conditions`\n\n        \"\"\"\n\n        self.conconf.set_condition('duration', rule)\n        if not self.no_auto:\n            self.make_mask()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclearing the conditions for the current object.", "response": "def clear_conditions(self, *conkeys, **noclear):\n        \"\"\"Clear conditions.\n\n        Clear only the conditions conkeys if specified. Clear only the\n        conditions not specified by conkeys if noclear is True (False\n        default).\n\n        .. note::\n           Updates the mask if not no_auto.\n        \"\"\"\n\n        offenders = set(conkeys) - set(self.conconf.conditions.keys())\n        if offenders:\n            raise KeyError(', '.join([off for off in offenders]))\n\n        # Valid keywords subtracted\n        offenders = set(noclear) - set({'noclear'})\n        if offenders:\n            raise KeyError(', '.join([off for off in offenders]))\n\n        noclear = noclear.get('noclear', False)\n\n        for ck in self.conconf.conditions:\n            if not conkeys:\n                # self.conconf.set_condition(ck, None)\n                self.conconf.reset()\n                break\n            elif not noclear and ck in conkeys:\n                self.conconf.set_condition(ck, None)\n            elif noclear and ck not in conkeys:\n                self.conconf.set_condition(ck, None)\n\n        if not self.no_auto:\n            self.make_mask()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_mask(self, clean=True, dry=False):\n\n        cc = self.conconf\n        # All True initially.\n        mask = np.ones(self.rec_cnt) == True  # NOQA\n        for cond in cc.conditions_list('cond'):\n            try:\n                mask = mask & self._mask_array(cond)\n            except Exception:\n                print cond\n                print 'produced an error:'\n                raise           # re-raise\n\n        mask = mask & datautils.startstop_bool(self)\n\n        samplerate = cc.get_condition('samplerate')\n        if samplerate is not None:\n            samplerate = float(samplerate)\n        mask = datautils.duration_bool(mask, cc.get_condition('duration'),\n                                       samplerate)\n\n        if dry:\n            return\n        if not clean and self.mask is not None:\n            self.mask = self.mask & mask\n        else:\n            self.mask = mask", "response": "Set the attribute self. mask to a mask based on the conditions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_channel_names(self, names):\n        if not names:\n            self.chnames = None\n            return\n\n        if len(names) != len(self.keys):\n            raise ValueError('len(names) != len(self.D.keys())')\n\n        self.chnames = dict(zip(self.keys, names))", "response": "Set self. chnames. Custom channel names that can be used in calls\n            on this object and in condition strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef counter(self, ch, part=None):\n        return Counter(self(self._key(ch), part=part))", "response": "Return a Counter object on the channel ch."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an iterator over the records in the pack.", "response": "def records(self, part=None, fallback=True):\n        \"\"\"Return an iterator over the records in the pack.\n\n        Each record is supplied as a namedtuple with the channel names\n        as field names. This is useful if each record make a meaningful\n        data set on its own.\n\n        part: int or None\n            Same meaning as in\n            :meth:`~channelpack.ChannelPack.__call__`.\n\n        fallback: boolean\n            The named tuple requires python-valid naming. If fallback is\n            False, there will be an error if ``self.chnames`` is not\n            valid names and not None. If True, fall back to the\n            ``self.chnames_0`` on error.\n\n        .. note:: The error produced on invalid names if fallback is\n           False is not produced until iteration start. Here is a good\n           post on stack overflow on the subject `231767\n           <http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python>`_\n\n        \"\"\"\n\n        names_0 = [self.chnames_0[k] for k in sorted(self.chnames_0.keys())]\n        if self.chnames is not None:\n            names = [self.chnames[k] for k in sorted(self.chnames.keys())]\n\n        try:\n            Record = namedtuple('Record', names)\n        except NameError:       # no names\n            Record = namedtuple('Record', names_0)\n            names = names_0\n        except ValueError:      # no good names\n            if fallback:\n                Record = namedtuple('Record', names_0)\n                names = names_0\n            else:\n                raise\n\n        for tup in zip(*[self(name, part) for name in names]):\n            yield Record(*tup)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _key(self, ch):\n\n        if ch in self.D:\n            return ch\n\n        if isinstance(ch, int):\n            raise KeyError(ch)  # dont accept integers as custom names\n\n        if self.chnames:\n            for item in self.chnames.items():\n                if item[1] == ch:\n                    return item[0]\n        for item in self.chnames_0.items():\n            if item[1] == ch:\n                return item[0]\n\n        # If we got here, ch can be an int represented by a string if it comes\n        # from a condition string:\n        try:\n            chint = int(ch)\n            if chint in self.D:\n                return chint\n        except ValueError:\n            pass\n\n        raise KeyError(ch)", "response": "Return the integer key for ch."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef name(self, ch, firstwordonly=False):\n\n        names = self.chnames or self.chnames_0\n        i = self._key(ch)\n\n        if not firstwordonly:\n            return names[i]\n        elif firstwordonly is True or firstwordonly == 1:\n            return names[i].split()[0].strip()\n\n        # According to user pattern\n        return re.findall(firstwordonly, names[i])[0]", "response": "Return the name of the current channel."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef query_names(self, pat):\n\n        for item in self.chnames.items():\n            if fnmatch.fnmatchcase(item[1], pat):\n                print item", "response": "Print the chnames of the user whose name matches pat. See fnmatch. fnmatchcase."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_basefilemtime(self):\n\n        dirpath = os.path.split(self.filename)[0]\n        name = os.path.basename(self.fs).split('.')[0]\n        for ext in ORIGINEXTENSIONS:  # This should be some user configuration.\n            res = glob.glob(dirpath + '/' + name + '.' + ext)\n            if res:             # Assume first match is valid.\n                # If some shell patterns will be used later\n                self.mtimefs = os.path.normpath(res[0])\n                # Time stamp string:\n                self.mtimestamp = time.ctime(os.path.getmtime(self.mtimefs))\n                break\n        else:\n            self.mtimefs = self.filename\n            self.mtimestamp = time.ctime(os.path.getmtime(self.mtimefs))", "response": "Set the attributes mtimestamp and mtimefs based on the file name and extension."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets condition conkey to value val. Convert val to str", "response": "def set_condition(self, conkey, val):\n        \"\"\"Set condition conkey to value val. Convert val to str if not\n        None.\n\n        conkey: str\n            A valid condition key.\n\n        val: str, int, float, None\n            Can always be None. Can be number or string depending on conkey.\n        \"\"\"\n\n        if not any([conkey.startswith(c) for c in _COND_PREFIXES]):\n            raise KeyError(conkey)\n\n        if val in NONES:\n            self.conditions[conkey] = None\n        else:\n            self.conditions[conkey] = str(val)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef spit_config(self, conf_file, firstwordonly=False):\n\n        cfg = ConfigParser.RawConfigParser()\n        for sec in _CONFIG_SECS:\n            cfg.add_section(sec)\n\n        sec = 'channels'\n        for i in sorted(self.pack.D):\n            cfg.set(sec, str(i),\n                    self.pack.name(i, firstwordonly=firstwordonly))\n\n        sec = 'conditions'\n        for k in self.sorted_conkeys():\n            cfg.set(sec, k, self.conditions[k])\n\n        cfg.write(conf_file)", "response": "write the config file to the spit file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the config file and updates the packs channel names and conditions accordingly.", "response": "def eat_config(self, conf_file):\n        \"\"\"conf_file a file opened for reading.\n\n        Update the packs channel names and the conditions, accordingly.\n\n        \"\"\"\n\n        # Read the file:\n        cfg = ConfigParser.RawConfigParser()\n        cfg.readfp(conf_file)\n\n        # Update channel names:\n        sec = 'channels'\n        mess = 'missmatch of channel keys'\n        assert(set(self.pack.D.keys()) == set([int(i) for i in cfg.options(sec)])), mess  # NOQA\n        if not self.pack.chnames:\n            self.pack.chnames = dict(self.pack.chnames_0)\n        for i in cfg.options(sec):  # i is a string.\n            self.pack.chnames[self.pack._key(int(i))] = cfg.get(sec, i)\n\n        # Update conditions:\n        sec = 'conditions'\n\n        # conkeys = set(self.conditions.keys())\n        # conops = set(cfg.options(sec))\n\n        # This check should be superfluous:\n        # --------------------------------------------------\n        # for conkey in conkeys:\n        #     if not any([conkey.startswith(c) for c in _COND_PREFIXES]):\n        #         raise KeyError(conkey)\n        # --------------------------------------------------\n\n        # for con in conkeys - conops: # Removed conditions.\n        # self.set_condition(con, None)\n        conops = cfg.options(sec)\n        self.reset()            # Scary\n        for con in conops:\n            self.set_condition(con, cfg.get(sec, con))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef conditions_list(self, conkey):\n        L = []\n        keys = [k for k in self.conditions if k.startswith(conkey)]  # sloppy\n        if not keys:\n            raise KeyError(conkey)\n        for k in keys:\n            if self.conditions[k] is None:\n                continue\n            raw = self.conditions[k]\n            L.append(raw)\n\n        return L", "response": "Return a list of conditions based on a specific conkey."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cond_int(self, conkey):\n\n        m = re.match(self.numrx, conkey)\n        if not m:\n            return conkey\n        return int(m.group(1))", "response": "Return the trailing number from cond if any as an int."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef valid_conkey(self, conkey):\n\n        for prefix in _COND_PREFIXES:\n            trailing = conkey.lstrip(prefix)\n            if trailing == '' and conkey:  # conkey is not empty\n                return True\n            try:\n                int(trailing)\n                return True\n            except ValueError:\n                pass\n\n        return False", "response": "Check that the conkey is a valid one. Return True if valid False if not."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef next_conkey(self, conkey):\n\n        if conkey in self.conditions:\n            return conkey       # Explicit conkey\n\n        conkeys = self.sorted_conkeys(prefix=conkey)  # Might be empty.\n        if not conkeys:\n            # A trailing number given that does not already exist.\n            # accept possible gap from previous number.\n            return conkey\n        for candidate in conkeys:\n            if self.conditions[candidate] is None:\n                return candidate\n\n        i = self.cond_int(candidate)  # The last one.\n        return re.sub(r'\\d+', str(i + 1), candidate)", "response": "Return the next conkey based on conkey as a\n        string."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns all condition keys in self. conditions as a list sorted suitable for print or write to a file.", "response": "def sorted_conkeys(self, prefix=None):\n        \"\"\"Return all condition keys in self.conditions as a list sorted\n        suitable for print or write to a file. If prefix is given return\n        only the ones prefixed with prefix.\"\"\"\n\n        # Make for defined and sorted output:\n        conkeys = []\n        for cond in _COND_PREFIXES:\n            conkeys += sorted([key for key in self.conditions\n                               if key.startswith(cond)], key=self.cond_int)\n        if not prefix:\n            return conkeys\n        return [key for key in conkeys if key.startswith(prefix)]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if a list or array contains ordinal data.", "response": "def isordinal(x):\n    \"\"\"Checks if a list or array contains ordinal data.\n\n    Warning:\n    --------\n    This is not a reliable check for a variable being\n    ordinal.\n\n    The following criteria are used\n\n    - There are more observations than unique values.\n        Why? Ordinal means discrete or countable and\n        I just assume that an ordinal sample should\n        have some recurring (countable) values.\n    - Values are integers or strings.\n        Why? Ordinal scale data are usually labels\n        (e.g. strings) or are encoded labels (e.g.\n        as integers).\n    - Ordinal scale data is sortable\n        Integers imply that the Analyst encoded the\n        labels according to the ordinal data's \"natural\n        order\". Strings would imply that the alphabetic\n        order would be the natual order (what is usually\n        not the case)\n\n    Usage:\n    ------\n        obs = 10\n        np.random.seed(42)\n        x1 = np.random.randint(1,50, (obs,))\n        x2 = np.random.randint(0,3, (obs,))\n        x3 = np.random.uniform(0,3, (obs,))\n\n        flag, msg = isordinal(x1)\n        if not flag:\n            warnings.warn(msg)\n    \"\"\"\n    import numpy as np\n\n    if len(x) == len(np.unique(x)):\n        return False, (\"number of observations equals the \"\n                       \"number of unique values.\")\n\n    if not isinstance(x[0], str):\n        if not np.all(np.equal(np.mod(x, 1), 0)):\n            return False, \"elements are not integer or strings.\"\n\n    return True, \"is ordinal\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve a value from its key.", "response": "def get(self, key, default=NoDefault):\n        \"\"\"Retrieve a value from its key.\n\n        Retrieval steps are:\n        1) Normalize the key\n        2) For each option group:\n           a) Retrieve the value at that key\n           b) If no value exists, continue\n           c) If the value is an instance of 'Default', continue\n           d) Otherwise, return the value\n        3) If no option had a non-default value for the key, return the\n            first Default() option for the key (or :arg:`default`).\n        \"\"\"\n        key = normalize_key(key)\n        if default is NoDefault:\n            defaults = []\n        else:\n            defaults = [default]\n\n        for options in self.options:\n            try:\n                value = options[key]\n            except KeyError:\n                continue\n\n            if isinstance(value, Default):\n                defaults.append(value.value)\n                continue\n            else:\n                return value\n\n        if defaults:\n            return defaults[0]\n\n        return NoDefault"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_all_children(self, include_self=False):\n        ownership = Ownership.objects.filter(parent=self)\n        subsidiaries = Company.objects.filter(child__in=ownership)\n        for sub in subsidiaries:\n            subsidiaries = subsidiaries | sub.get_all_children()\n\n        if include_self is True:\n            self_company = Company.objects.filter(id=self.id)\n            subsidiaries = subsidiaries | self_company\n\n        return subsidiaries", "response": "Get all subsidiaries of this company."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting all parents of this company.", "response": "def get_all_parents(self):\n        \"\"\"\n        Return all parents of this company.\n        \"\"\"\n        ownership = Ownership.objects.filter(child=self)\n        parents = Company.objects.filter(parent__in=ownership)\n        for parent in parents:\n            parents = parents | parent.get_all_parents()\n        return parents"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget all the related companies of this company.", "response": "def get_all_related_companies(self, include_self=False):\n        \"\"\"\n        Return all parents and subsidiaries of the company\n        Include the company if include_self = True\n        \"\"\"\n        parents = self.get_all_parents()\n        subsidiaries = self.get_all_children()\n        related_companies = parents | subsidiaries\n\n        if include_self is True:\n            company_qs = Company.objects.filter(id=self.id)\n            related_companies = related_companies | company_qs\n\n        related_companies_ids = [company.id for company in list(set(related_companies))]\n        related_companies = Company.objects.filter(id__in=related_companies_ids)\n\n        return related_companies"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn all direct subsidiaries of this company AS OWNERSHIP OBJECTS.", "response": "def get_immediate_children_ownership(self):\n        \"\"\"\n        Return all direct subsidiaries of this company AS OWNERSHIP OBJECTS.\n        Excludes subsidiaries of subsidiaries.\n\n        \"\"\"\n        ownership = Ownership.objects.filter(parent=self).select_related('child', 'child__country')\n        return ownership"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all direct parents of this company. Excludes parents of parents of parents", "response": "def get_immediate_parents(self):\n        \"\"\"\n        Return all direct parents of this company. Excludes parents of parents\n        \"\"\"\n        ownership = Ownership.objects.filter(child=self)\n        parents = Company.objects.filter(parent__in=ownership).distinct()\n        return parents"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_directors(self):\n        directors = Director.objects.filter(company=self, is_current=True).select_related('person')\n        return directors", "response": "Return all directors for this company"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncaching some basic data such as financial statement metrics", "response": "def cache_data(self):\n        \"\"\"\n        Cache some basic data such as financial statement metrics\n        \"\"\"\n        # Set Slug if not set\n        if not self.slug_name:\n            self.slug_name = slugify(self.name).strip()\n            if len(self.slug_name) > 255:\n                self.slug_name = self.slug_name[0:254]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the name of a company on a given date. This takes into accounts and name changes that may have occurred.", "response": "def get_name_on_date(self, date):\n        \"\"\"\n        Get the name of a company on a given date. This takes into accounts and\n        name changes that may have occurred.\n        \"\"\"\n        if date is None:\n            return self.name\n\n        post_name_changes = CompanyNameChange.objects.filter(company=self,\n                                                             date__gte=date).order_by('date')\n        if post_name_changes.count() == 0:\n            return self.name\n        else:\n            return post_name_changes[0].name_before"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save(self, *args, **kwargs):\n\n        self.name = str(self.parent.name) + \"   -   \" + str(self.child.name) + \"  -  \" + str(self.ownership_type)\n\n        if self.amount > 100:\n            raise ValueError(\"Ownership amount cannot be more than 100%\")\n        elif self.amount < 0:\n            raise ValueError(\"Ownership amount cannot be less than 0%\")\n        else:\n            super(Ownership, self).save(*args, **kwargs)", "response": "Save the current object to the database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating board tenure in years", "response": "def tenure(self):\n        \"\"\"\n        Calculates board tenure in years\n        \"\"\"\n        if self.end_date:\n            return round((date.end_date - self.start_date).days / 365., 2)\n        else:\n            return round((date.today() - self.start_date).days / 365., 2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves the person model so it updates his number of board connections field.", "response": "def save(self, *args, **kwargs):\n        \"\"\"\n        Save the person model so it updates his/her number of board connections field.\n        Also updates name\n        \"\"\"\n\n        self.name = str(self.company.name) + \"   ---   \" + str(self.person)\n        super(Director, self).save(*args, **kwargs)  # Call the \"real\" save() method.\n        other_directors = Director.objects.filter(company=self.company)\n        for director in other_directors:\n            director.person.save()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_toc_tree(title, input, output, content_directory):\n\n    LOGGER.info(\"{0} | Building Sphinx documentation index '{1}' file!\".format(build_toc_tree.__name__,\n                                                                               output))\n    file = File(input)\n    file.cache()\n\n    existing_files = [foundations.strings.get_splitext_basename(item)\n                      for item in glob.glob(\"{0}/*{1}\".format(content_directory, FILES_EXTENSION))]\n    relative_directory = content_directory.replace(\"{0}/\".format(os.path.dirname(output)), \"\")\n\n    toc_tree = [\"\\n\"]\n    for line in file.content:\n        search = re.search(r\"`([a-zA-Z_ ]+)`_\", line)\n        if not search:\n            continue\n\n        item = search.groups()[0]\n        code = \"{0}{1}\".format(item[0].lower(), item.replace(\" \", \"\")[1:])\n        if code in existing_files:\n            link = \"{0}/{1}\".format(relative_directory, code)\n            data = \"{0}{1}{2} <{3}>\\n\".format(\" \", \" \" * line.index(\"-\"), item, link)\n            LOGGER.info(\"{0} | Adding '{1}' entry to Toc Tree!\".format(build_toc_tree.__name__,\n                                                                       data.replace(\"\\n\", \"\")))\n            toc_tree.append(data)\n    toc_tree.append(\"\\n\")\n\n    TOCTREE_TEMPLATE_BEGIN[0] = TOCTREE_TEMPLATE_BEGIN[0].format(title)\n    TOCTREE_TEMPLATE_BEGIN[1] = TOCTREE_TEMPLATE_BEGIN[1].format(\"=\" * len(TOCTREE_TEMPLATE_BEGIN[0]))\n    content = TOCTREE_TEMPLATE_BEGIN\n    content.extend(toc_tree)\n    content.extend(TOCTREE_TEMPLATE_END)\n\n    file = File(output)\n    file.content = content\n    file.write()\n\n    return True", "response": "Builds Sphinx documentation table of content tree file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_command_line_arguments():\n\n    parser = argparse.ArgumentParser(add_help=False)\n\n    parser.add_argument(\"-h\",\n                        \"--help\",\n                        action=\"help\",\n                        help=\"'Displays this help message and exit.'\")\n\n    parser.add_argument(\"-t\",\n                        \"--title\",\n                        type=unicode,\n                        dest=\"title\",\n                        help=\"'Package title.'\")\n\n    parser.add_argument(\"-i\",\n                        \"--input\",\n                        type=unicode,\n                        dest=\"input\",\n                        help=\"'Input file to convert.'\")\n\n    parser.add_argument(\"-o\",\n                        \"--output\",\n                        type=unicode,\n                        dest=\"output\",\n                        help=\"'Output file.'\")\n\n    parser.add_argument(\"-c\",\n                        \"--content_directory\",\n                        type=unicode,\n                        dest=\"content_directory\",\n                        help=\"'Content directory.'\")\n\n    if len(sys.argv) == 1:\n        parser.print_help()\n        sys.exit(1)\n\n    return parser.parse_args()", "response": "Retrieves command line arguments."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main():\n\n    args = get_command_line_arguments()\n    return build_toc_tree(args.title,\n                          args.input,\n                          args.output,\n                          args.content_directory)", "response": "Starts the Application.\n\n    :return: Definition success.\n    :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cipher (self, xl, xr, direction):\n        if direction == self.ENCRYPT:\n            for i in range (16):\n                xl = xl ^ self.p_boxes[i]\n                xr = self.__round_func (xl) ^ xr\n                xl, xr = xr, xl\n            xl, xr = xr, xl\n            xr = xr ^ self.p_boxes[16]\n            xl = xl ^ self.p_boxes[17]\n        else:\n            for i in range (17, 1, -1):\n                xl = xl ^ self.p_boxes[i]\n                xr = self.__round_func (xl) ^ xr\n                xl, xr = xr, xl\n            xl, xr = xr, xl\n            xr = xr ^ self.p_boxes[1]\n            xl = xl ^ self.p_boxes[0]\n        return xl, xr", "response": "This function encrypts the xl and xr with the other ones."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef initCTR(self, iv=0):\n        assert struct.calcsize(\"Q\") == self.blocksize()\n        self.ctr_iv = iv\n        self._calcCTRBUF()", "response": "Initializes the CTR mode of the cypher"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate one block of CTR keystream", "response": "def _calcCTRBUF(self):\n        \"\"\"Calculates one block of CTR keystream\"\"\"\n        self.ctr_cks = self.encrypt(struct.pack(\"Q\", self.ctr_iv)) # keystream block\n        self.ctr_iv += 1\n        self.ctr_pos = 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _nextCTRByte(self):\n        b = ord(self.ctr_cks[self.ctr_pos])\n        self.ctr_pos += 1\n        if self.ctr_pos >= len(self.ctr_cks):\n            self._calcCTRBUF()\n        return b", "response": "Returns one byte of CTR keystream"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef encryptCTR(self, data):\n        if type(data) != types.StringType:\n            raise RuntimeException(\"Can only work on 8-bit strings\")\n        result = []\n        for ch in data:\n            result.append(chr(ord(ch) ^ self._nextCTRByte()))\n        return \"\".join(result)", "response": "Encrypts a buffer of data with CTR mode."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the likelihoods of observing the actual number coauthors shared by p1 and p2", "response": "def coauthor_likelihoods(p1, p2):\n    \"\"\"returns the likelihoods of observing the actual number coauthors shared \n    by c{p1} and c{p2}, conditioned on whether or not p1 and p2 are a match\n    \"\"\"\n    def get_coauthors(p):\n        ret = set()\n        for m in p.mentions:\n            for co_m in article_to_mentions[m.article_id]:\n                if m != co_m:\n                    co_p = Agglomerator.MENTION_TO_CLUSTER[co_m]\n                    ret.add(co_p)\n        return ret\n\n    def num_common_coauthors(p1, p2):\n        return len(set.intersection(get_coauthors(p1), get_coauthors(p2)))\n\n    num_common = num_common_coauthors(p1, p2)\n    if num_common >= len(config.p_coauthor[0]):\n        num_common = len(config.p_coauthor[0]) - 1\n    likelihood0 = config.p_coauthor[0][num_common]\n    likelihood1 = config.p_coauthor[1][num_common]\n    \n    return likelihood1, likelihood0"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nattempts to populate an item s information with it s ID returns True if successful False otherwise", "response": "def populate(self, usr = None, itemID = None):\n        \"\"\" Attempts to populate an item's information with it's ID, returns result\n        \n        Note that the item id must already be set or otherwise supplied and that the item\n        must exist in the associated user's inventory. \n           \n        Parameters:\n           usr (User) -- User who has the item\n           itemID (str) -- The item's object ID\n           \n        Returns\n           bool - True if successful, false otherwise\n           \n        Raises\n           parseException\n        \"\"\"\n        if not self.id and not itemID:\n            return False\n            \n        if not self.usr and not user:\n            return False\n        \n        # Object's ID is used by default over any provided ID        \n        if self.id: itemID = self.id\n            \n        # Same with the user\n        if self.usr: usr = self.usr\n        \n        pg = usr.getPage(\"http://www.neopets.com/iteminfo.phtml?obj_id=\" + str(itemID), vars = {'Referer': 'http://www.neopets.com/objects.phtml?type=inventory'})\n        \n        # Verify valid ID\n        if \"not in your inventory\" in pg.content:\n            logging.getLogger(\"neolib.item\").exception(\"Invalid ID given, could not populate. ID: \" + itemID)\n            return False\n        \n        try:\n            self.img = pg.table.img['src']\n            self.name = pg.table.find_all(\"td\")[1].text.split(\" : \")[1].replace(\"Owner\", \"\")\n            self.desc = pg.find_all(\"div\", align=\"center\")[1].i.text\n            \n            stats = pg.table.next_sibling.table.find_all(\"td\")\n            \n            self.type = stats[1].text\n            self.weight = stats[3].text\n            self.rarity = stats[5].text\n            self.estVal = stats[7].text\n        except Exception:\n            logging.getLogger(\"neolib.item\").exception(\"Failed to parse item details.\", {'pg': pg})\n            raise parseException\n        \n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntransfers an item from user s inventory to another inventory.", "response": "def sendTo(self, loc, usr=None):\n        \"\"\" Transfer's an item from user's inventory to another inventory, returns result\n           \n        Parameters:\n           loc (str) -- Location to send the item to (see Item.SHOP, Item.SDB, etc.)\n           usr (User) -- User who has the item\n           \n        Returns\n           bool - True if successful, false otherwise\n        \"\"\"\n        if not loc in self._messages:\n            return False\n        if not self.usr and not usr:\n            return False\n        if self.usr: usr = self.usr\n        \n        # Request the item page first to look human\n        pg = usr.getPage(\"http://www.neopets.com/iteminfo.phtml?obj_id=\" + str(self.id))\n        \n        form = pg.form(name=\"item_form\")\n        form['action'] = loc\n        \n        pg = form.submit()\n        return self._messages[loc] in pg.content"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of optgroups for this widget.", "response": "def optgroups(self, name, value, attrs=None):\n        \"\"\"Return a list of optgroups for this widget.\"\"\"\n        default = (None, [], 0)\n        groups = [default]\n        # We must add at least one 'selected' option or widget will show nothing.\n        for v in value:\n            if not v:\n                continue\n            if hasattr(self.choices, 'queryset'):\n                item = self.choices.queryset.filter(id=v).first()\n                if item:\n                    label = item.name\n                else:\n                    label = force_text(v)\n            else:\n                label = force_text(v)\n            subgroup = default[1]\n            subgroup.append(self.create_option(\n                name, v, label, True, 0,\n                subindex=None, attrs=attrs,\n            ))\n        return groups"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates and analyze a new document", "response": "def post_document(self, data):\n    \"\"\"\n    Create and analyze a new document\n    data -- A Dictionary representing the new document\n    \"\"\"\n    data.update({ 'client' : CLIENT })\n    return self._call('POST', self._generate_url_path('documents'), data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmodifies the properties of an existing document", "response": "def put_document(self, signature, data):\n    \"\"\" \n    Modify the properties of an existing document\n    signature -- The signature for the desired document\n    data      -- A Dictionary with the new allowed value eg. {'allow': false}\n    \"\"\"\n    return self._call('PUT', self._generate_url_path('documents', signature), data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting more exhaustive statistics for the current user", "response": "def get_extended_stats(self, data):\n    \"\"\" \n    Get more exhaustive statistics for the current user\n    data -- A dictionary with the range of dates you want the stats for {'from': '2010/01/01', 'to': '2010/01/10'}\n    \"\"\"\n    return self._call('GET', self._generate_url_path('extended-stats') + '?' + self._urlencode(data))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _call(self, method, path, data=None):\n    if is_python3():\n      conn = http.client.HTTPConnection(API_HOST)\n    else:\n      conn = httplib.HTTPConnection(API_HOST)\n\n    headers = {'User-Agent' : USER_AGENT}\n\n    if data:\n      headers.update( {'Content-type': 'application/x-www-form-urlencoded'} )\n      conn.request(method, path, self._urlencode(data), headers)\n\n    else:\n      conn.request(method, path, None, headers)\n\n    response = conn.getresponse()\n    result   =  [response.status, self._parse_body(response.read())]\n    conn.close()\n    return result", "response": "Perform the actual HTTP request"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_body(self, body):\n    if is_python3():\n      return json.loads(body.decode('UTF-8'))\n    else:\n      return json.loads(body)", "response": "Parses the body of a response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_urls(self):\n        urls = super(CompetitionEntryAdmin, self).get_urls()\n        csv_urls = patterns('',\n            url(\n                r'^exportcsv/$',\n                self.admin_site.admin_view(self.csv_export),\n                name='competition-csv-export'\n            )\n        )\n        return csv_urls + urls", "response": "Extend the admin urls for the CompetitionEntryAdmin model\n            to be able to invoke a CSV export view on the admin model"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a CSV document of the competition entry and its userical details.", "response": "def csv_export(self, request):\n        \"\"\" Return a CSV document of the competition entry and its user\n            details\n        \"\"\"\n        response = HttpResponse(content_type='text/csv')\n        response['Content-Disposition'] = 'attachment; filename=competitionentries.csv'\n\n        # create the csv writer with the response as the output file\n        writer = UnicodeWriter(response)\n        writer.writerow([\n            'Competition ID', 'Competition', 'First Name', 'Last Name', 'Email Address',\n            'Cell Number', 'Question', 'Answer File', 'Answer Option', 'Answer Text',\n            'Has Correct Answer', 'Winner', 'Time Stamp'\n        ])\n\n        # This sucks big time. get_urls is cached upon first call, which means\n        # it has no concept of a filter currently being applied to the\n        # changelist. Grab the querystring from the referrer and re-use\n        # changelist API to apply the filtering for us.\n        try:\n            dc, qs = request.META.get('HTTP_REFERER', '').split('?')\n        except ValueError:\n            qs = ''\n        request.META['QUERY_STRING'] = qs\n        queryset = self.get_changelist(request)(\n            request, self.model, self.list_display, self.list_display_links,\n            self.list_filter, self.date_hierarchy, self.search_fields,\n            self.list_select_related, self.list_per_page,\n            self.list_max_show_all, self.list_editable, self\n        ).get_query_set(request)\n\n        # select_related is too slow, so cache for fast lookups. This will not\n        # scale indefinitely.\n        competition_map = {}\n        ids = queryset.distinct('competition').values_list(\n            'competition_id', flat=True\n        )\n        for obj in Competition.objects.filter(id__in=ids):\n            competition_map[obj.id] = obj\n\n        # Looking up individual members is too slow, so cache for fast\n        # lookups. This will not scale indefinitely.\n        member_mobile_number_map = {}\n        ids = queryset.distinct('user').values_list(\n            'user_id', flat=True\n        )\n        for di in Member.objects.filter(id__in=ids).values(\n            'id', 'mobile_number'\n            ):\n            member_mobile_number_map[di['id']] = di['mobile_number']\n\n        for entry in queryset:\n            competition = competition_map[entry.competition_id]\n            entry.competition = competition\n            row = [\n                entry.competition.id,\n                entry.competition.title,\n                entry.user.first_name, entry.user.last_name,\n                entry.user.email,\n                member_mobile_number_map.get(entry.user_id, ''),\n                entry.competition.question,\n                entry.answer_file.name if entry.answer_file else '',\n                entry.answer_option.text if entry.answer_option else '',\n                entry.answer_text,\n                entry.has_correct_answer(),\n                entry.winner,\n                entry.timestamp\n            ]\n            writer.writerow(['' if f is None else unicode(f) for f in row])  # '' instead of None\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of all the files contained in the folder specified by folderpath.", "response": "def filelist(folderpath, ext=None):\n    '''\n    Returns a list of all the files contained in the folder specified by `folderpath`.\n    To filter the files by extension simply add a list containing all the extension with `.` as the second argument.\n    If `flat` is False, then the Path objects are returned.\n    '''\n    if not ext:\n        ext = []\n    if os.path.exists(folderpath) and os.path.isdir(folderpath):\n        return [ os.path.join(folderpath, f) for f in os.listdir(folderpath) if os.path.isfile(os.path.join(folderpath, f)) and os.path.splitext(f)[1] in ext ]\n    else:\n        log.warn('\"{}\" does not exist or is not a directory'.format(folderpath))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef particles(category=None):\n    '''\n    Returns a dict containing old greek particles grouped by category.\n    '''\n    filepath = os.path.join(os.path.dirname(__file__), './particles.json')\n    with open(filepath) as f:\n        try:\n            particles = json.load(f)\n        except ValueError as e:\n            log.error('Bad json format in \"{}\"'.format(filepath))\n        else:\n            if category:\n                if category in particles:\n                    return particles[category]\n                else:\n                    log.warn('Category \"{}\" not contained in particle dictionary!'.format(category))\n            return particles", "response": "Returns a dict containing old greek particles grouped by category."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parts():\n    '''\n    Returns the dictionary with the part as key and the contained book as indices.\n    '''\n    parts = {\n        'Canon': [ _ for _  in range(1, 5) ],\n        'Apostle': [ 5 ],\n        'Paul': [ _ for _ in range(6, 19) ],\n        'General': [ _ for _ in range(19, 26) ],\n        'Apocalypse': [ 27 ]\n    }\n    return parts", "response": "Returns the dictionary with the part as key and the contained book as indices."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef component_activated(self, component):\n        component.env = self\n        super(Environment, self).component_activated(component)", "response": "Initialize additional member variables for components."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninterpreting a message and populate the internal list.", "response": "def interpret(self, msg):\n        \"\"\" Create a slide show \"\"\"\n\n        self.captions = msg.get('captions', '.')\n        \n        for item in msg['slides']:\n            self.add(item)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the duration of the slide", "response": "def set_duration(self, duration):\n        \"\"\" Calculate how long each slide should show \"\"\"\n        fixed = sum(int(x.get('time', 0)) for x in self.slides)\n\n        nfixed = len([x for x in self.slides if x.get('time', 0) > 0])\n\n        unfixed = len(self.slides) - nfixed\n\n        self.wait = max(1, int(duration / unfixed))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines how many sequences there are in a file", "response": "def num_sequences(fileh):\n  \"\"\"\n    Determine how many sequences there are in fasta file/stream.\n\n    :param fileh: the stream to read the fasta data from, or a string giving\n                  the filename of the file to load. Note that if a stream is\n                  given, it will be consumed by this function\n    :return: the number of sequences in this fasta stream/file\n  \"\"\"\n  if type(fileh).__name__ == \"str\":\n    fh = open(fileh)\n  else:\n    fh = fileh\n  count = 0\n  for _ in fastaIterator(fh):\n    count += 1\n  return count"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the next seq header from a filehandle or stream.", "response": "def __read_seq_header(fh, prev_line):\n  \"\"\"\n  Given a file handle/stream, read the next fasta header from that stream.\n\n  :param fh:         filehandle to read from\n  :param prev_line:  the previous line read from this filestream\n  \"\"\"\n  seq_header = \"\"\n  if prev_line is not None and not _isSequenceHead(prev_line):\n    raise FastaFileFormatError(\"terminated on non-read header: \" + prev_line)\n  if prev_line is None:\n    while seq_header.strip() == \"\":\n      seq_header = fh.readline()\n  else:\n    seq_header = prev_line\n  return seq_header"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread the sequence data from the file and returns the last line that was read from the file handle or stream", "response": "def __read_seq_data(fh):\n  \"\"\"\n  :return: a tuple of the sequence data and the last line that was read from\n           the file handle/stream\n  \"\"\"\n  line = None\n  seq_data = \"\"\n  while line is None or not _isSequenceHead(line):\n    line = fh.readline()\n    if line == \"\":\n      break  # file is finished...\n    if not _isSequenceHead(line):\n      seq_data += line.strip()\n  return seq_data, line"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dbsafe_encode(value, compress_object=False):\n    if not compress_object:\n        value = b64encode(dumps(deepcopy(value)))\n    else:\n        value = b64encode(compress(dumps(deepcopy(value))))\n    return PickledObject(value)", "response": "Encode a value for use in a DBS safe way."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the default value for this field.", "response": "def get_default(self):\n        \"\"\"\n        Returns the default value for this field.\n\n        The default implementation on models.Field calls force_unicode\n        on the default, which means you can't set arbitrary Python\n        objects as the default. To fix this, we just return the value\n        without calling force_unicode on it. Note that if you set a\n        callable as a default, the field will still call it. It will\n        *not* try to pickle and encode it.\n\n        \"\"\"\n        if self.has_default():\n            if callable(self.default):\n                return self.default()\n            return self.default\n            # If the field doesn't have a default, then we punt to models.Field.\n        return super(PickledObjectField, self).get_default()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_python(self, value):\n        if value is not None:\n            try:\n                value = dbsafe_decode(value, self.compress)\n            except:\n                # If the value is a definite pickle; and an error is raised in\n                # de-pickling it should be allowed to propogate.\n                if isinstance(value, PickledObject):\n                    raise\n        return value", "response": "Convert the value to a Python value."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprepares the value for the database.", "response": "def get_db_prep_value(self, value):\n        \"\"\"\n        Pickle and b64encode the object, optionally compressing it.\n\n        The pickling protocol is specified explicitly (by default 2),\n        rather than as -1 or HIGHEST_PROTOCOL, because we don't want the\n        protocol to change over time. If it did, ``exact`` and ``in``\n        lookups would likely fail, since pickle would now be generating\n        a different string.\n\n        \"\"\"\n        if value is not None and not isinstance(value, PickledObject):\n            # We call force_unicode here explicitly, so that the encoded string\n            # isn't rejected by the postgresql_psycopg2 backend. Alternatively,\n            # we could have just registered PickledObject with the psycopg\n            # marshaller (telling it to store it like it would a string), but\n            # since both of these methods result in the same value being stored,\n            # doing things this way is much easier.\n            value = force_unicode(dbsafe_encode(value, self.compress))\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the next comment found in text starting at start.", "response": "def nextComment(self, text, start=0):\n        \"\"\"Return the next comment found in text starting at start.\n\n        \"\"\"\n\n        m = min([self.lineComment(text, start),\n                 self.blockComment(text, start),\n                 self._emptylineregex.search(text, start)],\n                key=lambda m: m.start(0) if m else len(text))\n        return m"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn true if the text is a line comment.", "response": "def isLineComment(self, text):\n        \"\"\"Return true if the text is a line comment.\n\n        \"\"\"\n\n        m = self.lineComment(text, 0)\n        return m and m.start(0) == 0 and m.end(0) == len(text)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef nextValidComment(self, text, start=0):\n\n        m = min([self.lineComment(text, start),\n                 self.blockComment(text, start)],\n                key=lambda m: m.start(0) if m else len(text))\n        return m", "response": "Return the next valid comment."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extractContent(self, text):\n\n        m = self.nextValidComment(text)\n        return '' if m is None else m.group(1)", "response": "Extract the content of the comment text."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef chunkComment(self, text, start=0):\n\n        # Build a list of comments\n        comm, out = self.nextComment(text, start), []\n        while comm:\n            out.append(comm.group(0))\n            comm = self.nextComment(text, comm.start(0) + 1)\n\n        # Collect the comments according to whether they are line\n        # comments or block comments.\n        out = [list(g) for (_, g) in groupby(out, self.isLineComment)]\n\n        # Filter out seperator lines.\n        out = [i for i in out if i != ['']]\n\n        return out", "response": "Return a list of chunks of comments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of comments.", "response": "def comments(self, text, start=0):\n        \"\"\"Return a list of comments.\n\n        \"\"\"\n\n        out = [self.extractChunkContent(s)\n               for s in self.chunkComment(text, start)]\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the code instead of the comments.", "response": "def code(self, text):\n        \"\"\"Return the code instead of the comments.\n\n        \"\"\"\n\n        comm = self.nextValidComment(text)\n        while comm:\n            text = text[:comm.start()] + text[comm.end():]\n            comm = self.nextValidComment(text, comm.end(0))\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef each_cons(sequence, size):\n    return zip(*(islice(it, start, None)\n                 for start, it in enumerate(tee(sequence, size))))", "response": "Iterates lazily through a sequence looking at a sliding window\n    with given size for each time."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a generator that yields the elements from iterable slicing just before predicate is True", "response": "def slice_before(predicate, iterable):\n    \"\"\"Returns groups of elements from iterable,\n    slicing just before predicate(elem) is True\n    \"\"\"\n    if isinstance(predicate, string_type):\n        predicate = re.compile(predicate)\n\n    if hasattr(predicate, 'match'):\n        predicate = predicate.match\n\n    record = []\n\n    for i, item in enumerate(iterable):\n        if i == 0:\n            record = [item]\n            continue\n\n        if predicate(item):\n            yield tuple(record)\n            record = [item]\n        else:\n            record.append(item)\n\n    if record:\n        yield tuple(record)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a generator that yields the elements from iterable slicing just after predicate is True", "response": "def slice_after(predicate, iterable):\n    \"\"\"Returns groups of elements from iterable,\n    slicing just after predicate(elem) is True\n    \"\"\"\n    record = []\n    for i, item in enumerate(iterable):\n        record.append(item)\n\n        if predicate(item):\n            yield tuple(record)\n            record = []\n\n    if record:\n        yield tuple(record)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __chopStringDict(self, data):\n        '''Returns a dictionary of the provided raw service/host check string.'''\n\n        r = {}\n        d = data.split('\\t')\n\n        for item in d:\n            item_parts = item.split('::')\n            if len(item_parts) == 2:\n                (name, value) = item_parts\n            else:\n                name = item_parts[0]\n                value = item_parts[1]\n\n            name = self.__filter(name)\n            r[name] = value\n\n        if \"hostperfdata\" in r:\n            r[\"type\"] = \"hostcheck\"\n            r[\"perfdata\"] = r[\"hostperfdata\"]\n            r[\"checkcommand\"] = re.search(\"(.*?)!\\(?.*\", r[\"hostcheckcommand\"]).group(1)\n            r[\"name\"] = \"hostcheck\"\n        else:\n            r[\"type\"] = \"servicecheck\"\n            r[\"perfdata\"] = r[\"serviceperfdata\"]\n            r[\"checkcommand\"] = re.search(\"((.*)(?=\\!)|(.*))\", r[\"servicecheckcommand\"]).group(1)\n            r[\"name\"] = self.__filter(r[\"servicedesc\"])\n\n        r[\"hostname\"] = self.replacePeriod(self.__filter(r[\"hostname\"]))\n\n        return r", "response": "Returns a dictionary of the provided raw service / host check string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfiltering out problematic characters.", "response": "def __filter(self, name):\n        '''Filter out problematic characters.\n\n        This should become a separate module allowing the user to define filter rules\n        from a bootstrap file and most likely become a separate module.\n        '''\n\n        name = name.replace(\"'\", '')\n        name = name.replace('\"', '')\n        name = name.replace('!(null)', '')\n        name = name.replace(\" \", \"_\")\n        name = name.replace(\"/\", \"_\")\n        name = name.replace(\".\", \"_\")\n        return name.lower()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef smartupgrade(self, restart=True, dependencies=False, prerelease=False):\n        if not self.check():\n            if self.verbose:\n                print(\"Package {} already up-to-date!\".format(self.pkg))\n            return\n        if self.verbose:\n            print(\"Upgrading {} ...\".format(self.pkg))\n        self.upgrade(dependencies, prerelease, force=False)\n        if restart:\n            self.restart()", "response": "This method is used to upgrade the package if there is a later version available."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupgrading the package unconditionaly with pip.", "response": "def upgrade(self, dependencies=False, prerelease=False, force=False):\n        \"\"\"\n        Upgrade the package unconditionaly\n        Args:\n            dependencies: update package dependencies if True (see pip --no-deps)\n            prerelease: update to pre-release and development versions\n            force: reinstall all packages even if they are already up-to-date\n        Returns True if pip was sucessful\n        \"\"\"\n        pip_args = ['install', self.pkg]\n\n        found = self._get_current() != (-1)\n        if found:\n            pip_args.append(\"--upgrade\")\n\n        if force:\n            pip_args.append(\n                \"--force-reinstall\" if found else \"--ignore-installed\")\n\n        if not dependencies:\n            pip_args.append(\"--no-deps\")\n\n        if prerelease:\n            pip_args.append(\"--pre\")\n\n        proxy = os.environ.get('http_proxy')\n        if proxy:\n            pip_args.extend(['--proxy', proxy])\n\n        if self.__index:\n            pip_args.extend(['-i', self.index])\n\n        try:\n            ecode = pip.main(args=pip_args)\n        except TypeError:\n            # pip changed in 0.6.0 from initial_args to args, this is for backwards compatibility\n            # can be removed when pip 0.5 is no longer in use at all (approx.\n            # year 2025)\n            ecode = pip.main(initial_args=pip_args)\n\n        if ecode != 0:\n            raise PIPError(ecode)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef restart(self):\n        if self.verbose:\n            print(\"Restarting {} {} ...\".format(sys.executable, sys.argv))\n        os.execl(sys.executable, *([sys.executable] + sys.argv))", "response": "Restart application with same args as it was started. Does not return."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bugzscout_app(environ, start_response):\n    try:\n        start_response('200 OK', [('content-type', 'text/html')])\n        return ['Hellow world!']\n    except Exception as ex:\n        # Set the description to a familiar string with the exception\n        # message. Add the stack trace to extra.\n        b.submit_error('An error occurred in MyApp: {0}'.format(ex.message),\n                       extra=traceback.extract_tb(*sys.exc_info()))\n\n        # Reraise the exception.\n        raise ex", "response": "Simple WSGI application that returns 200 OK response with Hellow\n    world! in the body."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes an API request to get the token", "response": "def _request(self, base_url, client_id, client_secret,\n                 parameters, **kwargs):\n        \"\"\"Make an API request to get the token\"\"\"\n        logging.debug('Getting an OAuth token for client \"%s\" with scope \"%s\"',\n                      client_id, parameters.get('scope'))\n        headers = {'Content-Type': 'application/x-www-form-urlencoded',\n                   'Accept': 'application/json'}\n\n        api = API(base_url,\n                  auth_username=client_id,\n                  auth_password=client_secret,\n                  **kwargs)\n        endpoint = api.auth.token\n\n        response = yield endpoint.post(body=urllib.urlencode(parameters),\n                                       request_timeout=60,\n                                       headers=headers)\n\n        logging.debug('Received token: %s', response.get('access_token'))\n        raise Return(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncaches the token request and use cached responses if available", "response": "def _cached_request(self, base_url, client_id, client_secret,\n                        parameters, **kwargs):\n        \"\"\"Cache the token request and use cached responses if available\"\"\"\n        key = (base_url, client_id, tuple(parameters.items()))\n        cached = self._cache.get(key, {})\n\n        if not cached.get('access_token') or self._expired(cached):\n            cached = yield self._request(base_url, client_id, client_secret,\n                                         parameters, **kwargs)\n            self._cache[key] = cached\n            # Purge cache when adding a new item so it doesn't grow too large\n            # It's assumed the cache size is small enough that it's OK to loop\n            # over the whole cache regularly. If not, could change this to\n            # just pop off the oldest one\n            self.purge_cache()\n\n        logging.debug('Using a cached token: %s', cached.get('access_token'))\n        raise Return(cached)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef purge_cache(self):\n        if len(self._cache) > self.max_cache_size:\n            items = sorted(self._cache.items(), key=lambda (k, v): v['expiry'])\n            self._cache = {k: v for k, v in items[self.max_cache_size:]\n                           if not self._expired(v)}", "response": "Purge expired cached tokens and oldest tokens if more than max_cache_size"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate the user agent and return it as a string.", "response": "def _create_user_agent(self):\n        \"\"\" Create the user agent and return it as a string. \"\"\"\n        user_agent = '{}/{} {}'.format(pyspacegdn.__title__,\n                                       pyspacegdn.__version__,\n                                       default_user_agent())\n        if self.client_name:\n            user_agent = '{}/{} {}'.format(self.client_name,\n                                           self.client_version, user_agent)\n        return user_agent"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload the appropriate configuration file for the given application name.", "response": "def load_configuration(app_name):\n    '''\n    creates a new configuration and loads the appropriate\n    files.\n    '''\n    if sys.prefix == '/usr':\n        conf_dir = '/etc'\n        share_dir = '/usr/share'\n    else:\n        conf_dir = os.path.join(sys.prefix, 'etc')\n        share_dir = os.path.join(sys.prefix, 'share')\n    # Step 1: try to locate pynlp.yml\n    yml_config = {}\n    for fname in [\n            '%s.yml'%(app_name,),\n            os.path.expanduser('~/.%s.yml'%(app_name,)),\n            os.path.join(conf_dir, '%s.yml'%(app_name,))]:\n        if os.path.exists(fname):\n            yml_config = yaml.load(open(fname))\n            break\n    try:\n        data_dir = yml_config['paths']['data_dir']\n    except KeyError:\n        try:\n            data_dir = os.environ[app_name.upper()]\n        except KeyError:\n            data_dir = os.path.join(share_dir, app_name)\n    return AppContext(yml_config, data_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve the config variable named path from the config file.", "response": "def get_config_var(self, path, env=None):\n        '''\n        retrieves the config variable named ``path`` from the config file.\n        Path elements that start with a $ are replaced with values from the\n        dict passed as ``env``\n        '''\n        if env is None:\n            env = {}\n        result = self.conf\n        for e in path.split('.'):\n            if e[0] == '$':\n                try:\n                    result = result[env[e[1:]]]\n                except KeyError as ex:\n                    try:\n                        result = result['.default']\n                    except KeyError:\n                        raise ex\n            else:\n                result = result[e]\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_base_wrappers(method='get', template_name='', predicates=(), wrappers=()):\n    wrappers += (preserve_view(MethodPredicate(method), *predicates),)\n\n    if template_name:\n        wrappers += (render_template(template_name),)\n\n    return wrappers", "response": "Get the base wrappers used by view_config."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef view_config(\n        method='get',\n        template_name='',\n        predicates=(),\n        wrappers=(),\n        base_wrappers_getter=get_base_wrappers,\n):\n    \"\"\" Creating Views applied some configurations\n    and store it to _wrapped attribute on each Views.\n\n    * _wrapped expects to be called by Controller\n      (subclasses of uiro.controller.BaseController)\n    * The original view will not be affected by this decorator.\n    \"\"\"\n    wrappers = base_wrappers_getter(method, template_name, predicates, wrappers)\n\n    def wrapper(view_callable):\n        def _wrapped(*args, **kwargs):\n            return reduce(\n                lambda a, b: b(a),\n                reversed(wrappers + (view_callable,))\n            )(*args, **kwargs)\n        view_callable._wrapped = _wrapped\n        view_callable._order = next(_counter)\n        return view_callable\n    return wrapper", "response": "Decorator for views that creates some configurations that are applied to each Controller."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef preserve_view(*predicates):\n    def wrapper(view_callable):\n        def _wrapped(self, request, context, *args, **kwargs):\n            if all([predicate(request, context) for predicate in predicates]):\n                return view_callable(self, request, context, *args, **kwargs)\n            else:\n                raise ViewNotMatched\n        return _wrapped\n    return wrapper", "response": "A decorator that ensures that a view is called only if the request was apposite."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render_template(template_name, template_getter=get_app_template):\n    def wrapper(func):\n        template = template_getter(template_name)\n\n        def _wraped(self, request, context, *args, **kwargs):\n            res = func(self, request, context, *args, **kwargs)\n            if isinstance(res, dict):\n                return template.render(**res)\n            else:\n                return res\n        return _wraped\n    return wrapper", "response": "Decorator to specify which template to use for Wrapped Views."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convert(amount, source, target='CZK', date=None, percent=0, valid_days_max=None):\n    if source.upper() == 'CZK':\n        czk = amount\n    else:\n        czk = amount * rate(source, date, valid_days_max=valid_days_max)\n    result = convert_to(target, czk, date, valid_days_max=valid_days_max)\n    return modified(result, percent)", "response": "converts amount + source to target in CZK"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert_to(target, amount, date=None, percent=0, valid_days_max=None):\n    if target.upper() == 'CZK':\n        result = amount\n    else:\n        result = amount / rate(target, date, valid_days_max=valid_days_max)\n    return modified(result, percent)", "response": "converts the amount in CZK into given currency"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef worse(src_amount, src_currency, target_amount_obtained, target_currency, date=None, valid_days_max=None):\n    calculated = convert(src_amount, src_currency, target=target_currency, date=date, valid_days_max=valid_days_max)\n    worse = calculated - target_amount_obtained\n    worse_src = convert(worse, target_currency, target=src_currency, date=date, valid_days_max=valid_days_max)\n    if src_amount:\n        return worse_src / src_amount * 100.0, worse_src, worse\n    elif not target_amount_obtained:\n        return 0.0, worse_src, worse\n    else:\n        return float('inf') if (target_amount_obtained < 0) else float('-inf'), worse_src, worse", "response": "calculate a difference between the calculated target amount and the amount you give as src_amount_obtained instead\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading a line from standard input stream and writes it to output stream and returns the line.", "response": "def prompt(self, prompt_msg=None, newline=False):\n        \"\"\" Writes prompt message to output stream and\n            reads line from standard input stream.\n\n            `prompt_msg`\n                Message to write.\n            `newline`\n                Append newline character to prompt message before writing.\n\n            Return string.\n            \"\"\"\n\n        if prompt_msg is not None:\n            self.write(prompt_msg, newline)\n\n        return self._input.readline().rstrip(os.linesep)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write(self, buf, newline=True):\n\n        buf = buf or ''\n\n        if newline:\n            buf += os.linesep\n\n        try:\n            self._output.write(buf)\n\n            if hasattr(self._output, 'flush'):\n                self._output.flush()\n\n        except IOError as exc:\n            if exc.errno != errno.EPIPE:  # silence EPIPE errors\n                raise", "response": "Writes buffer to output stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef success(self, buf, newline=True):\n\n        if self._colored:\n            buf = self.ESCAPE_GREEN + buf + self.ESCAPE_CLEAR\n\n        self.write(buf, newline)", "response": "Same as write but adds success coloring if enabled."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite a buffer to the error stream.", "response": "def error(self, buf, newline=True):\n        \"\"\" Similar to `write`, except it writes buffer to error stream.\n            If coloring enabled, adds error coloring.\n\n            `buf`\n                Data buffer to write.\n            `newline`\n                Append newline character to buffer before writing.\n            \"\"\"\n\n        buf = buf or ''\n\n        if self._colored:\n            buf = self.ESCAPE_RED + buf + self.ESCAPE_CLEAR\n        if newline:\n            buf += os.linesep\n\n        try:\n            self._error.write(buf)\n\n            if hasattr(self._error, 'flush'):\n                self._error.flush()\n\n        except IOError as exc:\n            if exc.errno != errno.EPIPE:  # silence EPIPE errors\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert(cls, **kwargsql):\n        filters = []\n        for k, v in kwargsql.items():\n            terms = k.split('__')\n            if terms[-1] in cls.KWARGQL_SUPPORTED_MONGO_OPS:\n                v = {\n                    '$' + terms[-1]: v\n                }\n                if terms[-1] == 'exists':\n                    v['$exists'] = bool(v['$exists'])\n                terms = terms[:-1]\n            elif terms[-1] in cls.KWARGSQL_REGEX_OPS:\n                config = cls.KWARGSQL_REGEX_OPS[terms[-1]]\n                pattern = '^{prefix}{pattern}{suffix}$'.format(\n                    prefix=config.get('prefix', ''),\n                    pattern=re.escape(v),\n                    suffix=config.get('suffix', '')\n                )\n                v = {\n                    '$regex': pattern,\n                    '$options': config.get('options', ''),\n                }\n                terms = terms[:-1]\n            k = '.'.join(terms)\n            filters.append({k: v})\n        if len(filters) == 0:\n            return {}\n        if len(filters) == 1:\n            return filters[0]\n        else:\n            return {\n                '$and': filters\n            }", "response": "Convert a dict of kwargsql to a filter that can be used in pymongo. collection. find"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef config_conf(obj):\n    \"Extracts the configuration of the underlying ConfigParser from obj\"\n    # If we ever want to add some default options this is where to do that\n    cfg = {}\n    for name in dir(obj):\n        if name in CONFIG_PARSER_CFG: # argument of ConfigParser\n            cfg[name] = getattr(obj, name)\n    return cfg", "response": "Extracts the configuration of the underlying ConfigParser from obj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npreventing the addition of any single hyphen multiple letter args", "response": "def add_gnu_argument(self, *args, **kwargs):\n    \"Prevent the addition of any single hyphen, multiple letter args\"\n\n    gnu_args = []\n\n    for arg in args:\n        # Fix if we have at least 3 chars where the first is a hyphen\n        # and the second is not a hyphen (e.g. -op becomes --op)\n        if len(arg) > 3 and arg[0] == '-' and arg[1] != '-':\n            gnu_args.append('-' + arg)\n        else:\n            gnu_args.append(arg)\n\n    argparse.ArgumentParser.add_argument(self, *gnu_args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_valid_user_by_email(email):\n    user = get_user(email)\n    if user:\n        if user.valid is False:\n            return Err(\"user not valid\")\n        return Ok(user)\n    return Err(\"user not exists\")", "response": "Get user instance by email"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef identify_vcs(repo_url, guess=False, repo_aliases=REPO_ALIASES):\n    repo_url = unicode(repo_url)\n\n    # Do basic alias check\n    vcs = identify_vcs_vs_alias(repo_url, guess=guess, repo_aliases=repo_aliases)\n    if vcs:\n        return vcs\n\n    # remove prefix and try again\n    no_prefix = ''.join(repo_url.split(\"//\")[1:])\n    vcs = identify_vcs_vs_alias(no_prefix, guess=guess, repo_aliases=repo_aliases)\n    if vcs:\n        return vcs\n\n    if guess:\n        if \"bitbucket\" in repo_url:\n            return \"hg\"\n\n    raise UnknownVCS", "response": "Identify the type of repo that repo_url represents."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetermine the hosting service of repo_url.", "response": "def identify_hosting_service(repo_url, hosting_services=HOSTING_SERVICES):\n    \"\"\"\n    Determines the hosting service of `repo_url`.\n    :param repo_url: Repo URL of unknown type.\n    :returns: Hosting service or raises UnknownHostingService exception.\n    \"\"\"\n    repo_url = unicode(repo_url)\n\n    for service in hosting_services:\n        if service in repo_url:\n            return service\n\n    raise UnknownHostingService"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dictionary representation of a WAT - DAREPO repository.", "response": "def watdarepo(repo_url, mode='d', guess=False, repo_aliases=REPO_ALIASES, hosting_services=HOSTING_SERVICES):\n    \"\"\"\n    Gets vcs and hosting service for repo_urls\n    :param repo_url: Repo URL of unknown type.\n    :param mode: Return dictionary (default) or object\n    :param guess: Whether or not to make guesses\n    :returns: Hosting service or raises UnknownHostingService exception.\n    \"\"\"\n\n    repo_url = unicode(repo_url)\n\n    # Set the repo_url\n    repo_data = {'repo_url': repo_url}\n\n    # Get the VCS type\n    try:\n        repo_data['vcs'] = identify_vcs(repo_url, repo_aliases=repo_aliases)\n    except UnknownVCS:\n        repo_data['vcs'] = None\n\n    # Get the hosting service\n    try:\n        repo_data['hosting_service'] = identify_hosting_service(repo_url, hosting_services=hosting_services)\n    except UnknownHostingService:\n        repo_data['hosting_service'] = None\n\n    # If mode is 'c' or 'o', return an object representation of data.\n    if mode in ('c', 'o'):\n        # Define the c/o response class\n        Repo = type(str('Repo'), (object,), repo_data)\n        # Return the c/o response object\n        return Repo()\n\n    # return dictionary representation of data.\n    return repo_data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate buildout. cfg file and create buildout. cfg file", "response": "def create(buildout_directory, buildout_extends):\n    \"\"\"Create buildout directory\n    \"\"\"\n    ##\n    # Resolve arguments\n    directory = get_buildout_directory(buildout_directory)\n    extends = get_buildout_extends(buildout_extends)\n\n    ##\n    # Create buildout directory\n    local('mkdir -p {0:s}'.format(directory))\n\n    ##\n    # Create buildout.cfg\n    filename = os.path.join(directory, 'buildout.cfg')\n    contents = \"\"\"\\\n[buildout]\nextends = {0:s}\n\"\"\".format(extends)\n\n    ##\n    # Write buildout.cfg\n    with NamedTemporaryFile() as output:\n        print(\"[localhost] create: {0:s}\".format(output.name))\n        output.write(contents)\n        output.flush()\n        local('cp {0:s} {1:s}'.format(output.name, filename))\n        local('chmod a+r {0:s}'.format(filename))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlook up the exception in error_dictionary and raises it.", "response": "def exception(self, ncode):\n        \"\"\"\n        Looks up the exception in error_dictionary and raises it.\n        Required arguments:\n        * ncode - Error numerical code.\n        \"\"\"\n        error = self.error_dictionary[ncode]\n        error_msg = self._buffer[self._index - 1].split(None, 3)[3]\n        exec('raise self.%s(\"%s: %s\")' % (error, error, error_msg))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef truncatechars(value,arg=50): \r\n    '''\r\n    Takes a string and truncates it to the requested amount, by inserting an ellipses into the middle.\r\n    ''' \r\n    arg = int(arg) \r\n    if arg < len(value): \r\n        half = (arg-3)/2 \r\n        return \"%s...%s\" % (value[:half],value[-half:]) \r\n    return value", "response": "Takes a string and truncates it to the requested amount."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute the logpdf of a multivariate Gaussian distribution with diagonal covariance at a given point x.", "response": "def logpdf_diagonal_gaussian(self, x, mean, cov):\n        '''\n        Compute logpdf of a multivariate Gaussian distribution with diagonal covariance at a given point x.\n        A multivariate Gaussian distribution with a diagonal covariance is equivalent\n        to a collection of independent Gaussian random variables.\n\n        x should be a sparse matrix. The logpdf will be computed for each row of x.\n        mean and cov should be given as 1D numpy arrays\n        mean[i] : mean of i-th variable\n        cov[i] : variance of i-th variable'''\n\n        n = x.shape[0]\n        dim = x.shape[1]\n        assert(dim == len(mean) and dim == len(cov))\n\n        # multiply each i-th column of x by (1/(2*sigma_i)), where sigma_i is sqrt of variance of i-th variable.\n        scaled_x = x.dot(self.diag(1./(2*np.sqrt(cov))) )\n        # multiply each i-th entry of mean by (1/(2*sigma_i))\n        scaled_mean = mean/(2*np.sqrt(cov))\n\n        # sum of pairwise squared Eulidean distances gives SUM[(x_i - mean_i)^2/(2*sigma_i^2)]\n        return -np.sum(np.log(np.sqrt(2*np.pi*cov))) - pairwise_distances(scaled_x, [scaled_mean], 'euclidean').flatten()**2"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef log_sum_exp(self,x, axis):\n        '''Compute the log of a sum of exponentials'''\n        x_max = np.max(x, axis=axis)\n        if axis == 1:\n            return x_max + np.log( np.sum(np.exp(x-x_max[:,np.newaxis]), axis=1) )\n        else:\n            return x_max + np.log( np.sum(np.exp(x-x_max), axis=0) )", "response": "Compute the log of a sum of exponentials"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef e(self, k, n, \u03c4, \u03c3):\n        d = self._dichalcogenide\n        at, \u0394, \u03bb = d.at, d.\u0394, d.\u03bb\n        sqrt = numpy.sqrt\n        \u03b1 = \u03c4 * \u03c3\n        return 0.5 * (\u03bb * \u03b1 + n * sqrt((2 * at * k)**2 + (\u0394 - \u03bb * \u03b1)**2))", "response": "Return the energy of a given band."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninverse energy - momentum relation.", "response": "def k(self, e, n, \u03c4, \u03c3):\n        \"\"\"Inverse energy-momentum relation.\n\n        :param e: Energy :math:`E`.\n        :type e: float\n\n        :param n: Band index :math:`n = \u00b11`.\n        :type n: int\n\n        :param \u03c4: Valley index :math:`\u03c4 = \u00b11`.\n        :type \u03c4: int\n\n        :param \u03c3: Spin index :math:`\u03c3 = \u00b11`.\n        :type \u03c3: int\n\n        :return: :math:`k(E)`\n        :rtype: float\n        \"\"\"\n        d = self._dichalcogenide\n        at, \u0394, \u03bb = d.at, d.\u0394, d.\u03bb\n        sqrt = numpy.sqrt\n\n        x = 2 * e * \u0394**-1\n        y = (\u03bb * \u0394**-1) * (1 - x)\n\n        return (at**-1) * (\u0394 / 2) * sqrt(x**2 + 2 * \u03c4 * \u03c3 * y - 1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the distance of the chemical potential base at the top of the upper valence band.", "response": "def \u0394\u03bc(self):\n        \"\"\"Chemical potential offset.\n\n        The distance of the chemical potential\n        from the top of the upper valence band.\n\n        :return: :math:`\u0394\u03bc`\n        :rtype: float\n        :default: :math:`-\u03bb`\n        \"\"\"\n        if not hasattr(self, '_\u0394\u03bc'): self.\u0394\u03bc = -self._dichalcogenide.\u03bb\n        return self._\u0394\u03bc"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef \u03be_bounds(self):\n        \u03bb, \u0394\u03bc = self._dichalcogenide.\u03bb, self.\u0394\u03bc\n        return (abs(\u0394\u03bc) - 2 * \u03bb, abs(\u0394\u03bc))", "response": "Allowed range for the variable"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the trigonometric function of the energy.", "response": "def trig(self, name):\n        \"\"\"Trigonometric functions of the energy.\n\n        * ``sin \u03b8``       - :math:`\\\\sin \u03b8(E)`\n        * ``cos \u03b8``       - :math:`\\\\cos \u03b8(E)`\n        * ``sin^2 \u03b8/2``   - :math:`\\\\sin^2 \\\\frac{\u03b8(E)}{2}`\n        * ``cos^2 \u03b8/2``   - :math:`\\\\cos^2 \\\\frac{\u03b8(E)}{2}`\n\n        :param name: One of the above function names.\n        :type name: str\n\n        :return: Corresponding function of the energy :math:`E`.\n        :rtype: function\n        \"\"\"\n        fn = {}\n        \u03bb, \u0394 = self._dichalcogenide.\u03bb, self._dichalcogenide.\u0394\n        sqrt = numpy.sqrt\n        x = lambda e: (2 * e - \u03bb)**(-1)\n\n        fn['sin \u03b8'] = lambda e: sqrt((2 * e - \u0394) * (2 * e + \u0394 - 2 * \u03bb)) * x(e)\n        fn['cos \u03b8'] = lambda e: (\u0394 - \u03bb) * x(e)\n        fn['sin^2 \u03b8/2'] = lambda e: (e - \u0394 / 2) * x(e)\n        fn['cos^2 \u03b8/2'] = lambda e: (e + \u0394 / 2 - \u03bb) * x(e)\n\n        return fn[name]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextends a prefixed uri with the help of a specific dictionary of prefixes", "response": "def __extend_uri(prefixes, short):\n    \"\"\"\n    Extend a prefixed uri with the help of a specific dictionary of prefixes\n    :param prefixes: Dictionary of prefixes\n    :param short: Prefixed uri to be extended\n    :return:\n    \"\"\"\n    for prefix in prefixes:\n        if short.startswith(prefix):\n            return short.replace(prefix + ':', prefixes[prefix])\n    return short"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting patterns and spaces from the plan graph.", "response": "def __extract_patterns_and_spaces(self):\n        \"\"\"\n        Analyses the search plan graph in order to build the required data structures from patterns\n        and spaces.\n        :return:\n        \"\"\"\n\n        def __decorate_nodes(nodes, space):\n            \"\"\"\n            Performs a backward search from a list of pattern nodes and assigns a set of search spaces\n            to all encountered nodes.\n            :param nodes: List of pattern nodes that belongs to a search space\n            :param space: List of  search space id\n            :return:\n            \"\"\"\n            for n in nodes:\n                if n not in self.__node_spaces:\n                    self.__node_spaces[n] = set([])\n                self.__node_spaces[n].add(space)\n                pred_nodes = self.__plan_graph.subjects(AGORA.next, n)\n                __decorate_nodes(pred_nodes, space)\n\n        # Extract all search spaces in the plan and build a dictionary of subjects-to-ignore per each of them.\n        # Ignored subjects are those that won't be dereferenced due to a explicit graph pattern (object) filter,\n        # e.g. ?s doap:name \"jenkins\" -> All ?s that don't match the filter will be ignored.\n        self.__spaces = set(self.__plan_graph.subjects(RDF.type, AGORA.SearchSpace))\n        self.__subjects_to_ignore = dict([(sp, set([])) for sp in self.__spaces])\n\n        patterns = list(self.__plan_graph.subjects(RDF.type, AGORA.TriplePattern))\n        for tp in patterns:\n            # A triple pattern belongs to a UNIQUE search space\n            space = list(self.__plan_graph.subjects(AGORA.definedBy, tp)).pop()\n            self.__patterns[tp] = {'space': space}\n\n            # Depending on the format of each triple pattern (either '?s a Concept' or '?s prop O'),\n            # it is required to extract different properties.\n            tp_pred = list(self.__plan_graph.objects(tp, predicate=AGORA.predicate)).pop()\n\n            if tp_pred == RDF.type:  # ?s a Concept\n                self.__patterns[tp]['type'] = list(self.__plan_graph.objects(tp, predicate=AGORA.object)).pop()\n                try:\n                    check_type = list(self.__plan_graph.objects(tp, predicate=AGORA.checkType)).pop().toPython()\n                except IndexError:\n                    check_type = True\n                self.__patterns[tp]['check'] = check_type\n            else:  # ?s prop O\n                self.__patterns[tp]['property'] = tp_pred\n                tp_obj = list(self.__plan_graph.objects(tp, predicate=AGORA.object)).pop()\n                if (tp_obj, RDF.type, AGORA.Literal) in self.__plan_graph:  # In case O is a Literal\n                    self.__patterns[tp]['filter_object'] = list(self.__plan_graph.objects(tp_obj, AGORA.value)).pop()\n                elif isinstance(tp_obj, URIRef):\n                    self.__patterns[tp]['filter_object'] = tp_obj\n\n                tp_sub = list(self.__plan_graph.objects(tp, predicate=AGORA.subject)).pop()\n                if isinstance(tp_sub, URIRef):\n                    self.__patterns[tp]['filter_subject'] = tp_sub\n\n            # Get all pattern nodes (those that have a byPattern properties) of the search plan and search backwards\n            # in order to set the scope of each search space.\n            nodes = list(self.__plan_graph.subjects(AGORA.byPattern, tp))\n            for n in nodes:\n                if n not in self.__node_patterns:\n                    self.__node_patterns[n] = set([])\n                self.__node_patterns[n].add(tp)\n            __decorate_nodes(nodes, space)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_fragment(self, **kwargs):\n        gen, namespaces, plan = self.get_fragment_generator(**kwargs)\n        graph = ConjunctiveGraph()\n        [graph.bind(prefix, u) for (prefix, u) in namespaces]\n        [graph.add((s, p, o)) for (_, s, p, o) in gen]\n\n        return graph", "response": "Return a complete fragment."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a generator that executes the search plan.", "response": "def get_fragment_generator(self, on_load=None, on_seeds=None, on_plink=None, on_link=None, on_type=None,\n                               on_type_validation=None, on_tree=None, workers=None, stop_event=None, queue_wait=None,\n                               queue_size=100, provider=None, lazy=True):\n        \"\"\"\n        Create a fragment generator that executes the search plan.\n        :param on_load: Function to be called just after a new URI is dereferenced\n        :param on_seeds: Function to be called just after a seed of a tree is identified\n        :param on_plink: Function to be called when a pattern link is reached\n        :param on_link: Function to be called when following a property that is not of a pattern\n        :param on_type: Function to be called when search for a type triple\n        :param on_type_validation: Function to be called just after a type is validated\n        :param on_tree: Function to be called just before a tree is going to be explored\n        :param provider:\n        :param queue_size:\n        :param workers:\n        :param stop_event:\n        :param queue_wait:\n        :param lazy:\n        :return:\n        \"\"\"\n\n        if workers is None:\n            workers = multiprocessing.cpu_count()\n\n        fragment_queue = Queue.Queue(maxsize=queue_size)\n        workers_queue = Queue.Queue(maxsize=workers)\n\n        if stop_event is None:\n            stop_event = Event()\n\n        def __create_graph():\n            if provider is None:\n                return ConjunctiveGraph()\n            else:\n                return provider.create(conjunctive=True)\n\n        def __release_graph(g):\n            if provider is not None:\n                provider.release(g)\n            else:\n                g.remove((None, None, None))\n                g.close()\n\n        def __open_graph(gid, loader, format):\n            if provider is None:\n                content, headers = loader(gid, format)\n                if not isinstance(content, bool):\n                    g = ConjunctiveGraph()\n                    g.parse(source=content, format=format)\n                    return g\n                return content\n            else:\n                return provider.create(gid=gid, loader=loader, format=format)\n\n        def __get_content(uri, format):\n            try:\n                # log.debug('[Dereference][START] {}'.format(uri))\n                response = requests.get(uri, headers={'Accept': _accept_mimes[format]}, timeout=30)\n            except requests.Timeout:\n                log.debug('[Dereference][TIMEOUT][GET] {}'.format(uri))\n                return True\n            except UnicodeEncodeError:\n                log.debug('[Dereference][ERROR][ENCODE] {}'.format(uri))\n                return True\n            except Exception:\n                log.debug('[Dereference][ERROR][GET] {}'.format(uri))\n                return True\n\n            if response.status_code == 200:\n                try:\n                    return StringIO.StringIO(response.content), response.headers\n                except SyntaxError:\n                    traceback.print_exc()\n                    log.error('[Dereference][ERROR][PARSE] {}'.format(uri))\n                    return False\n                except ValueError:\n                    traceback.print_exc()\n                    log.debug('[Dereference][ERROR][VAL] {}'.format(uri))\n                    return False\n                except DBNotFoundError:\n                    # Ignore this exception... it is raised due to a stupid problem with prefixes\n                    return True\n                except SAXParseException:\n                    traceback.print_exc()\n                    log.error('[Dereference][ERROR][SAX] {}'.format(uri))\n                    return False\n                except Exception:\n                    traceback.print_exc()\n                    log.error('[Dereference][ERROR] {}'.format(uri))\n                    return True\n\n        def __dereference_uri(tg, uri):\n\n            if not isinstance(uri, URIRef):\n                return\n\n            uri = uri.encode('utf-8')\n\n            def treat_resource_content(parse_format):\n                g = __open_graph(uri, loader=__get_content, format=parse_format)\n                if isinstance(g, bool):\n                    return g\n\n                try:\n                    tg.get_context(uri).__iadd__(g)\n                    return True\n                finally:\n                    if g is not None:\n                        __release_graph(g)\n\n            \"\"\"\n            Load in a tree graph the set of triples contained in uri, trying to not deference the same uri\n            more than once in the context of a search plan execution\n            :param tg: The graph to be loaded with all the triples obtained from uri\n            :param uri: A resource uri to be dereferenced\n            :return:\n            \"\"\"\n            loaded = False\n            for fmt in sorted(_accept_mimes.keys(), key=lambda x: x != self.__last_success_format):\n                loaded = treat_resource_content(fmt)\n                if loaded:\n                    self.__last_success_format = fmt\n                    break\n\n            if loaded and on_load is not None:\n                triples = list(tg.get_context(uri).triples((None, None, None)))\n                on_load(uri, triples)\n\n        def __process_link_seed(seed, tree_graph, link, next_seeds):\n            __check_stop()\n            try:\n                __dereference_uri(tree_graph, seed)\n                seed_pattern_objects = tree_graph.objects(subject=seed, predicate=link)\n                next_seeds.update(seed_pattern_objects)\n            except Exception as e:\n                traceback.print_exc()\n                log.warning(e.message)\n\n        def __process_pattern_link_seed(seed, tree_graph, pattern_link):\n            __check_stop()\n            try:\n                __dereference_uri(tree_graph, seed)\n            except:\n                pass\n            seed_pattern_objects = tree_graph.objects(subject=seed, predicate=pattern_link)\n            return seed_pattern_objects\n\n        def __check_stop():\n            if stop_event.isSet():\n                with self.__resource_lock:\n                    self.__fragment.clear()\n                    for tg in self.__resource_queue.keys():\n                        try:\n                            tg.remove((None, None, None))\n                            tg.store.close()\n                        except KeyError:\n                            pass\n                        tg.close()\n                        __release_graph(tg)\n                    self.__plan_graph = None\n                    self.__uri_cache = None\n                    self.__node_spaces = None\n                    self.__node_patterns = None\n                    self.__spaces = None\n                    self.__patterns = None\n                    self.__subjects_to_ignore.clear()\n                    self.__resource_queue.clear()\n                gc.collect()\n                raise StopException()\n\n        def __put_triple_in_queue(quad):\n            if (dt.now() - self.__last_iteration_ts).total_seconds() > 100:\n                log.info('Aborted fragment collection!')\n                stop_event.set()\n            fragment_queue.put(quad, timeout=queue_wait)\n\n        def __follow_node(node, tree_graph, seed_space, seed):\n            \"\"\"\n            Recursively search for relevant triples following the current node and all its successors\n            :param node: Tree node to be followed\n            :param tree_graph:\n            :param seed_space:\n            :param seed: Collected seed for the current node\n            :return:\n            \"\"\"\n\n            def node_has_filter(x):\n                \"\"\"\n                Check if a node is a pattern node and has an object filter\n                \"\"\"\n                p_node = list(self.__plan_graph.objects(subject=x, predicate=AGORA.byPattern))\n                try:\n                    p_node = p_node.pop()\n                    return 'filter_object' in self.__patterns[p_node] or 'filter_subject' in self.__patterns[p_node]\n                except IndexError:\n                    return False\n\n            try:\n                # Get the sorted list of current node's successors\n                nxt = sorted(list(self.__plan_graph.objects(node, AGORA.next)),\n                             key=lambda x: node_has_filter(x), reverse=True)\n\n                # Per each successor...\n                for n in nxt:\n                    if seed_space in self.__node_spaces[n]:\n                        node_patterns = self.__node_patterns.get(n, [])\n\n                        # In case the node is not a leaf, 'onProperty' tells which is the next link to follow\n                        try:\n                            link = list(self.__plan_graph.objects(subject=n, predicate=AGORA.onProperty)).pop()\n                        except IndexError:\n                            link = None\n\n                        filter_next_seeds = set([])\n                        next_seeds = set([])\n                        # If the current node is a pattern node, it must search for triples to yield\n                        for pattern in node_patterns:\n                            pattern_space = self.__patterns[pattern].get('space', None)\n                            if pattern_space != seed_space or seed in self.__subjects_to_ignore[pattern_space]:\n                                continue\n\n                            subject_filter = self.__patterns[pattern].get('filter_subject', None)\n                            if subject_filter is not None and seed != subject_filter:\n                                self.__subjects_to_ignore[pattern_space].add(seed)\n                                continue\n\n                            pattern_link = self.__patterns[pattern].get('property', None)\n\n                            # If pattern is of type '?s prop O'...\n                            if pattern_link is not None:\n                                if (seed, pattern_link) not in self.__fragment:\n                                    obj_filter = self.__patterns[pattern].get('filter_object', None)\n                                    if on_plink is not None:\n                                        on_plink(pattern_link, [seed], pattern_space)\n\n                                    seed_was_filtered = True\n                                    try:\n                                        for seed_object in list(\n                                                __process_pattern_link_seed(seed, tree_graph, pattern_link)):\n                                            __check_stop()\n                                            quad = (pattern, seed, pattern_link, seed_object)\n                                            if obj_filter is None or u''.join(seed_object).encode(\n                                                    'utf-8') == u''.join(obj_filter.toPython()).encode('utf-8'):\n                                                self.__fragment.add((seed, pattern_link))\n                                                __put_triple_in_queue(quad)\n                                                seed_was_filtered = False\n                                                if isinstance(obj_filter, URIRef):\n                                                    filter_next_seeds.add(obj_filter)\n                                        if obj_filter is not None and seed_was_filtered:\n                                            self.__subjects_to_ignore[pattern_space].add(seed)\n                                    except AttributeError as e:\n                                        log.warning('Trying to find {} objects of {}: {}'.format(link, seed, e.message))\n\n                            # If pattern is of type '?s a Concept'...\n                            obj_type = self.__patterns[pattern].get('type', None)\n                            if obj_type is not None:\n                                check_type = self.__patterns[pattern].get('check', False)\n                                if on_type is not None:\n                                    on_type(obj_type, [seed], pattern_space)\n\n                                __dereference_uri(tree_graph, seed)\n                                try:\n                                    seed_objects = list(tree_graph.objects(subject=seed, predicate=link))\n                                    for seed_object in seed_objects:\n                                        type_triple = (pattern, seed_object, RDF.type, obj_type)\n                                        # In some cases, it is necessary to verify the type of the seed\n                                        if (seed_object, obj_type) not in self.__fragment:\n                                            if check_type:\n                                                __dereference_uri(tree_graph, seed_object)\n                                                types = list(\n                                                    tree_graph.objects(subject=seed_object, predicate=RDF.type))\n                                                if obj_type in types:\n                                                    self.__fragment.add((seed_object, obj_type))\n                                                    __put_triple_in_queue(type_triple)\n                                                else:\n                                                    self.__subjects_to_ignore[pattern_space].add(seed_object)\n                                            else:\n                                                self.__fragment.add((seed_object, obj_type))\n                                                __put_triple_in_queue(type_triple)\n                                except AttributeError as e:\n                                    log.warning('Trying to find {} objects of {}: {}'.format(link, seed, e.message))\n\n                        # If the current node is not a leaf... go on finding seeds for the successors\n                        if link is not None and seed not in self.__subjects_to_ignore[seed_space]:\n                            if on_link is not None:\n                                on_link(link, [seed], seed_space)\n                            __process_link_seed(seed, tree_graph, link, next_seeds)\n\n                        if filter_next_seeds:\n                            next_seeds = set.intersection(next_seeds, filter_next_seeds)\n\n                        chs = list(chunks(list(next_seeds), min(len(next_seeds), max(1, workers / 2))))\n                        next_seeds.clear()\n                        try:\n                            while True:\n                                __check_stop()\n                                chunk = chs.pop()\n                                threads = []\n                                for s in chunk:\n                                    try:\n                                        workers_queue.put_nowait(s)\n                                        future = pool.submit(__follow_node, n, tree_graph, seed_space, s)\n                                        threads.append(future)\n                                    except Queue.Full:\n                                        # If all threads are busy...I'll do it myself\n                                        __follow_node(n, tree_graph, seed_space, s)\n                                    except Queue.Empty:\n                                        pass\n\n                                wait(threads)\n                                [(workers_queue.get_nowait(), workers_queue.task_done()) for _ in threads]\n                        except (IndexError, KeyError):\n                            pass\n            except Queue.Full:\n                stop_event.set()\n            except Exception as e:\n                traceback.print_exc()\n                log.error(e.message)\n                return\n\n        def get_fragment_triples():\n            \"\"\"\n            Iterate over all search trees and yield relevant triples\n            :return:\n            \"\"\"\n\n            def execute_plan():\n                for tree in trees:\n                    if on_tree is not None:\n                        on_tree(tree)\n\n                    # Prepare an dedicated graph for the current tree and a set of type triples (?s a Concept)\n                    # to be evaluated retrospectively\n                    tree_graph = __create_graph()\n\n                    try:\n                        self.__resource_queue[tree_graph] = []\n\n                        # Get all seeds of the current tree\n                        seeds = list(self.__plan_graph.objects(tree, AGORA.hasSeed))\n                        if on_seeds is not None:\n                            on_seeds(seeds)\n\n                        # Check if the tree root is a pattern node and in that case, adds a type triple to the\n                        # respective set\n                        root_pattern = list(self.__plan_graph.objects(tree, AGORA.byPattern))\n                        if len(root_pattern):\n                            pattern_node = list(\n                                self.__plan_graph.objects(subject=tree, predicate=AGORA.byPattern)).pop()\n                            seed_type = self.__patterns[pattern_node].get('type', None)\n                            [type_triples.add((pattern_node, sd, seed_type)) for sd in seeds]\n\n                        # Get the children of the root node and follow them recursively\n                        nxt = list(self.__plan_graph.objects(tree, AGORA.next))\n                        if len(nxt):\n                            # Prepare the list of seeds to start the exploration with, taking into account all\n                            # search spaces that were defined\n                            s_seeds = set(seeds)\n                            for sp in self.__spaces:\n                                for seed in s_seeds:\n                                    __follow_node(tree, tree_graph, sp, seed)\n                    finally:\n                        __release_graph(tree_graph)\n\n                        if lazy and found_data and len(self.__spaces) == 1:\n                            break\n\n                self.__completed = True\n\n            def get_tree_length(x):\n                \"\"\"\n                Return the value of the Agora length property in the given tree node\n                :param x:\n                :return:\n                \"\"\"\n                length = list(self.__plan_graph.objects(subject=x, predicate=AGORA.length)).pop()\n                return length\n\n            # Get all search trees contained in the search plan and sort them by length. A shorter tree is going\n            # to be explored first.\n            trees = self.__plan_graph.subjects(RDF.type, AGORA.SearchTree)\n            trees = sorted(trees, key=lambda x: get_tree_length(x))\n\n            type_triples = set([])\n\n            thread = Thread(target=execute_plan)\n            thread.daemon = True\n            thread.start()\n\n            found_data = False\n            while not self.__completed or fragment_queue.not_empty:\n                try:\n                    (t, s, p, o) = fragment_queue.get(timeout=1)\n                    found_data = True\n                    fragment_queue.task_done()\n                    if p == RDF.type:\n                        type_triples.add((t, s, o))\n                    else:\n                        yield (t, s, p, o)\n                except Queue.Empty:\n                    if self.__completed:\n                        break\n                self.__last_iteration_ts = dt.now()\n            thread.join()\n\n            # All type triples that are of subjects to ignore won't be returned (this has to be done this way\n            # because of generators nature)\n            all_ignores = {}\n            if self.__subjects_to_ignore.values():\n                all_ignores = set.intersection(*self.__subjects_to_ignore.values())\n            valid_type_triples = [(t, s, o) for (t, s, o) in type_triples if s not in all_ignores]\n            for (t, s, o) in valid_type_triples:\n                if on_type_validation is not None:\n                    on_type_validation((t, s, RDF.type, o))\n                yield (t, s, RDF.type, o)\n\n        return get_fragment_triples(), self.__plan_graph.namespaces(), self.__plan_graph"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef CLI(ctx, config, list_lookups):\n    loglevel = 'info'\n    verbosity = getattr(logging, loglevel.upper(), 'INFO')\n    #verbosity = logging.DEBUG\n    ctx.obj = {\n        'verbosity': verbosity,\n        'logfile': None,\n        'config': {'lookups': {}},\n    }\n    #logfmt = '%(levelname)-8s | %(message)s'\n    logfmt = '%(message)s'\n    logging.basicConfig(format=logfmt, level=verbosity)\n    debug('CLI >  CWD=\"{0}\"'.format(os.getcwd()))\n    with open(CONFIG_FILE, 'ab+') as phonedb:\n        phonedb.seek(0)\n        rawdata = phonedb.read()\n        if rawdata:\n            data = json.loads(rawdata, object_pairs_hook=OrderedDict)\n            debug(data)\n            ctx.obj['config'] = data\n            if 'lookups' not in ctx.obj['config']:\n                ctx.obj['config']['lookups'] = {}\n\n    if 'sms_gateways' not in ctx.obj['config']:\n        \"\"\"\n        gwsorted = sorted(ctx.obj['config']['sms_gateways'].items())\n        gwordered = OrderedDict()\n        for (k, v) in gwsorted:\n            gwordered[k] = v\n        ctx.obj['config']['sms_gateways'] = gwordered\n        \"\"\"\n        info('loading SMS gateways...')\n        sms_gateways = {}\n        with open('carrier-gateways', 'rb') as gateways:\n            gwdata = gateways.read()\n            import re\n            re_carrier = r'(?P<carrier>\\w+[\\w\\&\\(\\)\\-\\'\\s]*[\\w\\)\\(]+)\\s+'\n            re_gateway = r'10digitphonenumber(?P<gateway>\\@\\w[\\w\\.]*\\w)\\s+'\n            gwre = re.compile(re_carrier + re_gateway)\n            gws = gwre.findall(gwdata)\n            for gw in gwre.finditer(gwdata):\n                gwinfo = gw.groupdict()\n                debug(gw.groupdict())\n                sms_gateways[gwinfo['carrier']] = gwinfo['gateway']\n            num_lines = len([l for l in gwdata.split('\\n') if len(l)])\n            debug('lines={0} ({1} / 2)'.format(num_lines/2, num_lines))\n            debug('matches={0}'.format(len(data)))\n        ctx.obj['config']['sms_gateways'] = sms_gateways\n        with open(CONFIG_FILE, 'wb') as cfg:\n            cfg.write(json.dumps(ctx.obj['config'], indent=2))\n        info('SMS gateways written to config')\n\n    if list_lookups:\n        sms_updated = False\n        from fuzzywuzzy import fuzz\n        from fuzzywuzzy import process\n        lookups = ctx.obj['config']['lookups']\n        info('cached lookups:')\n        for number, pinfo in lookups.iteritems():\n            owner = pinfo['comment']\n            common = pinfo['body']['national_format']\n            carrier = pinfo['body']['carrier']['name']\n            pntype = pinfo['body']['carrier']['type']\n            info('  {0}: {1}'.format(owner, common))\n            info('    - carrier: {0}'.format(carrier))\n            info('    - type: {0}'.format(pntype))\n            debug('    - unformatted: {0}'.format(number))\n            if 'sms' not in lookups[number]:\n                carriers = ctx.obj['config']['sms_gateways'].keys()\n                fuzzy = process.extract(carrier, carriers)\n                fuzz_max = 0\n                result = []\n                gateway_key = None\n                for f in fuzzy:\n                    if f[1] >= fuzz_max:\n                        fuzz_max = f[1]\n                        result.append(f[0])\n                debug(result)\n                if len(result) > 1:\n                    if len(sorted(result)[0]) <= len(carrier):\n                        gateway_key = sorted(result)[0]\n                    else:\n                        gateway_key = result[0]\n                else:\n                    gateway_key = result[0]\n                gw_suffix = ctx.obj['config']['sms_gateways'][gateway_key]\n                ctx.obj['config']['lookups'][number]['sms'] = '{0}{1}'.format(\n                    number, gw_suffix)\n                sms_updated = True\n            info('    - SMS gateway: {0}'.format(\n                ctx.obj['config']['lookups'][number]['sms']))\n        if sms_updated:\n            with open(CONFIG_FILE, 'wb') as cfg:\n                cfg.write(json.dumps(ctx.obj['config'], indent=2))\n        ctx.exit()", "response": "Lookup basic phone number information or send SMS messages"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the carrier and country code for a phone number", "response": "def lookup(ctx, number, comment, cache):\n    \"\"\"Get the carrier and country code for a phone number\"\"\"\n    phone = PhoneNumber(number, comment=comment)\n    info('{0} | {1}'.format(phone.number, ctx.obj['config']['lookups'].keys()))\n    if phone.number in ctx.obj['config']['lookups']:\n        info('{0} is already cached:'.format(phone.number))\n        info(jsonify(ctx.obj['config']['lookups'][phone.number]))\n        return\n    data = phone.lookup()\n    info('carrier = {0}'.format(phone.carrier))\n    info('type = {0}'.format(phone.type))\n    info('cache = {0}'.format(cache))\n    if cache:\n        ctx.obj['config']['lookups'][phone.number] = phone.raw\n        with open(CONFIG_FILE, 'wb') as cfg:\n            cfg.write(json.dumps(ctx.obj['config'], indent=2))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _interception(self, joinpoint):\n\n        if self.pre_cond is not None:\n            self.pre_cond(joinpoint)\n\n        result = joinpoint.proceed()\n\n        if self.post_cond is not None:\n            joinpoint.exec_ctx[Condition.RESULT] = result\n            self.post_cond(joinpoint)\n\n        return result", "response": "Intercept call of joinpoint callee in doing pre and post conditions."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef anonymous_required(function):\n\n    def wrapper(*args, **kwargs):\n        if args[0].user.is_authenticated():\n            url = settings.ANONYMOUS_REQUIRED_REDIRECT_URL\n            return HttpResponseRedirect(reverse(url))\n        return function(*args, **kwargs)\n\n    return wrapper", "response": "Redirect to user profile if user is already logged-in"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef disqus_sso_script(context):\n    settings = context[\"settings\"]\n    public_key = getattr(settings, \"COMMENTS_DISQUS_API_PUBLIC_KEY\", \"\")\n    secret_key = getattr(settings, \"COMMENTS_DISQUS_API_SECRET_KEY\", \"\")\n    user = context[\"request\"].user\n    if public_key and secret_key and user.is_authenticated():\n        context[\"public_key\"] = public_key\n        context[\"sso_data\"] = _get_disqus_sso(user, public_key, secret_key)\n    return context", "response": "Provides a generic context variable which adds single - sign - on\n    support to DISQUS if Public Key and Secret Key are specified."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing color symbols for the current locale.", "response": "def init_color_symbols(self):\n        \"\"\"\n            'home', 'popover', 'get', 'scroll', 'paginate',\n            'sleep', 'git', 'browser', 'bug',\n            'end', 'right', 'wrong', 'save', 'main', 'raw'\n\n        - font support: https://github.com/ryanoasis/nerd-fonts\n        \"\"\"\n        # symbols = OrderedDict({})\n        if self.is_prod:\n            return\n        keys = [\n            'home', 'popover', 'get', 'scroll', 'paginate',\n            'sleep', 'git', 'browser', 'bug', 'end',\n            'right', 'wrong', 'save', 'main', 'raw',\n            'keyboard', 'store', 'upload', 'send', 'music',\n        ]\n\n        _symbols = ['\uf00c' for _ in keys]\n        # symbols only available in my computer\n        txt = self.cfg.get('pretty.symbols', '')\n        if txt:\n            sym = txt.split('\\n')[0].split(',')\n            _symbols = sym + _symbols[len(sym):]\n\n        for i, k in enumerate(keys):\n            if k in ['wrong', 'end']:\n                self.symbols[k] = R.format(_symbols[i])\n            else:\n                self.symbols[k] = G.format(_symbols[i])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef config_factory(ConfigClass=dict, prefix=None,\n    config_file=None\n    ):\n    '''return a class, which implements the compiler_factory API\n\n    :param ConfigClass:\n        defaults to dict.  A simple factory (without parameter) for a\n        dictionary-like object, which implements __setitem__() method.\n\n        Additionally you can implement following methods:\n\n        :``init_args``: A method to be called to initialize the config object\n           by passing :py:class:`~argparse.Namespace` object resulting from\n           :py:class:`~argparse.ArgumentParser.parseargs` method.\n\n           You could load data from a configuration file here.\n\n        :``compile_args``: A method, which can return the same like a\n           ``compile`` function does.  If there is no such method, a tuple\n           with a ConfigClass instance as single element is returned.\n\n    :param prefix:\n        Add this prefix to config_name.  (e.g. if prefix=\"foo\" and you\n        have config_name=\"x.y\" final config_path results in \"foo.x.y\")\n\n    :param config_file:\n        An :py:class:`~argdeco.arguments.arg` to provide a config file.\n\n        If you provide this argument, you can implement one of the following\n        methods in your ``ConfigClass`` to load data from the configfile:\n\n        :``load``: If you pass ``config_file`` argument, this method can be\n           implemented to load configuration data from resulting stream.\n\n           If config_file is '-', stdin stream is passed.\n\n        :``load_from_file``: If you prefer to open the file yourself, you can\n           do this, by implementing ``load_from_file`` instead which has the\n           filename as its single argument.\n\n        :``update``: method like :py:meth:`dict.update`.   If neither of\n           ``load`` or ``load_from_file`` is present, but ``update`` is,\n           it is assumed, that config_file is of type YAML (or JSON) and\n           configuration is updated by calling ``update`` with the parsed data\n           as parameter.\n\n        If you implement neither of these, it is assumed, that configuration\n        file is of type YAML (or plain JSON, as YAML is a superset of it).\n\n        Data is loaded from file and will update configuration object using\n        dict-like :py:meth:`dict.update` method.\n\n    :type config_file: argdeco.arguments.arg\n\n    :returns:\n        ConfigFactory class, which implements compiler_factory API.\n    '''\n    config_factory = ConfigClass\n\n    class ConfigFactory:\n        def __init__(self, command):\n            self.command = command\n            if config_file:\n                from .arguments import arg\n                assert isinstance(config_file, arg), \"config_file must be of type arg\"\n                try:\n                    self.command.add_argument(config_file)\n                except:\n                    pass\n\n        def __call__(self, args, **opts):\n            cfg = ConfigClass()\n\n            if hasattr(cfg, 'init_args'):\n                cfg.init_args(args)\n\n            if config_file is not None:\n                if hasattr(args, config_file.dest):\n                    fn = getattr(args, config_file.dest)\n                    if fn is not None:\n                        if hasattr(cfg, 'load'):\n                            if config_file.dest == '-':\n                                cfg.load(sys.stdin)\n                            else:\n                                with open(fn, 'r') as f:\n                                    cfg.load(f)\n\n                        elif hasattr(cfg, 'load_from_file'):\n                            cfg.load_from_file(fn)\n\n                        elif hasattr(cfg, 'update'):\n                            # assume yaml file\n                            import yaml\n                            with open(fn, 'r') as f:\n                                data = yaml.load(f)\n                            cfg.update(data)\n\n            for k,v in opts.items():\n                config_name = self.command.get_config_name(args.action, k)\n\n                if config_name is None: continue\n                if prefix is not None:\n                    config_name = '.'.join([prefix, config_name])\n                cfg[config_name] = v\n\n            if hasattr(cfg, 'compile_args'):\n                return cfg.compile_args()\n            else:\n                return (cfg,)\n\n    return ConfigFactory", "response": "A simple factory for the compiler_factory API\n           class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nflattening a nested dictionary D to a flat dictionary", "response": "def flatten(self, D):\n        '''flatten a nested dictionary D to a flat dictionary\n\n        nested keys are separated by '.'\n        '''\n\n        if not isinstance(D, dict):\n            return D\n\n        result = {}\n        for k,v in D.items():\n            if isinstance(v, dict):\n                for _k,_v in self.flatten(v).items():\n                    result['.'.join([k,_k])] = _v\n            else:\n                result[k] = v\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, E=None, **F):\n        '''flatten nested dictionaries to update pathwise\n\n        >>> Config({'foo': {'bar': 'glork'}}).update({'foo': {'blub': 'bla'}})\n        {'foo': {'bar': 'glork', 'blub': 'bla'}\n\n        In contrast to:\n\n        >>> {'foo': {'bar': 'glork'}}.update({'foo': {'blub': 'bla'}})\n        {'foo: {'blub': 'bla'}'}\n\n        '''\n        def _update(D):\n            for k,v in D.items():\n                if super(ConfigDict, self).__contains__(k):\n                    if isinstance(self[k], ConfigDict):\n                        self[k].update(v)\n                    else:\n                        self[k] = self.assimilate(v)\n                else:\n                    self[k] = self.assimilate(v)\n\n        if E is not None:\n            if not hasattr(E, 'keys'):\n                E = self.assimilate(dict(E))\n            _update(E)\n\n        _update(F)\n\n        return self", "response": "flatten nested dictionaries to update pathwise\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndiscover the JSON format and registers it if available.", "response": "def discover_json(bank=None, **meta):\n    \"\"\"Discovers the JSON format and registers it if available.\n\n    To speed up JSON parsing and composing, install `simplejson`::\n\n        pip install simplejson\n\n    The standard library module `json` will be used by default.\n\n    :param bank: The format bank to register the format in\n    :param meta: Extra information associated with the format\n    \"\"\"\n    try:\n        import simplejson as json\n    except ImportError:\n        import json\n    if bank is None:\n        bank = default_bank\n    bank.register('json', json.loads, json.dumps, **meta)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef discover_yaml(bank=None, **meta):\n    try:\n        import yaml\n        if bank is None:\n            bank = default_bank\n        bank.register('yaml', yaml.load, yaml.dump, **meta)\n    except ImportError:\n        pass", "response": "Discovers the YAML format and registers it if available."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filter_factory(global_conf, **local_conf):\n    conf = global_conf.copy()\n    conf.update(local_conf)\n\n    def trusted_shared_nets(app):\n        return TrustedSharedNetwork(app, conf)\n    return trusted_shared_nets", "response": "Returns a WSGI filter app for use with paste. deploy."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef import_legislators(src):\n    logger.info(\"Importing Legislators From: {0}\".format(src))\n    current = pd.read_csv(\"{0}/{1}/legislators-current.csv\".format(\n        src, LEGISLATOR_DIR))\n    historic = pd.read_csv(\"{0}/{1}/legislators-historic.csv\".format(\n        src, LEGISLATOR_DIR))\n    legislators = current.append(historic)\n\n    return legislators", "response": "Read the legislators from the csv files into a single Dataframe."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_legislators(legislators, destination):\n    logger.info(\"Saving Legislators To: {0}\".format(destination))\n    legislators.to_csv(\"{0}/legislators.csv\".format(destination),\n                       encoding='utf-8')", "response": "Save a list of legislators to a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread the committees from the csv files into a single Dataframe.", "response": "def import_committees(src):\n    \"\"\"\n    Read the committees from the csv files into a single Dataframe. Intended for importing new data.\n    \"\"\"\n    committees = []\n    subcommittees = []\n\n    with open(\"{0}/{1}/committees-current.yaml\".format(src, LEGISLATOR_DIR),\n              'r') as stream:\n        committees += yaml.load(stream)\n\n    with open(\"{0}/{1}/committees-historical.yaml\".format(src, LEGISLATOR_DIR),\n              'r') as stream:\n        committees += yaml.load(stream)\n\n    # Sub Committees are not Committees\n    # And unfortunately the good folk at thomas thought modeling data with duplicate id's was a good idea.\n    # you can have two subcommittees with the ID 12. Makes a simple membership map impossible.\n    for com in committees:\n        com['committee_id'] = com['thomas_id']\n        if 'subcommittees' in com:\n            # process sub committees into separate DataFrame\n            for subcom in com.get('subcommittees'):\n                subcom['committee_id'] = com[\n                    'thomas_id'\n                ]  # we use committee_id so we can easily merge dataframes\n                subcom['subcommittee_id'] = \"{0}-{1}\".format(\n                    subcom['committee_id'], subcom['thomas_id'])\n                subcommittees.append(subcom)\n\n            del com['subcommittees']\n\n    committees_df = pd.DataFrame(committees)\n    subcommittees_df = pd.DataFrame(subcommittees)\n\n    return [committees_df, subcommittees_df]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmoving a committee from one file to another.", "response": "def move_committees(src, dest):\n    \"\"\"\n    Import stupid yaml files, convert to something useful.\n    \"\"\"\n    comm, sub_comm = import_committees(src)\n    save_committees(comm, dest)\n    save_subcommittees(comm, dest)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a directory for a given congress.", "response": "def make_congress_dir(congress, dest):\n    \"\"\"\n    If the directory for a given congress does not exist. Make it.\n    \"\"\"\n\n    congress_dir = \"{0}/{1}\".format(dest, congress)\n    path = os.path.dirname(congress_dir)\n    logger.debug(\"CSV DIR: {}\".format(path))\n    if not os.path.exists(congress_dir):\n        logger.info(\"Created: {0}\".format(congress_dir))\n        os.mkdir(congress_dir)\n    return congress_dir"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving a single object of a single class to a single file.", "response": "def save_congress(congress, dest):\n    \"\"\"\n    Takes a congress object with legislation, sponser, cosponsor, commities\n    and subjects attributes and saves each item to it's own csv file.\n    \"\"\"\n    try:\n        logger.debug(congress.name)\n        logger.debug(dest)\n        congress_dir = make_congress_dir(congress.name, dest)\n        congress.legislation.to_csv(\"{0}/legislation.csv\".format(congress_dir),\n                                    encoding='utf-8')\n        logger.debug(congress_dir)\n        congress.sponsors.to_csv(\"{0}/sponsor_map.csv\".format(congress_dir),\n                                 encoding='utf-8')\n        congress.cosponsors.to_csv(\n            \"{0}/cosponsor_map.csv\".format(congress_dir),\n            encoding='utf-8')\n        congress.events.to_csv(\"{0}/events.csv\".format(congress_dir),\n                               encoding='utf-8')\n        congress.committees.to_csv(\n            \"{0}/committees_map.csv\".format(congress_dir),\n            encoding='utf-8')\n        congress.subjects.to_csv(\"{0}/subjects_map.csv\".format(congress_dir),\n                                 encoding='utf-8')\n        congress.votes.to_csv(\"{0}/votes.csv\".format(congress_dir),\n                              encoding='utf-8')\n        congress.votes_people.to_csv(\n            \"{0}/votes_people.csv\".format(congress_dir),\n            encoding='utf-8')\n        if hasattr(congress, 'amendments'):\n            congress.amendments.to_csv(\n                \"{0}/amendments.csv\".format(congress_dir),\n                encoding='utf-8')\n    except Exception:\n        logger.error(\"############################################shoot me\")\n        exc_type, exc_obj, exc_tb = sys.exc_info()\n        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n        logger.error(exc_type, fname, exc_tb.tb_lineno)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts the legislation fields from a bill object", "response": "def extract_legislation(bill):\n    \"\"\"\n    Returns a list of the legislation fields we need for our legislation DataFrame\n    :param bill:\n    :return list:\n    \"\"\"\n    record = []\n    record.append(bill.get('congress', None))\n    record.append(bill.get('bill_id', None))\n    record.append(bill.get('bill_type', None))\n    record.append(bill.get('introduced_at', None))\n    record.append(bill.get('number', None))\n    record.append(bill.get('official_title', None))\n    record.append(bill.get('popular_title', None))\n    record.append(bill.get('short_title', None))\n    record.append(bill.get('status', None))\n    record.append(bill.get('status_at', None))\n    record.append(bill.get('top_subject', None))\n    record.append(bill.get('updated_at', None))\n\n    return record"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extract_sponsor(bill):\n    logger.debug(\"Extracting Sponsor\")\n    sponsor_map = []\n    sponsor = bill.get('sponsor', None)\n    if sponsor:\n        sponsor_map.append(sponsor.get('type'))\n        sponsor_map.append(sponsor.get('thomas_id'))\n        sponsor_map.append(bill.get('bill_id'))\n        sponsor_map.append(sponsor.get('district'))\n        sponsor_map.append(sponsor.get('state'))\n    logger.debug(\"END Extracting Sponsor\")\n    return sponsor_map if sponsor_map else None", "response": "Extract a list of the fields we need to map a sponser to a bill"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extract_cosponsors(bill):\n    logger.debug(\"Extracting Cosponsors\")\n    cosponsor_map = []\n    cosponsors = bill.get('cosponsors', [])\n    bill_id = bill.get('bill_id', None)\n\n    for co in cosponsors:\n        co_list = []\n        co_list.append(co.get('thomas_id'))\n        co_list.append(bill_id)\n        co_list.append(co.get('district'))\n        co_list.append(co.get('state'))\n        cosponsor_map.append(co_list)\n\n    logger.debug(\"End Extractioning Cosponsors\")\n\n    return cosponsor_map", "response": "Extract cosponsors from legislation bill."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract a list of subjects from a legislation bill.", "response": "def extract_subjects(bill):\n    \"\"\"\n    Return a list subject for legislation.\n    \"\"\"\n    logger.debug(\"Extracting Subjects\")\n    subject_map = []\n    subjects = bill.get('subjects', [])\n    bill_id = bill.get('bill_id', None)\n    bill_type = bill.get('bill_type', None)\n\n    for sub in subjects:\n        subject_map.append((bill_id, bill_type, sub))\n\n    logger.debug(\"End Extractioning Subjects\")\n\n    return subject_map"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract committees from a bill.", "response": "def extract_committees(bill):\n    \"\"\"\n    Returns committee associations from a bill.\n    \"\"\"\n    bill_id = bill.get('bill_id', None)\n    logger.debug(\"Extracting Committees for {0}\".format(bill_id))\n\n    committees = bill.get('committees', None)\n    committee_map = []\n\n    for c in committees:\n        logger.debug(\"Processing committee {0}\".format(c.get('committee_id')))\n        c_list = []\n        sub = c.get('subcommittee_id')\n        if sub:\n            logger.debug(\"is subcommittee\")\n            c_list.append('subcommittee')  # type\n            c_list.append(c.get('subcommittee'))\n            sub_id = \"{0}-{1}\".format(\n                c.get('committee_id'), c.get('subcommittee_id'))\n            logger.debug(\"Processing subcommittee {0}\".format(sub_id))\n            c_list.append(sub_id)\n        else:\n            c_list.append('committee')\n            c_list.append(c.get('committee'))\n            c_list.append(c.get('committee_id'))\n        c_list.append(bill_id)\n        committee_map.append(c_list)\n    return committee_map"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts all events from legislation. Thing of this is a log for congress.", "response": "def extract_events(bill):\n    \"\"\"\n    Returns all events from legislation. Thing of this as a log for congress.\n    There are alot of events that occur around legislation. For now we are\n    going to kepe it simple. Introduction, cosponsor, votes dates\n    \"\"\"\n    events = []\n    #logger.debug(events)\n\n    bill_id = bill.get('bill_id', None)\n    if bill_id:\n        for event in bill.get('actions', []):\n            e = []\n            e.append(bill_id)\n            e.append(event.get('acted_at', None))\n            e.append(event.get('how', None))\n            e.append(event.get('result', None))\n            e.append(event.get('roll', None))\n            e.append(event.get('status', None))\n            e.append(event.get('suspension', False))\n            e.append(event.get('text', None))\n            e.append(event.get('type', None))\n            e.append(event.get('vote_type', None))\n            e.append(event.get('where', None))\n            e.append(event.get('calander', None))\n            e.append(event.get('number', None))\n            e.append(event.get('under', None))\n            e.append(event.get('committee', None))\n            e.append(event.get('committees', []))\n            events.append(e)\n    #logger.debug(events)\n\n    return events"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprocess the amendments of a project", "response": "def process_amendments(congress):\n    \"\"\"\n    Traverse amendments for a project\n    \"\"\"\n    amend_dir = \"{0}/{1}/amendments\".format(congress['src'],\n                                            congress['congress'])\n    logger.info(\"Processing Amendments for {0}\".format(congress['congress']))\n\n    amendments = []\n\n    for root, dirs, files in os.walk(amend_dir):\n        if \"data.json\" in files and \"text-versions\" not in root:\n            file_path = \"{0}/data.json\".format(root)\n            logger.debug(\"Processing {0}\".format(file_path))\n            a = json.loads(open(file_path, 'r').read())\n            amendment = []\n\n            amendment.append(a['amendment_id'])\n            amendment.append(a['amendment_type'])\n            if a['amends_amendment']:\n                amendment.append(a['amends_amendment'].get('amendment_id',\n                                                           None))\n            else:\n                amendment.append(None)\n            if a['amends_bill']:\n                amendment.append(a['amends_bill'].get('bill_id', None))\n            else:\n                amendment.append(None)\n            if a['amends_treaty']:\n                amendment.append(a['amends_treaty'].get('treaty_id', None))\n            else:\n                amendment.append(None)\n            amendment.append(a['chamber'])\n            amendment.append(a['congress'])\n            amendment.append(a['description'])\n            amendment.append(a['introduced_at'])\n            amendment.append(a['number'])\n            amendment.append(a.get('proposed_at', None))\n            amendment.append(a['purpose'])\n            amendment.append(a['sponsor'].get('thomas_id', None))\n            amendment.append(a['sponsor'].get('committee_id', None))\n            amendment.append(a['sponsor']['type'])\n            amendment.append(a['status'])\n            amendment.append(a['updated_at'])\n\n            amendments.append(amendment)\n\n    return amendments if amendments else [[None] * 17]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef lis_to_bio_map(folder):\n    logger.info(\"Opening legislator csv for lis_dct creation\")\n    lis_dic = {}\n    leg_path = \"{0}/legislators.csv\".format(folder)\n    logger.info(leg_path)\n    with open(leg_path, 'r') as csvfile:\n        leg_reader = csv.reader(csvfile)\n        for row in leg_reader:\n            if row[22]:\n                lis_dic[row[22]] = row[19]\n    return lis_dic", "response": "Read the CSV file for the lis_id and bioguide_id of all congress s in a folder and return a dictionary that maps the lis_id to bioguide_id which every member of congress has."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting govtrack congress directory and return a dictionary of dataframes.", "response": "def convert_congress(congress):\n    \"\"\"\n    Recurse the passed govtrack congress directory and convert it's contents\n    to a set of csv files from the legislation contained therein.\n    :return dict: A Dictionary of DataFrames\n    \"\"\"\n\n    logger.info(\"Begin processing Congress {0}\".format(congress['congress']))\n\n    congress_obj = Congress(congress)\n    lis_to_bio = lis_to_bio_map(congress['dest'])\n\n    logger.debug(\"made congress object\")\n    logger.debug(congress_obj)\n\n    # We construct lists that can be used to construct dataframes.  Adding to\n    # dataframes is expensive so we don't do  that.\n\n    bills = process_bills(congress)\n    amendments = process_amendments(congress)\n    votes = process_votes(congress, lis_to_bio)\n\n    try:\n\n        logger.debug(\" ======================  SAVING {}\".format(congress))\n\n        congress_obj.legislation = pd.DataFrame(bills['legislation'] if bills[\n            'legislation'] else [[None] * 12])\n        congress_obj.legislation.columns = [\n            'congress', 'bill_id', 'bill_type', 'introduced_at', 'number',\n            'official_title', 'popular_title', 'short_title', 'status',\n            'status_at', 'top_subject', 'updated_at'\n        ]\n\n        f = [s for s in bills['sponsors'] if s]\n        sponsors = f if f else [[None] * 5]\n        congress_obj.sponsors = pd.DataFrame(sponsors)\n        congress_obj.sponsors.columns = [\n            'type', 'thomas_id', 'bill_id', 'district', 'state'\n        ]\n\n        c = [s for s in bills['cosponsors'] if len(s) > 0]\n        cosponsors = c if c else [[None] * 5]\n        congress_obj.cosponsors = pd.DataFrame(cosponsors)\n        congress_obj.sponsors.columns = [\n            'type', 'thomas_id', 'bill_id', 'district', 'state'\n        ]\n\n        c = [s for s in bills['committees'] if len(s) > 0]\n        committees = c if c else [[None] * 4]\n        congress_obj.committees = pd.DataFrame(committees)\n        congress_obj.committees.columns = [\n            'type', 'name', 'committee_id', 'bill_id'\n        ]\n\n        s = [s for s in bills['subjects'] if len(s) > 0]\n        subjects = s if s else [[None] * 3]\n        congress_obj.subjects = pd.DataFrame(subjects)\n        congress_obj.subjects.columns = ['bill_id', 'bill_type', 'subject']\n\n        e = [s for s in bills['events'] if len(s) > 0]\n        events = e if e else [[None] * 16]\n        congress_obj.events = pd.DataFrame(events)\n        congress_obj.events.columns = [\n            'bill_id', 'acted_at', 'how', 'result', 'roll', 'status',\n            'suspension', 'text', 'type', 'vote_type', 'where', 'calander',\n            'number', 'under', 'committee', 'committees'\n        ]\n\n        # Amendment data is not avalible for all congresses\n        if amendments:\n            congress_obj.amendments = pd.DataFrame(amendments)\n            congress_obj.amendments.columns = [\n                'amendment_id', 'amendment_type', 'amends_amendment',\n                'amends_bill', 'amends_treaty', 'chamber', 'congress',\n                'description', 'introduced', 'number', 'proposed', 'purpose',\n                'sponsor_id', 'committee_id', 'sponsor_type', 'status',\n                'updated'\n            ]\n\n        congress_obj.votes = pd.DataFrame(votes['votes'])\n        congress_obj.votes.columns = ['amendment_id', 'bill_id', 'category',\n                                      'congress', 'chamber', 'date', 'number',\n                                      'requires', 'result', 'result_text',\n                                      'session', 'type', 'updated_at',\n                                      'vote_id', 'yes', 'no', 'not_voting',\n                                      'present']\n\n        congress_obj.votes_people = pd.DataFrame(votes['people'])\n        congress_obj.votes_people.columns = ['vote', 'vote_id', 'bioguide_id',\n                                             'party', 'state', 'date']\n\n        save_congress(congress_obj, congress['dest'])\n\n    except Exception as e:\n        logger.error(\n            \"################### ERRROR SAVING ########################\")\n        logger.error(\"congress {0}\".format(congress))\n        exc_type, exc_obj, exc_tb = sys.exc_info()\n        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n        raise e"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convert_level(self, record):\n        level = record.levelno\n        if level >= logging.CRITICAL:\n            return levels.CRITICAL\n        if level >= logging.ERROR:\n            return levels.ERROR\n        if level >= logging.WARNING:\n            return levels.WARNING\n        if level >= logging.INFO:\n            return levels.INFO\n        return levels.DEBUG", "response": "Converts a logging level into a logbook level."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntry to find extra data from the old logging record. The return value is a dictionary that is merged with the log record extra dictionaries.", "response": "def find_extra(self, record):\n        \"\"\"Tries to find custom data from the old logging record.  The\n        return value is a dictionary that is merged with the log record\n        extra dictionaries.\n        \"\"\"\n        rv = vars(record).copy()\n        for key in ('name', 'msg', 'args', 'levelname', 'levelno',\n                    'pathname', 'filename', 'module', 'exc_info',\n                    'exc_text', 'lineno', 'funcName', 'created',\n                    'msecs', 'relativeCreated', 'thread', 'threadName',\n                    'processName', 'process'):\n            rv.pop(key, None)\n        return rv"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_version(fname):\r\n  \"grab __version__ variable from fname (assuming fname is a python file). parses without importing.\"\r\n  assign_stmts = [s for s in ast.parse(open(fname).read()).body if isinstance(s,ast.Assign)]\r\n  valid_targets = [s for s in assign_stmts if len(s.targets) == 1 and s.targets[0].id == '__version__']\r\n  return valid_targets[-1].value.s", "response": "grab __version__ variable from fname parses without importing."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister a map function as a view Currently, only a single map function can be created for each view NOTE: the map function source is saved in CouchDB, so it cannot depend on anything outside the function's scope. :param db_name: the database name", "response": "def view(db_name):\n    \"\"\"\n    Register a map function as a view\n\n    Currently, only a single map function can be created for each view\n\n    NOTE: the map function source is saved in CouchDB, so it cannot depend on\n    anything outside the function's scope.\n\n    :param db_name: the database name\n    \"\"\"\n    def decorator(func):\n        v = View(db_name, func)\n        v.register()\n        return v\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading design docs for registered views", "response": "def load_design_docs():\n    \"\"\"\n    Load design docs for registered views\n    \"\"\"\n    url = ':'.join([options.url_registry_db, str(options.db_port)])\n    client = partial(couch.BlockingCouch, couch_url=url)\n\n    for name, docs in _views.items():\n        db = client(db_name=name)\n        views = []\n\n        for doc in docs:\n            try:\n                current_doc = db.get_doc(doc['_id'])\n\n                # use the current _rev if not provided\n                if '_rev' not in doc:\n                    doc['_rev'] = current_doc['_rev']\n            except couch.NotFound:\n                pass\n\n            views.append(doc)\n\n        db.save_docs(views)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef active_user_organisations_resource(doc):\n    if doc.get('type') == 'user' and doc.get('state') != 'deactivated':\n        for org_id, resource in doc.get('organisations', {}).items():\n            if resource['state'] != 'deactivated':\n                resource['id'] = org_id\n                resource['user_id'] = doc['_id']\n                yield [doc['_id'], org_id], resource", "response": "Get user. organisations subresouces"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget user. organisations subresouces", "response": "def user_organisations_resource(doc):\n    \"\"\"Get user.organisations subresouces\"\"\"\n    if doc.get('type') == 'user':\n        for org_id, resource in doc.get('organisations', {}).items():\n            resource['id'] = org_id\n            resource['user_id'] = doc['_id']\n            yield [doc['_id'], org_id], resource"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nviewing for getting organisations associated with a user", "response": "def active_joined_organisations(doc):\n    \"\"\"View for getting organisations associated with a user\"\"\"\n    if doc.get('type') == 'user' and doc.get('state') != 'deactivated':\n        for org_id, state in doc.get('organisations', {}).items():\n            if state['state'] == 'deactivated':\n                continue\n\n            org = {'_id': org_id}\n            yield [doc['_id'], None], org\n\n            try:\n                yield [doc['_id'], state['state']], org\n            except KeyError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nview for getting organisations associated with a user", "response": "def joined_organisations(doc):\n    \"\"\"View for getting organisations associated with a user\"\"\"\n    if doc.get('type') == 'user':\n        for org_id, state in doc.get('organisations', {}).items():\n            org = {'_id': org_id}\n            yield [doc['_id'], None], org\n\n            try:\n                yield [doc['_id'], state['state']], org\n            except KeyError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef admin_emails(doc):\n    if doc.get('type') == 'user' and doc.get('state') != 'deactivated':\n        if doc.get('role') == 'administrator':\n            yield None, doc['email']\n        for org_id, state in doc.get('organisations', {}).items():\n            if state.get('role') == 'administrator' and state.get('state') != 'deactivated':\n                yield org_id, doc['email']", "response": "View for admin email addresses"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget reference links from a document", "response": "def reference_links(doc):\n    \"\"\"Get reference links\"\"\"\n    if doc.get('type') == 'organisation' and doc.get('state') != 'deactivated':\n        for asset_id_type, link in doc.get('reference_links', {}).get('links', {}).items():\n            value = {\n                'organisation_id': doc['_id'],\n                'link': link\n            }\n            yield asset_id_type, value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nviews for getting active services", "response": "def active_services(doc):\n    \"\"\"View for getting active services\"\"\"\n    if doc.get('state') != 'deactivated':\n        for service_id, service in doc.get('services', {}).items():\n            if service.get('state') != 'deactivated':\n                service_type = service.get('service_type')\n                org = doc['_id']\n                service['id'] = service_id\n                service['organisation_id'] = org\n\n                yield service_id, service\n                yield [service_type, org], service\n                yield [service_type, None], service\n                yield [None, org], service\n                yield [None, None], service"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nviews for getting services", "response": "def services(doc):\n    \"\"\"View for getting services\"\"\"\n    for service_id, service in doc.get('services', {}).items():\n        service_type = service.get('service_type')\n        org = doc['_id']\n        service['id'] = service_id\n        service['organisation_id'] = org\n\n        yield service_id, service\n        yield [service_type, org], service\n        yield [service_type, None], service\n        yield [None, org], service\n        yield [None, None], service"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nviewing for getting active service by location", "response": "def active_service_location(doc):\n    \"\"\"View for getting active service by location\"\"\"\n    if doc.get('state') != 'deactivated':\n        for service_id, service in doc.get('services', {}).items():\n            if service.get('state') != 'deactivated':\n                service['id'] = service_id\n                service['organisation_id'] = doc['_id']\n\n                location = service.get('location', None)\n                if location:\n                    yield location, service"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nview for getting service by location", "response": "def service_location(doc):\n    \"\"\"View for getting service by location\"\"\"\n    for service_id, service in doc.get('services', {}).items():\n        service['id'] = service_id\n        service['organisation_id'] = doc['_id']\n\n        location = service.get('location', None)\n        if location:\n            yield location, service"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nviews for getting service by name", "response": "def service_name(doc):\n    \"\"\"View for getting service by name\"\"\"\n    for service_id, service in doc.get('services', {}).items():\n        service['id'] = service_id\n        service['organisation_id'] = doc['_id']\n\n        name = service.get('name', None)\n        if name:\n            yield name, service"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nview for getting active repositories", "response": "def active_repositories(doc):\n    \"\"\"View for getting active repositories\"\"\"\n    if doc.get('state') != 'deactivated':\n        for repository_id, repo in doc.get('repositories', {}).items():\n            if repo.get('state') != 'deactivated':\n                repo['id'] = repository_id\n                repo['organisation_id'] = doc['_id']\n\n                yield repository_id, repo"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nviewing for getting repositories", "response": "def repositories(doc):\n    \"\"\"View for getting repositories\"\"\"\n    for repository_id, repo in doc.get('repositories', {}).items():\n        repo['id'] = repository_id\n        repo['organisation_id'] = doc['_id']\n\n        yield repository_id, repo"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nviews for checking if the repository name is unique", "response": "def repository_name(doc):\n    \"\"\"View for checking repository name is unique\"\"\"\n    for repository_id, repo in doc.get('repositories', {}).items():\n        repo['id'] = repository_id\n        repo['organisation_id'] = doc['_id']\n\n        name = repo.get('name', None)\n        if name:\n            yield name, repository_id"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef service_and_repository(doc):\n    if doc.get('type') == 'organisation' and doc.get('state') != 'deactivated':\n        for repository_id, repo in doc.get('repositories', {}).items():\n            if repo.get('state') != 'deactivated':\n                repo['id'] = repository_id\n                repo['organisation_id'] = doc['_id']\n\n                yield repository_id, repo\n\n        for service_id, service in doc.get('services', {}).items():\n            if service.get('state') != 'deactivated':\n                service['id'] = service_id\n                service['organisation_id'] = doc['_id']\n\n                yield service_id, service", "response": "Yields the service and repository IDs for a given document"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a design document from a Python map function", "response": "def create_design_doc(self):\n        \"\"\"Create a design document from a Python map function\"\"\"\n        source = [x for x in inspect.getsourcelines(self.func)[0]\n                  if not x.startswith('@')]\n\n        doc = {\n            '_id': '_design/{}'.format(self.name),\n            'language': 'python',\n            'views': {\n                self.name: {\n                    'map': ''.join(source)\n                }\n            }\n        }\n\n        return doc"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nquerying database for results of view", "response": "def get(self, **kwargs):\n        \"\"\"\n        Queries database for results of view\n        :return:\n        \"\"\"\n        db_url = ':'.join([options.url_registry_db, str(options.db_port)])\n        db = couch.AsyncCouch(db_name=self.db_name, couch_url=db_url)\n\n        result = yield db.view(\n            design_doc_name=self.name,\n            view_name=self.name,\n            **kwargs)\n\n        raise Return(result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef first(self, **kwargs):\n        result = yield self.get(**kwargs)\n\n        if not result['rows']:\n            raise exceptions.NotFound()\n\n        raise Return(result['rows'][0])", "response": "Queries database for first result of view\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the view s values", "response": "def values(self, **kwargs):\n        \"\"\"Get the view's values\"\"\"\n        result = yield self.get(**kwargs)\n\n        if not result['rows']:\n            raise Return([])\n\n        raise Return([x['value'] for x in result['rows']])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getScriptArgumentParser(args=sys.argv):\n    # Description\n    parser = argparse.ArgumentParser(\n            description=DESCRIPTION)\n    # source\n    parser.add_argument('config_file',\n            help=\"Valid script configration file.  This should be the path to \"\\\n                 \"the script XML configuration file.  See config_sample.xml\"\\\n                 \"for detailed config specifications.\")\n    \n    # --verbose\n    parser.add_argument('--verbose',\n            action='store_true',\n            help=\"Echo verbose messages to stdout.\")\n    \n    # --verbose\n    parser.add_argument('--debug',\n            action='store_true',\n            help=\"Echo debug messages to stdout.\")\n    \n    return parser", "response": "Returns an argument parser object that can be used to validate and execute the current script invocation."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef configure_zca(cls, cache_config):\n        # step 1\n        packages = [sparc.apps.cache]\n        Configure(packages)\n        configure_vocabulary_registry()\n        #step 2\n        config = ElementTree.parse(cache_config).getroot()\n        for zcml in config.findall('zcml'):\n            zcml_file, package = 'configure.zcml' \\\n                        if 'file' not in zcml.attrib else zcml.attrib['file'],\\\n                            import_module(zcml.attrib['package'])\n            zope.configuration.xmlconfig.XMLConfig(zcml_file, package)()\n        #step3\n        alsoProvides(config, IAppElementTreeConfig)\n        sm = getSiteManager()\n        sm.registerUtility(config, IAppElementTreeConfig)\n        return config", "response": "Configure the runtime Zope Component Architecture registry\n        \n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef poller_configurations(self):\n        configs = []\n        for cacheablesource in self.config.findall('cacheablesource'):\n            for cachearea in self.config.findall('cachearea'):\n                if 'sources' not in cachearea.attrib:\n                    configs.append({'cacheablesource': cacheablesource, \n                           'cachearea': cachearea})\n                elif cacheablesource.attrib['id'] in \\\n                                        cachearea.attrib['sources'].split():\n                    configs.append({'cacheablesource': cacheablesource, \n                           'cachearea': cachearea})\n        return configs", "response": "Returns a sequence of data structures for all poller configurations"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_poller(self, **kwargs):\n        cacheablesource = \\\n            createObject(kwargs['cacheablesource'].attrib['factory'], \n                         kwargs['cacheablesource'])\n        cachearea = \\\n            createObject(kwargs['cachearea'].attrib['factory'], \n                         kwargs['cachearea'])\n        poll = abs(int(kwargs['cacheablesource'].attrib['poll']))\n        logger.info(\"Poller create for cacheablesource id %s and cachearea id %s\" \\\n                        % (kwargs['cacheablesource'].attrib['id'], \\\n                          kwargs['cachearea'].attrib['id'])\n                        )\n        return (cacheablesource, cachearea, poll)", "response": "Creates a poller data structure from the specified kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef go(self, poller_configurations):\n        try:\n            notify(\n                CachableSourcePollersAboutToStartEvent(poller_configurations))\n            logger.info(\"Starting pollers\")\n            exit_ = threading.Event()\n            for config in poller_configurations: # config is a dict\n                kwargs = {'exit_': exit_}\n                kwargs.update(config)\n                threading.Thread(target=self.poll, \n                                        kwargs=(kwargs), \n                                    ).start()\n            while threading.active_count() > 1:\n                time.sleep(.001)\n        except KeyboardInterrupt:\n            logger.info(\"KeyboardInterrupt signal caught, shutting down pollers...\")\n            exit_.set()", "response": "Create threaded pollers and start configured polling cycles\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting the color to HTML", "response": "def to_html(self):\n        \"\"\" Converts to Hex \"\"\"\n        out = \"#\"\n        if self.r == 0:\n            out += \"00\"\n        else:\n            out += hex(self.r)[2:]\n        if self.b == 0:\n            out += \"00\"\n        else:\n            out += hex(self.b)[2:]\n        if self.g == 0:\n            out += \"00\"\n        else:\n            out += hex(self.g)[2:]\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef merge(self, other):\n        print \"MERGING\", self, other\n        other = self.coerce(other)\n        if self.is_contradictory(other):\n            raise Contradiction(\"Cannot merge %s and %s\" % (self, other))\n        elif self.value is None and not other.value is None:\n            self.r, self.g, self.b = other.r, other.g, other.b\n            self.value = RGBColor(self.r, self.b, self.g, rgb_type='sRGB')\n        # last cases:  other is none, or both are none \n        \n        return self", "response": "Merges the values of this color with the values of the other color."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef push_to_topic(dst, dat, qos=0, retain=False, cfgs=None):\n    cfg_amqt = {\n        'hostname': cfgs['hostname'],\n        'port': cfgs['port'],\n        'username': cfgs['username'],\n        'password': cfgs['password'],\n    }\n\n    msg = {\n        'topic': dst,\n        'payload': dat,\n        'qos': qos,\n        'retain': retain,\n    }\n    try:\n        Publisher(cfg_amqt).run(msg)\n        return True\n    except Exception as err:\n        log.error('push to amqt: {}'.format(err))\n        return False", "response": "Push a dat to a topic"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _on_connect(client, userdata, flags, rc):\n    log.debug('[MQTT] Connected with result code ' + str(rc))\n    client.subscribe('test_topic', qos=2)", "response": "Callback function for when a client is connected"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calculate_health(package_name, package_version=None, verbose=False, no_output=False):\n    total_score = 0\n    reasons = []\n\n    package_releases = CLIENT.package_releases(package_name)\n    if not package_releases:\n        if not no_output:\n            print(TERMINAL.red('{} is not listed on pypi'.format(package_name)))\n        return 0, []\n\n    if package_version is None:\n        package_version = package_releases[0]\n\n    package_info = CLIENT.release_data(package_name, package_version)\n    release_urls = CLIENT.release_urls(package_name, package_version)\n\n    if not package_info or not release_urls:\n        if not no_output:\n            print(TERMINAL.red('Version {} is not listed on pypi'.format(\n                package_version)))\n        return 0, []\n\n    if not no_output:\n        print(TERMINAL.bold('{} v{}'.format(package_name, package_version)))\n        print('-----')\n\n    checkers = [\n        checks.check_license,\n        checks.check_homepage,\n        checks.check_summary,\n        checks.check_description,\n        checks.check_python_classifiers,\n        checks.check_author_info,\n        checks.check_release_files,\n        checks.check_stale\n    ]\n\n    for checker in checkers:\n        result, reason, score = checker(package_info, release_urls)\n        if result:\n            total_score += score\n        else:\n            reasons.append(reason)\n\n    if total_score < 0:\n        total_score = 0\n\n    if not no_output:\n        percentage = int(float(total_score) / float(checks.TOTAL_POSSIBLE) * 100)\n        score_string = 'score: {}/{} {}%'.format(total_score, checks.TOTAL_POSSIBLE, percentage)\n\n        print(get_health_color(percentage)(score_string))\n\n    if verbose and not no_output:\n        for reason in reasons:\n            print(reason)\n\n    if no_output:\n        return total_score, reasons", "response": "Calculates the health of a package on pypi."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a color based on the health score", "response": "def get_health_color(score):\n    \"\"\"\n    Returns a color based on the health score\n    :param score: integer from 0 - 100 representing health\n    :return: string of color to apply in terminal\n    \"\"\"\n    color = TERMINAL.green\n\n    if score <= 80:\n        color = TERMINAL.yellow\n    elif score <= 60:\n        color = TERMINAL.orange\n    elif score <= 40:\n        color = TERMINAL.red\n\n    return color"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses user input for a package name and returns the health of the package", "response": "def main():\n    \"\"\"\n    Parses user input for a package name\n    :return:\n    \"\"\"\n    parser = argparse.ArgumentParser('Determines the health of a package')\n\n    parser.add_argument(\n        'package_name',\n        help='Name of package listed on pypi.python.org',\n    )\n\n    parser.add_argument(\n        'package_version', nargs='?',\n        help='Version of package to check',\n    )\n\n    parser.add_argument(\n        '-v', '--verbose', required=False,\n        help='Show verbose output - the reasons for the package health score',\n        action='store_true'\n    )\n\n    parser.add_argument(\n        '-n', '--no_output', required=False,\n        help='Show no output - no output will be generated',\n        action='store_true'\n    )\n\n    args = parser.parse_args()\n\n    return calculate_health(args.package_name, args.package_version, args.verbose, args.no_output)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filter(filter_creator):\n    filter_func = [None]\n\n    def function_getter(function):\n        if isinstance(function, Filter):\n            function.add_filter(filter)\n\n            return function\n        else:\n            return Filter(\n                filter=filter_func[0],\n                callback=function,\n            )\n\n    def filter_decorator(*args, **kwargs):\n        filter_function = filter_creator(*args, **kwargs)\n\n        filter_func[0] = filter_function\n\n        return function_getter\n\n    return filter_decorator", "response": "Creates a decorator that can be used as a filter."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if all filters are called.", "response": "def check_filter(self, args, kwargs):\n        \"\"\"\n        Calls all filters in the :attr:`_filters` list and if all of them\n        return :const:`True` will return :const:`True`. If any of the filters\n        return :const:`False` will return :const:`True` instead.\n\n        This method is equal to the following snippet:\n            `all(f(*args, **kwargs) for f in self.filters)`\n        \"\"\"\n        for f in self._filters:\n            if not f(*args, **kwargs):\n                return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self, uuid):\n        url = \"{base}/{uuid}\".format(\n            base=self.local_base_url,\n            uuid=uuid\n        )\n        return self.core.delete(url)", "response": "Delete a resource from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, data):\n        self.debug(data)\n        url = \"{base}/{uuid}\".format(\n            base=self.local_base_url,\n            uuid=data.get('uuid')\n        )\n        return self.core.update(url, data)", "response": "Update the related resources."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nperforming Guinier analysis on the samples.", "response": "def guinieranalysis(samplenames, qranges=None, qmax_from_shanum=True, prfunctions_postfix='', dist=None,\n                    plotguinier=True, graph_extension='.png', dmax=None, dmax_from_shanum=False):\n    \"\"\"Perform Guinier analysis on the samples.\n\n    Inputs:\n        samplenames: list of sample names\n        qranges: dictionary of q ranges for each sample. The keys are sample names. The special '__default__' key\n            corresponds to all samples which do not have a key in the dict.\n        qmax_from_shanum: use the qmax determined by the shanum program for the GNOM input.\n        prfunctions_postfix: The figure showing the P(r) functions will be saved as\n            prfunctions_<prfunctions_postfix><graph_extension>\n        dist: the sample-to-detector distance to use.\n        plotguinier: if Guinier plots are needed.\n        graph_extension: the extension of the saved graph image files.\n        dmax: Dict of Dmax parameters. If not found or None, determine automatically using DATGNOM. If found,\n            GNOM is used. The special key '__default__' works in a similar fashion as for `qranges`.\"\"\"\n    figpr = plt.figure()\n    ip = get_ipython()\n    axpr = figpr.add_subplot(1, 1, 1)\n    if qranges is None:\n        qranges = {'__default__': (0, 1000000)}\n    if dmax is None:\n        dmax = {'__default__': None}\n    if '__default__' not in qranges:\n        qranges['__default__'] = (0, 1000000)\n    if '__default__' not in dmax:\n        dmax['__default__'] = None\n    table_autorg = [['Name', 'Rg (nm)', 'I$_0$ (cm$^{-1}$ sr$^{-1}$)',\n                     'q$_{min}$ (nm$^{-1}$)', 'q$_{max}$ (nm$^{-1}$)',\n                     'qmin*Rg', 'qmax*Rg', 'quality', 'aggregation',\n                     'Dmax (nm)', 'q$_{shanum}$ (nm$^{-1}$)']]\n    table_gnom = [['Name', 'Rg (nm)', 'I$_0$ (cm$^{-1}$ sr$^{-1}$)',\n                   'qmin (nm$^{-1}$)', 'qmax (nm$^{-1}$)',\n                   'Dmin (nm)', 'Dmax (nm)', 'Total estimate', 'Porod volume (nm$^3$)']]\n    results = {}\n    for sn in samplenames:\n        if sn not in qranges:\n            print('Q-range not given for sample {}: using default one'.format(sn))\n            qrange = qranges['__default__']\n        else:\n            qrange = qranges[sn]\n        if sn not in dmax:\n            dmax_ = dmax['__default__']\n        else:\n            dmax_ = dmax[sn]\n        print('Using q-range for sample {}: {} <= q <= {}'.format(sn, qrange[0], qrange[1]))\n        curve = getsascurve(sn, dist)[0].trim(*qrange).sanitize()\n\n        curve.save(sn + '.dat')\n        try:\n            Rg, I0, qmin, qmax, quality, aggregation = autorg(sn + '.dat')\n        except ValueError:\n            print('Error running autorg on %s' % sn)\n            continue\n        dmax_shanum, nsh, nopt, qmaxopt = shanum(sn + '.dat')\n        if qmax_from_shanum:\n            curve_trim = curve.trim(qmin, qmaxopt)\n        else:\n            curve_trim = curve.trim(qmin, qrange[1])\n        if dmax_from_shanum:\n            dmax_ = dmax_from_shanum\n        curve_trim.save(sn + '_optrange.dat')\n        if dmax_ is None:\n            print('Calling DATGNOM for sample {} with Rg={}, q-range from {} to {}'.format(\n                sn, Rg.val, curve_trim.q.min(), curve_trim.q.max()))\n            gnompr, metadata = datgnom(sn + '_optrange.dat', Rg=Rg.val, noprint=True)\n        else:\n            print('Calling GNOM for sample {} with Rmax={}, q-range from {} to {}'.format(\n                sn, dmax_, curve_trim.q.min(), curve_trim.q.max()))\n            gnompr, metadata = gnom(curve_trim, dmax_)\n        rg, i0, vporod = datporod(sn + '_optrange.out')\n        axpr.errorbar(gnompr[:, 0], gnompr[:, 1], gnompr[:, 2], None, label=sn)\n        if plotguinier:\n            figsample = plt.figure()\n            axgnomfit = figsample.add_subplot(1, 2, 1)\n            curve.errorbar('b.', axes=axgnomfit, label='measured')\n            axgnomfit.errorbar(metadata['qj'], metadata['jexp'], metadata['jerror'], None, 'g.', label='gnom input')\n            axgnomfit.loglog(metadata['qj'], metadata['jreg'], 'r-', label='regularized by GNOM')\n            figsample.suptitle(sn)\n            axgnomfit.set_xlabel('q (nm$^{-1}$)')\n            axgnomfit.set_ylabel('$d\\Sigma/d\\Omega$ (cm$^{-1}$ sr$^{-1}$)')\n            axgnomfit.axvline(qmaxopt, 0, 1, linestyle='dashed', color='black', lw=2)\n            axgnomfit.grid(True, which='both')\n            axgnomfit.axis('tight')\n            axgnomfit.legend(loc='best')\n            axguinier = figsample.add_subplot(1, 2, 2)\n            axguinier.errorbar(curve.q, curve.Intensity, curve.Error, curve.qError, '.', label='Measured')\n            q = np.linspace(qmin, qmax, 100)\n            axguinier.plot(q, I0.val * np.exp(-q ** 2 * Rg.val ** 2 / 3), label='AutoRg')\n            axguinier.plot(q, metadata['I0_gnom'].val * np.exp(-q ** 2 * metadata['Rg_gnom'].val ** 2 / 3),\n                           label='Gnom')\n            axguinier.set_xscale('power', exponent=2)\n            axguinier.set_yscale('log')\n            axguinier.set_xlabel('q (nm$^{-1}$)')\n            axguinier.set_ylabel('$d\\Sigma/d\\Omega$ (cm$^{-1}$ sr$^{-1}$)')\n            axguinier.legend(loc='best')\n        idxmin = np.arange(len(curve))[curve.q <= qmin].max()\n        idxmax = np.arange(len(curve))[curve.q >= qmax].min()\n        idxmin = max(0, idxmin - 5)\n        idxmax = min(len(curve) - 1, idxmax + 5)\n        if plotguinier:\n            curveguinier = curve.trim(curve.q[idxmin], curve.q[idxmax])\n            axguinier.axis(xmax=curve.q[idxmax], xmin=curve.q[idxmin], ymin=curveguinier.Intensity.min(),\n                           ymax=curveguinier.Intensity.max())\n            axguinier.grid(True, which='both')\n        table_gnom.append(\n                [sn, metadata['Rg_gnom'].tostring(extra_digits=2), metadata['I0_gnom'].tostring(extra_digits=2),\n                 metadata['qmin'], metadata['qmax'],\n                 metadata['dmin'], metadata['dmax'], metadata['totalestimate_corrected'], vporod])\n        table_autorg.append([sn, Rg.tostring(extra_digits=2), I0, '%.3f' % qmin, '%.3f' % qmax, qmin * Rg, qmax * Rg,\n                             '%.1f %%' % (quality * 100), aggregation, '%.3f' % dmax_shanum, '%.3f' % qmaxopt])\n        if plotguinier:\n            figsample.tight_layout()\n            figsample.savefig(os.path.join(ip.user_ns['auximages_dir'], 'guinier_%s%s' % (sn, graph_extension)),\n                              dpi=600)\n        results[sn] = {\n            'Rg_autorg'  : Rg, 'I0_autorg': I0,\n            'qmin_autorg': qmin, 'qmax_autorg': qmax,\n            'quality'    : quality, 'aggregation': aggregation,\n            'dmax_autorg': dmax_shanum, 'qmax_shanum': qmaxopt,\n            'Rg_gnom'    : metadata['Rg_gnom'],\n            'I0_gnom'    : metadata['I0_gnom'],\n            'qmin_gnom'  : metadata['qmin'],\n            'qmax_gnom'  : metadata['qmax'],\n            'dmin_gnom'  : metadata['dmin'],\n            'dmax_gnom'  : metadata['dmax'],\n            'VPorod'     : vporod,\n        }\n    axpr.set_xlabel('r (nm)')\n    axpr.set_ylabel('P(r)')\n    axpr.legend(loc='best')\n    axpr.grid(True, which='both')\n    writemarkdown('## Results from autorg and shanum')\n    tab = ipy_table.IpyTable(table_autorg)\n    tab.apply_theme('basic')\n    display(tab)\n    writemarkdown('## Results from gnom')\n    tab = ipy_table.IpyTable(table_gnom)\n    tab.apply_theme('basic')\n    if prfunctions_postfix and prfunctions_postfix[0] != '_':\n        prfunctions_postfix = '_' + prfunctions_postfix\n    figpr.tight_layout()\n    figpr.savefig(os.path.join(ip.user_ns['auximages_dir'], 'prfunctions%s%s' % (prfunctions_postfix, graph_extension)),\n                  dpi=600)\n    display(tab)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_level(logger=None, log_level=None):\n    '''Set logging levels using logger names.\n\n    :param logger: Name of the logger\n    :type logger: String\n\n    :param log_level: A string or integer corresponding to a Python logging level\n    :type log_level: String\n\n    :rtype: None\n\n    '''\n    log_level = logging.getLevelName(os.getenv('VERBOSITY', 'WARNING'))\n    logging.getLogger(logger).setLevel(log_level)", "response": "Sets the logging level of the logger."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef un_priority(op,val):\n  \"unary expression order-of-operations helper\"\n  if isinstance(val,BinX) and val.op < op: return bin_priority(val.op,UnX(op,val.left),val.right)\n  else: return UnX(op,val)", "response": "unary expression order - of - operations helper"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef lex(string):\n  \"this is only used by tests\"\n  safe_lexer = LEXER.clone() # reentrant? I can't tell, I hate implicit globals. do a threading test\n  safe_lexer.input(string)\n  a = []\n  while 1:\n    t = safe_lexer.token()\n    if t: a.append(t)\n    else: break\n  return a", "response": "this is only used by tests"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse(string):\n  \"return a BaseX tree for the string\"\n  print string\n  if string.strip().lower().startswith('create index'): return IndexX(string)\n  return YACC.parse(string, lexer=LEXER.clone())", "response": "return a BaseX tree for the string"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef p_x_boolx(self,t):\n    # todo: ply exposes precedence with %prec, use it.\n    if len(t)==4: t[0] = bin_priority(t[2],t[1],t[3])\n    elif len(t)==3: t[0] = un_priority(t[1],t[2])\n    else: raise NotImplementedError('unk_len',len(t)) # pragma: no cover", "response": "A boolean expression is a priority expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef p_array(self,t):\n    if len(t)==4: t[0] = ArrayLit(t[2].children)\n    elif len(t)==5: t[0] = ArrayLit(t[3].children)\n    else: raise NotImplementedError('unk_len',len(t)) # pragma: no cover", "response": "A function to parse the array expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef p_fromtable(self,t):\n    if len(t)==6: t[0]=AliasX(t[2],t[5])\n    elif len(t)==2: t[0]=t[1]\n    else: raise NotImplementedError('unk_len',len(t)) # pragma: no cover", "response": "fromtable : NAME\n                 | aliasx\n                 | '(' selectx ')' kw_as NAME"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef p_joinx(self,t):\n    # todo: support join types http://www.postgresql.org/docs/9.4/static/queries-table-expressions.html#QUERIES-JOIN\n    \"\"\"joinx : fromtable jointype fromtable\n             | fromtable jointype fromtable kw_on expression\n             | fromtable jointype fromtable kw_using '(' namelist ')'\n    \"\"\"\n    if len(t)==4: t[0] = JoinX(t[1],t[3],None,t[2])\n    elif len(t)==6: t[0] = JoinX(t[1],t[3],t[5],t[2])\n    else: raise NotImplementedError('todo: join .. using')", "response": "p_joinx is a helper function for joining with joinx"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates an expression in the order of the tablespecs", "response": "def p_createx(self,t):\n    \"\"\"expression : kw_create kw_table nexists NAME '(' tablespecs ')' opt_inheritx\n                  | kw_create kw_table nexists NAME inheritx\n    \"\"\"\n    if len(t)==6:\n      t[0] = CreateX(t[3], t[4], [], None, [], t[5])\n    else:\n      all_constraints = {k:list(group) for k, group in itertools.groupby(t[6], lambda x:type(x))}\n      pkey = (all_constraints.get(PKeyX) or [None])[0] # todo: get pkey from column constraints as well\n      if PKeyX in all_constraints and len(all_constraints[PKeyX]) != 1:\n        raise SQLSyntaxError('too_many_pkeyx', all_constraints[PKeyX])\n      # note below: this is a rare case where issubclass is safe\n      table_constraints = sum([v for k,v in all_constraints.items() if issubclass(k, TableConstraintX)], [])\n      t[0] = CreateX(t[3], t[4], all_constraints.get(ColX) or [], pkey, table_constraints, t[8])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef p_assignlist(self,t):\n    \"assignlist : assignlist ',' assign \\n | assign\"\n    if len(t)==4: t[0] = t[1] + [t[3]]\n    elif len(t)==2: t[0] = [t[1]]\n    else: raise NotImplementedError('unk_len', len(t)) # pragma: no cover", "response": "assignlist : assignlist ',' assign \\ n | assign"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nregisters a function on pypi or gemfury :return:", "response": "def main():\n    \"\"\"\n    register a function on pypi or gemfury\n    :return:\n    \"\"\"\n    setup_main()\n    config = ConfigData(clean=True)\n    try:\n        config.register()\n    finally:\n        config.clean_after_if_needed()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters the model with the registry", "response": "def register(self, model, index):\n        \"\"\"Register the model with the registry\"\"\"\n        self.model_to_indexes[model].add(index)\n        if not self.connected:\n            connections.index_name = {}\n            from django.conf import settings\n            kwargs = {}\n            for name, params in settings.ELASTICSEARCH_CONNECTIONS.items():\n                params = copy.deepcopy(params)\n                kwargs[name] = params\n                connections.index_name[name] = params.pop(\"index_name\")\n            connections.configure(**kwargs)\n            self.connected = True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, instance, **kwargs):\n        for index in self.model_to_indexes[instance.__class__]:\n            if not index._doc_type.ignore_signals:\n                index.update(instance, **kwargs)", "response": "Update all the Index instances attached to this model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load(self):\n        pg = self.usr.getPage(\"http://www.neopets.com/browseshop.phtml?owner=\" + self.owner)\n        \n        # Checks for valid shop\n        if \"doesn't have a shop\" in pg.content:\n            raise invalidShop\n        elif \"not a valid shop\" in pg.content:\n            raise invalidShop\n        elif \"no items for sale\" in pg.content:\n            return\n            \n        try:\n            panel = pg.find(text = \" (owned by \").parent\n            \n            self.name = panel.b.text\n            self.desc = panel.p.text\n            self.welcomeMsg = panel.img.text\n        except Exception:\n            logging.getLogger(\"neolib.shop\").exception(\"Unable to parse shop front content.\", {'pg': pg})\n            raise parseException\n        \n        self.inventory = UserShopFrontInventory(self.usr, self.owner, self.objID, self.price, pg)", "response": "Loads the details and current inventory from the user s website."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bucket(cls, bucket_name, connection=None):\n        connection = cls.connection if connection == None else connection\n\n\n        if bucket_name not in cls._buckets:\n            connection = \"{connection}/{bucket_name}\".format(connection=connection, bucket_name=bucket_name)\n\n            if cls.password:\n                cls._buckets[connection] = Bucket(connection, password=cls.password)\n            else:\n                cls._buckets[connection] = Bucket(connection)\n\n        return cls._buckets[connection]", "response": "Gets the bucket object from couchbase server."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds the open and close braces of the tag we want to start at.", "response": "def find_open_and_close_braces(line_index, start, brace, lines):\n    \"\"\"\n    Take the line where we want to start and the index where we want to start\n    and find the first instance of matched open and close braces of the same\n    type as brace in file file.\n\n    :param: line (int): the index of the line we want to start searching at\n    :param: start (int): the index in the line we want to start searching at\n    :param: brace (string): one of the type of brace we are looking for ({, },\n        [, or ])\n    :param lines ([string, string, ...]): the array of lines in the file we\n        are looking in.\n\n    :return: (start, start_line, end, end_line): (int, int, int): the index\n        of the start and end of whatever braces we are looking for, and the\n        line number that the end is on (since it may be different than the line\n        we started on)\n    \"\"\"\n\n    if brace in ['[', ']']:\n        open_brace = '['\n        close_brace = ']'\n    elif brace in ['{', '}']:\n        open_brace = '{'\n        close_brace = '}'\n    elif brace in ['(', ')']:\n        open_brace = '('\n        close_brace = ')'\n    else:\n        # unacceptable brace type!\n        return (-1, -1, -1, -1)\n\n    open_braces = []\n    line = lines[line_index]\n\n    ret_open_index = line.find(open_brace, start)\n    line_index_cpy = line_index\n    # sometimes people don't put the braces on the same line\n    # as the tag\n    while ret_open_index == -1:\n        line_index = line_index + 1\n        if line_index >= len(lines):\n            # failed to find open braces...\n            return (0, line_index_cpy, 0, line_index_cpy)\n        line = lines[line_index]\n        ret_open_index = line.find(open_brace)\n\n    open_braces.append(open_brace)\n\n    ret_open_line = line_index\n\n    open_index = ret_open_index\n    close_index = ret_open_index\n\n    while len(open_braces) > 0:\n        if open_index == -1 and close_index == -1:\n            # we hit the end of the line!  oh, noez!\n            line_index = line_index + 1\n\n            if line_index >= len(lines):\n                # hanging braces!\n                return (ret_open_index, ret_open_line,\n                        ret_open_index, ret_open_line)\n\n            line = lines[line_index]\n            # to not skip things that are at the beginning of the line\n            close_index = line.find(close_brace)\n            open_index = line.find(open_brace)\n\n        else:\n            if close_index != -1:\n                close_index = line.find(close_brace, close_index + 1)\n            if open_index != -1:\n                open_index = line.find(open_brace, open_index + 1)\n\n        if close_index != -1:\n            open_braces.pop()\n            if len(open_braces) == 0 and \\\n                    (open_index > close_index or open_index == -1):\n                break\n        if open_index != -1:\n            open_braces.append(open_brace)\n\n    ret_close_index = close_index\n\n    return (ret_open_index, ret_open_line, ret_close_index, line_index)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nassembling a caption of a picture into a nice way.", "response": "def assemble_caption(begin_line, begin_index, end_line, end_index, lines):\n    \"\"\"\n    Take the caption of a picture and put it all together\n    in a nice way.  If it spans multiple lines, put it on one line.  If it\n    contains controlled characters, strip them out.  If it has tags we don't\n    want to worry about, get rid of them, etc.\n\n    :param: begin_line (int): the index of the line where the caption begins\n    :param: begin_index (int): the index within the line where the caption\n        begins\n    :param: end_line (int): the index of the line where the caption ends\n    :param: end_index (int): the index within the line where the caption ends\n    :param: lines ([string, string, ...]): the line strings of the text\n\n    :return: caption (string): the caption, formatted and pieced together\n    \"\"\"\n\n    # stuff we don't like\n    label_head = '\\\\label{'\n\n    # reassemble that sucker\n    if end_line > begin_line:\n        # our caption spanned multiple lines\n        caption = lines[begin_line][begin_index:]\n\n        for included_line_index in range(begin_line + 1, end_line):\n            caption = caption + ' ' + lines[included_line_index]\n\n        caption = caption + ' ' + lines[end_line][:end_index]\n        caption = caption.replace('\\n', ' ')\n        caption = caption.replace('  ', ' ')\n    else:\n        # it fit on one line\n        caption = lines[begin_line][begin_index:end_index]\n\n    # clean out a label tag, if there is one\n    label_begin = caption.find(label_head)\n    if label_begin > -1:\n        # we know that our caption is only one line, so if there's a label\n        # tag in it, it will be all on one line.  so we make up some args\n        dummy_start, dummy_start_line, label_end, dummy_end = \\\n                find_open_and_close_braces(0, label_begin, '{', [caption])\n        caption = caption[:label_begin] + caption[label_end + 1:]\n\n    caption = caption.strip()\n\n    if len(caption) > 1 and caption[0] == '{' and caption[-1] == '}':\n        caption = caption[1:-1]\n\n    return caption"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prepare_image_data(extracted_image_data, output_directory,\n                       image_mapping):\n    \"\"\"Prepare and clean image-data from duplicates and other garbage.\n\n    :param: extracted_image_data ([(string, string, list, list) ...],\n        ...])): the images and their captions + contexts, ordered\n    :param: tex_file (string): the location of the TeX (used for finding the\n        associated images; the TeX is assumed to be in the same directory\n        as the converted images)\n    :param: image_list ([string, string, ...]): a list of the converted\n        image file names\n    :return extracted_image_data ([(string, string, list, list) ...],\n        ...])) again the list of image data cleaned for output\n    \"\"\"\n    img_list = {}\n    for image, caption, label in extracted_image_data:\n        if not image or image == 'ERROR':\n            continue\n        image_location = get_image_location(\n            image,\n            output_directory,\n            image_mapping.keys()\n        )\n\n        if not image_location or not os.path.exists(image_location) or \\\n                len(image_location) < 3:\n            continue\n\n        image_location = os.path.normpath(image_location)\n        if image_location in img_list:\n            if caption not in img_list[image_location]['captions']:\n                img_list[image_location]['captions'].append(caption)\n        else:\n            img_list[image_location] = dict(\n                url=image_location,\n                original_url=image_mapping[image_location],\n                captions=[caption],\n                label=label,\n                name=get_name_from_path(image_location, output_directory)\n            )\n    return img_list.values()", "response": "Prepare and clean image - data from duplicates and other garbage."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_image_location(image, sdir, image_list, recurred=False):\n    if isinstance(image, list):\n        # image is a list, not good\n        return None\n\n    image = image.encode('utf-8', 'ignore')\n    image = image.strip()\n\n    figure_or_file = '(figure=|file=)'\n    figure_or_file_in_image = re.findall(figure_or_file, image)\n    if len(figure_or_file_in_image) > 0:\n        image = image.replace(figure_or_file_in_image[0], '')\n\n    includegraphics = r'\\\\includegraphics{(.+)}'\n    includegraphics_in_image = re.findall(includegraphics, image)\n    if len(includegraphics_in_image) > 0:\n        image = includegraphics_in_image[0]\n\n    image = image.strip()\n\n    some_kind_of_tag = '\\\\\\\\\\\\w+ '\n\n    if image.startswith('./'):\n        image = image[2:]\n    if re.match(some_kind_of_tag, image):\n        image = image[len(image.split(' ')[0]) + 1:]\n    if image.startswith('='):\n        image = image[1:]\n\n    if len(image) == 1:\n        return None\n\n    image = image.strip()\n    converted_image_should_be = get_converted_image_name(image)\n\n    if image_list is None:\n        image_list = os.listdir(sdir)\n\n    for png_image in image_list:\n        png_image_rel = os.path.relpath(png_image, start=sdir)\n        if converted_image_should_be == png_image_rel:\n            return png_image\n\n    # maybe it's in a subfolder (TeX just understands that)\n    for prefix in ['eps', 'fig', 'figs', 'figures', 'figs', 'images']:\n        if os.path.isdir(os.path.join(sdir, prefix)):\n            image_list = os.listdir(os.path.join(sdir, prefix))\n            for png_image in image_list:\n                if converted_image_should_be == png_image:\n                    return os.path.join(sdir, prefix, png_image)\n\n    # maybe it is actually just loose.\n    for png_image in os.listdir(sdir):\n        if os.path.split(converted_image_should_be)[-1] == png_image:\n            return converted_image_should_be\n        if os.path.isdir(os.path.join(sdir, png_image)):\n            # try that, too!  we just do two levels, because that's all that's\n            # reasonable..\n            sub_dir = os.path.join(sdir, png_image)\n            for sub_dir_file in os.listdir(sub_dir):\n                if os.path.split(converted_image_should_be)[-1] == sub_dir_file:  # noqa\n                    return os.path.join(sub_dir, converted_image_should_be)\n\n    # maybe it's actually up a directory or two: this happens in nested\n    # tarballs where the TeX is stored in a different directory from the images\n    for png_image in os.listdir(os.path.split(sdir)[0]):\n        if os.path.split(converted_image_should_be)[-1] == png_image:\n            return converted_image_should_be\n    for png_image in os.listdir(os.path.split(os.path.split(sdir)[0])[0]):\n        if os.path.split(converted_image_should_be)[-1] == png_image:\n            return converted_image_should_be\n\n    if recurred:\n        return None\n\n    # agh, this calls for drastic measures\n    for piece in image.split(' '):\n        res = get_image_location(piece, sdir, image_list, recurred=True)\n        if res is not None:\n            return res\n\n    for piece in image.split(','):\n        res = get_image_location(piece, sdir, image_list, recurred=True)\n        if res is not None:\n            return res\n\n    for piece in image.split('='):\n        res = get_image_location(piece, sdir, image_list, recurred=True)\n        if res is not None:\n            return res\n\n    return None", "response": "Take a raw image name + directory and return the location of the image file that is converted to the base directory of the image."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_converted_image_name(image):\n    png_extension = '.png'\n\n    if image[(0 - len(png_extension)):] == png_extension:\n        # it already ends in png!  we're golden\n        return image\n\n    img_dir = os.path.split(image)[0]\n    image = os.path.split(image)[-1]\n\n    # cut off the old extension\n    if len(image.split('.')) > 1:\n        old_extension = '.' + image.split('.')[-1]\n        converted_image = image[:(0 - len(old_extension))] + png_extension\n    else:\n        # no extension... damn\n        converted_image = image + png_extension\n\n    return os.path.join(img_dir, converted_image)", "response": "Returns the name of the image after it has been converted to png format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a TeX file and a current TeX file returns the location of the actual file that we have found.", "response": "def get_tex_location(new_tex_name, current_tex_name, recurred=False):\n    \"\"\"\n    Takes the name of a TeX file and attempts to match it to an actual file\n    in the tarball.\n\n    :param: new_tex_name (string): the name of the TeX file to find\n    :param: current_tex_name (string): the location of the TeX file where we\n        found the reference\n\n    :return: tex_location (string): the location of the other TeX file on\n        disk or None if it is not found\n    \"\"\"\n\n    tex_location = None\n\n    current_dir = os.path.split(current_tex_name)[0]\n\n    some_kind_of_tag = '\\\\\\\\\\\\w+ '\n\n    new_tex_name = new_tex_name.strip()\n    if new_tex_name.startswith('input'):\n        new_tex_name = new_tex_name[len('input'):]\n    if re.match(some_kind_of_tag, new_tex_name):\n        new_tex_name = new_tex_name[len(new_tex_name.split(' ')[0]) + 1:]\n    if new_tex_name.startswith('./'):\n        new_tex_name = new_tex_name[2:]\n    if len(new_tex_name) == 0:\n        return None\n    new_tex_name = new_tex_name.strip()\n\n    new_tex_file = os.path.split(new_tex_name)[-1]\n    new_tex_folder = os.path.split(new_tex_name)[0]\n    if new_tex_folder == new_tex_file:\n        new_tex_folder = ''\n\n    # could be in the current directory\n    for any_file in os.listdir(current_dir):\n        if any_file == new_tex_file:\n            return os.path.join(current_dir, new_tex_file)\n\n    # could be in a subfolder of the current directory\n    if os.path.isdir(os.path.join(current_dir, new_tex_folder)):\n        for any_file in os.listdir(os.path.join(current_dir, new_tex_folder)):\n            if any_file == new_tex_file:\n                return os.path.join(os.path.join(current_dir, new_tex_folder),\n                                    new_tex_file)\n\n    # could be in a subfolder of a higher directory\n    one_dir_up = os.path.join(os.path.split(current_dir)[0], new_tex_folder)\n    if os.path.isdir(one_dir_up):\n        for any_file in os.listdir(one_dir_up):\n            if any_file == new_tex_file:\n                return os.path.join(one_dir_up, new_tex_file)\n\n    two_dirs_up = os.path.join(os.path.split(os.path.split(current_dir)[0])[0],\n                               new_tex_folder)\n    if os.path.isdir(two_dirs_up):\n        for any_file in os.listdir(two_dirs_up):\n            if any_file == new_tex_file:\n                return os.path.join(two_dirs_up, new_tex_file)\n\n    if tex_location is None and not recurred:\n        return get_tex_location(new_tex_name + '.tex', current_tex_name,\n                                recurred=True)\n\n    return tex_location"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a filename by merging path after root directory.", "response": "def get_name_from_path(full_path, root_path):\n    \"\"\"Create a filename by merging path after root directory.\"\"\"\n    relative_image_path = os.path.relpath(full_path, root_path)\n    return \"_\".join(relative_image_path.split('.')[:-1]).replace('/', '_')\\\n        .replace(';', '').replace(':', '')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of security groups that will be added to the authority", "response": "def apply(self, vpc):\n        \"\"\"\n        returns a list of new security groups that will be added\n        \"\"\"\n        assert vpc is not None\n        # make sure we're up to date\n        self.reload_remote_groups()\n\n        vpc_groups = self.vpc_groups(vpc)\n        self._apply_groups(vpc)\n\n        # reloads groups from AWS, the authority\n        self.reload_remote_groups()\n        vpc_groups = self.vpc_groups(vpc)\n\n\n        groups = {k.name:k for k in vpc_groups}\n\n        for x,y in self.config.items():\n            # process 1 security group at a time\n            group = groups[x]\n            if y.get('rules'):\n                # apply all rule changes\n                rules = [Rule.parse(rule) for rule in y.get('rules')]\n                rules = list(itertools.chain(*rules))\n\n                rules = self.filter_existing_rules(rules, group)\n                # need to use chain because multiple rules can be created for a single stanza\n                for rule in rules:\n                    group_name = groups.get(rule.group_name, None)\n                    if group_name and rule.address:\n                        raise Exception(\"Can't auth an address and a group\")\n\n                    logger.debug(\"Authorizing %s %s %s to address:%s name:%s\", rule.protocol,\n                                 rule.from_port, rule.to_port, rule.address, rule.group_name)\n\n                    group_to_authorize = groups.get(rule.group_name, None)\n\n                    try:\n                        group.authorize(rule.protocol,\n                                    rule.from_port,\n                                    rule.to_port,\n                                    rule.address,\n                                    group_to_authorize, None)\n                    except Exception as e:\n                        print \"could not authorize group %s\" % group_to_authorize\n                        raise\n\n                # apply rules\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filter_existing_rules(self, rules, group):\n        tmp = []\n        for rule in rules:\n\n            def eq(x):\n                # returns True if this existing AWS rule matches the one we want to create\n                assert isinstance(x, boto.ec2.securitygroup.IPPermissions)\n                # these are simple catches that determine if we can rule out\n                # the existing rule\n                group_match = False\n                if rule.group_name:\n                    logger.debug(\"Checking for possible group name match %s\", x.grants[0].group_id)\n\n                if rule.group_name and x.grants[0].group_id \\\n                    and rule.group_name != self.get_group(x.grants[0].group_id).name:\n                    logger.debug(\"Group name %s didn't match %s\", rule.group_name, x.grants[0].name)\n                    return False\n\n                if x.ip_protocol != rule.protocol:\n                    logger.debug(\"ruled out due to protocol: %s vs %s\", x.ip_protocol, rule.protocol)\n                    return False\n\n                if int(x.from_port) != int(rule.from_port):\n                    logger.debug(\"ruled out due to from_port: %s vs %s\", int(x.from_port), int(rule.from_port))\n                    return False\n\n                if int(x.to_port) != (rule.to_port):\n                    logger.debug(\"ruled out due to to_port: %s vs %s\", int(x.to_port), int(rule.to_port))\n                    return False\n\n                # final checks - if one of these rules matches we already have a matching rule\n                # and we return True\n                if rule.address and not filter(lambda y: y.cidr_ip == rule.address, x.grants ):\n                    logger.debug(\"%s not found in grants\", rule.address)\n                    return False\n\n                logger.debug(\"%s %s ok\", rule.address, rule.group_name)\n                logger.debug(\"port_from: %s %s\", rule.from_port, x.from_port)\n                logger.debug(\"port_to: %s %s\", rule.to_port, x.to_port)\n                logger.debug(\"group: %s %s\", rule.group_name, x.to_port)\n                return True\n\n            logger.debug(\"Applying rules for %s\", group.name)\n            filtered = filter(eq, group.rules)\n\n            if not filtered:\n                logger.debug(filtered)\n                logger.debug(\"Applying rule %s against %s\", rule, group.rules)\n                tmp.append(rule)\n        return tmp", "response": "returns list of rules with the existing ones filtered out\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef anitya_unmapped_new_update(config, message):\n    if not anitya_new_update(config, message):\n        return False\n\n    for package in message['msg']['message']['packages']:\n        if package['distro'].lower() == 'fedora':\n            return False\n\n    # If none of the packages were listed as Fedora, then this is unmapped.\n    return True", "response": "Check if a new release is unmapped."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef anitya_specific_distro(config, message, distro=None, *args, **kw):\n\n    if not distro:\n        return False\n\n    if not anitya_catchall(config, message):\n        return False\n\n    d = message['msg'].get('distro', {})\n    if d:  # Have to be careful for None here\n        if d.get('name', '').lower() == distro.lower():\n            return True\n\n    d = None\n    p = message['msg'].get('project', {})\n    if p:\n        d = p.get('distro', {})\n    if d:  # Have to be careful for None here\n        if d.get('name', '').lower() == distro.lower():\n            return True\n\n    for pkg in message['msg'].get('message', {}).get('packages', []):\n        if pkg['distro'].lower() == distro.lower():\n            return True\n\n    return False", "response": "Distro - specific release - monitoring. org events\n    This rule will match all anitya events only for a particular distro."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef anitya_by_upstream_project(config, message, projects=None, *args, **kw):\n    # We only deal in anitya messages, first off.\n    if not anitya_catchall(config, message):\n        return False\n\n    if not projects or not isinstance(projects, six.string_types):\n        return False\n\n    # Get the project for the message.\n    project = message.get('msg', {}).get('project', {}).get('name', None)\n\n    # Split the string into a list of targets\n    targets = [p.strip() for p in projects.split(',')]\n    # Filter out empty strings if someone is putting ',,,' garbage in\n    targets = [target for target in targets if target]\n\n    return project in targets", "response": "This rule will let through anything regarding a particular upstream project"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nuse zipped icon. png as icon", "response": "def data(self, index, role):\r\n        \"\"\"use zipped icon.png as icon\"\"\"\r\n        if index.column() == 0 and role == QtCore.Qt.DecorationRole:\r\n            if self.isPyz(index):\r\n                with ZipFile(str(self.filePath(index)), 'r') as myzip:\r\n                    #    print myzip.namelist()\r\n                    try:\r\n                        myzip.extract('icon', self._tmp_dir_work)\r\n                        p = os.path.join(self._tmp_dir_work, 'icon')\r\n                        return QtGui.QIcon(p)\r\n                    except KeyError:\r\n                        pass\r\n        return super(_FileSystemModel, self).data(index, role)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nopen edit replace __main__. py", "response": "def editStartScript(self, index):\r\n        \"\"\"open, edit, replace __main__.py\"\"\"\r\n        f = str(self.fileName(index))\r\n        if f.endswith('.%s' % self.file_type):\r\n            zipname = str(self.filePath(index))\r\n            with ZipFile(zipname, 'a') as myzip:\r\n                # extract+save script in tmp-dir:\r\n                myzip.extract('__main__.py', self._tmp_dir_work)\r\n                tempfilename = f[:-4]\r\n                tempfilepath = os.path.join(self._tmp_dir_work, tempfilename)\r\n                os.rename(\r\n                    os.path.join(\r\n                        self._tmp_dir_work,\r\n                        '__main__.py'),\r\n                    tempfilepath)\r\n                self.openTxt(tempfilepath)\r\n                self._editedSessions[index] = (\r\n                    zipname, self._tmp_dir_work, tempfilename)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef status_messages(self):\n        messages = IStatusMessage(self.request)\n        m = messages.show()\n        for item in m:\n            item.id = idnormalizer.normalize(item.message)\n        return m", "response": "Returns status messages if any"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef users(self):\n        existing_users = self.existing_users()\n        existing_user_ids = [x['id'] for x in existing_users]\n\n        # Only add search results that are not already members\n        sharing = getMultiAdapter((self.my_workspace(), self.request),\n                                  name='sharing')\n        search_results = sharing.user_search_results()\n        users = existing_users + [x for x in search_results\n                                  if x['id'] not in existing_user_ids]\n\n        users.sort(key=lambda x: safe_unicode(x[\"title\"]))\n        return users", "response": "Get current users and add in any search results."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of dicts of items in the current context", "response": "def children(self):\n        \"\"\" returns a list of dicts of items in the current context\n        \"\"\"\n        items = []\n        catalog = self.context.portal_catalog\n        current_path = '/'.join(self.context.getPhysicalPath())\n\n        sidebar_search = self.request.get('sidebar-search', None)\n        if sidebar_search:\n            st = '%s*' % sidebar_search  # XXX plone only allows * as postfix.\n            # With solr we might want to do real substr\n            results = catalog.searchResults(SearchableText=st,\n                                            path=current_path)\n        else:\n            results = self.context.getFolderContents()\n\n        for item in results:\n            # Do some checks to set the right classes for icons and candy\n            desc = (\n                item['Description']\n                and 'has-description'\n                or 'has-no-description'\n            )\n\n            content_type = TYPE_MAP.get(item['portal_type'], 'none')\n\n            mime_type = ''  # XXX: will be needed later for grouping by mimetyp\n            # typ can be user, folder, date and mime typish\n            typ = 'folder'  # XXX: This needs to get dynamic later\n            url = item.getURL()\n\n            ptool = api.portal.get_tool('portal_properties')\n            view_action_types = \\\n                ptool.site_properties.typesUseViewActionInListings\n\n            if content_type in FOLDERISH_TYPES:\n                dpi = (\n                    \"source: #workspace-documents; \"\n                    \"target: #workspace-documents\"\n                )\n                url = url + '/@@sidebar.default#workspace-documents'\n                content_type = 'group'\n            else:\n                if item['portal_type'] in view_action_types:\n                    url = \"%s/view\" % url\n                dpi = (\n                    \"target: #document-body; \"\n                    \"source: #document-body; \"\n                    \"history: record\"\n                )\n                content_type = 'document'\n\n            cls = 'item %s type-%s %s' % (content_type, typ, desc)\n\n            items.append({\n                'id': item['getId'],\n                'cls': cls,\n                'title': item['Title'],\n                'description': item['Description'],\n                'url': url,\n                'type': TYPE_MAP.get(item['portal_type'], 'none'),\n                'mime-type': mime_type,\n                'dpi': dpi})\n        return items"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting all ip v4 addresses of current computer", "response": "def get_ip4():\n    \"\"\"\n    return all ip v4 address of current computer\n    :return:\n    \"\"\"\n    addresses = []\n\n    shell_cmd = \"ifconfig | awk '/inet addr/{print substr($2,6)}'\"\n    proc = subprocess.Popen([shell_cmd], stdout=subprocess.PIPE, shell=True)\n    (out, err) = proc.communicate()\n    ip_addresses = out.split('\\n')\n    for addr in ip_addresses:\n        if re.match(r'\\d{1,4}\\.\\d{1,4}\\.\\d{1,4}\\.\\d{1,4}', addr):\n             addresses.append(addr)\n    return addresses"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(self):\n        '''\n        On the remote host, use an installed virtualenv executable (e.g. the\n        globally installed virtualenv on the path) to create a virutal\n        environment.  The venv directory MUST NOT already exist.\n        '''\n        # require that the venv does not yet exist.\n        if self.exists():\n            raise Exception('Path already exists. Abort creation. venv={}'.format(self.venv))\n\n        # create the venv dir\n        run('mkdir -p {}'.format(self.venv))\n\n        # create the virtual environment\n        run('{virtualenv} {venv}'.format(virtualenv=self.virtualenv, venv=self.venv))", "response": "Create the virutal\n        environment."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef install(self):\n        '''\n        Use pip to install the requirements file.\n        '''\n        remote_path = os.path.join(self.venv, 'requirements.txt')\n        put(self.requirements, remote_path)\n        run('{pip} install -r {requirements}'.format(\n            pip=self.pip(), requirements=remote_path))", "response": "Install the current version of the current user s package."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfreeze the local version of the local version of the local version of the local version of the local version", "response": "def freeze(self):\n        '''\n        Use pip to freeze the requirements and save them to the local\n        requirements.txt file.\n        '''\n        remote_path = os.path.join(self.venv, 'requirements.txt')\n        run('{} freeze > {}'.format(self.pip(), remote_path))\n        get(remote_path, self.requirements)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove(self):\n        '''\n        Remove the virtual environment completely\n        '''\n        print 'remove'\n        if self.exists():\n            print 'cleaning', self.venv\n            run('rm -rf {}'.format(self.venv))", "response": "Remove the virtual environment completely"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds the directories in dirs to sys. path.", "response": "def venv_pth(self, dirs):\n        '''\n        Add the directories in `dirs` to the `sys.path`.  A venv.pth file\n        will be written in the site-packages dir of this virtualenv to add\n        dirs to sys.path.\n\n        dirs: a list of directories.\n        '''\n        # Create venv.pth to add dirs to sys.path when using the virtualenv.\n        text = StringIO.StringIO()\n        text.write(\"# Autogenerated file.  Do not modify.\\n\")\n        for path in dirs:\n            text.write('{}\\n'.format(path))\n        put(text, os.path.join(self.site_packages_dir(), 'venv.pth'), mode=0664)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_to_team(self, **kw):\n        group = self.context.participant_policy.title()\n        data = kw.copy()\n        if \"groups\" in data:\n            data[\"groups\"].add(group)\n        else:\n            data[\"groups\"] = set([group])\n\n        super(PloneIntranetWorkspace, self).add_to_team(**data)", "response": "Add our additional participation related items to the current team"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef group_for_policy(self, policy=None):\n        if policy is None:\n            policy = self.context.participant_policy\n        return \"%s:%s\" % (policy.title(), self.context.UID())", "response": "Lookup the collective. workspace usergroup corresponding to the given policy"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getRoles(self, principal_id):\n        context = self.context\n        current_roles = list(DefaultLocalRoleAdapter.getRoles(\n            self,\n            principal_id,\n        ))\n\n        # check we are not on the workspace itself\n        if IHasWorkspace.providedBy(context):\n            return current_roles\n        # otherwise we should acquire the workspace and check out roles\n        workspace = getattr(context, 'acquire_workspace', lambda: None)()\n        if workspace is None:\n            return current_roles\n\n        workspace_roles = api.user.get_roles(obj=workspace)\n        if 'SelfPublisher' in workspace_roles and 'Owner' in current_roles:\n            current_roles.append('Reviewer')\n        return current_roles", "response": "Get the roles of the user who is a selfpublisher who is also a selfpublisher and the reviewer role."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, method, path_settings, target):\n        self.routes.append(Route(method, path_settings, target))\n        return", "response": "Adds a new route to the list of routes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add2(self, target, path_settings, method):\n        return self.add(method, path_settings, target)", "response": "add2 - add a new entry to the set"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds - Add a new entry to the set", "response": "def add3(self, target, path_settings=None, method='GET'):\n        \"\"\"\n        add() with reordered paameters\n        \"\"\"\n        if path_settings is None:\n            path_settings = []\n        return self.add(method, path_settings, target)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wsgi_server_target(self, wsgi_environment, response_start):\n\n        route_result = {}\n\n        request_method = wsgi_environment['REQUEST_METHOD']\n\n        path_info = wsgi_environment['PATH_INFO']\n\n        if self.PATH_INFO_mode == 'std':\n            path_info = path_info.encode('latin1').decode('utf-8')\n            wsgi_environment['PATH_INFO'] = path_info\n\n        if path_info.startswith('/'):\n            path_info = path_info[1:]\n\n        if path_info in ['/', '']:\n            splitted_path_info = []\n        else:\n            splitted_path_info = path_info.split('/')\n\n        for i in range(len(splitted_path_info)):\n            splitted_path_info[i] = self.unquote_callable(\n                splitted_path_info[i]\n                )\n\n        target = self.default_target\n\n        routing_error = False\n\n        # if len(splitted_path_info) != 0 and len(self.routes) != 0:\n        if len(self.routes) != 0:\n\n            path_segment_to_check_position = 0\n\n            filter_result = copy.copy(self.routes)\n\n            # filter by method\n            for i in range(len(filter_result) - 1, -1, -1):\n                filter_result_i = filter_result[i]\n                if ((filter_result_i.method in [None, False])\n                        or\n                        (filter_result_i.method != True\n                         and not request_method in filter_result_i.method)):\n\n                    del filter_result[i]\n\n            # filter by path settings\n            for i in range(len(splitted_path_info) - 1, -1, -1):\n\n                if len(filter_result) == 0:\n                    break\n\n                filter_result = _filter_routes_by_segment(\n                    splitted_path_info[i],\n                    filter_result,\n                    i\n                    )\n\n                if (len(filter_result) == 1\n                        and filter_result[0].path_settings[i][0] == 'path'):\n                    break\n\n            for i in range(len(filter_result) - 1, -1, -1):\n                if (len(filter_result[i].path_settings) >\n                        len(splitted_path_info)):\n                    del filter_result[i]\n\n            selected_route = None\n\n            filter_result_l = len(filter_result)\n\n            if filter_result_l == 0:\n                routing_error = True\n                logging.error(\"route not found\")\n\n            elif filter_result_l == 1:\n                selected_route = filter_result[0]\n\n            else:\n                routing_error = True\n                logging.error(\"can't find matching route\")\n\n            #print(\"selected_route 1: {}\".format(selected_route))\n            #print(\"route_result 1: {}\".format(route_result))\n\n            if selected_route is not None:\n\n                target = selected_route.target\n\n                for i in range(len(selected_route.path_settings)):\n\n                    selected_route_path_settings_i = \\\n                        selected_route.path_settings[i]\n\n                    if type(selected_route_path_settings_i[2]) == str:\n\n                        selected_route_path_settings_i_0 = \\\n                            selected_route_path_settings_i[0]\n\n                        selected_route_path_settings_i_2 = \\\n                            selected_route_path_settings_i[2]\n\n                        if selected_route_path_settings_i_0 == 'path':\n                            route_result[selected_route_path_settings_i_2] = \\\n                                splitted_path_info[i:]\n                            break\n\n                        elif selected_route_path_settings_i_0 == '=':\n                            route_result[selected_route_path_settings_i_2] = \\\n                                (selected_route.path_settings[i]\n                                 == splitted_path_info[i])\n\n                        elif selected_route_path_settings_i_0 == 'rer':\n                            route_result[selected_route_path_settings_i_2] = \\\n                                selected_route.path_settings[i].match(\n                                    splitted_path_info[i]\n                                    )\n\n                        elif selected_route_path_settings_i_0 in ['fm', 're']:\n                            route_result[selected_route_path_settings_i_2] = \\\n                                splitted_path_info[i]\n\n                        else:\n                            raise Exception(\"programming error\")\n\n            #print(\"route_result 2: {}\".format(route_result))\n\n        if routing_error:\n            logging.error(\n                \"routing error\\n\"\n                \"   asked route is: {}\\n\"\n                \"   starting  route list is: {}\\n\"\n                \"   resulting route list is: {}\".format(\n                    path_info,\n                    self.routes,\n                    filter_result\n                    )\n                )\n\n        if len(self.routes) == 0:\n            logging.warning(\"routes not specified\")\n\n        return target(wsgi_environment, response_start, route_result)", "response": "Search for a target from the routes and passes it to the carafe base class."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving NoneTypes from the dict", "response": "def clean_query_Dict(cls, query_Dict):\n    \"\"\"removes NoneTypes from the dict\n    \"\"\"\n    return {k: v for k, v in query_Dict.items() if v}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting all rooms in a node.", "response": "def list(self, teamId=None, rType=None, maxResults=C.MAX_RESULT_DEFAULT, limit=C.ALL):\n    \"\"\"\n    rType can be DIRECT or GROUP\n    \"\"\"\n    queryParams = {'teamId': teamId,\n            'type': rType,\n            'max': maxResults}\n    queryParams = self.clean_query_Dict(queryParams)\n    ret = self.send_request(C.GET, self.end, data=queryParams, limit=limit)\n    return [Room(self.token, roomData) for roomData in ret['items']]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, title):\n    return self.send_request(C.POST, self.end, data={'title':title})", "response": "Create a new node in the TeleSign Lock."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild a list of flags.", "response": "def get_flag_args(**options):\n    \"\"\"Build a list of flags.\"\"\"\n    flags = []\n    for key, value in options.items():\n        # Build short flags.\n        if len(key) == 1:\n            flag = f'-{key}'\n        # Built long flags.\n        else:\n            flag = f'--{key}'\n        flags = flags + [flag, value]\n    return flags"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_template(template_path, **parameters):\n    path = sanitize_path(template_path)\n    template_file = path.name\n    template_dir = str(path.parent)\n\n    ## Apply ARN of instance role of worker nodes and apply to cluster\n    template_loader = jinja2.FileSystemLoader(searchpath=template_dir)\n    template_env = jinja2.Environment(loader=template_loader)\n\n    template = template_env.get_template(template_file)\n    output_text = template.render(**parameters)\n\n    return output_text", "response": "Use jinja2 to fill in template with given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving special characters and spaces from string and convert to lowercase", "response": "def cleanString(someText):\n    \"\"\"\n    remove special characters and spaces from string\n    and convert to lowercase\n    \"\"\"\n    ret = ''\n    if someText is not None:\n        ret = filter(unicode.isalnum, someText.lower())\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngroup a list of permissions into a dictionary with permission types as keys and sets of entities with access to the resource as values.", "response": "def group_permissions(permissions):\n    \"\"\"\n    Groups a permissions list\n\n    Returns a dictionary, with permission types as keys and sets of entities\n    with access to the resource as values, e.g.:\n\n        {\n            'organisation_id': {\n                'org1': set(['rw', 'r', 'w']),\n                'org2': set(['-']),\n                'org3': set(['r', 'w']),\n            },\n            'all': set(['r'])\n        }\n\n    'org1' has 'rw' access to the resource, 'org2' is denied access and 'org3'\n    has 'r' & 'w' access (the same as 'rw'). Note that 'rw' will always result\n    in 'rw', 'r' & 'w' in the set to make checks easier.\n\n    If present in the resource's permissions, the 'all' permission type is an\n    exception in that it's value is just a set instead of a dictionary.\n\n    :param permissions: a list of permissions\n    :returns: defaultdict\n    \"\"\"\n    groups = defaultdict(lambda: defaultdict(set))\n\n    for p in sorted(permissions, key=itemgetter('type')):\n        permission_set = groups[p['type']][p.get('value')]\n        permission_set.add(p['permission'])\n\n        if p['permission'] == 'rw':\n            permission_set.update({'r', 'w'})\n\n    # the 'all' permission type always has None as the value\n    groups['all'] = groups['all'][None]\n\n    return groups"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_secret(length=30):\n    rand = random.SystemRandom()\n    ascii_characters = string.ascii_letters + string.digits\n\n    return ''.join(rand.choice(ascii_characters) for _ in range(length))", "response": "Generate an ASCII secret using random. SysRandom\n    Based on oauthlib s common. generate_token function"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget all organisations in a given state.", "response": "def all(cls, state=None, include_deactivated=False):\n        \"\"\"\n        Get all organisations\n\n        :param state: State of organisation\n        :param include_deactivated: Flag to include deactivated\n        :returns: list of Organisation instances\n        :raises: SocketError, CouchException\n        \"\"\"\n        if state and state not in validators.VALID_STATES:\n            raise exceptions.ValidationError('Invalid \"state\"')\n        elif state:\n            organisations = yield views.organisations.get(key=state,\n                                                          include_docs=True)\n        elif include_deactivated:\n            organisations = yield views.organisations.get(include_docs=True)\n        else:\n            organisations = yield views.active_organisations.get(include_docs=True)\n\n        raise Return([cls(**org['doc']) for org in organisations['rows']])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the organisations that the user has joined", "response": "def user_organisations(cls, user_id, state=None, include_deactivated=False):\n        \"\"\"\n        Get organisations that the user has joined\n\n        :param user_id: the user ID\n        :param state: the user's \"join\" state\n        :param include_deactivated: Include deactivated resources in response\n        :returns: list of Organisation instances\n        :raises: SocketError, CouchException\n        \"\"\"\n        if state and state not in validators.VALID_STATES:\n            raise exceptions.ValidationError('Invalid \"state\"')\n\n        if include_deactivated:\n            organisations = yield views.joined_organisations.get(\n                key=[user_id, state], include_docs=True)\n        else:\n            organisations = yield views.active_joined_organisations.get(\n                key=[user_id, state], include_docs=True)\n\n        raise Return([cls(**org['doc']) for org in organisations['rows']])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if the user can update the organisation.", "response": "def can_update(self, user, **data):\n        \"\"\"\n        Sys admins can always update an organisation.\n\n        Organisation admins and creators can update, but may not update the following fields:\n\n            - star_rating\n\n        :param user: a User\n        :param data: data that the user wants to update\n        :returns: bool, set of fields that the user was not authorized to update\n        \"\"\"\n        if user.is_admin():\n            raise Return((True, set([])))\n\n        org_admin = user.is_org_admin(self.id)\n        creator = self.created_by == user.id\n        if org_admin or creator:\n            fields = {'star_rating'} & set(data.keys())\n            if fields:\n                raise Return((False, fields))\n            else:\n                raise Return((True, set([])))\n\n        raise Return((False, set([])))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_unique(self):\n        errors = []\n        service_id = getattr(self, 'id', None)\n        fields = [('location', views.service_location),\n                  ('name', views.service_name)]\n\n        for field, view in fields:\n            value = getattr(self, field, None)\n            if not value:\n                continue\n\n            result = yield view.values(key=value)\n            matched = {x['id'] for x in result if x['id'] != service_id}\n            if matched:\n                errors.append(\"Service with {} '{}' already exists\"\n                              .format(field, value))\n\n        if errors:\n            raise exceptions.ValidationError(errors)", "response": "Check the service s name and location are unique"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean(self, user=None):\n        doc = self._resource\n        internal_fields = deepcopy(self.internal_fields)\n        if user is None or not user.is_user(self.organisation_id):\n            internal_fields.append('permissions')\n\n        result = {k: v for k, v in doc.iteritems() if k not in internal_fields}\n\n        return result", "response": "Remove internal fields from the resource"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a service by it s location", "response": "def get_by_location(cls, location, include_deactivated=False):\n        \"\"\"Get a service by it's location\"\"\"\n        if include_deactivated:\n            view = views.service_location\n        else:\n            view = views.active_service_location\n\n        result = yield view.first(key=location, include_docs=True)\n        parent = cls.parent_resource(**result['doc'])\n\n        raise Return(cls(parent=parent, **result['value']))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef all(cls, service_type=None, organisation_id=None, include_deactivated=False):\n        if include_deactivated:\n            resources = yield views.services.get(key=[service_type, organisation_id])\n        else:\n            resources = yield views.active_services.get(key=[service_type, organisation_id])\n\n        # TODO: shouldn't this include the doc as the parent?\n        raise Return([cls(**resource['value']) for resource in resources['rows']])", "response": "Get all resources in the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef can_approve(self, user, **data):\n        is_external = data.get('service_type', self.service_type) == 'external'\n        raise Return(user.is_admin() or is_external)", "response": "Only sys admins can approve a service\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef authenticate(cls, client_id, secret):\n        result = yield views.oauth_client.get(key=[secret, client_id])\n        if not result['rows']:\n            raise Return()\n\n        service = yield Service.get(client_id)\n        raise Return(service)", "response": "Authenticate a client using it s secret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck whether the service is authorized to access the resource.", "response": "def authorized(self, requested_access, resource):\n        \"\"\"\n        Check whether the service is authorized to access the resource\n\n        :param requested_access: \"r\", \"w\", or \"rw\"\n        :param resource: a Resource or SubResource with \"permissions\" attribute\n        :returns: True if has access, False otherwise\n        \"\"\"\n        if {self.state, resource.state} != {State.approved}:\n            return False\n\n        permissions = group_permissions(getattr(resource, 'permissions', []))\n\n        org_permissions = permissions['organisation_id'][self.organisation_id]\n        type_permissions = permissions['service_type'][self.service_type]\n        all_permissions = permissions['all']\n\n        for permission_set in [org_permissions, type_permissions, all_permissions]:\n            if '-' in permission_set:\n                return False\n            elif set([x for x in requested_access]).issubset(permission_set):\n                return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_service(self):\n        try:\n            service = yield Service.get(self.service_id)\n        except couch.NotFound:\n            raise exceptions.ValidationError('Service {} not found'\n                                             .format(self.service_id))\n\n        if service.service_type != 'repository':\n            raise exceptions.ValidationError('{} is not a repository service'\n                                             .format(self.service_id))\n\n        if service.state != State.approved:\n            raise exceptions.ValidationError('{} is not an approved service'\n                                             .format(self.service_id))", "response": "Check the service exists and is a repository service"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks the repository s name is unique", "response": "def check_unique(self):\n        \"\"\"Check the repository's name is unique\"\"\"\n        result = yield views.repository_name.values(key=self.name)\n        repo_id = getattr(self, 'id', None)\n        repos = {x for x in result if x != repo_id and x}\n\n        if repos:\n            raise exceptions.ValidationError(\n                \"Repository with name '{}' already exists\".format(self.name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef can_approve(self, user, **data):\n        service_id = data.get('service_id', self.service_id)\n\n        try:\n            service = yield Service.get(service_id)\n\n            is_repo_admin = user.is_org_admin(service.organisation_id)\n\n            is_reseller_preverifying = user.is_reseller() and data.get('pre_verified', False)\n\n            raise Return(is_repo_admin or is_reseller_preverifying)\n        except couch.NotFound:\n            pass\n\n        raise Return(False)", "response": "Checks if a user can approve a repository service or sys admins."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if user can update the record.", "response": "def can_update(self, user, **kwargs):\n        \"\"\"\n        Sys admin's can change anything\n\n        If the user is an organisation administrator or created the repository,\n        they may change any field other than \"organisation_id\"\n\n        If the user is a service administrator the user may change the \"state\"\n        but no other fields.\n        \"\"\"\n        if user.is_admin():\n            raise Return((True, set([])))\n\n        is_creator = self.created_by == user.id\n        if user.is_org_admin(self.organisation_id) or is_creator:\n            fields = set([])\n            if 'organisation_id' in kwargs:\n                fields.add('organisation_id')\n\n            if fields:\n                raise Return((False, fields))\n            else:\n                raise Return((True, set([])))\n\n        try:\n            service = yield Service.get(self.service_id)\n\n            if user.is_org_admin(service.organisation_id):\n                fields = set(kwargs) - {'state'}\n                if fields:\n                    raise Return((False, fields))\n                else:\n                    raise Return((True, fields))\n        except couch.NotFound:\n            # will be handled in Repository.validate\n            pass\n\n        raise Return((False, set([])))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a cleaned dictionary including relations", "response": "def with_relations(self, user=None):\n        \"\"\"\n        Return a cleaned dictionary including relations\n\n        :returns: a Repository instance\n        \"\"\"\n        repository = self.clean(user=user)\n        try:\n            parent = yield self.get_parent()\n            repository['organisation'] = parent.clean()\n        except couch.NotFound:\n            parent = None\n            repository['organisation'] = {'id': self.parent_id}\n\n        service_id = self.service_id\n        try:\n            # TODO: cache this lookup\n            service = yield Service.get(service_id)\n            repository['service'] = service.clean(user=user)\n        except couch.NotFound:\n            # just include the service ID if cannot find the service\n            repository['service'] = {'id': service_id}\n\n        del repository['service_id']\n        del repository['organisation_id']\n\n        raise Return(repository)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef client_secrets(cls, client_id):\n        secrets = yield cls.view.get(key=client_id, include_docs=True)\n        raise Return([cls(**secret['doc']) for secret in secrets['rows']])", "response": "Get the client s secrets using the client_id\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_all_secrets(cls, user, client_id):\n        can_delete = yield cls(client_id=client_id).can_delete(user)\n        if not can_delete:\n            raise exceptions.Unauthorized('User may not delete {} secrets'\n                                          .format(client_id))\n\n        results = yield cls.view.get(key=client_id, include_docs=True)\n\n        if results['rows']:\n            db = cls.db_client()\n\n            docs = [{\n                '_rev': doc['doc']['_rev'],\n                '_id': doc['doc']['_id'],\n                '_deleted': True\n            } for doc in results['rows']]\n\n            yield db.save_docs(docs)", "response": "Delete all of the client s credentials"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend a contact form message to one or more recipients", "response": "def sendContact(self, context={}):\n    \"\"\"\n    Send contact form message to single or multiple recipients\n    \"\"\"\n    for recipient in self.recipients:\n      super(ContactFormMail, self).__init__(recipient, self.async)\n      self.sendEmail('contactForm', 'New contact form message', context)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef proxify_elt(elt, bases=None, _dict=None, public=False):\n\n    # ensure _dict is a dictionary\n    proxy_dict = {} if _dict is None else _dict.copy()\n    # set of proxified attribute names which are proxified during bases parsing\n    # and avoid to proxify them twice during _dict parsing\n    proxified_attribute_names = set()\n    # ensure bases is a tuple of types\n    if bases is None:\n        bases = (elt if isclass(elt) else elt.__class__,)\n\n    if isinstance(bases, string_types):\n        bases = (lookup(bases),)\n\n    elif isclass(bases):\n        bases = (bases,)\n\n    else:\n        bases = tuple(bases)\n\n    # fill proxy_dict with routines of bases\n    for base in bases:\n        # exclude object\n        if base is object:\n            continue\n        for name, member in getmembers(base, isroutine):\n            # check if name is public\n            if public and not name.startswith('_'):\n                continue\n            eltmember = getattr(elt, name, None)\n            if eltmember is None:\n                raise TypeError(\n                    'Wrong elt {0}. Must implement {1} ({2}) of {3}.'.\n                    format(elt, name, member, base)\n                )\n            # proxify member if member is not a constructor\n            if name not in ['__new__', '__init__']:\n                # get routine from proxy_dict or eltmember\n                routine = proxy_dict.get(name, eltmember)\n                # exclude object methods\n                if getattr(routine, '__objclass__', None) is not object:\n                    # get routine proxy\n                    routine_proxy = proxify_routine(routine)\n                    if ismethod(routine_proxy):\n                        routine_proxy = get_method_function(routine_proxy)\n                    # update proxy_dict\n                    proxy_dict[name] = routine_proxy\n                    # and save the proxified attribute flag\n                    proxified_attribute_names.add(name)\n\n    # proxify proxy_dict\n    for name in proxy_dict:\n        value = proxy_dict[name]\n        if not hasattr(elt, name):\n            raise TypeError(\n                'Wrong elt {0}. Must implement {1} ({2}).'.format(\n                    elt, name, value\n                )\n            )\n        if isroutine(value):\n            # if member has not already been proxified\n            if name not in proxified_attribute_names:\n                # proxify it\n                value = proxify_routine(value)\n            proxy_dict[name] = value\n\n    # set default constructors if not present in proxy_dict\n    if '__new__' not in proxy_dict:\n        proxy_dict['__new__'] = object.__new__\n\n    if '__init__' not in proxy_dict:\n        proxy_dict['__init__'] = object.__init__\n\n    # generate a new proxy class\n    cls = type('Proxy', bases, proxy_dict)\n    # instantiate proxy cls\n    result = cls if isclass(elt) else cls()\n    # bind elt to proxy\n    setattr(result, __PROXIFIED__, elt)\n\n    return result", "response": "Proxify an element to the base classes of the base classes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef proxify_routine(routine, impl=None):\n\n    # init impl\n    impl = routine if impl is None else impl\n\n    is_method = ismethod(routine)\n    if is_method:\n        function = get_method_function(routine)\n    else:\n        function = routine\n\n    # flag which indicates that the function is not a pure python function\n    # and has to be wrapped\n    wrap_function = not hasattr(function, '__code__')\n\n    try:\n        # get params from routine\n        args, varargs, kwargs, _ = getargspec(function)\n    except TypeError:\n        # in case of error, wrap the function\n        wrap_function = True\n\n    if wrap_function:\n        # if function is not pure python, create a generic one\n        # with assignments\n        assigned = []\n        for wrapper_assignment in WRAPPER_ASSIGNMENTS:\n            if hasattr(function, wrapper_assignment):\n                assigned.append(wrapper_assignment)\n        # and updates\n        updated = []\n        for wrapper_update in WRAPPER_UPDATES:\n            if hasattr(function, wrapper_update):\n                updated.append(wrapper_update)\n\n        @wraps(function, assigned=assigned, updated=updated)\n        def wrappedfunction(*args, **kwargs):\n            \"\"\"Default wrap function.\"\"\"\n\n        function = wrappedfunction\n        # get params from function\n        args, varargs, kwargs, _ = getargspec(function)\n\n    name = function.__name__\n\n    result = _compilecode(\n        function=function, name=name, impl=impl,\n        args=args, varargs=varargs, kwargs=kwargs\n    )\n\n    # set wrapping assignments\n    for wrapper_assignment in WRAPPER_ASSIGNMENTS:\n        try:\n            value = getattr(function, wrapper_assignment)\n        except AttributeError:\n            pass\n        else:\n            setattr(result, wrapper_assignment, value)\n\n    # set proxy module\n    result.__module__ = proxify_routine.__module__\n\n    # update wrapping updating\n    for wrapper_update in WRAPPER_UPDATES:\n        try:\n            value = getattr(function, wrapper_update)\n        except AttributeError:\n            pass\n        else:\n            getattr(result, wrapper_update).update(value)\n\n    # set proxyfied element on proxy\n    setattr(result, __PROXIFIED__, routine)\n\n    if is_method:  # create a new method\n        args = [result, get_method_self(routine)]\n        if PY2:\n            args.append(routine.im_class)\n        result = MethodType(*args)\n\n    return result", "response": "Proxify a routine with input impl."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget generated code. :return: function proxy generated code. :rtype: str", "response": "def _compilecode(function, name, impl, args, varargs, kwargs):\n    \"\"\"Get generated code.\n\n    :return: function proxy generated code.\n    :rtype: str\n    \"\"\"\n\n    newcodestr, generatedname, impl_name = _generatecode(\n        function=function, name=name, impl=impl,\n        args=args, varargs=varargs, kwargs=kwargs\n    )\n\n    try:\n        __file__ = getfile(function)\n    except TypeError:\n        __file__ = '<string>'\n\n    # compile newcodestr\n    code = compile(newcodestr, __file__, 'single')\n\n    # define the code with the new function\n    _globals = {}\n    exec_(code, _globals)\n\n    # get new code\n    _var = _globals[generatedname]\n    newco = get_function_code(_var)\n\n    # get new consts list\n    newconsts = list(newco.co_consts)\n\n    if PY3:\n        newcode = list(newco.co_code)\n    else:\n        newcode = [ord(co) for co in newco.co_code]\n\n    consts_values = {impl_name: impl}\n\n    # change LOAD_GLOBAL to LOAD_CONST\n    index = 0\n    newcodelen = len(newcode)\n    while index < newcodelen:\n        if newcode[index] == LOAD_GLOBAL:\n            oparg = newcode[index + 1] + (newcode[index + 2] << 8)\n            name = newco.co_names[oparg]\n            if name in consts_values:\n                const_value = consts_values[name]\n                if const_value in newconsts:\n                    pos = newconsts.index(const_value)\n                else:\n                    pos = len(newconsts)\n                    newconsts.append(consts_values[name])\n                newcode[index] = LOAD_CONST\n                newcode[index + 1] = pos & 0xFF\n                newcode[index + 2] = pos >> 8\n        index += 1\n\n    codeobj = getcodeobj(newconsts, newcode, newco, get_function_code(function))\n    # instanciate a new function\n    if function is None or isbuiltin(function):\n        result = FunctionType(codeobj, {})\n\n    else:\n        result = type(function)(\n            codeobj,\n            get_function_globals(function),\n            function.__name__,\n            get_function_defaults(function),\n            get_function_closure(function)\n        )\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_proxy(elt, bases=None, _dict=None):\n\n    # try to find an instance proxy generator\n    proxygenerator = getattr(elt, __GETPROXY__, None)\n\n    # if a proxy generator is not found, use this module\n    if proxygenerator is None:\n        if isroutine(elt):\n            result = proxify_routine(elt)\n\n        else:  # in case of object, result is a Proxy\n            result = proxify_elt(elt, bases=bases, _dict=_dict)\n\n    else:  # otherwise, use the specific proxy generator\n        result = proxygenerator()\n\n    return result", "response": "Get proxy from an object or function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the proxified element from where get proxified element.", "response": "def proxified_elt(proxy):\n    \"\"\"Get proxified element.\n\n    :param proxy: proxy element from where get proxified element.\n    :return: proxified element. None if proxy is not proxified.\n    \"\"\"\n\n    if ismethod(proxy):\n        proxy = get_method_function(proxy)\n    result = getattr(proxy, __PROXIFIED__, None)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if elt is a proxy.", "response": "def is_proxy(elt):\n    \"\"\"Return True if elt is a proxy.\n\n    :param elt: elt to check such as a proxy.\n    :return: True iif elt is a proxy.\n    :rtype: bool\n    \"\"\"\n\n    if ismethod(elt):\n        elt = get_method_function(elt)\n\n    result = hasattr(elt, __PROXIFIED__)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsafe format for string.", "response": "def safe_format(s, **kwargs):\n  \"\"\"\n  :type s str\n  \"\"\"\n  return string.Formatter().vformat(s, (), defaultdict(str, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef safe_format_sh(s, **kwargs):\n\n  to_replace = set(kwargs.keys()) & set(FORMAT_RE.findall(s))\n\n  for item in to_replace:\n    s = s.replace(\"{{\" + item + \"}}\", kwargs[item])\n\n  return s", "response": "safe_format_sh - safe format for HAR file"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getInstance(cls, *args):\n        '''\n        Returns a singleton instance of the class\n        '''\n        if not cls.__singleton:\n            cls.__singleton = Heroku(*args)\n        return cls.__singleton", "response": "Returns a singleton instance of the class\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ajax_login_required(view_func):\n\n    @wraps(view_func, assigned=available_attrs(view_func))\n    def _wrapped_view(request, *args, **kwargs):\n        if request.is_ajax():\n            if request.user.is_authenticated():\n                return view_func(request, *args, **kwargs)\n            else:\n                response = http.HttpResponse()\n                response['X-Django-Requires-Auth'] = True\n                response['X-Django-Login-Url'] = settings.LOGIN_URL\n                return response\n        else:\n            return login_required(view_func)(request, *args, **kwargs)\n    return _wrapped_view", "response": "Handle non - authenticated users differently if it is an AJAX request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrequire the view is only accessed via AJAX.", "response": "def ajax_only(view_func):\n    \"\"\"Required the view is only accessed via AJAX.\"\"\"\n\n    @wraps(view_func, assigned=available_attrs(view_func))\n    def _wrapped_view(request, *args, **kwargs):\n        if request.is_ajax():\n            return view_func(request, *args, **kwargs)\n        else:\n            return http.HttpResponseBadRequest()\n    return _wrapped_view"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrequire that the user is not logged in.", "response": "def anonymous_required(func=None, url=None):\n    \"\"\"Required that the user is not logged in.\"\"\"\n\n    url = url or \"/\"\n\n    def _dec(view_func):\n        @wraps(view_func, assigned=available_attrs(view_func))\n        def _wrapped_view(request, *args, **kwargs):\n            if request.user.is_authenticated():\n                return redirect(url)\n            else:\n                return view_func(request, *args, **kwargs)\n        return _wrapped_view\n\n    if func is None:\n        return _dec\n    else:\n        return _dec(func)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef secure(view_func):\n\n    @wraps(view_func, assigned=available_attrs(view_func))\n    def _wrapped_view(request, *args, **kwargs):\n        if not request.is_secure():\n            redirect = _redirect(request, True)\n            if redirect:\n                # Redirect might be None if SSL is not enabled\n                return redirect\n        return view_func(request, *args, **kwargs)\n    return _wrapped_view", "response": "Handles SSL redirect on the view level."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef encode_int(n):\n    global ENCODED_INT_CACHE\n\n    try:\n        return ENCODED_INT_CACHE[n]\n    except KeyError:\n        pass\n\n    if n < MIN_29B_INT or n > MAX_29B_INT:\n        raise OverflowError(\"Out of range\")\n\n    if n < 0:\n        n += 0x20000000\n\n    bytes = ''\n    real_value = None\n\n    if n > 0x1fffff:\n        real_value = n\n        n >>= 1\n        bytes += chr(0x80 | ((n >> 21) & 0xff))\n\n    if n > 0x3fff:\n        bytes += chr(0x80 | ((n >> 14) & 0xff))\n\n    if n > 0x7f:\n        bytes += chr(0x80 | ((n >> 7) & 0xff))\n\n    if real_value is not None:\n        n = real_value\n\n    if n > 0x1fffff:\n        bytes += chr(n & 0xff)\n    else:\n        bytes += chr(n & 0x7f)\n\n    ENCODED_INT_CACHE[n] = bytes\n\n    return bytes", "response": "Encodes an integer n into a variable length signed 29 - bit integer as defined by the spec."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decode_int(stream, signed=False):\n    n = result = 0\n    b = stream.read_uchar()\n\n    while b & 0x80 != 0 and n < 3:\n        result <<= 7\n        result |= b & 0x7f\n        b = stream.read_uchar()\n        n += 1\n\n    if n < 3:\n        result <<= 7\n        result |= b\n    else:\n        result <<= 8\n        result |= b\n\n        if result & 0x10000000 != 0:\n            if signed:\n                result -= 0x20000000\n            else:\n                result <<= 1\n                result += 1\n\n    return result", "response": "Decode a C { int } from a stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting a Boolean value to the internal buffer.", "response": "def writeBoolean(self, value):\n        \"\"\"\n        Writes a Boolean value.\n\n        @type value: C{bool}\n        @param value: A C{Boolean} value determining which byte is written.\n        If the parameter is C{True}, C{1} is written; if C{False}, C{0} is\n        written.\n\n        @raise ValueError: Non-boolean value found.\n        \"\"\"\n        if not isinstance(value, bool):\n            raise ValueError(\"Non-boolean value found\")\n\n        if value is True:\n            self.stream.write_uchar(1)\n        else:\n            self.stream.write_uchar(0)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef writeMultiByte(self, value, charset):\n        if type(value) is unicode:\n            value = value.encode(charset)\n\n        self.stream.write(value)", "response": "Writes a multibyte string to the datastream using the specified character set."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef writeUTF(self, value):\n        buf = util.BufferedByteStream()\n        buf.write_utf8_string(value)\n        bytes = buf.getvalue()\n\n        self.stream.write_ushort(len(bytes))\n        self.stream.write(bytes)", "response": "Writes a UTF - 8 string to the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite a UTF - 8 string. Similar to writeUTF but does not prefix the string with a 16 - bit length word.", "response": "def writeUTFBytes(self, value):\n        \"\"\"\n        Writes a UTF-8 string. Similar to L{writeUTF}, but does\n        not prefix the string with a 16-bit length word.\n\n        @type value: C{str}\n        @param value: The string value to be written.\n        \"\"\"\n        val = None\n\n        if isinstance(value, unicode):\n            val = value\n        else:\n            val = unicode(value, 'utf8')\n\n        self.stream.write_utf8_string(val)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef readBoolean(self):\n        byte = self.stream.read(1)\n\n        if byte == '\\x00':\n            return False\n        elif byte == '\\x01':\n            return True\n        else:\n            raise ValueError(\"Error reading boolean\")", "response": "Reads a 1 byte boolean from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readMultiByte(self, length, charset):\n        #FIXME nick: how to work out the code point byte size (on the fly)?\n        bytes = self.stream.read(length)\n\n        return unicode(bytes, charset)", "response": "Reads a multibyte string of specified length from the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread a UTF - 8 string from the data stream.", "response": "def readUTF(self):\n        \"\"\"\n        Reads a UTF-8 string from the data stream.\n\n        The string is assumed to be prefixed with an unsigned\n        short indicating the length in bytes.\n\n        @rtype: C{str}\n        @return: A UTF-8 string produced by the byte\n        representation of characters.\n        \"\"\"\n        length = self.stream.read_ushort()\n        return self.stream.read_utf8_string(length)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a string to the internal list of strings.", "response": "def addString(self, s):\n        \"\"\"\n        Creates a reference to C{s}. If the reference already exists, that\n        reference is returned.\n\n        @type s: C{str}\n        @param s: The string to be referenced.\n        @rtype: C{int}\n        @return: The reference index.\n\n        @raise TypeError: The parameter C{s} is not of C{basestring} type.\n        \"\"\"\n        if not isinstance(s, basestring):\n            raise TypeError\n\n        if len(s) == 0:\n            return -1\n\n        return self.strings.append(s)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a class definition to the class_ref list and returns the reference to the class definition.", "response": "def addClass(self, alias, klass):\n        \"\"\"\n        Creates a reference to C{class_def}.\n\n        @param alias: C{ClassDefinition} instance.\n        \"\"\"\n        ref = self.class_idx\n\n        self.class_ref[ref] = alias\n        cd = self.classes[klass] = alias\n\n        cd.reference = ref\n\n        self.class_idx += 1\n\n        return ref"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getObjectForProxy(self, proxy):\n        obj = self.proxied_objects.get(id(proxy))\n\n        if obj is None:\n            from pyamf import flex\n\n            obj = flex.unproxy_object(proxy)\n\n            self.addProxyObject(obj, proxy)\n\n        return obj", "response": "Returns the unproxied version of the proxy and returns that raw object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a reference to the unproxied and proxied versions of obj for later retrieval.", "response": "def addProxyObject(self, obj, proxied):\n        \"\"\"\n        Stores a reference to the unproxied and proxied versions of C{obj} for\n        later retrieval.\n\n        @since: 0.6\n        \"\"\"\n        self.proxied_objects[id(obj)] = proxied\n        self.proxied_objects[id(proxied)] = obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the proxied version of obj as stored in the context or creates a new proxied object and returns that.", "response": "def getProxyForObject(self, obj):\n        \"\"\"\n        Returns the proxied version of C{obj} as stored in the context, or\n        creates a new proxied object and returns that.\n\n        @see: L{pyamf.flex.proxy_object}\n        @since: 0.6\n        \"\"\"\n        proxied = self.proxied_objects.get(id(obj))\n\n        if proxied is None:\n            from pyamf import flex\n\n            proxied = flex.proxy_object(obj)\n\n            self.addProxyObject(obj, proxied)\n\n        return proxied"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads and returns a utf - 8 encoded byte array.", "response": "def readBytes(self):\n        \"\"\"\n        Reads and returns a utf-8 encoded byte array.\n        \"\"\"\n        length, is_reference = self._readLength()\n\n        if is_reference:\n            return self.context.getString(length)\n\n        if length == 0:\n            return ''\n\n        result = self.stream.read(length)\n        self.context.addString(result)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef readString(self):\n        length, is_reference = self._readLength()\n\n        if is_reference:\n            result = self.context.getString(length)\n\n            return self.context.getStringForBytes(result)\n\n        if length == 0:\n            return ''\n\n        result = self.stream.read(length)\n        self.context.addString(result)\n\n        return self.context.getStringForBytes(result)", "response": "Reads and returns a string from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readDate(self):\n        ref = self.readInteger(False)\n\n        if ref & REFERENCE_BIT == 0:\n            return self.context.getObject(ref >> 1)\n\n        ms = self.stream.read_double()\n        result = util.get_datetime(ms / 1000.0)\n\n        if self.timezone_offset is not None:\n            result += self.timezone_offset\n\n        self.context.addObject(result)\n\n        return result", "response": "Reads a date from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading an array from the stream.", "response": "def readArray(self):\n        \"\"\"\n        Reads an array from the stream.\n\n        @warning: There is a very specific problem with AMF3 where the first\n        three bytes of an encoded empty C{dict} will mirror that of an encoded\n        C{{'': 1, '2': 2}}\n        \"\"\"\n        size = self.readInteger(False)\n\n        if size & REFERENCE_BIT == 0:\n            return self.context.getObject(size >> 1)\n\n        size >>= 1\n\n        key = self.readBytes()\n\n        if key == '':\n            # integer indexes only -> python list\n            result = []\n            self.context.addObject(result)\n\n            for i in xrange(size):\n                result.append(self.readElement())\n\n            return result\n\n        result = pyamf.MixedArray()\n        self.context.addObject(result)\n\n        while key:\n            result[key] = self.readElement()\n            key = self.readBytes()\n\n        for i in xrange(size):\n            el = self.readElement()\n            result[i] = el\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads class definition from the stream.", "response": "def _getClassDefinition(self, ref):\n        \"\"\"\n        Reads class definition from the stream.\n        \"\"\"\n        is_ref = ref & REFERENCE_BIT == 0\n        ref >>= 1\n\n        if is_ref:\n            class_def = self.context.getClassByReference(ref)\n\n            return class_def\n\n        name = self.readBytes()\n        alias = None\n\n        if name == '':\n            name = pyamf.ASObject\n\n        try:\n            alias = pyamf.get_class_alias(name)\n        except pyamf.UnknownClassAlias:\n            if self.strict:\n                raise\n\n            alias = pyamf.TypedObjectClassAlias(name)\n\n        class_def = ClassDefinition(alias)\n\n        class_def.encoding = ref & 0x03\n        class_def.attr_len = ref >> 2\n        class_def.static_properties = []\n\n        if class_def.attr_len > 0:\n            for i in xrange(class_def.attr_len):\n                key = self.readBytes()\n\n                class_def.static_properties.append(key)\n\n        self.context.addClass(class_def, alias.klass)\n\n        return class_def"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef readObject(self):\n        ref = self.readInteger(False)\n\n        if ref & REFERENCE_BIT == 0:\n            obj = self.context.getObject(ref >> 1)\n\n            if obj is None:\n                raise pyamf.ReferenceError('Unknown reference %d' % (ref >> 1,))\n\n            if self.use_proxies is True:\n                obj = self.readProxy(obj)\n\n            return obj\n\n        ref >>= 1\n\n        class_def = self._getClassDefinition(ref)\n        alias = class_def.alias\n\n        obj = alias.createInstance(codec=self)\n        obj_attrs = dict()\n\n        self.context.addObject(obj)\n\n        if class_def.encoding in (ObjectEncoding.EXTERNAL, ObjectEncoding.PROXY):\n            obj.__readamf__(DataInput(self))\n\n            if self.use_proxies is True:\n                obj = self.readProxy(obj)\n\n            return obj\n        elif class_def.encoding == ObjectEncoding.DYNAMIC:\n            self._readStatic(class_def, obj_attrs)\n            self._readDynamic(class_def, obj_attrs)\n        elif class_def.encoding == ObjectEncoding.STATIC:\n            self._readStatic(class_def, obj_attrs)\n        else:\n            raise pyamf.DecodeError(\"Unknown object encoding\")\n\n        alias.applyAttributes(obj, obj_attrs, codec=self)\n\n        if self.use_proxies is True:\n            obj = self.readProxy(obj)\n\n        return obj", "response": "Reads an object from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef readXML(self):\n        ref = self.readInteger(False)\n\n        if ref & REFERENCE_BIT == 0:\n            return self.context.getObject(ref >> 1)\n\n        xmlstring = self.stream.read(ref >> 1)\n\n        x = xml.fromstring(xmlstring)\n        self.context.addObject(x)\n\n        return x", "response": "Reads an xml object from the stream and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef readByteArray(self):\n        ref = self.readInteger(False)\n\n        if ref & REFERENCE_BIT == 0:\n            return self.context.getObject(ref >> 1)\n\n        buffer = self.stream.read(ref >> 1)\n\n        try:\n            buffer = zlib.decompress(buffer)\n            compressed = True\n        except zlib.error:\n            compressed = False\n\n        obj = ByteArray(buffer)\n        obj.compressed = compressed\n\n        self.context.addObject(obj)\n\n        return obj", "response": "Reads a string of data from the stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites a Boolean to the stream.", "response": "def writeBoolean(self, n):\n        \"\"\"\n        Writes a Boolean to the stream.\n        \"\"\"\n        t = TYPE_BOOL_TRUE\n\n        if n is False:\n            t = TYPE_BOOL_FALSE\n\n        self.stream.write(t)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef writeInteger(self, n):\n        if n < MIN_29B_INT or n > MAX_29B_INT:\n            self.writeNumber(float(n))\n\n            return\n\n        self.stream.write(TYPE_INTEGER)\n        self.stream.write(encode_int(n))", "response": "Writes an integer to the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting a float to the stream.", "response": "def writeNumber(self, n):\n        \"\"\"\n        Writes a float to the stream.\n\n        @type n: C{float}\n        \"\"\"\n        self.stream.write(TYPE_NUMBER)\n        self.stream.write_double(n)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef serialiseString(self, s):\n        if type(s) is unicode:\n            s = self.context.getBytesForString(s)\n\n        self.serialiseBytes(s)", "response": "Writes a raw string to the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef writeBytes(self, b):\n        self.stream.write(TYPE_STRING)\n\n        self.serialiseBytes(b)", "response": "Writes a raw string to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef writeString(self, s):\n        s = self.context.getBytesForString(s)\n\n        self.writeBytes(s)", "response": "Writes a string to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites a C { date } instance to the data stream.", "response": "def writeDate(self, n):\n        \"\"\"\n        Writes a C{datetime} instance to the stream.\n\n        @type n: L{datetime}\n        @param n: The C{Date} data to be encoded to the AMF3 data stream.\n        \"\"\"\n        if isinstance(n, datetime.time):\n            raise pyamf.EncodeError('A datetime.time instance was found but '\n                'AMF3 has no way to encode time objects. Please use '\n                'datetime.datetime instead (got:%r)' % (n,))\n\n        self.stream.write(TYPE_DATE)\n\n        ref = self.context.getObjectReference(n)\n\n        if ref != -1:\n            self._writeInteger(ref << 1)\n\n            return\n\n        self.context.addObject(n)\n\n        self.stream.write_uchar(REFERENCE_BIT)\n\n        if self.timezone_offset is not None:\n            n -= self.timezone_offset\n\n        ms = util.get_timestamp(n)\n        self.stream.write_double(ms * 1000.0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites a C { list } to the AMF3 data stream.", "response": "def writeList(self, n, is_proxy=False):\n        \"\"\"\n        Writes a C{tuple}, C{set} or C{list} to the stream.\n\n        @type n: One of C{__builtin__.tuple}, C{__builtin__.set}\n            or C{__builtin__.list}\n        @param n: The C{list} data to be encoded to the AMF3 data stream.\n        \"\"\"\n        if self.use_proxies and not is_proxy:\n            self.writeProxy(n)\n\n            return\n\n        self.stream.write(TYPE_ARRAY)\n\n        ref = self.context.getObjectReference(n)\n\n        if ref != -1:\n            self._writeInteger(ref << 1)\n\n            return\n\n        self.context.addObject(n)\n\n        self._writeInteger((len(n) << 1) | REFERENCE_BIT)\n        self.stream.write('\\x01')\n\n        [self.writeElement(x) for x in n]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites a C { dict } to the AMF3 data stream.", "response": "def writeDict(self, n):\n        \"\"\"\n        Writes a C{dict} to the stream.\n\n        @type n: C{__builtin__.dict}\n        @param n: The C{dict} data to be encoded to the AMF3 data stream.\n        @raise ValueError: Non C{int}/C{str} key value found in the C{dict}\n        @raise EncodeError: C{dict} contains empty string keys.\n        \"\"\"\n        # Design bug in AMF3 that cannot read/write empty key strings\n        # for more info\n        if '' in n:\n            raise pyamf.EncodeError(\"dicts cannot contain empty string keys\")\n\n        if self.use_proxies:\n            self.writeProxy(n)\n\n            return\n\n        self.stream.write(TYPE_ARRAY)\n\n        ref = self.context.getObjectReference(n)\n\n        if ref != -1:\n            self._writeInteger(ref << 1)\n\n            return\n\n        self.context.addObject(n)\n\n        # The AMF3 spec demands that all str based indicies be listed first\n        keys = n.keys()\n        int_keys = []\n        str_keys = []\n\n        for x in keys:\n            if isinstance(x, python.int_types):\n                int_keys.append(x)\n            elif isinstance(x, python.str_types):\n                str_keys.append(x)\n            else:\n                raise ValueError(\"Non int/str key value found in dict\")\n\n        # Make sure the integer keys are within range\n        l = len(int_keys)\n\n        for x in int_keys:\n            if l < x <= 0:\n                # treat as a string key\n                str_keys.append(x)\n                del int_keys[int_keys.index(x)]\n\n        int_keys.sort()\n\n        # If integer keys don't start at 0, they will be treated as strings\n        if len(int_keys) > 0 and int_keys[0] != 0:\n            for x in int_keys:\n                str_keys.append(str(x))\n                del int_keys[int_keys.index(x)]\n\n        self._writeInteger(len(int_keys) << 1 | REFERENCE_BIT)\n\n        for x in str_keys:\n            self.serialiseString(x)\n            self.writeElement(n[x])\n\n        self.stream.write_uchar(0x01)\n\n        for k in int_keys:\n            self.writeElement(n[k])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef writeProxy(self, obj):\n        proxy = self.context.getProxyForObject(obj)\n\n        self.writeObject(proxy, is_proxy=True)", "response": "Writes a proxied object to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites an object to the stream.", "response": "def writeObject(self, obj, is_proxy=False):\n        \"\"\"\n        Writes an object to the stream.\n        \"\"\"\n        if self.use_proxies and not is_proxy:\n            self.writeProxy(obj)\n\n            return\n\n        self.stream.write(TYPE_OBJECT)\n\n        ref = self.context.getObjectReference(obj)\n\n        if ref != -1:\n            self._writeInteger(ref << 1)\n\n            return\n\n        self.context.addObject(obj)\n\n        # object is not referenced, serialise it\n        kls = obj.__class__\n        definition = self.context.getClass(kls)\n        alias = None\n        class_ref = False # if the class definition is a reference\n\n        if definition:\n            class_ref = True\n            alias = definition.alias\n        else:\n            alias = self.context.getClassAlias(kls)\n            definition = ClassDefinition(alias)\n\n            self.context.addClass(definition, alias.klass)\n\n        if class_ref:\n            self.stream.write(definition.reference)\n        else:\n            ref = 0\n\n            if definition.encoding != ObjectEncoding.EXTERNAL:\n                ref += definition.attr_len << 4\n\n            final_reference = encode_int(ref | definition.encoding << 2 |\n                REFERENCE_BIT << 1 | REFERENCE_BIT)\n\n            self.stream.write(final_reference)\n\n            definition.reference = encode_int(\n                definition.reference << 2 | REFERENCE_BIT)\n\n            if alias.anonymous:\n                self.stream.write('\\x01')\n            else:\n                self.serialiseString(alias.alias)\n\n            # work out what the final reference for the class will be.\n            # this is okay because the next time an object of the same\n            # class is encoded, class_ref will be True and never get here\n            # again.\n\n        if alias.external:\n            obj.__writeamf__(DataOutput(self))\n\n            return\n\n        attrs = alias.getEncodableAttributes(obj, codec=self)\n\n        if alias.static_attrs:\n            if not class_ref:\n                [self.serialiseString(attr) for attr in alias.static_attrs]\n\n            for attr in alias.static_attrs:\n                value = attrs.pop(attr)\n\n                self.writeElement(value)\n\n            if definition.encoding == ObjectEncoding.STATIC:\n                return\n\n        if definition.encoding == ObjectEncoding.DYNAMIC:\n            if attrs:\n                for attr, value in attrs.iteritems():\n                    if type(attr) in python.int_types:\n                        attr = str(attr)\n\n                    self.serialiseString(attr)\n                    self.writeElement(value)\n\n            self.stream.write('\\x01')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef writeByteArray(self, n):\n        self.stream.write(TYPE_BYTEARRAY)\n\n        ref = self.context.getObjectReference(n)\n\n        if ref != -1:\n            self._writeInteger(ref << 1)\n\n            return\n\n        self.context.addObject(n)\n\n        buf = str(n)\n        l = len(buf)\n        self._writeInteger(l << 1 | REFERENCE_BIT)\n        self.stream.write(buf)", "response": "Writes a L{ByteArray} to the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef writeXML(self, n):\n        self.stream.write(TYPE_XMLSTRING)\n        ref = self.context.getObjectReference(n)\n\n        if ref != -1:\n            self._writeInteger(ref << 1)\n\n            return\n\n        self.context.addObject(n)\n\n        self.serialiseString(xml.tostring(n).encode('utf-8'))", "response": "Writes an XML string to the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nassociates an HTML element with a tag.", "response": "def v1_tag_associate(request, tags, tag):\n    '''Associate an HTML element with a tag.\n\n    The association should be a JSON serialized object on the\n    request body. Here is an example association that should\n    make the object's structure clear:\n\n    .. code-block:: python\n\n        {\n            \"url\": \"http://example.com/abc/xyz?foo=bar\",\n            \"text\": \"The text the user highlighted.\",\n            \"stream_id\": \"{unix timestamp}-{md5 of url}\",\n            \"hash\": \"{nilsimsa hash of the HTML}\",\n            \"timestamp\": {unix timestamp},\n            \"xpath\": {\n                \"start_node\": \"/html/body/p[1]/text()[2]\",\n                \"start_idx\": 3,\n                \"end_node\": \"/html/body/p[1]/text()[3]\",\n                \"end_idx\": 9\n            }\n        }\n\n    All fields are required and cannot be empty or ``null``.\n\n    The tag of the association should be specified in the URL\n    and is delimited by ``//``.\n    '''\n    tag = tag.decode('utf-8').strip()\n    assoc = dict(json.loads(request.body.read()), **{'tag': tag})\n    tags.add(assoc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef v1_tag_list(tags, tag=''):\n    '''List all direct children tags of the given parent.\n\n    If no parent is specified, then list all top-level tags.\n\n    The JSON returned for ``/dossier/v1/tags/list/foo/bar``\n    might look like this:\n\n    .. code-block:: python\n\n        {\n            'children': [\n                {'name': 'baz', 'parent': 'bar', 'tag': 'foo/bar/baz'},\n            ]\n        }\n    '''\n    tag = tag.decode('utf-8').strip()\n    return {'children': tags.list(tag)}", "response": "List all direct children tags of the given parent."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nproviding fast suggestions for tag components.", "response": "def v1_tag_suggest(request, tags, prefix, parent=''):\n    '''Provide fast suggestions for tag components.\n\n    This yields suggestions for *components* of a tag and a given\n    prefix. For example, given the tags ``foo/bar/baz`` and\n    ``fob/bob``, here are some example completions (ordering may be\n    different):\n\n    .. code-block:: text\n\n        /dossier/v1/tags/suggest/prefix/f => ['foo', 'fob']\n        /dossier/v1/tags/suggest/prefix/foo => ['foo']\n        /dossier/v1/tags/suggest/prefix/b/parent/foo => ['bar']\n        /dossier/v1/tags/suggest/prefix/b/parent/fob => ['bob']\n        /dossier/v1/tags/suggest/prefix/b/parent/foo/bar => ['baz']\n\n    N.B. Each of the lists above are wrapped in the following\n    JSON envelope for the response:\n\n    .. code-block:: text\n\n        {'suggestions': ['foo', 'fob']}\n\n    An optional query parameter, ``limit``, may be passed to control\n    the number of suggestions returned.\n    '''\n    prefix = prefix.decode('utf-8').strip()\n    parent = parent.decode('utf-8').strip()\n    limit = min(10000, int(request.params.get('limit', 100)))\n    return {'suggestions': tags.suggest(parent, prefix, limit=limit)}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef v1_stream_id_associations(tags, stream_id):\n    '''Retrieve associations for a given stream_id.\n\n    The associations returned have the exact same structure as defined\n    in the ``v1_tag_associate`` route with one addition: a ``tag``\n    field contains the full tag name for the association.\n    '''\n    stream_id = stream_id.decode('utf-8').strip()\n    return {'associations': tags.assocs_by_stream_id(stream_id)}", "response": "Retrieve associations for a given stream_id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving associations for a given URL.", "response": "def v1_url_associations(tags, url):\n    '''Retrieve associations for a given URL.\n\n    The associations returned have the exact same structure as defined\n    in the ``v1_tag_associate`` route with one addition: a ``tag``\n    field contains the full tag name for the association.\n    '''\n    url = urllib.unquote_plus(url.decode('utf-8')).strip()\n    return {'associations': tags.assocs_by_url(url)}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving associations for a given tag.", "response": "def v1_tag_associations(tags, tag):\n    '''Retrieve associations for a given tag.\n\n    The associations returned have the exact same structure as defined\n    in the ``v1_tag_associate`` route with one addition: a ``tag``\n    field contains the full tag name for the association.\n    '''\n    tag = tag.decode('utf-8').strip()\n    return {'associations': tags.assocs_by_tag(tag)}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_all(self):\n        '''Deletes all tag data.\n\n        This does not destroy the ES index, but instead only\n        deletes all tags with the configured doc types.\n        '''\n        try:\n            self.conn.indices.delete_mapping(\n                index=self.index, doc_type=self.type_tag)\n        except TransportError:\n            logger.warn('type %r in index %r already deleted',\n                        self.index, self.type_tag, exc_info=True)\n        try:\n            self.conn.indices.delete_mapping(\n                index=self.index, doc_type=self.type_assoc)\n        except TransportError:\n            logger.warn('type %r in index %r already deleted',\n                        self.index, self.type_assoc, exc_info=True)", "response": "Deletes all tag data.\n\n        This does not destroy the ES index, but instead only\n        deletes all tags with the configured doc types."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate the field type mapping.", "response": "def _create_mappings(self):\n        'Create the field type mapping.'\n        created1 = self._create_tag_mapping()\n        created2 = self._create_assoc_mapping()\n        return created1 or created2"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef attrsetter( attribute, *static_value ):\r\n\r\n    if static_value:\r\n        def attrsetter_func(obj):\r\n            setattr( obj, attribute, static_value[0] )\r\n            return obj\r\n    else:\r\n        def attrsetter_func(inst, value):\r\n            setattr( inst, attribute, value )\r\n            return inst\r\n    return attrsetter_func", "response": "Returns an attribute setter function that can be used to set the value of an object attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_last_traceback():\n    import traceback\n    from StringIO import StringIO\n    tb = StringIO()\n    traceback.print_exc(file=tb)\n    return to_unicode(tb.getvalue())", "response": "Retrieve the last traceback as an unicode string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nencode and write a Hip file.", "response": "def write(file_name, data):\n    \"\"\"Encode and write a Hip file.\"\"\"\n    with open(file_name, 'w') as f:\n        f.write(encode(data))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, thread_uuid, uuid):\n        members = (v for v in self.list(thread_uuid) if v.get('userUuid') == uuid)\n        for i in members:\n            self.log.debug(i)\n            return i\n        return None", "response": "Get one thread member."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, wg_uuid, uuid):\n        url = \"%(base)s/%(wg_uuid)s/members/%(uuid)s\" % {\n            'base': self.local_base_url,\n            'wg_uuid': wg_uuid,\n            'uuid': uuid\n        }\n        return self.core.get(url)", "response": "Get one workgroup member."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete one thread member.", "response": "def delete(self, wg_uuid, uuid):\n        \"\"\" Delete one thread member.\"\"\"\n        url = \"%(base)s/%(wg_uuid)s/members/%(uuid)s\" % {\n            'base': self.local_base_url,\n            'wg_uuid': wg_uuid,\n            'uuid': uuid\n        }\n        return self.core.delete(url)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run_from_cli():\n\n    arg_parser = argparse.ArgumentParser(\n        description='Read and write properties in a wp-config.php file. '\n                    'Include a --value argument to set the value, omit it to '\n                    'read the value of the specified key.',\n        prog='python -m wpconfigr')\n\n    arg_parser.add_argument('--filename',\n                            help='wp-config.php filename',\n                            required=True)\n\n    arg_parser.add_argument('--key',\n                            help='Property key',\n                            required=True)\n\n    arg_parser.add_argument('--value',\n                            help='New property value',\n                            required=False)\n\n    arg_parser.add_argument('--log-level',\n                            default='CRITICAL',\n                            help='Log level',\n                            required=False)\n\n    arg_parser.add_argument('--set-true',\n                            action='store_true',\n                            help='Set the value as boolean true')\n\n    arg_parser.add_argument('--set-false',\n                            action='store_true',\n                            help='Set the value as boolean false')\n\n    args = arg_parser.parse_args()\n\n    if args.set_true and args.set_false:\n        arg_parser.error('Cannot set --set-true and --set-false.')\n\n    if args.value and args.set_true:\n        arg_parser.error('Cannot set --value and --set-true.')\n\n    if args.value and args.set_false:\n        arg_parser.error('Cannot set --value and --set-false.')\n\n    basicConfig(level=str(args.log_level).upper())\n\n    updater = WpConfigFile(filename=args.filename)\n\n    if args.set_true:\n        value = True\n    elif args.set_false:\n        value = False\n    else:\n        value = args.value\n\n    if value is not None:\n        updater.set(key=args.key, value=value)\n    else:\n        got = updater.get(key=args.key)\n\n        if got:\n            print(got)", "response": "Perform an update instigated from a CLI."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef manage_file_analysis(args: argparse.Namespace, filename: str, data: object) -> None:\n    key = DataStore.hashfile(filename)\n    print('Analyzing {} --> {}'.format(filename, key))\n    if data.check_key(key):  # if exists in database, prepopulate\n        fit = LineFit(filename, data=data.get_data(key))\n    else:\n        fit = LineFit(filename)\n    if args.time:\n        noise, curvature, rnge, domn = fit.analyze(time=args.time)\n        newrow = [args.time, noise, curvature,\n                  rnge, domn, fit.accepts[args.time]]\n        data.update1(key, newrow, len(fit.noises))\n    else:\n        fit.analyze_full()\n        newrows = np.array([range(len(fit.noises)), fit.noises,\n                            fit.curves, fit.ranges, fit.domains, fit.accepts])\n        data.update(key, newrows)\n    data.save()", "response": "Manage the analysis of a file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting program arguments. Just use --help....", "response": "def get_args() -> argparse.Namespace:\n    \"\"\"\n    Get program arguments.\n\n    Just use --help....\n    \"\"\"\n    parser = argparse.ArgumentParser(prog='python3 linefit.py',\n                                     description=('Parameterize and analyze '\n                                                  'usability of conduit edge data'))\n    parser.add_argument('files', metavar='F', type=str, nargs='*',\n                        help=('File(s) for processing. '\n                              'Each file has a specific format: '\n                              'See README (or header) for specification.'))\n    parser.add_argument('-p', '--plot', action='store_true', default=False,\n                        help=('Create Plot of file(s)? Note, unless --time flag used, '\n                              'will plot middle time.'))\n    parser.add_argument('-pd', '--plotdata', action='store_true', default=False,\n                        help='Create plot of current datastore.')\n    parser.add_argument('-a', '--analyze', action='store_true', default=False,\n                        help=('Analyze the file and determine Curvature/Noise parameters. '\n                              'If --time not specified, will examine entire file. '\n                              'This will add results to datastore with false flags '\n                              'in accept field if not provided.'))\n    parser.add_argument('-mt', '--machinetest', action='store_true', default=False,\n                        help=('Determine if the times from the file are usable based on '\n                              'supervised learning model. If --time not specified, '\n                              'will examine entire file.'))\n    parser.add_argument('-m', '--model', type=str, default='nn',\n                        help=('Learning Model to use. Options are [\"nn\", \"svm\", \"forest\", \"sgd\"]'))\n    parser.add_argument('-nnk', '--nnk', type=int, default=10,\n                        help=('k-Parameter for k nearest neighbors. Google it.'))\n    parser.add_argument('-t', '--time', type=int, default=None,\n                        help=('Time (column) of data to use for analysis OR plotting. '\n                              'Zero-Indexed'))\n    parser.add_argument('-d', '--datastore', type=str, default=DATASTORE,\n                        help=(\"Datastore filename override. \"\n                              \"Don't do this unless you know what you're doing\"))\n    parser.add_argument('-pds', '--printdata', action='store_true', default=False,\n                        help=(\"Print data\"))\n    parser.add_argument('-pdss', '--printdatashort', action='store_true', default=False,\n                        help=(\"Print data short\"))\n    args = parser.parse_args()\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_keys(self) -> typing.List[str]:\n        keys = []\n        for key in self.data.keys():\n            if key not in ['__header__', '__version__', '__globals__']:\n                keys.append(key)\n        return keys", "response": "Return list of SHA512 hash keys that exist in datafile"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if a key exists in the datastore. True if yes False if no.", "response": "def check_key(self, key: str) -> bool:\n        \"\"\"\n        Checks if key exists in datastore. True if yes, False if no.\n\n        :param: SHA512 hash key\n\n        :return: whether or key not exists in datastore\n        \"\"\"\n        keys = self.get_keys()\n        return key in keys"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npulling all available data and concatenates for model training", "response": "def get_traindata(self) -> np.ndarray:\n        \"\"\"\n        Pulls all available data and concatenates for model training\n\n        :return: 2d array of points\n        \"\"\"\n        traindata = None\n        for key, value in self.data.items():\n            if key not in ['__header__', '__version__', '__globals__']:\n                if traindata is None:\n                    traindata = value[np.where(value[:, 4] != 0)]\n                else:\n                    traindata = np.concatenate((traindata, value[np.where(value[:, 4] != 0)]))\n        return traindata"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef plot_traindata(self, name: str='dataplot') -> None:\n        traindata = self.get_traindata()\n\n        plt.figure(figsize=(16, 16))\n        plt.scatter(traindata[:, 1], traindata[:, 2],\n                    c=traindata[:, 5], marker='o', label='Datastore Points')\n        plt.xlabel(r'$\\log_{10}$ Noise')\n        plt.ylabel(r'$\\log_{10}$ Curvature')\n        plt.legend(loc=2, fontsize='xx-large')\n        plt.savefig('./img/{}.png'.format(name))", "response": "Plots the training data for the current thread."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprinting data to stdout", "response": "def printdata(self) -> None:\n        \"\"\" Prints data to stdout \"\"\"\n        np.set_printoptions(threshold=np.nan)\n        print(self.data)\n        np.set_printoptions(threshold=1000)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates entry in datastore", "response": "def update(self, key: str, data: np.ndarray) -> None:\n        \"\"\" Update entry in datastore \"\"\"\n        self.data[key] = data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating one entry in specific record in datastore", "response": "def update1(self, key: str, data: np.ndarray, size: int) -> None:\n        \"\"\" Update one entry in specific record in datastore \"\"\"\n        print(data)\n        if key in self.get_keys():\n            self.data[key][data[0]] = data\n        else:\n            newdata = np.zeros((size, 6))\n            newdata[data[0]] = data\n            self.data[key] = newdata"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a hash of a file using block parsing", "response": "def hashfile(name: str) -> str:\n        \"\"\"\n        Gets a hash of a file using block parsing\n\n        http://stackoverflow.com/questions/3431825/generating-a-md5-checksum-of-a-file\n        Using SHA512 for long-term support (hehehehe)\n        \"\"\"\n        hasher = hashlib.sha512()\n        with open(name, 'rb') as openfile:\n            for chunk in iter(lambda: openfile.read(4096), b''):\n                hasher.update(chunk)\n        return hasher.hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _loadedges(self) -> typing.Tuple[np.ndarray, np.ndarray, np.ndarray, float, np.ndarray]:\n        data = sco.loadmat(self.filename)\n        datakeys = [k for k in data.keys()\n                    if ('right' in k) or ('left' in k) or ('edge' in k)]\n        averagedata = ((data[datakeys[0]] + data[datakeys[1]]) / 2)\n\n        try:\n            times = (data['times'] - data['times'].min())[0]\n        except KeyError:\n            times = np.arange(len(data[datakeys[0]][0]))\n\n        try:\n            accept = data['accept']\n        except KeyError:\n            accept = np.zeros(len(times))\n\n        try:\n            ratio = data['ratio']\n        except KeyError:\n            ratio = 1\n\n        try:\n            viscosity = data['viscosity']\n        except KeyError:\n            viscosity = np.ones(len(times))\n        return averagedata, times, accept, ratio, viscosity", "response": "Load the. mat file and return the averagedata times accept ratio viscosity"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot_file(self, name: str=None, time: int=None) -> None:\n        if not time:\n            time = int(len(self.times) / 2)\n        if not name:\n            name = './img/' + self.filename + '.png'\n        yhat, residuals, residual_mean, noise = self._get_fit(time)\n        plt.figure()\n        plt.scatter(self.domain, self.averagedata[:, time], alpha=0.2)\n        plt.plot(yhat)\n        plt.savefig(name)", "response": "Plot the data for the current time."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _gaussian_function(self, datalength: int, values: np.ndarray,\n                           height: int, index: int) -> np.ndarray:\n        \"\"\"\n        i'th Regression Model Gaussian\n\n        :param: len(x)\n        :param: x values\n        :param: height of gaussian\n        :param: position of gaussian\n\n        :return: gaussian bumps over domain\n        \"\"\"\n        return height * np.exp(-(1 / (self.spread_number * datalength)) *\n                               (values - ((datalength / self.function_number) * index)) ** 2)", "response": "Gaussian function for the given data set and height"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_fit(self, time: int) -> typing.Tuple[np.ndarray, np.ndarray, float, float]:\n        rawdata = self.averagedata[:, time]\n        domain = np.arange(len(rawdata))\n        datalength = len(domain)\n        coefficients = np.zeros((datalength, self.function_number + 2))\n        coefficients[:, 0] = 1\n        coefficients[:, 1] = domain\n        for i in range(self.function_number):\n            coefficients[:, 2 + i] = self._gaussian_function(datalength, domain, 1, i)\n        betas = linalg.inv(coefficients.transpose().dot(coefficients)).dot(coefficients.transpose().dot(rawdata))\n        predicted_values = coefficients.dot(betas)\n        residuals = rawdata - predicted_values\n        error = np.sqrt(residuals.transpose().dot(residuals) / (datalength - (self.function_number + 2)))\n        return predicted_values, residuals, residuals.mean(), error", "response": "Fit regression model to data"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetermines Noise of Residuals.", "response": "def _get_noise(self, residuals: np.ndarray) -> float:\n        \"\"\"\n        Determine Noise of Residuals.\n\n        :param: residuals\n\n        :return: noise\n        \"\"\"\n        return np.mean(np.abs(residuals))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef analyze(self, time: int=None) -> typing.Tuple[float, float, int, int]:\n        if not time:\n            time = int(len(self.times) / 2)\n        if self.domains[time] == 0:\n            yhat, residuals, mean_residual, error = self._get_fit(time)\n            yhat_p = self.ddiff(yhat)\n            yhat_pp = self.ddiff(yhat_p)\n            noise = self._get_noise(residuals)\n            curvature = (1 / self.ratio) * (1 / len(yhat_pp)) * np.sqrt(si.simps(yhat_pp ** 2))\n            rng = (self.ratio * (np.max(self.averagedata[:, time]) -\n                                 np.min(self.averagedata[:, time])))\n            dmn = self.ratio * len(self.averagedata[:, time])\n\n            self.noises[time] = np.log10(noise)\n            self.curves[time] = np.log10(curvature)\n            self.ranges[time] = np.log10(rng)\n            self.domains[time] = np.log10(dmn)\n        return self.noises[time], self.curves[time], self.ranges[time], self.domains[time]", "response": "Determine noise curvature range and domain of specified array."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nanalyze the full data set.", "response": "def analyze_full(self) -> typing.Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Determine noise, curvature, range, and domain of specified data.\n        Like analyze, except examines the entire file.\n\n        :param: float->pixel to inch ratio\n\n        :return: array->curvatures\n        :return: array->noises\n        :return: array->ranges\n        :return: array->domains\n        \"\"\"\n        if self.noises[0] == 0:\n            timelength = len(self.times)\n            for i in tqdm(range(timelength)):\n                self.analyze(time=i)\n        return self.noises, self.curves, self.ranges, self.domains"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn machine learning algorithm based on arguments", "response": "def get_algo(self, args: argparse.Namespace, algo: str) -> object:\n        \"\"\" Returns machine learning algorithm based on arguments \"\"\"\n        if algo == 'nn':\n            return NearestNeighbor(args.nnk)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plot_fitspace(self, name: str, X: np.ndarray, y: np.ndarray, clf: object) -> None:\n        cmap_light = ListedColormap(['#FFAAAA', '#AAFFAA', '#AAAAFF'])\n        cmap_bold = ListedColormap(['#FF0000', '#00FF00', '#0000FF'])\n\n        # Plot the decision boundary. For that, we will assign a color to each\n        # point in the mesh [x_min, m_max]x[y_min, y_max].\n        h = 0.01  # Mesh step size\n        x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n        y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n        xx, yy = np.meshgrid(np.arange(x_min, x_max, h),\n                             np.arange(y_min, y_max, h))\n        Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])\n\n        # Put the result into a color plot\n        Z = Z.reshape(xx.shape)\n        plt.figure()\n        plt.pcolormesh(xx, yy, Z, cmap=cmap_light)\n\n        # Plot also the training points\n        plt.scatter(X[:, 0], X[:, 1], c=y, cmap=cmap_bold)\n        plt.xlim(xx.min(), xx.max())\n        plt.ylim(yy.min(), yy.max())\n        plt.xlabel(r'$\\log_{10}$ Noise')\n        plt.ylabel(r'$\\log_{10}$ Curvature')\n        plt.savefig(name)", "response": "Plot the 2dplane of fitspace"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a connection class for a given service.", "response": "def get_connection(self, service_name):\n        \"\"\"\n        Returns a ``Connection`` **class** for a given service.\n\n        :param service_name: A string that specifies the name of the desired\n            service. Ex. ``sqs``, ``sns``, ``dynamodb``, etc.\n        :type service_name: string\n\n        :rtype: <kotocore.connection.Connection subclass>\n        \"\"\"\n        try:\n            return self.cache.get_connection(service_name)\n        except NotCached:\n            pass\n\n        # We didn't find it. Construct it.\n        new_class = self.connection_factory.construct_for(service_name)\n        self.cache.set_connection(service_name, new_class)\n        return new_class"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_resource(self, service_name, resource_name, base_class=None):\n        try:\n            return self.cache.get_resource(\n                service_name,\n                resource_name,\n                base_class=base_class\n            )\n        except NotCached:\n            pass\n\n        # We didn't find it. Construct it.\n        new_class = self.resource_factory.construct_for(\n            service_name,\n            resource_name,\n            base_class=base_class\n        )\n        self.cache.set_resource(service_name, resource_name, new_class)\n        return new_class", "response": "Returns a resource class for a given service and resource name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_collection(self, service_name, collection_name, base_class=None):\n        try:\n            return self.cache.get_collection(\n                service_name,\n                collection_name,\n                base_class=base_class\n            )\n        except NotCached:\n            pass\n\n        # We didn't find it. Construct it.\n        new_class = self.collection_factory.construct_for(\n            service_name,\n            collection_name,\n            base_class=base_class\n        )\n        self.cache.set_collection(service_name, collection_name, new_class)\n        return new_class", "response": "Returns a new class for the desired\n            class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect_to(self, service_name, **kwargs):\n        service_class = self.get_connection(service_name)\n        return service_class.connect_to(**kwargs)", "response": "Shortcut method to make instantiating the connection classes\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving the form for this form.", "response": "def save(self, **kwargs):\n        \"\"\"\n        Create a ``FormEntry`` instance and related ``FieldEntry``\n        instances for each form field.\n        \"\"\"\n        entry = super(FormForForm, self).save(commit=False)\n        entry.form = self.form\n        entry.entry_time = now()\n        entry.save()\n        entry_fields = entry.fields.values_list(\"field_id\", flat=True)\n        new_entry_fields = []\n        for field in self.form_fields:\n            field_key = \"field_%s\" % field.id\n            value = self.cleaned_data[field_key]\n            if value and self.fields[field_key].widget.needs_multipart_form:\n                value = fs.save(join(\"forms\", str(uuid4()), value.name), value)\n            if isinstance(value, list):\n                value = \", \".join([v.strip() for v in value])\n            if field.id in entry_fields:\n                field_entry = entry.fields.get(field_id=field.id)\n                field_entry.value = value\n                field_entry.save()\n            else:\n                new = {\"entry\": entry, \"field_id\": field.id, \"value\": value}\n                new_entry_fields.append(FieldEntry(**new))\n        if new_entry_fields:\n            FieldEntry.objects.bulk_create(new_entry_fields)\n        return entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef email_to(self):\n        for field in self.form_fields:\n            if issubclass(fields.CLASSES[field.field_type], forms.EmailField):\n                return self.cleaned_data[\"field_%s\" % field.id]\n        return None", "response": "Return the value entered for the first field of type\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the list of selected column names.", "response": "def columns(self):\n        \"\"\"\n        Returns the list of selected column names.\n        \"\"\"\n        fields = [f.label for f in self.form_fields\n                  if self.cleaned_data[\"field_%s_export\" % f.id]]\n        if self.cleaned_data[\"field_0_export\"]:\n            fields.append(self.entry_time_name)\n        return fields"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the list of rows for the given form.", "response": "def rows(self, csv=False):\n        \"\"\"\n        Returns each row based on the selected criteria.\n        \"\"\"\n\n        # Store the index of each field against its ID for building each\n        # entry row with columns in the correct order. Also store the IDs of\n        # fields with a type of FileField or Date-like for special handling of\n        # their values.\n        field_indexes = {}\n        file_field_ids = []\n        date_field_ids = []\n        for field in self.form_fields:\n            if self.cleaned_data[\"field_%s_export\" % field.id]:\n                field_indexes[field.id] = len(field_indexes)\n                if field.is_a(fields.FILE):\n                    file_field_ids.append(field.id)\n                elif field.is_a(*fields.DATES):\n                    date_field_ids.append(field.id)\n        num_columns = len(field_indexes)\n        include_entry_time = self.cleaned_data[\"field_0_export\"]\n        if include_entry_time:\n            num_columns += 1\n\n        # Get the field entries for the given form and filter by entry_time\n        # if specified.\n        field_entries = FieldEntry.objects.filter(\n            entry__form=self.form).order_by(\n            \"-entry__id\").select_related(\"entry\")\n        if self.cleaned_data[\"field_0_filter\"] == FILTER_CHOICE_BETWEEN:\n            time_from = self.cleaned_data[\"field_0_from\"]\n            time_to = self.cleaned_data[\"field_0_to\"]\n            if time_from and time_to:\n                field_entries = field_entries.filter(\n                    entry__entry_time__range=(time_from, time_to))\n\n        # Loop through each field value ordered by entry, building up each\n        # entry as a row. Use the ``valid_row`` flag for marking a row as\n        # invalid if it fails one of the filtering criteria specified.\n        current_entry = None\n        current_row = None\n        valid_row = True\n        for field_entry in field_entries:\n            if field_entry.entry_id != current_entry:\n                # New entry, write out the current row and start a new one.\n                if valid_row and current_row is not None:\n                    if not csv:\n                        current_row.insert(0, current_entry)\n                    yield current_row\n                current_entry = field_entry.entry_id\n                current_row = [\"\"] * num_columns\n                valid_row = True\n                if include_entry_time:\n                    current_row[-1] = field_entry.entry.entry_time\n            field_value = field_entry.value or \"\"\n            # Check for filter.\n            field_id = field_entry.field_id\n            filter_type = self.cleaned_data.get(\"field_%s_filter\" % field_id)\n            filter_args = None\n            if filter_type:\n                if filter_type == FILTER_CHOICE_BETWEEN:\n                    f, t = \"field_%s_from\" % field_id, \"field_%s_to\" % field_id\n                    filter_args = [self.cleaned_data[f], self.cleaned_data[t]]\n                else:\n                    field_name = \"field_%s_contains\" % field_id\n                    filter_args = self.cleaned_data[field_name]\n                    if filter_args:\n                        filter_args = [filter_args]\n            if filter_args:\n                # Convert dates before checking filter.\n                if field_id in date_field_ids:\n                    y, m, d = field_value.split(\" \")[0].split(\"-\")\n                    dte = date(int(y), int(m), int(d))\n                    filter_args.append(dte)\n                else:\n                    filter_args.append(field_value)\n                filter_func = FILTER_FUNCS[filter_type]\n                if not filter_func(*filter_args):\n                    valid_row = False\n            # Create download URL for file fields.\n            if field_entry.value and field_id in file_field_ids:\n                url = reverse(\"admin:form_file\", args=(field_entry.id,))\n                field_value = self.request.build_absolute_uri(url)\n                if not csv:\n                    parts = (field_value, split(field_entry.value)[1])\n                    field_value = mark_safe(\"<a href=\\\"%s\\\">%s</a>\" % parts)\n            # Only use values for fields that were selected.\n            try:\n                current_row[field_indexes[field_id]] = field_value\n            except KeyError:\n                pass\n        # Output the final row.\n        if valid_row and current_row is not None:\n            if not csv:\n                current_row.insert(0, current_entry)\n            yield current_row"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef close(self):\n        if self.marquise_ctx is None:\n            self.__debug(\"Marquise handle is already closed, will do nothing.\")\n            # Multiple close() calls are okay.\n            return\n\n        self.__debug(\"Shutting down Marquise handle spooling to %s and %s\" % (self.spool_path_points, self.spool_path_contents))\n\n        # At the time of writing this always succeeds (returns 0).\n        MARQUISE_SHUTDOWN(self.marquise_ctx)\n\n        # Signal that our context is no longer valid.\n        self.marquise_ctx = None", "response": "Close the Marquise context ensuring that all spool files are closed."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nqueue a simple datapoint (ie. a 64-bit word), return True/False for success. Arguments: address -- uint64_t representing a unique metric. timestamp -- uint64_t representing number of nanoseconds (10^-9) since epoch. value -- uint64_t value being stored. There are no formal restrictions on how `address` is chosen, but it must be unique to the metric you are inserting. If you don't have one, you may generate one by calling `hash_identifier` with a string; the recommended input is the source identifier. If you don't have a `timestamp` you may pass in None to have Pymarquise generate one for you.", "response": "def send_simple(self, address, timestamp, value):\n        \"\"\"Queue a simple datapoint (ie. a 64-bit word), return True/False for success.\n\n        Arguments:\n        address -- uint64_t representing a unique metric.\n        timestamp -- uint64_t representing number of nanoseconds (10^-9) since epoch.\n        value -- uint64_t value being stored.\n\n        There are no formal restrictions on how `address` is chosen,\n        but it must be unique to the metric you are inserting. If you\n        don't have one, you may generate one by calling\n        `hash_identifier` with a string; the recommended input is the\n        source identifier.\n\n        If you don't have a `timestamp` you may pass in None to have\n        Pymarquise generate one for you.\n        \"\"\"\n        if self.marquise_ctx is None:\n            raise ValueError(\"Attempted to write to a closed Marquise handle.\")\n\n        self.__debug(\"Supplied address: %s\" % address)\n\n        if value is None:\n            raise TypeError(\"Can't store None as a value.\")\n\n        if timestamp is None:\n            timestamp = self.current_timestamp()\n\n        # Wrap/convert our arguments to C datatypes before dispatching.\n        # FFI will take care of converting them to the right endianness. I think.\n        c_address =   FFI.cast(\"uint64_t\", address)\n        c_timestamp = FFI.cast(\"uint64_t\", timestamp)\n        c_value =     FFI.cast(\"uint64_t\", value)\n\n        success = MARQUISE_SEND_SIMPLE(self.marquise_ctx, c_address, c_timestamp, c_value)\n        if success != 0:\n            self.__debug(\"send_simple returned %d, raising exception\" % success)\n            raise RuntimeError(\"send_simple was unsuccessful, errno is %d\" % FFI.errno)\n        self.__debug(\"send_simple returned %d\" % success)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_extended(self, address, timestamp, value):\n        if self.marquise_ctx is None:\n            raise ValueError(\"Attempted to write to a closed Marquise handle.\")\n\n        self.__debug(\"Supplied address: %s\" % address)\n\n        if value is None:\n            raise TypeError(\"Can't store None as a value.\")\n\n        value = str(value)\n\n        if timestamp is None:\n            timestamp = self.current_timestamp()\n\n        # Use cast() here to make up the C datatypes for dispatch.\n        # FFI will take care of converting them to the right endianness. I think.\n        c_address =   FFI.cast(\"uint64_t\", address)\n        c_timestamp = FFI.cast(\"uint64_t\", timestamp)\n        # c_value needs to be a byte array with a length in bytes\n        c_value =     cstring(value)\n        c_length =    FFI.cast(\"size_t\", len_cstring(value))\n        self.__debug(\"Sending extended value '%s' with length of %d\" % (value, c_length))\n\n        success = MARQUISE_SEND_EXTENDED(self.marquise_ctx, c_address, c_timestamp, c_value, c_length)\n        if success != 0:\n            self.__debug(\"send_extended returned %d, raising exception\" % success)\n            raise RuntimeError(\"send_extended was unsuccessful, errno is %d\" % FFI.errno)\n        self.__debug(\"send_extended returned %d\" % success)\n\n        return True", "response": "This method sends an extended datapoint to the Marquise system."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_source(self, address, metadata_dict):\n        if self.marquise_ctx is None:\n            raise ValueError(\"Attempted to write to a closed Marquise handle.\")\n\n        self.__debug(\"Supplied address: %s\" % address)\n\n        # Sanity check the input, everything must be UTF8 strings (not\n        # yet confirmed), no Nonetypes or anything stupid like that.\n        #\n        # The keys of the key-value pairs are unique, by virtue of\n        # taking a dict as input.\n        if any([ x is None for x in metadata_dict.keys() ]):\n            raise TypeError(\"One of your metadata_dict keys is a Nonetype\")\n\n        # Values are allowed to be None, coerce to empty strings.\n        metadata_dict = dict([ (x[0],\"\" if x[1] is None else x[1]) for x in metadata_dict.items() ])\n\n        # Cast each string to a C-string. This may have unusual results if your\n        # keys/vals aren't particularly stringy, such as Python classes,\n        # Exceptions, etc. They will get str()'d, and they may look stupid.\n        # pylint: disable=multiple-statements\n        try:                     c_fields = [ cstring(str(x)) for x in metadata_dict.keys() ]\n        except Exception as exc: raise TypeError(\"One of your metadata_dict keys couldn't be cast to a Cstring, %s\" % exc)\n\n        try:                     c_values = [ cstring(str(x)) for x in metadata_dict.values() ]\n        except Exception as exc: raise TypeError(\"One of your metadata_dict values couldn't be cast to a Cstring, %s\" % exc)\n        # pylint: enable=multiple-statements\n\n        # Get our source_dict data structure\n        source_dict = MARQUISE_NEW_SOURCE(c_fields, c_values, len(metadata_dict))\n        if is_cnull(source_dict):\n            raise ValueError(\"errno is set to EINVAL on invalid input, our errno is %d\" % FFI.errno)\n\n        # If you do something stupid, like passing a string where an\n        # int (address) is meant to go, CFFI will explode. Which is\n        # fine, but that causes memory leaks. The explosion still\n        # occurs, but we cleanup after (before?) ourselves.\n        try:\n            success = MARQUISE_UPDATE_SOURCE(self.marquise_ctx, address, source_dict)\n        except TypeError as exc:\n            MARQUISE_FREE_SOURCE(source_dict)\n            raise\n\n        self.__debug(\"marquise_update_source returned %d\" % success)\n        if success != 0:\n            MARQUISE_FREE_SOURCE(source_dict)\n            raise RuntimeError(\"marquise_update_source was unsuccessful, errno is %d\" % FFI.errno)\n\n        MARQUISE_FREE_SOURCE(source_dict)\n        return True", "response": "Update the source_dict for an address and the spool file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _zeo_key(self, key, new_type=OOBTree):\n        zeo_key = self.zeo.get(key, None)\n\n        if zeo_key is None:\n            zeo_key = new_type()\n            self.zeo[key] = zeo_key\n\n        return zeo_key", "response": "Get the key from the zeo database root."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_db_fields(self, obj):\n        for field in obj.indexes:\n            yield field, self._zeo_key(field)", "response": "Returns list of database dictionaries which are used as indexes for\n        each attribute."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck that the object has the right interface.", "response": "def _check_obj_properties(self, pub, name=\"pub\"):\n        \"\"\"\n        Make sure, that `pub` has the right interface.\n\n        Args:\n            pub (obj): Instance which will be checked.\n            name (str): Name of the instance. Used in exception. Default `pub`.\n\n        Raises:\n            InvalidType: When the `pub` is not instance of `obj_type`.\n        \"\"\"\n        if not hasattr(pub, \"indexes\"):\n            raise InvalidType(\"`%s` doesn't have .indexes property!\" % name)\n\n        if not pub.indexes:\n            raise InvalidType(\"`%s.indexes` is not set!\" % name)\n\n        if not hasattr(pub, \"project_key\"):\n            raise InvalidType(\n                \"`%s` doesn't have .project_key property!\" % name\n            )\n\n        if not pub.project_key:\n            raise InvalidType(\"`%s.project_key` is not set!\" % name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nput publication into all indexes.", "response": "def _put_into_indexes(self, obj):\n        \"\"\"\n        Put publication into all indexes.\n\n        Attr:\n            obj (obj): Indexable object.\n\n        Raises:\n            UnindexableObject: When there is no index (property) which can be\n                used to index `obj` in database.\n        \"\"\"\n        no_of_used_indexes = 0\n        for field_name, db_index in list(self._get_db_fields(obj)):\n            attr_value = getattr(obj, field_name)\n\n            if attr_value is None:  # index only by set attributes\n                continue\n\n            container = db_index.get(attr_value, None)\n            if container is None:\n                container = OOTreeSet()\n                db_index[attr_value] = container\n\n            container.insert(obj)\n\n            no_of_used_indexes += 1\n\n        # make sure that atleast one `attr_value` was used\n        if no_of_used_indexes <= 0:\n            raise UnindexableObject(\n                \"You have to use atleast one of the identificators!\"\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef store_object(self, obj):\n        self._check_obj_properties(obj)\n\n        with transaction.manager:\n            self._put_into_indexes(obj)", "response": "Store the object into database and into proper indexes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_subset_matches(self, query):\n        for field_name, db_index in self._get_db_fields(query):\n            attr = getattr(query, field_name)\n\n            if attr is None:  # don't use unset attributes\n                continue\n\n            results = db_index.get(attr, OOTreeSet())\n\n            if results:\n                yield results", "response": "Yields publications at indexes defined by query property values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef search_objects(self, query):\n        self._check_obj_properties(query, \"query\")\n\n        # AND operator between results\n        final_result = None\n        for result in self._get_subset_matches(query):\n            if final_result is None:\n                final_result = result\n                continue\n\n            final_result = intersection(final_result, result)\n\n        # if no result is found, `final_result` is None, and I want []\n        if not final_result:\n            return []\n\n        return list(final_result)", "response": "Search objects in DBPublication database for objects that match the query."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _wrap_measure(individual_group_measure_process, group_measure, loaded_processes): \n    def wrapped_measure(state_collection,overriding_parameters=None,loggers=None):\n        if loggers == None:\n            loggers = funtool.logger.set_default_loggers()\n        if loaded_processes != None :\n            if group_measure.grouping_selectors != None:\n                for grouping_selector_name in group_measure.grouping_selectors:\n                    state_collection= funtool.state_collection.add_grouping(state_collection, grouping_selector_name, loaded_processes) \n                    for group in funtool.state_collection.groups_in_grouping(state_collection, grouping_selector_name):\n                        analysis_collection = funtool.analysis.AnalysisCollection(None,group,{},{})\n                        if group_measure.analysis_selectors != None:\n                            for analysis_selector in group_measure.analysis_selectors:\n                                analysis_collection = loaded_processes[\"analysis_selector\"][analysis_selector].process_function(analysis_collection,state_collection)\n                        if analysis_collection != None:\n                            individual_group_measure_process(analysis_collection,state_collection)\n        return state_collection\n    return wrapped_measure", "response": "Wraps a function that creates analysis_collections for each group in the collection."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_limits(self, min_=None, max_=None):\n        self._min, self._max = min_, max_", "response": "Sets the minimum and maximum value for this config value."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints an instance s AWS account number or 0 when not in EC2 \u2013", "response": "def getAWSAccountID():\n  '''\n  Print an instance's AWS account number or 0 when not in EC2\n  '''\n  link = \"http://169.254.169.254/latest/dynamic/instance-identity/document\"\n  try:\n    conn = urllib2.urlopen(url=link, timeout=5)\n  except urllib2.URLError:\n    return '0'\n  jsonData = json.loads(conn.read())\n  return jsonData['accountId']"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef readInstanceTag(instanceID, tagName=\"Name\", connection=None):\n  assert isinstance(instanceID, basestring), (\"instanceID must be a string but is %r\" % instanceID)\n  assert isinstance(tagName, basestring), (\"tagName must be a string but is %r\" % tagName)\n\n  if not connection:\n    # Assume AWS credentials are in the environment or the instance is using an IAM role\n    connection = boto.ec2.connect_to_region(myRegion())\n\n  # Filter the tag values for our instance_id\n  # http://docs.aws.amazon.com/AWSEC2/latest/CommandLineReference/ApiReference-cmd-DescribeTags.html\n  tagData = connection.get_all_tags(filters={\"resource-id\": instanceID, \"key\": tagName})\n  if tagData:\n    tagValue = tagData[0].value\n  else:\n    raise RuntimeError, \"%s: No such tag on %s\" % (tagName, instanceID)\n  return tagValue", "response": "Load a tag from EC2\n."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading an EC2 tag for the running instance & print it.", "response": "def readMyEC2Tag(tagName, connection=None):\n  \"\"\"\n  Load an EC2 tag for the running instance & print it.\n\n  :param str tagName: Name of the tag to read\n  :param connection: Optional boto connection\n  \"\"\"\n  assert isinstance(tagName, basestring), (\"tagName must be a string but is %r\" % tagName)\n\n  # Load metadata. if == {} we are on localhost\n  # http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AESDG-chapter-instancedata.html\n\n  if not connection:\n    # Assume AWS credentials are in the environment or the instance is using an IAM role\n    connection = boto.ec2.connect_to_region(myRegion())\n\n  return readInstanceTag(connection=connection,\n                         instanceID=myInstanceID(),\n                         tagName=tagName)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ver_to_tuple(value):\n    return tuple(int(_f) for _f in re.split(r'\\D+', value) if _f)", "response": "Convert version like string to a tuple of integers."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef increment_name(self, name, i):\n        if i == 0:\n            return name\n        if '.' in name:\n            split = name.split('.')\n            split[-2] = split[-2] + str(i)\n            return '.'.join(split)\n        else:\n            return name + str(i)", "response": "Increment the name of a resource by i."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_name(self, name, overwrite=False, increment=True):\n\n        # check if the file exists\n        exists = os.path.exists(os.path.join(self._path, self.increment_name(name, 0)))\n\n        # make sure that we dont overwrite if overwrite and increment are both false\n        warning = \"Filename and path already exists, refusing to set filename without overwrite=True or increment=True\"\n        assert not (exists and not overwrite and not increment), warning\n\n        if overwrite is True:\n            increment = False\n\n        # otherwise overwrite the file\n        if increment is False:\n            self.filepath = os.path.join(self._path, self.increment_name(name, 0))\n            self.name = self.increment_name(name, 0)\n            return self.name\n\n        # or increment the filename\n        i = 0\n        while os.path.exists(os.path.join(self._path, self.increment_name(name, i))):\n            i += 1\n        self.name = self.increment_name(name, i)\n        self.filepath = os.path.join(self._path, self.increment_name(name, i))\n        return self.name", "response": "Sets the name of the file to be saved."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_local_metadata(self):\n        # save to the set local path and add .json\n        with open(self.filepath + '.json', 'w+') as outfile:\n            json.dump(self._prep_metadata(), outfile, indent=4)", "response": "Save all the exposed variables to a json file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate a multipart upload etag in the same way as amazon s3", "response": "def calculate_etag(self, expected=None):\n        \"\"\"\n            calculates a multipart upload etag in the same way as amazon s3\n            args:\n                source_path -- The file to calculate the etage for\n                chunk_size -- The chunk size to calculate for.\n                expected -- optional If passed a string, the string\n                will be compared to the resulting etag and raise an\n                exception if they don't match\n        \"\"\"\n        md5s = []\n        with open(self.filepath, 'rb') as fp:\n            while True:\n                data = fp.read(CHUNK_SIZE)\n                if not data:\n                    break\n                md5s.append(hashlib.md5(data))\n\n        digests = b\"\".join(m.digest() for m in md5s)\n\n        new_md5 = hashlib.md5(digests)\n        new_etag = '%s-%s' % (new_md5.hexdigest(),len(md5s))\n        self.etag = new_etag\n\n        return new_etag"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the impediments from a single XML file.", "response": "def get_impediments():\n    \"\"\"\n    :raise urllib2.URLError | urllib.error.URLError: When\n    :return:\n    \"\"\"\n    file = urlopen(XML_URL)\n\n    doc = dom.parse(file)\n    xml = doc.documentElement\n\n    nodes = xml.getElementsByTagName('utr')\n    impediments = [extract(node) for node in nodes]\n\n    return impediments"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef initialize():\n    try:\n        requests.get('http://localhost:4242/poll')\n        state['connected_to_bot'] = True\n    except requests.exceptions.ConnectionError:\n        state['connected_to_bot'] = False\n\n    # set up turtle\n    state['window'] = turtle.Screen()\n    state['window'].setup(width=AXI_WIDTH, height=AXI_HEIGHT)\n    state['turtle'] = turtle.Turtle()\n    state['turtle'].width(2)\n    state['turtle'].speed(0)\n    point_in_direction(0)\n\n    pen_up()", "response": "Initialize the ARIMA - specific Turtle object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef move_forward(num_steps):\n    assert int(num_steps) == num_steps, \"move_forward() only accepts integers, but you gave it \" + str(num_steps)\n\n    _make_cnc_request(\"move.forward./\" + str(num_steps))\n\n    state['turtle'].forward(num_steps)", "response": "Moves the pen forward a few steps in the direction that turtle is facing."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef command_banner(title, banner_colour='white'):\n    size = get_terminal_size()\n\n    def decorator(function):\n        \"\"\"Use this function to create the basic decorator.\n\n        This function is used for defining the decorator and having the outer\n        function pass the variables passed to this decorator for use in the\n        wrapper function.\n\n        :param function: the function to decorate.\n        :type function: n/a\n        :return: the results of the wrapper function.\n        :rtype: n/a\n        \"\"\"\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            \"\"\"Use this function to wrap the decorated function.\n\n            This function is used for providing the banner around the\n            decorated function.\n            \"\"\"\n            banner_length = size[0] - 3\n            top_banner_length = banner_length - len(title) - 2\n            echo('')\n            secho('|{0} {1} {0}|'.format(\n                '-' * floor(top_banner_length / 2), title\n            ), fg=banner_colour)\n            echo('')\n            function(*args, **kwargs)\n            echo('')\n            secho('|{0}|'.format('-' * banner_length), fg=banner_colour)\n            echo('')\n        return wrapper\n    return decorator", "response": "Decorator for showing a banner before and after a command."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a new value to the array.", "response": "def add(self, v):\n    \"\"\"Add a new value.\"\"\"\n    self._vals_added += 1\n    if self._mean is None:\n      self._mean = v\n    self._mean = self._mean + ((v - self._mean) / float(self._vals_added))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _build_trees_by_chrom(blocks, verbose=False):\n  if verbose:\n    sys.stderr.write(\"separating blocks by chromosome... \")\n  by_chrom = {}\n  for b in blocks:\n    if b.chrom not in by_chrom:\n      by_chrom[b.chrom] = []\n    by_chrom[b.chrom].append(b)\n  if verbose:\n    sys.stderr.write(\"done\\n\")\n\n  if verbose:\n    sys.stderr.write(\"building interval trees by chromosome... \")\n  res = {}\n  for c in by_chrom:\n    res[c] = IntervalTree(by_chrom[c], openEnded=True)\n  if verbose:\n    sys.stderr.write(\"done\\n\")\n\n  return res", "response": "Construct set of interval trees from an iterable of genome alignment blocks."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a column from the block at the specified position", "response": "def get_column_absolute(self, position,\n                          miss_seqs=MissingSequenceHandler.TREAT_AS_ALL_GAPS,\n                          species=None):\n    \"\"\"\n    return a column from the block as dictionary indexed by seq. name.\n\n    :param position:  the index to extract from the block; must be absolute\n                      coordinates (i.e. between self.start and self.end, not\n                      inclusive of the end).\n    :param miss_seqs: how to treat sequence with no actual sequence data for\n                      the column.\n    :return: dictionary where keys are sequence names and values are\n             nucleotides (raw strings).\n    \"\"\"\n    if position < self.start or position >= self.end:\n      raise ValueError(\"getting column at genomic locus \" + self._chrom + \" \" +\n                       str(position) + \" failed; locus is outside of genome \" +\n                       \"alignment block\")\n\n    rel_coord = self.sequence_to_alignment_coords(self.reference_sequence_name,\n                                                  position, position + 1)\n    assert(len(rel_coord) == 1)\n    rel_start, rel_end = rel_coord[0]\n    assert(rel_end == rel_start + 1)\n    raw_col = self.get_column(rel_start, miss_seqs)\n\n    if species is None:\n      return raw_col\n    res = {}\n    for k in raw_col:\n      name_parts = k.split(\".\")\n      if name_parts[0] in species:\n        res[k] = raw_col[k]\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_blocks(self, chrom, start, end):\n    if chrom not in self.block_trees:\n      return []\n    return self.block_trees[chrom].intersectingInterval(start, end)", "response": "Get any blocks in this alignment that overlap a given genomic interval."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the column at the specified chromosome and position.", "response": "def get_column(self, chrom, position,\n                 missing_seqs=MissingSequenceHandler.TREAT_AS_ALL_GAPS,\n                 species=None):\n    \"\"\"Get the alignment column at the specified chromosome and position.\"\"\"\n    blocks = self.get_blocks(chrom, position, position + 1)\n    if len(blocks) == 0:\n      raise NoSuchAlignmentColumnError(\"Request for column on chrom \" +\n                                       chrom + \" at position \" +\n                                       str(position) + \" not possible; \" +\n                                       \"genome alignment not defined at \" +\n                                       \"that locus.\")\n    if len(blocks) > 1:\n      raise NoUniqueColumnError(\"Request for column on chrom \" + chrom +\n                                \" at position \" + str(position) + \"not \" +\n                                \"possible; ambiguous alignment of that locus.\")\n\n    return blocks[0].get_column_absolute(position, missing_seqs, species)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __get_keys(self, chrom, start, end=None):\n    keys = []\n    if chrom in self.whole_chrom_files:\n      keys.append(self.whole_chrom_files[chrom])\n    if chrom in self.partial_trees:\n      if end is not None:\n        hits = self.partial_trees[chrom].intersectingInterval(start, end)\n      else:\n        hits = self.partial_trees[chrom].intersectingPoint(start, end)\n      for hit in hits:\n        keys.append(hit.key)\n    return keys", "response": "Get the hash keys in whole or partial_trees that overlap the interval."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting any blocks in this alignment that overlap a given genomic interval.", "response": "def get_blocks(self, chrom, start, end):\n    \"\"\"\n    Get any blocks in this alignment that overlap the given location.\n\n    :return: the alignment blocks that overlap a given genomic interval;\n             potentially none, in which case the empty list is returned.\n    \"\"\"\n    blocks = []\n    for k in self.__get_keys(chrom, start, end):\n      self.__switch_alig(k)\n      blocks += self.current.get_blocks(chrom, start, end)\n    return blocks"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_site_metas(with_static=False, with_media=False, is_secure=False,\n                   extra={}):\n    \"\"\"\n    Return metas from the current *Site* and settings\n\n    Added Site metas will be callable in templates like this\n    ``SITE.themetaname``\n\n    This can be used in code out of a Django requests (like in management\n    commands) or in a context processor to get the *Site* urls.\n\n    Default metas returned :\n\n    * SITE.name: Current *Site* entry name;\n    * SITE.domain: Current *Site* entry domain;\n    * SITE.web_url: The Current *Site* entry domain prefixed with the http\n      protocol like ``http://mydomain.com``. If HTTPS is enabled 'https' will be used instead of 'http';\n\n    Optionally it can also return ``STATIC_URL`` and ``MEDIA_URL`` if needed\n    (like out of Django requests).\n    \"\"\"\n    site_current = Site.objects.get_current()\n    metas = {\n        'SITE': {\n            'name': site_current.name,\n            'domain': site_current.domain,\n            'web_url': 'http://%s' % site_current.domain,\n        }\n    }\n    if is_secure:\n        metas['web_url'] = 'https://%s' % site_current.domain\n    if with_media:\n        metas['MEDIA_URL'] = getattr(settings, 'MEDIA_URL', '')\n    if with_static:\n        metas['STATIC_URL'] = getattr(settings, 'STATIC_URL', '')\n    metas.update(extra)\n    return metas", "response": "Returns a dictionary of all site metas from the current Site and settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts part of non - nested XML to dict.", "response": "def _alephResultToDict(dom):\n    \"\"\"\n    Convert part of non-nested XML to :py:class:`dict`.\n\n    Args:\n        dom (HTMLElement tree): pre-parsed XML (see dhtmlparser).\n\n    Returns:\n        dict: with python data\n    \"\"\"\n    result = {}\n    for i in dom.childs:\n        if not i.isOpeningTag():\n            continue\n\n        keyword = i.getTagName().strip()\n        value = _tryConvertToInt(i.getContent().strip())\n\n        # if there are multiple tags with same keyword, add values into\n        # array, instead of rewriting existing value at given keyword\n        if keyword in result:                  # if it is already there ..\n            if isinstance(result[keyword], list):  # and it is list ..\n                result[keyword].append(value)          # add it to list\n            else:                                  # or make it array\n                result[keyword] = [result[keyword], value]\n        else:                                  # if it is not in result, add it\n            result[keyword] = value\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef searchInAleph(base, phrase, considerSimilar, field):\n    downer = Downloader()\n\n    if field.lower() not in VALID_ALEPH_FIELDS:\n        raise InvalidAlephFieldException(\"Unknown field '\" + field + \"'!\")\n\n    param_url = Template(SEARCH_URL_TEMPLATE).substitute(\n        PHRASE=quote_plus(phrase),  # urlencode phrase\n        BASE=base,\n        FIELD=field,\n        SIMILAR=\"Y\" if considerSimilar else \"N\"\n    )\n    result = downer.download(ALEPH_URL + param_url)\n\n    dom = dhtmlparser.parseString(result)\n\n    find = dom.find(\"find\")  # find <find> element :)\n    if len(find) <= 0:\n        raise AlephException(\"Aleph didn't returned any information.\")\n    find = find[0]\n\n    # convert aleph result into dictionary\n    result = _alephResultToDict(find)\n\n    # add informations about base into result\n    result[\"base\"] = base\n\n    if \"error\" not in result:\n        return result\n\n    # handle errors\n    if result[\"error\"] == \"empty set\":\n        result[\"no_entries\"] = 0  # empty set have 0 entries\n        return result\n    else:\n        raise AlephException(result[\"error\"])", "response": "This function is used to search in Aleph s database for a set of records in the specified language."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef downloadRecords(search_result, from_doc=1):\n    downer = Downloader()\n\n    if \"set_number\" not in search_result:\n        return []\n\n    # set numbers should be probably aligned to some length\n    set_number = str(search_result[\"set_number\"])\n    if len(set_number) < 6:\n        set_number = (6 - len(set_number)) * \"0\" + set_number\n\n    # download all no_records\n    records = []\n    for cnt in range(search_result[\"no_records\"]):\n        doc_number = from_doc + cnt\n\n        if cnt >= MAX_RECORDS or doc_number > search_result[\"no_records\"]:\n            break\n\n        set_data = downer.download(\n            ALEPH_URL + Template(RECORD_URL_TEMPLATE).substitute(\n                SET_NUM=set_number,\n                RECORD_NUM=doc_number,\n            )\n        )\n\n        records.append(set_data)\n\n    return records", "response": "Download records from search_result starting from from_doc."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getDocumentIDs(aleph_search_result, number_of_docs=-1):\n    downer = Downloader()\n\n    if \"set_number\" not in aleph_search_result:\n        return []\n\n    # set numbers should be probably aligned to some length\n    set_number = str(aleph_search_result[\"set_number\"])\n    if len(set_number) < 6:\n        set_number = (6 - len(set_number)) * \"0\" + set_number\n\n    # limit number of fetched documents, if -1, download all\n    if number_of_docs <= 0:\n        number_of_docs = aleph_search_result[\"no_entries\"]\n\n    # download data about given set\n    set_data = downer.download(\n        ALEPH_URL + Template(SET_URL_TEMPLATE).substitute(\n            SET_NUMBER=set_number,\n            NUMBER_OF_DOCS=number_of_docs,\n        )\n    )\n\n    # parse data\n    dom = dhtmlparser.parseString(set_data)\n    set_data = dom.find(\"ill-get-set\")\n\n    # there should be at least one <ill-get-set> field\n    if len(set_data) <= 0:\n        raise AlephException(\"Aleph didn't returned set data.\")\n\n    ids = []\n    for library in set_data:\n        documents = _alephResultToDict(library)\n\n        if \"error\" in documents:\n            raise AlephException(\"getDocumentIDs: \" + documents[\"error\"])\n\n        # convert all document records to DocumentID named tuple and extend\n        # them to 'ids' array\n        if isinstance(documents[\"doc-number\"], list):\n            ids.extend(\n                map(\n                    lambda x: DocumentID(\n                        x,\n                        documents[\"set-library\"],\n                        aleph_search_result[\"base\"]\n                    ),\n                    set(documents[\"doc-number\"])\n                )\n            )\n        else:\n            ids.append(\n                DocumentID(\n                    documents[\"doc-number\"],\n                    documents[\"set-library\"],\n                    aleph_search_result[\"base\"]\n                )\n            )\n\n    return ids", "response": "Get IDs of documents from Aleph."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef downloadMARCXML(doc_id, library, base=\"nkc\"):\n    downer = Downloader()\n\n    data = downer.download(\n        ALEPH_URL + Template(DOC_URL_TEMPLATE).substitute(\n            DOC_ID=doc_id,\n            LIBRARY=library\n        )\n    )\n\n    dom = dhtmlparser.parseString(data)\n\n    # check if there are any errors\n    # bad library error\n    error = dom.find(\"login\")\n    if error:\n        error_msg = error[0].find(\"error\")\n\n        if error_msg:\n            raise LibraryNotFoundException(\n                \"Can't download document doc_id: '\" + str(doc_id) + \"' \" +\n                \"(probably bad library: '\" + library + \"')!\\nMessage: \" +\n                \"\\n\".join(map(lambda x: x.getContent(), error_msg))\n            )\n\n    # another error - document not found\n    error = dom.find(\"ill-get-doc\")\n    if error:\n        error_msg = error[0].find(\"error\")\n\n        if error_msg:\n            raise DocumentNotFoundException(\n                \"\\n\".join(map(lambda x: x.getContent(), error_msg))\n            )\n\n    return data", "response": "Download MARC XML document with given doc_id from given library."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndownloads MARC OAI document with given doc_id from given base.", "response": "def downloadMARCOAI(doc_id, base):\n    \"\"\"\n    Download MARC OAI document with given `doc_id` from given (logical) `base`.\n\n    Funny part is, that some documents can be obtained only with this function\n    in their full text.\n\n    Args:\n        doc_id (str):         You will get this from :func:`getDocumentIDs`.\n        base (str, optional): Base from which you want to download Aleph\n                              document.\n                              This seems to be duplicite with\n                              :func:`searchInAleph` parameters, but it's just\n                              something Aleph's X-Services wants, so ..\n\n    Returns:\n        str: MARC XML Unicode string.\n\n    Raises:\n        InvalidAlephBaseException\n        DocumentNotFoundException\n    \"\"\"\n    downer = Downloader()\n\n    data = downer.download(\n        ALEPH_URL + Template(OAI_DOC_URL_TEMPLATE).substitute(\n            DOC_ID=doc_id,\n            BASE=base\n        )\n    )\n\n    dom = dhtmlparser.parseString(data)\n\n    # check for errors\n    error = dom.find(\"error\")\n    if len(error) <= 0:  # no errors\n        return data\n\n    if \"Error reading document\" in error[0].getContent():\n        raise DocumentNotFoundException(\n            str(error[0].getContent())\n        )\n    else:\n        raise InvalidAlephBaseException(\n            error[0].getContent() + \"\\n\" +\n            \"The base you are trying to access probably doesn't exist.\"\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalls documentation: `/subscription/create <https://www.wepay.com/developer/reference/subscription#create>`_, plus extra keyword parameters: :keyword str access_token: will be used instead of instance's ``access_token``, with ``batch_mode=True`` will set `authorization` param to it's value. :keyword bool batch_mode: turn on/off the batch_mode, see :class:`wepay.api.WePay` :keyword str batch_reference_id: `reference_id` param for batch call, see :class:`wepay.api.WePay` :keyword str api_version: WePay API version, see :class:`wepay.api.WePay`", "response": "def __create(self, subscription_plan_id, **kwargs):\n        \"\"\"Call documentation: `/subscription/create\n        <https://www.wepay.com/developer/reference/subscription#create>`_, plus\n        extra keyword parameters:\n        \n        :keyword str access_token: will be used instead of instance's\n           ``access_token``, with ``batch_mode=True`` will set `authorization`\n           param to it's value.\n\n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'subscription_plan_id': subscription_plan_id\n        }\n        return self.make_call(self.__create, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __cancel(self, subscription_id, **kwargs):\n        params = {\n            'subscription_id': subscription_id\n        }\n        return self.make_call(self.__cancel, params, kwargs)", "response": "This is the internal method to cancel the current state of the current state of the current state of the instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __modify(self, subscription_id, **kwargs):\n        params = {\n            'subscription_id': subscription_id\n        }\n        return self.make_call(self.__modify, params, kwargs)", "response": "Modify the internal state of a wePay instance s internal state."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nquerying the triplestore for an item sends it to elasticsearch", "response": "def _index_item(self, uri, num, batch_num):\n        \"\"\" queries the triplestore for an item sends it to elasticsearch \"\"\"\n\n        data = RdfDataset(get_all_item_data(uri, self.namespace),\n                          uri).base_class.es_json()\n        self.batch_data[batch_num].append(data)\n        self.count += 1"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _index_group_with_sub(self):\n\n        lg = logging.getLogger(\"%s.%s\" % (self.ln, inspect.stack()[0][3]))\n        lg.setLevel(self.log_level)\n        # get a list of all the uri to index\n        results = run_sparql_query(sparql=self.query, namespace=self.namespace)\n        # results = results[:100]\n        # Start processing through uri\n        self.time_start = datetime.datetime.now()\n        batch_size = 12000\n        if len(results) > batch_size:\n            batch_end = batch_size\n        else:\n            batch_end = len(results)\n        batch_start = 0\n        batch_num = 1\n        self.batch_data = {}\n        self.batch_data[batch_num] = []\n        end = False\n        last = False\n        while not end:\n            lg.debug(\"batch %s: %s-%s\", batch_num, batch_start, batch_end)\n            sub_batch = []\n            j = 0\n            for i, subj in enumerate(results[batch_start:batch_end]):\n                qry_size = 50\n                if j < qry_size:\n                    sub_batch.append(subj)\n                if j == qry_size or i == batch_end:\n                    sub_batch.append(subj)\n                    th = threading.Thread(name=batch_start + i + 1,\n                                          target=self._index_sub,\n                                          args=(sub_batch,\n                                                i+1,batch_num,))\n                    th.start()\n                    j = 0\n                    sub_batch = []\n            lg.debug(datetime.datetime.now() - self.time_start)\n            main_thread = threading.main_thread()\n            for t in threading.enumerate():\n                if t is main_thread:\n                    continue\n                t.join()\n            action_list = \\\n                    self.es_worker.make_action_list(self.batch_data[batch_num])\n            self.es_worker.bulk_save(action_list)\n            del self.batch_data[batch_num]\n            batch_end += batch_size\n            batch_start += batch_size\n            if last:\n                end = True\n            if len(results) <= batch_end:\n                batch_end = len(results)\n                last = True\n            batch_num += 1\n            self.batch_data[batch_num] = []\n            lg.debug(datetime.datetime.now() - self.time_start)", "response": "Index all the URIs defined by the query into Elasticsearch."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef select_newest_project(dx_project_ids):\n    if len(dx_project_ids) == 1:\n        return dx_project_ids[0]\n    \n    projects = [dxpy.DXProject(x) for x in dx_project_ids]\n    created_times = [x.describe()[\"created\"] for x in projects]\n    paired = zip(created_times,projects)\n    paired.sort(reverse=True)\n    return paired[0][0]", "response": "Returns the newest project in the list of DNAnexus projects."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\naccept the pending transfers for projects in the specified billing account.", "response": "def accept_project_transfers(access_level,queue,org,share_with_org=None):\n      \"\"\"\n      Args:\n          access_level: `str`. Permissions level the new member should have on transferred projects. Should \n              be one of [\"VIEW\",\"UPLOAD\",\"CONTRIBUTE\",\"ADMINISTER\"]. See \n              https://wiki.dnanexus.com/API-Specification-v1.0.0/Project-Permissions-and-Sharing for more details on access levels.\n          queue: `str`. The value of the queue property on a DNAnexus project. Only projects that are \n              pending transfer that have this value for the queue property will be transferred to the \n              specified org.\n          org: `str`. The name of the DNAnexus org under which to accept the project transfers for projects \n              that have their queue property set to the value of the 'queue' argument.\n          share_with_org: `str`. Set this argument if you'd like to share the transferred projects \n              with the org so that all users of the org will have access to the project. The value you \n              supply should be the access level that members of the org will have.\n      Returns:\n          `dict`: The projects that were transferred to the specified billing account. Keys are the \n          project IDs, and values are the project names. \n      \"\"\"\n      dx_username = gbsc_dnanexus.utils.get_dx_username()\n      #gbsc_dnanexus.utils.log_into_dnanexus(dx_username)\n      org = gbsc_dnanexus.utils.add_dx_orgprefix(org)\n      pending_transfers = gbsc_dnanexus.utils.pending_transfers(dx_username)\n      #pending_transfers is a list of project IDs\n      transferred = {}\n      for proj_id in pending_transfers:\n          dx_proj = dxpy.DXProject(proj_id)\n          props = dx_proj.describe(input_params={\"properties\": True})[\"properties\"]\n          try:\n              project_queue = props[\"queue\"]  \n          except KeyError:\n              raise DxProjectMissingQueueProperty(\"DNAnexus project {proj_name} ({proj_id}) is missing the queue property.\".format(proj_name=dx_proj.name,proj_id=proj_id))\n          if queue != project_queue:\n              continue\n          msg = \"Accepting project transfer of {proj_name} ({proj_id}) for user {user}, to be billed under the org {org}.\".format(proj_name=dx_proj.name,proj_id=proj_id,user=dx_username,org=org)\n          debug_logger.debug(msg)\n          dxpy.DXHTTPRequest(\"/\" + proj_id + \"/acceptTransfer\", {\"billTo\": org })\n          success_logger.info(msg)\n          transferred[proj_id] = dx_proj.name\n          if share_with_org:\n              msg = \"Sharing project {proj_id} with {org} with access level {share_with_org}.\".format(proj_id=proj_id,org=org,share_with_org=share_with_org)\n              debug_logger.debug(msg)\n              share_with_org(project_ids=[proj_id], org=org, access_level=share_with_org)\n              dxpy.api.project_invite(object_id=proj_id,input_params={\"invitee\": org,\"level\": share_with_org,\"suppressEmailNotification\": True})\n              success_logger.info(msg)\n      return transferred"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsharing one or more DNAnexus projects with an organization.", "response": "def share_with_org(project_ids, org, access_level, suppress_email_notification=False):\n    \"\"\"\n    Shares one or more DNAnexus projects with an organization.\n\n    Args:\n        project_ids: `list`. One or more DNAnexus project identifiers, where each project ID is in \n            the form \"project-FXq6B809p5jKzp2vJkjkKvg3\". \n        org: `str`. The name of the DNAnexus org with which to share the projects. \n        access_level: The permission level to give to members of the org - one of\n            [\"VIEW\",\"UPLOAD\",\"CONTRIBUTE\",\"ADMINISTER\"].\n        suppress_email_notification: `bool`. True means to allow the DNAnexus platform to send an\n            email notification for each shared project. \n    \"\"\"\n    for p in project_ids:\n        dxpy.api.project_invite(object_id=p,input_params={\"invitee\": org,\"level\": access_level,\"suppressEmailNotification\": suppress_email_notification})"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches for the project in the DNAnexus class and sets the self. dx_project_id property.", "response": "def _set_dxproject_id(self,latest_project=False):\n        \"\"\"\n        Searches for the project in DNAnexus based on the input arguments when instantiating the class. \n        If multiple projects are found based on the search criteria, an exception will be raised. A \n        few various search strategies are employed, based on the input arguments. In all cases, if the \n        'billing_account_id' was specifed, all searches will search for projects only belonging to the \n        specified billing account. The search strategies work as follows: If the project ID was\n        provided, the search will attempt to find the project by ID only. If the project ID wasn't \n        provided, but the project name was specified, then the search will attempt to find the project\n        by name and by any project properties that may have been set during instantiation \n        (uhts_run_name, sequencing_lane, and library_name). If neither the project name nor the \n        project ID was specified, then a search by whichever project properties were specified will take place.\n    \n        This method will not set the self.dx_project_id if none of the search methods are successful \n        in finding a single project, and this may indicate that the sequencing hasn't finished yet.\n    \n        Args:\n            latest_project: `bool`. True indicates that if multiple projects are found given the search \n            criteria, the most recently created project will be returned.\n    \n        Returns: \n            `str`. The DNAnexus project ID or the empty string if a project wasn't found.\n     \n        Raises: \n            `scgpm_seqresults_dnanexus.dnanexus_utils.DxMultipleProjectsWithSameLibraryName()`: The \n                search is by self.library_name, and multiple DNAnexus projects have that library name.\n\n            `DxMissingLibraryNameProperty`: The DNAnexus project property 'library_name' is not present. \n        \"\"\"\n        dx_project_props = {}\n        if self.library_name:\n            dx_project_props[\"library_name\"] = self.library_name\n        if self.uhts_run_name:\n            dx_project_props[\"seq_run_name\"] = self.uhts_run_name\n        if self.sequencing_lane:\n            dx_project_props[\"seq_lane_index\"] = str(self.sequencing_lane)\n    \n        dx_proj = \"\"\n        if self.dx_project_id:\n            prefix = \"project-\"\n            if not self.dx_project_id.startswith(prefix):\n                self.dx_project_id = prefix + self.dx_project_id\n            dx_proj = dxpy.DXProject(dxid=self.dx_project_id)\n        elif self.dx_project_name:\n            res = dxpy.find_one_project(properties=dx_project_props,billed_to=self.billing_account_id,zero_ok=True,more_ok=False,name=self.dx_project_name)\n            if res:\n                dx_proj = dxpy.DXProject(dxid=res[\"id\"])\n        else:\n            #try to find by library_name and potential uhts_run_name\n            res = list(dxpy.find_projects(properties=dx_project_props,billed_to=self.billing_account_id))\n            if len(res) == 1:\n                dx_proj = dxpy.DXProject(dxid=res[0][\"id\"])\n            elif len(res) > 1:\n                dx_proj_ids = [x[\"id\"] for x in res]\n                if not latest_project:\n                    raise DxMultipleProjectsWithSameLibraryName(\"Error - Multiple DNAnexus projects have the same value for the library_name property value of {library_name}. The projects are {dx_proj_ids}.\".format(library_name=self.library_name,dx_proj_ids=dx_proj_ids))\n                dx_proj = gbsc_dnanexus.utils.select_newest_project(dx_project_ids=dx_proj_ids)\n    \n        if not dx_proj:\n              return\n    \n        self.dx_project = dx_proj\n        self.dx_project_id = dx_proj.id\n        self.dx_project_name = dx_proj.name\n        self.dx_project_props = dxpy.api.project_describe(object_id=dx_proj.id,input_params={\"fields\": {\"properties\": True}})[\"properties\"]\n        try:\n            self.library_name = self.dx_project_props[\"library_name\"]\n        except KeyError:\n            msg = \"DNAnexus project {} is missing the library_name property.\".format(self.dx_project_name)\n            raise DxMissingLibraryNameProperty(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_run_details_json(self):\n        run_details_filename = \"run_details.json\"\n        run_details_json_id = dxpy.find_one_data_object(more_ok=False,zero_ok=True,project=self.dx_project_id,name=run_details_filename)[\"id\"]\n        json_data = json.loads(dxpy.open_dxfile(dxid=run_details_json_id).read())\n        #dxpy.download_dxfile(show_progress=True,dxid=run_details_json_id,project=self.dx_project_id,filename=output_name)\n        return json_data", "response": "Retrieves the JSON object for the stats in the file named run_details. json in the project \n        specified by self. dx_project_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the alignment summary metrics file and returns a dictionary of the alignment summary metrics.", "response": "def get_alignment_summary_metrics(self, barcode):\n        \"\"\"\n        Parses the metrics in a ${barcode}alignment_summary_metrics file in the DNAnexus project\n        (usually in the qc folder). This contains metrics produced by Picard Tools's \n        CollectAlignmentSummaryMetrics program. \n        \"\"\"\n        filename = barcode + \".alignment_summary_metrics\"\n        # In the call to dxpy.find_one_data_object() below, I'd normally set the \n        # more_ok parameter to False, but this blows-up in Python 3.7 - giving me a RuntimeError. \n        # So, I just won't set it for now. I think dxpy is still mainly a Python 2.7 library and\n        # can break in later version of Python3. \n        try:\n            file_id = dxpy.find_one_data_object(\n                zero_ok=False,\n                project=self.dx_project_id,\n                name=filename)[\"id\"]\n        except dxpy.exceptions.DXSearchError as err:\n            msg = \"Picard alignment summary metrics for barcode {} in DX project {} not found.\".format(barcode, self.dx_project_id)\n            debug_logger.error(msg)\n            raise DxMissingAlignmentSummaryMetrics(msg)\n        fh = StringIO(dxpy.open_dxfile(file_id).read())\n        asm = picard.CollectAlignmentSummaryMetrics(fh)\n        return asm.metrics"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading the JSON in a ${barcode}_stats. json file in the DNAnexus project.", "response": "def get_barcode_stats(self, barcode):\n        \"\"\"\n        Loads the JSON in a ${barcode}_stats.json file in the DNAnexus project (usually in the qc\n        folder). \n        \"\"\"\n        filename = barcode + \"_stats.json\"\n        # In the call to dxpy.find_one_data_object() below, I'd normally set the \n        # more_ok parameter to False, but this blows-up in Python 3.7 - giving me a RuntimeError. \n        # So, I just won't set it for now. I think dxpy is still mainly a Python 2.7 library and\n        # can break in later version of Python3. \n        file_id = dxpy.find_one_data_object(\n            zero_ok=False,\n            project=self.dx_project_id,\n            name=filename)[\"id\"]\n        json_data = json.loads(dxpy.open_dxfile(file_id).read())\n        return json_data"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve the sample_stats. json file for the given barcode.", "response": "def get_sample_stats_json(self,barcode=None):\n        \"\"\"\n        .. deprecated:: 0.1.0\n           GSSC has removed the sample_stats.json file since the entire folder it was in has been \n           removed. Use :meth:`get_barcode_stats` instead. \n     \n        Retrieves the JSON object for the stats in the file named sample_stats.json in the project \n        specified by self.dx_project_id.  This file is located in the DNAnexus folder stage\\d_qc_report.\n    \n        Args:\n            barcode: `str`. The barcode for the sample. Currently, the sample_stats.json file is of the \n                following form when there isn't a genome mapping: \n    \n                [{\"Sample name\": \"AGTTCC\"}, {\"Sample name\": \"CAGATC\"}, {\"Sample name\": \"GCCAAT\"}, ...}]. \n    \n                When there is a mapping, each dictionary has many more keys in addition to the \"Sample name\" one.\n    \n        Returns: \n            `list` of dicts if barcode=None, otherwise a dict for the given barcode.\n        \"\"\"\n        sample_stats_json_filename = \"sample_stats.json\"\n        sample_stats_json_id = dxpy.find_one_data_object(more_ok=False,zero_ok=False,project=self.dx_project_id,name=sample_stats_json_filename)[\"id\"]\n        #dxpy.download_dxfile(dxid=sample_stats_json_id,project=self.dx_project_id,filename=sample_stats_json_filename)\n        json_data = json.loads(dxpy.open_dxfile(sample_stats_json_id).read())\n      \n        if not barcode:\n            return json_data\n      \n        for d in json_data: #d is a dictionary\n            sample_barcode = d[\"Sample name\"]\n            if sample_barcode == barcode:\n                return d\n        if barcode:\n            raise DnanexusBarcodeNotFound(\"Barcode {barcode} for {library_name} not found in {sample_stats_json_filename} in project {project}.\".format(barcode=barcode,library_name=self.library_name,sample_stats_json_filename=sample_stats_json_filename,project=self.dx_project_id))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef download_metadata_tar(self,download_dir):  \n        if not os.path.isdir(download_dir):\n            os.makedirs(download_dir)  \n        res = dxpy.find_one_data_object(project=self.dx_project_id,folder=self.DX_RAW_DATA_FOLDER,name=\"*metadata.tar\",name_mode=\"glob\")\n        #res will be something like {u'project': u'project-BzqVkxj08kVZbPXk54X0P2JY', u'id': u'file-BzqVkg800Fb0z4437GXJfGY6'}\n        #dxpy.find_one_data_object() raises a dxpy.exceptions.DXSearchError() if nothing is found.\n        dx_file = dxpy.DXFile(dxid=res[\"id\"],project=res[\"project\"])\n        download_file_name = os.path.join(download_dir,dx_file.name)\n        msg = \"{filename} to {download_dir}.\".format(filename=dx_file.name,download_dir=download_dir)\n        debug_logger.debug(\"Downloading \" + msg)\n        dxpy.bindings.dxfile_functions.download_dxfile(dxid=dx_file,filename=download_file_name)\n        success_logger.info(\"Downloaded \" + msg)\n        return download_file_name", "response": "Downloads the metadata. tar file from the DNAnexus sequencing results project."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef download_fastqc_reports(self,download_dir):\n        if not os.path.isdir(download_dir):\n            os.makedirs(download_dir)  \n        msg = \"the FASTQC reports to {download_dir}.\".format(download_dir=download_dir)\n        debug_logger.debug(\"Downloading \" + msg)\n        dxpy.download_folder(project=self.dx_project_id,destdir=download_dir,folder=self.DX_FASTQC_FOLDER,overwrite=True)\n        success_logger.info(\"Downloaded \" + msg)\n        #rename the downloaded folder to ${download_dir}/FASTQC\n        return download_dir", "response": "Downloads the FASTQC reports from the DNAnexus Sequencing results project."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef download_fastqs(self,dest_dir,barcode,overwrite=False):\n        fastq_props = self.get_fastq_files_props(barcode=barcode)\n        res = {}  \n        for f in fastq_props:\n            props = fastq_props[f]\n            read_num = int(props[\"read\"])\n            barcode = props[\"barcode\"]\n            if barcode not in res:\n                res[barcode] = {}\n            name = props[\"fastq_file_name\"]\n            filedest = os.path.abspath(os.path.join(dest_dir,name))\n            res[barcode][read_num] = filedest\n            if os.path.exists(filedest) and not overwrite:\n                continue\n            debug_logger.debug(\"Downloading FASTQ file {name} from DNAnexus project {project} to {path}.\".format(name=name,project=self.dx_project_name,path=filedest))\n            dxpy.download_dxfile(f,filedest)\n        return res", "response": "Download all FASTQ files in the project that match the specified barcode and store them in a dict with the barcode and read number as the key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_fastq_dxfile_objects(self,barcode=None):\n        fq_ext_glob = \"*{}\".format(self.FQEXT)\n        name = fq_ext_glob\n        if barcode:\n            name = \"*_{barcode}_*{FQEXT}\".format(barcode=barcode, FQEXT=self.FQEXT)\n        fastqs= dxpy.find_data_objects(project=self.dx_project_id,folder=self.DX_FASTQ_FOLDER,name=name,name_mode=\"glob\")\n        if not fastqs:\n            # Then look for them in all folders:\n            fastqs= dxpy.find_data_objects(project=self.dx_project_id,name=name,name_mode=\"glob\")\n           \n        if not fastqs:\n            msg = \"No FASTQ files found for run {run} \".format(run=proj_name)\n            if barcode:\n                msg += \"and barcode {barcode}.\".format(barcode=barcode)\n            raise FastqNotFound(msg)\n        fastqs = [dxpy.DXFile(project=x[\"project\"],dxid=x[\"id\"]) for x in fastqs]\n        return fastqs", "response": "Returns all the FASTQ files in the project self. dx_project_name as DXFile objects."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_fastq_files_props(self,barcode=None):\n        fastqs = self.get_fastq_dxfile_objects(barcode=barcode)   #FastqNotFound Exception here if no FASTQs found for specified barcode.\n        dico = {}\n        for f in fastqs:\n            #props = dxpy.api.file_describe(object_id=f.id, input_params={\"fields\": {\"properties\": True}})[\"properties\"]\n            props = f.get_properties()\n            dico[f] = props\n            dico[f][\"fastq_file_name\"] = f.name\n        return dico", "response": "Returns the properties of all FASTQ files in the project that match the \n            barcode."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking a URL string and returns its protocol and server", "response": "def parse_url(url):\n    \"\"\" Takes a URL string and returns its protocol and server \"\"\"\n    # Verify that the protocol makes sense.  We shouldn't guess!\n    if not RE_PROTOCOL_SERVER.match(url):\n        raise Exception(\"URL should begin with `protocol://domain`\")\n\n    protocol, server, path, _, _, _ = urlparse.urlparse(url)\n\n    return protocol, server"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef record_event(self, event):\n        with open(self._path, 'a') as file_:\n            file_.write(str(event) + '\\n')", "response": "Records the event in the store\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_events(self):\n        with open(self._path, 'r') as file_:\n            file_lines = file_.read().splitlines()\n            event_lines = [line for line in file_lines if line]\n        events = []\n        for event_line in event_lines:\n            for event_cls in (AddEvent, SetReadingEvent, ReadEvent,\n                              SetFinishedEvent):\n                try:\n                    event = event_cls.from_str(event_line)\n                except EventParseError:\n                    pass\n                else:\n                    events.append(event)\n        return events", "response": "Returns a list of all KindleEvent s held in the store\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef name(self, value):\n\n        if isinstance(value, string_types):\n\n            match = Parameter._PARAM_NAME_COMPILER_MATCHER(value)\n\n            if match is None or match.group() != value:\n                value = re_compile(value)\n\n        self._name = value", "response": "Set the name of the parameter."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget serialized value. :rtype: str", "response": "def svalue(self):\n        \"\"\"Get serialized value.\n\n        :rtype: str\n        \"\"\"\n\n        result = self._svalue\n\n        if result is None:  # try to get svalue from value if svalue is None\n\n            try:\n                value = self.value\n\n            except Parameter.Error:\n                pass\n\n            else:\n                result = self._svalue = self.serializer(value)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchanging of serialized value. Nonify this value as well.", "response": "def svalue(self, value):\n        \"\"\"Change of serialized value.\n\n        Nonify this value as well.\n\n        :param str value: serialized value to use.\n        \"\"\"\n\n        if value is not None:  # if value is not None\n            self._value = None\n            self._error = None\n\n        self._svalue = value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresolving this foreign - value for a given configuration.", "response": "def resolve(\n            self,\n            configurable=None, conf=None, scope=None, ptype=None,\n            parser=None, error=True, svalue=None,\n            safe=None, besteffort=None\n    ):\n        \"\"\"Resolve this parameter value related to a configurable and a\n        configuration.\n\n        Save error in this attribute `error` in case of failure.\n\n        :param str svalue: serialized value too resolve. Default is this svalue.\n        :param Configurable configurable: configurable to use for foreign\n            parameter resolution.\n        :param Configuration conf: configuration to use for\n            cross-value resolution.\n        :param dict scope: variables to use for local expression evaluation.\n        :param type ptype: return type. Default is this ptype.\n        :param parser: specific parser to use. Default this parser.\n        :param bool error: raise an error if True (False by default).\n        :param bool safe: if True (default) resolve without builtins functions.\n        :param bool besteffort: best effort flag. Default is this besteffort.\n        :return: newly resolved value.\n        :raises: Parameter.Error for any raised exception.\n        \"\"\"\n\n        result = self._value\n\n        # if cached value is None and serialiazed value exists\n        if self._value is None and self._svalue is not None:\n\n            self._error = None  # nonify error.\n\n            if ptype is None:\n                ptype = self.ptype\n\n            if parser is None:  # init parser\n                parser = self.parser\n\n            if svalue is None:\n                svalue = self._svalue\n\n            if conf is None:  # init conf\n                conf = self.conf\n\n            if configurable is None:  # init configurable\n                configurable = self.configurable\n\n            if scope is None:\n                scope = self.scope\n\n            else:\n                scope, selfscope = self.scope.copy(), scope\n                scope.update(selfscope)\n\n            if safe is None:\n                safe = self.safe\n\n            if besteffort is None:\n                besteffort = self.besteffort\n\n            # parse value if str and if parser exists\n            try:\n                result = self._value = parser(\n                    svalue=svalue, conf=conf,\n                    configurable=configurable, ptype=ptype,\n                    scope=scope, safe=safe, besteffort=besteffort\n                )\n\n            except Exception as ex:\n\n                self._error = ex\n                if error:\n                    msg = 'Impossible to parse value ({0}) with {1}.'\n                    msg = msg.format(self._svalue, self.parser)\n                    reraise(Parameter.Error, Parameter.Error(msg))\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the parameter value.", "response": "def value(self):\n        \"\"\"Get parameter value.\n\n        If this cached value is None and this serialized value is not None,\n        calculate the new value from the serialized one.\n\n        :return: parameter value.\n        :raises: TypeError if serialized value is not an instance of self ptype\n            . ParserError if parsing step raised an error.\n        \"\"\"\n\n        result = self._value\n\n        if result is None and self._svalue is not None:\n\n            try:\n                result = self._value = self.resolve()\n\n            except Exception as e:\n                reraise(\n                    Parameter.Error,\n                    Parameter.Error('Call the method \"resolve\" first.')\n                )\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef value(self, value):\n\n        if value is None or (\n                self.ptype is None or isinstance(value, self.ptype)\n        ):\n            self._value = value\n\n        else:\n            # raise wrong type error\n            error = TypeError(\n                'Wrong value type of {0} ({1}). {2} expected.'.format(\n                    self.name, value, self.ptype\n                )\n            )\n            self._error = error\n            raise error", "response": "Change of parameter value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef attr(object, attr):\n    pseudo_context = {'object': object}\n    try:\n        value = Variable('object.%s' % attr).resolve(pseudo_context)\n    except VariableDoesNotExist:\n        value = None\n    return value", "response": "Get the value of an attribute in a django template dynamically"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_cartesian(r, theta, theta_units=\"radians\"):\n    assert theta_units in ['radians', 'degrees'],\\\n        \"kwarg theta_units must specified in radians or degrees\"\n\n    # Convert to radians\n    if theta_units == \"degrees\":\n        theta = to_radians(theta)\n\n    theta = to_proper_radians(theta)\n    x = r * cos(theta)\n    y = r * sin(theta)\n\n    return x, y", "response": "Converts polar r theta to cartesian x y."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the index of the n - item in the dataframe", "response": "def set_index(data,col_index):\n    \"\"\"\n    Sets the index if the index is not present\n\n    :param data: pandas table \n    :param col_index: column name which will be assigned as a index\n    \"\"\"\n    if col_index in data:\n        data=data.reset_index().set_index(col_index)\n        if 'index' in data:\n            del data['index']\n        return data\n    elif data.index.name==col_index:\n        return data\n    else:\n        logging.error(\"something's wrong with the df\")\n        df2info(data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef del_Unnamed(df):\n    cols_del=[c for c in df.columns if 'Unnamed' in c]\n    return df.drop(cols_del,axis=1)", "response": "Deletes all the unnamed columns from a DataFrame"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fhs2data_combo(fhs,cols,index,labels=None,col_sep=': '):\n\n    if labels is None:\n        labels=[basename(fh) for fh in fhs]\n    if len(fhs)>0:\n        for fhi,fh in enumerate(fhs):\n            label=labels[fhi]\n            data=pd.read_csv(fh).set_index(index)\n            if fhi==0:\n                data_combo=pd.DataFrame(index=data.index)\n                for col in cols:\n                    data_combo.loc[:,'%s%s%s' % (label,col_sep,col)]=data.loc[:,col]\n            else:\n                for col in cols:\n                    data_combo.loc[:,'%s%s%s' % (label,col_sep,col)]=data.loc[:,col]    \n        return data_combo\n    else:\n        logging.error('no fhs found: len(fhs)=0')", "response": "Returns a pandas table \n    containing the data from multiple csv files."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngrabs the configuration, and makes the call to Authentise to create the session", "response": "def __create_session(username=None, password=None):\n        \"\"\"grabs the configuration, and makes the call to Authentise to create the session\"\"\"\n        config = Config()\n\n        if not username or not password:\n            username = config.username\n            password = config.password\n\n        payload = {\n            \"username\": username,\n            \"password\": password,\n        }\n\n        session_resp = requests.post(\"https://users.{}/sessions/\".format(config.host), json=payload)\n        if session_resp.status_code == 403:\n            raise errors.ResourceError(\"bad user credentials\")\n\n        return session_resp.cookies[\"session\"]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_user(cls, username, password, name, email):\n        config = Config()\n        payload = {\"username\": username,\n                   \"email\": email,\n                   \"name\": name,\n                   \"password\": password, }\n        user_creation_resp = requests.post(\"https://users.{}/users/\".format(config.host),\n                                           json=payload)\n        if user_creation_resp.status_code != 201:\n            raise errors.ResourceError(\"couldnt create user\")", "response": "utility class method to create a user"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wrap_text(paragraph, line_count, min_char_per_line=0):\n\tone_string = strip_all_white_space(paragraph)\n\tif min_char_per_line:\n\t\tlines = wrap(one_string, width=min_char_per_line)\n\t\ttry:\n\t\t\treturn lines[:line_count]\n\t\texcept IndexError:\n\t\t\treturn lines\n\telse:\n\t\treturn wrap(one_string, len(one_string)/line_count)", "response": "Wraps the given text to the specified number of lines."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_request_id(self, renew=False):\n        if not AppRequest.__request_id or renew:\n            self.set_request_id(uuid.uuid1())\n        return AppRequest.__request_id", "response": "This method is used to get the request ID of the current AppRequest."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef jsonify(data, pretty=False, **kwargs):\n    isod = isinstance(data, OrderedDict)\n    params = {\n        'for_json': True,\n        'default': _complex_encode,\n    }\n    if pretty:\n        params['indent'] = 2\n        params['sort_keys'] = False if isod else True\n    params.update(kwargs)\n    try:\n        return json.dumps(data, ensure_ascii=False, **params)\n    except UnicodeDecodeError:\n        return json.dumps(data, **params)", "response": "Serialize Python objects to JSON with optional pretty formatting"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getDocNumber(xml):\n    dom = dhtmlparser.parseString(xml)\n\n    doc_number_tag = dom.find(\"doc_number\")\n\n    if not doc_number_tag:\n        return \"-1\"\n\n    return doc_number_tag[0].getContent().strip()", "response": "Parses the doc_number tag from xml and returns the doc_number string or - 1 if not found."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef serialize(data, format: str = 'json', pretty: bool = False):\n    def encode(obj):\n        if isinstance(obj, stellata.model.Model):\n            return obj.to_dict()\n        elif isinstance(obj, datetime.datetime):\n            return int(obj.timestamp())\n        elif isinstance(obj, datetime.date):\n            return obj.isoformat()\n        elif isinstance(obj, decimal.Decimal):\n            return float(obj)\n        elif hasattr(obj, 'serialize'):\n            return obj.serialize()\n\n        return obj\n\n    if format == 'msgpack':\n        return msgpack.packb(data, default=encode)\n\n    if format == 'json':\n        if pretty:\n            return json.dumps(data, default=encode, indent=4)\n        return json.dumps(data, default=encode)\n\n    return data", "response": "Serialize a stellata object to a string format."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a docstring for the specified executable.", "response": "def pretty_exe_doc(program, parser, stack=1, under='-'):\n    \"\"\"\n    Takes the name of a script and a parser that will give the help message for it.\n    The module that called this function will then add a header to the docstring\n    of the script, followed immediately by the help message generated\n    by the OptionParser\n\n    :param str program: Name of the program that we want to make the header\n    :param optparser.Option parser: Either a parser or a callable with no arguments\n                                    that will give the desired parser\n    :param int stack: How far up the stack to get the docstring to change\n    :param str under: The character you want for the program underline\n    \"\"\"\n\n    if os.path.basename(sys.argv[0]) == 'sphinx-build':\n        # Get the calling module\n        mod = inspect.getmodule(inspect.stack()[stack][0])\n\n        # Get parser\n        _parser = parser() if '__call__' in dir(parser) else parser\n\n        # Make the parser use the correct program\n        _parser.set_usage(mod.__usage__.replace('%prog', program))\n\n        # Modify docs by adding a header and usate\n        mod.__doc__ = '\\n'.join(['', program, under * len(program), '::', ''] +\n                                ['    %s' % l for l in _parser.format_help().split('\\n')]) + \\\n                                mod.__doc__"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main():  # suppress(unused-function)\n    description = (\"\"\"Pre-populate cache for polysquare-generic-file-linter \"\"\"\n                   \"\"\"and spellcheck-linter.\"\"\")\n    parser = argparse.ArgumentParser(description=description)\n    parser.add_argument(\"cache_path\",\n                        metavar=(\"PATH\"),\n                        help=\"\"\"PATH to cache\"\"\",\n                        type=str)\n    parser.add_argument(\"--technical-terms\",\n                        metavar=(\"FILE\"),\n                        help=\"\"\"FILE containing technical terms\"\"\",\n                        type=str)\n    arguments = parser.parse_args(sys.argv[1:])\n    valid_words_dictionary.create(arguments.cache_path)\n    technical_words_dictionary.create(arguments.technical_terms,\n                                      arguments.cache_path)\n    return 0", "response": "Entry point for the command line interface."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_key(self, key_id):\n        url = ENCRYPTION_KEY_URL.format(key_id)\n        return self._key_from_json(self._get_resource(url))", "response": "Returns a restclients. Key object for the given key ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a restclients. Key object for the given resource.", "response": "def get_current_key(self, resource_name):\n        \"\"\"\n        Returns a restclients.Key object for the given resource.  If the\n        resource isn't found, or if there is an error communicating with the\n        KWS, a DataFailureException will be thrown.\n        \"\"\"\n        url = ENCRYPTION_CURRENT_KEY_URL.format(resource_name)\n        return self._key_from_json(self._get_resource(url))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _key_from_json(self, data):\n        key = Key()\n        key.algorithm = data[\"Algorithm\"]\n        key.cipher_mode = data[\"CipherMode\"]\n        key.expiration = datetime.strptime(data[\"Expiration\"].split(\".\")[0],\n                                           \"%Y-%m-%dT%H:%M:%S\")\n        key.key_id = data[\"ID\"]\n        key.key = data[\"Key\"]\n        key.size = data[\"KeySize\"]\n        key.url = data[\"KeyUrl\"]\n        return key", "response": "Internal method for creating the Key object from a JSON dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qrplatba(pdf,\n             IBAN, castka=None, mena='CZK', splatnost=None, msg=None, KS='0558', VS='', SS=None, IBAN2=None,\n             w=36, x=None, y=None, **payment_more):\n    \"\"\"This is the main method which generates the QR platba code.\n    pdf - object from: with PDF(<outputfilename>) as pdf:\n        (we use wfpdf (which is really minor wrapper),\n        we haven't not tested the calling with fpdf directly, but maybe it is easy)\n    IBAN..IBAN2 - ACC, AM, CC, DT, MSG, X-KS, X-VS, X-SS, ALT-ACC attributes of payment\n    w - width [mm] of the generated image (real width is a little bigger thanks to lines and 'QR platba' label)\n    code is printed at current position (if not defined using x,y)\n        current position moves to the end of 'QR platba' label\n    **payment_more - any other payment attributes (key=value will generate *key:value , '_' in key changes to '-')\n    \"\"\"\n    if x is None:\n        x = pdf.get_x()\n    if y is None:\n        y = pdf.get_y()\n\n    qr = 'SPD*1.0*ACC:' + IBAN\n    if IBAN2:\n        qr += '*ALT-ACC:' + IBAN2\n    if castka:\n        qr += '*AM:'\n        try:\n            qr += '%.2f' % castka\n        except TypeError:\n            qr += castka\n    if mena:\n        qr += '*CC:' + mena\n    if splatnost:\n        qr += '*DT:'\n        try:\n            qr += splatnost\n        except TypeError:\n            qr += date.strftime(splatnost, '%Y%m%d')\n    if msg:\n        qr += '*MSG:' + msg\n    if KS:\n        qr += '*X-KS:' + KS\n    if VS:\n        qr += '*X-VS:' + VS\n    if SS:\n        qr += '*X-SS:' + SS\n    for key in payment_more:\n        qr += '*%s:' % key.replace('_', '-') + payment_more[key]\n\n    png, pixels = getQRCode(qr)\n    # as long as we generate qr code with scale=1 w/pixels is module size in [mm]:\n    module_size = 1.0 * w / pixels\n    # for the line around we add 1* module_size to sure have good quiet zone\n    pdf.image(png, x=x + module_size, y=y + module_size, w=w, type='png')\n    os.unlink(png)\n\n    pdf.set_font_size(6)\n    # pdf.set_font('', style='B')  # we don't set this here\n    pllbl = 'QR platba'\n    pllbl_w = pdf.get_string_width(pllbl)\n    # some positions in next code were corrected (+-module_size) to obtain good result\n    pllbl_right = x + pllbl_w + 7 * module_size\n    square_size = w + 2 * module_size\n    pdf.line(x, y, x + square_size, y)                                        # top\n    pdf.line(x, y, x, y + square_size)                                        # left\n    pdf.line(x + square_size, y, x + square_size, y + square_size)            # right\n    pdf.line(x, y + square_size, x + 2 * module_size, y + square_size)        # bottom before\n    pdf.line(pllbl_right, y + square_size, x + square_size, y + square_size)  # bottom after\n    pdf.set_xy(x + 3 * module_size, y + square_size)\n    pdf.cell(pllbl_w, h=2, txt=pllbl)", "response": "This method generates the QR platba code from the specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_value(self, spreadsheet_id: str, range_name: str) -> dict:\n        service = self.__get_service()\n        result = service.spreadsheets().values().get(spreadsheetId=spreadsheet_id, range=range_name).execute()\n        return result.get('values', [])", "response": "get value by range"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef with_timeout(timeout, d, reactor=reactor):\n    if timeout is None or not isinstance(d, Deferred):\n        return d\n\n    ret = Deferred(canceller=lambda _: (\n        d.cancel(),\n        timeout_d.cancel(),\n    ))\n\n    timeout_d = sleep(timeout, reactor)\n    timeout_d.addCallback(lambda _: (\n        d.cancel(),\n        ret.errback(Failure(Timeout())) if not ret.called else None,\n    ))\n\n    timeout_d.addErrback(lambda f: f.trap(CancelledError))\n\n    d.addCallback(lambda result: (\n        timeout_d.cancel(),\n        ret.callback(result),\n    ))\n\n    d.addErrback(lambda f: (\n        if_(not f.check(CancelledError), lambda: (\n            timeout_d.cancel(),\n            ret.errback(f),\n            )),\n    ))\n\n    return ret", "response": "Returns a Deferred that will be cancelled after the specified number of seconds."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef form(self, usr=None, **kwargs):\n        if self.usr: usr = self.usr\n        if self.find(\"form\", kwargs):\n            return HTTPForm(usr, self.url, self.find(\"form\", kwargs))", "response": "Returns an HTTPForm that matches the given criteria\n        \n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef newSession():\n        from neolib.config.Configuration import Configuration\n        \n        s = requests.session()\n        if not Configuration.loaded():\n            if not Configuration.initialize():\n                s.headers.update(Page._defaultVars)\n            else:\n                s.headers.update(Configuration.getConfig().core.HTTPHeaders.toDict())\n        else:\n            s.headers.update(Configuration.getConfig().core.HTTPHeaders.toDict())\n        \n        return requests.session()", "response": "Returns a new Requests session with pre - loaded default HTTP Headers and Configuration class\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef verify_port_map(plugin):\n    result = True\n    ex_ports = plugin.get(EX_PORTS_KEY)\n    result &= isinstance(ex_ports, list) and verify_ports(ex_ports)\n    in_ports = plugin.get(IN_PORTS_KEY)\n    result &= isinstance(in_ports, list) and verify_ports(in_ports)\n    env_list = plugin.get(ENV_KEY)\n    result &= isinstance(env_list, list) and verify_environment(env_list)\n    if result:\n        result &= len(ex_ports) == len(in_ports)\n    return result", "response": "extra validation of port map"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef verify_ports(port_list):\n    result = True  # empty list is ok\n    for item in port_list:\n        try:\n            (port, protocol) = item.split(PORT_SEPARATOR)\n            port_num = int(port)\n        except ValueError:\n            result = False\n            break\n        result &= protocol in ALLOWED_PROTOCOLS\n        result &= port == str(port_num)\n    return result", "response": "Verify that the ports in the list are ok."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn constraints to target a specific model.", "response": "def get_model_id_constraints(model):\n  \"\"\"Returns constraints to target a specific model.\"\"\"\n  pkname = model.primary_key_name\n  pkey = model.primary_key\n  return get_id_constraints(pkname, pkey)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_id_constraints(pkname, pkey):\n  if isinstance(pkname, str):\n    return {pkname: pkey}\n  else:\n    return dict(zip(pkname, pkey))", "response": "Returns a dict with pkname = pkey. pkname = pkey. pkey = pkname. pkname = pkey. pkey = pkey. pkname = pkey. pkey = pkey. pkname = pkey. pkname = pkey. pkey = pkey. pkname = pkey. pkname = pkey. pkey = pkname. pkname = pkey. pkey = pkey. pkname = pkey."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall DataAccess. find and passes the results to the given constructor.", "response": "def _find_model(self, constructor, table_name, constraints=None, *, columns=None, order_by=None):\n    \"\"\"Calls DataAccess.find and passes the results to the given constructor.\"\"\"\n    data = self.find(table_name, constraints, columns=columns, order_by=order_by)\n    return constructor(data) if data else None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling DataAccess. find_all and passes the results to the given constructor.", "response": "def _find_models(self, constructor, table_name, constraints=None, *, columns=None,\n                   order_by=None, limiting=None):\n    \"\"\"Calls DataAccess.find_all and passes the results to the given constructor.\"\"\"\n    for record in self.find_all(table_name, constraints, columns=columns, order_by=order_by,\n                                limiting=limiting):\n      yield constructor(record)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef page_models(self, constructor, paging, constraints=None, *, columns=None, order_by=None):\n    records, count = self.page(constructor.table_name, paging, constraints, columns=columns,\n                               order_by=order_by)\n    return ([constructor(r) for r in records], count)", "response": "Specialization of DataAccess. page that returns models instead of cursor objects."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_model_by_id(self, constructor, id_, *, columns=None):\n    return self.find_model(\n      constructor, get_id_constraints(constructor.primary_key_name, id_), columns=columns)", "response": "Searches for a model by id according to its class primary_key_name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef refresh_model(self, model, *, overwrite=False):\n    new_model = self.find_model_by_id(model.__class__, model.primary_key)\n    if overwrite:\n      model.update(new_model.to_dict(use_default_excludes=False))\n      return model\n    else:\n      return new_model", "response": "Refreshes the model instance with the latest record from the database."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate a model. :include_keys: if given, only updates the given attributes. Otherwise, updates all non-id attributes.", "response": "def update_model(self, model, *, include_keys=None):\n    \"\"\"Updates a model.\n\n    :include_keys: if given, only updates the given attributes. Otherwise, updates all non-id\n    attributes.\n    \"\"\"\n    id_constraints = get_model_id_constraints(model)\n\n    if include_keys is None:\n      include_keys = set(\n        model.attrs.keys()).difference(model.exclude_keys_sql).difference(id_constraints.keys())\n\n    # If include_keys was not null but was empty\n    if not include_keys:\n      return model\n\n    values = model.to_dict(include_keys=include_keys)\n    returnings = []\n\n    _, updated_ts = model.timestamps if model.timestamps else (None, None)\n\n    if updated_ts and updated_ts not in values:\n      values[updated_ts] = utc_now() if self.core.supports_timezones else local_now()\n      returnings.append(updated_ts)\n\n    returning = \", \".join(returnings)\n    cr = self.update(model.table_name, values, id_constraints, returning=returning)\n\n    if returning and self.core.supports_returning_syntax:\n      rec = cr.fetchone()\n      for idx, attr_name in enumerate(returnings):\n        setattr(model, attr_name, rec[idx])\n\n    return model"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninserting a record for the given model.", "response": "def insert_model(self, model, *, upsert=None):\n    \"\"\"Inserts a record for the given model.\n\n    If model's primary key is auto, the primary key will be set appropriately.\n    \"\"\"\n    pkname = model.primary_key_name\n    include_keys = set(model.attrs.keys()).difference(model.exclude_keys_sql)\n\n    if model.primary_key_is_auto:\n      if pkname in include_keys:\n        include_keys.remove(pkname)\n    else:\n      if isinstance(pkname, str):\n        include_keys.add(pkname)\n      else:\n        include_keys.update(set(pkname))\n\n    data = model.to_dict(include_keys=include_keys)\n    returnings = []\n\n    if model.primary_key_is_auto:\n      returnings.append(pkname)\n    if model.timestamps:\n      returnings.extend(ts_name for ts_name in model.timestamps if ts_name)\n\n    returning = \", \".join(returnings)\n    cr = self.insert(model.table_name, data, returning=returning, upsert=upsert)\n\n    if self.core.supports_returning_syntax:\n      if returning:\n        rec = cr.fetchone()\n        if rec:\n          for idx, attr_name in enumerate(returnings):\n            setattr(model, attr_name, rec[idx])\n    else:\n      if model.primary_key_is_auto:\n        setattr(model, model.primary_key_name, cr.lastrowid)\n\n    return model"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_model(self, model_or_type, id_=None):\n    if not id_:\n      constraints = get_model_id_constraints(model_or_type)\n    else:\n      constraints = get_id_constraints(model_or_type.primary_key_name, id_)\n    self.delete(model_or_type.table_name, constraints)\n\n    return model_or_type", "response": "Deletes a model.\n\n    :model_or_type: if a model, delete that model. If it is a ModelBase subclass, id_ must be\n    specified, and the associated record is deleted."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_or_build(self, constructor, props):\n    model = self.find_model(constructor, props)\n    return model or constructor(**props)", "response": "Looks for a model that matches the given dictionary constraints. If it is not found a new\n    model is returned."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_or_create(self, constructor, props, *, comp=None):\n    model = self.find_model(constructor, comp or props)\n    if model is None:\n      model = constructor(**props)\n      self.insert_model(model)\n    return model", "response": "Looks for a model taht matches the given dictionary constraints. If it is not found a new object is created and returned."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_or_upsert(self, constructor, props, *, comp=None, return_status=False):\n    model = self.find_model(constructor, comp or props)\n    status = _UPSERT_STATUS_FOUND\n\n    if model is None:\n      model = constructor(**props)\n      status = _UPSERT_STATUS_CREATED\n      self.insert_model(model, upsert=Upsert(Upsert.DO_NOTHING))\n      if model.is_new:\n        model = self.find_model(constructor, comp or props)\n        status = _UPSERT_STATUS_DUPLICATE\n\n    if return_status:\n      return (model, status)\n    else:\n      return model", "response": "This method finds or upserts a new model with the given properties."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef temp_copy(self):\n        with contextmanagers.temp_dir() as temp_dir:\n            temp_root_path = os.path.join(temp_dir, 'root')\n            path = os.path.join(self.path, '')  # adds trailing slash\n            check_call(['rsync', '-r', \"--exclude={}\".format(self.private_dir()), \"--filter=dir-merge,- {}\".format(\n                self.ignore_patterns_file()), path, temp_root_path])\n            copy = self.__class__(path=temp_root_path)\n            yield copy", "response": "Yields a new Vcs object that represents a temporary disposable\n            copy of the current repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses a discussion form.", "response": "def process_form(request, form_class, form_dict=None, save_kwargs=None, *a, **kw):\n    '''\n        Optional:\n        =========\n\n        You can pass kwargs to the form save function in a 'save_kwargs' dict.\n\n\n        Example Usage:\n        ==============\n\n        success, form = process_form(request, DiscussionForm, initial={\n            'category':Category.objects.all()[0].id,\n        })\n        if success:\n            return form # this is the return from the forms save method.\n\n        return template(request, 'talk/create_discussion.html', {\n            'categories': Category.objects.all(),\n            'form': form\n        })\n    '''\n\n    form = form_class(form_dict or request.POST or None, *a, **kw)\n\n    if request.method == 'POST':\n        if form.is_valid():\n            if not save_kwargs:\n                save_kwargs = {}\n            results = form.save(request=request, **save_kwargs)\n            return (True, results)\n    return (False, form)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef friendly_type_name(self) -> str:\n        _constraints_set = []\n        if self._must_be_dir:\n            _constraints_set.append('must be a directory')\n        if self._must_be_file:\n            _constraints_set.append('must be a file')\n        if self._must_exist:\n            _constraints_set.append('must already exist')\n        _constraints_as_str = ' (' + ', '.join(_constraints_set) + ')' if _constraints_set else ''\n        return 'path' + _constraints_as_str", "response": "Returns a friendly type name for the end - user - related entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntweeting status of images", "response": "def tweet(self, status, images):\n        # time.sleep(10)\n        template = \"%s #soyprice\"\n        \"\"\"\n        if not images:\n            self.twitter.update_status(status=template % status)\n        else:\n            medias = map(lambda i: self.upload_media(i), images)\n            self.twitter.post('/statuses/update_with_media',\n                              params={'status': template % status,\n                              'media': medias[0]})\n                              \"\"\"\n        print template % status, len(template % status)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a new PageSet that contains only the published pages.", "response": "def published(self, for_user=None, include_login_required=False):\n        \"\"\"\n        Override ``DisplayableManager.published`` to exclude\n        pages with ``login_required`` set to ``True``. if the\n        user is unauthenticated and the setting\n        ``PAGES_PUBLISHED_INCLUDE_LOGIN_REQUIRED`` is ``False``.\n\n        The extra ``include_login_required`` arg allows callers to\n        override the ``PAGES_PUBLISHED_INCLUDE_LOGIN_REQUIRED``\n        behaviour in special cases where they want to deal with the\n        ``login_required`` field manually, such as the case in\n        ``PageMiddleware``.\n        \"\"\"\n        published = super(PageManager, self).published(for_user=for_user)\n        unauthenticated = for_user and not for_user.is_authenticated()\n        if (unauthenticated and not include_login_required and\n                not settings.PAGES_PUBLISHED_INCLUDE_LOGIN_REQUIRED):\n            published = published.exclude(login_required=True)\n        return published"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate or update a symbolic link atomically.", "response": "def atomic_symlink(src, dst):\n    \"\"\"Create or update a symbolic link atomically.\n\n    This function is similar to :py:func:`os.symlink` but will update a symlink atomically.\"\"\"\n\n    dst_dir = os.path.dirname(dst)\n    tmp = None\n    max_tries = getattr(os, 'TMP_MAX', 10000)\n\n    try:\n        if not os.path.exists(dst_dir):\n            os.makedirs(dst_dir)\n        for n in range(max_tries):\n            try:\n                # mktemp is described as being unsafe. That is not true in this case since symlink is an\n                # atomic operation at the file system level; if some other processes creates a file with\n                # 'our' name then symlink will fail.\n                tmp = tempfile.mktemp(dir=dst_dir)\n                os.symlink(src, tmp)\n                logger.debug('created symlink %s', tmp)\n            except OSError as e:\n                if e.errno == errno.EEXIST:\n                    continue  # Someone else grabbed the temporary name first\n                else:\n                    raise\n            logger.debug('renaming %s to %s', tmp, dst)\n            os.rename(tmp, dst)\n            return\n    except:\n        if tmp and os.path.exists(tmp):\n            os.remove(tmp)\n        raise\n    raise IOError(errno.EEXIST, 'No usable temporary file name found')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes the command loop", "response": "def run():  #pylint: disable=too-many-locals\n    \"\"\"Execute the command loop\n    \"\"\"\n    store = EventStore(STORE_PATH)\n    with open(CREDENTIAL_PATH, 'r') as cred_file:\n        creds = json.load(cred_file)\n        uname, pword = creds['uname'], creds['pword']\n    mgr = KindleProgressMgr(store, uname, pword)\n\n    print 'Detecting updates to Kindle progress:'\n    events = mgr.detect_events()\n    if events is None:\n        print 'Failed to retrieve Kindle progress updates'\n        return\n    elif not events:\n        print '  No updates detected'\n    else:\n        for event in events:\n            print '  ' + str(event)\n\n    print\n    print 'Finished updating.'\n    print 'Mark new books as \\'reading\\' or old books as \\'read\\'? (y/N)'\n    if safe_raw_input('> ') == 'y':\n        _change_state_prompt(mgr)\n    mgr.commit_events()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns a prompt to change the state of books.", "response": "def _change_state_prompt(mgr):\n    \"\"\"Runs a prompt to change the state of books.\n\n    Registers `Event`s with `mgr` as they are requested.\n\n    Args:\n        mgr: A `KindleProgressMgr` object with the `books` and `progress`\n            fields populated.\n    \"\"\"\n    cmd = ''\n    book_range = range(1, len(mgr.books) + 1)\n    ind_to_book = dict(zip(book_range, mgr.books))\n    get_book = lambda cmd_str: ind_to_book[int(cmd_str.split()[1])]\n    while cmd != 'q':\n        print 'Books:'\n        for i in book_range:\n            print '\\t%d: %s' % (i, ind_to_book[i])\n        print 'Commands:'\n        print '| start {#}   | Start reading book with index {#}'\n        print '| finish {#}  | Finish reading book with index {#}'\n        print '| q           | Quit'\n        cmd = safe_raw_input('> ')\n        if cmd is None or cmd == 'q':\n            break\n        elif cmd.startswith('start '):\n            book = get_book(cmd)\n            initial_progress = mgr.progress[book.asin].locs[1]\n            event = SetReadingEvent(book.asin, initial_progress)\n        elif cmd.startswith('finish '):\n            event = SetFinishedEvent(get_book(cmd).asin)\n        else:\n            print 'Invalid command'\n            event = None\n        if event is not None:\n            print\n            print 'REGISTERED EVENT:'\n            print '  ' + str(event)\n            mgr.register_events((event))\n        print"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef change_sheet(self, sheet_name_or_num):\n        if isinstance(sheet_name_or_num, int):\n            self._sheet = self.__wb[self.__wb.sheetnames[sheet_name_or_num]]\n        elif isinstance(sheet_name_or_num, basestring):\n            self._sheet = self.__wb[sheet_name_or_num]\n        else:\n            reason = \"Must enter either sheet name or sheet number.\"\n            raise Exception(reason)", "response": "Changes the active sheet."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _os_install(self, package_file):\n        packages = \" \".join(json.load(package_file.open()))\n        if packages:\n            for packager in self.pkg_install_cmds:\n                if packager in self.context.externalbasis:\n                    installer = self.pkg_install_cmds[packager]\n            return f\"RUN    {installer} {packages}\"\n        else:\n            return \"\"", "response": "return a string of docker build RUN directives one RUN per package type one package type per JSON file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pave_profile(self):\n        settings.personal_config.path.mkdir()\n        json.dump(\n            settings.personal_config.package_list,\n            settings.personal_config.os_packages.open(mode=\"w\"),\n        )\n        json.dump({}, settings.personal_config.lang_packages.open(mode=\"w\"))\n        settings.personal_config.projects.mkdir()", "response": "This function writes the pave profile to the settings."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pave_community(self):\n        settings.project_config.path.mkdir()\n        settings.project_config.base.write_text(self.context.base_text)\n        settings.project_config.os_packages.write_text(\"[]\")\n        settings.project_config.lang_packages.write_text(\"{}\")", "response": "This function is used to set up the pave community for the current context."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build(self):\n        docker_build = docker.from_env().api.build\n        build_actions = []\n        for a in docker_build(\n            str(settings.project_customization.path), tag=settings.tag\n        ):\n            build_actions.append(a)", "response": "Build all the available images"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns the containment runfile", "response": "def run(self):\n        \"\"\"\n        Usage:\n          containment run\n        \"\"\"\n        run_command = (\n            settings.project_customization.runfile.read_text().split()\n        )\n        chmod_string = (\n            \"chmod +x \"\n            + settings.project_customization.runfile.absolute().as_posix()\n        )\n        subprocess.run(chmod_string.split())\n        subprocess.run(\n            run_command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconnecting to the RabbitMQ instance and return the current instance s ID.", "response": "async def connect(self):\n        \"\"\"\n        Create new asynchronous connection to the RabbitMQ instance.\n        This will connect, declare exchange and bind itself to the configured queue.\n\n        After that, client is ready to publish or consume messages.\n\n        :return: Does not return anything.\n        \"\"\"\n        if self.connected or self.is_connecting:\n            return\n\n        self._is_connecting = True\n        try:\n            logger.info(\"Connecting to RabbitMQ...\")\n            self._transport, self._protocol = await aioamqp.connect(**self._connection_parameters)\n\n            logger.info(\"Getting channel...\")\n            self._channel = await self._protocol.channel()\n\n            if self._global_qos is not None:\n                logger.info(\"Setting prefetch count on connection (%s)\", self._global_qos)\n                await self._channel.basic_qos(0, self._global_qos, 1)\n\n            logger.info(\"Connecting to exchange '%s (%s)'\", self._exchange_name, self._exchange_type)\n            await self._channel.exchange(self._exchange_name, self._exchange_type)\n\n        except (aioamqp.AmqpClosedConnection, Exception):\n            logger.error(\"Error initializing RabbitMQ connection\", exc_info=True)\n            self._is_connecting = False\n            raise exceptions.StreamConnectionError\n\n        self._is_connecting = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def consume_queue(self, subscriber: AbstractSubscriber) -> None:\n\n        \"\"\"\n        Subscribe to the queue consuming.\n\n        :param subscriber:\n        :return:\n        \"\"\"\n\n        queue_name = subscriber.name\n        topics = subscriber.requested_topics\n\n        if queue_name in self._known_queues:\n            raise exceptions.ConsumerError(\"Queue '%s' already being consumed\" % queue_name)\n\n        await self._declare_queue(queue_name)\n\n        # TODO: There is a lot of room to improvement here. Figure out routing done the right way\n        for key in topics:\n            self._routing.setdefault(key, set())\n            if subscriber in self._routing[key]:\n                logger.warning(\"Subscriber '%s' already receiving routing_key '%s'\", subscriber, key)\n                break\n            await self._bind_key_to_queue(key, queue_name)\n            self._routing[key].add(subscriber)\n\n        logger.info(\"Consuming queue '%s'\", queue_name)\n        await asyncio.wait_for(\n            self._channel.basic_consume(callback=self._on_message, queue_name=queue_name),\n            timeout=10\n        )\n        self._add_to_known_queue(queue_name)", "response": "Subscribe to the queue consuming."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def _bind_key_to_queue(self, routing_key: AnyStr, queue_name: AnyStr) -> None:\n        logger.info(\"Binding key='%s'\", routing_key)\n\n        result = await self._channel.queue_bind(\n            exchange_name=self._exchange_name,\n            queue_name=queue_name,\n            routing_key=routing_key,\n        )\n        return result", "response": "Bind to queue with specified routing key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def _on_message(self, channel, body, envelope, properties) -> None:\n\n        subscribers = self._get_subscribers(envelope.routing_key)\n        if not subscribers:\n            logger.debug(\"No route for message with key '%s'\", envelope.routing_key)\n            return\n\n        body = self._serializer.deserialize(body)\n\n        for subscriber in subscribers:\n            # Check later if ensure_future can be applied here\n            await subscriber.on_message(body, envelope.routing_key)\n\n        await self._channel.basic_client_ack(envelope.delivery_tag)", "response": "A message is received by this consumer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_this(func, types, args=None, delimiter_chars=\":\"):\n    _LOG.debug(\"Creating parser for %s\", func.__name__)\n    (func_args, dummy_1, dummy_2, defaults) = getargspec(func)\n    types, func_args = _check_types(func.__name__, types, func_args, defaults)\n    args_and_defaults = _get_args_and_defaults(func_args, defaults)\n    parser = _get_arg_parser(func, types, args_and_defaults, delimiter_chars)\n    arguments = parser.parse_args(_get_args_to_parse(args, sys.argv))\n    return _call(func, func_args, arguments)", "response": "Create an ArgParser for the given function converting the command line arguments according to the list of types and arguments to be parsed."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds all the sub - parsers to the top - level parser.", "response": "def _add_sub_parsers(self, top_level_parser, methods_to_parse, class_name):\n        \"\"\"Add all the sub-parsers to the top_level_parser.\n\n        Args:\n            top_level_parser: the top level parser\n            methods_to_parse: dict of method name pointing to their associated\n            argument parser\n            class_name: name of the decorated class\n\n        Returns:\n            a dict of registered name of the parser i.e. sub command name\n            pointing to the method real name\n        \"\"\"\n        description = \"Accessible methods of {}\".format(class_name)\n        sub_parsers = top_level_parser.add_subparsers(description=description,\n                                                      dest=\"method\")\n        # Holds the mapping between the name registered for the parser\n        # and the method real name. It is useful in the 'inner_call'\n        # method retrieve the real method\n        parser_to_method = {}\n        for method_name, parser in methods_to_parse.items():\n            # We use the name provided in 'create_parser` or the name of the\n            # decorated method\n            parser_name = parser.get_name() or method_name\n            # Make the method name compatible for the argument parsing\n            if parser_name.startswith(\"_\"):\n                if not self._parse_private:\n                    # We skip private methods if the caller asked not to\n                    # parse them\n                    continue\n                # 'Private' methods are exposed without their leading or\n                # trailing '_'s. Also works for 'special' methods.\n                parser_name = parser_name.strip(\"_\")\n            parser_name = parser_name.replace(\"_\", \"-\")\n            parser_to_method[parser_name] = method_name\n            sub_parsers.add_parser(parser_name, parents=[parser],\n                                   add_help=False,\n                                   description=parser.description)\n        return parser_to_method"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate the complete argument parser for the decorated class.", "response": "def _set_class_parser(self, init_parser, methods_to_parse, cls):\n        \"\"\"Creates the complete argument parser for the decorated class.\n\n        Args:\n            init_parser: argument parser for the __init__ method or None\n            methods_to_parse: dict of method name pointing to their associated\n            argument parser\n            cls: the class we are decorating\n\n        Returns:\n            The decorated class with an added attribute 'parser'\n        \"\"\"\n        top_level_parents = [init_parser] if init_parser else []\n        description = self._description or cls.__doc__\n        top_level_parser = argparse.ArgumentParser(description=description,\n                                                   parents=top_level_parents,\n                                                   add_help=False,\n                                                   conflict_handler=\"resolve\")\n        top_level_parser.add_argument(\"-h\", \"--help\", action=FullHelpAction,\n                                      help=\"Display this help message\")\n        parser_to_method = self._add_sub_parsers(top_level_parser,\n                                                 methods_to_parse,\n                                                 cls.__name__)\n        # Update the dict with the __init__ method so we can instantiate\n        # the decorated class\n        if init_parser:\n            parser_to_method[\"__init__\"] = \"__init__\"\n        top_level_parser.call = self._get_parser_call_method(parser_to_method)\n        cls.parser = top_level_parser"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the parser special method call that handles sub - command calling.", "response": "def _get_parser_call_method(self, parser_to_method):\n        \"\"\"Return the parser special method 'call' that handles sub-command\n            calling.\n\n        Args:\n            parser_to_method: mapping of the parser registered name\n            to the method it is linked to\n        \"\"\"\n        def inner_call(args=None, instance=None):\n            \"\"\"Allows to call the method invoked from the command line or\n            provided argument.\n\n            Args:\n                args: list of arguments to parse, defaults to command line\n                arguments\n                instance: an instance of the decorated class. If instance is\n                None, the default, and __init__ is decorated the object will be\n                instantiated on the fly from the command line arguments\n            \"\"\"\n            parser = self._cls.parser\n            namespace = parser.parse_args(_get_args_to_parse(args, sys.argv))\n            if instance is None:\n                # If the __init__ method is not part of the method to\n                # decorate we cannot instantiate the class\n                if \"__init__\" not in parser_to_method:\n                    raise ParseThisError((\"'__init__' method is not decorated. \"\n                                          \"Please provide an instance to \"\n                                          \"'{}.parser.call' or decorate the \"\n                                          \"'__init___' method with \"\n                                          \"'create_parser'\"\n                                          .format(self._cls.__name__)))\n                # We instantiate the class from the command line arguments\n                instance = _call_method_from_namespace(self._cls, \"__init__\",\n                                                       namespace)\n            method_name = parser_to_method[namespace.method]\n            return _call_method_from_namespace(instance, method_name, namespace)\n        return inner_call"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns the analyses and return a StateCollection object.", "response": "def run_analyses(prepared_analyses=None,log_dir=default_log_dir):\n    \"\"\"\n        If all defaults are ok, this should be the only function needed to run the analyses.\n    \"\"\"\n    if prepared_analyses == None:\n        prepared_analyses = prepare_analyses()\n    state_collection = funtool.state_collection.StateCollection([],{})\n    for analysis in prepared_analyses:\n        state_collection= funtool.analysis.run_analysis(analysis, state_collection, log_dir)\n    return state_collection"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning the named analysis.", "response": "def run_analysis( named_analysis, prepared_analyses=None,log_dir=default_log_dir):\n    \"\"\"\n    Runs just the named analysis. Otherwise just like run_analyses\n    \"\"\"\n    if prepared_analyses == None:\n        prepared_analyses = prepare_analyses()\n    state_collection = funtool.state_collection.StateCollection([],{})\n    for analysis in prepared_analyses:\n        if analysis.name == named_analysis:\n            state_collection= funtool.analysis.run_analysis(analysis, state_collection, log_dir)\n    return state_collection"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a MARC XML string to a namedtuple of data about the EPublication.", "response": "def from_xml(xml):\n        \"\"\"\n        Convert :class:`.MARCXMLRecord` object to :class:`.EPublication`\n        namedtuple.\n\n        Args:\n            xml (str/MARCXMLRecord): MARC XML which will be converted to\n                EPublication. In case of str, ``<record>`` tag is required.\n\n        Returns:\n            structure: :class:`.EPublication` namedtuple with data about \\\n                       publication.\n        \"\"\"\n        parsed = xml\n        if not isinstance(xml, MARCXMLRecord):\n            parsed = MARCXMLRecord(str(xml))\n\n        # check whether the document was deleted\n        if \"DEL\" in parsed.datafields:\n            raise DocumentNotFoundException(\"Document was deleted.\")\n\n        # convert Persons objects to amqp's Authors namedtuple\n        authors = map(\n            lambda a: Author(\n                (a.name + \" \" + a.second_name).strip(),\n                a.surname,\n                a.title\n            ),\n            parsed.get_authors()\n        )\n\n        # i know, that this is not PEP8, but you dont want to see it without\n        # proper formating (it looks bad, really bad)\n        return EPublication(\n            ISBN                = parsed.get_ISBNs(),\n            invalid_ISBN        = parsed.get_invalid_ISBNs(),\n            id_number           = parsed.controlfields.get(\"001\", None),\n            nazev               = parsed.get_name(),\n            podnazev            = parsed.get_subname(),\n            vazba               = _first_or_blank_string(parsed.get_binding()),\n            cena                = parsed.get_price(),\n            castDil             = parsed.get_part(),\n            nazevCasti          = parsed.get_part_name(),\n            nakladatelVydavatel = parsed.get_publisher(),\n            datumVydani         = parsed.get_pub_date(),\n            poradiVydani        = parsed.get_pub_order(),\n            zpracovatelZaznamu  = _first_or_blank_string(parsed[\"040a\"]),\n            format              = parsed.get_format(),\n            url                 = parsed.get_urls(),\n            mistoVydani         = parsed.get_pub_place(),\n            ISBNSouboruPublikaci= [],\n            autori              = authors,\n            originaly           = parsed.get_originals(),\n            internal_url        = parsed.get_internal_urls(),\n            anotace             = None, # TODO: read the annotation\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef poll(self):\n        self.runner.module_name = 'async_status'\n        self.runner.module_args = \"jid=%s\" % self.jid\n        self.runner.pattern = \"*\"\n        self.runner.background = 0\n\n        self.runner.inventory.restrict_to(self.hosts_to_poll)\n        results = self.runner.run()\n        self.runner.inventory.lift_restriction()\n\n        hosts = []\n        poll_results = { 'contacted': {}, 'dark': {}, 'polled': {}}\n        for (host, res) in results['contacted'].iteritems():\n            if res.get('started',False):\n                hosts.append(host)\n                poll_results['polled'][host] = res\n            else:\n                self.results['contacted'][host] = res\n                poll_results['contacted'][host] = res\n                if 'failed' in res:\n                    self.runner.callbacks.on_async_failed(host, res, self.jid)\n                else:\n                    self.runner.callbacks.on_async_ok(host, res, self.jid)\n        for (host, res) in results['dark'].iteritems():\n            self.results['dark'][host] = res\n            poll_results['dark'][host] = res\n            self.runner.callbacks.on_async_failed(host, res, self.jid)\n\n        self.hosts_to_poll = hosts\n        if len(hosts)==0:\n            self.completed = True\n\n        return poll_results", "response": "Poll the job status.\n            Returns the changes in this iteration."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwaiting a certain time for the job to complete.", "response": "def wait(self, seconds, poll_interval):\n        \"\"\" Wait a certain time for job completion, check status every poll_interval. \"\"\"\n        # jid is None when all hosts were skipped\n        if self.jid is None:\n            return self.results\n\n        clock = seconds - poll_interval\n        while (clock >= 0 and not self.completed):\n            time.sleep(poll_interval)\n\n            poll_results = self.poll()\n\n            for (host, res) in poll_results['polled'].iteritems():\n                if res.get('started'):\n                    self.runner.callbacks.on_async_poll(host, res, self.jid, clock)\n\n            clock = clock - poll_interval\n\n        return self.results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the in - line editing form for editing a single model field.", "response": "def get_edit_form(obj, field_names, data=None, files=None):\n    \"\"\"\n    Returns the in-line editing form for editing a single model field.\n    \"\"\"\n\n    # Map these form fields to their types defined in the forms app so\n    # we can make use of their custom widgets.\n    from yacms.forms import fields\n    widget_overrides = {\n        forms.DateField: fields.DATE,\n        forms.DateTimeField: fields.DATE_TIME,\n        forms.EmailField: fields.EMAIL,\n    }\n\n    class EditForm(forms.ModelForm):\n        \"\"\"\n        In-line editing form for editing a single model field.\n        \"\"\"\n\n        app = forms.CharField(widget=forms.HiddenInput)\n        model = forms.CharField(widget=forms.HiddenInput)\n        id = forms.CharField(widget=forms.HiddenInput)\n        fields = forms.CharField(widget=forms.HiddenInput)\n\n        class Meta:\n            model = obj.__class__\n            fields = field_names.split(\",\")\n\n        def __init__(self, *args, **kwargs):\n            super(EditForm, self).__init__(*args, **kwargs)\n            self.uuid = str(uuid4())\n            for f in self.fields.keys():\n                field_class = self.fields[f].__class__\n                try:\n                    widget = fields.WIDGETS[widget_overrides[field_class]]\n                except KeyError:\n                    pass\n                else:\n                    self.fields[f].widget = widget()\n                css_class = self.fields[f].widget.attrs.get(\"class\", \"\")\n                css_class += \" \" + field_class.__name__.lower()\n                self.fields[f].widget.attrs[\"class\"] = css_class\n                self.fields[f].widget.attrs[\"id\"] = \"%s-%s\" % (f, self.uuid)\n                if settings.FORMS_USE_HTML5 and self.fields[f].required:\n                    self.fields[f].widget.attrs[\"required\"] = \"\"\n\n    initial = {\"app\": obj._meta.app_label, \"id\": obj.id,\n               \"fields\": field_names, \"model\": obj._meta.object_name.lower()}\n    return EditForm(instance=obj, initial=initial, data=data, files=files)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clean_description(self):\n        description = self.cleaned_data.get(\"description\")\n        validation_helper = safe_import_module(settings.FORUM_TEXT_VALIDATOR_HELPER_PATH)\n        if validation_helper is not None:\n            return validation_helper(self, description)\n        else:\n            return description", "response": "Clean the description of the object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _filter_disabled_regions(contents):\n    contents = list(contents)\n\n    in_backticks = False\n    contents_len = len(contents)\n\n    index = 0\n    while index < contents_len:\n        character = contents[index]\n        if character == \"`\":\n            # Check to see if we should toggle the in_backticks\n            # mode here by looking ahead for another two characters.\n            if ((index + 2) < contents_len and\n                    \"\".join(contents[index:index + 3]) == \"```\"):\n                in_backticks = not in_backticks\n                index += 3\n                continue\n\n        if in_backticks:\n            contents[index] = \" \"\n\n        index += 1\n\n    return \"\".join(contents)", "response": "Filter regions that are contained in back - ticks."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns spellcheck on the contents of a file.", "response": "def spellcheck(contents, technical_terms=None, spellcheck_cache=None):\n    \"\"\"Run spellcheck on the contents of a file.\n\n    :technical_terms: is a path to a file containing a list of \"technical\"\n    terms. These may be symbols as collected from files by using\n    the generic linter or other such symbols. If a symbol-like term is\n    used within contents and it does not appear in :technical_terms: then\n    an error will result.\n\n    :spellcheck_cache: is a path to a directory where graph files generated\n    by the spellchecking engine should be stored. It is used for caching\n    purposes between invocations, since generating the spellchecking\n    graph is an expensive operation which can take a few seconds to complete.\n    \"\"\"\n    contents = spelling.filter_nonspellcheckable_tokens(contents)\n    contents = _filter_disabled_regions(contents)\n    lines = contents.splitlines(True)\n    user_words, valid_words = valid_words_dictionary.create(spellcheck_cache)\n    technical_words = technical_words_dictionary.create(technical_terms,\n                                                        spellcheck_cache)\n\n    return sorted([e for e in spellcheck_region(lines,\n                                                valid_words,\n                                                technical_words,\n                                                user_words)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses command line arguments.", "response": "def _parse_arguments(arguments=None):\n    \"\"\"Return a parser context result.\"\"\"\n    dir_hash = hashlib.sha1(os.getcwd().encode(\"utf-8\")).hexdigest()\n\n    parser = argparse.ArgumentParser(description=\"\"\"Find spelling errors\"\"\")\n    parser.add_argument(\"files\",\n                        nargs=\"*\",\n                        metavar=(\"FILE\"),\n                        help=\"\"\"read FILE\"\"\",\n                        type=str)\n    parser.add_argument(\"--spellcheck-cache\",\n                        help=\"\"\"path to spell-checking cache file\"\"\",\n                        default=None)\n    parser.add_argument(\"--technical-terms\",\n                        help=\"\"\"path to file to source technical terms from\"\"\",\n                        default=None)\n    parser.add_argument(\"--stamp-file-path\",\n                        help=\"\"\"path to directory to store cached results\"\"\",\n                        default=os.path.join(tempfile.gettempdir(),\n                                             \"jobstamps\",\n                                             \"spellcheck_linter\",\n                                             dir_hash))\n\n    return parser.parse_args(arguments)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreport a spelling error.", "response": "def _report_spelling_error(error, file_path):\n    \"\"\"Report a spelling error.\"\"\"\n    line = error.line_offset + 1\n    code = \"file/spelling_error\"\n    description = _SPELLCHECK_MESSAGES[error.error_type].format(error.word)\n    if error.suggestions is not None:\n        description = (description +\n                       \", perhaps you meant: \" +\n                       \", \".join(error.suggestions))\n\n    sys.stdout.write(\"{0}:{1} [{2}] {3}\\n\".format(file_path,\n                                                  line,\n                                                  code,\n                                                  description))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef compare_version(value):\n\n    # extract parts from value\n    import re\n    res = re.match(r'(<|<=|==|>|>=)(\\d{1,2}\\.\\d{1,2}(\\.\\d{1,2})?)$',\n                   str(value).strip())\n    if not res:\n        return False\n    operator, value, _ = res.groups()\n\n    # break into pieces\n    value = tuple(int(x) for x in str(value).split('.'))\n    if len(value) < 3:\n        value += (0,)\n\n    version = __version_info__\n\n    if operator in ('<', '<='):\n        if version < value:\n            return True\n\n        if operator != '<=':\n            return False\n\n    elif operator in ('>=', '>'):\n        if version > value:\n            return True\n\n        if operator != '>=':\n            return False\n\n    return value == version", "response": "Determines if the provided version value compares with program version."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_all_publications(return_namedtuples=True):\n    sources = [\n        ben_cz.get_publications,\n        grada_cz.get_publications,\n        cpress_cz.get_publications,\n        zonerpress_cz.get_publications,\n    ]\n\n    # get data from all scrappers\n    publications = []\n    for source in sources:\n        publications.extend(\n            filters.filter_publications(source())\n        )\n\n    # convert to namedtuples\n    if return_namedtuples:\n        publications = map(lambda x: x.to_namedtuple(), publications)\n\n    return publications", "response": "Get list of publications from all available sources."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reraise(exception, message, separator='\\n'):\r\n    import sys\r\n\r\n    # IMPORTANT: Do NOT use try/except mechanisms in this method or the\r\n    # sys.exc_info()[-1] will be invalid\r\n\r\n    if hasattr(exception, 'reraised_message'):\r\n        current_message = exception.reraised_message\r\n    else:\r\n        current_message = exception_to_unicode(exception)\r\n\r\n    # Build the new message\r\n    if not current_message.startswith(separator):\r\n        current_message = separator + current_message\r\n    message = '\\n' + message + current_message\r\n\r\n    if exception.__class__ in _SPECIAL_EXCEPTION_MAP:\r\n        # Handling for special case, some exceptions have different behaviors.\r\n        exception = _SPECIAL_EXCEPTION_MAP[exception.__class__](\r\n            *exception.args\r\n        )\r\n\r\n    elif exception.__class__ not in _SPECIAL_EXCEPTION_MAP.values():\r\n        # In Python 2.5 overriding the exception \"__str__\" has no effect in\r\n        # \"unicode()\". Instead, we must change the \"args\" attribute which is\r\n        # used to build the string representation. Even though the\r\n        # documentation says \"args\" will be deprecated, it uses its first\r\n        # argument in unicode() implementation and not \"message\".\r\n        exception.args = (message,)\r\n\r\n    exception.message = message\r\n    # keep the already decoded message in the object in case this exception is\r\n    # reraised again\r\n    exception.reraised_message = message\r\n\r\n    # Reraise the exception with the EXTRA message information\r\n    if six.PY2:\r\n        six.reraise(exception, None, sys.exc_info()[-1])\r\n    else:\r\n        raise exception.with_traceback(sys.exc_info()[-1])", "response": "Raises the given exception with the given message."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a unicode representation of an exception in a sequence of strings.", "response": "def exception_to_unicode(exception):\r\n    \"\"\"\r\n    Obtains unicode representation of an Exception.\r\n\r\n    This wrapper is used to circumvent Python 2.7 problems with built-in\r\n    exceptions with unicode messages.\r\n\r\n    Steps used:\r\n        * Try to obtain Exception.__unicode__\r\n        * Try to obtain Exception.__str__ and decode with utf-8\r\n        * Try to obtain Exception.__str__ and decode with\r\n          locale.getpreferredencoding\r\n        * If all fails, return Exception.__str__ and decode with\r\n          (ascii, errors='replace')\r\n\r\n    :param Exception exception:\r\n\r\n    :return unicode:\r\n        Unicode representation of an Exception.\r\n    \"\"\"\r\n    if six.PY2:\r\n        try:\r\n            # First, try to obtain __unicode__ as defined by the Exception\r\n            return six.text_type(exception)\r\n        except UnicodeDecodeError:\r\n            try:\r\n                # If that fails, try decoding with utf-8 which is the strictest\r\n                # and will complain loudly.\r\n                return bytes(exception).decode('utf-8')\r\n            except UnicodeDecodeError:\r\n                try:\r\n                    # If that fails, try obtaining bytes repr and decoding with\r\n                    # locale\r\n                    return bytes(exception).decode(\r\n                        locale.getpreferredencoding()\r\n                    )\r\n                except UnicodeDecodeError:\r\n                    # If all failed, give up and decode with ascii replacing\r\n                    # errors.\r\n                    return bytes(exception).decode(errors='replace')\r\n        except UnicodeEncodeError:\r\n            # Some exception contain unicode messages, but try to convert them\r\n            # to bytes when calling unicode() (such as IOError). In these\r\n            # cases, we do our best to fix Python 2.7's poor handling of\r\n            # unicode exceptions.\r\n\r\n            # This should be true if code got here:\r\n            assert type(exception.message) == six.text_type\r\n\r\n            return exception.message\r\n    else:\r\n        return str(exception)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a cell according to its cell. value_type.", "response": "def parse_cell(self, cell, coords, cell_mode=CellMode.cooked):\n    \"\"\"Parses a cell according to its cell.value_type.\"\"\"\n    # pylint: disable=too-many-return-statements\n    if cell_mode == CellMode.cooked:\n      if cell.covered or cell.value_type is None or cell.value is None:\n        return None\n\n      vtype = cell.value_type\n\n      if vtype == 'string':\n        return cell.value\n\n      if vtype == 'float' or vtype == 'percentage' or vtype == 'currency':\n        return cell.value\n\n      if vtype == 'boolean':\n        return cell.value\n\n      if vtype == 'date':\n        date_tuple = tuple([int(i) if i is not None else 0 \\\n                            for i in _DATE_REGEX.match(cell.value).groups()])\n        return self.tuple_to_datetime(date_tuple)\n\n      if vtype == 'time':\n        hour, minute, second = _TIME_REGEX.match(cell.value).groups()\n        # TODO: This kills off the microseconds\n        date_tuple = (0, 0, 0, int(hour), int(minute), round(float(second)))\n        return self.tuple_to_datetime(date_tuple)\n\n      raise ValueError(\"Unhandled cell type: {0}\".format(vtype))\n    else:\n      return cell"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_row(self, row_index):\n    if self._raw_rows is None:\n      self._raw_rows = list(self.raw_sheet.rows())\n    return self._raw_rows[row_index]", "response": "Returns the row at row_index."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates the sequence of merged cell ranges in the format of a cell formula.", "response": "def merged_cell_ranges(self):\n    \"\"\"Generates the sequence of merged cell ranges in the format:\n\n    ((col_low, row_low), (col_hi, row_hi))\n    \"\"\"\n    for row_number, row in enumerate(self.raw_sheet.rows()):\n      for col_number, cell in enumerate(row):\n        rspan, cspan = cell.span\n        if (rspan, cspan) != (1, 1):\n          yield ((col_number, row_number), (col_number + cspan, row_number + rspan))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_student(self, **kwargs):\n        if len(kwargs) != 1 or not any(i in self.accepted_params for i in kwargs.keys()):\n            # Raises a TypeError if called with other than exactly 1 argument or with other parameter than the ones\n            # accepted.\n            raise TypeError('Called with invalid argument(s) and/or wrong number of arguments.')\n\n        response = requests.post(self.url, kwargs, auth=(self.user, self.key))\n\n        if response.status_code == 200:\n            return response.json()\n        elif response.status_code == 401:\n            raise Unauthorized('Invalid credentials.')\n        elif response.status_code == 404:\n            raise StudentNotFound\n        else:\n            raise HTTPError(('HTTP %s error.' % response.status_code), response=response)", "response": "Calls the API and gets a student by one of these parameters at a time."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a ConfigParser. ConfigParser object from the provided sections and key value pairs.", "response": "def create_config(sections, section_contents):\n    \"\"\"Create a config file from the provided sections and key value pairs.\n\n    Args:\n        sections (List[str]): A list of section keys.\n        key_value_pairs (Dict[str, str]): A list of of dictionaries. Must be as long as\n        the list of sections. That is to say, if there are two sections, there should be two\n        dicts.\n    Returns:\n        configparser.ConfigParser: A ConfigParser.\n    Raises:\n        ValueError\n    \"\"\"\n    sections_length, section_contents_length = len(sections), len(section_contents)\n    if sections_length != section_contents_length:\n        raise ValueError(\"Mismatch between argument lengths.\\n\"\n                         \"len(sections) = {}\\n\"\n                         \"len(section_contents) = {}\"\n                         .format(sections_length, section_contents_length))\n    config = configparser.ConfigParser()\n    for section, section_content in zip(sections, section_contents):\n        config[section] = section_content\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_config(config, config_path=CONFIG_PATH):\n    if not os.path.exists(config_path):\n        os.makedirs(os.path.dirname(config_path))\n    with open(config_path, 'w', encoding='utf-8') as f:\n        config.write(f)", "response": "Write the config to the output path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_config(config_path=CONFIG_PATH):\n    if not os.path.isfile(config_path):\n        raise IOError(\"No config file found at %s\" % config_path)\n    config_parser = configparser.ConfigParser()\n    config_parser.read(config_path)\n    config = _config_parser_to_defaultdict(config_parser)\n    return config", "response": "Read the config information from the config file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_config(config):\n    for section, expected_section_keys in SECTION_KEYS.items():\n        section_content = config.get(section)\n        if not section_content:\n            raise ConfigurationError(\"Config file badly formed! Section {} is missing.\"\n                                     .format(section))\n        elif not _section_is_healthy(section_content, expected_section_keys):\n            raise ConfigurationError(\"The {} section of the configuration file is badly formed!\"\n                                     .format(section))", "response": "Check that all sections of the config file contain the keys that they should."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun diagnostics on the configuration file.", "response": "def run_config_diagnostics(config_path=CONFIG_PATH):\n    \"\"\"Run diagnostics on the configuration file.\n\n    Args:\n        config_path (str): Path to the configuration file.\n    Returns:\n        str, Set[str], dict(str, Set[str]): The path to the configuration file, a set of missing\n        sections and a dict that maps each section to the entries that have either missing or empty\n        options.\n    \"\"\"\n    config = read_config(config_path)\n    missing_sections = set()\n    malformed_entries = defaultdict(set)\n    for section, expected_section_keys in SECTION_KEYS.items():\n        section_content = config.get(section)\n        if not section_content:\n            missing_sections.add(section)\n        else:\n            for option in expected_section_keys:\n                option_value = section_content.get(option)\n                if not option_value:\n                    malformed_entries[section].add(option)\n    return config_path, missing_sections, malformed_entries"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_attribute_from_config(config, section, attribute):\n    section = config.get(section)\n    if section:\n        option = section.get(attribute)\n        if option:\n            return option\n    raise ConfigurationError(\"Config file badly formed!\\n\"\n                             \"Failed to get attribute '{}' from section '{}'!\"\n                             .format(attribute, section))", "response": "Try to parse an attribute of the config file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef valid_config_exists(config_path=CONFIG_PATH):\n    if os.path.isfile(config_path):\n        try:\n            config = read_config(config_path)\n            check_config(config)\n        except (ConfigurationError, IOError):\n            return False\n    else:\n        return False\n    return True", "response": "Verify that a valid config file exists."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a ConfigParser to a defaultdict.", "response": "def _config_parser_to_defaultdict(config_parser):\n    \"\"\"Convert a ConfigParser to a defaultdict.\n\n    Args:\n        config_parser (ConfigParser): A ConfigParser.\n    \"\"\"\n    config = defaultdict(defaultdict)\n    for section, section_content in config_parser.items():\n        if section != 'DEFAULT':\n            for option, option_value in section_content.items():\n                config[section][option] = option_value\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start(self, *args, **kwargs):\n        '''\n        Launch IPython notebook server in background process.\n\n        Arguments and keyword arguments are passed on to `Popen` call.\n\n        By default, notebook server is launched using current working directory\n        as the notebook directory.\n        '''\n        if 'stderr' in kwargs:\n            raise ValueError('`stderr` must not be specified, since it must be'\n                             ' monitored to determine which port the notebook '\n                             'server is running on.')\n        args_ = ('%s' % sys.executable, '-m', 'IPython', 'notebook') + self.args\n        args_ = args_ + tuple(args)\n        self.process = Popen(args_, stderr=PIPE, **kwargs)\n        self._notebook_dir = os.getcwd()\n\n        # Determine which port the notebook is running on.\n        cre_address = re.compile(r'The \\w+ Notebook is running at: '\n                                 r'(?P<address>https?://.*?:'\n                                 r'(?P<port>\\d+)[^\\r]*/)\\r?$')\n        cre_notebook_dir = re.compile(r'Serving notebooks from local '\n                                      r'directory:\\s+(?P<notebook_dir>[^\\r]*)\\r?$')\n        match = None\n        self.stderr_lines = []\n\n        while not self.process.poll() and match is None:\n            stderr_line = self.process.stderr.readline()\n            self.stderr_lines.append(stderr_line)\n            match = cre_address.search(stderr_line)\n            dir_match = cre_notebook_dir.search(stderr_line)\n            if dir_match:\n                self._notebook_dir = dir_match.group('notebook_dir')\n\n        if match:\n            # Notebook was started successfully.\n            self.address = match.group('address')\n            self.port = int(match.group('port'))\n        else:\n            raise IOError(''.join(self.stderr_lines))", "response": "Launch IPython notebook server in background process."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef open(self, filename=None):\n        '''\n        Open a browser tab with the notebook path specified relative to the\n        notebook directory.\n\n        If no filename is specified, open the root of the notebook server.\n        '''\n        if filename is None:\n            address = self.address + 'tree'\n        else:\n            notebook_path = self.resource_filename(filename)\n            if not notebook_path.isfile():\n                raise IOError('Notebook path not found: %s' % notebook_path)\n            else:\n                address = '%snotebooks/%s' % (self.address, filename)\n        webbrowser.open_new_tab(address)", "response": "Open a browser tab with the path specified relative to the theCOOKIE directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlaunches an IPython notebook session from a template file.", "response": "def launch_from_template(self, template_path, notebook_dir=None,\n                             overwrite=False, output_name=None,\n                             create_dir=False, no_browser=False, **kwargs):\n        '''\n        Launch a copy of the specified `.ipynb` (template) file in an IPython\n        notebook session for the specified notebook directory.\n\n        If an IPython notebook session has already been launched for the\n        notebook directory, reuse it.\n\n        If no notebook directory is specified, use the current working directory.\n\n        Arguments\n        ---------\n\n         - `template_path`: Path to template `.ipynb` file.\n         - `notebook_dir`: Directory to start IPython notebook session in.\n         - `overwrite`: Overwrite existing file in `notebook_dir`, if necessary.\n         - `create_dir`: Create notebook directory, if necessary.\n         - `no_browser`: Do not launch new browser tab.\n        '''\n        template_path = template_path.abspath()\n        if output_name is None:\n            output_name = template_path.name\n\n        if notebook_dir is None:\n            notebook_dir = path(os.getcwd())\n        else:\n            notebook_dir = path(notebook_dir).abspath()\n\n        if template_path.parent.realpath() == notebook_dir.realpath():\n            raise IOError('Notebook directory must not be the parent directory of '\n                          'the template file.')\n        else:\n            # The parent of the template file is not the notebook directory.\n            output_path = notebook_dir.joinpath(output_name)\n            if output_path.isfile() and not overwrite:\n                # A file with the same name already exists in the root.\n                raise IOError('Notebook already exists with same name.')\n            # Create notebook directory if it doesn't exist.\n            if create_dir:\n                notebook_dir.mkdirs_p()\n\n            template_path.copy(output_path)\n            notebook_path = output_path\n\n        session = self.get_session(notebook_dir=notebook_dir, **kwargs)\n\n        if not no_browser:\n            # Open IPython notebook in new browser tab.\n            session.open(notebook_path.name)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_session(self, notebook_dir=None, no_browser=True, **kwargs):\n        '''\n        Return handle to IPython session for specified notebook directory.\n\n        If an IPython notebook session has already been launched for the\n        notebook directory, reuse it.  Otherwise, launch a new IPython notebook\n        session.\n\n        By default, notebook session is launched using current working\n        directory as the notebook directory.\n\n        Arguments\n        ---------\n\n         - `notebook_dir`: Directory to start IPython notebook session in.\n         - `no_browser`: Do not launch new browser tab.\n        '''\n        if notebook_dir in self.sessions and self.sessions[notebook_dir].is_alive():\n            # Notebook process is already running for notebook directory,\n            session = self.sessions[notebook_dir]\n            if 'daemon' in kwargs:\n                # Override `daemon` setting of existing session.\n                session.daemon = kwargs['daemon']\n            if not no_browser:\n                session.open()\n        else:\n            # Notebook process is not running for notebook directory, so\n            # start new IPython notebook process.\n\n            # Use default `daemon` setting for manager if no specified.\n            daemon = kwargs.pop('daemon', self.daemon)\n            if no_browser:\n                kwargs['no_browser'] = None\n            if notebook_dir is not None:\n                kwargs['notebook_dir'] = notebook_dir\n            session = Session(daemon=daemon, **kwargs)\n            session.start()\n            self.sessions[str(session.notebook_dir)] = session\n        return session", "response": "Returns a handle to an IPython notebook session for the specified notebook directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef normalizeISBN(isbn):\n    try:\n        return isbnlib.mask(isbnlib.canonical(isbn))\n    except isbnlib.NotValidISBNError:\n        return isbn", "response": "Normalize ISBN to a standard format."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrestructures data about blobs for output.", "response": "def prepare(data):\n    \"\"\"Restructure/prepare data about blobs for output.\"\"\"\n    sha = data.get(\"sha\")\n    content = data.get(\"content\")\n    encoding = data.get(\"encoding\")\n    return {\"sha\": sha, \"content\": content, \"encoding\": encoding}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch a blob. Args: profile A profile generated from ``simplygithub.authentication.profile``. Such profiles tell this module (i) the ``repo`` to connect to, and (ii) the ``token`` to connect with. sha The SHA of the blob to fetch. Returns: A dict with data about the blob.", "response": "def get_blob(profile, sha):\n    \"\"\"Fetch a blob.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        sha\n            The SHA of the blob to fetch.\n\n    Returns:\n        A dict with data about the blob.\n\n    \"\"\"\n    resource = \"/blobs/\" + sha\n    data = api.get_request(profile, resource)\n    return prepare(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_blob(profile, content):\n    resource = \"/blobs\"\n    payload = {\"content\": content}\n    data = api.post_request(profile, resource, payload)\n    return data", "response": "Create a blob.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        content\n            The (UTF-8 encoded) content to create in the blob.\n\n    Returns:\n        A dict with data about the newly created blob."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a copy of the sequence.", "response": "def copy(self):\n    \"\"\"\n    Copy constructor for Sequence objects.\n    \"\"\"\n    return Sequence(self.name, self.sequenceData, self.start, self.end,\n                    self.strand, self.remaining, self.meta_data,\n                    self.mutableString)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef effective_len(self):\n    if self._effective_len is None:\n      self._effective_len = len([nuc for nuc in self.sequenceData\n                                 if nuc != \"N\" and nuc != \"n\"])\n    return self._effective_len", "response": "Get the length of the sequence in the effective order."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef subsequence(self, start, end):\n    if (start < self.start or start >= self.end or end <= self.start or\n       end > self.end or start >= end):\n      raise SequenceError(\"invalid subsequence coordinates (\" + str(start) +\n                          \" ,\" + str(end) + \") for sequence \" + str(self))\n\n    rel_start_string_coord = self.start - start - 1\n    rel_end_string_coord = self.end - end - 1\n    seq = self.sequenceData[rel_start_string_coord:rel_end_string_coord]\n    return Sequence(self.name, seq, start, end, self.strand,\n                    self.remaining + self.end - end, self.mutableString)", "response": "Returns a new sequence object that represents a subsequence of this sequence object starting from start to end."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef relative_subsequence(self, start, end):\n    if start < 1:\n      raise SequenceError(\"invalid start coordinate for subsequence: \" +\n                          str(start))\n    if end > self.ungapped_len:\n      raise SequenceError(\"invalid end coordinate for subsequence: \" +\n                          str(end) + \" greater than number of non-gap \" +\n                          \"nucleotides in sequence (\" + self.ungapped_len +\n                          \")\")\n    raise SequenceError(\"method not implemented\")", "response": "This method extracts a subsequence from this sequence using coordinates that are are\n    relative to start and end coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gapped_relative_subsequence(self, start, end):\n    if start < 1:\n      msg = \"invalid start coordinate for subsequence: \" + str(start)\n      raise InvalidSequenceCoordinatesError(msg)\n    if end > len(self.sequenceData) + 1:\n      msg = \"invalid end coordinate for subsequence: \" + str(end) +\\\n            \" greater than length of sequence (\" + str(len(self)) + \")\"\n      raise InvalidSequenceCoordinatesError(msg)\n\n    non_gaps_before = start - 1 - self.sequenceData[:start - 1].count(GAP_CHAR)\n    seq = self.sequenceData[start - 1:end - 1]\n    non_gaps_in = len(seq) - seq.count(GAP_CHAR)\n    non_gaps_after = self.ungapped_len - non_gaps_before - non_gaps_in\n    new_start = self.start + non_gaps_before\n    new_end = new_start + non_gaps_in\n    new_remaining = self.remaining + non_gaps_after\n\n    return Sequence(self.name, seq, new_start, new_end, self.strand,\n                    new_remaining, self.meta_data, self.mutableString)", "response": "Returns a new sequence that is a gapped subsequence of the sequence with coordinates that are are\n    relative to the start of the sequence."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef percentNuc(self, nuc):\n    count = reduce(lambda x, y: x + 1 if y == nuc else x, self.sequenceData, 0)\n    return count / float(len(self.sequenceData))", "response": "Returns the percentage composition of the sequence that is equal to the passed nucleotide."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef similarity(self, self_start, self_end, other_start, other_end, other):\n    assert(self_end - self_start == other_end - other_start)\n    count = 0\n    for i in range(0, self_end - self_start + 1):\n      if (self.sequenceData[self_start + i] ==\n         other.sequenceData[other_start + i]):\n        count += 1\n    return count", "response": "Compute the number of matching bases in the subsequences self and other."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reverseComplement(self, isRNA=None):\n    isRNA_l = self.isRNA() if isRNA is None else isRNA\n\n    tmp = \"\"\n    for n in self.sequenceData:\n      if isRNA_l:\n        tmp += RNA_COMPLEMENTS[n]\n      else:\n        tmp += DNA_COMPLEMENTS[n]\n    self.sequenceData = tmp[::-1]", "response": "Reverse complement this sequence in - place."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef maskRegion(self, region):\n    if region.start < 0 or region.end < 0 or \\\n       region.start > len(self) or region.end > len(self):\n      raise SequenceError(\"cannot mask region \" + str(region.start) + \" to \" +\n                          str(region.end) + \" in \" + self.name + \". \" +\n                          \"Region specifies nucleotides not present in \" +\n                          \"this read. Valid range would have been 0 -- \" +\n                          str(len(self)))\n\n    if self.mutableString:\n      for i in range(region.start, region.end + 1):\n        self.sequenceData[i] = 'N'\n    else:\n      self.sequenceData = \"\".join([self.sequenceData[:region.start],\n                                  (\"N\" * (region.end - region.start + 1)),\n                                  self.sequenceData[region.end + 1:]])", "response": "Masks nucleotides in this sequence in the regions given by Ns\n     "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmask the given regions in this sequence with Ns.", "response": "def maskRegions(self, regions, verbose=False):\n    \"\"\"\n      Mask the given regions in this sequence with Ns.\n\n      :param region: iterable of regions to mask. Each region can be any object\n                     with .start and .end attributes. Co-ords are zero based\n                     and inclusive of both end points. Any other attributes\n                     (e.g. chrom.) are ignored.\n      :param verbose: print status messages to stderr if True\n    \"\"\"\n    if verbose:\n      pind = ProgressIndicator(totalToDo=len(regions),\n                               messagePrefix=\"completed\",\n                               messageSuffix=\"of masking regions in \" +\n                                             self.name)\n    for region in regions:\n      self.maskRegion(region)\n      if verbose:\n        pind.done += 1\n        pind.showProgress()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsplits this sequence into two halves and return them.", "response": "def split(self, point=None):\n    \"\"\"\n      Split this sequence into two halves and return them. The original\n      sequence remains unmodified.\n\n      :param point: defines the split point, if None then the centre is used\n      :return: two Sequence objects -- one for each side\n    \"\"\"\n    if point is None:\n      point = len(self) / 2\n\n    r1 = Sequence(self.name + \".1\", self.sequenceData[:point])\n    r2 = Sequence(self.name + \".2\", self.sequenceData[point:])\n\n    return r1, r2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclip a sequence from the end of this sequence.", "response": "def clip_end(self, seq, mm_score):\n    \"\"\"\n      Clip a sequence from the end of this sequence -- we assume the sequence\n      to be clipped will always begin somewhere in this sequence, but may not\n      be fully contained. If found, replaced with Ns.\n\n      :param seq: sequence to be clipped\n      :param mm_score: the number of matching bases needed to consider a hit,\n                       mm_score = len(seq) would be 100% match\n    \"\"\"\n    lim = mm_score - 1\n    other_end = len(seq) - 1\n    other_start = 0\n\n    for i in range(len(self.sequenceData) - 1, lim - 1, -1):\n      self_end = i\n      self_start = i - (len(seq) - 1)\n\n      if self_start < 0:\n        self_start = 0\n        other_start = other_end - self_end\n\n      score = self.similarity(self_start, self_end, other_start,\n                              other_end, seq)\n      if (score >= mm_score):\n        self.nsRight(len(seq) + (len(self) - i) - 1)\n        break"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef maskMatch(self, mask):\n    if len(mask) > len(self.sequenceData):\n      return False\n    lim = len(mask)\n    for i in range(0, lim):\n      if mask[i] == \"N\" or mask[i] == \"n\":\n        continue\n      if mask[i] != self.sequenceData[i]:\n        return False\n    return True", "response": "Determines whether this sequence matches the given mask."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_fasta_str(self, line_width=50, include_coords=True):\n    res = \">\" + self.name\n    if include_coords:\n      res += \":\" + str(self.start) + \"-\" + str(self.end)\n      res += \" (\" + str(self.remaining) + \")\"\n    m_str = self.meta_data_to_string()\n    if m_str:\n      res += (\" \" + m_str)\n    res += \"\\n\"\n    for i in range(0, len(self.sequenceData), line_width):\n      res += self.sequenceData[i:i + line_width]\n      if i + line_width < len(self.sequenceData):\n        res += \"\\n\"\n    return res", "response": "Returns a string representation of this sequence object in fasta format"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef walk_recursive(f, data):\n    results = {}\n    if isinstance(data, list):\n        return [walk_recursive(f, d) for d in data]\n    elif isinstance(data, dict):\n        results = funcy.walk_keys(f, data)\n\n        for k, v in data.iteritems():\n            if isinstance(v, dict):\n                results[f(k)] = walk_recursive(f, v)\n            elif isinstance(v, list):\n                results[f(k)] = [walk_recursive(f, d) for d in v]\n    else:\n        return f(data)\n\n    return results", "response": "Recursively apply a function to all dicts in a nested dictionary\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(self, config, strip_app_name=False, filter_by_app_name=False,\n            key_normalisation_func=default_key_normalisation_func):\n        \"\"\"\n        Add a dict of config data. Values from later dicts will take precedence\n        over those added earlier, so the order data is added matters.\n\n        Note: Double underscores can be used to indicate dict key name\n        boundaries. i.e. if we have a dict like:\n\n        {\n            'logging': {\n                'level': INFO\n                ...\n            }\n        }\n\n        we could pass an environment variable LOGGING__LEVEL=DEBUG to override\n        the log level.\n\n        Note: Key names will be normalised by recursively applying the\n        key_normalisation_func function. By default this will:\n\n            1) Convert keys to lowercase\n            2) Replace hyphens with underscores\n            3) Strip leading underscores\n\n        This allows key names from different sources (e.g. CLI args, env vars,\n        etc.) to be able to override each other.\n\n        :param config dict: config data\n        :param strip_app_name boolean: If True, the configured app_name will\n        stripped from the start of top-level input keys if present.\n        :param filter_by_app_name boolean: If True, keys that don't begin with\n        the app name will be discarded.\n        :return:\n        \"\"\"\n        config = walk_recursive(key_normalisation_func, OrderedDict(config))\n\n        if filter_by_app_name:\n            config = funcy.compact(funcy.select_keys(\n                lambda k: k.startswith(self._app_name), config))\n\n        if strip_app_name:\n            strip_app_name_regex = re.compile(\"^%s\" % self._app_name)\n            config = funcy.walk_keys(\n                lambda k: re.sub(strip_app_name_regex, '', k), config)\n\n        self._sources.append(config)\n\n        return self", "response": "Add a dict of config data to the internal list of sources."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_merged_config(self):\n        merged_config = OrderedDict()\n\n        for source in self._sources:\n            merged_config = dict_merge(merged_config, source,\n                                       self._dict_boundary)\n\n        return merged_config", "response": "Returns all dicts merged so you can access the data\n        values\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_param(self, name, value):\n        if name not in self.param_names:\n            raise ValueError('No GO-PCA Server parameter named \"%s\"!' %(param))\n        self.__params[name] = value", "response": "Set a GO - PCA Server parameter."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset multiple GO - PCA Server parameters using a dictionary containing the parameter values.", "response": "def set_params(self, params):\n        \"\"\"Sets multiple GO-PCA Server parameters using a dictionary.\n\n        Parameters\n        ----------\n        params: dict\n            Dictionary containing the parameter values.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        for k,v in params.iteritems():\n            self.set_param(k,v)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reset_params(self):\n        self.__params = dict([p, None] for p in self.param_names)\n        self.set_params(self.param_defaults)", "response": "Reset all parameters to their default values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the current configuration is valid.", "response": "def check(self):\n        \"\"\"Check if the current configuration is valid.\n\n        Parameters:\n        -----------\n        None\n\n        Returns\n        -------\n        bool\n            True iff no problems were found.\n\n        \"\"\"\n\n        passed = True\n\n        def check_type(attr, types):\n            # checks whether the parameter has a certain type\n            val = getattr(self, attr)\n            if not isinstance(val, types):\n                logger.error('Parameter \"%s\" = %s: invalid type ' +\n                        '(should be %s).', attr, val, str(types))\n                passed = False\n\n        def check_file_exists(attr):\n            # check whether the specified file exists\n            path = getattr(self, attr)\n            if not os.path.isfile(path):\n                logger.error('Parameter \"%s\" = %s: file does not exist. ',\n                        attr, path)\n                passed = False\n\n        def check_dir_exists(attr):\n            # check whether the specified directory exists\n            path = getattr(self, attr)\n            if not os.path.isdir(path):\n                logger.error('Parameter \"%s\" = %s: directory does not exist.',\n                        attr, path)\n                passed = False\n\n        def check_dir_writable(attr):\n            path = getattr(self, attr)\n            if not misc.test_dir_writable(path):\n                logger.error('Parameter \"%s\" = %s: directory is not writable',\n                        attr, path)\n                passed = False\n\n        def check_file_writable(attr):\n            # check whether the specified file is writable\n            path = getattr(self, attr)\n            if not misc.test_file_writable(path):\n                logger.error('Parameter \"%s\" = %s: file not writable.',\n                        attr, path)\n                passed = False\n\n        def check_range(attr, mn = None, mx = None,\n                left_open = False, right_open = False):\n            # checks if a GO-PCA parameter falls within a certain numeric range\n\n            val = getattr(self, attr)\n            in_range = True\n\n            rel_op = {True: '<', False: '<='}\n\n            if mn is not None:\n                left_rel = '%s %s ' %(str(mn), rel_op[left_open])\n                if left_open:\n                    if not mn < val: in_range = False\n                else:\n                    if not mn <= val: in_range = False\n\n            if mx is not None:\n                right_rel = ' %s %s' %(rel_op[right_open], str(mx))\n                if right_open:\n                    if not val < mx: in_range = False\n                else:\n                    if not val <= mx: in_range = False\n\n            if not in_range:\n                logger.error('Parameter \"%s\" = %s: out of range ' +\n                        '(should be %s %s %s).',\n                        attr, val, left_rel, attr, right_rel)\n                passed = False\n\n        # check if input files are strings\n        # specification of gene ontology file is optional\n        check_type('data_dir', (str, unicode))\n        check_dir_writable('data_dir')\n\n        check_type('job_dir', (str, unicode))\n        check_dir_writable('job_dir')\n\n        if self.ssl_dir is not None:\n            check_dir_exists('ssl_dir')\n            if not os.path.isfile(ssl_dir + os.sep + 'gopca_server.cert'):\n                logger.error('SSL certificate file not found!')\n                passed = False\n            if not os.path.isfile(ssl_dir + os.sep + 'gopca_server.key'):\n                logger.error('SSL key file no found!')\n                passed = False\n\n        check_type('port', int)\n\n        # TO-DO: check remaining parameters\n        return passed"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a waybill shims from a given command name and docker image", "response": "def create(cli, command, docker_id):\n        \"\"\"Creates waybill shims from a given command name and docker image\"\"\"\n        content = waybill_template.format(command=command,\n                                          docker_id=docker_id)\n        waybill_dir = cli.get_waybill_dir()\n        waybill_filename = os.path.join(waybill_dir, command + '.waybill')\n        with open(waybill_filename, 'wb') as filehandle:\n            filehandle.write(content)\n        cli.log.info('Created waybill {0}'.format(waybill_filename))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load(cli, yaml_filename):\n        \"\"\"Expected Definition:\n        - name: NAME\n          docker_id: IMAGE\n        - name: NAME\n          docker_id: IMAGE\n        \"\"\"\n        with open(yaml_filename, 'rb') as filehandle:\n            for waybill in yaml.load(filehandle.read()):\n                cli.create(waybill.name,\n                           waybill.docker_id)", "response": "Creates waybill shims from a given yaml file"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef shellinit(cli):\n        output = 'eval echo \"Initializing Waybills\"'\n        if which('docker') is None:\n            raise ValueError(\"Unable to find program 'docker'.  Please make sure it is installed and setup properly\")\n        for waybill in cli.get_waybills():\n            output += ' && source {0}'.format(waybill)\n        return output", "response": "Implements the waybill shims in the active shell"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef service_data(self):\n        # Lean on the cache first.\n        if self._loaded_service_data is not None:\n            return self._loaded_service_data\n\n        # We don't have a cache. Build it.\n        self._loaded_service_data = self._introspect_service(\n            # We care about the ``botocore.session`` here, not the\n            # ``kotocore.session``.\n            self.session.core_session,\n            self.service_name\n        )\n        # Clear out the API version, just in case.\n        self._api_version = None\n        return self._loaded_service_data", "response": "Returns all introspected service data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the API version introspected from the service data.", "response": "def api_version(self):\n        \"\"\"\n        Returns API version introspected from the service data.\n\n        If the data has been previously accessed, a memoized version of the\n        API version is returned.\n\n        :returns: The service's version\n        :rtype: string\n        \"\"\"\n        # Lean on the cache first.\n        if self._api_version is not None:\n            return self._api_version\n\n        # We don't have a cache. Build it.\n        self._api_version = self._introspect_api_version(\n            self.session.core_session,\n            self.service_name\n        )\n        return self._api_version"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct a new connection class for a given service.", "response": "def construct_for(self, service_name):\n        \"\"\"\n        Builds a new, specialized ``Connection`` subclass for a given service.\n\n        This will introspect a service, determine all the API calls it has &\n        constructs a brand new class with those methods on it.\n\n        :param service_name: The name of the service to construct a connection\n            for. Ex. ``sqs``, ``sns``, ``dynamodb``, etc.\n        :type service_name: string\n\n        :returns: A new connection class for that service\n        \"\"\"\n        # Construct a new ``ConnectionDetails`` (or similar class) for storing\n        # the relevant details about the service & its operations.\n        details = self.details_class(service_name, self.session)\n        # Make sure the new class gets that ``ConnectionDetails`` instance as a\n        # ``cls._details`` attribute.\n        attrs = {\n            '_details': details,\n        }\n\n        # Determine what we should call it.\n        klass_name = self._build_class_name(service_name)\n\n        # Construct what the class ought to have on it.\n        attrs.update(self._build_methods(details))\n\n        # Create the class.\n        return type(\n            klass_name,\n            (self.base_connection,),\n            attrs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_trailerLinks(self):\n        if self._trailerLinks:\n            return self._trailerLinks\n\n        wip = WebIncParser(\"http://trailers.apple.com\" + self.baseURL,\n                           \"includes/playlists/web.inc\")\n\n        self._trailerLinks = wip.getTrailers()\n        return self._trailerLinks", "response": "Returns a dictionary with names as keys and list of trailer urls as values. Each trailer can have more links due to different qualities. Each trailer can have more links due to different qualities. Each trailer can have more links due to different qualities. Each trailer can have more links due to different qualities."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_poster(self):\n        if self._posterData:\n            return self._posterData\n\n        response = urllib.request.urlopen(self.posterURL)\n        self._posterData = response.read()\n        return self._posterData", "response": "Returns the poster data as in JPEG or GIF file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_description(self):\n        if self._description:\n            return self._description\n\n        try:\n            trailerURL= \"http://trailers.apple.com%s\" % self.baseURL\n            response = urllib.request.urlopen(trailerURL)\n            Reader = codecs.getreader(\"utf-8\")\n            responseReader = Reader(response)\n            trailerHTML = responseReader.read()\n            description = re.search('<meta *name=\"Description\" *content=\"(.*?)\" *[/]*>'\n                                    ,trailerHTML)\n            if description:\n                self._description = description.group(1)\n            else:\n                self._description = \"None\"\n        except:\n            self._description = \"Error\"\n        return self._description", "response": "Returns description text as provided by the studio"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nunwrapping a set of points in a 2 dimensional periodic system.", "response": "def _unwrap_one_layer(r, L, n):\n    \"\"\"For a set of points in a 2 dimensional periodic system, extend the set of\n    points to tile the points at a given period.\n\n    Parameters\n    ----------\n    r: float array, shape (:, 2).\n        Set of points.\n    L: float array, shape (2,)\n        System lengths.\n    n: integer.\n        Period to unwrap.\n\n    Returns\n    -------\n    rcu: float array, shape (:, 2).\n        The set of points. tiled at the periods at a distance `n` from the\n        origin.\n    \"\"\"\n    try:\n        L[0]\n    except (TypeError, IndexError):\n        L = np.ones([r.shape[1]]) * L\n    if n == 0:\n        return list(r)\n    rcu = []\n    for x, y in r:\n        for ix in range(-n, n + 1):\n            for iy in range(-n, n + 1):\n                if abs(ix) == n or abs(iy) == n:\n                    rcu.append(np.array([x + ix * L[0], y + iy * L[1]]))\n    return rcu"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nunwrapping a set of points in a 2 dimensional periodic system to tile the points up to a given period.", "response": "def _unwrap_to_layer(r, L, n=1):\n    \"\"\"For a set of points in a 2 dimensional periodic system, extend the set of\n    points to tile the points up to to a given period.\n\n    Parameters\n    ----------\n    r: float array, shape (:, 2).\n        Set of points.\n    L: float array, shape (2,)\n        System lengths.\n    n: integer.\n        Period to unwrap up to.\n\n    Returns\n    -------\n    rcu: float array, shape (:, 2).\n        The set of points. tiled up to the periods at a distance `n` from the\n        origin.\n    \"\"\"\n    rcu = []\n    for i_n in range(n + 1):\n        rcu.extend(_unwrap_one_layer(r, L, i_n))\n    return rcu"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef draw_medium(r, R, L, n=1, ax=None):\n    if ax is None:\n        ax = plt.gca()\n    for ru in _unwrap_to_layer(r, L, n):\n        c = plt.Circle(ru, radius=R, alpha=0.2)\n        ax.add_artist(c)", "response": "Draw a single medium system."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cli(ctx, name, dname, license_key, ips_version, force, enable, ssl, spdy, gzip, cache, install, dev):\n    assert isinstance(ctx, Context)\n    login_session = ctx.get_login()\n    log = logging.getLogger('ipsv.new')\n    ctx.cache = cache\n\n    # Prompt for our desired license\n    def get_license():\n        \"\"\"\n        Prompt the user for a license selection\n        @rtype: ips_vagrant.scraper.licenses.LicenseMeta\n        \"\"\"\n        licenses = Licenses(login_session).get()\n        user_license = license_key or ctx.config.get('User', 'LicenseKey')\n\n        # If we already have a license key saved, skip the prompt and use it instead\n        if user_license:\n            licenses = {license.license_key: license for license in licenses}\n            if user_license in licenses:\n                return licenses[user_license]\n\n        # Ask the user to select a license key\n        opt = choice([\n            (key, '{u} ({k})'.format(u=license.community_url, k=license.license_key))\n            for key, license in enumerate(licenses)\n        ], 1, 'Which license key would you like to use?')\n        license = licenses[opt]\n\n        # Should we save this license?\n        if click.confirm('Would you like to save and use this license for future requests?', True):\n            ctx.log.debug('Saving license key {k}'.format(k=license.license_key))\n            ctx.config.set('User', 'LicenseKey', license.license_key)\n            with open(ctx.config_path, 'wb') as configfile:\n                ctx.config.write(configfile)\n\n        return license\n\n    # Get the latest IPS release\n    lmeta = get_license()\n    p = Echo('Fetching IPS version information...')\n    ips = IpsManager(ctx, lmeta)\n    p.done()\n    if ips_version:\n        if ips_version == 'latest_dev':\n            v = ips.dev_version\n            if not v:\n                click.secho('There is no IPS development release available for download', err=True, fg='red', bold=True)\n                raise Exception('There is no IPS development release available for download')\n            p = Echo('Downloading IPS development release {vs}...'.format(vs=v.version.vstring))\n        else:\n            ips_version = Version(ips_version)\n            v = ips.versions[ips_version.vtuple]\n            p = Echo('Fetching IPS version {iv}'.format(iv=ips_version.vstring))\n    else:\n        v = ips.latest\n        p = Echo('Downloading IPS release {vs}...'.format(vs=v.version.vstring))\n    filename = ips.get(v, cache)\n    p.done()\n\n    # Parse the specific domain and make sure it's valid\n    log.debug('Parsing domain name: %s', dname)\n    dname = domain_parse(dname)\n    if ssl is None:\n        ssl = dname.scheme == 'https'\n    log.debug('Domain name parsed: %s', dname)\n\n    domain = Domain.get_or_create(dname)\n\n    # Make sure this site does not already exist\n    p = Echo('Constructing site data...')\n    site = ctx.db.query(Site).filter(Site.domain == domain).filter(collate(Site.name, 'NOCASE') == name).count()\n    if site:\n        p.done(p.FAIL)\n        log.error('Site already exists')\n        click.secho('An installation named \"{s}\" has already been created for the domain {d}'\n                    .format(s=name, d=dname.hostname),\n                    err=True, fg='red', bold=True)\n        raise click.Abort\n\n    # Create the site database entry\n    site = Site(name=name, domain=domain, license_key=lmeta.license_key, version=v.version.vstring, ssl=ssl, spdy=spdy,\n                gzip=gzip, enabled=enable, in_dev=dev)\n\n    status = p.OK\n    if os.path.exists(site.root):\n        if not force:\n            p.done(p.FAIL)\n            click.secho(\"Installation path already exists and --force was not passed:\\n{p}\".format(p=site.root),\n                        err=True, fg='red', bold=True)\n            log.info('Aborting installation, path already exists: {p}'.format(p=site.root))\n            raise click.Abort\n\n        log.warn('Overwriting existing installation path: {p}'.format(p=site.root))\n        status = p.WARN\n\n    ctx.db.add(site)\n    ctx.db.commit()\n    p.done(status)\n\n    # Construct the HTTP path\n    p = Echo('Constructing paths and configuration files...')\n    site.write_nginx_config()\n    p.done()\n\n    # Generate SSL certificates if enabled\n    if ssl:\n        p = Echo('Generating SSL certificate...')\n        ssl_path = os.path.join(ctx.config.get('Paths', 'NginxSSL'), domain.name)\n        if not os.path.exists(ssl_path):\n            log.debug('Creating new SSL path: %s', ssl_path)\n            os.makedirs(ssl_path, 0o755)\n\n        sc = CertificateFactory(site).get()\n        site.ssl_key = sc.key\n        site.ssl_certificate = sc.certificate\n\n        with open(os.path.join(ssl_path, '{s}.key'.format(s=site.slug)), 'w') as f:\n            f.write(sc.key)\n        with open(os.path.join(ssl_path, '{s}.pem').format(s=site.slug), 'w') as f:\n            f.write(sc.certificate)\n        p.done()\n\n    # Create a symlink if this site is being enabled\n    if site.enabled:\n        site.enable(force)\n\n        # Restart Nginx\n        p = Echo('Restarting web server...')\n        FNULL = open(os.devnull, 'w')\n        subprocess.check_call(['service', 'nginx', 'restart'], stdout=FNULL, stderr=subprocess.STDOUT)\n        p.done()\n\n    # Extract IPS setup files\n    p = Echo('Extracting setup files to tmp...')\n    tmpdir = tempfile.mkdtemp('ips')\n    setup_zip = os.path.join(tmpdir, 'setup.zip')\n    setup_dir = os.path.join(tmpdir, 'setup')\n    os.mkdir(setup_dir)\n\n    log.info('Extracting setup files')\n    shutil.copyfile(filename, setup_zip)\n    with zipfile.ZipFile(setup_zip) as z:\n        namelist = z.namelist()\n        if re.match(r'^ips_\\w{5}\\/?$', namelist[0]):\n            log.debug('Setup directory matched: %s', namelist[0])\n        else:\n            log.error('No setup directory matched, unable to continue')\n            raise Exception('Unrecognized setup file format, aborting')\n\n        z.extractall(setup_dir)\n        log.debug('Setup files extracted to: %s', setup_dir)\n        p.done()\n        p = MarkerProgressBar('Copying setup files...')\n        setup_tmpdir = os.path.join(setup_dir, namelist[0])\n        for dirname, dirnames, filenames in p(os.walk(setup_tmpdir)):\n            for filepath in dirnames:\n                site_path = os.path.join(site.root, dirname.replace(setup_tmpdir, ''), filepath)\n                if not os.path.exists(site_path):\n                    log.debug('Creating directory: %s', site_path)\n                    os.mkdir(site_path, 0o755)\n\n            for filepath in filenames:\n                tmp_path = os.path.join(dirname, filepath)\n                site_path = os.path.join(site.root, dirname.replace(setup_tmpdir, ''), filepath)\n                shutil.copy(tmp_path, site_path)\n\n        log.info('Setup files copied to: %s', site.root)\n    shutil.rmtree(tmpdir)\n\n    # Apply proper permissions\n    # p = MarkerProgressBar('Setting file permissions...')\n    writeable_dirs = ['uploads', 'plugins', 'applications', 'datastore']\n    \n    for wdir in writeable_dirs:\n        log.debug('Setting file permissions in %s', wdir)\n        os.chmod(os.path.join(site.root, wdir), 0o777)\n        p = MarkerProgressBar('Setting file permissions...', nl=False)\n        for dirname, dirnames, filenames in p(os.walk(os.path.join(site.root, wdir))):\n            for filename in filenames:\n                os.chmod(os.path.join(dirname, filename), 0o666)\n\n            for filename in dirnames:\n                os.chmod(os.path.join(dirname, filename), 0o777)\n    Echo('Setting file permissions...').done()\n\n    shutil.move(os.path.join(site.root, 'conf_global.dist.php'), os.path.join(site.root, 'conf_global.php'))\n    os.chmod(os.path.join(site.root, 'conf_global.php'), 0o777)\n\n    # Run the installation\n    if install:\n        p = Echo('Initializing installer...')\n        i = installer(v.version, ctx, site, force)\n        p.done()\n        i.start()\n    else:\n        db_info = None\n        if click.confirm('Would you like to create the database for this installation now?', default=True):\n            db_info = create_database(site)\n\n        click.echo('------')\n\n        if db_info:\n            db_name, db_user, db_pass = db_info\n\n            log.debug('MySQL Database Name: %s', db_name)\n            log.debug('MySQL Database User: %s', db_user)\n            log.debug('MySQL Database Password: %s', db_pass)\n\n            click.secho('MySQL Database Name: {dbn}'.format(dbn=db_name), bold=True)\n            click.secho('MySQL Database User: {dbu}'.format(dbu=db_user), bold=True)\n            click.secho('MySQL Database Password: {dbp}'.format(dbp=db_pass), bold=True)\n\n        click.secho('IPS is now ready to be installed. To proceed with the installation, follow the link below',\n                    fg='yellow', bold=True)\n        click.echo('{schema}://{host}'.format(schema='https' if site.ssl else 'http', host=site.domain.name))", "response": "Download and install an Invision Power Suite release."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nuploading a new model resource to the warehouse.", "response": "def upload(self,  # pylint: disable=too-many-arguments\n               path,\n               name=None,\n               resize=False,\n               rotation=False,\n               callback_url=None,\n               callback_method=None,\n               auto_align=False, ):\n        \"\"\"Create a new model resource in the warehouse and uploads the path contents to it\"\"\"\n        if name is None:\n            head, tail = ntpath.split(path)\n            name = tail or ntpath.basename(head)\n\n        url = \"http://models.{}/model/\".format(self.config.host)\n\n        payload = {\"name\": name,\n                   \"allowed_transformations\": {\"resize\": resize,\n                                               \"rotation\": rotation, },\n                   \"auto-align\": auto_align}\n        if callback_url and callback_method:\n            payload[\"callback\"] = {\"url\": callback_url, \"method\": callback_method}\n\n        post_resp = requests.post(url, json=payload, cookies={\"session\": self.session})\n        if not post_resp.ok:\n            raise errors.ResourceError(\"payload to model service invalid\")\n\n        self.name = name\n\n        with open(path, \"rb\") as model_file:\n            put_resp = requests.put(post_resp.headers[\"x-upload-location\"],\n                                    data=model_file.read(),\n                                    headers={\"Content-Type\": \"application/octet-stream\"})\n            if not put_resp.ok:\n                raise errors.ResourceError(\"model upload failed\")\n\n        self.location = post_resp.headers[\"Location\"]\n        self._state = self._get_status()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef download(self, path):\n        service_get_resp = requests.get(self.location, cookies={\"session\": self.session})\n        payload = service_get_resp.json()\n        self._state = payload[\"status\"]\n\n        if self._state != \"processed\":\n            raise errors.ResourceError(\"slice resource status is: {}\".format(self._state))\n        else:\n            download_get_resp = requests.get(payload[\"content\"])\n            with open(path, \"wb\") as model_file:\n                model_file.write(download_get_resp.content)", "response": "downloads a model resource to the path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a JSON - like object for the run state object.", "response": "def to_dict(obj):\n        \"\"\"Generate a JSON serialization for the run state object.\n\n        Returns\n        -------\n        Json-like object\n            Json serialization of model run state object\n        \"\"\"\n        # Have text description of state in Json object (for readability)\n        json_obj = {'type' : repr(obj)}\n        # Add state-specific elementsTYPE_MODEL_RUN\n        if obj.is_failed:\n            json_obj['errors'] = obj.errors\n        elif obj.is_success:\n            json_obj['modelOutput'] = obj.model_output\n        return json_obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a data file with a given model run.", "response": "def create_data_file_attachment(self, identifier, resource_id, filename, mime_type=None):\n        \"\"\"Attach a given data file with a model run. The attached file is\n        identified by the resource identifier. If a resource with the given\n        identifier already exists it will be overwritten.\n\n        This operation wil copy the file 'filename' into the attachments\n        directory for the model run with name 'resource_id'. If the resource id\n        is not a valid file name an exception will be thrown.\n\n        Parameters\n        ----------\n        identifier : string\n            Unique model run identifier\n        resource_id : string\n            Unique attachment identifier\n        filename : string\n            Path to data file that is being attached. A copy of the file will\n            be created\n        mime_type : string, optional\n            File Mime type\n\n        Returns\n        -------\n        ModelRunHandle\n            Modified model run handle or None if no run with given identifier\n            exists\n        \"\"\"\n        # Get model run to ensure that it exists\n        model_run = self.get_object(identifier)\n        if model_run is None:\n            return None\n        # It is only possible to attach files to successful model run\n        if not model_run.state.is_success:\n            raise ValueError('cannot attach file to model run in state: ' + str(model_run.state))\n        # The attachment will be written to a file with name resource_id\n        # inside the model run's attachment directory. If the resource id\n        # contains path components we will create sub-folders for them. If the\n        # resource file exists it will be overwritten.\n        target = os.path.abspath(\n            os.path.join(model_run.attachment_directory, resource_id)\n        )\n        directory, local_name = os.path.split(target)\n        # Make sure that the given resource identifier does not result in the\n        # file bein palced in a directory other than the attachments directory.\n        if directory != model_run.attachment_directory:\n            raise ValueError('invalid resource identifier: ' + resource_id)\n        # Create the attachments directory if it doesn't exist\n        if not os.path.exists(model_run.attachment_directory):\n            os.makedirs(model_run.attachment_directory)\n        shutil.copyfile(filename, target)\n        if mime_type is None:\n            # Mime type is derived from the file name\n            mime_type = 'text/plain'\n            if filename.endswith('.csv'):\n                mime_type = 'text/csv'\n            elif filename.endswith('.tsv'):\n                mime_type = 'text/tab-separated-values'\n            elif filename.endswith('.gz'):\n                mime_type = 'application/x-gzip'\n            elif filename.endswith('.png'):\n                mime_type = 'image/png'\n            elif filename.endswith('.jpg'):\n                mime_type = 'image/jpeg'\n            elif filename.endswith('.gif'):\n                mime_type = 'image/gif'\n        # Update model run information in the database\n        model_run.attachments[resource_id] = Attachment(\n            resource_id,\n            mime_type,\n            os.path.getsize(target)\n        )\n        self.replace_object(model_run)\n        # Return modified model run\n        return model_run"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new model run object with the given list of arguments. The initial state of the object is RUNNING.", "response": "def create_object(self, name, experiment_id, model_id, argument_defs, arguments=None, properties=None):\n        \"\"\"Create a model run object with the given list of arguments. The\n        initial state of the object is RUNNING.\n\n        Raises ValueError if given arguments are invalid.\n\n        Parameters\n        ----------\n        name : string\n            User-provided name for the model run\n        experiment_id : string\n            Unique identifier of associated experiment object\n        model_id : string\n            Unique model identifier\n        argument_defs : list(attribute.AttributeDefinition)\n            Definition of valid arguments for the given model\n        arguments : list(dict('name':...,'value:...')), optional\n            List of attribute instances\n        properties : Dictionary, optional\n            Set of model run properties.\n        Returns\n        -------\n        PredictionHandle\n            Object handle for created model run\n        \"\"\"\n        # Create a new object identifier.\n        identifier = str(uuid.uuid4()).replace('-','')\n        # Directory for successful model run resource files. Directories are\n        # simply named by object identifier\n        directory = os.path.join(self.directory, identifier)\n        # Create the directory if it doesn't exists\n        if not os.access(directory, os.F_OK):\n            os.makedirs(directory)\n        # By default all model runs are in IDLE state at creation\n        state = ModelRunIdle()\n        # Create the initial set of properties.\n        run_properties = {\n            datastore.PROPERTY_NAME: name,\n            datastore.PROPERTY_STATE: str(state),\n            datastore.PROPERTY_MODEL: model_id\n        }\n        if not properties is None:\n            for prop in properties:\n                if not prop in run_properties:\n                    run_properties[prop] = properties[prop]\n        # If argument list is not given then the initial set of arguments is\n        # empty. Here we do not validate the given arguments. Definitions of\n        # valid argument sets are maintained in the model registry and are not\n        # accessible by the model run manager at this point.\n        run_arguments = {}\n        if not arguments is None:\n            # Convert arguments to dictionary of Atrribute instances. Will\n            # raise an exception if values are of invalid type.\n            run_arguments = attribute.to_dict(arguments, argument_defs)\n        # Create the image group object and store it in the database before\n        # returning it.\n        obj = ModelRunHandle(\n            identifier,\n            run_properties,\n            directory,\n            state,\n            experiment_id,\n            model_id,\n            run_arguments\n        )\n        self.insert_object(obj)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete an attachment from a model run.", "response": "def delete_data_file_attachment(self, identifier, resource_id):\n        \"\"\"Delete attached file with given resource identifier from a mode run.\n\n        Raise ValueError if an image archive with the given resource identifier\n        is attached to the model run instead of a data file.\n\n        Parameters\n        ----------\n        identifier : string\n            Unique model run identifier\n        resource_id : string\n            Unique attachment identifier\n\n        Returns\n        -------\n        boolean\n            True, if file was deleted. False, if no attachment with given\n            identifier existed.\n        \"\"\"\n        # Get model run to ensure that it exists. If not return False\n        model_run = self.get_object(identifier)\n        if model_run is None:\n            return False\n        # Ensure that attachment with given resource identifier exists.\n        if not resource_id in model_run.attachments:\n            return False\n        # Delete file on disk\n        os.remove(os.path.join(model_run.attachment_directory, resource_id))\n        # Update model run information in the database\n        del model_run.attachments[resource_id]\n        self.replace_object(model_run)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a PredictionHandle object from a JSON document retrieved from database.", "response": "def from_dict(self, document):\n        \"\"\"Create model run object from JSON document retrieved from database.\n\n        Parameters\n        ----------\n        document : JSON\n            Json document in database\n\n        Returns\n        -------\n        PredictionHandle\n            Handle for model run object\n        \"\"\"\n        # Get object identifier from Json document\n        identifier = str(document['_id'])\n        # Directories are simply named by object identifier\n        directory = os.path.join(self.directory, identifier)\n        # Create attachment descriptors\n        attachments = {}\n        for obj in document['attachments']:\n            attachment = Attachment.from_dict(obj)\n            attachments[attachment.identifier] = attachment\n        # Create model run handle.\n        return ModelRunHandle(\n            identifier,\n            document['properties'],\n            directory,\n            ModelRunState.from_dict(document['state']),\n            document['experiment'],\n            document['model'],\n            attribute.attributes_from_dict(document['arguments']),\n            attachments=attachments,\n            schedule=document['schedule'],\n            timestamp=datetime.datetime.strptime(\n                document['timestamp'], '%Y-%m-%dT%H:%M:%S.%f'\n            ),\n            is_active=document['active']\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_data_file_attachment(self, identifier, resource_id):\n        # Get model run to ensure that it exists. If not return None\n        model_run = self.get_object(identifier)\n        if model_run is None:\n            return None, None\n        # Ensure that attachment with given resource identifier exists.\n        if not resource_id in model_run.attachments:\n            return None, None\n        # Raise an exception if the attached resource is not a data file\n        attachment = model_run.attachments[resource_id]\n        filename = os.path.join(model_run.attachment_directory, resource_id)\n        return filename, attachment.mime_type", "response": "Get path to data file with given identifier and resource identifier."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a Json - like dictionary for a model run object. Extends the base class to_dict method.", "response": "def to_dict(self, model_run):\n        \"\"\"Create a Json-like dictionary for a model run object. Extends the\n        basic object with run state, arguments, and optional prediction results\n        or error descriptions.\n\n        Parameters\n        ----------\n        model_run : PredictionHandle\n\n        Returns\n        -------\n        (JSON)\n            Json-like object, i.e., dictionary.\n        \"\"\"\n        # Get the basic Json object from the super class\n        json_obj = super(DefaultModelRunManager, self).to_dict(model_run)\n        # Add run state\n        json_obj['state'] = ModelRunState.to_dict(model_run.state)\n        # Add run scheduling Timestamps\n        json_obj['schedule'] = model_run.schedule\n        # Add experiment information\n        json_obj['experiment'] = model_run.experiment_id\n        # Add model information\n        json_obj['model'] = model_run.model_id\n        # Transform dictionary of attributes into list of key-value pairs.\n        json_obj['arguments'] = attribute.attributes_to_dict(model_run.arguments)\n        # Include attachments\n        json_obj['attachments'] = [\n            attachment.to_dict()\n                for attachment in model_run.attachments.values()\n            ]\n        return json_obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_state(self, identifier, state):\n        # Get model run to ensure that it exists\n        model_run = self.get_object(identifier)\n        if model_run is None:\n            return None\n        # Set timestamp of state change. Raise exception if state change results\n        # in invalid life cycle\n        timestamp = str(datetime.datetime.utcnow().isoformat())\n        if state.is_idle:\n            raise ValueError('invalid state change: run cannot become idle')\n        elif state.is_running:\n            # Current state is required to be IDLE\n            if not model_run.state.is_idle:\n                raise ValueError('invalid state change: finished run cannot start again')\n            model_run.schedule[RUN_STARTED] = timestamp\n        elif state.is_failed:\n            # Current state is required to be RUNNING\n            if not (model_run.state.is_running or model_run.state.is_idle):\n                raise ValueError('invalid state change: cannot fail finished run')\n            model_run.schedule[RUN_FINISHED] = timestamp\n        elif state.is_success:\n            # Current state is required to be RUNNING\n            if not model_run.state.is_running:\n                raise ValueError('invalid state change: cannot finish inactive run')\n            model_run.schedule[RUN_FINISHED] = timestamp\n        # Update model run state and replace object in database\n        model_run.state = state\n        model_run.properties[datastore.PROPERTY_STATE] = str(state)\n        self.replace_object(model_run)\n        # Return modified model run\n        return model_run", "response": "Updates the state of identified model run."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef partial_update(self, request, *args, **kwargs):\n    instance = self.get_object()\n    serializer = self.get_serializer(instance, data=request.data, partial=True, context=self.get_serializer_context())\n    serializer.is_valid(raise_exception=True)\n    serializer.save()\n\n    if getattr(instance, '_prefetched_objects_cache', None): #pragma: no cover\n      instance = self.get_object()\n      serializer = self.get_serializer(instance)\n\n    return response.Response(serializer.data)", "response": "This is a partial update for the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconnect to the remote host", "response": "def connect(self):\n        ''' connect to the remote host '''\n\n        vvv(\"ESTABLISH CONNECTION FOR USER: %s\" % self.runner.remote_user, host=self.host)\n\n        self.common_args = []\n        extra_args = C.ANSIBLE_SSH_ARGS\n        if extra_args is not None:\n            self.common_args += shlex.split(extra_args)\n        else:\n            self.common_args += [\"-o\", \"ControlMaster=auto\",\n                                 \"-o\", \"ControlPersist=60s\",\n                                 \"-o\", \"ControlPath=/tmp/ansible-ssh-%h-%p-%r\"]\n        self.common_args += [\"-o\", \"StrictHostKeyChecking=no\"]\n        if self.port is not None:\n            self.common_args += [\"-o\", \"Port=%d\" % (self.port)]\n        if self.runner.private_key_file is not None:\n            self.common_args += [\"-o\", \"IdentityFile=\"+os.path.expanduser(self.runner.private_key_file)]\n        if self.runner.remote_pass:\n            self.common_args += [\"-o\", \"GSSAPIAuthentication=no\",\n                                 \"-o\", \"PubkeyAuthentication=no\"]\n        else:\n            self.common_args += [\"-o\", \"KbdInteractiveAuthentication=no\",\n                                 \"-o\", \"PasswordAuthentication=no\"]\n        self.common_args += [\"-o\", \"User=\"+self.runner.remote_user]\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns a command on the remote host", "response": "def exec_command(self, cmd, tmp_path, sudo_user,sudoable=False, executable='/bin/sh'):\n        ''' run a command on the remote host '''\n\n        ssh_cmd = self._password_cmd()\n        ssh_cmd += [\"ssh\", \"-tt\", \"-q\"] + self.common_args + [self.host]\n\n        if not self.runner.sudo or not sudoable:\n            if executable:\n                ssh_cmd.append(executable + ' -c ' + pipes.quote(cmd))\n            else:\n                ssh_cmd.append(cmd)\n        else:\n            sudocmd, prompt = utils.make_sudo_cmd(sudo_user, executable, cmd)\n            ssh_cmd.append(sudocmd)\n\n        vvv(\"EXEC %s\" % ssh_cmd, host=self.host)\n        try:\n            # Make sure stdin is a proper (pseudo) pty to avoid: tcgetattr errors\n            import pty\n            master, slave = pty.openpty()\n            p = subprocess.Popen(ssh_cmd, stdin=slave,\n                                 stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            stdin = os.fdopen(master, 'w', 0)\n        except:\n            p = subprocess.Popen(ssh_cmd, stdin=subprocess.PIPE,\n                                 stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            stdin = p.stdin\n\n        self._send_password()\n\n        if self.runner.sudo and sudoable and self.runner.sudo_pass:\n            fcntl.fcntl(p.stdout, fcntl.F_SETFL,\n                        fcntl.fcntl(p.stdout, fcntl.F_GETFL) | os.O_NONBLOCK)\n            sudo_output = ''\n            while not sudo_output.endswith(prompt):\n                rfd, wfd, efd = select.select([p.stdout], [],\n                                              [p.stdout], self.runner.timeout)\n                if p.stdout in rfd:\n                    chunk = p.stdout.read()\n                    if not chunk:\n                        raise errors.AnsibleError('ssh connection closed waiting for sudo password prompt')\n                    sudo_output += chunk\n                else:\n                    stdout = p.communicate()\n                    raise errors.AnsibleError('ssh connection error waiting for sudo password prompt')\n            stdin.write(self.runner.sudo_pass + '\\n')\n            fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) & ~os.O_NONBLOCK)\n\n        # We can't use p.communicate here because the ControlMaster may have stdout open as well\n        stdout = ''\n        stderr = ''\n        while True:\n            rfd, wfd, efd = select.select([p.stdout, p.stderr], [], [p.stdout, p.stderr], 1)\n            if p.stdout in rfd:\n                dat = os.read(p.stdout.fileno(), 9000)\n                stdout += dat\n                if dat == '':\n                    p.wait()\n                    break\n            elif p.stderr in rfd:\n                dat = os.read(p.stderr.fileno(), 9000)\n                stderr += dat\n                if dat == '':\n                    p.wait()\n                    break\n            elif p.poll() is not None:\n                break\n        stdin.close() # close stdin after we read from stdout (see also issue #848)\n\n        if p.returncode != 0 and stderr.find('Bad configuration option: ControlPersist') != -1:\n            raise errors.AnsibleError('using -c ssh on certain older ssh versions may not support ControlPersist, set ANSIBLE_SSH_ARGS=\"\" (or ansible_ssh_args in the config file) before running again')\n\n        return (p.returncode, '', stdout, stderr)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef put_file(self, in_path, out_path):\n        ''' transfer a file from local to remote '''\n        vvv(\"PUT %s TO %s\" % (in_path, out_path), host=self.host)\n        if not os.path.exists(in_path):\n            raise errors.AnsibleFileNotFound(\"file or module does not exist: %s\" % in_path)\n        cmd = self._password_cmd()\n\n        if C.DEFAULT_SCP_IF_SSH:\n            cmd += [\"scp\"] + self.common_args\n            cmd += [in_path,self.host + \":\" + out_path]\n            indata = None\n        else:\n            cmd += [\"sftp\"] + self.common_args + [self.host]\n            indata = \"put %s %s\\n\" % (in_path, out_path)\n\n        p = subprocess.Popen(cmd, stdin=subprocess.PIPE,\n                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        self._send_password()\n        stdout, stderr = p.communicate(indata)\n\n        if p.returncode != 0:\n            raise errors.AnsibleError(\"failed to transfer file to %s:\\n%s\\n%s\" % (out_path, stdout, stderr))", "response": "transfer a file from local to remote"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch a file from remote to local", "response": "def fetch_file(self, in_path, out_path):\n        ''' fetch a file from remote to local '''\n        vvv(\"FETCH %s TO %s\" % (in_path, out_path), host=self.host)\n        cmd = self._password_cmd()\n\n        if C.DEFAULT_SCP_IF_SSH:\n            cmd += [\"scp\"] + self.common_args\n            cmd += [self.host + \":\" + in_path, out_path]\n            indata = None\n        else:\n            cmd += [\"sftp\"] + self.common_args + [self.host]\n            indata = \"get %s %s\\n\" % (in_path, out_path)\n\n        p = subprocess.Popen(cmd, stdin=subprocess.PIPE,\n                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        self._send_password()\n        stdout, stderr = p.communicate(indata)\n\n        if p.returncode != 0:\n            raise errors.AnsibleError(\"failed to transfer file from %s:\\n%s\\n%s\" % (in_path, stdout, stderr))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\noverrides save_form to implement custom save_form.", "response": "def save_form(self, request, form, change):\n        \"\"\"\n        Super class ordering is important here - user must get saved first.\n        \"\"\"\n        OwnableAdmin.save_form(self, request, form, change)\n        return DisplayableAdmin.save_form(self, request, form, change)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if the user has permission to view the blog.", "response": "def has_module_permission(self, request):\n        \"\"\"\n        Hide from the admin menu unless explicitly set in ``ADMIN_MENU_ORDER``.\n        \"\"\"\n        for (name, items) in settings.ADMIN_MENU_ORDER:\n            if \"blog.BlogCategory\" in items:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the first environment variable set.", "response": "def env(*vars, **kwargs):\n    \"\"\"Returns the first environment variable set.\n\n    If none are non-empty, defaults to '' or keyword arg default.\n    \"\"\"\n    for v in vars:\n        value = os.environ.get(v)\n        if value:\n            return value\n    return kwargs.get('default', '')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the client class for the requested API version.", "response": "def get_client_class(api_name, version, version_map):\n    \"\"\"Returns the client class for the requested API version.\n\n    :param api_name: the name of the API, e.g. 'compute', 'image', etc\n    :param version: the requested API version\n    :param version_map: a dict of client classes keyed by version\n    :rtype: a client class for the requested API version\n    \"\"\"\n    try:\n        client_path = version_map[str(version)]\n    except (KeyError, ValueError):\n        msg = _(\"Invalid %(api_name)s client version '%(version)s'. must be \"\n                \"one of: %(map_keys)s\")\n        msg = msg % {'api_name': api_name, 'version': version,\n                     'map_keys': ', '.join(version_map.keys())}\n        raise exceptions.UnsupportedVersion(msg)\n\n    return importutils.import_class(client_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_item_properties(item, fields, mixed_case_fields=(), formatters=None):\n    if formatters is None:\n        formatters = {}\n\n    row = []\n\n    for field in fields:\n        if field in formatters:\n            row.append(formatters[field](item))\n        else:\n            if field in mixed_case_fields:\n                field_name = field.replace(' ', '_')\n            else:\n                field_name = field.lower().replace(' ', '_')\n            if not hasattr(item, field_name) and isinstance(item, dict):\n                data = item[field_name]\n            else:\n                data = getattr(item, field_name, '')\n            if data is None:\n                data = ''\n            row.append(data)\n    return tuple(row)", "response": "Return a tuple containing the item properties."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert string in the form of key1 = value1 key2 = value2... string into dictionary.", "response": "def str2dict(strdict, required_keys=None, optional_keys=None):\n    \"\"\"Convert key1=value1,key2=value2,... string into dictionary.\n\n    :param strdict: string in the form of key1=value1,key2=value2\n    :param required_keys: list of required keys. All keys in this list must be\n                       specified. Otherwise ArgumentTypeError will be raised.\n                       If this parameter is unspecified, no required key check\n                       will be done.\n    :param optional_keys: list of optional keys.\n                       This parameter is used for valid key check.\n                       When at least one of required_keys and optional_keys,\n                       a key must be a member of either of required_keys or\n                       optional_keys. Otherwise, ArgumentTypeError will be\n                       raised. When both required_keys and optional_keys are\n                       unspecified, no valid key check will be done.\n    \"\"\"\n    result = {}\n    if strdict:\n        for kv in strdict.split(','):\n            key, sep, value = kv.partition('=')\n            if not sep:\n                msg = _(\"invalid key-value '%s', expected format: key=value\")\n                raise argparse.ArgumentTypeError(msg % kv)\n            result[key] = value\n    valid_keys = set(required_keys or []) | set(optional_keys or [])\n    if valid_keys:\n        invalid_keys = [k for k in result if k not in valid_keys]\n        if invalid_keys:\n            msg = _(\"Invalid key(s) '%(invalid_keys)s' specified. \"\n                    \"Valid key(s): '%(valid_keys)s'.\")\n            raise argparse.ArgumentTypeError(\n                msg % {'invalid_keys': ', '.join(sorted(invalid_keys)),\n                       'valid_keys': ', '.join(sorted(valid_keys))})\n    if required_keys:\n        not_found_keys = [k for k in required_keys if k not in result]\n        if not_found_keys:\n            msg = _(\"Required key(s) '%s' not specified.\")\n            raise argparse.ArgumentTypeError(msg % ', '.join(not_found_keys))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef loads(cls, data):\n        '''Create a feature collection from a CBOR byte string.'''\n        rep = cbor.loads(data)\n        if not isinstance(rep, Sequence):\n            raise SerializationError('expected a CBOR list')\n        if len(rep) != 2:\n            raise SerializationError('expected a CBOR list of 2 items')\n        metadata = rep[0]\n        if 'v' not in metadata:\n            raise SerializationError('no version in CBOR metadata')\n        if metadata['v'] != 'fc01':\n            raise SerializationError('invalid CBOR version {!r} '\n                                     '(expected \"fc01\")'\n                                     .format(metadata['v']))\n        read_only = metadata.get('ro', False)\n        contents = rep[1]\n        return cls.from_dict(contents, read_only=read_only)", "response": "Create a feature collection from a CBOR byte string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a CBOR byte string from a feature collection.", "response": "def dumps(self):\n        '''Create a CBOR byte string from a feature collection.'''\n        metadata = {'v': 'fc01'}\n        if self.read_only:\n            metadata['ro'] = 1\n        rep = [metadata, self.to_dict()]\n        return cbor.dumps(rep)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_dict(cls, data, read_only=False):\n        '''Recreate a feature collection from a dictionary.\n\n        The dictionary is of the format dumped by :meth:`to_dict`.\n        Additional information, such as whether the feature collection\n        should be read-only, is not included in this dictionary, and\n        is instead passed as parameters to this function.\n\n        '''\n        fc = cls(read_only=read_only)\n        fc._features = {}\n        fc._from_dict_update(data)\n        return fc", "response": "Recreate a feature collection from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_dict(self):\n        '''Dump a feature collection's features to a dictionary.\n\n        This does not include additional data, such as whether\n        or not the collection is read-only.  The returned dictionary\n        is suitable for serialization into JSON, CBOR, or similar\n        data formats.\n\n        '''\n        def is_non_native_sc(ty, encoded):\n            return (ty == 'StringCounter'\n                    and not is_native_string_counter(encoded))\n\n        fc = {}\n        native = ('StringCounter', 'Unicode')\n        for name, feat in self._features.iteritems():\n            if name.startswith(self.EPHEMERAL_PREFIX):\n                continue\n            if not isinstance(name, unicode):\n                name = name.decode('utf-8')\n            tyname = registry.feature_type_name(name, feat)\n            encoded = registry.get(tyname).dumps(feat)\n\n            # This tomfoolery is to support *native untagged* StringCounters.\n            if tyname not in native or is_non_native_sc(tyname, encoded):\n                encoded = cbor.Tag(cbor_names_to_tags[tyname], encoded)\n            fc[name] = encoded\n        return fc", "response": "Dump a feature collection s features to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmerging this feature collection with another.", "response": "def merge_with(self, other, multiset_op, other_op=None):\n        '''Merge this feature collection with another.\n\n        Merges two feature collections using the given ``multiset_op``\n        on each corresponding multiset and returns a new\n        :class:`FeatureCollection`. The contents of the two original\n        feature collections are not modified.\n\n        For each feature name in both feature sets, if either feature\n        collection being merged has a :class:`collections.Counter`\n        instance as its value, then the two values are merged by\n        calling `multiset_op` with both values as parameters.  If\n        either feature collection has something other than a\n        :class:`collections.Counter`, and `other_op` is not\n        :const:`None`, then `other_op` is called with both values to\n        merge them.  If `other_op` is :const:`None` and a feature\n        is not present in either feature collection with a counter\n        value, then the feature will not be present in the result.\n\n        :param other: The feature collection to merge into ``self``.\n        :type other: :class:`FeatureCollection`\n        :param multiset_op: Function to merge two counters\n        :type multiset_op: fun(Counter, Counter) -> Counter\n        :param other_op: Function to merge two non-counters\n        :type other_op: fun(object, object) -> object\n        :rtype: :class:`FeatureCollection`\n\n        '''\n        result = FeatureCollection()\n        for ms_name in set(self._counters()) | set(other._counters()):\n            c1 = self.get(ms_name, None)\n            c2 = other.get(ms_name, None)\n            if c1 is None and c2 is not None:\n                c1 = c2.__class__()\n            if c2 is None and c1 is not None:\n                c2 = c1.__class__()\n            result[ms_name] = multiset_op(c1, c2)\n        if other_op is not None:\n            for o_name in (set(self._not_counters()) |\n                           set(other._not_counters())):\n                v = other_op(self.get(o_name, None), other.get(o_name, None))\n                if v is not None:\n                    result[o_name] = v\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef total(self):\n        '''\n        Returns sum of all counts in all features that are multisets.\n        '''\n        feats = imap(lambda name: self[name], self._counters())\n        return sum(chain(*map(lambda mset: map(abs, mset.values()), feats)))", "response": "Returns the total number of counts in all features that are multisets."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add(self, name, obj):\n        '''Register a new feature serializer.\n\n        The feature type should be one of the fixed set of feature\n        representations, and `name` should be one of ``StringCounter``,\n        ``SparseVector``, or ``DenseVector``.  `obj` is a describing\n        object with three fields: `constructor` is a callable that\n        creates an empty instance of the representation; `dumps` is\n        a callable that takes an instance of the representation and\n        returns a JSON-compatible form made of purely primitive\n        objects (lists, dictionaries, strings, numbers); and `loads`\n        is a callable that takes the response from `dumps` and recreates\n        the original representation.\n\n        Note that ``obj.constructor()`` *must* return an\n        object that is an instance of one of the following\n        types: ``unicode``, :class:`dossier.fc.StringCounter`,\n        :class:`dossier.fc.SparseVector` or\n        :class:`dossier.fc.DenseVector`. If it isn't, a\n        :exc:`ValueError` is raised.\n        '''\n        ro = obj.constructor()\n        if name not in cbor_names_to_tags:\n            print(name)\n            raise ValueError(\n                'Unsupported feature type name: \"%s\". '\n                'Allowed feature type names: %r'\n                % (name, cbor_names_to_tags.keys()))\n        if not is_valid_feature_instance(ro):\n            raise ValueError(\n                'Constructor for \"%s\" returned \"%r\" which has an unknown '\n                'sub type \"%r\". (mro: %r). Object must be an instance of '\n                'one of the allowed types: %r'\n                % (name, ro, type(ro), type(ro).mro(), ALLOWED_FEATURE_TYPES))\n        self._registry[name] = {'obj': obj, 'ro': obj.constructor()}\n        self._inverse[obj.constructor] = name", "response": "Register a new feature serializer."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef instance_contains(container, item):\n    return item in (member for _, member in inspect.getmembers(container))", "response": "Search into instance attributes properties and return values of no - args methods."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextend operator. contains by trying very hard to find item inside container.", "response": "def contains(container, item):\n    \"\"\"Extends ``operator.contains`` by trying very hard to find ``item`` inside container.\"\"\"\n\n    # equality counts as containment and is usually non destructive\n    if container == item:\n        return True\n\n    # testing mapping containment is usually non destructive\n    if isinstance(container, abc.Mapping) and mapping_contains(container, item):\n        return True\n\n    # standard containment except special cases\n    if isinstance(container, str):\n        # str __contains__ includes substring match that we don't count as containment\n        if strict_contains(container, item):\n            return True\n    else:\n        try:\n            if item in container:\n                return True\n        except Exception:\n            pass\n\n    # search matches in generic instances\n    return instance_contains(container, item)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting general brightness in range 0... 1", "response": "def set_brightness(self, brightness):\n        \"\"\"set general brightness in range 0...1\"\"\"\n        brightness = min([1.0, max([brightness, 0.0])]) # enforces range 0 ... 1\n        self.state.brightness = brightness\n        self._repeat_last_frame()\n        sequence_number = self.zmq_publisher.publish_brightness(brightness)\n        logging.debug(\"Set brightness to {brightPercent:05.1f}%\".format(brightPercent=brightness*100))\n        return (True, sequence_number, \"OK\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister a new animation class", "response": "def register_animation(self, animation_class):\n        \"\"\"Add a new animation\"\"\"\n        self.state.animationClasses.append(animation_class)\n        return len(self.state.animationClasses) - 1"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_scene(self, animation_id, name, color, velocity, config):\n        # check arguments\n        if animation_id < 0 or animation_id >= len(self.state.animationClasses):\n            err_msg = \"Requested to register scene with invalid Animation ID. Out of range.\"\n            logging.info(err_msg)\n            return(False, 0, err_msg)\n        if self.state.animationClasses[animation_id].check_config(config) is False:\n            err_msg = \"Requested to register scene with invalid configuration.\"\n            logging.info(err_msg)\n            return(False, 0, err_msg)\n        self.state.sceneIdCtr += 1\n        self.state.scenes[self.state.sceneIdCtr] = Scene(animation_id, name, color, velocity, config)\n        sequence_number = self.zmq_publisher.publish_scene_add(self.state.sceneIdCtr, animation_id, name, color, velocity, config)\n        logging.debug(\"Registered new scene.\")\n\n        # set this scene as active scene if none is configured yet\n        if self.state.activeSceneId is None:\n            self.set_scene_active(self.state.sceneIdCtr)\n        return (True, sequence_number, \"OK\")", "response": "Add a new scene to the state."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a scene by Scene ID", "response": "def remove_scene(self, scene_id):\n        \"\"\"remove a scene by Scene ID\"\"\"\n        if self.state.activeSceneId == scene_id:\n            err_msg = \"Requested to delete scene {sceneNum}, which is currently active. Cannot delete active scene.\".format(sceneNum=scene_id)\n            logging.info(err_msg)\n            return(False, 0, err_msg)\n        try:\n            del self.state.scenes[scene_id]\n            logging.debug(\"Deleted scene {sceneNum}\".format(sceneNum=scene_id))\n        except KeyError:\n            err_msg = \"Requested to delete scene {sceneNum}, which does not exist\".format(sceneNum=scene_id)\n            logging.info(err_msg)\n            return(False, 0, err_msg)\n        # if we are here, we deleted a scene, so publish it\n        sequence_number = self.zmq_publisher.publish_scene_remove(scene_id)\n        logging.debug(\"Removed scene {sceneNum}\".format(sceneNum=scene_id))\n        return (True, sequence_number, \"OK\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrenames a scene by scene ID", "response": "def set_scene_name(self, scene_id, name):\n        \"\"\"rename a scene by scene ID\"\"\"\n        if not scene_id in self.state.scenes: # does that scene_id exist?\n            err_msg = \"Requested to rename scene {sceneNum}, which does not exist\".format(sceneNum=scene_id)\n            logging.info(err_msg)\n            return(False, 0, err_msg)\n        self.state.scenes[scene_id] = self.state.scenes[scene_id]._replace(name=name) # TODO: is there a better solution?\n        sequence_number = self.zmq_publisher.publish_scene_name(scene_id, name)\n        logging.debug(\"Renamed scene {sceneNum}\".format(sceneNum=scene_id))\n        return (True, sequence_number, \"OK\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreconfiguring a scene by scene ID", "response": "def set_scene_config(self, scene_id, config):\n        \"\"\"reconfigure a scene by scene ID\"\"\"\n        if not scene_id in self.state.scenes: # does that scene_id exist?\n            err_msg = \"Requested to reconfigure scene {sceneNum}, which does not exist\".format(sceneNum=scene_id)\n            logging.info(err_msg)\n            return(False, 0, err_msg)\n        if scene_id == self.state.activeSceneId:\n            pass  # TODO: maybe calculate next frame, esp. if static scene\n        self.state.scenes[scene_id] = self.state.scenes[scene_id]._replace(config=config)\n        sequence_number = self.zmq_publisher.publish_scene_config(scene_id, config)\n        logging.debug(\"Reconfigured scene {sceneNum}\".format(sceneNum=scene_id))\n        return (True, sequence_number, \"OK\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_scene_color(self, scene_id, color):\n        if not scene_id in self.state.scenes: # does that scene_id exist?\n            err_msg = \"Requested to recolor scene {sceneNum}, which does not exist\".format(sceneNum=scene_id)\n            logging.info(err_msg)\n            return(False, 0, err_msg)\n        self.state.scenes[scene_id] = self.state.scenes[scene_id]._replace(color=color)\n        sequence_number = self.zmq_publisher.publish_scene_color(scene_id, color)\n        logging.debug(\"Recolored scene {sceneNum}\".format(sceneNum=scene_id))\n        if scene_id == self.state.activeSceneId:\n            self.state.activeAnimation.set_color(color)\n            self._do_next_frame() # TODO: make it more sensible, e.g. call only if static scene\n        return (True, sequence_number, \"OK\")", "response": "reconfigure a scene by scene ID"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset a scene velocity", "response": "def set_scene_velocity(self, scene_id, velocity):\n        \"\"\"reconfigure a scene by scene ID\"\"\"\n        if not scene_id in self.state.scenes: # does that scene_id exist?\n            err_msg = \"Requested to set velocity on scene {sceneNum}, which does not exist\".format(sceneNum=scene_id)\n            logging.info(err_msg)\n            return(False, 0, err_msg)\n        self.state.scenes[scene_id] = self.state.scenes[scene_id]._replace(velocity=velocity)\n        sequence_number = self.zmq_publisher.publish_scene_velocity(scene_id, velocity)\n        logging.debug(\"set velocity on scene {sceneNum}\".format(sceneNum=scene_id))\n        if scene_id == self.state.activeSceneId:\n            self.state.activeAnimation.set_velocity(velocity)\n            self._do_next_frame() # TODO: make it more sensible, e.g. call only if static scene\n        return (True, sequence_number, \"OK\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_scene_active(self, scene_id):\n        if self.state.activeSceneId != scene_id: # do nothing if scene has not changed\n            self._deactivate_scene()\n            sequence_number = self.zmq_publisher.publish_active_scene(scene_id)\n            self.state.activeSceneId = scene_id\n            if self.state.mainswitch is True: # activate scene only if we are switched on\n                self._activate_scene()\n            logging.debug(\"Set scene {sceneNum} as active scene\".format(sceneNum=scene_id))\n            return (True, sequence_number, \"OK\")\n        else:\n            logging.debug(\"Scene {sceneNum} already is active scene\".format(sceneNum=scene_id))\n            return (False, 0, \"This already is the activated scene.\")", "response": "sets the active scene by scene ID"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_mainswitch_state(self, state):\n        if self.state.mainswitch == state:\n            err_msg = \"MainSwitch unchanged, already is {sState}\".format(sState=\"On\" if state else \"Off\") # fo obar lorem ipsum\n            logging.debug(err_msg) # fo obar lorem ipsum\n            return (False, 0, err_msg) # because nothing changed\n        self.state.mainswitch = state\n        sequence_number = self.zmq_publisher.publish_mainswitch_state(state)\n        logging.debug(\"MainSwitch toggled, new state is {sState}\".format(sState=\"On\" if state else \"Off\")) # fo obar lorem ipsum\n        if state is True:\n            self.hw_communication.switch_on()\n            self._activate_scene() # reinit scene\n        else:\n            self._deactivate_scene()\n            self.hw_communication.switch_off()\n        return (True, sequence_number, \"OK\")", "response": "Turns output on or off. Also turns hardware on ir off."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef publish_mainswitch_state(self, state):\n        self.sequence_number += 1\n        self.publisher.send_multipart(msgs.MessageBuilder.mainswitch_state(self.sequence_number, state))\n        return self.sequence_number", "response": "publish changed mainswitch state"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef publish_active_scene(self, scene_id):\n        self.sequence_number += 1\n        self.publisher.send_multipart(msgs.MessageBuilder.scene_active(self.sequence_number, scene_id))\n        return self.sequence_number", "response": "publish changed active scene"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npublishes the removal of a scene", "response": "def publish_scene_remove(self, scene_id):\n        \"\"\"publish the removal of a scene\"\"\"\n        self.sequence_number += 1\n        self.publisher.send_multipart(msgs.MessageBuilder.scene_remove(self.sequence_number, scene_id))\n        return self.sequence_number"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef publish_scene_name(self, scene_id, name):\n        self.sequence_number += 1\n        self.publisher.send_multipart(msgs.MessageBuilder.scene_name(self.sequence_number, scene_id, name))\n        return self.sequence_number", "response": "publish a changed scene name"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npublish a changed scene configuration", "response": "def publish_scene_config(self, scene_id, config):\n        \"\"\"publish a changed scene configuration\"\"\"\n        self.sequence_number += 1\n        self.publisher.send_multipart(msgs.MessageBuilder.scene_config(self.sequence_number, scene_id, config))\n        return self.sequence_number"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef publish_scene_color(self, scene_id, color):\n        self.sequence_number += 1\n        self.publisher.send_multipart(msgs.MessageBuilder.scene_color(self.sequence_number, scene_id, color))\n        return self.sequence_number", "response": "publish a changed scene color"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef publish_scene_velocity(self, scene_id, velocity):\n        self.sequence_number += 1\n        self.publisher.send_multipart(msgs.MessageBuilder.scene_velocity(self.sequence_number, scene_id, velocity))\n        return self.sequence_number", "response": "publish a changed scene velovity"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle a snapshot request.", "response": "def handle_snapshot(self, msg):\n        \"\"\"Handles a snapshot request\"\"\"\n        logging.debug(\"Sending state snapshot request\")\n        identity = msg[0]\n        self.snapshot.send_multipart([identity] + msgs.MessageBuilder.mainswitch_state(self.sequence_number, self.app.state.mainswitch))\n        self.snapshot.send_multipart([identity] + msgs.MessageBuilder.brightness(self.sequence_number, self.app.state.brightness))\n        for animation_id, anim  in enumerate(self.app.state.animationClasses):\n            self.snapshot.send_multipart([identity] + msgs.MessageBuilder.animation_add(self.sequence_number, animation_id, anim.name))\n        for scene_id, scene in self.app.state.scenes.items():\n            self.snapshot.send_multipart([identity] + msgs.MessageBuilder.scene_add(\n                self.sequence_number, scene_id, scene.animation_id, scene.name, scene.color, scene.velocity, scene.config))\n        self.snapshot.send_multipart([identity] + msgs.MessageBuilder.scene_active(\n            self.sequence_number, 0 if self.app.state.activeSceneId is None else self.app.state.activeSceneId))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle an incoming message", "response": "def handle_collect(self, msg):\n        \"\"\"handle an incoming message\"\"\"\n        (success, sequence_number, comment) = self._handle_collect(msg)\n        self.collector.send_multipart(msgs.MessageWriter().bool(success).uint64(sequence_number).string(comment).get())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_eggs(entry_point_name):\n    def _load_eggs(env):\n        distributions, errors = working_set.find_plugins(\n            pkg_resources.Environment()\n        )\n        for dist in distributions:\n            if dist not in working_set:\n                env.log.debug('Adding plugin %s from %s', dist, dist.location)\n                working_set.add(dist)\n\n        def _log_error(item, e):\n            ue = exception_to_unicode(e)\n            if isinstance(e, DistributionNotFound):\n                env.log.debug('Skipping \"%s\": (\"%s\" not found)', item, ue)\n            elif isinstance(e, VersionConflict):\n                env.log.error('Skipping \"%s\": (version conflict \"%s\")',\n                              item, ue)\n            elif isinstance(e, UnknownExtra):\n                env.log.error('Skipping \"%s\": (unknown extra \"%s\")', item, ue)\n            else:\n                env.log.error('Skipping \"%s\": %s', item,\n                              exception_to_unicode(e, traceback=True))\n\n        for dist, e in errors.iteritems():\n            _log_error(dist, e)\n\n        for entry in sorted(working_set.iter_entry_points(entry_point_name),\n                            key=lambda entry: entry.name):\n            env.log.debug(\n                'Loading %s from %s',\n                entry.name,\n                entry.dist.location\n            )\n            try:\n                entry.load(require=True)\n            except Exception as exc:\n                _log_error(entry, exc)\n            else:\n                _enable_plugin(env, entry.module_name)\n    return _load_eggs", "response": "Loader that loads any eggs in sys. path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_json(self):\n        res = dict()\n        res['Count'] = self.count\n        res['Messages'] = self.messages\n        res['ForcedState'] = self.forced\n        res['ForcedKeyboard'] = self.keyboard\n        res['Entities'] = list()\n        for item in self.entities:\n            res['Entities'].append(item.to_json())\n        res['ForcedMessage'] = self.forced_message\n        return res", "response": "Serialize object to json dict"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_json(self):\n        res = dict()\n        res['Handle'] = ''\n        res['Name'] = self.name\n        res['ImageUrl'] = self.url\n        res['Description'] = self.desc\n        res[\"EntityOptions\"] = self.options\n        return res", "response": "Serialize object to json dict"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_json(self):\n        data = dict()\n        data['name'] = self.name\n        data['language'] = self.language\n        data['fancy_name'] = self.fancy_name\n        data['scenario'] = self.scenario\n        return data", "response": "Serialize object to json dict"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_json(self):\n        data = dict()\n        data['InterlocutorId'] = self.id_\n        data['Text'] = self.text\n        data['Username'] = self.username\n        data['FirstName'] = self.first_name\n        data['LastName'] = self.last_name\n        return data", "response": "Serialize object to json dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef with_uvloop_if_possible(f, *args, **kwargs):\n    try:\n        import uvloop\n        import asyncio\n        asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\n        print('uvloop will be used')\n    except ImportError:\n        print('uvloop unavailable')\n    return f(*args, **kwargs)", "response": "Decorator to provide optional uvloop usage if available"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the global NST instance with the current NST and begins tracking", "response": "def initialize():\n        \"\"\" Initializes the global NST instance with the current NST and begins tracking\n        \"\"\"\n        NST.running = True\n        pg = Page(\"http://www.neopets.com/\")\n        \n        curtime = pg.find(\"td\", {'id': 'nst'}).text\n        NST.curTime = datetime.datetime.strptime(curtime.replace(\" NST\", \"\"), \"%I:%M:%S %p\") + datetime.timedelta(0,2)\n        \n        NST.inst = NST()\n        NST.daemon = True # Ensures the thread is properly destroyed when the master thread terminates\n        NST.inst.start()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _attach_to_model(self, model):\n        if not issubclass(model, ModelWithDynamicFieldMixin):\n            raise ImplementationError(\n                'The \"%s\" model does not inherit from ModelWithDynamicFieldMixin '\n                'so the \"%s\" DynamicField cannot be attached to it' % (\n                model.__name__, self.name))\n\n        super(DynamicFieldMixin, self)._attach_to_model(model)\n\n        if self.dynamic_version_of is not None:\n            return\n\n        if hasattr(model, self.name):\n            return\n\n        setattr(model, self.name, self)", "response": "Attach this DynamicField to the given model."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the pattern used to check if a field name can be accepted by this object.", "response": "def pattern(self):\n        \"\"\"\n        Return the pattern used to check if a field name can be accepted by this\n        dynamic field. Use a default one ('^fieldname_(.+)$') if not set when\n        the field was initialized\n        \"\"\"\n        if self.dynamic_version_of is not None:\n            return self.dynamic_version_of.pattern\n\n        if not self._pattern:\n            self._pattern = re.compile('^%s_(.+)$' % self.name)\n        return self._pattern"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the format used to create the variation of the current current .", "response": "def format(self):\n        \"\"\"\n        Return the format used to create the name of a variation of the current\n        dynamic field. Use a default one ('fieldname_%s') if not set when the\n        field was initialized\n        \"\"\"\n        if self.dynamic_version_of is not None:\n            return self.dynamic_version_of.format\n\n        if not self._format:\n            self._format = '%s_%%s' % self.name\n        return self._format"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _inventory(self):\n        if self.dynamic_version_of:\n            return self.dynamic_version_of._inventory\n\n        if not hasattr(self, '_inventory_field'):\n            self._inventory_field = limpyd_fields.SetField()\n            self._inventory_field._attach_to_model(self._model)\n            self._inventory_field._attach_to_instance(self._instance)\n            self._inventory_field.lockable = True\n            self._inventory.name = self.name\n\n        return self._inventory_field", "response": "Returns the internal inventory field a SetField\n            which is used to track all dynamic versions used on a specific instance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\noverriding the base method to add the dynamic part to the inventory.", "response": "def _call_command(self, name, *args, **kwargs):\n        \"\"\"\n        If a command is called for the main field, without dynamic part, an\n        ImplementationError is raised: commands can only be applied on dynamic\n        versions.\n        On dynamic versions, if the command is a modifier, we add the version in\n        the inventory.\n        \"\"\"\n        if self.dynamic_version_of is None:\n            raise ImplementationError('The main version of a dynamic field cannot accept commands')\n        try:\n            result = super(DynamicFieldMixin, self)._call_command(name, *args, **kwargs)\n        except:\n            raise\n        else:\n            if name in self.available_modifiers and name not in ('delete', 'hdel'):\n                self._inventory.sadd(self.dynamic_part)\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete(self):\n        if self.dynamic_version_of is None:\n            self._delete_dynamic_versions()\n        else:\n            super(DynamicFieldMixin, self).delete()\n            self._inventory.srem(self.dynamic_part)", "response": "Delete the current object from the inventory."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes all dynamic versions of the current field and all its content.", "response": "def _delete_dynamic_versions(self):\n        \"\"\"\n        Call the `delete` method of all dynamic versions of the current field\n        found in the inventory then clean the inventory.\n        \"\"\"\n        if self.dynamic_version_of:\n            raise ImplementationError(u'\"_delete_dynamic_versions\" can only be '\n                                      u'executed on the base field')\n        inventory = self._inventory\n        for dynamic_part in inventory.smembers():\n            name = self.get_name_for(dynamic_part)\n            # create the field\n            new_field = self._create_dynamic_version()\n            new_field.name = name\n            new_field._dynamic_part = dynamic_part  # avoid useless computation\n            new_field._attach_to_model(self._model)\n            new_field._attach_to_instance(self._instance)\n            # and delete its content\n            new_field.delete()\n\n        inventory.delete()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the name of the variation of the current dynamic field based on the given dynamic part.", "response": "def get_name_for(self, dynamic_part):\n        \"\"\"\n        Compute the name of the variation of the current dynamic field based on\n        the given dynamic part. Use the \"format\" attribute to create the final\n        name.\n        \"\"\"\n        name = self.format % dynamic_part\n        if not self._accept_name(name):\n            raise ImplementationError('It seems that pattern and format do not '\n                                      'match for the field \"%s\"' % self.name)\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_for(self, dynamic_part):\n        if not hasattr(self, '_instance'):\n            raise ImplementationError('\"get_for\" can be used only on a bound field')\n        name = self.get_name_for(dynamic_part)\n        return self._instance.get_field(name)", "response": "Returns a variation of the current dynamic field based on the given dynamic part."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef threadsafe_generator(generator_func):\n    def decoration(*args, **keyword_args):\n        \"\"\"A thread-safe decoration for a generator function.\"\"\"\n        return ThreadSafeIter(generator_func(*args, **keyword_args))\n    return decoration", "response": "A generator function that makes it thread - safe."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lazy_property(function):\n    cached_val = []\n    def _wrapper(*args):\n        try:\n            return cached_val[0]\n        except IndexError:\n            ret_val = function(*args)\n            cached_val.append(ret_val)\n            return ret_val\n    return _wrapper", "response": "Decorator for lazy property functions."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cat(self, numlines=None):\n        if len(self.titles) == 1:\n            lines = self.lines()\n            if numlines is not None:\n                lines = lines[len(lines)-numlines:]\n            log(\"\\n\".join(lines))\n        else:\n            lines = [self._printtuple(line[0], line[1]) for line in self.lines()]\n            if numlines is not None:\n                lines = lines[len(lines)-numlines:]\n            log(\"\".join(lines))", "response": "Return a list of lines output by this service."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _match_service(self, line_with_color):\n        line = re.compile(\"(\\x1b\\[\\d+m)+\").sub(\"\", line_with_color)        # Strip color codes\n\n        regexp = re.compile(r\"^\\[(.*?)\\]\\s(.*?)$\")\n        if regexp.match(line):\n            title = regexp.match(line).group(1).strip()\n            if title in self.titles:\n                return (title, regexp.match(line).group(2))\n        return None", "response": "Return line if line matches this service s name return None otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of JSON objects output by this service.", "response": "def json(self):\n        \"\"\"Return a list of JSON objects output by this service.\"\"\"\n        lines = []\n        for line in self.lines():\n            try:\n                if len(line) == 1:\n                    lines.append(json.loads(line, strict=False))\n                else:\n                    lines.append(json.loads(line[1], strict=False))\n            except ValueError:\n                pass\n        return lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef popen(*args, **kwargs):\n    process = subprocess.Popen(*args, **kwargs)\n    try:\n        yield process.pid\n    finally:\n        os.kill(process.pid, signal.SIGTERM)\n        os.waitpid(process.pid, 0)", "response": "Run a process in a with context."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef coerce(self, value):\n        if isinstance(value, LinearOrderedCell) and (self.domain == value.domain or \\\n            list_diff(self.domain, value.domain) == []):\n            # is LinearOrderedCell with same domain\n            return value\n        elif value in self.domain:\n            return LinearOrderedCell(self.domain, value, value)\n        elif isinstance(value, (list, tuple)) and all(map(value in self.domain, value)):\n            if len(value) == 1:\n                return LinearOrderedCell(self.domain, value[0], value[0])\n            elif len(value) == 2:\n                return LinearOrderedCell(self.domain, *value)\n            else:\n                sorted_vals = sorted(value, key=lambda x: self.to_i(x))\n                return LinearOrderedCell(self.domain, sorted_vals[0], sorted_vals[-1])\n        else:\n            raise Exception(\"Cannot coerce %s into LinearOrderedCell\" % (str(value)))", "response": "Coerces a value into a LinearOrderedCell with the same domain and returns a LinearOrderedCell with the same domain."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_contradictory(self, other):\n        other = self.coerce(other)\n        to_i = self.to_i\n        assert to_i(other.low) <= to_i(other.high), \"Low must be <= high\"\n        if max(map(to_i, [other.low, self.low])) <= min(map(to_i, [other.high, self.high])):\n            return False\n        else:\n            return True", "response": "Returns True if self can coexist\n        False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_entailed_by(self, other):\n        other = self.coerce(other)\n        to_i = self.to_i\n        return to_i(other.low) >= to_i(self.low) and \\\n                to_i(other.high) <= to_i(self.high)", "response": "Return True if self is entailed by other."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_equal(self, other):\n        other = self.coerce(other)\n        return list_diff(self.domain, other.domain) == [] \\\n                and self.low == other.low \\\n                and self.high == other.high", "response": "Return True if two intervals are the same."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge(self, other):\n        other = self.coerce(other)\n        if list_diff(self.domain, other.domain) != []:\n            raise Exception(\"Incomparable orderings. Different domains\")\n        if self.is_equal(other):\n            # pick among dependencies\n            return self\n        elif other.is_entailed_by(self):\n            return self\n        elif self.is_entailed_by(other):\n            self.low, self.high = other.low, other.high\n        elif self.is_contradictory(other):\n            raise Contradiction(\"Cannot merge %s and %s\" % (self, other))\n        else:\n            # information in both\n            to_i = self.to_i\n            self.low = self.domain[max(map(to_i, [self.low, other.low]))]\n            self.high =self.domain[min(map(to_i, [self.high, other.high]))]\n        return self", "response": "Merges two sets of values into this set."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef coerce(value):\n        if isinstance(value, ListCell):\n            return value\n        elif isinstance(value, (list)):\n            return ListCell(value)\n        else:\n            return ListCell([value])", "response": "Converts a value into a list of lists"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_contradictory(self, other):\n        if other.size() > self.size():\n            return other.is_contradictory(self)\n        # ensure self is bigger or equal size\n        if other.size() == 0:\n            # empty lists are fine\n            return False\n        \n        # see if any values in the shorter list are contradictory or \n        # unequal\n        for i, oval in enumerate(other.value):\n            if hasattr(self.value[i], 'is_contradictory') and \\\n                    self.value[i].is_contradictory(oval):\n                # allow comparing cells\n                return True\n            elif self.value[i] != oval:\n                return True\n        return False", "response": "Check if two lists are contradictory."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True iff the values in this list can be entailed by the other list.", "response": "def is_entailed_by(self, other):\n        \"\"\"\n        Returns True iff the values in this list can be entailed by the other\n        list (ie, this list is a prefix of the other)\n        \"\"\"\n        other = ListCell.coerce(other)\n        if other.size() < self.size():\n            # other is bigger, can't be entailed\n            return False\n        if self.value is None:\n            # list is empty\n            return True\n\n        # see if any values in the shorter list are contradictory or \n        # unequal\n        for i, oval in enumerate(other.value):\n            if i == len(self.value):\n                break\n\n            if hasattr(self.value[i], 'is_entailed_by') and \\\n                   not self.value[i].is_entailed_by(oval):\n                # compare cells\n                return False \n            elif self.value[i] != oval:\n                return False \n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds an element to the list.", "response": "def append(self, el):\n        \"\"\"\n        Idiosynractic method for adding an element to a list\n        \"\"\"\n        if self.value is None:\n            self.value = [el]\n        else:\n            self.value.append(el)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef merge(self, other):\n        other = PrefixCell.coerce(other)\n        if self.is_equal(other):\n            # pick among dependencies\n            return self\n        elif other.is_entailed_by(self):\n            return self\n        elif self.is_entailed_by(other):\n            self.value = other.value\n        elif self.is_contradictory(other):\n            raise Contradiction(\"Cannot merge prefix '%s' with '%s'\" % \\\n                    (self, other))\n        else:\n            if len(self.value) > len(other.value):\n                self.value = other.value[:]\n            # otherwise, return self\n        return self", "response": "Merges two prefixes into this one."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_template(self, context, **kwargs):\n        if 'template' in kwargs['params']:\n            self.template = kwargs['params']['template']\n        return super(GoscaleTemplateInclusionTag, self).get_template(context, **kwargs)", "response": "Returns the template to be used for the current context and arguments."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd any new given keywords from the custom keywords field in the admin and returns their IDs for use when saving a model with a .", "response": "def admin_keywords_submit(request):\n    \"\"\"\n    Adds any new given keywords from the custom keywords field in the\n    admin, and returns their IDs for use when saving a model with a\n    keywords field.\n    \"\"\"\n    keyword_ids, titles = [], []\n    remove = punctuation.replace(\"-\", \"\")  # Strip punctuation, allow dashes.\n    for title in request.POST.get(\"text_keywords\", \"\").split(\",\"):\n        title = \"\".join([c for c in title if c not in remove]).strip()\n        if title:\n            kw, created = Keyword.objects.get_or_create_iexact(title=title)\n            keyword_id = str(kw.id)\n            if keyword_id not in keyword_ids:\n                keyword_ids.append(keyword_id)\n                titles.append(title)\n    return HttpResponse(\"%s|%s\" % (\",\".join(keyword_ids), \", \".join(titles)),\n        content_type='text/plain')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef initial_validation(request, prefix):\n    post_data = request.POST\n    login_required_setting_name = prefix.upper() + \"S_ACCOUNT_REQUIRED\"\n    posted_session_key = \"unauthenticated_\" + prefix\n    redirect_url = \"\"\n    if getattr(settings, login_required_setting_name, False):\n        if not request.user.is_authenticated():\n            request.session[posted_session_key] = request.POST\n            error(request, _(\"You must be logged in. Please log in or \"\n                             \"sign up to complete this action.\"))\n            redirect_url = \"%s?next=%s\" % (settings.LOGIN_URL, reverse(prefix))\n        elif posted_session_key in request.session:\n            post_data = request.session.pop(posted_session_key)\n    if not redirect_url:\n        model_data = post_data.get(\"content_type\", \"\").split(\".\", 1)\n        if len(model_data) != 2:\n            return HttpResponseBadRequest()\n        try:\n            model = apps.get_model(*model_data)\n            obj = model.objects.get(id=post_data.get(\"object_pk\", None))\n        except (TypeError, ObjectDoesNotExist, LookupError):\n            redirect_url = \"/\"\n    if redirect_url:\n        if request.is_ajax():\n            return HttpResponse(dumps({\"location\": redirect_url}))\n        else:\n            return redirect(redirect_url)\n    return obj, post_data", "response": "This function is called by the validation endpoint of the base class. It is called by the validation endpoint to validate the initial request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle a ThreadedCommentForm submission and redirect back to its related object.", "response": "def comment(request, template=\"generic/comments.html\", extra_context=None):\n    \"\"\"\n    Handle a ``ThreadedCommentForm`` submission and redirect back to its\n    related object.\n    \"\"\"\n    response = initial_validation(request, \"comment\")\n    if isinstance(response, HttpResponse):\n        return response\n    obj, post_data = response\n    form_class = import_dotted_path(settings.COMMENT_FORM_CLASS)\n    form = form_class(request, obj, post_data)\n    if form.is_valid():\n        url = obj.get_absolute_url()\n        if is_spam(request, form, url):\n            return redirect(url)\n        comment = form.save(request)\n        response = redirect(add_cache_bypass(comment.get_absolute_url()))\n        # Store commenter's details in a cookie for 90 days.\n        for field in ThreadedCommentForm.cookie_fields:\n            cookie_name = ThreadedCommentForm.cookie_prefix + field\n            cookie_value = post_data.get(field, \"\")\n            set_cookie(response, cookie_name, cookie_value)\n        return response\n    elif request.is_ajax() and form.errors:\n        return HttpResponse(dumps({\"errors\": form.errors}))\n    # Show errors with stand-alone comment form.\n    context = {\"obj\": obj, \"posted_comment_form\": form}\n    context.update(extra_context or {})\n    return TemplateResponse(request, template, context)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling a RatingForm submission and redirect back to its related object.", "response": "def rating(request):\n    \"\"\"\n    Handle a ``RatingForm`` submission and redirect back to its\n    related object.\n    \"\"\"\n    response = initial_validation(request, \"rating\")\n    if isinstance(response, HttpResponse):\n        return response\n    obj, post_data = response\n    url = add_cache_bypass(obj.get_absolute_url().split(\"#\")[0])\n    response = redirect(url + \"#rating-%s\" % obj.id)\n    rating_form = RatingForm(request, obj, post_data)\n    if rating_form.is_valid():\n        rating_form.save()\n        if request.is_ajax():\n            # Reload the object and return the rating fields as json.\n            obj = obj.__class__.objects.get(id=obj.id)\n            rating_name = obj.get_ratingfield_name()\n            json = {}\n            for f in (\"average\", \"count\", \"sum\"):\n                json[\"rating_\" + f] = getattr(obj, \"%s_%s\" % (rating_name, f))\n            response = HttpResponse(dumps(json))\n        if rating_form.undoing:\n            ratings = set(rating_form.previous) ^ set([rating_form.current])\n        else:\n            ratings = rating_form.previous + [rating_form.current]\n        set_cookie(response, \"yacms-rating\", \",\".join(ratings))\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add(self, obj, metadata=None, update=False):\n        if (obj not in self) or update:\n            self[obj.id] = Object.fromdict(\n                obj.id,\n                dict(\n                    metadata=obj.metadata.read() if metadata is None else metadata,\n                    bitstreams=[bs._properties for bs in obj.bitstreams]))\n            time.sleep(0.1)\n            return self.objects[obj.id]", "response": "Adds an existing CDSTAR object to the catalog."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self, obj):\n        obj = self.api.get_object(getattr(obj, 'id', obj))\n        obj.delete()\n        self.remove(obj.id)", "response": "Delete an object in CDSTAR and remove it from the catalog."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(self, path, metadata, filter_=filter_hidden, object_class=None):\n        path = Path(path)\n        if path.is_file():\n            fnames = [path]\n        elif path.is_dir():\n            fnames = list(walk(path, mode='files'))\n        else:\n            raise ValueError('path must be a file or directory')  # pragma: no cover\n        for fname in fnames:\n            if not filter_ or filter_(fname):\n                created, obj = self._create(fname, metadata, object_class=object_class)\n                yield fname, created, obj", "response": "Create objects in CDSTAR and register them in the catalog."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parsePyLintWarnings(warnings):\n\n    warningsDict = {}\n\n    for line in warnings:\n\n        match = re.search(P_PYLINT_ERROR, line)\n\n        if match:\n            matchDict = match.groupdict()\n\n            if not warningsDict.get(matchDict[\"file\"]):\n                warningsDict[matchDict[\"file\"]] = []\n\n            warningEntry = {\n                \"line\": matchDict.get(\"file\"),\n                \"warning_id\": matchDict.get(\"type\") + matchDict.get(\"errno\"),\n            }\n\n            if matchDict.get(\"msg\"):\n                warningEntry[\"warning_message\"] = matchDict.get(\"msg\")\n\n            warningsDict[matchDict[\"file\"]].append(warningEntry)\n\n    return warningsDict", "response": "Takes a list of pyLint s log warnings and returns a dictionary of the warnings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting object from list of objects", "response": "def get_page_object(objects, sid):\n    \"\"\"\n    **Arguments**\n\n    ``objects``\n        all objects\n\n    ``sid`\n        symbolic id for object selection\n\n    :return selected object\n    \"\"\"\n    selected_object = None\n\n    for obj in objects:\n        if obj.sid == sid:\n            selected_object = obj\n            break\n    return selected_object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the object by name from the object list.", "response": "def get_page_object_by_name(context, name):\n    \"\"\"\n    **Arguments**\n\n    ``name`\n        name for object selection\n\n    :return selected object\n    \"\"\"\n    selected_object = None\n\n    try:\n        for obj_type in context['page']['content']:\n            for obj in context['page']['content'][obj_type]:\n                if obj.name == name:\n                    selected_object = obj\n                    break\n        if selected_object is None:\n            for obj_type in context['page']['content']:\n                for obj in context['page']['ext_content'][obj_type]:\n                    if obj.name == name:\n                        selected_object = obj\n                        break\n    except TypeError:\n        pass\n    return selected_object"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_page_object_by_id(context, object_type, oid):\n    if type(oid) != int:\n        raise template.TemplateSyntaxError('page_object_by_id tag requires a integer argument')\n\n    selected_object = None\n\n    try:\n        try:\n            for obj in context['page']['content'][object_type]:\n                sid = '{0:>s}:{1:>s}:{2:>s}:{3:>d}'.format(\n                    obj.language, context['page']['page'].name, obj.type, oid\n                )\n                if obj.sid == sid:\n                    selected_object = obj\n                    break\n        except TypeError:\n            pass\n    except KeyError:\n        try:\n            try:\n                for obj in context['page']['ext_content'][object_type]:\n                    sid = '{0:>s}:{1:>s}:{2:>s}:{3:>d}'.format(\n                        obj.language, context['page']['page'].name, obj.type, oid\n                    )\n                    if obj.sid == sid:\n                        selected_object = obj\n                        break\n            except TypeError:\n                pass\n        except KeyError:\n            raise template.TemplateSyntaxError('wrong content type: {0:>s}'.format(object_type))\n    return selected_object", "response": "Get the page object by its id."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_page_objects_by_type(context, object_type):\n    try:\n        objects = context['page']['content'][object_type]\n    except KeyError:\n        raise template.TemplateSyntaxError('wrong content type: {0:>s}'.format(object_type))\n    return objects", "response": "Get page objects by type."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets objects of the given object type from the page s ext_content list.", "response": "def get_page_objects_by_ext_type(context, object_type):\n    \"\"\"\n    **Arguments**\n\n    ``object_type``\n        object type\n\n    :return selected objects\n    \"\"\"\n    try:\n        objects = context['page']['ext_content'][object_type]\n    except KeyError:\n        raise template.TemplateSyntaxError('wrong content type: {0:>s}'.format(object_type))\n    return objects"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef csep_close(ra, rb):\n    seps = csep(ra, rb)\n    seps_sq = np.sum(np.square(seps), axis=-1)\n\n    i_close = np.argmin(seps_sq, axis=-1)\n\n    i_all = list(range(len(seps)))\n    sep = seps[i_all, i_close]\n    sep_sq = seps_sq[i_all, i_close]\n    return sep, sep_sq", "response": "Return the closest separation vector between each point in one set and every point in a second set."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef csep_periodic(ra, rb, L):\n    seps = ra[:, np.newaxis, :] - rb[np.newaxis, :, :]\n    for i_dim in range(ra.shape[1]):\n        seps_dim = seps[:, :, i_dim]\n        seps_dim[seps_dim > L[i_dim] / 2.0] -= L[i_dim]\n        seps_dim[seps_dim < -L[i_dim] / 2.0] += L[i_dim]\n    return seps", "response": "Return the separation vectors between each pair of two sets of points."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef csep_periodic_close(ra, rb, L):\n    seps = csep_periodic(ra, rb, L)\n    seps_sq = np.sum(np.square(seps), axis=-1)\n\n    i_close = np.argmin(seps_sq, axis=-1)\n\n    i_all = list(range(len(seps)))\n    sep = seps[i_all, i_close]\n    sep_sq = seps_sq[i_all, i_close]\n    return sep, sep_sq", "response": "Return the closest separation vector between each point in one set and every point in a second set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the squared distance between each point in on set ra rb and L.", "response": "def cdist_sq_periodic(ra, rb, L):\n    \"\"\"Return the squared distance between each point in on set,\n    and every point in a second set, in periodic space.\n\n    Parameters\n    ----------\n    ra, rb: float array-like, shape (n, d) and (m, d) in d dimensions.\n        Two sets of points.\n    L: float array, shape (d,)\n        System lengths.\n\n    Returns\n    -------\n    cdist_sq: float array-like, shape (n, m, d)\n        cdist_sq[i, j] is the squared distance between point j and point i.\n    \"\"\"\n    return np.sum(np.square(csep_periodic(ra, rb, L)), axis=-1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pdist_sq_periodic(r, L):\n    d = csep_periodic(r, r, L)\n    d[np.identity(len(r), dtype=np.bool)] = np.inf\n    d_sq = np.sum(np.square(d), axis=-1)\n    return d_sq", "response": "Return the squared distance between all combinations of\n    a set of points in periodic space."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef angular_distance(n1, n2):\n    return np.arctan2(vector.vector_mag(np.cross(n1, n2)), np.dot(n1, n2))", "response": "Returns the angular separation between two 3 dimensional vectors."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the value of the attribute from the source object.", "response": "def get_value(self, source):\n    \"\"\"Apply self.convert to the source. The parameter passed to convert depends on\n    self.source_name. If source_name is given, self.convert(getattr(source, source_name)) is called,\n    otherwise self.convert(source) is called.\n    \"\"\"\n    if self.source_name is None:\n      present, value = True, self.convert(source)\n      converted = True\n    else:\n      present, value = has_value(source, self.source_name)\n      converted = False\n\n    if not present or value is None:\n      if self.is_required:\n        raise ValueError(\"required value not present\")\n      else:\n        return None\n    else:\n      if converted:\n        return value\n      else:\n        return self.convert(value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_namedtuple(cls, field_mappings, name=\"Record\"):\n    return namedtuple(name, [fm.destination_name for fm in field_mappings])", "response": "Gets a namedtuple class that matches the destination_names in the list of field_mappings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_namedtuple_factory(cls, field_mappings, name=\"Record\"):\n    ntup = cls.get_namedtuple(field_mappings, name)\n    return lambda data: ntup(**data)", "response": "Returns a method that will convert a dictionary to a namedtuple"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a record to a dictionary via field_mappings and pass that to destination_factory.", "response": "def transfer(cls, field_mappings, source, destination_factory):\n    \"\"\"Convert a record to a dictionary via field_mappings, and pass that to destination_factory.\"\"\"\n    data = dict()\n    for index, field_mapping in enumerate(field_mappings):\n      try:\n        data[field_mapping.destination_name] = field_mapping.get_value(source)\n      except Exception as ex:\n        raise Exception(\n          \"Error with mapping #{0} '{1}'->'{2}': {3}\".format(\n            index,\n            field_mapping.source_name,\n            field_mapping.destination_name, ex)) from ex\n    return destination_factory(data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transfer_all(cls, field_mappings, sources, destination_factory=None):\n    for index, source in enumerate(sources):\n      try:\n        yield cls.transfer(field_mappings, source, destination_factory or (lambda x: x))\n      except Exception as ex:\n        raise Exception(\"Error with source #{0}: {1}\".format(index, ex)) from ex", "response": "Calls cls. transfer on all records in sources."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmerges content of a dict in another dict", "response": "def merge_dict(lhs, rhs):\n    \"\"\" Merge content of a dict in another\n\n    :param: dict: lhs\n      dict where is merged the second one\n    :param: dict: rhs\n      dict whose content is merged\n    \"\"\"\n    assert isinstance(lhs, dict)\n    assert isinstance(rhs, dict)\n    for k, v in rhs.iteritems():\n        if k not in lhs:\n            lhs[k] = v\n        else:\n            lhs[k] = merge_dict(lhs[k], v)\n    return lhs"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_dict(data):\n    assert isinstance(data, dict)\n    options = data.get('options', {})\n    content = data.get('content', {})\n\n    def get_type(key, type_str):\n        if TYPE_RE.match(type_str) is not None:\n            return eval(type_str)\n        else:\n            raise Exception((u\"Value of key '{}' must match the \"\n                             u\"following regular expression: {}\").format(\n                 key, TYPE_RE.pattern\n             ))\n\n    def to_func(key, func_str, args):\n        if isinstance(args, (str, float, int)):\n            # It is very dangerous to try to convert every string argument\n            # to a Python type...\n            try:\n                args = get_type(key, args)\n            except:\n                pass\n        elif isinstance(args, list):\n            if any(args) and key is not None and args[0] == key:\n                args.pop(0)\n                if len(args) == 1:\n                    return to_func(key, func_str, args[0])\n            for i in range(len(args)):\n                arg = args[i]\n                if isinstance(arg, dict):\n                    if len(arg) > 1:\n                        raise Exception(\n                            u\"Invalid parameter {} in function {}\".format(\n                                arg.keys()[0], func_str\n                            ))\n                    elif not any(arg):\n                        raise Exception(\n                            u\"Empty dict parameter in function {}\".format(\n                                func_str\n                            )\n                        )\n                    else:\n                        args[i] = to_func(None, *(next(arg.iteritems())))\n                elif isinstance(arg, (str, int, float)):\n                    try:\n                        args[i] = get_type(key, arg)\n                    except:\n                        pass\n                else:\n                    raise NotImplementedError(\n                        u\"Unhandled parameter {} in function {}\".format(\n                            arg, func_str\n                        )\n                    )\n        elif isinstance(args, dict):\n            pass  # FIXME: might be required to recursively evaluate values\n        elif args is None and key is not None:\n            pass\n        else:\n            return get_type(key, func_str)\n\n        func = getattr(voluptuous, func_str, None)\n        if func is None:\n            return (func_str, args)\n        else:\n            call = u'{}('.format(func.__name__)\n            if key is not None:\n                func = functools.partial(func, key)\n                call += '%r, ' % key\n            call += '%r)' % args\n            LOGGER.debug(u'yamlious call: {}'.format(call))\n            if isinstance(args, list):\n                return func(*args)\n            elif isinstance(args, dict):\n                return func(**args)\n            else:\n                return func(args)\n\n    def extract_content(content, schema=None):\n        schema = schema or dict()\n        for k, v in content.iteritems():\n            k = str(k)\n            if isinstance(v, (int, str, float)):\n                schema[k] = get_type(k, str(v))\n            elif inspect.isclass(v):\n                schema[k] = v\n            elif isinstance(v, list):\n                schema[k] = [extract_content(e) for e in v]\n            elif isinstance(v, dict):\n                key = v.pop('key', None)\n                nested = v.pop('nested', None)\n                if key is not None:\n                    # Special key for Required('bla')\n                    if isinstance(key, basestring):\n                        key = {key: None}\n                    if not isinstance(key, dict):\n                        raise Exception(\"'key' value must be a dict\")\n                    elif len(key) != 1:\n                        raise Exception(\"'key' dict value size must be 1\")\n                    k = to_func(k, *next(key.iteritems()))\n                if nested is not None and any(v):\n                    raise Exception((\n                        \"In key {}: cannot have both nested dict and extra\"\n                        u\"key(s): {}\").format(\n                            k, ','.join(map(str(v.keys())))\n                        ))\n                if nested is not None:\n                    schema[k] = extract_content(nested)\n                elif len(v) > 1:\n                    raise Exception(\n                        \"In key \" + k +\n                        \": cannot have more than function value\"\n                    )\n                elif len(v) == 0:\n                    raise Exception(\n                        \"In key \" + str(k) +\n                        \": value cannot be an empty dict\"\n                    )\n                else:\n                    schema[k] = to_func(None, *next(v.iteritems()))\n\n        return schema\n    return (extract_content(content), options)", "response": "Build input parameters of voluptuous. Schema class from dict description."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_yaml(*streams):\n    return from_dict(merge_dicts(*map(\n        lambda f: yaml.load(f, Loader=Loader),\n        list(streams)\n    )))", "response": "Build voluptuous. Schema function parameters from a list of YAML files."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_config(raise_=True):\n    ELIBConfig.check()\n    known_paths = set()\n    duplicate_values = set()\n    missing_values = set()\n    for config_value in ConfigValue.config_values:\n        if config_value.path not in known_paths:\n            known_paths.add(config_value.path)\n        else:\n            duplicate_values.add(config_value.name)\n        try:\n            config_value()\n        except MissingValueError:\n            missing_values.add(config_value.name)\n\n    if raise_ and duplicate_values:\n        raise DuplicateConfigValueError(str(duplicate_values))\n    if raise_ and missing_values:\n        raise MissingValueError(str(missing_values), 'missing config value(s)')\n    return duplicate_values, missing_values", "response": "Verifies that all configuration values have a valid setting."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngroup items from iterable by key and return a dictionary where keys are the items of the iterable having the same key.", "response": "def groupby(iterable, key=None):\n    \"\"\"\n    Group items from iterable by key and return a dictionary where values are\n    the lists of items from the iterable having the same key.\n\n    :param key: function to apply to each element of the iterable.\n      If not specified or is None key defaults to identity function and\n      returns the element unchanged.\n\n    :Example:\n    >>> groupby([0, 1, 2, 3], key=lambda x: x % 2 == 0)\n    {True: [0, 2], False: [1, 3]}\n    \"\"\"\n    groups = {}\n    for item in iterable:\n        if key is None:\n            key_value = item\n        else:\n            key_value = key(item)\n        groups.setdefault(key_value, []).append(item)\n    return groups"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndelegates a rule to another class which instantiates a Klein app This also memoizes the resource instance on the handler function itself", "response": "def enter(clsQname):\n    \"\"\"\n    Delegate a rule to another class which instantiates a Klein app\n\n    This also memoizes the resource instance on the handler function itself\n    \"\"\"\n    def wrapper(routeHandler):\n        @functools.wraps(routeHandler)\n        def inner(self, request, *a, **kw):\n            if getattr(inner, '_subKlein', None) is None:\n                cls = namedAny(clsQname)\n                inner._subKlein = cls().app.resource()\n            return routeHandler(self, request, inner._subKlein, *a, **kw)\n        inner._subKleinQname = clsQname\n        return inner\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef openAPIDoc(**kwargs):\n    s = yaml.dump(kwargs, default_flow_style=False)\n    def deco(routeHandler):\n        # Wrap routeHandler, retaining name and __doc__, then edit __doc__.\n\n        # The only reason we need to do this is so we can be certain\n        # that __doc__ will be modifiable. partial() objects have\n        # a modifiable __doc__, but native function objects do not.\n        ret = functools.wraps(routeHandler)(routeHandler)\n        if not ret.__doc__:\n            ret.__doc__ = ''\n        ret.__doc__ = cleandoc(ret.__doc__) + '\\n---\\n' + s\n        return ret\n    return deco", "response": "Decorator to update a function s docstring to include the OpenAPI Yaml generated by running the OpenAPIGraph object\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn this comment as plain text. Useful for emails.", "response": "def get_as_text(self):\n        \"\"\"\n        Return this comment as plain text.  Useful for emails.\n        \"\"\"\n        d = {\n            'user': self.user or self.name,\n            'date': self.post_date,\n            'comment': self.text,\n            'domain': self.site.domain,\n            'url': self.get_absolute_url()\n        }\n        return _('Posted by %(user)s at %(date)s\\n\\n%(comment)s\\n\\nhttp://%(domain)s%(url)s') % d"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling an HTTP exception by rendering a template based on the code of the HTTPException.", "response": "def handle_http_exception(error):\n    \"\"\"\n    Attempts to render a template based on the `code` of a `HTTPException`. The\n    format string `errors/{code}.html` is used to generate the filename of\n    the template.\n\n    e.g. A `NotFound` exception will attempt to render `errors/404.html`.\n\n    If no template is found the standard flask error response is returned.\n    \"\"\"\n    template = TEMPLATE.format(code=error.code)\n\n    try:\n        return flask.render_template(template, exception=error), error.code\n    except jinja2.exceptions.TemplateNotFound:\n        pass\n\n    return error"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes the application with the error handler", "response": "def init_app(application):\n    \"\"\"\n    Associates the error handler\n    \"\"\"\n    for code in werkzeug.exceptions.default_exceptions:\n        application.register_error_handler(code, handle_http_exception)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _find_palettes(stream):\n    ''' Need to configure palettes manually, since we are checking stderr. '''\n    chosen = choose_palette(stream=stream)\n    palettes = get_available_palettes(chosen)\n    fg = ForegroundPalette(palettes=palettes)\n    fx = EffectsPalette(palettes=palettes)\n    return fg, fx, chosen", "response": "Find the available palettes and return them as a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a new logging level to the logging module and the logging class.", "response": "def add_logging_level(name, value, method_name=None):\n    ''' Comprehensively adds a new logging level to the ``logging`` module and\n        the currently configured logging class.\n\n        Derived from: https://stackoverflow.com/a/35804945/450917\n    '''\n    if not method_name:\n        method_name = name.lower()\n\n    # set levels\n    logging.addLevelName(value, name)\n    setattr(logging, name, value)\n    level_map[name.lower()] = value\n\n    if value == getattr(logging, 'EXCEPT', None):  # needs traceback added\n        def logForLevel(self, message='', *args, **kwargs):\n            if self.isEnabledFor(value):\n                message = (message + ' \u25be\\n').lstrip() + traceback.format_exc()\n                self._log(value, message, args, **kwargs)\n    else:\n        def logForLevel(self, message, *args, **kwargs):\n            if self.isEnabledFor(value):\n                self._log(value, message, args, **kwargs)\n\n    def logToRoot(message, *args, **kwargs):  # may not need\n        logging.log(value, message, *args, **kwargs)\n\n    # set functions\n    setattr(logging.getLoggerClass(), method_name, logForLevel)\n    setattr(logging, method_name, logToRoot)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef configure(self, **kwargs):\n        ''' Convenience function to set a number of parameters on this logger\n            and associated handlers and formatters.\n        '''\n        for kwarg in kwargs:\n            value = kwargs[kwarg]\n\n            if kwarg == 'level':\n                self.set_level(value)\n\n            elif kwarg == 'default_level':\n                self.default_level = level_map.get(value, value)\n\n            elif kwarg == 'datefmt':\n                self.handlers[0].formatter.datefmt = value\n\n            elif kwarg == 'msgfmt':\n                self.handlers[0].formatter._style._fmt = value\n\n            elif kwarg == 'stream':\n                global fg, fx, _CHOSEN_PALETTE\n                self.handlers[0].stream = value\n                fg, fx, _CHOSEN_PALETTE = _find_palettes(value)\n\n            elif kwarg == 'theme':\n                if type(value) is str:\n                    theme = _themes[value]\n                    if value == 'plain':\n                        fmtr =  logging.Formatter(style='{', **theme)\n                    elif value == 'json':\n                        fmtr =  _JSONFormatter(**theme)\n                    else:\n                        fmtr =  _ColorFormatter(tty=_is_a_tty, **theme)\n                elif type(value) is dict:\n                    if 'style' in value or 'icons' in value:\n                        fmtr =  _ColorFormatter(tty=_is_a_tty, **theme)\n                    else:\n                        fmtr =  logging.Formatter(style='{', **theme)\n                self.handlers[0].setFormatter(fmtr)\n\n            elif kwarg == 'icons':\n                if type(value) is str:\n                    value = _icons[value]\n                self.handlers[0].formatter._theme_icons = value\n\n            elif kwarg == 'style':\n                if type(value) is str:\n                    value = _styles[value]\n                self.handlers[0].formatter._theme_style = value\n\n            elif kwarg == 'lexer':\n                try:\n                    self.handlers[0].formatter.set_lexer(value)\n                except AttributeError as err:\n                    self.error('lexer: ColorFormatter not available.')\n            else:\n                raise NameError('unknown keyword argument: %s' % kwarg)", "response": "Convenience function to set a number of parameters on this logger\n            and associated handlers and formatters."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlogging the current logging configuration.", "response": "def log_config(self):\n        ''' Log the current logging configuration. '''\n        level = self.level\n        debug = self.debug\n        debug('Logging config:')\n        debug('/ name: {}, id: {}', self.name, id(self))\n        debug('  .level: %s (%s)', level_map_int[level], level)\n        debug('  .default_level: %s (%s)',\n                   level_map_int[self.default_level], self.default_level)\n\n        for i, handler in enumerate(self.handlers):\n            fmtr = handler.formatter\n            debug('  + Handler: %s %r', i, handler)\n            debug('    + Formatter: %r', fmtr)\n            debug('      .datefmt: %r', fmtr.datefmt)\n            debug('      .msgfmt: %r', fmtr._fmt)\n            debug('      fmt_style: %r', fmtr._style)\n            try:\n                debug('      theme styles: %r', fmtr._theme_style)\n                debug('      theme icons:\\n%r', fmtr._theme_icons)\n                debug('      lexer: %r\\n', fmtr._lexer)\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking that a number that represents a date as milliseconds is correct.", "response": "def is_valid_timestamp(date, unit='millis'):\n    \"\"\"\n    Checks that a number that represents a date as milliseconds is correct.\n    \"\"\"\n    assert isinstance(date, int), \"Input is not instance of int\"\n\n    if unit is 'millis':\n        return is_positive(date) and len(str(date)) == 13\n    elif unit is 'seconds':\n        return is_positive(date) and len(str(date)) == 10\n    else:\n        raise ValueError('Unknown unit \"%s\"' % unit)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites log at DEBUG level.", "response": "def debug(self, msg=None, *args, **kwargs):\n        \"\"\"Write log at DEBUG level. Same arguments as Python's built-in\n        Logger.\n\n        \"\"\"\n\n        return self._log(logging.DEBUG, msg, args, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef exception(self, msg=None, *args, **kwargs):\n        kwargs['exc_info'] = 1\n        return self._log(logging.ERROR, msg, args, kwargs)", "response": "Similar to log but at ERROR level with exc_info set."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef log(self, level, msg=None, *args, **kwargs):\n\n        return self._log(level, msg, args, kwargs)", "response": "Writes a log message at any arbitray level."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlog a message to the logger.", "response": "def _log(self, level, msg, args, kwargs):\n        \"\"\"Throttled log output.\"\"\"\n\n        with self._tb_lock:\n            if self._tb is None:\n                throttled = 0\n                should_log = True\n            else:\n                throttled = self._tb.throttle_count\n                should_log = self._tb.check_and_consume()\n\n        if should_log:\n            if throttled > 0:\n                self._logger.log(level, \"\")\n                self._logger.log(\n                    level,\n                    \"(... throttled %d messages ...)\",\n                    throttled,\n                )\n                self._logger.log(level, \"\")\n\n            if msg is not None:\n                self._logger.log(level, msg, *args, **kwargs)\n\n            return FancyLogContext(self._logger,\n                                   level,\n                                   self._verbosity,\n                                   self._structured_detail,\n                                   self._with_prefix)\n        else:\n            return NoopLogContext()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef timestamp_to_local_time(timestamp, timezone_name):\n    # first convert timestamp to UTC\n    utc_time = datetime.utcfromtimestamp(float(timestamp))\n    delo = Delorean(utc_time, timezone='UTC')\n    # shift d according to input timezone\n    localized_d = delo.shift(timezone_name)\n    return localized_d", "response": "Convert an epoch timestamp to a localized Delorean datetime object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef timestamp_to_local_time_str(\n        timestamp, timezone_name, fmt=\"yyyy-MM-dd HH:mm:ss\"):\n    \"\"\"Convert epoch timestamp to a localized datetime string.\n\n    Arguments\n    ---------\n    timestamp : int\n        The timestamp to convert.\n    timezone_name : datetime.timezone\n        The timezone of the desired local time.\n    fmt : str\n        The format of the output string.\n\n    Returns\n    -------\n    str\n        The localized datetime string.\n    \"\"\"\n    localized_d = timestamp_to_local_time(timestamp, timezone_name)\n    localized_datetime_str = localized_d.format_datetime(fmt)\n    return localized_datetime_str", "response": "Convert epoch timestamp to a localized datetime string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_timestamp(timezone_name, year, month, day, hour=0, minute=0):\n    tz = pytz.timezone(timezone_name)\n    tz_datetime = tz.localize(datetime(year, month, day, hour, minute))\n    timestamp = calendar.timegm(tz_datetime.utctimetuple())\n    return timestamp", "response": "Get epoch timestamp from timezone year month day hour and minute."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncarving up a media range and returns a tuple of the type subtype and params.", "response": "def parse_media_range(range):\n    \"\"\"Carves up a media range and returns a tuple of the\n       (type, subtype, params) where 'params' is a dictionary\n       of all the parameters for the media range.\n       For example, the media range 'application/*;q=0.5' would\n       get parsed into:\n\n       ('application', '*', {'q', '0.5'})\n\n       In addition this function also guarantees that there \n       is a value for 'q' in the params dictionary, filling it\n       in with a proper default if necessary.\n       \"\"\"\n    (type, subtype, params) = parse_mime_type(range)\n    if 'q' not in params or not params['q'] or \\\n            float(params['q']) > 1 or float(params['q']) < 0:\n        params['q'] = '1'\n    return (type, subtype, params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fitness_and_quality_parsed(mime_type, parsed_ranges):\n    best_fitness = -1 \n    best_fit_q = 0\n    (target_type, target_subtype, target_params) =\\\n            parse_media_range(mime_type)\n    for (type, subtype, params) in parsed_ranges:\n        if (type == target_type or type == '*' or target_type == '*') and \\\n                (subtype == target_subtype or subtype == '*' or target_subtype == '*'):\n            param_matches = reduce(lambda x, y: x+y, [1 for (key, value) in \\\n                    list(target_params.items()) if key != 'q' and \\\n                    key in params and value == params[key]], 0)\n            fitness = (type == target_type) and 100 or 0\n            fitness += (subtype == target_subtype) and 10 or 0\n            fitness += param_matches\n            if fitness > best_fitness:\n                best_fitness = fitness\n                best_fit_q = params['q']\n            \n    return float(best_fit_q), best_fitness", "response": "Find the best match for a given mime - type against a list of parsed media ranges."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef upgrader(version=None):\n\n    def decorator(func):\n        # Save the version to update from\n        func.__vers_upgrader__ = version\n        return func\n\n    # What is version?  It can be None, an int, or a callable,\n    # depending on how @upgrader() was called\n    if version is None:\n        # Called as @upgrader(); return the decorator\n        return decorator\n    elif isinstance(version, six.integer_types):\n        # Called as @upgrader(1); sanity-check version and return the\n        # decorator\n        if version < 1:\n            raise TypeError(\"Invalid upgrader version number %r\" % version)\n        return decorator\n    elif callable(version):\n        # Called as @upgrader; use version = None and call the\n        # decorator\n        func = version\n        version = None\n        return decorator(func)\n    else:\n        # Called with an invalid version\n        raise TypeError(\"Invalid upgrader version number %r\" % version)", "response": "A function to mark a method as an upgrader from an older version of a given object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef downgrader(version):\n\n    def decorator(func):\n        # Save the version to downgrade to\n        func.__vers_downgrader__ = version\n        return func\n\n    # Sanity-check the version number\n    if not isinstance(version, six.integer_types) or version < 1:\n        raise TypeError(\"Invalid downgrader version number %r\" % version)\n\n    return decorator", "response": "A decorator that makes a function downgrader to an older\n    version of a given object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate the service files and returns a list of them.", "response": "def generate(self, overwrite=False):\n        \"\"\"Generate service files and returns a list of them.\n\n        Note that env var names will be capitalized using a Jinja filter.\n        This is template dependent.\n        Even though a param might be named `key` and have value `value`,\n        it will be rendered as `KEY=value`.\n\n        We retrieve the names of the template files and see the paths\n        where the generated files will be deployed. These are files\n        a user can just take and use.\n        If the service is also installed, those files will be moved\n        to the relevant location on the system.\n\n        Note that the parameters required to generate the file are\n        propagated automatically which is why we don't pass them explicitly\n        to the generating function.\n\n        `self.template_prefix` and `self.generate_into_prefix` are set in\n         `base.py`\n\n        `self.files` is an automatically generated list of the files that\n        were generated during the process. It should be returned so that\n        the generated files could be printed out for the user.\n        \"\"\"\n        super(SystemD, self).generate(overwrite=overwrite)\n        self._validate_init_system_specific_params()\n\n        svc_file_template = self.template_prefix + '.service'\n        env_file_template = self.template_prefix\n        self.svc_file_path = self.generate_into_prefix + '.service'\n        self.env_file_path = self.generate_into_prefix\n\n        self.generate_file_from_template(svc_file_template, self.svc_file_path)\n        self.generate_file_from_template(env_file_template, self.env_file_path)\n        return self.files"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef install(self):\n        super(SystemD, self).install()\n\n        self.deploy_service_file(self.svc_file_path, self.svc_file_dest)\n        self.deploy_service_file(self.env_file_path, self.env_file_dest)\n        sh.systemctl.enable(self.name)\n        sh.systemctl('daemon-reload')", "response": "Install the service on the local machine"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef status(self, name=''):\n        super(SystemD, self).status(name=name)\n\n        svc_list = sh.systemctl('--no-legend', '--no-pager', t='service')\n        svcs_info = [self._parse_service_info(svc) for svc in svc_list]\n        if name:\n            names = (name, name + '.service')\n            # return list of one item for specific service\n            svcs_info = [s for s in svcs_info if s['name'] in names]\n        self.services['services'] = svcs_info\n        return self.services", "response": "Return a list of the statuses of the name service or all services for this init system."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sort(self, *sort):\n        self.add_get_param('sort', FILTER_DELIMITER.join(\n            [ELEMENT_DELIMITER.join(elements) for elements in sort]))\n        return self", "response": "Sort the results.\n\n        Define how the results should be sorted. The arguments should be tuples\n        of string defining the key and direction to sort by. For example\n        `('name', 'asc')` and `('version', 'desc')`. The first sorte rule is\n        considered first by the API. See also the API documentation on\n        `sorting`_.\n\n        Arguments:\n            `*sort` (`tuple`)\n                The rules to sort by\n\n        .. _sorting: https://github.com/XereoNet/SpaceGDN/wiki/API#sorting"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfiltering the results. Filter the results by provided rules. The rules should be tuples that look like this:: ('<key>', '<operator>', '<value>') For example:: ('name', '$eq', 'Vanilla Minecraft') This is also covered in the documentation_ of the SpaceGDN API. .. _documentation: https://github.com/XereoNet/SpaceGDN/wiki/API#where", "response": "def where(self, *where):\n        \"\"\" Filter the results.\n\n        Filter the results by provided rules. The rules should be tuples that\n        look like this::\n\n            ('<key>', '<operator>', '<value>')\n\n        For example::\n\n            ('name', '$eq', 'Vanilla Minecraft')\n\n        This is also covered in the documentation_ of the SpaceGDN API.\n\n        .. _documentation: https://github.com/XereoNet/SpaceGDN/wiki/API#where\n\n        \"\"\"\n        filters = list()\n        for key, operator, value in where:\n            filters.append(ELEMENT_DELIMITER.join((key, operator, value)))\n        self.add_get_param('where', FILTER_DELIMITER.join(filters))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the request and fetch the results.", "response": "def fetch(self):\n        \"\"\" Run the request and fetch the results.\n\n        This method will compile the request, send it to the SpaceGDN endpoint\n        defined with the `SpaceGDN` object and wrap the results in a\n        :class:`pyspacegdn.Response` object.\n\n        Returns a :class:`pyspacegdn.Response` object.\n\n        \"\"\"\n        response = Response()\n        has_next = True\n        while has_next:\n            resp = self._fetch(default_path='v2')\n            results = None\n            if resp.success:\n                results = resp.data['results']\n                self.add_get_param('page', resp.data['pagination']['page'] + 1)\n                has_next = resp.data['pagination']['has_next']\n            response.add(results, resp.status_code, resp.status_reason)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef singleton(cls):\n    import inspect\n\n    # Create a structure to store instances of any singletons that get\n    # created.\n    instances = {}\n\n    # Make sure that the constructor for this class doesn't take any\n    # arguments.  Since singletons can only be instantiated once, it doesn't\n    # make any sense for the constructor to take arguments.  If the class \n    # doesn't implement its own constructor, don't do anything.  This case is \n    # considered specially because it causes a TypeError in python 3.3 but not \n    # in python 3.4.\n    if cls.__init__ is not object.__init__:\n        argspec = inspect.getfullargspec(cls.__init__)\n        if len(argspec.args) != 1 or argspec.varargs or argspec.varkw:\n            raise TypeError(\"Singleton classes cannot accept arguments to the constructor.\")\n\n\n    def get_instance():\n        \"\"\" Creates and returns the singleton object.  This function is what \n        gets returned by this decorator. \"\"\"\n\n        # Check to see if an instance of this class has already been\n        # instantiated.  If it hasn't, create one.  The `instances` structure\n        # is technically a global variable, so it will be preserved between\n        # calls to this function.\n        if cls not in instances:\n            instances[cls] = cls()\n\n        # Return a previously instantiated object of the requested type.\n        return instances[cls]\n\n    # Return the decorator function.\n    return get_instance", "response": "Decorator function that turns a class into a singleton."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_dict(doc):\n        if 'path' in doc:\n            path = doc['path']\n        else:\n            path = None\n        return ModelOutputFile(\n            doc['filename'],\n            doc['mimeType'],\n            path=path\n        )", "response": "Create a model output file object from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_dict(self):\n        doc = {\n            'filename' : self.filename,\n            'mimeType' : self.mime_type\n        }\n        # Add path if present\n        if self.filename != self.path:\n            doc['path'] = self.path\n        return doc", "response": "Returns a dictionary representation of the object to convert into a Json\n        object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a model output object from a dictionary.", "response": "def from_dict(doc):\n        \"\"\"Create a model output object from a dictionary.\n\n        \"\"\"\n        return ModelOutputs(\n            ModelOutputFile.from_dict(doc['prediction']),\n            [ModelOutputFile.from_dict(a) for a in doc['attachments']]\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_dict(self):\n        return {\n            'prediction' : self.prediction_file.to_dict(),\n            'attachments' : [a.to_dict() for a in self.attachments]\n        }", "response": "Get a dictionary serialization of the object to convert into a Json\n        object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting the model with given identifier in the database. Returns the object handle for the deleted model or None if the model identifier is unknown.", "response": "def delete_model(self, model_id, erase=False):\n        \"\"\"Delete the model with given identifier in the database. Returns the\n        handle for the deleted model or None if object identifier is unknown.\n\n        Parameters\n        ----------\n        model_id : string\n            Unique model identifier\n        erase : Boolean, optinal\n            If true, the record will be deleted from the database. Otherwise,\n            the active flag will be set to False to support provenance tracking.\n\n        Returns\n        -------\n        ModelHandle\n        \"\"\"\n        return self.delete_object(model_id, erase=erase)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates an experiment object for the subject and image group.", "response": "def register_model(self, model_id, properties, parameters, outputs, connector):\n        \"\"\"Create an experiment object for the subject and image group. Objects\n        are referenced by their identifier. The reference to a functional data\n        object is optional.\n\n        Raises ValueError if no valid experiment name is given in property list.\n\n        Parameters\n        ----------\n        model_id : string\n            Unique model identifier\n        properties : Dictionary\n            Dictionary of model specific properties.\n        parameters : list(scodata.attribute.AttributeDefinition)\n            List of attribute definitions for model run parameters\n        outputs : ModelOutputs\n            Description of model outputs\n        connector : dict\n            Connection information to communicate with model workers\n\n        Returns\n        -------\n        ModelHandle\n            Handle for created model object in database\n        \"\"\"\n        # Create object handle and store it in database before returning it\n        obj = ModelHandle(model_id, properties, parameters, outputs, connector)\n        self.insert_object(obj)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_dict(self, model):\n        # Get the basic Json object from the super class\n        obj = super(ModelRegistry, self).to_dict(model)\n        # Add model parameter\n        obj['parameters'] = [\n            para.to_dict() for para in model.parameters\n        ]\n        obj['outputs'] = model.outputs.to_dict()\n        obj['connector'] = model.connector\n        return obj", "response": "Create a dictionary serialization for a model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_connector(self, model_id, connector):\n        model = self.get_model(model_id)\n        if model is None:\n            return None\n        model.connector = connector\n        self.replace_object(model)\n        return model", "response": "Updates the connector information for a given model."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts parameter names from snake_case to camelCase.", "response": "def _snake_to_camel(name, strict=False):\n    \"\"\"Converts parameter names from snake_case to camelCase.\n\n    Args:\n        name, str. Snake case.\n        strict: bool, default True. If True, will set name to lowercase before\n            converting, otherwise assumes original name is proper camel case.\n            Set to False if name may already be in camelCase.\n\n    Returns:\n        str: CamelCase.\n    \"\"\"\n    if strict:\n        name = name.lower()\n    terms = name.split('_')\n    return terms[0] + ''.join([term.capitalize() for term in terms[1:]])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset default attributes when None.", "response": "def _set_default_attr(self, default_attr):\n        \"\"\"Sets default attributes when None.\n\n        Args:\n            default_attr: dict. Key-val of attr, default-value.\n        \"\"\"\n        for attr, val in six.iteritems(default_attr):\n            if getattr(self, attr, None) is None:\n                setattr(self, attr, val)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nserializing this object as JSON.", "response": "def to_json(self, drop_null=True, camel=False, indent=None, sort_keys=False):\n        \"\"\"Serialize self as JSON\n\n        Args:\n            drop_null: bool, default True. Remove 'empty' attributes. See\n                to_dict.\n            camel: bool, default True. Convert keys to camelCase.\n            indent: int, default None. See json built-in.\n            sort_keys: bool, default False. See json built-in.\n\n        Return:\n            str: object params.\n        \"\"\"\n        return json.dumps(self.to_dict(drop_null, camel), indent=indent,\n                          sort_keys=sort_keys)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_dict(self, drop_null=True, camel=False):\n        #return _to_dict(self, drop_null, camel)\n        def to_dict(obj, drop_null, camel):\n            \"\"\"Recursively constructs the dict.\"\"\"\n            if isinstance(obj, (Body, BodyChild)):\n                obj = obj.__dict__\n            if isinstance(obj, dict):\n                data = {}\n                for attr, val in six.iteritems(obj):\n                    if camel:\n                        attr = _snake_to_camel(attr)\n                    valid_null = (isinstance(val, bool) or val == 0 or\n                                  (val and to_dict(val, drop_null, camel)))\n                    if not drop_null or (drop_null and valid_null):\n                        data[attr] = to_dict(val, drop_null, camel)\n                return data\n            elif isinstance(obj, list):\n                data = []\n                for val in obj:\n                    valid_null = (isinstance(val, bool) or val == 0 or\n                                  (val and to_dict(val, drop_null, camel)))\n                    if not drop_null or (drop_null and valid_null):\n                        data.append(to_dict(val, drop_null, camel))\n                return data\n            else:\n                return obj\n        return to_dict(self, drop_null, camel)", "response": "Serialize this object as a dict."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the JSON request body and store content in object attributes.", "response": "def parse(self, body):\n        \"\"\"Parse JSON request, storing content in object attributes.\n\n        Args:\n            body: str. HTTP request body.\n\n        Returns:\n            self\n        \"\"\"\n        if isinstance(body, six.string_types):\n            body = json.loads(body)\n\n        # version\n        version = body['version']\n        self.version = version\n\n        # session\n        session = body['session']\n        self.session.new = session['new']\n        self.session.session_id = session['sessionId']\n        application_id = session['application']['applicationId']\n        self.session.application.application_id = application_id\n        if 'attributes' in session and session['attributes']:\n            self.session.attributes = session.get('attributes', {})\n        else:\n            self.session.attributes = {}\n        self.session.user.user_id = session['user']['userId']\n        self.session.user.access_token = session['user'].get('accessToken', 0)\n\n        # request\n        request = body['request']\n\n        # launch request\n        if request['type'] == 'LaunchRequest':\n            self.request = LaunchRequest()\n\n        # intent request\n        elif request['type'] == 'IntentRequest':\n            self.request = IntentRequest()\n            self.request.intent = Intent()\n            intent = request['intent']\n            self.request.intent.name = intent['name']\n            if 'slots' in intent and intent['slots']:\n                for name, slot in six.iteritems(intent['slots']):\n                    self.request.intent.slots[name] = Slot()\n                    self.request.intent.slots[name].name = slot['name']\n                    self.request.intent.slots[name].value = slot.get('value')\n\n        # session ended request\n        elif request['type'] == 'SessionEndedRequest':\n            self.request = SessionEndedRequest()\n            self.request.reason = request['reason']\n\n        # common - keep after specific requests to prevent param overwrite\n        self.request.type = request['type']\n        self.request.request_id = request['requestId']\n        self.request.timestamp = request['timestamp']\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_speech_text(self, text):\n        self.response.outputSpeech.type = 'PlainText'\n        self.response.outputSpeech.text = text", "response": "Set response output speech as plain text type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting response output speech as SSML type.", "response": "def set_speech_ssml(self, ssml):\n        \"\"\"Set response output speech as SSML type.\n\n        Args:\n            ssml: str. Response speech used when type is 'SSML', should be formatted\n                with Speech Synthesis Markup Language. Cannot exceed 8,000\n                characters.\n        \"\"\"\n        self.response.outputSpeech.type = 'SSML'\n        self.response.outputSpeech.ssml = ssml"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_card_simple(self, title, content):\n        self.response.card.type = 'Simple'\n        self.response.card.title = title\n        self.response.card.content = content", "response": "Set response card as simple type."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset response card as standard type.", "response": "def set_card_standard(self, title, text, smallImageUrl=None,\n                          largeImageUrl=None):\n        \"\"\"Set response card as standard type.\n\n        title, text, and image cannot exceed 8,000 characters.\n\n        Args:\n            title: str. Title of Simple or Standard type card.\n            text: str. Content of Standard type card.\n            smallImageUrl: str. URL of small image. Cannot exceed 2,000\n                characters. Recommended pixel size: 720w x 480h.\n            largeImageUrl: str. URL of large image. Cannot exceed 2,000\n                characters. Recommended pixel size: 1200w x 800h.\n        \"\"\"\n        self.response.card.type = 'Standard'\n        self.response.card.title = title\n        self.response.card.text = text\n        if smallImageUrl:\n            self.response.card.image.smallImageUrl = smallImageUrl\n        if largeImageUrl:\n            self.response.card.image.largeImageUrl = largeImageUrl"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset response reprompt output speech as plain text type.", "response": "def set_reprompt_text(self, text):\n        \"\"\"Set response reprompt output speech as plain text type.\n\n        Args:\n            text: str. Response speech used when type is 'PlainText'. Cannot\n                exceed 8,000 characters.\n        \"\"\"\n        self.response.reprompt.outputSpeech.type = 'PlainText'\n        self.response.reprompt.outputSpeech.text = text"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets response reprompt output speech as SSML type.", "response": "def set_reprompt_ssml(self, ssml):\n        \"\"\"Set response reprompt output speech as SSML type.\n\n        Args:\n            ssml: str. Response speech used when type is 'SSML', should be formatted\n                with Speech Synthesis Markup Language. Cannot exceed 8,000\n                characters.\n        \"\"\"\n        self.response.reprompt.outputSpeech.type = 'SSML'\n        self.response.reprompt.outputSpeech.ssml = ssml"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite a list of lines to the stream.", "response": "def writelines(self, lines):\n        '''\n            Write a list of lines to the stream. Line separators are not added, so it is usual for each of the lines provided to have a line separator at the end.\n        :param lines:\n        '''\n        if self.__closed:\n            raise OSError()\n        for line in lines:\n            self.write(line)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __save(self, b):\n        '''\n            saves the given data to the buffer\n        :param b:\n        '''\n        newbufferidx = (self.__bufferidx + len(b))\n        self.__buffer[self.__bufferidx:newbufferidx] = b\n        #update buffer index\n        self.__bufferidx = newbufferidx", "response": "Saves the given data to the buffer."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef flush(self):\n        '''\n        Flushes the buffer to socket. Only call when the write is done. Calling flush after each write will prevent the buffer to act as efficiently as possible\n        '''\n        # return if empty\n        if self.__bufferidx == 0:\n            return \n        # send here the data\n        self.conn.send(\"%s\\r\\n\" % hex(self.__bufferidx)[2:])\n        self.conn.send(\"%s\\r\\n\" % ''.join(self.__buffer[0:self.__bufferidx]))\n        # reset buffer index = 0 (beginning of the buffer)\n        self.__bufferidx = 0", "response": "Flushes the buffer to socket. Only call when the write is done."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef close(self):\n        '''\n        Closes the stream to output. It destroys the buffer and the buffer pointer. However, it will not close the the client connection\n        '''\n        #write all that is remained in buffer\n        self.flush()\n        # delete buffer\n        self.__buffer = None\n        #reset buffer index to -1 to indicate no where\n        self.__bufferidx = -1\n        #writing the final empty chunk to the socket\n        # send here the data\n        self.conn.send(\"0\\r\\n\")\n        self.conn.send(\"\\r\\n\" )\n        #set closed flag\n        self.__closed = True", "response": "Closes the stream to output. It destroys the buffer and the buffer pointer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating UI elements and connect signals.", "response": "def create_ui(self):\n        '''\n        Create UI elements and connect signals.\n        '''\n        box = Gtk.Box()\n        rotate_left = Gtk.Button('Rotate left')\n        rotate_right = Gtk.Button('Rotate right')\n        flip_horizontal = Gtk.Button('Flip horizontal')\n        flip_vertical = Gtk.Button('Flip vertical')\n        reset = Gtk.Button('Reset')\n        load = Gtk.Button('Load...')\n        save = Gtk.Button('Save...')\n\n        rotate_left.connect('clicked', lambda *args: self.rotate_left())\n        rotate_right.connect('clicked', lambda *args: self.rotate_right())\n        flip_horizontal.connect('clicked', lambda *args:\n                                self.flip_horizontal())\n        flip_vertical.connect('clicked', lambda *args: self.flip_vertical())\n        reset.connect('clicked', lambda *args: self.reset())\n        load.connect('clicked', lambda *args: GObject.idle_add(self.load))\n        save.connect('clicked', lambda *args: GObject.idle_add(self.save))\n\n        for b in (rotate_left, rotate_right, flip_horizontal, flip_vertical,\n                  reset, load, save):\n            box.pack_start(b, False, False, 0)\n\n        box.show_all()\n        self.widget.pack_start(box, False, False, 0)\n\n        if self.warp_actor.parent_corners is None:\n            for b in (rotate_left, rotate_right, flip_horizontal,\n                      flip_vertical, reset, load, save):\n                b.set_sensitive(False)\n            def check_init():\n                if self.warp_actor.parent_corners is not None:\n                    for b in (rotate_left, rotate_right, flip_horizontal,\n                              flip_vertical, reset, load, save):\n                        b.set_sensitive(True)\n                    return False\n                return True\n            GObject.timeout_add(100, check_init)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self):\n        '''\n        Save warp projection settings to HDF file.\n        '''\n        response = pu.open(title='Save perspective warp', patterns=['*.h5'])\n        if response is not None:\n            self.warp_actor.save(response)", "response": "Save warp projection settings to HDF file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading warp projection settings from HDF file.", "response": "def load(self):\n        '''\n        Load warp projection settings from HDF file.\n        '''\n        response = pu.open(title='Load perspective warp', patterns=['*.h5'])\n        if response is not None:\n            self.warp_actor.load(response)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef transaction_manager(fn):\n    @wraps(fn)\n    def transaction_manager_decorator(*args, **kwargs):\n        with transaction.manager:\n            return fn(*args, **kwargs)\n\n    return transaction_manager_decorator", "response": "Decorator which wraps whole function into transaction. manager."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef simple_logger(**kwargs):\n    # Args\n    logger_name = kwargs.get('name')\n    base_level = kwargs.get('base_level', logging.DEBUG)\n\n    should_stdout = kwargs.get('should_stdout', True)\n\n    should_http = kwargs.get('should_http', False)\n\n    # Generate base logger\n    logger = logging.getLogger(logger_name)\n    logger.setLevel(base_level)\n\n    # Define stdout handler\n    if should_stdout:\n        logger.addHandler(_add_stream_handler(**kwargs))\n\n    if should_http:\n        logger.addHandler(_add_http_handler(**kwargs))\n    return logger", "response": "Creates a simple logger with the given name and base level"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compare_dicts(d1, d2):\n    a = json.dumps(d1, indent=4, sort_keys=True)\n    b = json.dumps(d2, indent=4, sort_keys=True)\n    # stolen from cpython\n    # https://github.com/python/cpython/blob/01fd68752e2d2d0a5f90ae8944ca35df0a5ddeaa/Lib/unittest/case.py#L1091\n    diff = ('\\n' + '\\n'.join(difflib.ndiff(\n                   a.splitlines(),\n                   b.splitlines())))\n    return diff", "response": "Returns a diff string of the two dicts."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntake an object and makes it stringy", "response": "def stringer(x):\n    \"\"\"\n    Takes an object and makes it stringy\n    >>> print(stringer({'a': 1, 2: 3, 'b': [1, 'c', 2.5]}))\n    {'b': ['1', 'c', '2.5'], 'a': '1', '2': '3'}\n    \"\"\"\n    if isinstance(x, string_types):\n        return x\n    if isinstance(x, (list, tuple)):\n        return [stringer(y) for y in x]\n    if isinstance(x, dict):\n        return dict((stringer(a), stringer(b)) for a, b in x.items())\n    return text_type(x)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef diff_analysis(using):\n    python_analysis = collect_analysis(using)\n    es_analysis = existing_analysis(using)\n    return compare_dicts(es_analysis, python_analysis)", "response": "Returns a diff string of the analysis defined in ES and with\n    the analysis defined in Python land for the connection using"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef collect_analysis(using):\n    python_analysis = defaultdict(dict)\n    for index in registry.indexes_for_connection(using):\n        python_analysis.update(index._doc_type.mapping._collect_analysis())\n\n    return stringer(python_analysis)", "response": "collect the analysis settings from the Python land\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the existing analysis for the Elasticsearch connection", "response": "def existing_analysis(using):\n    \"\"\"\n    Get the existing analysis for the `using` Elasticsearch connection\n    \"\"\"\n    es = connections.get_connection(using)\n    index_name = settings.ELASTICSEARCH_CONNECTIONS[using]['index_name']\n    if es.indices.exists(index=index_name):\n        return stringer(es.indices.get_settings(index=index_name)[index_name]['settings']['index'].get('analysis', {}))\n    return DOES_NOT_EXIST"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_analysis_compatible(using):\n    python_analysis = collect_analysis(using)\n    es_analysis = existing_analysis(using)\n    if es_analysis == DOES_NOT_EXIST:\n        return True\n\n    # we want to ensure everything defined in Python land is exactly matched in ES land\n    for section in python_analysis:\n        # there is an analysis section (analysis, tokenizers, filters, etc) defined in Python that isn't in ES\n        if section not in es_analysis:\n            return False\n\n        # for this section of analysis (analysis, tokenizer, filter, etc), get\n        # all the items defined in that section, and make sure they exist, and\n        # are equal in Python land\n        subdict_python = python_analysis[section]\n        subdict_es = es_analysis[section]\n        for name in subdict_python:\n            # this analyzer, filter, etc isn't defined in ES\n            if name not in subdict_es:\n                return False\n            # this analyzer, filter etc doesn't match what is in ES\n            if subdict_python[name] != subdict_es[name]:\n                return False\n\n    return True", "response": "Returns True if the analysis defined in Python land and ES for the connection using is compatible with the current connection."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef combined_analysis(using):\n    python_analysis = collect_analysis(using)\n    es_analysis = existing_analysis(using)\n    if es_analysis == DOES_NOT_EXIST:\n        return python_analysis\n\n    # we want to ensure everything defined in Python land is added, or\n    # overrides the things defined in ES\n    for section in python_analysis:\n        if section not in es_analysis:\n            es_analysis[section] = python_analysis[section]\n\n        subdict_python = python_analysis[section]\n        subdict_es = es_analysis[section]\n        for name in subdict_python:\n            subdict_es[name] = subdict_python[name]\n\n    return es_analysis", "response": "Combine the analysis in ES with the analysis defined in Python."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats the response to be consumeable by flask.", "response": "def flaskify(response, headers=None, encoder=None):\n    \"\"\"Format the response to be consumeable by flask.\n\n    The api returns mostly JSON responses. The format method converts the dicts\n    into a json object (as a string), and the right response is returned (with\n    the valid mimetype, charset and status.)\n\n    Args:\n        response (Response): The dictionary object to convert into a json\n            object. If the value is a string, a dictionary is created with the\n            key \"message\".\n        headers (dict): optional headers for the flask response.\n        encoder (Class): The class of the encoder (if any).\n\n    Returns:\n        flask.Response: The flask response with formatted data, headers, and\n            mimetype.\n    \"\"\"\n\n    status_code = response.status\n    data = response.errors or response.message\n\n    mimetype = 'text/plain'\n    if isinstance(data, list) or isinstance(data, dict):\n        mimetype = 'application/json'\n        data = json.dumps(data, cls=encoder)\n\n    return flask.Response(\n        response=data, status=status_code, headers=headers, mimetype=mimetype)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef stop(self):\n        if hasattr(self, 'process'):\n            if self.process is not None:\n                try:\n                    is_running = self.process.poll() is None\n                except AttributeError:\n                    is_running = False\n\n                if is_running:\n                    self.bundle_engine.logline(\"Stopping {0}\".format(self.service.name))\n                    self.term_signal_sent = True\n\n                    # Politely ask all child processes to die first\n                    try:\n                        for childproc in psutil.Process(self.process.pid).children(recursive=True):\n                            childproc.send_signal(signal.SIGINT)\n                    except psutil.NoSuchProcess:\n                        pass\n                    except AttributeError:\n                        pass\n\n                    try:\n                        self.process.send_signal(self.service.stop_signal)\n                    except OSError as e:\n                        if e.errno == 3:        # No such process\n                            pass\n                else:\n                    self.bundle_engine.warnline(\"{0} stopped prematurely.\".format(self.service.name))\n            else:\n                self.bundle_engine.warnline(\"{0} stopped prematurely.\".format(self.service.name))\n        else:\n            self.bundle_engine.warnline(\"{0} was never successfully started.\".format(self.service.name))", "response": "Ask politely first with SIGINT and SIGQUIT."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nkills the child processes of this service.", "response": "def kill(self):\n        \"\"\"Murder the children of this service in front of it, and then murder the service itself.\"\"\"\n        if not self.is_dead():\n            self.bundle_engine.warnline(\"{0} did not shut down cleanly, killing.\".format(self.service.name))\n            try:\n                if hasattr(self.process, 'pid'):\n                    for child in psutil.Process(self.process.pid).children(recursive=True):\n                        os.kill(child.pid, signal.SIGKILL)\n                    self.process.kill()\n            except psutil.NoSuchProcess:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tempkeys(self):\r\n    self.levels.append(dict(self.levels[-1]))\r\n    try: yield\r\n    finally: self.levels.pop()", "response": "A context manager that creates a new level to make new keys temporary. Used to copy in sqex."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(self, ex):\r\n    \"helper for apply_sql in CreateX case\"\r\n    if ex.name in self:\r\n      if ex.nexists: return\r\n      raise ValueError('table_exists',ex.name)\r\n    if any(c.pkey for c in ex.cols):\r\n      if ex.pkey:\r\n        raise sqparse2.SQLSyntaxError(\"don't mix table-level and column-level pkeys\",ex)\r\n      # todo(spec): is multi pkey permitted when defined per column?\r\n      ex.pkey = sqparse2.PKeyX([c.name for c in ex.cols if c.pkey])\r\n    if ex.inherits:\r\n      # todo: what if child table specifies constraints etc? this needs work.\r\n      if len(ex.inherits) > 1: raise NotImplementedError('todo: multi-table inherit')\r\n      parent = self[ex.inherits[0]] = copy.deepcopy(self[ex.inherits[0]]) # copy so rollback works\r\n      child = self[ex.name] = table.Table(ex.name, parent.fields, parent.pkey)\r\n      parent.child_tables.append(child)\r\n      child.parent_table = parent\r\n    else:\r\n      self[ex.name]=table.Table(ex.name,ex.cols,ex.pkey.fields if ex.pkey else [])", "response": "helper for apply_sql in CreateX case"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef drop(self, ex):\r\n    \"helper for apply_sql in DropX case\"\r\n    # todo: factor out inheritance logic (for readability)\r\n    if ex.name not in self:\r\n      if ex.ifexists: return\r\n      raise KeyError(ex.name)\r\n    table_ = self[ex.name]\r\n    parent = table_.parent_table\r\n    if table_.child_tables:\r\n      if not ex.cascade:\r\n        raise table.IntegrityError('delete_parent_without_cascade',ex.name)\r\n      self.cascade_delete(ex.name)\r\n    else: del self[ex.name]\r\n    if parent: parent.child_tables.remove(table_)", "response": "helper for apply_sql in DropX case"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef apply_sql(self, ex, values, lockref):\r\n    sqex.depth_first_sub(ex,values)\r\n    with self.lock_db(lockref, isinstance(ex,sqparse2.StartX)):\r\n      sqex.replace_subqueries(ex,self,table.Table)\r\n      if isinstance(ex,sqparse2.SelectX): return sqex.run_select(ex,self,table.Table)\r\n      elif isinstance(ex,sqparse2.InsertX): return self[ex.table].insert(ex.cols,ex.values,ex.ret,self)\r\n      elif isinstance(ex,sqparse2.UpdateX):\r\n        if len(ex.tables)!=1: raise NotImplementedError('multi-table update')\r\n        return self[ex.tables[0]].update(ex.assigns,ex.where,ex.ret,self)\r\n      elif isinstance(ex,sqparse2.CreateX): self.create(ex)\r\n      elif isinstance(ex,sqparse2.IndexX): pass\r\n      elif isinstance(ex,sqparse2.DeleteX): return self[ex.table].delete(ex.where,self)\r\n      elif isinstance(ex,sqparse2.StartX): self.trans_start(lockref)\r\n      elif isinstance(ex,sqparse2.CommitX): self.trans_commit()\r\n      elif isinstance(ex,sqparse2.RollbackX): self.trans_rollback()\r\n      elif isinstance(ex,sqparse2.DropX): self.drop(ex)\r\n      else: raise TypeError(type(ex))", "response": "call the sql statement in tree with values subbed on the tables in t_d."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprepares basic auth headers.", "response": "def _prepare_basicauth(self, username, password):\n        \"\"\"\n        Handles BasicAuth preparation and error handling.  Either both\n        ``username`` and ``password`` must be defined, or neither.  Defining\n        one but not the other will result in an :class:`AssertionError`.\n\n        ``username``\n        ``password``\n\n        Returns a tuple of ``(header_key, header_value)`` which can be inserted\n        into the headers dictionary.\n        \"\"\"\n        if username and password:\n            enc_str = base64.b64encode(\":\".join((username, password)))\n            return (\"Authorization\", \"Basic %s\" % enc_str)\n        elif username or password:\n            raise Exception(\"Username and password must both be specified.\")\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npreparing a full URI with the selected information.", "response": "def _prepare_uri(self, path, query_params={}):\n        \"\"\"\n        Prepares a full URI with the selected information.\n\n        ``path``:\n            Path can be in one of two formats:\n\n                - If :attr:`server` was defined, the ``path`` will be appended\n                  to the existing host, or\n                - an absolute URL\n        ``query_params``:\n            Used to generate a query string, which will be appended to the end\n            of the absolute URL.\n\n        Returns an absolute URL.\n        \"\"\"\n        query_str = urllib.urlencode(query_params)\n\n        # If we have a relative path (as opposed to a full URL), build it of\n        # the connection info\n        if path.startswith('/') and self.server:\n            protocol = self.protocol\n            server = self.server\n        else:\n            protocol, server, path, _, _, _ = urlparse.urlparse(path)\n            assert server, \"%s is not a valid URL\" % path\n\n        return urlparse.urlunparse((\n            protocol, server, path, None, query_str, None))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking a request to the specified URI.", "response": "def _make_request(self, uri, method, body, headers={}):\n        \"\"\"\n        Wraps the response and content returned by :mod:`httplib2` into a\n        :class:`~webunit2.response.HttpResponse` object.\n\n        ``uri``:\n            Absolute URI to the resource.\n        ``method``:\n            Any supported HTTP methods defined in :rfc:`2616`.\n        ``body``:\n            In the case of POST and PUT requests, this can contain the contents\n            of the request.\n        ``headers``:\n            Dictionary of header values to be sent as part of the request.\n\n        Returns a :class:`~webunit2.response.HttpResponse` object containing\n        the request results.\n        \"\"\"\n        response, content = self._httpobj.request(\n            uri, method=method, body=body, headers=headers)\n\n        return HttpResponse(response, content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef retrieve_page(self, method, path, post_params={}, headers={},\n                      status=200, username=None, password=None,\n                      *args, **kwargs):\n        \"\"\"\n        Makes the actual request.  This will also go through and generate the\n        needed steps to make the request, i.e. basic auth.\n\n        ``method``:\n            Any supported HTTP methods defined in :rfc:`2616`.\n        ``path``:\n            Absolute or relative path. See :meth:`_prepare_uri` for more\n            detail.\n        ``post_params``:\n            Dictionary of key/value pairs to be added as `POST` parameters.\n        ``headers``:\n            Dictionary of key/value pairs to be added to the HTTP headers.\n        ``status``:\n            Will error out if the HTTP status code does not match this value.\n            Set this to `None` to disable checking.\n        ``username``, ``password``:\n            Username and password for basic auth; see\n            :meth:`_prepare_basicauth` for more detail.\n\n        An important note is that when ``post_params`` is specified, its\n        behavior depends on the ``method``.  That is, for `PUT` and `POST`\n        requests, the dictionary is multipart encoded and put into the body of\n        the request.  For everything else, it is added as a query string to the\n        URL.\n        \"\"\"\n        # Copy headers so that making changes here won't affect the original\n        headers = headers.copy()\n\n        # Update basic auth information\n        basicauth = self._prepare_basicauth(username, password)\n        if basicauth:\n            headers.update([basicauth])\n\n        # If this is a POST or PUT, we can put the data into the body as\n        # form-data encoded; otherwise, it should be part of the query string.\n        if method in [\"PUT\", \"POST\"]:\n            datagen, form_hdrs = poster.encode.multipart_encode(post_params)\n            body = \"\".join(datagen)\n            headers.update(form_hdrs)\n            uri = self._prepare_uri(path)\n        else:\n            body = \"\"\n            uri = self._prepare_uri(path, post_params)\n\n        # Make the actual request\n        response = self._make_request(uri, method, body, headers)\n\n        # Assert that the status we received was expected.\n        if status:\n            real_status = int(response.status_int)\n            assert real_status == int(status), \\\n                    \"expected %s, received %s.\" % (status, real_status)\n\n        return response", "response": "This method is used to make the actual request to retrieve the page of the specified object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new track token for the given request.", "response": "def create_track_token(request):\n    \"\"\"Returns ``TrackToken``.\n    ``TrackToken' contains request and user making changes.\n\n    It can be passed to ``TrackedModel.save`` instead of ``request``.\n    It is intended to be used when passing ``request`` is not possible\n    e.g. when ``TrackedModel.save`` will be called from celery task.\n    \"\"\"\n    from tracked_model.models import RequestInfo\n    request_pk = RequestInfo.create_or_get_from_request(request).pk\n    user_pk = None\n    if request.user.is_authenticated():\n        user_pk = request.user.pk\n\n    return TrackToken(request_pk=request_pk, user_pk=user_pk)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save(self, *args, **kwargs):\n        from tracked_model.models import History, RequestInfo\n        if self.pk:\n            action = ActionType.UPDATE\n            changes = None\n        else:\n            action = ActionType.CREATE\n            changes = serializer.dump_model(self)\n\n        request = kwargs.pop('request', None)\n        track_token = kwargs.pop('track_token', None)\n\n        super().save(*args, **kwargs)\n        if not changes:\n            changes = self._tracked_model_diff()\n\n        if changes:\n            hist = History()\n            hist.model_name = self._meta.model.__name__\n            hist.app_label = self._meta.app_label\n            hist.table_name = self._meta.db_table\n            hist.table_id = self.pk\n            hist.change_log = serializer.to_json(changes)\n            hist.action_type = action\n            if request:\n                if request.user.is_authenticated():\n                    hist.revision_author = request.user\n                req_info = RequestInfo.create_or_get_from_request(request)\n                hist.revision_request = req_info\n            elif track_token:\n                hist.revision_author_id = track_token.user_pk\n                hist.revision_request_id = track_token.request_pk\n\n            hist.save()\n\n        self._tracked_model_initial_state = serializer.dump_model(self)", "response": "Saves changes made on model instance if request or track_token keyword are provided."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a dictionary of changes made to model instance.", "response": "def _tracked_model_diff(self):\n        \"\"\"Returns changes made to model instance.\n        Returns None if no changes were made.\n        \"\"\"\n        initial_state = self._tracked_model_initial_state\n        current_state = serializer.dump_model(self)\n        if current_state == initial_state:\n            return None\n\n        change_log = {}\n        for field in initial_state:\n            old_value = initial_state[field][Field.VALUE]\n            new_value = current_state[field][Field.VALUE]\n            if old_value == new_value:\n                continue\n            field_data = initial_state.copy()[field]\n            del field_data[Field.VALUE]\n            field_data[Field.OLD] = old_value\n            field_data[Field.NEW] = new_value\n            change_log[field] = field_data\n\n        return change_log or None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a QuerySet of all the history of a tracked object", "response": "def tracked_model_history(self):\n        \"\"\"Returns history of a tracked object\"\"\"\n        from tracked_model.models import History\n        return History.objects.filter(\n            table_name=self._meta.db_table, table_id=self.pk)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreplace placeholders in a file with the values from the mapping.", "response": "def replace_placeholders(path: Path, properties: Dict[str, str]):\n    '''Replace placeholders in a file with the values from the mapping.'''\n\n    with open(path, encoding='utf8') as file:\n        file_content = Template(file.read())\n\n    with open(path, 'w', encoding='utf8') as file:\n        file.write(file_content.safe_substitute(properties))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate(self, document):\n        '''Check if the selected template exists.'''\n\n        template = document.text\n\n        if template not in self.builtin_templates:\n            raise ValidationError(\n                message=f'Template {template} not found. '\n                + f'Available templates are: {\", \".join(self.builtin_templates)}.',\n                cursor_position=0\n            )", "response": "Check if the selected template exists."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef init(self, project_name='', template='base', quiet=False, debug=False):\n        '''Generate new Foliant project.'''\n\n        self.logger.setLevel(DEBUG if debug else WARNING)\n\n        self.logger.info('Project creation started.')\n\n        self.logger.debug(f'Template: {template}')\n\n        template_path = Path(template)\n\n        if not template_path.exists():\n            self.logger.debug(\n                f'Template not found in {template_path}, looking in installed templates.'\n            )\n\n            installed_templates_path = Path(Path(__file__).parent / 'templates')\n\n            installed_templates = [\n                item.name for item in installed_templates_path.iterdir() if item.is_dir()\n            ]\n\n            self.logger.debug(f'Available templates: {installed_templates}')\n\n            if template in installed_templates:\n                self.logger.debug('Template found.')\n\n            else:\n                self.logger.debug('Template not found, asking for user input.')\n\n                try:\n                    template = prompt(\n                        f'Please pick a template from {installed_templates}: ',\n                        completer=WordCompleter(installed_templates),\n                        validator=BuiltinTemplateValidator(installed_templates)\n                    )\n\n                except KeyboardInterrupt:\n                    self.logger.warning('Project creation interrupted.')\n                    return\n\n            template_path = installed_templates_path / template\n\n            self.logger.debug(f'Template path: {template_path}')\n\n        if not project_name:\n            self.logger.debug('Project name not specified, asking for user input.')\n\n            try:\n                project_name = prompt('Enter the project name: ')\n\n            except KeyboardInterrupt:\n                self.logger.warning('Project creation interrupted.')\n                return\n\n        project_slug = slugify(project_name)\n        project_path = Path(project_slug)\n\n        properties = {\n            'title': project_name,\n            'slug': project_slug\n        }\n\n        self.logger.debug(f'Project properties: {properties}')\n\n        result = None\n\n        with spinner('Generating project', self.logger, quiet, debug):\n            copytree(template_path, project_path)\n\n            text_types = '*.md', '*.yml', '*.txt', '*.py'\n\n            text_file_paths = reduce(\n                lambda acc, matches: acc + [*matches],\n                (project_path.rglob(text_type) for text_type in text_types),\n                []\n            )\n\n            for text_file_path in text_file_paths:\n                self.logger.debug(f'Processing content of {text_file_path}')\n                replace_placeholders(text_file_path, properties)\n\n            for item in project_path.rglob('*'):\n                self.logger.debug(f'Processing name of {item}')\n                item.rename(Template(item.as_posix()).safe_substitute(properties))\n\n            result = project_path\n\n        if result:\n            self.logger.info(f'Result: {result}')\n\n            if not quiet:\n                print('\u2500' * 20)\n                print(f'Project \"{project_name}\" created in {result}')\n            else:\n                print(result)\n\n        else:\n            self.logger.critical('Project creation failed.')\n            exit(1)", "response": "Generate a new Foliant project."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_start_of_line(self):\n        if self.newline in ('\\r', '\\n', '\\r\\n'):\n            return self.buf.rfind(self.newline.encode('ascii'), 0, -1) + 1\n        if self.newline:\n            raise ValueError(r\"ropen newline argument must be one of \"\n                             r\"None, '', '\\r', '\\n', '\\r\\n'.\")\n\n        # self.newline is None or ''; universal newlines mode\n        end_of_search = -1\n        if len(self.buf) >= 2 and self.buf[-2:] == b'\\r\\n':\n            end_of_search = -2\n        return max(self.buf.rfind(b'\\n', 0, end_of_search),\n                   self.buf.rfind(b'\\r', 0, end_of_search)) + 1", "response": "Return the index of the first line stored in self. buf."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads next line into the buffer.", "response": "def read_next_into_buf(self):\n        \"\"\"Read data from the file in self.bufsize chunks until we're\n           certain we have a full line in the buffer.\n        \"\"\"\n        file_pos = self.fileobject.tell()\n        if (file_pos == 0) and (self.buf == b''):\n            raise StopIteration\n        while file_pos and (self.get_start_of_line() == 0):\n            bytes_to_read = min(self.bufsize, file_pos)\n            file_pos = file_pos - bytes_to_read\n            self.fileobject.seek(file_pos)\n            new_stuff = self.fileobject.read(bytes_to_read)[:bytes_to_read]\n            self.fileobject.seek(file_pos)\n            self.buf = new_stuff + self.buf"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse ISO 8601 time zone specs into tzinfo offsets", "response": "def parse_timezone(tzstring, default_timezone=UTC):\n    \"\"\"Parses ISO 8601 time zone specs into tzinfo offsets\n    \n    \"\"\"\n    if tzstring == \"Z\":\n        return default_timezone\n    # This isn't strictly correct, but it's common to encounter dates without\n    # timezones so I'll assume the default (which defaults to UTC).\n    # Addresses issue 4.\n    if tzstring is None:\n        return default_timezone\n    m = TIMEZONE_REGEX.match(tzstring)\n    prefix, hours, minutes = m.groups()\n    hours, minutes = int(hours), int(minutes)\n    if prefix == \"-\":\n        hours = -hours\n        minutes = -minutes\n    return FixedOffset(hours, minutes, tzstring)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing ISO 8601 dates into a datetime object.", "response": "def parse_date(datestring, default_timezone=UTC):\n    \"\"\"Parses ISO 8601 dates into datetime objects\n    \n    The timezone is parsed from the date string. However it is quite common to\n    have dates without a timezone (not strictly correct). In this case the\n    default timezone specified in default_timezone is used. This is UTC by\n    default.\n    \"\"\"\n    if not isinstance(datestring, basestring):\n        raise ParseError(\"Expecting a string %r\" % datestring)\n    m = ISO8601_REGEX.match(datestring)\n    if not m:\n        raise ParseError(\"Unable to parse date string %r\" % datestring)\n    groups = m.groupdict()\n    tz = parse_timezone(groups[\"timezone\"], default_timezone=default_timezone)\n    if groups[\"fraction\"] is None:\n        groups[\"fraction\"] = 0\n    else:\n        groups[\"fraction\"] = int(float(\"0.%s\" % groups[\"fraction\"]) * 1e6)\n        \n    if groups[\"hour\"] == None and groups[\"minute\"] == None and groups[\"second\"] == None:\n        return datetime(int(groups[\"year\"]), int(groups[\"month\"]), int(groups[\"day\"]), tzinfo=tz)\n    else:\n        return datetime(int(groups[\"year\"]), int(groups[\"month\"]), int(groups[\"day\"]),\n            int(groups[\"hour\"]), int(groups[\"minute\"]), int(groups[\"second\"]),\n            int(groups[\"fraction\"]), tz)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding item to db under index. If index is not in db create it using default.", "response": "def _add_to(self, db, index, item, default=OOSet):\n        \"\"\"\n        Add `item` to `db` under `index`. If `index` is not yet in `db`, create\n        it using `default`.\n\n        Args:\n            db (dict-obj): Dict-like object used to connect to database.\n            index (str): Index used to look in `db`.\n            item (obj): Persistent object, which may be stored in DB.\n            default (func/obj): Reference to function/object, which will be\n                used to create the object under `index`.\n                Default :class:`OOSet`.\n        \"\"\"\n        row = db.get(index, None)\n\n        if row is None:\n            row = default()\n            db[index] = row\n\n        row.add(item)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_tree(self, tree, parent=None):\n        if tree.path in self.path_db:\n            self.remove_tree_by_path(tree.path)\n\n        # index all indexable attributes\n        for index in tree.indexes:\n            if not getattr(tree, index):\n                continue\n\n            self._add_to(\n                getattr(self, index + \"_db\"),\n                getattr(tree, index),\n                tree,\n            )\n\n        if parent:\n            self._add_to(self.parent_db, tree.path, parent)\n\n        # make sure, that all sub-trees starts with path of parent tree\n        for sub_tree in tree.sub_trees:\n            assert sub_tree.path.startswith(tree.path)\n\n        for sub_tree in tree.sub_trees:\n            self.add_tree(sub_tree, parent=tree)", "response": "Adds tree into database."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the tree from database by given path.", "response": "def remove_tree_by_path(self, path):\n        \"\"\"\n        Remove the tree from database by given `path`.\n\n        Args:\n            path (str): Path of the tree.\n        \"\"\"\n        with transaction.manager:\n            trees = self.path_db.get(path, None)\n\n        if not trees:\n            return\n\n        for tree in trees:\n            return self._remove_tree(tree)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _remove_from(self, db, index, item):\n        with transaction.manager:\n            row = db.get(index, None)\n\n        if row is None:\n            return\n\n        with transaction.manager:\n            if item in row:\n                row.remove(item)\n\n        with transaction.manager:\n            if not row:\n                del db[index]", "response": "Removes item from db at index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching trees by issn.", "response": "def trees_by_issn(self, issn):\n        \"\"\"\n        Search trees by `issn`.\n\n        Args:\n            issn (str): :attr:`.Tree.issn` property of :class:`.Tree`.\n\n        Returns:\n            set: Set of matching :class:`Tree` instances.\n        \"\"\"\n        return set(\n            self.issn_db.get(issn, OOSet()).keys()\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches trees by path.", "response": "def trees_by_path(self, path):\n        \"\"\"\n        Search trees by `path`.\n\n        Args:\n            path (str): :attr:`.Tree.path` property of :class:`.Tree`.\n\n        Returns:\n            set: Set of matching :class:`Tree` instances.\n        \"\"\"\n        return set(\n            self.path_db.get(path, OOSet()).keys()\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches trees by sub_path using Tree. path. startswith ( sub_path comparison.", "response": "def trees_by_subpath(self, sub_path):\n        \"\"\"\n        Search trees by `sub_path` using ``Tree.path.startswith(sub_path)``\n        comparison.\n\n        Args:\n            sub_path (str): Part of the :attr:`.Tree.path` property of\n                :class:`.Tree`.\n\n        Returns:\n            set: Set of matching :class:`Tree` instances.\n        \"\"\"\n        matches = (\n            self.path_db[tree_path].keys()\n            for tree_path in self.path_db.iterkeys()\n            if tree_path.startswith(sub_path)\n        )\n\n        return set(sum(matches, []))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget parent for given tree or alternative value.", "response": "def get_parent(self, tree, alt=None):\n        \"\"\"\n        Get parent for given `tree` or `alt` if not found.\n\n        Args:\n            tree (obj): :class:`.Tree` instance, which is already stored in DB.\n            alt (obj, default None): Alternative value returned when `tree` is\n                not found.\n\n        Returns:\n            obj: :class:`.Tree` parent to given `tree`.\n        \"\"\"\n        parent = self.parent_db.get(tree.path)\n\n        if not parent:\n            return alt\n\n        return list(parent)[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef yearfrac_365q(d1, d2):\n\n    # import modules\n    from datetime import date\n    from oxyba import date_to_datetime\n\n    # define yearfrac formula\n    # toyf = lambda a,b: (a - b).days / 365.2425\n    def toyf(a, b):\n        a = date_to_datetime(a) if isinstance(a, date) else a\n        b = date_to_datetime(b) if isinstance(b, date) else b\n        return (a - b).days / 365.2425\n\n    # deal with scalars and vectors\n    n1 = len(d1) if hasattr(d1, \"__iter__\") else 1\n    n2 = len(d2) if hasattr(d2, \"__iter__\") else 1\n\n    # compute yearfrac\n    if n1 == 1 and n2 == 1:\n        return toyf(d1, d2)\n    elif n1 > 1 and n2 == 1:\n        return [toyf(elem, d2) for elem in d1]\n    elif n1 == 1 and n2 > 1:\n        return [toyf(d1, elem) for elem in d2]\n    elif n1 > 1 and n1 == n2:\n        return [toyf(e1, e2) for e1, e2 in zip(d1, d2)]\n    else:\n        raise Exception(\"d1 and d2 have the wrong dimensions.\")", "response": "date difference d1 - d2 as year fractional"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a symbolic link to the Dynamic Number list.", "response": "def add(self, name, value, unit=None):\n        \"\"\"Add symbolic link to Dynamic Number list.\n\n        name  -- name of the symbolic link\n        value -- value of the link (if not a string, conversion is done with str())\n        unit  -- if value is a numerical value, a unit can be added to invoke the \\unit{}{} LaTeX command\n        \"\"\"\n        # check if unit provided\n        if unit is not None:\n            add_unit = True\n            unit = str(unit)\n        else:\n            add_unit = False\n\n        # convert value to string\n        value = str(value)\n\n        # write to file\n        f = open(self.file_dir, 'a')\n        if add_unit:\n            f.write(\"\\\\pgfkeys{dynamicnumber/%s/%s = \\unit{%s}{%s}}\\n\" % (self.name, name, value, unit))\n        else:\n            f.write(\"\\\\pgfkeys{dynamicnumber/%s/%s = %s}\\n\" % (self.name, name, value))\n        f.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef retry_and_reset(fn):\n    @wraps(fn)\n    def retry_and_reset_decorator(*args, **kwargs):\n        obj = kwargs.get(\"self\", None)\n\n        if not obj:\n            obj = args[0]\n\n        try:\n            return fn(*args, **kwargs)\n        except ConnectionStateError:\n            obj._on_close_callback()\n\n        return fn(*args, **kwargs)\n\n    return retry_and_reset_decorator", "response": "Decorator used to make sure that an operation on ZEO object will be retried and reset the ZEO object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _open_connection(self):\n        if self._connection:\n            try:\n                self._connection.close()\n            except Exception:\n                pass\n\n        db = self._get_db()\n        self._connection = db.open()\n\n        self._connection.onCloseCallback(self._on_close_callback)", "response": "Open the connection to the database based on the configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the ZEO root object.", "response": "def _init_zeo_root(self, attempts=3):\n        \"\"\"\n        Get and initialize the ZEO root object.\n\n        Args:\n            attempts (int, default 3): How many times to try, if the connection\n                was lost.\n        \"\"\"\n        try:\n            db_root = self._connection.root()\n        except ConnectionStateError:\n            if attempts <= 0:\n                raise\n\n            self._open_connection()\n            return self._init_zeo_root(attempts=attempts-1)\n\n        # init the root, if it wasn't already declared\n        if self.project_key and self.project_key not in db_root:\n            with transaction.manager:\n                db_root[self.project_key] = self.default_type()\n\n        self._root = db_root[self.project_key] if self.project_key else db_root"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setup_logger(cls):\n\t\tif WAppsGlobals.log is None:\n\t\t\tWAppsGlobals.log = logging.getLogger(\"wasp-launcher\")\n\t\t\tformatter = logging.Formatter(\n\t\t\t\t'[%(name)s] [%(threadName)s] [%(levelname)s] [%(asctime)s] %(message)s',\n\t\t\t\t'%Y-%m-%d %H:%M:%S'\n\t\t\t)\n\t\t\tWLogApp.__log_handler__ = logging.StreamHandler(sys.stdout)\n\t\t\tWLogApp.__log_handler__.setFormatter(formatter)\n\t\t\tWAppsGlobals.log.addHandler(WLogApp.__log_handler__)\n\t\t\tWAppsGlobals.log.setLevel(logging.INFO)", "response": "Initialize :attr:`wasp_launcher.apps.WAppsGlobals.log` log.\n\n\t\t:return: None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_dataclass_loader(cls, registry, field_getters):\n    fields = cls.__dataclass_fields__\n    item_loaders = map(registry, map(attrgetter('type'), fields.values()))\n    getters = map(field_getters.__getitem__, fields)\n    loaders = list(starmap(compose, zip(item_loaders, getters)))\n\n    def dloader(obj):\n        return cls(*(g(obj) for g in loaders))\n\n    return dloader", "response": "create a loader for a dataclass type"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef num_choice(choices, default='1', valid_keys='', depth=1, icons='', sn_info=None,\n               indent=4, fg_color='green', separator='',\n               with_img=6, img_list=None, img_cache_dir='/tmp', use_cache=False,\n               extra_hints='', clear_previous=False, quit_app=True,\n               ):\n    \"\"\"\n        \u4f20\u5165\u6570\u7ec4, \u751f\u6210\u5f85\u9009\u62e9\u5217\u8868, \u5982\u679c\u542f\u7528\u56fe\u7247\u652f\u6301, \u9700\u8981\u989d\u5916\u4f20\u5165\u4e0e\u6570\u7ec4\u6392\u5e8f\u4e00\u81f4\u7684\u56fe\u7247\u5217\u8868,\n        - \u56fe\u7247\u5728 iterms \u4e2d\u663e\u793a\u901f\u5ea6\u8f83\u6162, \u4e0d\u63a8\u8350\u4f7f\u7528\n\n        .. note: \u56fe\u7247\u5728 iterms \u4e2d\u663e\u793a\u901f\u5ea6\u8f83\u6162, \u5982\u679c\u6570\u7ec4\u957f\u5ea6\u5927\u4e8e10, \u4e0d\u63a8\u8350\u4f7f\u7528\n\n        .. code:: python\n\n            sn_info = {\n                'align': '-', # \u5de6\u53f3\u5bf9\u9f50\n                'length': 2, # \u663e\u793a\u957f\u5ea6\n            }\n\n    :param use_cache:\n    :type use_cache:\n    :param default:\n    :type default:\n    :param indent: ``\u5de6\u4fa7\u7a7a\u767d``\n    :type indent:\n    :param fg_color: ``\u524d\u666f\u8272``\n    :type fg_color:\n    :param choices: \u5907\u9009\u9009\u9879\n    :type choices: list\n    :param depth: ``\u5982\u679c\u662f\u5d4c\u5957\u6570\u7ec4, \u663e\u793a\u5f53\u524d\u5c42\u7ea7``\n    :type depth: int\n    :param icons: ``\u9ed8\u8ba4\u5c55\u793a\u7684icons:  '\u2776\u2777\u2778\u2779\u277a\u277b\u277c\u277d\u277e\u277f'``\n    :type icons: any\n    :param sn_info: ``\u9700\u8981\u5c55\u793a\u7684\u5e8f\u53f7\u7684\u4fe1\u606f\u957f\u5ea6\u5bf9\u9f50\u65b9\u5f0f, \u9ed8\u8ba42\u4e2a\u5b57\u7b26/\u53f3\u5bf9\u9f50``\n    :type sn_info: dict\n    :param valid_keys: ``\u53ef\u4ee5\u8f93\u5165\u7684\u6709\u6548 key, \u4f7f\u7528 ',' \u5206\u9694``\n    :type valid_keys: str\n    :param separator: \u5206\u9694\u7b26 header/footer, \u9ed8\u8ba4\u65e0, \u5982\u679c\u4e0d\u4e3a\u7a7a, \u5219\u663e\u793a\n    :type separator:\n    :param img_cache_dir:  ``\u56fe\u7247\u7f13\u5b58\u76ee\u5f55``\n    :type img_cache_dir: str\n    :param with_img: ``\u662f\u5426\u4f7f\u7528\u56fe\u7247, \u5982\u679c\u503c\u5927\u4e8e0, \u5219\u4ee5\u5b9e\u9645\u503c\u5927\u5c0f\u6765\u4f5c\u4e3a\u7ec8\u7aef\u663e\u793a\u884c\u6570``\n    :type with_img: int\n    :param img_list: ``\u56fe\u7247\u539f\u59cb url ``\n    :type img_list: list\n    :param extra_hints: ``n-next,p-prev,s-skip``\n    :type extra_hints: any\n    :param clear_previous: ``clear previous output``\n    :type clear_previous:\n    :return:\n    :rtype:\n    \"\"\"\n    icons = ICONS if not icons else icons\n    if not choices:\n        return None\n\n    # warn: \u8fd9\u91cc\u9700\u8981\u4f7f\u7528 None, \u4e0d\u80fd not default \u6765\u5224\u65ad!!!, \u4f1a\u53ef\u80fd\u4f20\u5165 0\n    if default is not None:\n        default = '{}'.format(default)\n\n    sn_info = sn_info or {}\n    _header, _footer = gen_separator(separator=separator)\n\n    with textui.indent(indent, quote=' {}'.format(icons[depth - 1])):\n        if _header:\n            textui.puts(getattr(textui.colored, fg_color)(_header))\n\n        for i, choice in enumerate(choices, start=1):\n            if with_img > 0 and img_list:\n                cat_net_img(img_list[i - 1],\n                            indent=indent,\n                            img_height=with_img,\n                            img_cache_dir=img_cache_dir,\n                            use_cache=use_cache)\n\n            _align = '{}{}'.format(sn_info.get('align', ''), sn_info.get('length', 2))\n            # _hint = '%{}s. %s'.format(_align) % (i, choice)\n            _hint_num = '%{}s.'.format(_align) % i\n            _hint = '[{}]'.format(_hint_num)\n            _hint = textui.colored.magenta(_hint)\n            _hint += getattr(textui.colored, fg_color)(' %s' % choice)\n            textui.puts(_hint)\n\n        if _footer:\n            textui.puts(getattr(textui.colored, fg_color)(_footer))\n\n    _valid = [str(x + 1) for x in range(0, len(choices))]\n    default_prompt = 'Your Choice'\n    valid_choices = ['q-quit', 'b-back']\n    if extra_hints:\n        if isinstance(extra_hints, str):\n            extra_hints = extra_hints.split(',')\n        valid_choices += extra_hints\n\n    default_prompt = '{}({})?'.format(default_prompt, '/'.join(valid_choices))\n    c = click.prompt(\n        # click.style('[Depth: ({})]Your Choice(q-quit/b-back)?', fg='cyan').format(depth),\n        click.style(default_prompt, fg='cyan'),\n        type=str,\n        default=default\n    )\n\n    if str(c) in 'qQ':\n        if quit_app:\n            os._exit(0)\n        else:\n            if clear_previous:\n                click.clear()\n            return str(c)\n    if valid_keys == 'all':\n        return c\n    elif str(c) in 'bB':\n        if clear_previous:\n            click.clear()\n        return str(c)\n    elif valid_keys and str(c) in valid_keys.split(','):\n        return str(c)\n    elif c not in _valid:\n        textui.puts(textui.colored.red('  \ud83d\ude2d \u2718 Invalid input[{}]'.format(c)))\n        return num_choice(\n            choices, default, valid_keys, depth, icons, sn_info, indent, fg_color, separator, with_img, img_list,\n            img_cache_dir, use_cache, extra_hints, clear_previous, quit_app,\n        )\n    else:\n        return int(c) - 1", "response": "Return a list of num_choice items in a single order."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncopying data to the clipboard.", "response": "def copy_to_clipboard(dat):\n    \"\"\"\n        \u590d\u5236 ``dat`` \u5185\u5bb9\u5230 \u526a\u5207\u677f\u4e2d\n\n    :return: None\n    \"\"\"\n    p = subprocess.Popen(['pbcopy'], stdin=subprocess.PIPE)\n    p.stdin.write(to_bytes(dat))\n    p.stdin.close()\n    p.communicate()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cat_net_img(url='', indent=4, img_height=0, img_cache_dir='/tmp', use_cache=False):\n    name = url.split('/')[-1]\n    pth = os.path.join(img_cache_dir, name)\n\n    # \u5982\u679c\u4e0d\u4f7f\u7528\u7f13\u5b58 \u6216\u8005 \u6587\u4ef6\u4e0d\u5b58\u5728, \u5219\u5148\u4e0b\u8f7d\u5230\u672c\u5730, \u7136\u540e\u518d\u8bfb\u53d6\n    if not use_cache or not is_file_ok(pth):\n        raw = requests.get(url)\n        write_file(raw.content, pth)\n\n    with textui.indent(indent, quote=' {}'.format(' ')):\n        textui.puts(cat_img_by_path(pth, img_height))", "response": "- \u4f18\u5148 \u4ece\u5fae\u535a\u7f13\u5b58\u76ee\u5f55\u8bfb\u53d6\u56fe\u7247\n        - \u5982\u679c\u5931\u8d25, \u518d\u4ece\u76f8\u5e94\u7684url\u8bfb\u53d6\u7167\u7247\n\n    :param use_cache: ``\u4f7f\u7528\u7f13\u5b58``\n    :type use_cache:\n    :param img_cache_dir:\n    :type img_cache_dir:\n    :param url:\n    :type url:\n    :param indent:\n    :type indent:\n    :param img_height:\n    :type img_height:\n    :return:\n    :rtype:"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cat_img_cnt(cnt_in='', img_height=0):\n    if not img_height:\n        img_height = 6\n    _head = '\\x1b]1337;'\n    _file = 'File=name={}'.format(to_str(base64.b64encode(to_bytes(now()))))\n    _attr = ';inline=1;height={}:'.format(img_height)\n    _tail = '\\x07'\n    cnt = '{}{}{}{}{}'.format(\n        _head, _file, _attr, cnt_in, _tail\n    )\n    return cnt", "response": "\u5c55\u793a\u56fe\u7247\u5185\u5bb9\n\n    :param cnt_in:\n    :type cnt_in:\n    :param img_height:  \u7167\u7247\u5360\u7528\u7684\u7ec8\u7aef\u884c\u6570\n    :type img_height: int\n    :return:\n    :rtype:"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef str2unixtime(ts, fmt='%Y-%m-%d %H:%M:%S'):\n    t = time.strptime(ts, fmt)\n    return int(time.mktime(t))", "response": "converts a string to a unix time"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts unix timestamp to string", "response": "def unixtime2str(timestamp, fmt='%Y-%m-%d %H:%M:%S'):\n    \"\"\"\n    \u5c06 ``\u79d2\u7ea7\u522b\u7684\u65f6\u95f4\u6233`` \u8f6c\u6362\u6210\u5b57\u7b26\u4e32\n\n    .. warning:\n        \u65f6\u95f4\u6233\u662f\u4ee5 ``\u79d2`` \u4e3a\u5355\u4f4d\u7684\n\n    :param timestamp: unix timestamp\n    :type timestamp: int\n    :param fmt: show format\n    :type fmt: str\n    :return:\n    :rtype: str\n    \"\"\"\n    dt = None\n    try:\n        timestamp = time.localtime(timestamp)\n        dt = time.strftime(fmt, timestamp)\n    except Exception as err:\n        print(err)\n    return dt"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a random unixtime.", "response": "def unixtime(mm=False):\n    \"\"\"\n        \u8fd4\u56de\u5f53\u524d\u65f6\u95f4\u7684 ``unix\u65f6\u95f4\u6233``, \u9ed8\u8ba4\u8fd4\u56de\u7ea7\u522b ``second``\n\n    - \u53ef\u8bbe\u7f6e ``mm=True`` \u6765\u83b7\u53d6\u6beb\u79d2, \u6beb\u79d2\u4f7f\u7528 ``(\u79d2+\u968f\u673a\u6570)*1000`` \u6765\u5b9e\u73b0, \u5c3d\u91cf\u9632\u6b62\u51fa\u73b0\u76f8\u540c\n\n    - \u4f7f\u7528\u65f6\u95f4\u8303\u56f4\u9650\u5236:(2001/9/9 9:46:40 ~ 2286/11/21 1:46:3)\n    - \u6837\u4f8b\n\n    .. code:: python\n\n        # \u6807\u51c6\u60c5\u51b5\u76f4\u63a5\u4f7f\u7528\u79d2\n        len(str(unixtime()))\n        # \u8f93\u51fa 10\n\n        # \u5982\u679c\u9700\u8981\u552f\u4e00\u6807\u8bc6, \u53ef\u4ee5\u5c1d\u8bd5\u4f7f\u7528\n        len(str(unixtime(True)))\n        # \u8f93\u51fa 13\n\n    \"\"\"\n    if mm:\n        return int((time.mktime(datetime.datetime.now().timetuple()) + random.random()) * 1000)\n    else:\n        return int(time.mktime(datetime.datetime.now().timetuple()))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mkdir_p(pathin, is_dir=False):\n    h, _ = os.path.split(pathin)\n    if is_dir:\n        h = pathin\n    try:\n        if not os.path.exists(h):\n            os.makedirs(h)\n    except FileExistsError as _:\n        pass\n    except Exception as err:\n        raise err", "response": "mkdir - p pathin"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef walk_dir_with_filter(pth, prefix=None, suffix=None):\n    if suffix is None or type(suffix) != list:\n        suffix = []\n    if prefix is None or type(prefix) != list:\n        prefix = []\n\n    r = []\n    for root_, dirs, files in os.walk(pth):\n        for file_ in files:\n            full_pth = os.path.join(root_, file_)\n\n            # \u6392\u9664 \\.\u5f00\u5934\u6587\u4ef6, \u53ca .pyc .md \u7ed3\u5c3e\u6587\u4ef6\n            c = False\n            for x in prefix:\n                if file_.startswith(x):\n                    c = True\n                    break\n            if c:\n                continue\n            # if runs here , c is False\n            for x in suffix:\n                if file_.endswith(x):\n                    c = True\n                    break\n            if c:\n                continue\n\n            r.append(full_pth)\n    return r", "response": "Walks a directory and returns a list of all the files that match the filter."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites a file to a node", "response": "def write_file(dat, pth, append=False):\n    \"\"\"\n        \u5c06 dat \u5185\u5bb9\u5199\u5165 pth \u4e2d, \u5982\u679c\u5199\u5165\u6210\u529f, \u8fd4\u56de\u4e3a\u7a7a, \u5426\u5219\u8fd4\u56de\u5931\u8d25\u4fe1\u606f\n\n    :type append: ``bool``\n    :param append: \u5199\u5165\u6a21\u5f0f\n    :type append: ``bool``\n    :param dat: \u5f85\u5199\u5165\u5185\u5bb9\n    :type dat: ``str``\n    :param pth:\n    :type pth: ``str``\n    :return:\n    :rtype:\n    \"\"\"\n    err = None\n\n    _d, _nm = os.path.split(pth)\n    if _d and not os.path.exists(_d):\n        os.makedirs(_d)\n\n    try:\n        mode = 'ab' if append else 'wb'\n\n        with open(pth, mode) as _fp:\n            dat = to_bytes(dat)\n            _fp.write(dat)\n    except Exception as _err:\n        err = _err\n    return err"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_file(pth, use_str=False):\n    cont = None\n    try:\n        with open(u'' + pth, 'rb') as fp:\n            cont = fp.read()\n\n        if use_str:\n            cont = to_str(cont)\n    except Exception as err:\n        print(err)\n    return cont", "response": "read a file into a natalite list"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npickle m2f \u5c06 dat \u5185\u5bb9\u540c\u6b65\u5230\u6587\u4ef6", "response": "def pickle_m2f(dat, pth):\n    \"\"\"\n        \u5c06 dat \u5185\u5bb9\u540c\u6b65\u5230\u6587\u4ef6\u5b58\u50a8\u4e2d\n\n    :param dat:\n    :type dat:\n    :param pth:\n    :type pth:\n    :return:\n    :rtype:\n    \"\"\"\n    mkdir_p(pth)\n    # \u4e3a\u4e862\u4e0e3\u517c\u5bb9, \u8bbe\u7f6e dump \u7684\u534f\u8bae\u4e3a 2\n    with open(pth, 'wb') as f:\n        pickle.dump(dat, f, 2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pickle_f2m(pth, rt=None):\n    r = rt\n    try:\n        with open(pth, 'rb') as f:\n            r = pickle.load(f)\n    except Exception as err:\n        sys.stderr.write('pickle_f2m(pth={}) with error: {}\\n'.format(pth, err))\n    return r", "response": "pickle file to list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef xorsum(t):\n    _b = t[0]\n    for i in t[1:]:\n        _b = _b ^ i\n        _b &= 0xff\n    return _b", "response": "XOR sum of all the items in a sequence"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck the checksum of a sequence of words.", "response": "def check_sum(buf, csum):\n    \"\"\"\n    \u68c0\u67e5\u6570\u636e\u7684\u6821\u9a8c\u548c\n    :param buf:\n    :type buf:\n    :param csum:\n    :type csum:\n    :return:\n    :rtype:\n    \"\"\"\n    csum = csum.encode('utf-8')\n    _csum = ord(buf[0])\n    for x in buf[1:]:\n        _csum ^= ord(x)\n\n    _csum = binascii.b2a_hex(chr(_csum).encode('utf-8')).upper()\n    if _csum != csum:\n        sys.stderr.write('csum not matched: ({} {})\\n'.format(_csum, csum))\n    return _csum == csum"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef crc16(cmd, use_byte=False):\n    crc = 0xFFFF\n\n    # crc16 \u8ba1\u7b97\u65b9\u6cd5, \u9700\u8981\u4f7f\u7528 byte\n    if hasattr(cmd, 'encode'):\n        cmd = bytes.fromhex(cmd)\n\n    for _ in cmd:\n        c = _ & 0x00FF\n        crc ^= c\n        for i in range(8):\n            if crc & 0x0001 > 0:\n                crc >>= 1\n                crc ^= 0xA001\n            else:\n                crc >>= 1\n\n    # modbus crc16\u8ba1\u7b97\u65f6,\u9700\u8981\u9ad8/\u4f4e\u4f4d\u5012\u7f6e\n    t = [(crc & 0x00FF), (crc >> 8 & 0xFF)]\n    crc = '%02X%02X' % (t[0], t[1])\n    if use_byte:\n        crc = bytes.fromhex(crc)\n    return crc", "response": "crc16 \u68c0\u9a8c \u6307\u4ee4 \u6307\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef debug(users=None):\n    if not users:\n        return False\n    users = users if isinstance(users, list) else [users]\n    return True if getpass.getuser() in users else False", "response": "Returns True if the user is logged in False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets MAC address from network interface.", "response": "def get_addr(iface='lo0', iface_type='link'):\n    \"\"\"\n        \u83b7\u53d6\u7f51\u7edc\u63a5\u53e3 ``iface`` \u7684 ``mac``\n\n    - \u5982\u679c\u7cfb\u7edf\u7c7b\u578b\u4e3a ``mac``, \u4f7f\u7528 ``psutil``\n    - \u5176\u4ed6\u4f7f\u7528 ``socket``\n\n    :param iface: ``\u7f51\u7edc\u63a5\u53e3``\n    :type iface: str\n    :return: ``mac\u5730\u5740/\u7a7a``\n    :rtype: str/None\n    \"\"\"\n    if platform.system() in ['Darwin', 'Linux']:\n        if iface_type == 'link':\n            _AF_FAMILY = psutil.AF_LINK\n        elif iface_type in ['inet', 'inet6']:\n            _AF_FAMILY = getattr(socket, 'AF_{}'.format(iface_type.upper()))\n        else:\n            raise SystemError('Not valid address FAMILY')\n    else:\n        raise SystemExit('Unsupported System. Only Mac/Linux Supported')\n\n    addrs = psutil.net_if_addrs()\n    for n in addrs[iface]:\n        if n.family == _AF_FAMILY:\n            return n.address"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef uniqid(iface='wlan0', is_hex=True):\n    # return str(appid.getnode()) if not is_hex else str(hex(appid.getnode()))[2:-1]\n    m_ = get_addr(iface)\n    m_ = ''.join(m_.split(':')) if m_ else m_\n    if m_ and not is_hex:\n        m_ = str(int(m_.upper(), 16))\n    return m_", "response": "\u4f7f\u7528\u7f51\u5361\u7684\u7269\u7406\u5730\u5740 ``\u9ed8\u8ba4wlan0`` \u6765\u4f5c\u4e3a\u6807\u8bc6\n\n    - \u7f6e\u4f4d ``is_hex``, \u6765\u786e\u5b9a\u8fd4\u56de ``16\u8fdb\u5236/10\u8fdb\u5236\u683c\u5f0f``\n\n    :param iface: ``\u7f51\u7edc\u63a5\u53e3(\u9ed8\u8ba4wlan0)``\n    :type iface: str\n    :param is_hex: ``True(\u8fd4\u56de16\u8fdb\u5236)/False(10\u8fdb\u5236)``\n    :type is_hex: bool\n    :return: ``mac\u5730\u5740/\u7a7a``\n    :rtype: str"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget app id from iface", "response": "def app_id(iface=''):\n    \"\"\" \u4f9d\u636e\u6307\u5b9a\u7684 ``iface`` \u540d, \u6765\u83b7\u53d6\u7a0b\u5e8f\u8fd0\u884c\u9700\u8981\u7684\u552f\u4e00ID\n\n    - iface \u4e3a\u7a7a, \u5219\u81ea\u52a8\u4ece\u7cfb\u7edf\u9009\u62e9\u7b2c\u4e00\u4e2a\u53ef\u7528\u7684\u7f51\u7edc\u63a5\u53e3 mac\n    - \u987a\u5e8f,\u81ea\u52a8\u83b7\u53d6\u7f16\u53f7\u6700\u5c0f\u7684\u7f51\u7edc\u63a5\u53e3:\n        + macosx: en0~n\n        + linux: eth/wlan(0~n)\n\n    :param iface: ``\u7cfb\u7edf\u4e2d\u7684\u7f51\u7edc\u63a5\u53e3\u540d``\n    :type iface: str\n    :return:\n    :rtype:\n    \"\"\"\n    if iface:\n        return uniqid(iface)\n\n    if platform.system() == 'Darwin':\n        _ava_start = ['en']\n    elif platform.system() == 'Linux':\n        _ava_start = ['eth', 'wla']\n    else:\n        return None\n\n    nics = psutil.net_if_addrs()\n    _ifces = list(nics.keys())\n    _ifces.sort()\n\n    for _ in _ifces:\n        if _[:len(_ava_start[0])] in _ava_start:\n            return uniqid(_)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_sys_cmd_output(cmd):\n    _e, op = None, ''\n    if not isinstance(cmd, list):\n        cmd = cmd.split(' ')\n\n    try:\n        op = subprocess.check_output(cmd)\n        if sys.version_info[0] >= 3:\n            op = to_str(op)\n        op = op.split('\\n')\n    except Exception as err:\n        _e = err\n\n    return _e, op", "response": "get sys. stdout output"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef block_here(duration=0):\n    try:\n        while not duration:\n            time.sleep(0.001)\n\n        while duration:\n            time.sleep(0.001)\n            duration -= 1\n    except KeyboardInterrupt as err:\n        raise SystemExit(1)", "response": "\u5982\u679c duration \u4e3a0, \u5219\u4e00\u76f4\u963b\u585e\u7a0b\u5e8f\u8fd0\u884c\n    :param duration:\n    :type duration:\n    :return:\n    :rtype:"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_get(url, params, to=3):\n    try:\n        rs = requests.get(url, params=params, timeout=to)\n        if rs.status_code == 200:\n            try:\n                return rs.json()\n            except Exception as __e:\n                # log.error(__e)\n                return rs.text\n    except Exception as er:\n        log.error('get {} ({}) with err: {}'.format(url, params, er))\n        time.sleep(0.5)\n    return {}", "response": "request. get \u83b7\u53d6 url"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do_post(url, payload, to=3, use_json=True):\n    try:\n        if use_json:\n            rs = requests.post(url, json=payload, timeout=to)\n        else:\n            rs = requests.post(url, data=payload, timeout=to)\n        if rs.status_code == 200:\n            log.warn(rs.text)\n            return rs.json()\n    except Exception as er:\n        log.error('post to {} ({}) with err: {}'.format(url, payload, er))\n        time.sleep(0.5)\n    return {}", "response": "\u4f7f\u7528 ``request.get`` \u4ece\u6307\u5b9a url \u83b7\u53d6\u6570\u636e\n\n    :param use_json: \u662f\u5426\u4f7f\u7528 ``json`` \u683c\u5f0f, \u5982\u679c\u662f, \u5219\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u5b57\u5178, \u5426\u5219\u9700\u8981\u5148\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\n    :type use_json: bool\n    :param payload: \u5b9e\u9645\u6570\u636e\u5185\u5bb9\n    :type payload: dict\n    :param url: ``\u63a5\u53e3\u5730\u5740``\n    :type url:\n    :param to: ``\u54cd\u5e94\u8d85\u65f6\u8fd4\u56de\u65f6\u95f4``\n    :type to:\n    :return: ``\u63a5\u53e3\u8fd4\u56de\u7684\u6570\u636e``\n    :rtype: dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing url for domain and homepage", "response": "def get_domain_home_from_url(url):\n    \"\"\" parse url for domain and homepage\n\n    :param url: the req url\n    :type url: str\n    :return: (homepage, domain)\n    :rtype:\n    \"\"\"\n    p = parse.urlparse(url)\n    if p.netloc:\n        return '{}://{}'.format(p.scheme, p.netloc), p.netloc\n    else:\n        return '', ''"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreplaces all occurrences of pattens with a single delimiter", "response": "def multi_replace(original, pattens, delim='|,'):\n    \"\"\"\n        \u4f7f\u7528 ``multi_delim`` \u4e2d\u7684\u6240\u6709\u89c4\u5219\u6765\u66ff\u6362 ``original`` \u5b57\u7b26\u4e32\u5185\u5bb9\n\n    >>> orig = '\u4eca\u5929\u662f\u4e00\u4e2a\u597d\u5929\u6c14'\n    >>> multi_replace(orig, '\u4eca\u5929|\u662f|\u597d\u5929\u6c14')\n    '\u4e00\u4e2a'\n    >>> multi_replace(orig, '\u4eca\u5929,today |\u662f,is |\u597d\u5929\u6c14,good weather')\n    'today is \u4e00\u4e2agood weather'\n\n    :param delim: \u5206\u9694\u7b26, \u5916\u5c42 `|` \u5185\u5c42 `,`\n    :type delim:\n    :param original: \u539f\u59cb\u5b57\u7b26\u4e32\n    :type original: str\n    :param pattens: \u66ff\u6362\u89c4\u5219\n    :type pattens: str\n    :return:\n    :rtype:\n    \"\"\"\n    if not original:\n        return ''\n\n    if not delim or len(delim) != 2:\n        delim = '|,'\n\n    # \u6700\u5916\u5c42\u5206\u9694\u7b26, \u7b2c\u4e8c\u5c42\u5206\u9694\u7b26\n    level0, level1 = delim[0], delim[1]\n\n    for re_pair in pattens.split(level0):\n        _f, _to = re_pair, ''\n\n        re_pair = re_pair.split(level1)\n        if len(re_pair) == 2:\n            _f, _to = re_pair\n        original = original.replace(_f, _to)\n    return original"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading the most common words from a file", "response": "def words(fpth):\n    \"\"\"\n    ww = words(os.path.join(app_root, 'ig/helper.py'))\n    for k, v in (ww.most_common(3)):\n        print(k, v)\n\n    :param fpth:\n    :type fpth:\n    :return:\n    :rtype:\n    \"\"\"\n    from collections import Counter\n    words__ = Counter()\n    with open(fpth) as fp:\n        for line in fp:\n            words__.update(line.strip().split(' '))\n    return words__"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nblock current thread at random pareto time ``minimum < block < 15`` and return the sleep time ``seconds`` :param minimum: :type minimum: :param scale: :type scale: :param slow_mode: a tuple e.g.(2, 5) :type slow_mode: tuple :return:", "response": "def rand_block(minimum, scale, maximum=1):\n    \"\"\"\n        block current thread at random pareto time ``minimum < block < 15`` and return the sleep time ``seconds``\n\n    :param minimum:\n    :type minimum:\n    :param scale:\n    :type scale:\n    :param slow_mode: a tuple e.g.(2, 5)\n    :type slow_mode: tuple\n    :return:\n    \"\"\"\n    t = min(rand_pareto_float(minimum, scale), maximum)\n    time.sleep(t)\n    return t"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _print_divide(self):\n        for space in self.AttributesLength:\n            self.StrTable += \"+ \" + \"- \" * space\n        self.StrTable += \"+\" + \"\\n\"", "response": "Prints all those table line dividers."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef append_data(self, attribute, values):\n        found = False\n        if type(values) != list:\n            values = [values]\n        for col in self.Table:\n            if attribute in col:\n                dict_values = [u\"{0}\".format(value) for value in values]\n                col[attribute] += dict_values\n                found = True\n        if not found:\n            raise KeyError(attribute)", "response": "Appends the given value(s) to the attribute ( column )."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _create_table(self):\n        self.StrTable = \"\"\n        self.AttributesLength = []\n        self.Lines_num = 0\n        # Prepare some values..\n        for col in self.Table:\n            # Updates the table line count if necessary\n            values = list(col.values())[0]\n            self.Lines_num = max(self.Lines_num, len(values))\n            # find the length of longest value in current column\n            key_length = max([self._disp_width(v) for v in values] or [0])\n            # and also the table header\n            key_length = max(key_length, self._disp_width(list(col.keys())[0]))\n            self.AttributesLength.append(key_length)\n        # Do the real thing.\n        self._print_head()\n        self._print_value()", "response": "Creates a pretty - printed string representation of the table as\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating the header of the table.", "response": "def _print_head(self):\n        \"\"\"Generates the table header.\"\"\"\n        self._print_divide()\n        self.StrTable += \"| \"\n        for colwidth, attr in zip(self.AttributesLength, self.Attributes):\n            self.StrTable += self._pad_string(attr, colwidth * 2)\n            self.StrTable += \"| \"\n        self.StrTable += '\\n'\n        self._print_divide()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating the table values.", "response": "def _print_value(self):\n        \"\"\"Generates the table values.\"\"\"\n        for line in range(self.Lines_num):\n            for col, length in zip(self.Table, self.AttributesLength):\n                vals = list(col.values())[0]\n                val = vals[line] if len(vals) != 0 and line < len(vals) else ''\n                self.StrTable += \"| \"\n                self.StrTable += self._pad_string(val, length * 2)\n            self.StrTable += \"|\" + '\\n'\n            self._print_divide()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the width of the log entry in a string.", "response": "def _disp_width(self, pwcs, n=None):\n        \"\"\"\n        A wcswidth that never gives -1. Copying existing code is evil, but..\n        github.com/jquast/wcwidth/blob/07cea7f/wcwidth/wcwidth.py#L182-L204\n        \"\"\"\n        # pylint: disable=C0103\n        #         Invalid argument name \"n\"\n        # TODO: Shall we consider things like ANSI escape seqs here?\n        #       We can implement some ignore-me segment like those wrapped by\n        #       \\1 and \\2 in readline too.\n        end = len(pwcs) if n is None else n\n        idx = slice(0, end)\n        width = 0\n        for char in pwcs[idx]:\n            width += max(0, wcwidth(char))\n        return width"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncentering - pads a string to the given column width using spaces.", "response": "def _pad_string(self, str, colwidth):\n        \"\"\"Center-pads a string to the given column width using spaces.\"\"\"\n        width = self._disp_width(str)\n        prefix = (colwidth - 1 - width) // 2\n        suffix = colwidth - prefix - width\n        return ' ' * prefix + str + ' ' * suffix"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _download_sdss_image(\n            self):\n        \"\"\"*download sdss image*\n        \"\"\"\n        self.log.info('starting the ``_download_sdss_image`` method')\n\n        opt = \"\"\n        if self.grid:\n            opt += \"G\"\n\n        if self.label:\n            opt += \"L\"\n\n        if self.photocat:\n            opt += \"P\"\n\n        if self.speccat:\n            opt += \"S\"\n\n        if self.invertColors:\n            opt += \"I\"\n\n        if len(opt):\n            opt = \"opt=%(opt)s&\" % locals()\n\n        width = self.pixelWidth\n\n        scale = (self.arcminWidth * 60.) / width\n\n        converter = unit_conversion(\n            log=self.log\n        )\n        ra = converter.ra_sexegesimal_to_decimal(\n            ra=self.ra\n        )\n        dec = converter.dec_sexegesimal_to_decimal(\n            dec=self.dec\n        )\n        url = \"\"\"http://skyservice.pha.jhu.edu/DR12/ImgCutout/getjpeg.aspx?ra=%(ra)s&dec=%(dec)s&scale=%(scale)s&%(opt)sPhotoObjs=on&width=%(width)s&height=%(width)s\"\"\" % locals(\n        )\n\n        from fundamentals.download import multiobject_download\n        localUrls = multiobject_download(\n            urlList=[url],\n            downloadDirectory=self.downloadDirectory,\n            log=self.log,\n            timeStamp=False,\n            timeout=180,\n            concurrentDownloads=10,\n            resetFilename=[self.filename],\n            credentials=False,  # { 'username' : \"...\", \"password\", \"...\" }\n            longTime=True,\n            indexFilenames=False\n        )\n\n        print url\n\n        self.log.info('completed the ``_download_sdss_image`` method')\n        return None", "response": "download the sdss image"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating step and go to the next one or finish the wizard", "response": "def next(transport, wizard, step, data):\n    \"\"\"\n    Validate step and go to the next one (or finish the wizard)\n\n    :param transport: Transport object\n    :param wizard: Wizard block name\n    :param step: Current step number\n    :param data: form data for the step\n    \"\"\"\n    step = int(step)\n    wizard = blocks.get(wizard)\n\n    # Retrieve form block\n    form = wizard.next(step)\n\n    valid = forms.send(transport, form.register_name, data=data)\n\n    if valid:\n        if wizard.next(step+1) is None:\n            # It was last step\n            wizard.finish(transport)\n            return\n\n        # Next step\n        wizard.step = step+1\n        wizard.update(transport)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef features_check_singular(X, tol=1e-8):\n    import numpy as np\n    _, s, _ = np.linalg.svd(np.dot(X.T, X))\n    failed = s < tol\n    flag = True if np.any(failed) else False\n    return flag, failed.sum(), s", "response": "Checks if a set of features or variables X result in a base - level ill - conditioned matrix dot product with the singular values computed by numpy. linalg. svd."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the type of an object. Do some regex to remove the \"<class... bit.", "response": "def get_dir(obj, **kwargs):\n    \"\"\"Return the type of an object. Do some regex to remove the \"<class...\" bit.\"\"\"\n    attrs = list(filter(filter_dunder, dir(obj)))\n\n    if not attrs:\n        return \"No public attributes.\"\n\n    s = \"Attributes:\"\n    for attr in attrs:\n        s += '\\n - {} ({})'.format(attr, extract_type(type(getattr(obj, attr))))\n\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall documentation: `/account/find <https://www.wepay.com/developer/reference/account#find>`_, plus extra keyword parameters: :keyword str access_token: will be used instead of instance's ``access_token``, with ``batch_mode=True`` will set `authorization` param to it's value. :keyword bool batch_mode: turn on/off the batch_mode, see :class:`wepay.api.WePay` :keyword str batch_reference_id: `reference_id` param for batch call, see :class:`wepay.api.WePay` :keyword str api_version: WePay API version, see :class:`wepay.api.WePay`", "response": "def __find(self, **kwargs):\n        \"\"\"Call documentation: `/account/find\n        <https://www.wepay.com/developer/reference/account#find>`_, plus extra\n        keyword parameters:\n        \n        :keyword str access_token: will be used instead of instance's\n           ``access_token``, with ``batch_mode=True`` will set `authorization`\n           param to it's value.\n\n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {}\n        return self.make_call(self.__find, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall documentation: `/account/create <https://www.wepay.com/developer/reference/account#create>`_, plus extra keyword parameters: :keyword str access_token: will be used instead of instance's ``access_token``, with ``batch_mode=True`` will set `authorization` param to it's value. :keyword bool batch_mode: turn on/off the batch_mode, see :class:`wepay.api.WePay` :keyword str batch_reference_id: `reference_id` param for batch call, see :class:`wepay.api.WePay` :keyword str api_version: WePay API version, see :class:`wepay.api.WePay`", "response": "def __create(self, name, description, **kwargs):\n        \"\"\"Call documentation: `/account/create\n        <https://www.wepay.com/developer/reference/account#create>`_, plus extra\n        keyword parameters:\n        \n        :keyword str access_token: will be used instead of instance's\n           ``access_token``, with ``batch_mode=True`` will set `authorization`\n           param to it's value.\n\n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'name': name,\n            'description': description\n        }\n        return self.make_call(self.__create, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __modify(self, account_id, **kwargs):\n        params = {\n            'account_id': account_id\n        }\n        return self.make_call(self.__modify, params, kwargs)", "response": "Modify the internal state of a wePay account."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling documentation: `/account/delete <https://www.wepay.com/developer/reference/account#delete>`_, plus extra keyword parameters: :keyword str access_token: will be used instead of instance's ``access_token``, with ``batch_mode=True`` will set `authorization` param to it's value. :keyword bool batch_mode: turn on/off the batch_mode, see :class:`wepay.api.WePay` :keyword str batch_reference_id: `reference_id` param for batch call, see :class:`wepay.api.WePay` :keyword str api_version: WePay API version, see :class:`wepay.api.WePay`", "response": "def __delete(self, account_id, **kwargs):\n        \"\"\"Call documentation: `/account/delete\n        <https://www.wepay.com/developer/reference/account#delete>`_, plus extra\n        keyword parameters:\n        \n        :keyword str access_token: will be used instead of instance's\n           ``access_token``, with ``batch_mode=True`` will set `authorization`\n           param to it's value.\n\n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'account_id': account_id\n        }\n        return self.make_call(self.__delete, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls documentation: `/account/get_update_uri <https://www.wepay.com/developer/reference/account#update_uri>`_, plus extra keyword parameters: :keyword str access_token: will be used instead of instance's ``access_token``, with ``batch_mode=True`` will set `authorization` param to it's value. :keyword bool batch_mode: turn on/off the batch_mode, see :class:`wepay.api.WePay` :keyword str batch_reference_id: `reference_id` param for batch call, see :class:`wepay.api.WePay` :keyword str api_version: WePay API version, see :class:`wepay.api.WePay`", "response": "def __get_update_uri(self, account_id, **kwargs):\n        \"\"\"Call documentation: `/account/get_update_uri\n        <https://www.wepay.com/developer/reference/account#update_uri>`_, plus extra\n        keyword parameters:\n        \n        :keyword str access_token: will be used instead of instance's\n           ``access_token``, with ``batch_mode=True`` will set `authorization`\n           param to it's value.\n\n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'account_id': account_id\n        }\n        return self.make_call(self.__get_update_uri, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __get_reserve_details(self, account_id, **kwargs):\n        params = {\n            'account_id': account_id\n        }\n        return self.make_call(self.__get_reserve_details, params, kwargs)", "response": "Method to get the details of a reserve."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __balance(self, account_id, **kwargs):\n        params = {\n            'account_id': account_id\n        }\n        return self.make_call(self.__balance, params, kwargs)", "response": "This is the private method for the balance API."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __add_bank(self, account_id, **kwargs):\n        params = {\n            'account_id': account_id\n        }\n        return self.make_call(self.__add_bank, params, kwargs)", "response": "This is the main entry point for adding a new bank to an existing account."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __set_tax(self, account_id, taxes, **kwargs):\n        params = {\n            'account_id': account_id,\n            'taxes': taxes\n        }\n        return self.make_call(self.__set_tax, params, kwargs)", "response": "This is the private method for setting the taxes of a specific user in a specific instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __get_tax(self, account_id, **kwargs):\n        params = {\n            'account_id': account_id\n        }\n        return self.make_call(self.__get_tax, params, kwargs)", "response": "This is the private method for getting the tax of an account."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __remove(self, account_id, user_id, **kwargs):\n        params = {\n            'account_id': account_id,\n            'user_id': user_id\n        }\n        return self.make_call(self.__remove, params, kwargs)", "response": "Method to remove a user from an account s cache."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef basic_auth_string(username, password):\n    b64 = base64.encodestring('%s:%s' % (username, password)).strip()\n    return 'Basic %s' % b64", "response": "Encode a username and password for use in an HTTP Basic Authentication header"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall internally by callback. Does cb and error_cb selection.", "response": "def _do_cb(self, cb, error_cb, *args, **kw):\n        \"\"\"\n        Called internally by callback(). Does cb and error_cb selection.\n        \"\"\"\n        try:\n            res = self.work(*args, **kw)\n        except Exception as e:\n            if error_cb is None:\n                show_err()\n            elif error_cb:\n                error_cb(e)\n        else:\n            # Success, let's call away!\n            cb(res)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dict_minus(d, *keys):\n    # make shallow copy\n    d = dict(d)\n    for key in keys:\n        try:\n            del d[key]\n        except:\n            pass\n    return d", "response": "Delete key from dict if exists returning resulting dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef t_ID(self, t):\n        r'[a-zA-Z]+'\n        if t.value in self._RESERVED.keys():\n            t.type = self._RESERVED[t.value]\n            return t\n\n        if Information.is_valid_symbol(t.value) or \\\n                Information.is_valid_category(t.value):\n            t.type = self._INFORMATION_UNIT\n            return t\n\n        if Duration.is_valid_symbol(t.value):\n            t.type = self._DURATION_UNIT\n            return t\n\n        raise LexingError('Unrecognised token or unit \\'{0.value}\\' at '\n                          'position {0.lexpos}'.format(t))", "response": "r Returns the ID of the current token or raises LexingError if the token or unit is not a valid ID."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lex(self, string):\n        self.lexer.input(string)\n        for token in self.lexer:\n            yield token", "response": "Lex a string.\n        \n        :param string: The input to lex. \n        :return: A generator which will continue yielding tokens until the end\n                 of the input is reached."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(self, conn, tmp, module_name, module_args, inject):\n        ''' handler for fetch operations '''\n\n        # load up options\n        options = utils.parse_kv(module_args)\n        source = options.get('src', None)\n        dest = options.get('dest', None)\n        if source is None or dest is None:\n            results = dict(failed=True, msg=\"src and dest are required\")\n            return ReturnData(conn=conn, result=results)\n\n        # files are saved in dest dir, with a subdir for each host, then the filename\n        dest   = \"%s/%s/%s\" % (utils.path_dwim(self.runner.basedir, dest), conn.host, source)\n        dest   = dest.replace(\"//\",\"/\")\n\n        # calculate md5 sum for the remote file\n        remote_md5 = self.runner._remote_md5(conn, tmp, source)\n\n        # use slurp if sudo and permissions are lacking\n        remote_data = None\n        if remote_md5 in ('1', '2') and self.runner.sudo:\n            slurpres = self.runner._execute_module(conn, tmp, 'slurp', 'src=%s' % source, inject=inject)\n            if slurpres.is_successful():\n                if slurpres.result['encoding'] == 'base64':\n                    remote_data = base64.b64decode(slurpres.result['content'])\n                if remote_data is not None:\n                    remote_md5 = utils.md5s(remote_data)\n\n        # these don't fail because you may want to transfer a log file that possibly MAY exist\n        # but keep going to fetch other log files\n        if remote_md5 == '0':\n            result = dict(msg=\"unable to calculate the md5 sum of the remote file\", file=source, changed=False)\n            return ReturnData(conn=conn, result=result)\n        if remote_md5 == '1':\n            result = dict(msg=\"the remote file does not exist, not transferring, ignored\", file=source, changed=False)\n            return ReturnData(conn=conn, result=result)\n        if remote_md5 == '2':\n            result = dict(msg=\"no read permission on remote file, not transferring, ignored\", file=source, changed=False)\n            return ReturnData(conn=conn, result=result)\n\n        # calculate md5 sum for the local file\n        local_md5 = utils.md5(dest)\n\n        if remote_md5 != local_md5:\n            # create the containing directories, if needed\n            if not os.path.isdir(os.path.dirname(dest)):\n                os.makedirs(os.path.dirname(dest))\n\n            # fetch the file and check for changes\n            if remote_data is None:\n                conn.fetch_file(source, dest)\n            else:\n                f = open(dest, 'w')\n                f.write(remote_data)\n                f.close()\n            new_md5 = utils.md5(dest)\n            if new_md5 != remote_md5:\n                result = dict(failed=True, md5sum=new_md5, msg=\"md5 mismatch\", file=source, dest=dest)\n                return ReturnData(conn=conn, result=result)\n            result = dict(changed=True, md5sum=new_md5, dest=dest)\n            return ReturnData(conn=conn, result=result)\n        else:\n            result = dict(changed=False, md5sum=local_md5, file=source, dest=dest)\n            return ReturnData(conn=conn, result=result)", "response": "handler for fetch operations"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a PRIVMSG to someone.", "response": "def privmsg(self, target, message):\n        \"\"\"\n        Sends a PRIVMSG to someone.\n        Required arguments:\n        * target - Who to send the message to.\n        * message - Message to send.\n        \"\"\"\n        with self.lock:\n            self.send('PRIVMSG ' + target + ' :' + message)\n            if self.readable():\n                msg = self._recv(expected_replies=('301',))\n                if msg[0] == '301':\n                    return 'AWAY', msg[2].split(None, 1)[1].replace(':', '', 1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn val s relshell compatible type.", "response": "def equivalent_relshell_type(val):\n        \"\"\"Returns `val`'s relshell compatible type.\n\n        :param val:  value to check relshell equivalent type\n        :raises:     `NotImplementedError` if val's relshell compatible type is not implemented.\n        \"\"\"\n        builtin_type = type(val)\n        if builtin_type not in Type._typemap:\n            raise NotImplementedError(\"builtin type %s is not convertible to relshell type\" %\n                                      (builtin_type))\n        relshell_type_str = Type._typemap[builtin_type]\n        return Type(relshell_type_str)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstarting the callback function for the thread", "response": "def start(self, *args, **kwargs):\n    \n    \"\"\"\n    Set the arguments for the callback function and start the\n    thread\n    \"\"\"\n\n    self.runArgs = args\n    self.runKwargs = kwargs\n    Thread.start(self)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nattempt to purchase a main shop item returns result Returns True if successful False otherwise", "response": "def buy(self, price, pause=0):\n        \"\"\" Attempts to purchase a main shop item, returns result\n        \n        Uses the item's stock id and brr to navigate to the haggle page. Auotmatically downloads\n        the OCR image from the haggle page and attempts to crack it. Submits the haggle form with\n        the given price and returns if the item was successfully bought or not.\n           \n        Parameters:\n           price (str) -- The price to buy the item for\n           pause (int) -- The time in seconds to pause before submitting the haggle form\n           \n        Returns\n           bool - True if successful, false otherwise\n           \n        Raises:\n           failedOCR\n        \"\"\"\n        pg = self.usr.getPage(\"http://www.neopets.com/haggle.phtml?obj_info_id=%s&stock_id=%s&brr=%s\" % (self.id, self.stockid, self.brr))\n        form = pg.form(name=\"haggleform\")\n        \n        form['x'], form['y'] = self.crackOCR(StringIO.StringIO(self.usr.getPage(\"http://www.neopets.com\" + form.image).content))\n        form['current_offer'] = price\n        \n        if pause != 0:\n            time.sleep(pause)\n        \n        pg = form.submit()\n        \n        if \"I accept\" in pg.content:\n            return True\n        elif \"You must select the correct pet\" in pg.content:\n            logging.getLogger(\"neolib.item\").exception(\"Failed to crack OCR\")\n            raise failedOCR\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef crackOCR(self, image):\n        try:\n            im = Image.open(image)\n            \n            # Convert to greyscale, and find darkest pixel\n            im = im.convert(\"L\")\n            lo, hi = im.getextrema()\n            \n            # Find the pet outline and create a rectangle around a part of it\n            im = im.point(lambda p: p == lo)\n            rect = im.getbbox()\n            \n            # Return the center point\n            return (str(0.5 * (rect[0] + rect[2])), str(0.5 * (rect[1] + rect[3])))\n        except Exception:\n            logging.getLogger(\"neolib.item\").exception(\"Failed to crack OCR\")\n            raise failedOCR", "response": "Attempts to crack the given image and returns the center point of the center of the image."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the CONFIG_FILE for the current submission", "response": "def init(name, languages, run):\n    \"\"\"Initializes your CONFIG_FILE for the current submission\"\"\"\n    contents = [file_name for file_name in glob.glob(\"*.*\") if file_name != \"brains.yaml\"]\n\n    with open(CONFIG_FILE, \"w\") as output:\n        output.write(yaml.safe_dump({\n            \"run\": run,\n            \"name\": name,\n            \"languages\": languages,\n            # automatically insert all root files into contents\n            \"contents\": contents,\n        }, default_flow_style=False))\n\n    print \"\"\n    cprint(\"Automatically including the follow files in brain contents:\", \"cyan\")\n    for file_name in contents:\n        print \"\\t\", file_name\n    print \"\"\n    cprint(\"done! brains.yaml created\", 'green')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef push(description, datasets, wait, verbose):\n    # Loading config\n    config = _get_config()\n    file_patterns = config[\"contents\"]\n    if not isinstance(file_patterns, type([])):\n        # put it into an array so we can iterate it, if it isn't already an array\n        file_patterns = [file_patterns]\n    if datasets:\n        datasets_string = datasets.split(',')\n    else:\n        datasets_string = config.get(\"datasets\", '')\n\n\n    # Getting all file names/globs -- making sure we get CONFIG_FILE\n    files = {CONFIG_FILE}  # use a set so we don't get duplicates\n    for pattern in file_patterns:\n        files.update(glob.glob(pattern))\n    if not files:\n        print \"No files could be found? Check your contents section in `CONFIG_FILE`!\"\n        exit(-1)\n\n    if verbose:\n        print \"\"\n        print \"gatherered files:\"\n        for path in files:\n            print \"\\t\", path\n        print \"\"\n\n    # Zipping\n    _print(\"zipping...\")\n\n    if not os.path.exists(\"brains_history\"):\n        os.mkdir(\"brains_history\")\n\n    zip_path = 'brains_history/%s.zip' % str(datetime.datetime.now())\n    with ZipFile(zip_path, 'w') as zip_file:\n        for path in files:\n            zip_file.write(path)\n    cprint(\"done\", 'green')\n\n    # Sending to server\n    with open(zip_path, 'rb') as zip_file:\n        _print(\"sending to server...\")\n        try:\n            response = requests.post(\n                URL_SUBMIT,\n                files={\n                    \"zip_file\": zip_file,\n                },\n                data={\n                    \"name\": config[\"name\"],\n                    \"description\": description or '',\n                    \"languages\": config[\"languages\"],\n                    \"datasets\": datasets_string,\n                    \"wait\": wait,\n                },\n                stream=wait  # if we're waiting for response then stream\n            )\n\n            if response.status_code == 200:\n                cprint(\"done\", 'green')\n\n                if wait:\n                    _print(\"\\nOutput: \")\n                    cprint(\" \" * 72, 'green', attrs=('underline',))\n\n                    chunk_buffer = \"\"\n                    # read in 1 chunk at a time for carriage return detection\n                    for chunk in response.iter_content(chunk_size=1):\n                        chunk_buffer += chunk\n\n                        if chunk == '\\r':\n                            # We hit the end of a message!\n                            try:\n                                data = json.loads(chunk_buffer)\n                                if \"stdout\" not in data or \"stderr\" not in data:\n                                    print \"dis one\"\n                                    continue\n                            except (ValueError,):\n                                continue\n\n                            if data[\"stdout\"]:\n                                # Get rid of termination string, if it's there\n                                data[\"stdout\"] = data[\"stdout\"].replace(\"-%-%-%-%-END BRAIN SEQUENCE-%-%-%-%-\", \"\")\n                                _print(data[\"stdout\"])\n                            if data[\"stderr\"]:\n                                _print(colored(data[\"stderr\"], 'red'))\n\n                            # Clear buffer after reading message\n                            chunk_buffer = \"\"\n            else:\n                cprint(response.json()[\"error\"], 'red')\n        except requests.exceptions.ConnectionError:\n            cprint(\"failed to connect to server!\", 'red')\n            exit(-2)", "response": "Publish your submission to brains"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef diskMonitor(self):\n        '''Primitive monitor which checks whether new data is added to disk.'''\n\n        while self.loop():\n            try:\n                newest = max(glob.iglob(\"%s/*\" % (self.kwargs.directory)), key=os.path.getmtime)\n            except Exception:\n                pass\n            else:\n                if time() - os.path.getctime(newest) >= self.kwargs.idle_time:\n                    self.reading.set()\n                else:\n                    self.reading.clear()\n            sleep(1)", "response": "Primitive monitor which checks whether new data is added to disk."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, **kwargs):\n        super(ModelQuerySet, self).update(_changed=True, **kwargs)", "response": "Update the set with the given keyword parameters\n        and mark them as changed\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncommit current configuration, this will: - Unmark updated objects - Unmark new objects - Completely delete objects mark as deleted", "response": "def commit(cls):\n        \"\"\"\n        Commit current configuration, this will:\n            - Unmark updated objects\n            - Unmark new objects\n            - Completely delete objects mark as deleted\n        \"\"\"\n        cls.objects.deleted().true_delete()\n        cls.objects.changed().true_update(_new=False, _changed=False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(cls):\n        ifaddrs = getifaddrs()\n        # Create new interfaces\n        for ifname in ifaddrs.keys():\n            if filter(ifname.startswith, cls.NAME_FILTER):\n                cls.objects.get_or_create(name=ifname)\n\n        # Delete no longer existing ones\n        cls.objects.exclude(name__in=ifaddrs.keys()).delete()", "response": "Update rows to include known network interfaces\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the ordering of pages via AJAX from within the admin.", "response": "def admin_page_ordering(request):\n    \"\"\"\n    Updates the ordering of pages via AJAX from within the admin.\n    \"\"\"\n\n    def get_id(s):\n        s = s.split(\"_\")[-1]\n        return int(s) if s.isdigit() else None\n    page = get_object_or_404(Page, id=get_id(request.POST['id']))\n    old_parent_id = page.parent_id\n    new_parent_id = get_id(request.POST['parent_id'])\n    new_parent = Page.objects.get(id=new_parent_id) if new_parent_id else None\n\n    try:\n        page.get_content_model().can_move(request, new_parent)\n    except PageMoveException as e:\n        messages.error(request, e)\n        return HttpResponse('error')\n\n    # Perform the page move\n    if new_parent_id != page.parent_id:\n        # Parent changed - set the new parent and re-order the\n        # previous siblings.\n        page.set_parent(new_parent)\n        pages = Page.objects.filter(parent_id=old_parent_id)\n        for i, page in enumerate(pages.order_by('_order')):\n            Page.objects.filter(id=page.id).update(_order=i)\n    # Set the new order for the moved page and its current siblings.\n    for i, page_id in enumerate(request.POST.getlist('siblings[]')):\n        Page.objects.filter(id=get_id(page_id)).update(_order=i)\n\n    return HttpResponse(\"ok\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef page(request, slug, template=u\"pages/page.html\", extra_context=None):\n\n    from yacms.pages.middleware import PageMiddleware\n    if not PageMiddleware.installed():\n        raise ImproperlyConfigured(\"yacms.pages.middleware.PageMiddleware \"\n                                   \"(or a subclass of it) is missing from \" +\n                                   \"settings.MIDDLEWARE_CLASSES or \" +\n                                   \"settings.MIDDLEWARE\")\n\n    if not hasattr(request, \"page\") or request.page.slug != slug:\n        raise Http404\n\n    # Check for a template name matching the page's slug. If the homepage\n    # is configured as a page instance, the template \"pages/index.html\" is\n    # used, since the slug \"/\" won't match a template name.\n    template_name = str(slug) if slug != home_slug() else \"index\"\n    templates = [u\"pages/%s.html\" % template_name]\n    method_template = request.page.get_content_model().get_template_name()\n    if method_template:\n        templates.insert(0, method_template)\n    if request.page.content_model is not None:\n        templates.append(u\"pages/%s/%s.html\" % (template_name,\n            request.page.content_model))\n    for parent in request.page.get_ascendants(for_user=request.user):\n        parent_template_name = str(parent.slug)\n        # Check for a template matching the page's content model.\n        if request.page.content_model is not None:\n            templates.append(u\"pages/%s/%s.html\" % (parent_template_name,\n                request.page.content_model))\n    # Check for a template matching the page's content model.\n    if request.page.content_model is not None:\n        templates.append(u\"pages/%s.html\" % request.page.content_model)\n    templates.append(template)\n    return TemplateResponse(request, templates, extra_context or {})", "response": "Returns a new page object that can be used to render a page."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning unit vectors. Any null vectors raise an Exception.", "response": "def vector_unit_nonull(v):\n    \"\"\"Return unit vectors.\n    Any null vectors raise an Exception.\n\n    Parameters\n    ----------\n    v: array, shape (a1, a2, ..., d)\n        Cartesian vectors, with last axis indexing the dimension.\n\n    Returns\n    -------\n    v_new: array, shape of v\n    \"\"\"\n    if v.size == 0:\n        return v\n    return v / vector_mag(v)[..., np.newaxis]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef vector_unit_nullnull(v):\n    if v.size == 0:\n        return v\n    mag = vector_mag(v)\n    v_new = v.copy()\n    v_new[mag > 0.0] /= mag[mag > 0.0][..., np.newaxis]\n    return v_new", "response": "Return unit vectors. Any null vectors remain null vectors."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns unit vectors that are null randomly picked.", "response": "def vector_unit_nullrand(v, rng=None):\n    \"\"\"Return unit vectors.\n    Any null vectors are mapped to a uniformly picked unit vector.\n\n    Parameters\n    ----------\n    v: array, shape (a1, a2, ..., d)\n        Cartesian vectors, with last axis indexing the dimension.\n\n    Returns\n    -------\n    v_new: array, shape of v\n    \"\"\"\n    if v.size == 0:\n        return v\n    mag = vector_mag(v)\n    v_new = v.copy()\n    v_new[mag == 0.0] = sphere_pick(v.shape[-1], (mag == 0.0).sum(), rng)\n    v_new[mag > 0.0] /= mag[mag > 0.0][..., np.newaxis]\n    return v_new"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef vector_perp(v):\n    if v.shape[-1] != 2:\n        raise Exception('Can only define a unique perpendicular vector in 2d')\n    v_perp = np.empty_like(v)\n    v_perp[..., 0] = v[:, 1]\n    v_perp[..., 1] = -v[:, 0]\n    return v_perp", "response": "Return vectors perpendicular to 2 - dimensional vectors."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the polar vectors in their cartesian representation.", "response": "def polar_to_cart(arr_p):\n    \"\"\"Return polar vectors in their cartesian representation.\n\n    Parameters\n    ----------\n    arr_p: array, shape (a1, a2, ..., d)\n        Polar vectors, with last axis indexing the dimension,\n        using (radius, inclination, azimuth) convention.\n\n    Returns\n    -------\n    arr_c: array, shape of arr_p\n        Cartesian vectors.\n    \"\"\"\n    if arr_p.shape[-1] == 1:\n        arr_c = arr_p.copy()\n    elif arr_p.shape[-1] == 2:\n        arr_c = np.empty_like(arr_p)\n        arr_c[..., 0] = arr_p[..., 0] * np.cos(arr_p[..., 1])\n        arr_c[..., 1] = arr_p[..., 0] * np.sin(arr_p[..., 1])\n    elif arr_p.shape[-1] == 3:\n        arr_c = np.empty_like(arr_p)\n        arr_c[..., 0] = arr_p[..., 0] * np.sin(\n            arr_p[..., 1]) * np.cos(arr_p[..., 2])\n        arr_c[..., 1] = arr_p[..., 0] * np.sin(\n            arr_p[..., 1]) * np.sin(arr_p[..., 2])\n        arr_c[..., 2] = arr_p[..., 0] * np.cos(arr_p[..., 1])\n    else:\n        raise Exception('Invalid vector for polar representation')\n    return arr_c"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning cartesian vectors in their polar representation.", "response": "def cart_to_polar(arr_c):\n    \"\"\"Return cartesian vectors in their polar representation.\n\n    Parameters\n    ----------\n    arr_c: array, shape (a1, a2, ..., d)\n        Cartesian vectors, with last axis indexing the dimension.\n\n    Returns\n    -------\n    arr_p: array, shape of arr_c\n        Polar vectors, using (radius, inclination, azimuth) convention.\n    \"\"\"\n    if arr_c.shape[-1] == 1:\n        arr_p = arr_c.copy()\n    elif arr_c.shape[-1] == 2:\n        arr_p = np.empty_like(arr_c)\n        arr_p[..., 0] = vector_mag(arr_c)\n        arr_p[..., 1] = np.arctan2(arr_c[..., 1], arr_c[..., 0])\n    elif arr_c.shape[-1] == 3:\n        arr_p = np.empty_like(arr_c)\n        arr_p[..., 0] = vector_mag(arr_c)\n        arr_p[..., 1] = np.arccos(arr_c[..., 2] / arr_p[..., 0])\n        arr_p[..., 2] = np.arctan2(arr_c[..., 1], arr_c[..., 0])\n    else:\n        raise Exception('Invalid vector for polar representation')\n    return arr_p"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns vectors uniformly picked on the unit sphere.", "response": "def sphere_pick_polar(d, n=1, rng=None):\n    \"\"\"Return vectors uniformly picked on the unit sphere.\n    Vectors are in a polar representation.\n\n    Parameters\n    ----------\n    d: float\n        The number of dimensions of the space in which the sphere lives.\n    n: integer\n        Number of samples to pick.\n\n    Returns\n    -------\n    r: array, shape (n, d)\n        Sample vectors.\n    \"\"\"\n    if rng is None:\n        rng = np.random\n    a = np.empty([n, d])\n    if d == 1:\n        a[:, 0] = rng.randint(2, size=n) * 2 - 1\n    elif d == 2:\n        a[:, 0] = 1.0\n        a[:, 1] = rng.uniform(-np.pi, +np.pi, n)\n    elif d == 3:\n        u, v = rng.uniform(0.0, 1.0, (2, n))\n        a[:, 0] = 1.0\n        a[:, 1] = np.arccos(2.0 * v - 1.0)\n        a[:, 2] = 2.0 * np.pi * u\n    else:\n        raise Exception('Invalid vector for polar representation')\n    return a"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ball_pick(n, d, rng=None):\n    def valid(r):\n        return vector_mag_sq(r) < 1.0\n    return rejection_pick(L=2.0, n=n, d=d, valid=valid, rng=rng)", "response": "Return cartesian vectors uniformly picked on the unit ball in an arbitrary number of dimensions."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns vectors uniformly picked on the unit disk.", "response": "def disk_pick_polar(n=1, rng=None):\n    \"\"\"Return vectors uniformly picked on the unit disk.\n    The unit disk is the space enclosed by the unit circle.\n    Vectors are in a polar representation.\n\n    Parameters\n    ----------\n    n: integer\n        Number of points to return.\n\n    Returns\n    -------\n    r: array, shape (n, 2)\n        Sample vectors.\n    \"\"\"\n    if rng is None:\n        rng = np.random\n    a = np.zeros([n, 2], dtype=np.float)\n    a[:, 0] = np.sqrt(rng.uniform(size=n))\n    a[:, 1] = rng.uniform(0.0, 2.0 * np.pi, size=n)\n    return a"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef normalise_angle(th):\n    return th - (2.0 * np.pi) * np.floor((th + np.pi) / (2.0 * np.pi))", "response": "Normalise an angle to be in the range - pi pi."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef smallest_signed_angle(source, target):\n    dth = target - source\n    dth = (dth + np.pi) % (2.0 * np.pi) - np.pi\n    return dth", "response": "Find the smallest angle going from angle source to angle target."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef put(self, vpn_id: int) -> Vpn:\n        vpn = self._get_or_abort(vpn_id)\n        self.update(vpn)\n        session.commit()\n        return vpn", "response": "Updates the Vpn Resource with the given ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete the resource with the given name.", "response": "def delete(self, vpn_id: int):\n        \"\"\"\n        Deletes the resource with the given name.\n        \"\"\"\n        vpn = self._get_or_abort(vpn_id)\n        session.delete(vpn)\n        session.commit()\n        return '', 204"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates the vpn with the given data.", "response": "def post(self) -> Vpn:\n        \"\"\"\n        Creates the vpn with the given data.\n        \"\"\"\n        vpn = Vpn()\n        session.add(vpn)\n        self.update(vpn)\n        session.flush()\n        session.commit()\n        return vpn, 201, {\n            'Location': url_for('vpn', vpn_id=vpn.id)\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle_token(cls, parser, token):\n        tokens = token.contents.split()\n        if tokens[1] != 'for':\n            raise template.TemplateSyntaxError(\n                \"Second argument in %r tag must be 'for'\" % tokens[0]\n            )\n\n        # {% get_whatever for obj as varname %}\n        if len(tokens) == 5:\n            if tokens[3] != 'as':\n                raise template.TemplateSyntaxError(\"Third argument in %r must be 'as'\" % tokens[0])\n            return cls(\n                object_expr=parser.compile_filter(tokens[2]),\n                as_varname=tokens[4],\n            )\n\n        # {% get_whatever for app.model pk as varname %}\n        elif len(tokens) == 6:\n            if tokens[4] != 'as':\n                raise template.TemplateSyntaxError(\"Fourth argument in %r must be 'as'\" % tokens[0])\n            return cls(\n                ctype = BaseCommentNode.lookup_content_type(tokens[2], tokens[0]),\n                object_pk_expr = parser.compile_filter(tokens[3]),\n                as_varname = tokens[5]\n            )\n\n        else:\n            raise template.TemplateSyntaxError(\"%r tag requires 4 or 5 arguments\" % tokens[0])", "response": "Class method to parse get_comment_list / count / form and return a Node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef handle_token(cls, parser, token):\n        tokens = token.contents.split()\n        if tokens[1] != 'for':\n            raise template.TemplateSyntaxError(\"Second argument in %r tag must be 'for'\" % tokens[0])\n\n        # {% render_comment_list for obj %}\n        if len(tokens) == 3:\n            return cls(object_expr=parser.compile_filter(tokens[2]))\n\n        # {% render_comment_list for app.models pk %}\n        elif len(tokens) == 4:\n            return cls(\n                ctype = BaseCommentNode.lookup_content_type(tokens[2], tokens[0]),\n                object_pk_expr = parser.compile_filter(tokens[3])\n            )", "response": "Class method to parse render_comment_list and return a Node."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the calibration data for the current IMU if any.", "response": "def get_current_data(self):\n        \"\"\"Return the calibration data for the current IMU, if any.\"\"\"\n        if self.current_imuid in self.calibration_data:\n            return self.calibration_data[self.current_imuid]\n\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_battery(self):\n        if self.sk8 is None:\n            return\n        battery = self.sk8.get_battery_level()\n        self.lblBattery.setText('Battery: {}%'.format(battery))", "response": "Updates the battery level in the UI for the connected SK8"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle clicks on the IMU index spinner.", "response": "def imu_changed(self, val):\n        \"\"\"Handle clicks on the IMU index spinner.\"\"\"\n        self.current_imuid = '{}_IMU{}'.format(self.sk8.get_device_name(), val)\n        self.update_data_display(self.get_current_data())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef accel_calibration(self):\n        self.calibration_state = self.CAL_ACC\n        self.acc_dialog = SK8AccDialog(self.sk8.get_imu(self.spinIMU.value()), self)\n        if self.acc_dialog.exec_() == QDialog.Rejected:\n            return\n        \n        self.calculate_acc_calibration(self.acc_dialog.samples)", "response": "Perform accelerometer calibration for current IMU."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gyro_calibration(self):\n        QtWidgets.QMessageBox.information(self, 'Gyro calibration', 'Ensure the selected IMU is in a stable, unmoving position, then click OK. Don\\'t move the the IMU for a few seconds')\n        self.calibration_state = self.CAL_GYRO\n        self.gyro_dialog = SK8GyroDialog(self.sk8.get_imu(self.spinIMU.value()), self)\n        if self.gyro_dialog.exec_() == QDialog.Rejected:\n            return\n        \n        self.calculate_gyro_calibration(self.gyro_dialog.samples)", "response": "Perform gyroscope calibration for current IMU."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mag_calibration(self):\n        self.calibration_state = self.CAL_MAG\n        self.mag_dialog = SK8MagDialog(self.sk8.get_imu(self.spinIMU.value()), self)\n        if self.mag_dialog.exec_() == QDialog.Rejected:\n            return\n\n        self.calculate_mag_calibration(self.mag_dialog.samples)", "response": "Perform magnetometer calibration for current IMU."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the displayed data in the GUI for the current IMU.", "response": "def update_data(self):\n        \"\"\"Updates the displayed data in the GUI for the current IMU, applying\n        current calibration if it is available. \"\"\"\n        if self.sk8 is not None:\n            imu = self.spinIMU.value()\n            data = self.sk8.get_imu(imu)\n            if self.current_imuid in self.calibration_data:\n                calib_data = self.calibration_data[self.current_imuid]\n            else:\n                calib_data = {}\n                self.calibration_data[self.current_imuid] = calib_data\n\n            if calib_data is not None and self.ACC_TIMESTAMP in calib_data:\n                self.dataAccX.setText(str(int((data.acc[0] * float(calib_data[self.ACCX_SCALE])) - float(calib_data[self.ACCX_OFFSET]))))\n                self.dataAccY.setText(str(int((data.acc[1] * float(calib_data[self.ACCY_SCALE])) - float(calib_data[self.ACCY_OFFSET]))))\n                self.dataAccZ.setText(str(int((data.acc[2] * float(calib_data[self.ACCZ_SCALE])) - float(calib_data[self.ACCZ_OFFSET]))))\n            else:\n                self.dataAccX.setText(str(data.acc[0]))\n                self.dataAccY.setText(str(data.acc[1]))\n                self.dataAccZ.setText(str(data.acc[2]))\n\n            if calib_data is not None and self.GYRO_TIMESTAMP in calib_data:\n                self.dataGyroX.setText(str(data.gyro[0] - int(calib_data[self.GYROX_OFFSET])))\n                self.dataGyroY.setText(str(data.gyro[1] - int(calib_data[self.GYROY_OFFSET])))\n                self.dataGyroZ.setText(str(data.gyro[2] - int(calib_data[self.GYROZ_OFFSET])))\n            else:\n                self.dataGyroX.setText(str(data.gyro[0]))\n                self.dataGyroY.setText(str(data.gyro[1]))\n                self.dataGyroZ.setText(str(data.gyro[2]))\n\n            if calib_data is not None and self.MAG_TIMESTAMP in calib_data:\n                self.dataAccX.setText(str(int((data.mag[0] * float(calib_data[self.MAGX_SCALE])) - float(calib_data[self.MAGX_OFFSET]))))\n                self.dataAccY.setText(str(int((data.mag[1] * float(calib_data[self.MAGY_SCALE])) - float(calib_data[self.MAGY_OFFSET]))))\n                self.dataAccZ.setText(str(int((data.mag[2] * float(calib_data[self.MAGZ_SCALE])) - float(calib_data[self.MAGZ_OFFSET]))))\n            else:\n                self.dataMagX.setText(str(data.mag[0]))\n                self.dataMagY.setText(str(data.mag[1]))\n                self.dataMagZ.setText(str(data.mag[2]))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the gyroscope bias values for the current SK8 and stores them in the calibration data structure for the current SK8.", "response": "def calculate_gyro_calibration(self, gyro_samples):\n        \"\"\"Performs a basic gyroscope bias calculation. \n\n        Takes a list of (x, y, z) samples and averages over each axis to calculate\n        the bias values, and stores them in the calibration data structure for the \n        currently connected SK8\"\"\"\n\n        totals = [0, 0, 0]\n        for gs in gyro_samples:\n            totals[0] += gs[0]\n            totals[1] += gs[1]\n            totals[2] += gs[2]\n\n        for i in range(3):\n            totals[i] = int(float(totals[i]) / len(gyro_samples))\n\n        print('Saving gyro offsets for {}'.format(self.current_imuid))\n        self.calibration_data[self.current_imuid][self.GYROX_OFFSET] = str(totals[0])\n        self.calibration_data[self.current_imuid][self.GYROY_OFFSET] = str(totals[1])\n        self.calibration_data[self.current_imuid][self.GYROZ_OFFSET] = str(totals[2])\n        self.calibration_data[self.current_imuid][self.GYRO_TIMESTAMP] = datetime.now().isoformat()\n        self.write_calibration_data()\n        self.update_data_display(self.calibration_data[self.current_imuid])\n        self.calibration_state = self.CAL_NONE"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the accelerometer calibration for the current application.", "response": "def calculate_acc_calibration(self, acc_samples):\n        \"\"\"Performs accelerometer calibration. Assumes acc_samples contains samples\n        in order [+x, -x, +y, -y, +z, -z]. Calculates per-axis scale/offset values\"\"\"\n\n        # assumes 2g range\n        data = self.calibration_data[self.current_imuid]\n        accx_pos = sum([x[0] for x in acc_samples[0]]) / float(len(acc_samples[0]))\n        accx_neg = sum([x[0] for x in acc_samples[1]]) / float(len(acc_samples[1]))\n        accy_pos = sum([y[1] for y in acc_samples[2]]) / float(len(acc_samples[2]))\n        accy_neg = sum([y[1] for y in acc_samples[3]]) / float(len(acc_samples[3]))\n        accz_pos = sum([z[2] for z in acc_samples[4]]) / float(len(acc_samples[4]))\n        accz_neg = sum([z[2] for z in acc_samples[5]]) / float(len(acc_samples[5]))\n        data[self.ACCX_SCALE] = str(2000.0 / (accx_pos - accx_neg))\n        data[self.ACCY_SCALE] = str(2000.0 / (accy_pos - accy_neg))\n        data[self.ACCZ_SCALE] = str(2000.0 / (accz_pos - accz_neg))\n\n        data[self.ACCX_OFFSET] = str(int((accx_pos + accx_neg) / 2.0))\n        data[self.ACCY_OFFSET] = str(int((accy_pos + accy_neg) / 2.0))\n        data[self.ACCZ_OFFSET] = str(int((accz_pos + accz_neg) / 2.0))\n\n        data[self.ACC_TIMESTAMP] = datetime.now().isoformat()\n\n        self.write_calibration_data()\n        self.update_data_display(self.calibration_data[self.current_imuid])\n        self.calibration_state = self.CAL_NONE"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the magnetometer calibration for the current calendar.", "response": "def calculate_mag_calibration(self, mag_samples):\n        \"\"\"Performs magnetometer calibration. Assumes mag_samples contains samples\n        in order [+x, -x, +y, -y, +z, -z]. Calculates per-axis scale/offset values\"\"\"\n\n        max_vals = [mag_samples[0][0], mag_samples[2][1], mag_samples[3][2]]\n        min_vals = [mag_samples[1][0], mag_samples[3][1], mag_samples[5][2]]\n\n        magbiases = [int((max_vals[i] + min_vals[i]) / 2.0) for i in range(3)]\n        magscalings = [(max_vals[i] - min_vals[i]) / 2.0 for i in range(3)]\n        avg_rads = sum(magscalings) / 3.0\n        magscalings = [avg_rads / magscalings[i] for i in range(3)]\n\n        data = self.calibration_data[self.current_imuid]\n\n        data[self.MAGX_OFFSET] = str(int(magbiases[0]))\n        data[self.MAGY_OFFSET] = str(int(magbiases[1]))\n        data[self.MAGZ_OFFSET] = str(int(magbiases[2]))\n        \n        data[self.MAGX_SCALE] = str(magscalings[0])\n        data[self.MAGY_SCALE] = str(magscalings[1])\n        data[self.MAGZ_SCALE] = str(magscalings[2])\n\n        data[self.MAG_TIMESTAMP] = datetime.now().isoformat()\n\n        self.write_calibration_data()\n        self.update_data_display(self.calibration_data[self.current_imuid])\n        self.calibration_state = self.CAL_NONE"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef device_selected(self, index):\n        device = self.devicelist_model.itemFromIndex(index)\n        print(device.device.addr)\n        self.btnConnect.setEnabled(True)", "response": "Handler for selecting a device from the list in the UI"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert an integer to a Roman number.", "response": "def int_to_roman(num):\n    \"\"\"\n    https://stackoverflow.com/questions/42875103/integer-to-roman-number\n    https://stackoverflow.com/questions/33486183/convert-from-numbers-to-roman-notation\n    \"\"\"\n    conv = (\n        (\"M\", 1000),\n        (\"CM\", 900),\n        (\"D\", 500),\n        (\"CD\", 400),\n        (\"C\", 100),\n        (\"XC\", 90),\n        (\"L\", 50),\n        (\"XL\", 40),\n        (\"X\", 10),\n        (\"IX\", 9),\n        (\"V\", 5),\n        (\"IV\", 4),\n        (\"I\", 1)\n    )\n    roman = \"\"\n    i = 0\n    while num > 0:\n        while conv[i][1] > num:\n            i += 1\n        roman += conv[i][0]\n        num -= conv[i][1]\n    return roman"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef roman_to_int(roman):\n    vals = {\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n        \"C\": 100,\n        \"D\": 500,\n        \"M\": 1000,\n    }\n    total = 0\n    lastValue = sys.maxsize\n    for char in list(roman):\n        value = vals[char.upper()]\n        if value > lastValue:\n            total += value - 2 * lastValue\n        else:\n            total += value\n        lastValue = value\n    return total", "response": "Convert a Roman string to an integer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _handle_block(self, task, disable=False):\n\n        backup_file = os.path.join(task.task_dir, '.hosts.bak')\n        self.orig_data = self.orig_data or common.readfile(backup_file)\n        self.last_updated = self.last_updated or -1\n\n        if not self.orig_data:\n            # should't attempt restore without good original data, bail\n            if disable:\n                return False\n\n            # attempt to fetch data from the source\n            self.orig_data = common.readfile(self.hosts_file)\n            if not self.orig_data:\n                return False\n\n        # restore backup\n        if not os.path.exists(backup_file):\n            common.writefile(backup_file, self.orig_data)\n\n        # bail early if hosts file modification time hasn't changed\n        try:\n            should_write = (disable or self.last_updated\n                            != os.path.getmtime(self.hosts_file))\n\n        except OSError:\n            should_write = True  # file was removed, let's write!\n\n        if not should_write:\n            return True\n\n        # make copy of original data, in case we need to modify\n        data = self.orig_data\n\n        # if not restoring, tack on domains mapped\n        # to localhost to end of file data\n        if not disable:\n            # convert the set to a list and sort\n            domains = list(self.domains)\n            domains.sort()\n\n            data += ('\\n'.join('127.0.0.1\\t{0}\\t# FOCUS'\n                     .format(d) for d in domains) + '\\n')\n\n        # make temp file with new host file data\n        with tempfile.NamedTemporaryFile(prefix='focus_') as tempf:\n            tempf.write(data)\n            tempf.flush()\n\n            # overwrite hosts file with our modified copy.\n            if not self.run_root('cp \"{0}\" \"{1}\"'.format(tempf.name,\n                                                         self.hosts_file)):\n                return False\n\n            # MacOS X generally requires flushing the system dns cache to pick\n            # up changes to the hosts file:\n            #   dscacheutil -flushcache or lookupd -flushcache\n            if common.IS_MACOSX:\n                dscacheutil, lookupd = [common.which(x) for x in\n                                        ('dscacheutil', 'lookupd')]\n                self.run_root(' '.join([dscacheutil or lookupd,\n                                        '-flushcache']))\n\n        if disable:\n            common.safe_remove_file(backup_file)  # cleanup the backup\n\n        # store last modification time\n        try:\n            self.last_updated = os.path.getmtime(self.hosts_file)\n\n        except OSError:\n            # file was removed, let's update next time around\n            self.last_updated = -1\n\n        return True", "response": "Handles blocking domains using hosts file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_option(self, option, block_name, *values):\n        _extra_subs = ('www', 'm', 'mobile')\n\n        if len(values) == 0:  # expect some values here..\n            raise ValueError\n\n        for value in values:\n            value = value.lower()\n\n            # if it doesn't look like a protocol, assume http\n            # (e.g. only domain supplied)\n            if not _RE_PROTOCOL.match(value):\n                value = 'http://' + value\n\n            # did it parse? pull hostname/domain\n            parsed = urlparse.urlparse(value)\n            if parsed:\n                domain = parsed.hostname\n\n                if domain and _RE_TLD.search(domain):  # must have a TLD\n                    # doesn't have subdomain, tack on www, m, and mobile\n                    # for good measure. note, this check fails for\n                    # multi-part TLDs, e.g. .co.uk\n                    domain = _RE_WWW_SUB.sub('', domain)  # strip \"www.\"\n\n                    if len(domain.split('.')) == 2:\n                        for sub in _extra_subs:\n                            self.domains.add('{0}.{1}'.format(sub, domain))\n\n                    self.domains.add(domain)\n\n        # no domains.. must have failed\n        if not self.domains:\n            raise ValueError", "response": "Parse option.\n            and add to self. domains."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating url - safe signed token.", "response": "def sign(self, data):\n        \"\"\" Create url-safe signed token.\n\n        :param data: Data to sign\n        :type data: object\n        \"\"\"\n        try:\n            jsonstr = json.dumps(data, separators=(',', ':'))\n\n        except TypeError as e:\n            raise DataSignError(e.args[0])\n\n        else:\n            signature = self._create_signature(jsonstr)\n            return self._b64encode(jsonstr + '.' + signature)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unsign(self, b64msg):\n        msg = self._b64decode(b64msg)\n        try:\n            body, signature = msg.rsplit('.', 1)\n\n        except ValueError as e:\n            raise MalformedSigendMessage(e.args[0])\n\n        else:\n            if signature == self._create_signature(body):\n                try:\n                    return json.loads(body)\n\n                except ValueError as e:\n                    raise MalformedSigendMessage(e.args[0])\n\n            else:\n                raise BadSignature()", "response": "Returns data from signed token."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract file name from the input request body", "response": "def extract_file_name(content_dispo):\n    \"\"\"Extract file name from the input request body\"\"\"\n    # print type(content_dispo)\n    # print repr(content_dispo)\n    # convertion of escape string (str type) from server\n    # to unicode object\n    content_dispo = content_dispo.decode('unicode-escape').strip('\"')\n    file_name = \"\"\n    for key_val in content_dispo.split(';'):\n        param = key_val.strip().split('=')\n        if param[0] == \"filename\":\n            file_name = param[1].strip('\"')\n            break\n    return file_name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting ressources store into LinShare.", "response": "def list(self, url):\n        \"\"\" List ressources store into LinShare.\"\"\"\n        url = self.get_full_url(url)\n        self.log.debug(\"list url : \" + url)\n        # Building request\n        request = urllib2.Request(url)\n        request.add_header('Content-Type', 'application/json; charset=UTF-8')\n        request.add_header('Accept', 'application/json')\n        # Do request\n        ret = self.do_request(request)\n        self.log.debug(\"\"\"list url : %(url)s : request time : %(time)s\"\"\",\n                       {\"url\": url,\n                        \"time\": self.last_req_time})\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, url, data):\n        url = self.get_full_url(url)\n        self.log.debug(\"update url : \" + url)\n        # Building request\n        post_data = json.dumps(data).encode(\"UTF-8\")\n        request = urllib2.Request(url, post_data)\n        request.add_header('Content-Type', 'application/json; charset=UTF-8')\n        request.add_header('Accept', 'application/json')\n        request.get_method = lambda: 'PUT'\n        # Do request\n        ret = self.do_request(request)\n        self.log.debug(\"\"\"put url : %(url)s : request time : %(time)s\"\"\",\n                       {\"url\": url,\n                        \"time\": self.last_req_time})\n        return ret", "response": "update ressources store into LinShare."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndownload a file from LinShare using its rest api", "response": "def download(self, uuid, url, forced_file_name=None,\n                 progress_bar=True, chunk_size=256,\n                 directory=None, overwrite=False):\n        \"\"\" download a file from LinShare using its rest api.\n        This method could throw exceptions like urllib2.HTTPError.\"\"\"\n        self.last_req_time = None\n        url = self.get_full_url(url)\n        self.log.debug(\"download url : \" + url)\n        # Building request\n        request = urllib2.Request(url)\n        # request.add_header('Content-Type', 'application/json; charset=UTF-8')\n        request.add_header('Accept', 'application/json,*/*;charset=UTF-8')\n        # request start\n        starttime = datetime.datetime.now()\n        # doRequest\n        resultq = urllib2.urlopen(request)\n        code = resultq.getcode()\n        file_name = uuid\n        self.log.debug(\"ret code : '\" + str(code) + \"'\")\n        if code == 200:\n            content_lenth = resultq.info().getheader('Content-Length')\n            if not content_lenth:\n                msg = \"No content lengh header found !\"\n                self.log.debug(msg)\n                progress_bar = False\n            else:\n                file_size = int(content_lenth.strip())\n            if forced_file_name:\n                file_name = forced_file_name\n            else:\n                content_dispo = resultq.info().getheader('Content-disposition')\n                if content_dispo:\n                    content_dispo = content_dispo.strip()\n                    file_name = extract_file_name(content_dispo)\n            if directory:\n                if os.path.isdir(directory):\n                    file_name = directory + \"/\" + file_name\n            if os.path.isfile(file_name):\n                if not overwrite:\n                    cpt = 1\n                    while 1:\n                        if not os.path.isfile(file_name + \".\" + str(cpt)):\n                            file_name += \".\" + str(cpt)\n                            break\n                        cpt += 1\n                else:\n                    self.log.warn(\"'%s' already exists. It was overwriten.\",\n                                  file_name)\n            stream = None\n            pbar = None\n            if progress_bar:\n                widgets = [FileTransferSpeed(), ' <<<', Bar(), '>>> ',\n                           Percentage(), ' ', ETA()]\n                pbar = ProgressBar(widgets=widgets, maxval=file_size)\n                stream = FileWithCallback(file_name, 'w', pbar.update,\n                                          file_size, file_name)\n                pbar.start()\n            else:\n                stream = file(file_name, 'w')\n            while 1:\n                chunk = resultq.read(chunk_size)\n                if not chunk:\n                    break\n                stream.write(chunk)\n            stream.flush()\n            stream.close()\n            if pbar:\n                pbar.finish()\n        # request end\n        endtime = datetime.datetime.now()\n        self.last_req_time = str(endtime - starttime)\n        self.log.debug(\"download url : %(url)s : request time : %(time)s\",\n                       {\"url\": url,\n                        \"time\": self.last_req_time})\n        return (file_name, self.last_req_time)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_field(self, field, arg=None, value=None, extended=False,\n                  hidden=False, e_type=str, required=None):\n        \"\"\"Add a new field to the current ResourceBuilder.\n\n           Keyword arguments:\n           field    -- field name\n           arg      -- name of the attribute name in arg object (argparse)\n           value    -- a default for this field, used for resource creation.\n           extended -- If set to true, the current field will be display in\n                       extended list mode only.\n           hidden   -- If set to true, the current field won't be exposed\n                       as available keys.\n           e_type   -- field data type (default str): int, float, str\n           required -- True if the current field is required for create\n                       and update methods\n        \"\"\"\n        if required is None:\n            required = self._required\n        if arg is None:\n            arg = re.sub('(?!^)([A-Z]+)', r'_\\1', field).lower()\n        self._fields[field] = {\n            'field': field,\n            'arg': arg,\n            'value': value,\n            'extended': extended,\n            'required': required,\n            'e_type': e_type,\n            'hidden': hidden\n        }", "response": "Add a new field to the current resource builder."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun the shell operator synchronously to eat in_batches.", "response": "def run(self, in_batches):\n        \"\"\"Run shell operator synchronously to eat `in_batches`\n\n        :param in_batches: `tuple` of batches to process\n        \"\"\"\n        if len(in_batches) != len(self._batcmd.batch_to_file_s):\n            BaseShellOperator._rm_process_input_tmpfiles(self._batcmd.batch_to_file_s)  # [todo] - Removing tmpfiles can be easily forgot. Less lifetime for tmpfile.\n            raise AttributeError('len(in_batches) == %d, while %d IN_BATCH* are specified in command below:%s$ %s' %\n                                 (len(in_batches), len(self._batcmd.batch_to_file_s), os.linesep, self._batcmd.sh_cmd))\n\n        # prepare & start process (if necessary)\n        BaseShellOperator._batches_to_tmpfile(self._in_record_sep, self._in_column_sep, in_batches, self._batcmd.batch_to_file_s)\n        if self._process is None:\n            self._process = BaseShellOperator._start_process(\n                self._batcmd, self._cwd, self._env,\n                non_blocking_stdout=True)\n\n        # Begin thread to read from subprocess's stdout.\n        # Without this thread, subprocess's output buffer becomes full and no one solves it.\n        t_consumer = Thread(target=get_subprocess_output,\n                            args=(self._process.stdout, self._batch_done_output, self._subprocess_out_str))\n        t_consumer.start()\n\n        # pass batch to subprocess\n        BaseShellOperator._batch_to_stdin(self._process, self._in_record_sep, self._in_column_sep,\n                                          in_batches, self._batcmd.batch_to_file_s)\n\n        # pass batch-done indicator to subprocess\n        self._process.stdin.write(self._batch_done_indicator)\n\n        # get output from subprocess\n        t_consumer.join()\n        subprocess_out_str       = self._subprocess_out_str[0]\n        self._subprocess_out_str = []\n        out_batch = BaseShellOperator._out_str_to_batch(subprocess_out_str,\n                                                        self._out_recdef, self._out_col_patterns)\n        return out_batch"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nkilling the instantiated process.", "response": "def kill(self):\n        \"\"\"Kill instantiated process\n\n        :raises: `AttributeError` if instantiated process doesn't seem to satisfy `constraints <relshell.daemon_shelloperator.DaemonShellOperator>`_\n        \"\"\"\n        BaseShellOperator._close_process_input_stdin(self._batcmd.batch_to_file_s)\n        BaseShellOperator._wait_process(self._process, self._batcmd.sh_cmd, self._success_exitcodes)\n        BaseShellOperator._rm_process_input_tmpfiles(self._batcmd.batch_to_file_s)\n        self._process = None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef env_int(name, required=False, default=empty):\n    value = get_env_value(name, required=required, default=default)\n    if value is empty:\n        raise ValueError(\n            \"`env_int` requires either a default value to be specified, or for \"\n            \"the variable to be present in the environment\"\n        )\n    return int(value)", "response": "Pulls an environment variable out of the environment and casts it to an integer."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef env_float(name, required=False, default=empty):\n    value = get_env_value(name, required=required, default=default)\n    if value is empty:\n        raise ValueError(\n            \"`env_float` requires either a default value to be specified, or for \"\n            \"the variable to be present in the environment\"\n        )\n    return float(value)", "response": "Pulls an environment variable out of the environment and casts it to a float."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npull an environment variable out of the environment and returns it as a boolean.", "response": "def env_bool(name, truthy_values=TRUE_VALUES, required=False, default=empty):\n    \"\"\"Pulls an environment variable out of the environment returning it as a\n    boolean. The strings ``'True'`` and ``'true'`` are the default *truthy*\n    values. If not present in the environment and no default is specified,\n    ``None`` is returned.\n\n    :param name: The name of the environment variable be pulled\n    :type name: str\n\n    :param truthy_values: An iterable of values that should be considered\n    truthy.\n    :type truthy_values: iterable\n\n    :param required: Whether the environment variable is required. If ``True``\n    and the variable is not present, a ``KeyError`` is raised.\n    :type required: bool\n\n    :param default: The value to return if the environment variable is not\n    present. (Providing a default alongside setting ``required=True`` will raise\n    a ``ValueError``)\n    :type default: bool\n    \"\"\"\n    value = get_env_value(name, required=required, default=default)\n    if value is empty:\n        return None\n    return value in TRUE_VALUES"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef env_string(name, required=False, default=empty):\n    value = get_env_value(name, default=default, required=required)\n    if value is empty:\n        value = ''\n    return value", "response": "Pulls an environment variable out of the environment and returns it as a\n    string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef env_list(name, separator=',', required=False, default=empty):\n    value = get_env_value(name, required=required, default=default)\n    if value is empty:\n        return []\n    # wrapped in list to force evaluation in python 3\n    return list(filter(bool, [v.strip() for v in value.split(separator)]))", "response": "Pulls an environment variable out of the environment and returns it as a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef env_timestamp(name, required=False, default=empty):\n    if required and default is not empty:\n        raise ValueError(\"Using `default` with `required=True` is invalid\")\n\n    value = get_env_value(name, required=required, default=empty)\n    # change datetime.datetime to time, return time.struct_time type\n    if default is not empty and value is empty:\n        return default\n    if value is empty:\n        raise ValueError(\n            \"`env_timestamp` requires either a default value to be specified, \"\n            \"or for the variable to be present in the environment\"\n        )\n\n    timestamp = float(value)\n    return datetime.datetime.fromtimestamp(timestamp)", "response": "Pulls an environment variable out of the environment and parses it into a datetime. struct_time object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npulling an environment variable out of the environment and parses it to an ISO 8601 formatted string.", "response": "def env_iso8601(name, required=False, default=empty):\n    \"\"\"Pulls an environment variable out of the environment and parses it to a\n    ``datetime.datetime`` object. The environment variable is expected to be an\n    iso8601 formatted string.\n\n    If the name is not present in the environment and no default is specified\n    then a ``ValueError`` will be raised.\n\n    :param name: The name of the environment variable be pulled\n    :type name: str\n\n    :param required: Whether the environment variable is required. If ``True``\n    and the variable is not present, a ``KeyError`` is raised.\n    :type required: bool\n\n    :param default: The value to return if the environment variable is not\n    present. (Providing a default alongside setting ``required=True`` will raise\n    a ``ValueError``)\n    :type default: bool\n    \"\"\"\n    try:\n        import iso8601\n    except ImportError:\n        raise ImportError(\n            'Parsing iso8601 datetime strings requires the iso8601 library'\n        )\n\n    if required and default is not empty:\n        raise ValueError(\"Using `default` with `required=True` is invalid\")\n\n    value = get_env_value(name, required=required, default=empty)\n    # change datetime.datetime to time, return time.struct_time type\n    if default is not empty and value is empty:\n        return default\n    if value is empty:\n        raise ValueError(\n            \"`env_iso8601` requires either a default value to be specified, or \"\n            \"for the variable to be present in the environment\"\n        )\n    return iso8601.parse_date(value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(name, required=False, default=empty, type=None):\n    fn = {\n        'int': env_int,\n        int: env_int,\n\n        'bool': env_bool,\n        bool: env_bool,\n\n        'string': env_string,\n        str: env_string,\n\n        'list': env_list,\n        list: env_list,\n\n        'timestamp': env_timestamp,\n        datetime.time: env_timestamp,\n\n        'datetime': env_iso8601,\n        datetime.datetime: env_iso8601,\n    }.get(type, env_string)\n    return fn(name, default=default, required=required)", "response": "Generic getter for environment variables. Handles defaults required -ness default and type to expect."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_es_workers(self, **kwargs):\n        def make_es_worker(search_conn, es_index, es_doc_type, class_name):\n            \"\"\"\n            Returns a new es_worker instance\n\n            args:\n            -----\n                search_conn: the connection to elasticsearch\n                es_index: the name of the elasticsearch index\n                es_doc_type: the name of the elasticsearch doctype\n                class_name: name of the rdf class that is being indexed\n            \"\"\"\n            new_esbase = copy.copy(search_conn)\n            new_esbase.es_index = es_index\n            new_esbase.doc_type = es_doc_type\n            log.info(\"Indexing '%s' into ES index '%s' doctype '%s'\",\n                     class_name.pyuri,\n                     es_index,\n                     es_doc_type)\n            return new_esbase\n\n        def additional_indexers(rdf_class):\n            \"\"\"\n            returns additional classes to index based off of the es definitions\n            \"\"\"\n            rtn_list = rdf_class.es_indexers()\n            rtn_list.remove(rdf_class)\n            return rtn_list\n\n\n        self.es_worker = make_es_worker(self.search_conn,\n                                        self.es_index,\n                                        self.es_doc_type,\n                                        self.rdf_class.__name__)\n        if not kwargs.get(\"idx_only_base\"):\n            self.other_indexers = {item.__name__: make_es_worker(\n                        self.search_conn,\n                        item.es_defs.get('kds_esIndex')[0],\n                        item.es_defs.get('kds_esDocType')[0],\n                        item.__name__)\n                    for item in additional_indexers(self.rdf_class)}\n        else:\n            self.other_indexers = {}", "response": "Sets the self. es_worker and self. other_indexers to be used for indexing the base class of the rdf class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _index_sub(self, uri_list, num, batch_num):\n        bname = '%s-%s' % (batch_num, num)\n        log.debug(\"batch_num '%s' starting es_json conversion\",\n                  bname)\n        qry_data = get_all_item_data([item[0] for item in uri_list],\n                                     self.tstore_conn,\n                                     rdfclass=self.rdf_class)\n        log.debug(\"batch_num '%s-%s' query_complete | count: %s\",\n                  batch_num,\n                  num,\n                  len(qry_data))\n        # path = os.path.join(CFG.dirs.cache, \"index_pre\")\n        # if not os.path.exists(path):\n        #     os.makedirs(path)\n        # with open(os.path.join(path, bname + \".json\"), \"w\") as fo:\n        #     fo.write(json.dumps(qry_data))\n        data = RdfDataset(qry_data)\n        del qry_data\n        log.debug(\"batch_num '%s-%s' RdfDataset Loaded\", batch_num, num)\n        for value in uri_list:\n            try:\n\n                self.batch_data[batch_num]['main'].append(\\\n                        data[value[0]].es_json())\n                self.count += 1\n            except KeyError:\n                pass\n        for name, indexer in self.other_indexers.items():\n            for item in data.json_qry(\"$.:%s\" % name.pyuri):\n                val = item.es_json()\n                if val:\n                    self.batch_data[batch_num][name].append(val)\n                    self.batch_uris[batch_num].append(item.subject)\n        del data\n        del uri_list\n        log.debug(\"batch_num '%s-%s' converted to es_json\", batch_num, num)", "response": "Convert a list of uris to elasticsearch json objects"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_uri_list(self, **kwargs):\n        index_status_filter = \"\"\"\n                optional {{ ?s dcterm:modified ?modTime }} .\n                optional {{ ?s kds:esIndexTime ?time }} .\n                optional {{ ?s kds:esIndexError ?error }}\n                filter (\n                    !(bound(?time)) ||\n                    ?time<?modTime  ||\n                    (bound(?error) && ?time < {idx_start_time}))\n                \"\"\".format(idx_start_time=self.idx_start_time.sparql)\n        items_query_template = \"\"\"\n            SELECT DISTINCT ?s ?es_id\n            {{\n                VALUES ?rdftypes {{\\n\\t\\t{rdf_types} }} .\n                ?s a ?rdftypes .\n                BIND(SHA1(STR(?s)) as ?es_id) .\n                {status_filter}\n            }}\n            {order_by}\n            \"\"\"\n        status_filter = index_status_filter \\\n                        if not kwargs.get(\"no_status\") else \"\"\n        order_by = kwargs.get(\"order_by\", \"\")\n        sparql = items_query_template.format(\n                rdf_types=\"\\n\\t\\t\".join(self.rdf_types),\n                status_filter=status_filter,\n                order_by=order_by)\n        results = [(Uri(item['s']['value']), item['es_id']['value'],)\n                   for item in self.tstore_conn.query(sparql=sparql)]\n        return results", "response": "Returns a list of Uris to index\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nindexing all the URIs defined by the query into Elasticsearch", "response": "def _index_group_with_subgroup(self, **kwargs):\n        \"\"\" indexes all the URIs defined by the query into Elasticsearch \"\"\"\n\n        log.setLevel(self.log_level)\n        # get a list of all the uri to index\n        uri_list = kwargs.get('uri_list', self.get_uri_list())\n        if not uri_list:\n            log.info(\"0 items to index\")\n            return\n        # results = results[:100]\n        # Start processing through uri\n        batch_file = os.path.join(CFG.dirs.logs, \"batch_list.txt\")\n        # with open(batch_file, \"w\") as fo:\n        #     fo.write(\"{\")\n        log.info(\"'%s' items to index\", len(uri_list))\n        self.time_start = datetime.datetime.now()\n        batch_size = kwargs.get(\"batch_size\", 12000)\n        if len(uri_list) > batch_size:\n            batch_end = batch_size\n        else:\n            batch_end = len(uri_list)\n        batch_start = 0\n        batch_num = 1\n        self.batch_data = {}\n        self.batch_data[batch_num] = {}\n        self.batch_data[batch_num]['main'] = []\n        self.batch_uris = {}\n        self.batch_uris[batch_num] = []\n        for name, indexer in self.other_indexers.items():\n            self.batch_data[batch_num][name] = []\n        end = False\n        last = False\n        final_list = []\n        expand_index = kwargs.get(\"expand_index\", True)\n        while not end:\n            log.debug(\"batch %s: %s-%s\", batch_num, batch_start, batch_end)\n            sub_batch = []\n            j = 0\n            for i in range(batch_start, batch_end):\n            # for i, subj in enumerate(uri_list[batch_start:batch_end]):\n                qry_size = kwargs.get(\"qry_size\", 1000)\n                if j < qry_size:\n                    try:\n                        sub_batch.append(uri_list.pop()) #subj)\n                    except IndexError:\n                        pass\n                if j == qry_size -1 or i == batch_end - 1:\n                    try:\n                        sub_batch.append(uri_list.pop()) #subj)\n                    except IndexError:\n                        pass\n                    # with open(batch_file, \"a\") as fo:\n                    #     fo.write(json.dumps({str('%s-%s' % (batch_num, i+1)):\n                    #                          [item[0].sparql\n                    #                           for item in sub_batch]})[1:-1]+\",\\n\")\n                    if not kwargs.get(\"no_threading\", False):\n                        th = threading.Thread(name=batch_start + i + 1,\n                                              target=self._index_sub,\n                                              args=(sub_batch,\n                                                    i+1,\n                                                    batch_num,))\n                        th.start()\n                    else:\n                        self._index_sub(sub_batch, i+1, batch_num)\n                    j = 0\n                    final_list += sub_batch\n                    sub_batch = []\n                else:\n                    j += 1\n            log.debug(datetime.datetime.now() - self.time_start)\n            if not kwargs.get(\"no_threading\", False):\n                main_thread = threading.main_thread()\n                for t in threading.enumerate():\n                    if t is main_thread:\n                        continue\n                    t.join()\n            action_list = []\n            for key, items in self.batch_data[batch_num].items():\n                if key == 'main':\n                    es_worker = self.es_worker\n                else:\n                    es_worker = self.other_indexers[key]\n                action_list += es_worker.make_action_list(items)\n            result = self.es_worker.bulk_save(action_list)\n            final_list += self.batch_uris[batch_num]\n            self._update_triplestore(result, action_list)\n            del action_list\n            del self.batch_uris[batch_num]\n            del self.batch_data[batch_num]\n            try:\n                del pyrdf.memorized\n                pyrdf.memorized = {}\n            except AttributeError:\n                pass\n            while gc.collect() > 0:\n                pass\n            # pdb.set_trace()\n            batch_end += batch_size\n            batch_start += batch_size\n            if last:\n                end = True\n            if len(uri_list) <= batch_size:\n                batch_end = len(uri_list)\n                last = True\n            batch_num += 1\n            self.batch_uris[batch_num] = []\n            self.batch_data[batch_num] = {}\n            self.batch_data[batch_num]['main'] = []\n            for name, indexer in self.other_indexers.items():\n                self.batch_data[batch_num][name] = []\n            log.debug(datetime.datetime.now() - self.time_start)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _update_triplestore(self, es_result, action_list, **kwargs):\n        idx_time = XsdDatetime(datetime.datetime.utcnow())\n        uri_keys = {}\n        bnode_keys = {}\n        for item in action_list:\n            try:\n                uri_keys[item['_id']] = item['_source'][\"uri\"]\n            except KeyError:\n                bnode_keys[item['_id']] = item['_id']\n        error_dict = {}\n        error_bnodes = {}\n        if es_result[1]:\n            for result in es_result[1]:\n                err_item = list(result.values())[0]\n                try:\n                    error_dict[uri_keys.pop(err_item['_id'])] = \\\n                            XsdString(err_item['error']['reason'])\n                except KeyError:\n                    error_bnodes[bnode_keys.pop(err_item['_id'])] = \\\n                            XsdString(err_item['error']['reason'])\n        if uri_keys:\n            sparql_good = \"\"\"\n                DELETE\n                {{\n                    ?s kds:esIndexTime ?esTime .\n                    ?s kds:esIndexError ?esError .\n                }}\n                INSERT\n                {{\n                    GRAPH ?g {{ ?s kds:esIndexTime {idx_time} }}.\n                }}\n                WHERE\n                {{\n                    VALUES ?s {{ {subj_list} }} .\n                    {{\n                        SELECT DISTINCT ?g ?s ?esTime ?esError\n                        {{\n                            GRAPH ?g {{ ?s ?p ?o }} .\n                            OPTIONAL {{\n                                ?s kds:esIndexTime ?esTime\n                            }}\n                            OPTIONAL {{\n                                ?s kds:esIndexError ?esError\n                            }}\n                        }}\n                    }}\n                }}\n                \"\"\".format(idx_time=idx_time.sparql,\n                           subj_list=\"<%s>\" % \">\\n<\".join(uri_keys.values()))\n            self.tstore_conn.update_query(sparql_good)\n        # Process any errors that were found.\n        if not error_dict:\n            return\n        # Delete all indexing triples related to the error subjects\n        sparql_error = \"\"\"\n            DELETE\n            {{\n                ?s kds:esIndexTime ?esTime .\n                ?s kds:esIndexError ?esError .\n            }}\n            WHERE\n            {{\n                VALUES ?s {{ {subj_list} }} .\n                OPTIONAL {{\n                    ?s kds:esIndexTime ?esTime\n                }}\n                OPTIONAL {{\n                    ?s kds:esIndexError ?esError\n                }}\n            }}\n            \"\"\".format(subj_list=\"<%s>\" % \">\\n<\".join(error_dict.keys()))\n        self.tstore_conn.update_query(sparql_error)\n        del sparql_error\n        sparql_update = \"\"\"\n            INSERT\n            {{\n                GRAPH ?g {{\n                    ?s kds:esIndexTime {idx_time} .\n                    ?s kds:esIndexError ?esError .\n                }}\n            }}\n            WHERE\n            {{\n                VALUES (?s ?esError) {{ {error_list} }} .\n                {{\n                    SELECT DISTINCT ?g ?s\n                    {{\n                        graph ?g {{?s ?p ?o}}\n                    }}\n                }}\n            }}\"\"\".format(\n                    idx_time=idx_time.sparql,\n                    error_list=\"\\n\".join([\"(<%s> %s)\" % (key, val.sparql)\n                                          for key, val in error_dict.items()]))\n\n        # Create a turtle data stream of the new errors to upload into the\n        # triplestore\n        self.tstore_conn.update_query(sparql_update)\n        del sparql_update", "response": "Updates the triplestore with success of saves and failues of indexing the action items that were indexed by the user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete all of the status triples from the datastore that are in the index.", "response": "def delete_idx_status(self, rdf_class):\n        \"\"\"\n        Removes all of the index status triples from the datastore\n\n        Args:\n        -----\n            rdf_class: The class of items to remove the status from\n        \"\"\"\n\n        sparql_template = \"\"\"\n            DELETE\n            {{\n                ?s kds:esIndexTime ?esTime .\n                ?s kds:esIndexError ?esError .\n            }}\n            WHERE\n            {{\n\n                VALUES ?rdftypes {{\\n\\t\\t{} }} .\n                ?s a ?rdftypes .\n                OPTIONAL {{\n                    ?s kds:esIndexTime ?esTime\n                }}\n                OPTIONAL {{\n                    ?s kds:esIndexError ?esError\n                }}\n                FILTER(bound(?esTime)||bound(?esError))\n            }}\n            \"\"\"\n        rdf_types = [rdf_class.uri] + [item.uri\n                                       for item in rdf_class.subclasses]\n        sparql = sparql_template.format(\"\\n\\t\\t\".join(rdf_types))\n        log.warn(\"Deleting index status for %s\", rdf_class.uri)\n        return self.tstore_conn.update_query(sparql)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread all the elasticssearch ids for an index", "response": "def get_es_ids(self):\n        \"\"\"\n        reads all the elasticssearch ids for an index\n        \"\"\"\n        search = self.search.source(['uri']).sort(['uri'])\n        es_ids = [item.meta.id for item in search.scan()]\n        return es_ids"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating that the elasticsearch index and the triplestore index match the rdf_class.", "response": "def validate_index(self, rdf_class):\n        \"\"\"\n        Will compare the triplestore and elasticsearch index to ensure that\n        that elasticsearch and triplestore items match. elasticsearch records\n        that are not in the triplestore will be deleteed\n        \"\"\"\n        es_ids = set(self.get_es_ids())\n        tstore_ids = set([item[1]\n                          for item in self.get_uri_list(no_status=True)])\n        diff = es_ids - tstore_ids\n        if diff:\n            pdb.set_trace()\n            action_list = self.es_worker.make_action_list(diff,\n                                                          action_type=\"delete\")\n            results = self.es_worker.bulk_save(action_list)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndisable process collector for the prometheus process collector.", "response": "def _disable_prometheus_process_collector(self) -> None:\n        \"\"\"\n        There is a bug in SDC' Docker implementation and intolerable prometheus_client code, due to which\n        its process_collector will fail.\n\n        See https://github.com/prometheus/client_python/issues/80\n        \"\"\"\n        logger.info(\"Removing prometheus process collector\")\n        try:\n            core.REGISTRY.unregister(PROCESS_COLLECTOR)\n        except KeyError:\n            logger.debug(\"PROCESS_COLLECTOR already removed from prometheus\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconnects if necessary returns existing one if it can.", "response": "def connection(self, handshake=None):\n        \"\"\"\n        Connects if necessary, returns existing one if it can.\n\n        :param handshake: A function to be called with the client\n                          to complete the handshake.\n\n        :returns: thrift connection, deferred if necessary\n\n        \"\"\"\n        if self._state == _State.CONNECTED:\n            return succeed(self._current_client)\n        elif self._state == _State.DISCONNECTING:\n            return fail(ClientDisconnecting())\n        elif self._state == _State.NOT_CONNECTED:\n            d = self._notify_on_connect()\n            self._connect(handshake)\n            return d\n        else:\n            assert self._state == _State.CONNECTING\n            return self._notify_on_connect()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisconnecting from the broker.", "response": "def disconnect(self):\n        \"\"\"\n        Disconnects.\n\n        You probably don't need to use this unless you are writing\n        unit tests.\n        \"\"\"\n        if self._state == _State.CONNECTED:\n            self._state = _State.DISCONNECTING\n            self._transport.loseConnection()\n            return self._notify_on_disconnect()\n        if self._state == _State.CONNECTING:\n            return fail(ClientConnecting())\n        elif self._state == _State.NOT_CONNECTED:\n            return succeed(None)\n        elif self._state == _State.DISCONNECTING:\n            return self._notify_on_disconnect()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ensure_single_char(func):\n\t@functools.wraps(func)\n\tdef wrapper(*args, **kwargs):\n\t\tif not isinstance(args[0], str) or len(args[0]) != 1:\n\t\t\traise ValueError((\n\t\t\t\t'This function should be invoked with a string of length one '\n\t\t\t\t'as its first argument'))\n\t\treturn func(*args, **kwargs)\n\n\treturn wrapper", "response": "Decorator that ensures that the first argument of the decorated function is\n\ta single character i. e. a string of length one."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_letter(char, strict=True):\n\tif (char in chart.consonants) or (char in chart.vowels):\n\t\treturn True\n\n\tif not strict:\n\t\treturn unicodedata.category(char) in ['Ll', 'Lo', 'Lt', 'Lu']\n\n\treturn False", "response": "Return True if the character is a letter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck whether the character is a vowel letter.", "response": "def is_vowel(char):\n\t\"\"\"\n\tCheck whether the character is a vowel letter.\n\t\"\"\"\n\tif is_letter(char, strict=True):\n\t\treturn char in chart.vowels\n\n\treturn False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if the character is a diacritic.", "response": "def is_diacritic(char, strict=True):\n\t\"\"\"\n\tCheck whether the character is a diacritic (as opposed to a letter or a\n\tsuprasegmental).\n\n\tIn strict mode return True only if the diacritic is part of the IPA spec.\n\t\"\"\"\n\tif char in chart.diacritics:\n\t\treturn True\n\n\tif not strict:\n\t\treturn (unicodedata.category(char) in ['Lm', 'Mn', 'Sk']) \\\n\t\t\t\tand (not is_suprasegmental(char)) \\\n\t\t\t\tand (not is_tie_bar(char)) \\\n\t\t\t\tand (not 0xA700 <= ord(char) <= 0xA71F)\n\n\treturn False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_suprasegmental(char, strict=True):\n\tif (char in chart.suprasegmentals) or (char in chart.lengths):\n\t\treturn True\n\n\treturn is_tone(char, strict)", "response": "Returns True if the character is a suprasegmental."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_tone(char, strict=True):\n\tif char in chart.tones:\n\t\treturn True\n\n\tif not strict:\n\t\treturn 0xA700 <= ord(char) <= 0xA71F\n\n\treturn False", "response": "Check whether the character is a tone or word accent symbol."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the set of IPA characters that are not precomposed in normal form.", "response": "def get_precomposed_chars():\n\t\"\"\"\n\tReturn the set of IPA characters that are defined in normal form C in the\n\tspec. As of 2015, this is only the voiceless palatal fricative, \u00e7.\n\t\"\"\"\n\treturn set([\n\t\tletter for letter in chart.consonants\n\t\tif unicodedata.normalize('NFD', letter) != letter ])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef replace_substitutes(string):\n\tfor non_ipa, ipa in chart.replacements.items():\n\t\tstring = string.replace(non_ipa, ipa)\n\n\treturn string", "response": "Return the given string with all known common substitutes replaced with\n\ttheir IPA - compliant counterparts."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_ipa(self, file_path):\n\t\tsections = {\n\t\t\t'# consonants (pulmonic)': self.consonants,\n\t\t\t'# consonants (non-pulmonic)': self.consonants,\n\t\t\t'# other symbols': self.consonants,\n\t\t\t'# tie bars': self.tie_bars,\n\t\t\t'# vowels': self.vowels,\n\t\t\t'# diacritics': self.diacritics,\n\t\t\t'# suprasegmentals': self.suprasegmentals,\n\t\t\t'# lengths': self.lengths,\n\t\t\t'# tones and word accents': self.tones }\n\n\t\tcurr_section = None\n\n\t\twith open(file_path, encoding='utf-8') as f:\n\t\t\tfor line in map(lambda x: x.strip(), f):\n\t\t\t\tif line.startswith('#'):\n\t\t\t\t\tif line in sections:\n\t\t\t\t\t\tcurr_section = sections[line]\n\t\t\t\t\telse:\n\t\t\t\t\t\tcurr_section = None\n\t\t\t\telif line:\n\t\t\t\t\tif curr_section is not None:\n\t\t\t\t\t\tcurr_section.add(line.split('\\t')[0])", "response": "Load the properties from the specified file into the instance s set properties."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading the replacements from the specified file.", "response": "def load_replacements(self, file_path):\n\t\t\"\"\"\n\t\tPopulate self.replacements using the specified file.\n\t\t\"\"\"\n\t\twith open(file_path, encoding='utf-8') as f:\n\t\t\tfor line in map(lambda x: x.strip(), f):\n\t\t\t\tif line:\n\t\t\t\t\tline = line.split('\\t')\n\t\t\t\t\tself.replacements[line[0]] = line[1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the check_coverage object", "response": "def get(self):\n        \"\"\"\n        *get the check_coverage object*\n\n        **Return:**\n            - ``check_coverage``\n        \"\"\"\n        self.log.info('starting the ``get`` method')\n\n        match = self._query_sdss()\n\n        self.log.info('completed the ``get`` method')\n        return match"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nquerying the database for the current language.", "response": "def _query(\n        self,\n        sql,\n        url,\n        fmt,\n        log\n    ):\n        \"\"\"* query*\n        \"\"\"\n        self.log.info('starting the ``_query`` method')\n\n        try:\n            response = requests.get(\n                url=url,\n                params={\n                    \"cmd\": self._filtercomment(sql),\n                    \"format\": fmt,\n                },\n                headers={\n                    \"Cookie\": \"ASP.NET_SessionId=d0fiwrodvk4rdf21gh3jzr3t; SERVERID=dsa003\",\n                },\n            )\n            # print('Response HTTP Status Code: {status_code}'.format(\n            #     status_code=response.status_code))\n            # print('Response HTTP Response Body: {content}'.format(\n            #     content=response.content))\n        except requests.exceptions.RequestException:\n            print('HTTP Request failed')\n\n        self.log.info('completed the ``_query`` method')\n        return response.content"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _filtercomment(\n            self,\n            sql):\n        \"Get rid of comments starting with --\"\n        import os\n        fsql = ''\n        for line in sql.split('\\n'):\n            fsql += line.split('--')[0] + ' ' + os.linesep\n        return fsql", "response": "Get rid of comments starting with --"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsort by last name uniquely.", "response": "def sort_by_name(names):\n    \"\"\"Sort by last name, uniquely.\"\"\"\n\n    def last_name_key(full_name):\n        parts = full_name.split(' ')\n        if len(parts) == 1:\n            return full_name.upper()\n        last_first = parts[-1] + ' ' + ' '.join(parts[:-1])\n        return last_first.upper()\n\n    return sorted(set(names), key=last_name_key)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef store_attribute(self, key, value):\n        if key == 'summary' or key == 'filename' or key == 'previous':\n            return\n        attr = key.replace('-', '_')\n        if key.endswith('-time'):\n            value = int(value)\n        setattr(self, attr, value)", "response": "Store blame info we are interested in."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetermine if a file is known by git.", "response": "def is_git_file(cls, path, name):\n        \"\"\"Determine if file is known by git.\"\"\"\n        os.chdir(path)\n        p = subprocess.Popen(['git', 'ls-files', '--error-unmatch', name],\n                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        p.wait()\n        return p.returncode == 0"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef collect_blame_info(cls, matches):\n        old_area = None\n        for filename, ranges in matches:\n            area, name = os.path.split(filename)\n            if not area:\n                area = '.'\n            if area != old_area:\n                print(\"\\n\\n%s/\\n\" % area)\n                old_area = area\n            print(\"%s \" % name, end=\"\")\n            filter = cls.build_line_range_filter(ranges)\n            command = ['git', 'blame', '--line-porcelain'] + filter + [name]\n            os.chdir(area)\n            p = subprocess.Popen(command, stdout=subprocess.PIPE,\n                                 stderr=subprocess.PIPE)\n            out, err = p.communicate()\n            if err:\n                print(\" <<<<<<<<<< Unable to collect 'git blame' info:\", err)\n            else:\n                yield out", "response": "Runs git blame on files for the specified set of line ranges."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unique_authors(self, limit):\n        seen = set()\n        if limit == 0:\n            limit = None\n        seen_add = seen.add  # Assign to variable, so not resolved each time\n        return [x.author for x in self.sorted_commits[:limit]\n                if not (x.author in seen or seen_add(x.author))]", "response": "Unique list of authors but preserving order."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show(self, commit):\n        author = commit.author\n        author_width = 25\n        committer = ''\n        commit_date = date_to_str(commit.committer_time, commit.committer_tz,\n                                  self.verbose)\n        if self.verbose:\n            author += \" %s\" % commit.author_mail\n            author_width = 50\n            committer = \" %s %s\" % (commit.committer, commit.committer_mail)\n        return \"    {} {:>5d} {:{}s} {}{}\".format(\n            commit.uuid[:8], commit.line_count, author, author_width,\n            commit_date, committer)", "response": "Display one commit line."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef merge_user_commits(cls, commits):\n        user = None\n        for commit in commits:\n            if not user:\n                user = commit\n            else:\n                if commit.committer_time > user.committer_time:\n                    commit.line_count += user.line_count\n                    user = commit\n                else:\n                    user.line_count += commit.line_count\n        return user", "response": "Merge all the commits for the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsorts by commit size per author.", "response": "def sort(self):\n        \"\"\"Sort by commit size, per author.\"\"\"\n        # First sort commits by author email\n        users = []\n        # Group commits by author email, so they can be merged\n        for _, group in itertools.groupby(sorted(self.commits),\n                                          operator.attrgetter('author_mail')):\n            if group:\n                users.append(self.merge_user_commits(group))\n        # Finally sort by the (aggregated) commits' line counts\n        self.sorted_commits = sorted(users,\n                                     key=operator.attrgetter('line_count'),\n                                     reverse=True)\n        return self.sorted_commits"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsort commits by the committer date and time.", "response": "def sort(self):\n        \"\"\"Sort commits by the committer date/time.\"\"\"\n        self.sorted_commits = sorted(self.commits,\n                                     key=lambda x: x.committer_time,\n                                     reverse=True)\n        return self.sorted_commits"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert list of lines into list of line range tuples.", "response": "def make_ranges(cls, lines):\n        \"\"\"Convert list of lines into list of line range tuples.\n\n        Only will be called if there is one or more entries in the list. Single\n        lines, will be coverted into tuple with same line.\n        \"\"\"\n        start_line = last_line = lines.pop(0)\n        ranges = []\n        for line in lines:\n            if line == (last_line + 1):\n                last_line = line\n            else:\n                ranges.append((start_line, last_line))\n                start_line = line\n                last_line = line\n        ranges.append((start_line, last_line))\n        return ranges"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nscan the summary section of report and determine the coverage data.", "response": "def determine_coverage(cls, coverage_file):\n        \"\"\"Scan the summary section of report looking for coverage data.\n\n        Will see CSS class with \"stm mis\" (missing coverage), or \"stm par\"\n        (partial coverage), and can extract line number. Will get file name\n        from title tag.\n        \"\"\"\n        lines = []\n        source_file = 'ERROR'\n        for line in coverage_file:\n            m = title_re.match(line)\n            if m:\n                if m.group(2) == '100':\n                    return ('', [])\n                source_file = m.group(1)\n                continue\n            m = source_re.match(line)\n            if m:\n                lines.append(int(m.group(1)))\n                continue\n            if end_re.match(line):\n                break\n        line_ranges = cls.make_ranges(lines)\n        return (source_file, line_ranges)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef collect_modules(self):\n        coverage_dir = os.path.join(self.root, 'cover')\n        for name in fnmatch.filter(os.listdir(coverage_dir), \"*.html\"):\n                if name == 'index.html':\n                    continue\n                with open(os.path.join(coverage_dir, name)) as cover_file:\n                    src_file, line_ranges = self.determine_coverage(cover_file)\n                if not src_file:\n                    continue\n                src_file = os.path.abspath(os.path.join(self.root, src_file))\n                if os.path.isfile(src_file):\n                    yield (src_file, line_ranges)\n                else:\n                    raise SourceNotFound(\n                        \"Source file %(file)s not found at %(area)s\" %\n                        {'file': os.path.basename(src_file),\n                         'area': os.path.dirname(src_file)})", "response": "Generator to obtain lines of interest from coverage report files."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sort(self):\n        self.sorted_commits = []\n        if not self.commits:\n            return self.sorted_commits\n        prev_commit = self.commits.pop(0)\n        prev_line = prev_commit.line_number\n        prev_uuid = prev_commit.uuid\n        for commit in self.commits:\n            if (commit.uuid != prev_uuid or\n                    commit.line_number != (prev_line + 1)):\n                prev_commit.lines = self.line_range(prev_commit.line_number,\n                                                    prev_line)\n                self.sorted_commits.append(prev_commit)\n                prev_commit = commit\n            prev_line = commit.line_number\n            prev_uuid = commit.uuid\n        # Take care of last commit\n        prev_commit.lines = self.line_range(prev_commit.line_number, prev_line)\n        self.sorted_commits.append(prev_commit)\n        return self.sorted_commits", "response": "Sort the list of commits in order of line number."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write(url, content, **args):\n    with FTPSResource(url, **args) as resource:\n        resource.write(content)", "response": "Put an object into a ftps URL."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef yaml_str_join(l, n):\n    '''\n    YAML loader to join strings\n\n    The keywords are as following:\n\n    * `hostname`: Your hostname (from :func:`util.system.get_hostname`)\n\n    * `timestamp`: Current timestamp (from :func:`util.system.get_timestamp`)\n\n    :returns:\n        A `non character` joined string |yaml_loader_returns|\n\n    .. note::\n        Be careful with timestamps when using a `config` in :ref:`settings`.\n\n    .. seealso:: |yaml_loader_seealso|\n    '''\n\n    from photon.util.system import get_hostname, get_timestamp\n\n    s = l.construct_sequence(n)\n\n    for num, seq in enumerate(s):\n        if seq == 'hostname':\n            s[num] = '%s' % (get_hostname())\n        elif seq == 'timestamp':\n            s[num] = '%s' % (get_timestamp())\n    return ''.join([str(i) for i in s])", "response": "YAML loader to join strings"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_list(i, use_keys=False):\n    '''\n    Converts items to a list.\n\n    :param i: Item to convert\n\n        * If `i` is ``None``, the result is an empty list\n\n        * If `i` is 'string', the result won't be \\\n        ``['s', 't', 'r',...]`` rather more like ``['string']``\n\n        * If `i` is a nested dictionary, the result will be a flattened list.\n\n    :param use_keys:\n        If i is a dictionary, use the keys instead of values\n    :returns:\n        All items in i as list\n    '''\n\n    from photon.util.system import shell_notify\n\n    if not i:\n        return []\n    if isinstance(i, str):\n        return [i]\n    if isinstance(i, list):\n        return i\n    if isinstance(i, dict):\n        res = list()\n        for e in i.keys() if use_keys else i.values():\n            res.append(to_list(e)) if isinstance(e, dict) else res.append(e)\n        return res\n    shell_notify('type for %s uncovered' % (i), state=True, more=type(i))", "response": "Converts items to a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef this(obj, **kwargs):\n    verbose = kwargs.get(\"verbose\", True)\n\n    if verbose:\n        print('{:=^30}'.format(\" whatis.this? \"))\n\n    for func in pipeline:\n        s = func(obj, **kwargs)\n        if s is not None:\n            print(s)\n\n    if verbose:\n        print('{:=^30}\\n'.format(\" whatis.this? \"))", "response": "Prints series of debugging steps to user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_repeat_masker_header(pairwise_alignment):\n  res = \"\"\n  res += str(pairwise_alignment.meta[ALIG_SCORE_KEY]) + \" \"\n  res += \"{:.2f}\".format(pairwise_alignment.meta[PCENT_SUBS_KEY]) + \" \"\n  res += \"{:.2f}\".format(pairwise_alignment.meta[PCENT_S1_INDELS_KEY]) + \" \"\n  res += \"{:.2f}\".format(pairwise_alignment.meta[PCENT_S2_INDELS_KEY]) + \" \"\n  res += (pairwise_alignment.s1.name\n          if (pairwise_alignment.s1.name != \"\" and\n              pairwise_alignment.s1.name is not None)\n          else UNKNOWN_SEQ_NAME) + \" \"\n  res += str(pairwise_alignment.s1.start) + \" \"\n  res += str(pairwise_alignment.s1.end - 1) + \" \"\n  res += \"(\" + str(pairwise_alignment.s1.remaining) + \") \"\n  res += (\"C \" if not pairwise_alignment.s2.is_positive_strand() else \"\")\n  res += (pairwise_alignment.s2.name\n          if (pairwise_alignment.s2.name != \"\" and\n              pairwise_alignment.s2.name is not None)\n          else UNKNOWN_SEQ_NAME) + \" \"\n  res += (\"(\" + str(pairwise_alignment.s2.remaining) + \")\"\n          if not pairwise_alignment.s2.is_positive_strand()\n          else str(pairwise_alignment.s2.start))\n  res += \" \"\n  # Note here that we need to convert between our internal representation\n  # for coordinates and the repeat-masker one; internally, we always store\n  # coordinates as exclusive of the final value with start < end;\n  # repeatmasker gives the larger coordinate as the 'start' when the match\n  # is to the reverse complement, so we have to swap start/end, and its\n  # coordinates are inclusive of end, so we have to subtract 1 from end.\n  res += str(pairwise_alignment.s2.end - 1) + \" \"\n  res += (str(pairwise_alignment.s2.start)\n          if not pairwise_alignment.s2.is_positive_strand()\n          else \"(\" + str(pairwise_alignment.s2.remaining) + \")\") + \" \"\n  res += pairwise_alignment.meta[UNKNOWN_RM_HEADER_FIELD_KEY] + \" \"\n  res += str(pairwise_alignment.meta[RM_ID_KEY])\n  return res", "response": "generate header string of repeat - masker"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _to_repeatmasker_string(pairwise_alignment, column_width=DEFAULT_COL_WIDTH,\n                            m_name_width=DEFAULT_MAX_NAME_WIDTH):\n  \"\"\"\n  generate a repeatmasker formated representation of this pairwise alignment.\n\n  :param column_width: number of characters to output per line of alignment\n  :param m_name_width: truncate names on alignment lines to this length\n                       (set to None for no truncation)\n  \"\"\"\n  s1 = pairwise_alignment.s1\n  s2 = pairwise_alignment.s2\n\n  s1_neg = not s1.is_positive_strand()\n  s2_neg = not s2.is_positive_strand()\n  size = pairwise_alignment.size()\n\n  # figure out the complement column\n  s1_comp = \"C\" if s1_neg else \" \"\n  s2_comp = \"C\" if s2_neg else \" \"\n\n  # figure out the maximum name length, so we can size that column properly;\n  # pre-compute the space-padded names too\n  s1_len = len(s1.name)\n  s2_len = len(s2.name)\n  f_len = max(s1_len, s2_len)\n  if m_name_width is not None:\n    f_len = min(f_len, m_name_width)\n  s1_n = s1.name[:f_len] + (' ' * (f_len - s1_len))\n  s2_n = s2.name[:f_len] + (' ' * (f_len - s2_len))\n\n  # figure out the max width for the coordinates column; we use size of the\n  # alignment here rather than ungapped coordinates because its an upper\n  # bound and easier to compute (i.e. for sure already know).\n  s1_line_end_num = (s1.end if s1_neg else s1.start - 1)\n  s2_line_end_num = (s2.end if s2_neg else s2.start - 1)\n  max_num_len = max(len(str(s1.start + size)), len(str(s2.start + size)))\n\n  res = \"\"  # our result\n  i = 0     # how much of the full, gapped alignment, has been output so far?\n  res += _get_repeat_masker_header(pairwise_alignment) + \"\\n\\n\"\n  while i < len(pairwise_alignment.s1):\n    # keep track of how much of each sequence we've output\n    s1_sub = s1.gapped_relative_subsequence(i + 1, min(i + column_width + 1, len(s1) + 1))\n    s2_sub = s2.gapped_relative_subsequence(i + 1, min(i + column_width + 1, len(s2) + 1))\n    s1_ug_len = s1_sub.ungapped_len\n    s2_ug_len = s2_sub.ungapped_len\n    s1_line_start_num = (s1_line_end_num - 1 if s1_neg\n                         else s1_line_end_num + 1)\n    s1_line_end_num = (s1_line_start_num - s1_ug_len + 1 if s1_neg\n                       else s1_line_start_num + s1_ug_len - 1)\n    s2_line_start_num = (s2_line_end_num - 1 if s2_neg\n                         else s2_line_end_num + 1)\n    s2_line_end_num = (s2_line_start_num - s2_ug_len + 1 if s2_neg\n                       else s2_line_start_num + s2_ug_len - 1)\n\n    # output sequence one\n    res += (s1_comp + \" \" + s1_n + \" \")\n    s1_line_start_num_str = str(s1_line_start_num)\n    s1_num_padding = max_num_len - len(s1_line_start_num_str)\n    res += (' ' * s1_num_padding) + s1_line_start_num_str + \" \"\n    res += pairwise_alignment.s1[i:i + column_width] + \" \"\n    res += str(s1_line_end_num) + \"\\n\"\n\n    # output the annotation string, if we have one; needs to be padded by the\n    # number of char in the name col (f_len), the number in the coordinate\n    # col (max_num_len), the one char in the complement columns, and the\n    # three spaces that are used as column seperators for those.\n    if ANNOTATION_KEY in pairwise_alignment.meta:\n      res += (((f_len + max_num_len) * ' ') + \"    \" +\n              pairwise_alignment.meta[ANNOTATION_KEY][i:i + column_width] + \"\\n\")\n\n    # output sequence two\n    res += (s2_comp + \" \" + s2_n + \" \")\n    s2_line_start_num_str = str(s2_line_start_num)\n    s2_num_padding = max_num_len - len(s2_line_start_num_str)\n    res += (' ' * s2_num_padding) + s2_line_start_num_str + \" \"\n    res += pairwise_alignment.s2[i:i + column_width] + \" \"\n    res += str(s2_line_end_num) + \"\\n\"\n\n    res += \"\\n\"\n    i += column_width\n\n  # otuput any meta data key-value pairs that aren't known to us.\n  if pairwise_alignment.meta is not None:\n    for k in pairwise_alignment.meta:\n      if k not in KNOWN_KEYS:\n        if k is ROUNDTRIP_KEY:\n          res += (pairwise_alignment.meta[k] + \"\\n\")\n        else:\n          res += (k + \" = \" + str(pairwise_alignment.meta[k]) + \"\\n\")\n\n  # remove any trailing whitespace\n  res = res.strip()\n  return res", "response": "Generate a repeatmasker string from a pairwise alignment."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _rm_is_alignment_line(parts, s1_name, s2_name):\n  if len(parts) < 2:\n    return False\n  if _rm_name_match(parts[0], s1_name):\n    return True\n  if (_rm_name_match(parts[0], s2_name) or\n     (parts[0] == \"C\" and _rm_name_match(parts[1], s2_name))):\n    return True\n  return False", "response": "Return True if the tokenized line is an alignment line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndetermine whether a pre - split string is a repeat - masker alignment header line.", "response": "def _rm_is_header_line(parts, n):\n  \"\"\"\n  determine whether a pre-split string is a repeat-masker alignment header.\n\n  headers have no special structure or symbol to mark them, so this is based\n  only on the number of elements, and what data type they are.\n  \"\"\"\n  if (n == 15 and parts[8] == \"C\"):\n    return True\n  if (n == 14 and parts[0].isdigit()):\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the number of leading spaces in an alignment line.", "response": "def _rm_compute_leading_space_alig(space_pres_split, seq):\n  \"\"\"\n  count the number of characters that precede the sequence in a repeatmasker\n  alignment line. E.g. in the following line:\n         '  chr1               11 CCCTGGAGATTCTTATT--AGTGATTTGGGCT 41'\n  the answer would be 24.\n\n  :param space_pres_split: the alignment line, split into tokens around spaces,\n                           but with the spaces conserved as tokens.\n  :param seq: the sequence token.\n  \"\"\"\n  c = 0\n  for i in range(0, len(space_pres_split)):\n    if space_pres_split[i] == seq:\n      break\n    c += len(space_pres_split[i])\n  return c"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute the number of spaces that are following a non - space token.", "response": "def _rm_compute_leading_space(space_s_pres_split):\n  \"\"\"\n  count the number of spaces that precede a non-space token (not including\n  empty string tokens) in a string.\n\n  :param space_s_pres_split: the string, split into tokens around spaces,\n                             but with the spaces conserved as tokens.\n  \"\"\"\n  i = 0\n  c = 0\n  while (i < len(space_s_pres_split) and\n         (space_s_pres_split[i].isspace() or\n         (space_s_pres_split[i] == \"\"))):\n    c += len(space_s_pres_split[i])\n    i += 1\n  return c"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _rm_get_names_from_header(parts):\n  assert((parts[8] == \"C\" and len(parts) == 15) or (len(parts) == 14))\n  return (parts[4], parts[8]) if len(parts) == 14 else (parts[4], parts[9])", "response": "Get repeat and seq. name from repeatmasker alignment header line."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _rm_get_reference_coords_from_header(parts):\n  s = int(parts[5])\n  e = int(parts[6]) + 1\n  if (s >= e):\n    raise AlignmentIteratorError(\"invalid repeatmakser header: \" +\n                                 \" \".join(parts))\n  return (s, e)", "response": "This function extracts the start and end coordinates of a repeat\n occurrence from a repeatmakser header line."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nextracting repeat coordinates from a header line.", "response": "def _rm_get_repeat_coords_from_header(parts):\n  \"\"\"\n  extract the repeat coordinates of a repeat masker match from a header line.\n\n  An example header line is::\n\n    239 29.42 1.92 0.97 chr1 11 17 (41) C XX#YY (74) 104 1 m_b1s502i1 4\n    239 29.42 1.92 0.97 chr1 11 17 (41) XX#YY 1 104 (74) m_b1s502i1 4\n\n  if the match is to the reverse complement, the start and end coordinates are\n  at positions 11 and 12 (zero-based indexes), otherwise they're at positions\n  9 and 10. In the later case, the 'start' is the earlier number and the end\n  is the larger one. In reverse complement matches, RM lists the 'start' as the\n  larger number and the end as the smaller one. We swap these around to match\n  the Pyokit convention of start < end always and also adjust the end so it is\n  not inclusive of the last position\n\n  :param parts: the header line, as a tokenized list.\n  :return: tuple of (start, end)\n  \"\"\"\n  assert((parts[8] == \"C\" and len(parts) == 15) or (len(parts) == 14))\n  if len(parts) == 14:\n    s = int(parts[9])\n    e = int(parts[10]) + 1\n  else:\n    s = int(parts[12])\n    e = int(parts[11]) + 1\n  if (s >= e):\n    raise AlignmentIteratorError(\"invalid repeatmakser header: \" +\n                                 \" \".join(parts))\n  return (s, e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a repeatmasker alignment header line and place the extracted meta - data into the provided dictionary.", "response": "def _rm_parse_header_line(parts, meta_data):\n  \"\"\"\n  parse a repeatmasker alignment header line and place the extracted meta-data\n  into the provided dictionary. An example header line is::\n\n    239 29.42 1.92 0.97 chr1 11 17 (41) C XX#YY (74) 104 1 m_b1s502i1 4\n\n  If the alignment is to the consensus, this will have 14 fields; to the\n  reverse complement of the repeat consensus and it'll have 15. Fields as\n  follows:\n\n  =====  ========    ==========================================================\n  Num    Value       description\n  =====  ========    ==========================================================\n  0      239         Smith-Waterman score of the match\n  1      29.42       percent substitutions in match compared to the consensus\n  2      1.92        percent bases opposite gap in query seq (deleted bp)\n  3      0.97        percent bases opposite gap in repeat consensus (insert bp)\n  4      chr1        The name of the reference sequence (usually genomic chrom)\n  5      11          Start location in reference; always pos strand, I think..\n  6      17          End location in reference; always pos strand, I think..\n  7      (41)        Distance to end of ref (alt., neg strand co-ord of end)\n  8      C           Alignment is to rev. comp. of consensus. Ommited otherwise\n  8/9    XX#YY       XX is the name of the repeat and YY is the family\n  9/10   (74)        if +'ve, strt coord; else bases before start on neg strand\n  10/11  104         if +'ve, end coord; else start of match in pos strand\n  11/12  1           if +'ve, num bases aftr mtch to end; else end in + coords\n  12/13  m_b1s5..    ....?\n  13/14  4           unique ID\n  =====  ========    ==========================================================\n\n  Note that repeat-masker calls the larger coordinate the start when the match\n  is to the reverse complement; we swap these internally so start < end always,\n  regardless of whether the match is to the consensus or the reverse complement\n  of the consensus\n\n  Each field is mapped to a key as follows\n\n  =====  =================================================================\n  Num    Key (these are defined in pyokit.datastruct.multipleAlignment.py)\n  =====  =================================================================\n  0      ALIG_SCORE_KEY\n  1      PCENT_SUBS_KEY\n  2      PCENT_S1_INDELS_KEY\n  3      PCENT_S2_INDELS_KEY\n  4      S1_NAME_KEY\n  5      S1_START_KEY\n  6      S1_END_KEY\n  7      S1_END_NEG_STRAND_KEY\n  8      S2_REVERSE_COMP_KEY\n  8/9    S2_NAME_KEY\n  9/10   S2_START_KEY (S2 + strand) / S2_START_NEG_STRAND_KEY (S2 - strand)\n  10/11  S2_END_KEY (S2 + strand) / S2_START_KEY (S2 - strand)\n  11/12  S2_END_NEG_STRAND_KEY (S2 + strand) / S2_END_KEY (S2 - strand)\n  12/13  UNKNOWN_RM_HEADER_FIELD_KEY\n  13/14  RM_ID_KEY\n  =====  =================================================================\n\n  :param parts:     the header line, as a tokenized list.\n  :param meta_data: dictionary; resultant key-value pairs placed into this.\n  \"\"\"\n  meta_data[ALIG_SCORE_KEY] = parts[0]\n  meta_data[PCENT_SUBS_KEY] = float(parts[1])\n  meta_data[PCENT_S1_INDELS_KEY] = float(parts[2])\n  meta_data[PCENT_S2_INDELS_KEY] = float(parts[3])\n  meta_data[ANNOTATION_KEY] = \"\"\n\n  if parts[8] == \"C\":\n    meta_data[UNKNOWN_RM_HEADER_FIELD_KEY] = parts[13]\n    meta_data[RM_ID_KEY] = int(parts[14])\n  else:\n    meta_data[UNKNOWN_RM_HEADER_FIELD_KEY] = parts[12]\n    meta_data[RM_ID_KEY] = int(parts[13])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if two sequence names from a repeatmasker alignment match.", "response": "def _rm_name_match(s1, s2):\n  \"\"\"\n  determine whether two sequence names from a repeatmasker alignment match.\n\n  :return: True if they are the same string, or if one forms a substring of the\n           other, else False\n  \"\"\"\n  m_len = min(len(s1), len(s2))\n  return s1[:m_len] == s2[:m_len]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse an alignment line from a repeatmasker alignment and return the name and sequence string of the sequence it si from and the name of the sequence it si from and the name of the sequence it si from.", "response": "def _rm_extract_sequence_and_name(alig_str_parts, s1_name, s2_name):\n  \"\"\"\n  parse an alignment line from a repeatmasker alignment and return the name\n  of the sequence it si from and the sequence portion contained in the line.\n\n  :param alig_str_parts: the alignment string, split around whitespace as list\n  :param s1_name: the name of the first sequence in the alignment this line is\n                  from\n  :param s2_name: the name of the second sequence in the alignment this line is\n                  from\n  :return: a tuple of name and sequence string; name will always be either\n           s1_name or s2_name\n  :raise AlignmentIteratorError: if the line doesn't have the expected number\n                                 of elements, or the name does not match\n                                 either of s1_name or s2_name\n  \"\"\"\n  # first, based on the number of parts we have we'll guess whether its a\n  # reverse complement or not\n  if len(alig_str_parts) == 4:\n    # expect the first element to amtch something..\n    nm = alig_str_parts[0]\n    seq = alig_str_parts[2]\n  elif len(alig_str_parts) == 5:\n    # expect the second element to match something...\n    nm = alig_str_parts[1]\n    seq = alig_str_parts[3]\n  else:\n    raise AlignmentIteratorError(\"failed parsing alignment line '\" +\n                                 \" \".join(alig_str_parts) + \"'; reason: \" +\n                                 \"expected this line to have 4 or 5 \" +\n                                 \"elements, but it has \" +\n                                 str(len(alig_str_parts)))\n  if _rm_name_match(nm, s1_name):\n    return s1_name, seq\n  elif _rm_name_match(nm, s2_name):\n    return s2_name, seq\n  else:\n    raise AlignmentIteratorError(\"failed parsing alignment line '\" +\n                                 \" \".join(alig_str_parts) + \"'; reason: \" +\n                                 \"extracted alignment name (\" + nm + \") \" +\n                                 \"did not match either sequence name from \" +\n                                 \"header line (\" + s1_name + \" or \" +\n                                 s2_name + \")\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef repeat_masker_alignment_iterator(fn, index_friendly=True, verbose=False):\n  # step 1 -- build our iterator for the stream..\n  try:\n    fh = open(fn)\n  except (TypeError):\n    fh = fn\n  iterable = fh\n  if index_friendly:\n    iterable = iter(fh.readline, '')\n\n  # build progress indicator, if we want one and we're able to\n  if verbose:\n    try:\n      m_fn = \": \" + fh.name\n    except TypeError:\n      m_fn = \"\"\n    try:\n      current = fh.tell()\n      fh.seek(0, 2)\n      total_progress = fh.tell()\n      fh.seek(current)\n      pind = ProgressIndicator(totalToDo=total_progress,\n                               messagePrefix=\"completed\",\n                               messageSuffix=\"of processing repeat-masker \"\n                                             \"alignment file\" + m_fn)\n    except IOError:\n      pind = None\n\n  old_fh_pos = None\n  new_fh_pos = fh.tell()\n\n  s1 = None\n  s2 = None\n  s1_name = None\n  s2_name = None\n  s1_start = None\n  s1_end = None\n  s2_start = None\n  s2_end = None\n  meta_data = None\n  alignment_line_counter = 0\n  alig_l_space = 0\n  prev_seq_len = 0\n  rev_comp_match = None\n  remaining_repeat = None\n  remaining_genomic = None\n\n  for line in iterable:\n    if verbose and pind is not None:\n      pind.done = fh.tell()\n      pind.showProgress()\n\n    if index_friendly:\n      old_fh_pos = new_fh_pos\n      new_fh_pos = fh.tell()\n    line = line.rstrip()\n    if line.lstrip() == \"\" and alignment_line_counter % 3 != 1:\n      continue\n\n    s_pres_split = re.split(r'(\\s+)', line)\n    parts = [x for x in s_pres_split if not (x.isspace() or x == \"\")]\n\n    n = len(parts)\n    for i in REPEATMASKER_FIELDS_TO_TRIM:\n      if n >= i + 1:\n        parts[i] = parts[i].strip()\n\n    # decide what to do with this line -- is it a header line, part of the\n    # alignment or a meta-data key-value line\n    if alignment_line_counter % 3 == 1:\n      if (REPEATMASKER_VALIDATE_MUTATIONS and\n         not _rm_is_valid_annotation_line(line)):\n        raise IOError(\"invalid mutation line: \" + line)\n      l_space = _rm_compute_leading_space(s_pres_split) - alig_l_space\n      pad_right = prev_seq_len - (l_space + len(line.strip()))\n      meta_data[ANNOTATION_KEY] += ((' ' * l_space) + line.strip() +\n                                    (' ' * pad_right))\n      alignment_line_counter += 1\n    elif _rm_is_header_line(parts, n):\n      if not (s1 is None and s2 is None and meta_data is None):\n        if ANNOTATION_KEY in meta_data:\n          meta_data[ANNOTATION_KEY] = meta_data[ANNOTATION_KEY].rstrip()\n        if index_friendly:\n          fh.seek(old_fh_pos)\n        ss1 = Sequence(s1_name, s1, s1_start, s1_end, \"+\", remaining_genomic)\n        s2s = \"-\" if rev_comp_match else \"+\"\n        ss2 = Sequence(s2_name, s2, s2_start, s2_end, s2s, remaining_repeat)\n        yield PairwiseAlignment(ss1, ss2, meta_data)\n        if index_friendly:\n          fh.seek(new_fh_pos)\n      meta_data = {}\n      s1 = \"\"\n      s2 = \"\"\n      s1_name, s2_name = _rm_get_names_from_header(parts)\n      s1_start, s1_end = _rm_get_reference_coords_from_header(parts)\n      s2_start, s2_end = _rm_get_repeat_coords_from_header(parts)\n      rev_comp_match = _rm_is_reverse_comp_match(parts)\n      remaining_repeat = _rm_get_remaining_repeat_from_header(parts)\n      remaining_genomic = _rm_get_remaining_genomic_from_header(parts)\n\n      _rm_parse_header_line(parts, meta_data)\n      alignment_line_counter = 0\n    elif _rm_is_alignment_line(parts, s1_name, s2_name):\n      alignment_line_counter += 1\n      name, seq = _rm_extract_sequence_and_name(parts, s1_name, s2_name)\n      if name == s1_name:\n        s1 += seq\n      elif name == s2_name:\n        s2 += seq\n      alig_l_space = _rm_compute_leading_space_alig(s_pres_split, seq)\n      prev_seq_len = len(seq)\n    else:\n      k, v = _rm_parse_meta_line(parts)\n      meta_data[k] = v\n  if index_friendly:\n    fh.seek(old_fh_pos)\n  ss1 = Sequence(s1_name, s1, s1_start, s1_end, \"+\", remaining_genomic)\n  s2s = \"-\" if rev_comp_match else \"+\"\n  ss2 = Sequence(s2_name, s2, s2_start, s2_end, s2s, remaining_repeat)\n  yield PairwiseAlignment(ss1, ss2, meta_data)\n  if index_friendly:\n    fh.seek(new_fh_pos)", "response": "Iterator for repeat masker alignment files ; yields multiple alignment objects."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nscan path for viruses using clamd daemon.", "response": "def scan_file(path):\n    \"\"\"\n    Scan `path` for viruses using ``clamd`` antivirus daemon.\n\n    Args:\n        path (str): Relative or absolute path of file/directory you need to\n                    scan.\n\n    Returns:\n        dict: ``{filename: (\"FOUND\", \"virus type\")}`` or blank dict.\n\n    Raises:\n        ValueError: When the server is not running.\n        AssertionError: When the internal file doesn't exists.\n    \"\"\"\n    path = os.path.abspath(path)\n    assert os.path.exists(path), \"Unreachable file '%s'.\" % path\n\n    try:\n        cd = pyclamd.ClamdUnixSocket()\n        cd.ping()\n    except pyclamd.ConnectionError:\n        cd = pyclamd.ClamdNetworkSocket()\n        try:\n            cd.ping()\n        except pyclamd.ConnectionError:\n            raise ValueError(\n                \"Couldn't connect to clamd server using unix/network socket.\"\n            )\n\n    cd = pyclamd.ClamdUnixSocket()\n    assert cd.ping(), \"clamd server is not reachable!\"\n\n    result = cd.scan_file(path)\n\n    return result if result else {}"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexecute the current client and return a Deferred.", "response": "def execute(self, *args, **kwargs):\n        \"\"\"\n        See :py:func:`silverberg.client.CQLClient.execute`\n        \"\"\"\n        num_clients = len(self._seed_clients)\n        start_client = (self._client_idx + 1) % num_clients\n\n        def _client_error(failure, client_i):\n            failure.trap(ConnectError)\n            client_i = (client_i + 1) % num_clients\n            if client_i == start_client:\n                return failure\n            else:\n                return _try_execute(client_i)\n\n        def _try_execute(client_i):\n            self._client_idx = client_i\n            d = self._seed_clients[client_i].execute(*args, **kwargs)\n            return d.addErrback(_client_error, client_i)\n\n        return _try_execute(start_client)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse an object and tries to extract a resource_url.", "response": "def id_from_url(url, param_name: str) -> int:\n    \"\"\"\n    Parses an object and tries to extract a url.\n    Tries to parse if a resource_url has been given\n    it as a url.\n    :raise ValueError: If no id could be extracted.\n    \"\"\"\n    if url is None:\n        raise ValueError('url is none')\n    elif isinstance(url, int):\n        # Seems to already be the url.\n        return url\n    if not url:\n        raise ValueError('Seems to be empty')\n\n    try:\n        return int(url)\n    except ValueError:\n        pass\n\n    parsed = urlparse(url)\n    try:\n        resource_url = app.url_map.bind(parsed.netloc).match(\n            parsed.path\n        )\n    except NotFound:\n        raise ValueError('No URL found')\n\n    if param_name in resource_url[1]:\n        return resource_url[1][param_name]\n    else:\n        raise ValueError(\n            'Parameter {name} could not be extracted'.format(\n                name=param_name\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the best local timezone name for the current time.", "response": "def get_best_local_timezone():\n    \"\"\"\n    Compares local timezone offset to pytz's timezone db, to determine\n    a matching timezone name to use when TIME_ZONE is not set.\n    \"\"\"\n    zone_name = tzlocal.get_localzone().zone\n    if zone_name in pytz.all_timezones:\n        return zone_name\n    if time.daylight:\n        local_offset = time.altzone\n        localtz = time.tzname[1]\n    else:\n        local_offset = time.timezone\n        localtz = time.tzname[0]\n    local_offset = datetime.timedelta(seconds=-local_offset)\n    for zone_name in pytz.all_timezones:\n        timezone = pytz.timezone(zone_name)\n        if not hasattr(timezone, '_tzinfos'):\n            continue\n        for utcoffset, daylight, tzname in timezone._tzinfos:\n            if utcoffset == local_offset and tzname == localtz:\n                return zone_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_new_topics_count(last_seen=None, for_member=False):\n    if not last_seen:\n        last_seen = yesterday()\n    if not for_member:\n        return Topic.objects.filter(created__gt=last_seen).count()\n    return Topic.objects.filter(modified__gt=last_seen, user__id=for_member).count()", "response": "Returns count of new topics since last visit or one day."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the number of new topics since last visit or one day.", "response": "def get_active_topics_count(last_seen_timestamp=None):\n    \"\"\"\n    Returns count of new topics since last visit, or one day.\n    {% get_active_topics_count as active_topic_count %}\n    \"\"\"\n    if not last_seen_timestamp:\n        last_seen_timestamp = yesterday_timestamp()\n    return Topic.objects.filter(modified_int__gt=last_seen_timestamp).count()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef topic_quick_links(context, topic, latest, last_seen_time):\n    output_text = u''\n\n    pages = topic.page_count\n    if not pages or pages == 0:\n        hits = topic.post_count - 1\n        if hits < 1:\n            hits = 1\n        pages = hits // PAGINATE_BY + 1\n\n    # determine if we need to show new link.\n    if latest and latest.post_date_int > last_seen_time:\n        output_text += '<a href=\"{0}#first-new-post\" class=\"new\">new</a>'.format(topic.last_url)\n\n    # If only one post (or none) only return new link, if anything.\n    if topic.post_count < 2:\n        output_text += '1 post'\n    else:\n        # We have more than one post. Create last link\n        if latest:\n            last_link = '<a href=\"{0}#post-{1}\" title=\"latest post\">'.format(topic.last_url, latest.id)\n        else:\n            last_link = ''\n\n        # if only one page, just show the number of posts wrapped in a link\n        if pages < 2:\n            output_text += '{0}{1} posts</a>'.format(last_link, topic.post_count)\n\n        else:\n            page_link = u'<a href=\"%spage%%s/\">%%s</a>' % topic.get_short_url()\n            if pages < 4:\n                page_links = u' '.join([page_link % (page, page) for page in range(1, pages + 1)])\n            else:\n                page_links = u' '.join(\n                    [page_link % (1, 1), u'<small>&hellip;</small>'] +\n                    [page_link % (page, page) for page in range(pages - 1, pages + 1)]\n                )\n            output_text += '{0}{1}&#9658;</a>'.format(page_links, last_link)\n\n    return {\n        'output_text': output_text,\n        'topic': topic,\n        'forum_slug': context['forum_slug'],\n        'user': context['user'],\n        'perms': context['perms']\n    }", "response": "Generates a string containing the topic listing page links for the given topic."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of top recent topics excluding less valuable forums.", "response": "def get_topic_list(num=10, top_items=False):\n    \"\"\"\n    Returns a list of top recent topics, excluding less valuable forums.\n    Default is 10 topics.\n    Can be sorted for most active topics by votes and post count.\n    Usage:\n    {% get_topic_list 5 as topics %}\n    {% get_topic_list 7 top_items=True as topics %}\n    \"\"\"\n    excluded_forum_ids = [3, 7, 10, 12, 15, 16, 17, 18, 19, 23]\n    topics = Topic.objects.exclude(forum_id__in=excluded_forum_ids).order_by('-id')[0:num]\n    if top_items:\n        topics = sorted(list(topics), key=lambda t: (t.forum_id, -t.votes, -t.post_count))\n    return topics"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling documentation: `/checkout/create <https://www.wepay.com/developer/reference/checkout#create>`_, plus extra keyword parameters: :keyword str access_token: will be used instead of instance's ``access_token``, with ``batch_mode=True`` will set `authorization` param to it's value. :keyword bool batch_mode: turn on/off the batch_mode, see :class:`wepay.api.WePay` :keyword str batch_reference_id: `reference_id` param for batch call, see :class:`wepay.api.WePay` :keyword str api_version: WePay API version, see :class:`wepay.api.WePay`", "response": "def __create(self, account_id, short_description, type, amount, **kwargs):\n        \"\"\"Call documentation: `/checkout/create\n        <https://www.wepay.com/developer/reference/checkout#create>`_, plus\n        extra keyword parameters:\n        \n        :keyword str access_token: will be used instead of instance's\n           ``access_token``, with ``batch_mode=True`` will set `authorization`\n           param to it's value.\n\n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'account_id': account_id,\n            'short_description': short_description,\n            'type': type,\n            'amount': amount,\n            # 'currency': currency # - still optional for backwards compatibility\n        }\n        return self.make_call(self.__create, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __cancel(self, checkout_id, cancel_reason, **kwargs):\n        params = {\n            'checkout_id': checkout_id,\n            'cancel_reason': cancel_reason\n        }\n        return self.make_call(self.__cancel, params, kwargs)", "response": "Cancel the current state of a specific item in a specific checkout."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrefunds the current state of a wePay instance.", "response": "def __refund(self, checkout_id, refund_reason, **kwargs):\n        \"\"\"Call documentation: `/checkout/refund\n        <https://www.wepay.com/developer/reference/checkout#refund>`_, plus\n        extra keyword parameters:\n        \n        :keyword str access_token: will be used instead of instance's\n           ``access_token``, with ``batch_mode=True`` will set `authorization`\n           param to it's value.\n\n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'checkout_id': checkout_id,\n            'refund_reason': refund_reason\n        }\n        return self.make_call(self.__refund, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls documentation : / checkout_id / capture", "response": "def __capture(self, checkout_id, **kwargs):\n        \"\"\"Call documentation: `/checkout/capture\n        <https://www.wepay.com/developer/reference/checkout#capture>`_, plus\n        extra keyword parameters:\n        \n        :keyword str access_token: will be used instead of instance's\n           ``access_token``, with ``batch_mode=True`` will set `authorization`\n           param to it's value.\n\n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'checkout_id': checkout_id\n        }\n        return self.make_call(self.__capture, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __modify(self, checkout_id, **kwargs):\n        params = {\n            'checkout_id': checkout_id\n        }\n        return self.make_call(self.__modify, params, kwargs)", "response": "Modify the current state of a wePay instance s record set."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncompares the useragent from the broswer to the ignore list", "response": "def ignore_user_agent(user_agent):\n    \"\"\" compare the useragent from the broswer to the ignore list\n        This is popular if you want a mobile device to not trigger\n        as mobile. For example iPad.\"\"\"\n    if user_agent:\n        for ua in MOBI_USER_AGENT_IGNORE_LIST:\n            if ua and ua.lower() in user_agent.lower():\n                return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef process_request(request):\n\n        if 'HTTP_X_OPERAMINI_FEATURES' in request.META:\n            # Then it's running opera mini. 'Nuff said.\n            # Reference from:\n            # http://dev.opera.com/articles/view/opera-mini-request-headers/\n            request.mobile = True\n            return None\n\n        if 'HTTP_ACCEPT' in request.META:\n            s = request.META['HTTP_ACCEPT'].lower()\n            if 'application/vnd.wap.xhtml+xml' in s:\n                # Then it's a wap browser\n                request.mobile = True\n                return None\n\n        if 'HTTP_USER_AGENT' in request.META:\n            # This takes the most processing. Surprisingly enough, when I\n            # Experimented on my own machine, this was the most efficient\n            # algorithm. Certainly more so than regexes.\n            # Also, Caching didn't help much, with real-world caches.\n            s = request.META['HTTP_USER_AGENT'].lower()\n            for ua in search_strings:\n                if ua in s:\n                    # check if we are ignoring this user agent: (IPad)\n\n                    if not ignore_user_agent(s):\n                        request.mobile = True\n                        if MOBI_DETECT_TABLET:\n                            request.tablet = _is_tablet(s)\n                        return None\n\n        # Otherwise it's not a mobile\n        request.mobile = False\n        request.tablet = False\n        return None", "response": "Process the request and return the a\n archive ID."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getInstance(cls, *args):\n        '''\n        Returns a singleton instance of the class\n        '''\n        if not cls.__singleton:\n            cls.__singleton = DriverManager(*args)\n        return cls.__singleton", "response": "Returns a singleton instance of the class\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun one builder return statistics about the run", "response": "def build_by_builder(self, builder: Builder, stats: BuildProcessStats):\n        \"\"\" run one builder, return statistics about the run \"\"\"\n        logger = logging.getLogger(__name__)\n        target_signature = builder.get_signature()\n        assert target_signature is not None, \"builder signature is None\"\n        if self.cache.list_sig_ok(target_signature):\n            logger.info(\"verifying [{}]\".format(builder.get_name()))\n            file_bad = 0\n            file_correct = 0\n            file_missing = 0\n            file_total = 0\n            list_filename = self.cache.get_list_filename(target_signature)\n            for object_name, signature in Cache.iterate_objects(list_filename):\n                filename = self.cache.get_object_filename(signature)\n                if os.path.isfile(object_name):\n                    object_name_signature = sha1_file(object_name)\n                    if object_name_signature != signature:\n                        # logger.info(\"file [{}] is incorrect. Getting from cache.\".format(object_name))\n                        copy_mkdir(filename, object_name)\n                        stats.add_copy_sha1(filename, object_name)\n                        file_bad += 1\n                    else:\n                        # logger.info(\"file [{}] is up to date\".format(object_name))\n                        stats.add_nop(filename, object_name)\n                        file_correct += 1\n                else:\n                    # logger.info(\"file [{}] is missing. Getting from cache.\".format(object_name))\n                    copy_mkdir(filename, object_name)\n                    stats.add_copy_missing(filename, object_name)\n                    file_missing += 1\n                file_total += 1\n            if file_bad > 0 or file_missing > 0:\n                logger.info(\"Retrieved {} files from cache (bad/correct/missing = {}/{}/{}\".format(\n                    file_total, file_bad, file_correct, file_missing))\n            else:\n                logger.info(\"ok [{}]\".format(builder.get_name()))\n        else:\n            # this is one of the rare cases in which really want to catch all exceptions.\n            # noinspection PyBroadException\n            try:\n                logger.info(\"running [{}]\".format(builder.get_name()))\n                builder.build()\n                logger.info(\"ok [{}]\".format(builder.get_name()))\n                stats.add_builder_ok(builder)\n                # first lets build a list of what was constructed\n                targets = builder.get_targets()\n                targets.extend(builder.get_targets_post_build())\n                content = \"\"\n                for target in targets:\n                    signature = sha1_file(target)\n                    content += target + \" \" + signature + \"\\n\"\n                    self.cache.save_object_by_signature(signature, target)\n                self.cache.save_list_by_signature(target_signature, content)\n            except Exception as e:\n                logger.info(\"failed [{}]\".format(builder.get_name()))\n                logger.info(\"exception [{}]\".format(e))\n                stats.add_builder_fail(builder, e)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating anomalous score of the current set of anomalous products.", "response": "def update_anomalous_score(self):\n        \"\"\"Update anomalous score.\n\n        New anomalous score is a weighted average of differences\n        between current summary and reviews. The weights come from credibilities.\n\n        Therefore, the new anomalous score of reviewer :math:`p` is as\n\n        .. math::\n\n           {\\\\rm anomalous}(r) = \\\\frac{\n             \\\\sum_{p \\\\in P} {\\\\rm credibility}(p)|\n                {\\\\rm review}(r, p)-{\\\\rm summary}(p)|\n           }{\n             \\\\sum_{p \\\\in P} {\\\\rm credibility}(p)\n           }\n\n        where :math:`P` is a set of products reviewed by reviewer :math:`p`,\n        review(:math:`r`, :math:`p`) is the rating reviewer :math:`r` posted\n        to product :math:`p`, summary(:math:`p`) and credibility(:math:`p`) are\n        summary and credibility of product :math:`p`, respectively.\n\n        Returns:\n          absolute difference between old anomalous score and updated one.\n        \"\"\"\n        products = self._graph.retrieve_products(self)\n        diffs = [\n            p.summary.difference(self._graph.retrieve_review(self, p))\n            for p in products\n        ]\n\n        old = self.anomalous_score\n        try:\n            self.anomalous_score = np.average(\n                diffs, weights=list(map(self._credibility, products)))\n        except ZeroDivisionError:\n            self.anomalous_score = np.average(diffs)\n\n        return abs(self.anomalous_score - old)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef summary(self, v):\n        if hasattr(v, \"__iter__\"):\n            self._summary = self._summary_cls(v)\n        else:\n            self._summary = self._summary_cls(float(v))", "response": "Set summary.\n\n        Args:\n          v: A new summary. It could be a single number or lists."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating summary. The new summary is a weighted average of reviews i.e. .. math:: \\\\frac{\\\\sum_{r \\\\in R} \\\\mbox{weight}(r) \\\\times \\\\mbox{review}(r)} {\\\\sum_{r \\\\in R} \\\\mbox{weight}(r)}, where :math:`R` is a set of reviewers reviewing this product, :math:`\\\\mbox{review}(r)` and :math:`\\\\mbox{weight}(r)` are the review and weight of the reviewer :math:`r`, respectively. Args: w: A weight function. Returns: absolute difference between old summary and updated one.", "response": "def update_summary(self, w):\n        \"\"\"Update summary.\n\n        The new summary is a weighted average of reviews i.e.\n\n        .. math::\n\n            \\\\frac{\\\\sum_{r \\\\in R} \\\\mbox{weight}(r) \\\\times \\\\mbox{review}(r)}\n                {\\\\sum_{r \\\\in R} \\\\mbox{weight}(r)},\n\n        where :math:`R` is a set of reviewers reviewing this product,\n        :math:`\\\\mbox{review}(r)` and :math:`\\\\mbox{weight}(r)` are\n        the review and weight of the reviewer :math:`r`, respectively.\n\n        Args:\n          w: A weight function.\n\n        Returns:\n          absolute difference between old summary and updated one.\n        \"\"\"\n        old = self.summary.v  # pylint: disable=no-member\n\n        reviewers = self._graph.retrieve_reviewers(self)\n        reviews = [self._graph.retrieve_review(\n            r, self).score for r in reviewers]\n        weights = [w(r.anomalous_score) for r in reviewers]\n        if sum(weights) == 0:\n            self.summary = np.mean(reviews)\n        else:\n            self.summary = np.average(reviews, weights=weights)\n        return abs(self.summary.v - old)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new reviewer.", "response": "def new_reviewer(self, name, anomalous=None):\n        \"\"\"Create a new reviewer.\n\n        Args:\n          name: name of the new reviewer.\n          anomalous: initial anomalous score. (default: None)\n\n        Returns:\n          A new reviewer instance.\n        \"\"\"\n        n = self._reviewer_cls(\n            self, name=name, credibility=self.credibility, anomalous=anomalous)\n        self.graph.add_node(n)\n        self.reviewers.append(n)\n        return n"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new product instance.", "response": "def new_product(self, name):\n        \"\"\"Create a new product.\n\n        Args:\n          name: name of the new product.\n\n        Returns:\n          A new product instance.\n        \"\"\"\n        n = self._product_cls(self, name, summary_cls=self._summary_cls)\n        self.graph.add_node(n)\n        self.products.append(n)\n        return n"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a new review from a given reviewer to a given product.", "response": "def add_review(self, reviewer, product, review, date=None):\n        \"\"\"Add a new review from a given reviewer to a given product.\n\n        Args:\n          reviewer: an instance of Reviewer.\n          product: an instance of Product.\n          review: a float value.\n          date: date the review issued.\n\n        Returns:\n          the added new review object.\n\n        Raises:\n          TypeError: when given reviewer and product aren't instance of\n            specified reviewer and product class when this graph is constructed.\n        \"\"\"\n        if not isinstance(reviewer, self._reviewer_cls):\n            raise TypeError(\n                \"Type of given reviewer isn't acceptable:\", reviewer,\n                \", expected:\", self._reviewer_cls)\n        elif not isinstance(product, self._product_cls):\n            raise TypeError(\n                \"Type of given product isn't acceptable:\", product,\n                \", expected:\", self._product_cls)\n        r = self._review_cls(review, date=date)\n        self.graph.add_edge(reviewer, product, review=r)\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef retrieve_products(self, reviewer):\n        if not isinstance(reviewer, self._reviewer_cls):\n            raise TypeError(\n                \"Type of given reviewer isn't acceptable:\", reviewer,\n                \", expected:\", self._reviewer_cls)\n        return list(self.graph.successors(reviewer))", "response": "Retrieve products reviewed by a given reviewer."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef retrieve_reviewers(self, product):\n        if not isinstance(product, self._product_cls):\n            raise TypeError(\n                \"Type of given product isn't acceptable:\", product,\n                \", expected:\", self._product_cls)\n        return list(self.graph.predecessors(product))", "response": "Retrieve the reviewers who reviewed a given product."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef retrieve_review(self, reviewer, product):\n        if not isinstance(reviewer, self._reviewer_cls):\n            raise TypeError(\n                \"Type of given reviewer isn't acceptable:\", reviewer,\n                \", expected:\", self._reviewer_cls)\n        elif not isinstance(product, self._product_cls):\n            raise TypeError(\n                \"Type of given product isn't acceptable:\", product,\n                \", expected:\", self._product_cls)\n\n        try:\n            return self.graph[reviewer][product][\"review\"]\n        except TypeError:\n            raise KeyError(\n                \"{0} does not review {1}.\".format(reviewer, product))", "response": "Retrieve a review that the given reviewer put the given product."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self):\n        w = self._weight_generator(self.reviewers)\n        diff_p = max(p.update_summary(w) for p in self.products)\n        diff_a = max(r.update_anomalous_score() for r in self.reviewers)\n        return max(diff_p, diff_a)", "response": "Update reviewers anomalous scores and products summaries."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _weight_generator(self, reviewers):\n        scores = [r.anomalous_score for r in reviewers]\n        mu = np.average(scores)\n        sigma = np.std(scores)\n\n        if sigma:\n            def w(v):\n                \"\"\"Compute a weight for the given reviewer.\n\n                Args:\n                  v: anomalous score of a reviewer.\n                Returns:\n                  weight of the given anomalous score.\n                \"\"\"\n                try:\n                    exp = math.exp(self.alpha * (v - mu) / sigma)\n                    return 1. / (1. + exp)\n                except OverflowError:\n                    return 0.\n\n            return w\n\n        else:\n            # Sigma = 0 means all reviews have same anomalous scores.\n            # In this case, all reviews should be treated as same.\n            return lambda v: 1.", "response": "Returns a function that computes a weight for a given set of reviewers."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dump_credibilities(self, output):\n        for p in self.products:\n            json.dump({\n                \"product_id\": p.name,\n                \"credibility\": self.credibility(p)\n            }, output)\n            output.write(\"\\n\")", "response": "Dump credibilities of all products."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_absolute_url(self):\n        url_name = \"blog_post_detail\"\n        kwargs = {\"slug\": self.slug}\n        date_parts = (\"year\", \"month\", \"day\")\n        if settings.BLOG_URLS_DATE_FORMAT in date_parts:\n            url_name = \"blog_post_detail_%s\" % settings.BLOG_URLS_DATE_FORMAT\n            for date_part in date_parts:\n                date_value = str(getattr(self.publish_date, date_part))\n                if len(date_value) == 1:\n                    date_value = \"0%s\" % date_value\n                kwargs[date_part] = date_value\n                if date_part == settings.BLOG_URLS_DATE_FORMAT:\n                    break\n        return reverse(url_name, kwargs=kwargs)", "response": "Returns the absolute url for the blog post."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _read_zip(self, filepath):\n        with ZipFile(filepath) as zip:\n            namelist = zip.namelist()\n            if re.match(r'^ips_\\w{5}/?$', namelist[0]):\n                self.log.debug('Setup directory matched: %s', namelist[0])\n            else:\n                self.log.error('No setup directory matched')\n                raise BadZipfile('Unrecognized setup file format')\n\n            versions_path = os.path.join(namelist[0], 'applications/core/data/versions.json')\n            if versions_path not in namelist:\n                raise BadZipfile('Missing versions.json file')\n            versions = json.loads(zip.read(versions_path), object_pairs_hook=OrderedDict)\n            vid = next(reversed(versions))\n            version = versions[vid]\n\n            self.log.debug('Version matched: %s', version)\n            return Version(version, vid)", "response": "Read an IPS installation zipfile and return the core version number"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef merge_dictionaries(a, b):\n  res = {}\n  for k in a:\n    res[k] = a[k]\n  for k in b:\n    res[k] = b[k]\n  return res", "response": "Merge two dictionaries ; duplicate keys get value from b."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __build_sequence(parts):\n  strand = parts[4]\n  seq_length = int(parts[3])\n  total_seq_len = int(parts[5])\n  start = (int(parts[2]) if strand == \"+\"\n           else total_seq_len - int(parts[2]) - seq_length)\n  end = start + seq_length\n  remain = total_seq_len - end\n  return Sequence(parts[1], parts[6], start, end, strand, remain)", "response": "Build a sequence object from a list of pre - tokenized parts."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding an UnknownSequence object from a list of MAF line parts.", "response": "def __build_unknown_sequence(parts):\n  \"\"\"Build unknown seq (e lines) using pre-tokenized parts from MAF line.\n\n  e -- indicates that there is no aligning sequence for a species, but that\n       there are blocks before and after this one that do align. Format is the\n       same as the 's' lines, but the start and length indicate the start and\n       size of the non-aligning region in the sequence and the sequence is\n       replaced with a status character:\n       C -- the sequence before and after is contiguous implying that this\n            region was either deleted in the source or inserted in the\n            reference sequence.\n       I -- there are non-aligning bases in the source species between\n            chained alignment blocks before and after this block.\n       M -- there are non-aligning bases in the source and more than 90% of\n            them are Ns in the source. The browser shows a pale yellow bar.\n       n -- there are non-aligning bases in the source and the next aligning\n            block starts in a new chromosome or scaffold that is bridged\n            by a chain between still other blocks.\n  \"\"\"\n  strand = parts[4]\n  seq_length = int(parts[3])\n  total_seq_len = int(parts[5])\n  start = (int(parts[2]) if strand == \"+\"\n           else total_seq_len - int(parts[2]) - seq_length)\n  end = start + seq_length\n  remain = total_seq_len - end\n  return UnknownSequence(parts[1], start, end, strand, remain,\n                         {EMPTY_ALIGNMENT_STATUS_KEY: parts[6]})"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __annotate_sequence_with_context(seq, i_line_parts):\n  if i_line_parts[1] != seq.name:\n    raise MAFError(\"Trying to populate meta data for sequence \" + seq.name +\n                   \" with i-line information for \" +\n                   str(i_line_parts[1]) + \"; maflormed MAF file?\")\n  if len(i_line_parts) != 6:\n    raise MAFError(\"i-line with \" + str(len(i_line_parts)) + \"; expected 6.\")\n  seq.meta_data[LEFT_STATUS_KEY] = i_line_parts[2]\n  seq.meta_data[LEFT_COUNT_KEY] = int(i_line_parts[3])\n  seq.meta_data[RIGHT_STATUS_KEY] = i_line_parts[4]\n  seq.meta_data[RIGHT_COUNT_KEY] = int(i_line_parts[5])", "response": "This function extracts meta data from pre - tokenized MAF i - line and populate sequence with metadata about the context of the sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __annotate_sequence_with_quality(seq, q_line_parts):\n  if q_line_parts[1] != seq.name:\n    raise MAFError(\"trying to populate meta data for sequence \" + seq.name +\n                   \" with q-line information for \" +\n                   str(q_line_parts[1]) + \"; maflormed MAF file?\")\n  if len(q_line_parts[2]) != len(seq):\n    raise MAFError(\"trying to populate quality meta data for sequence with \" +\n                   \"length \" + str(len(seq)) + \" using quality line with \" +\n                   \"length \" + str(len(q_line_parts[2])) + \"; malformed \" +\n                   \"MAF file?\")\n  seq.meta_data[QUALITY_META_KEY] = q_line_parts[2]", "response": "Populate meta data for a sequence with quality information."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\niterates over MAF format file and yield objects for each block.", "response": "def maf_iterator(fn, index_friendly=False,\n                 yield_class=MultipleSequenceAlignment, yield_kw_args={},\n                 verbose=False):\n  \"\"\"\n  Iterate of MAF format file and yield <yield_class> objects for each block.\n\n  MAF files are arranged in blocks. Each block is a multiple alignment. Within\n  a block, the first character of a line indicates what kind of line it is:\n\n  a -- key-value pair meta data for block; one per block, should be first line\n  s -- a sequence line; see __build_sequence() for details.\n  i -- always come after s lines, and contain information about the context of\n       the sequence; see __annotate_sequence_with_context() for details.\n  e -- indicates that there is no aligning sequence for a species, but that\n       there are blocks before and after this one that do align. See\n       __build_unknown_sequence() for details.\n  q -- quality information about an aligned base in a species. See\n       __annotate_sequence_with_quality()\n\n  :param yield_class:   yield objects returned by this function/constructor;\n                        must accept key-word args of 'sequences' and\n                        'meta_data' which are list and dictionary respectively.\n                        Default is MultipleSequenceAlignment\n  :param yield_kw_args: extra keyword args to pass to 'yield_class'\n  \"\"\"\n\n  try:\n    fh = open(fn)\n  except (TypeError):\n    fh = fn\n  if index_friendly:\n    fh = iter(fh.readline, '')\n\n  sequences = []\n  meta_data = {}\n  for line in fh:\n    line = line.strip()\n    if line == \"\" or line[0] == \"#\":\n      continue\n    parts = line.split()\n    line_type = parts[0].strip()\n    if line_type == A_LINE:\n      if sequences != []:\n        meta_data[SEQ_ORDER_KEY] = [s.name for s in sequences]\n        kw_args = merge_dictionaries({\"sequences\": sequences,\n                                      \"meta_data\": meta_data}, yield_kw_args)\n        yield yield_class(**kw_args)\n      sequences = []\n      meta_data = {}\n      for i in range(1, len(parts)):\n        assert(parts[i].count(\"=\") == 1)\n        piv = parts[i].find(\"=\")\n        meta_data[parts[i][:piv]] = parts[i][piv + 1:]\n    elif line_type == S_LINE:\n      sequences.append(__build_sequence(parts))\n    elif line_type == I_LINE:\n      if len(sequences) < 1:\n        raise MAFError(\"found information line with no preceeding sequence \" +\n                       \"in block\")\n      __annotate_sequence_with_context(sequences[-1], parts)\n    elif line_type == E_LINE:\n      sequences.append(__build_unknown_sequence(parts))\n    elif line_type == Q_LINE:\n      if len(sequences) < 1:\n        raise MAFError(\"found quality line with no preceeding sequence in \" +\n                       \"block\")\n      __annotate_sequence_with_quality(sequences[-1], parts)\n    else:\n      raise MAFError(\"Unknown type of MAF line: \" + line)\n\n  # don't forget to yield the final block\n  if sequences != []:\n    meta_data[SEQ_ORDER_KEY] = [s.name for s in sequences]\n    kw_args = merge_dictionaries({\"sequences\": sequences,\n                                  \"meta_data\": meta_data},\n                                 yield_kw_args)\n    yield yield_class(**kw_args)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding basic frontmatter to a MarkDown file.", "response": "def add_frontmatter(file_name, title, makenew=False):\n    \"\"\"\n    Adds basic frontmatter to a MarkDown file that will be used in a Jekyll project.\n\n    Parameters\n    ==========\n    file_name : String\n        Relative file path from where this method is called to the location of the file that will have frontmatter added.\n    title : String\n        Title of the page that will go into the Jekyll project.\n    makenew : Boolean (OPTIONAL)\n        If set to True, will create a new file with the frontmatter next to the original file with \"_added_frontmatter\" appended to its name. Otherwise, the method simply edits the original file.\n\n    Examples\n    ========\n    Suppose we have the following directory:\n    data/\n        doc.md\n    \n    To write to a new file doc_add_frontmatter.md and add frontmatter:\n    >>> from aide_document import jekyll\n    >>> jekyll.add_frontmatter('doc.md', 'Document', True)\n\n    The last parameter can be omitted if you want to just overwrite doc.md.\n    \"\"\"\n\n    with open(file_name, \"r+\") as oldfile:\n\n        # Creates new file and writes to it if specified\n        if makenew:\n            with open(file_name[:-3] + '_added_frontmatter.md', 'w') as newfile:\n                newfile.write('---\\n' + 'title: ' + title + '\\n' + '---\\n')\n                newfile.write(oldfile.read())\n        \n        # Writes to old file if unspecified\n        else:\n            content = oldfile.read()\n            oldfile.seek(0)\n            oldfile.write('---\\n' + 'title: ' + title + '\\n' + '---\\n' + content)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _derive_db(self):\n        client = self\n        while hasattr(client, 'proxied'):\n            client = client.proxied\n        if hasattr(client, 'client'):\n            client = client.client\n            self._connection_kwargs = client.connection_pool.connection_kwargs\n            self._db = self._connection_kwargs['db']\n        else:\n            self._connection_kwargs = False\n            self._db = 'n/a'", "response": "Derive the database name from the object s attributes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite a line to a log file", "response": "def write_log_file(namespace, document):\n    \"\"\"Writes a line to a log file\n    \n    Arguments:\n        namespace {str} -- namespace of document\n        document {dict} -- document to write to the logs\n    \"\"\"\n    log_timestamp = asctime(gmtime(document[TS]))\n    with open(\"{}{}.{}.log\".format(LOG_DIR, namespace, DAY_STRING), \"a\") as f:\n        log_string = dumps({\n            \"datetime\": log_timestamp.upper(),\n            \"namespace\": namespace,\n            \"log\": document[LOG_KEY]\n        })\n        f.write(\"{}\\n\".format(log_string))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _compute_frequencies(self, word_sent):\n    freq = defaultdict(int)\n    for s in word_sent:\n      for word in s:\n        if word not in self._stopwords:\n          freq[word] += 1\n    # frequencies normalization and fitering\n    m = float(max(freq.values()))\n    for w in freq.keys():\n      freq[w] = freq[w]/m\n      if freq[w] >= self._max_cut or freq[w] <= self._min_cut:\n        del freq[w]\n    return freq", "response": "Compute the frequency of each word in word_sent."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef summarize(self, text, n):\n    sents = sent_tokenize(text)\n    assert n <= len(sents)\n    word_sent = [word_tokenize(s.lower()) for s in sents]\n    self._freq = self._compute_frequencies(word_sent)\n    ranking = defaultdict(int)\n    for i,sent in enumerate(word_sent):\n      for w in sent:\n        if w in self._freq:\n          ranking[i] += self._freq[w]\n    sents_idx = self._rank(ranking, n)    \n    return [sents[j] for j in sents_idx]", "response": "Return a list of n sentences \n      which represent the summary of text."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _rank(self, ranking, n):\n    return nlargest(n, ranking, key=ranking.get)", "response": "return the first n sentences with highest ranking"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef certify_required(value, required=False):\n    # Certify our kwargs:\n    if not isinstance(required, bool):\n        raise CertifierParamError(\n            'required',\n            required,\n        )\n    if value is None:\n        if required:\n            raise CertifierValueError(\n                message=\"required value is None\",\n            )\n        return True", "response": "Certify that a value is present if required."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncertify for integer parameter.", "response": "def _certify_int_param(value, negative=True, required=False):\n    \"\"\"\n    A private certifier (to `certifiable`) to certify integers from `certify_int`.\n\n    :param int value:\n        The value to certify is an integer.\n    :param bool negative:\n        If the value can be negative. Default=False.\n    :param bool required:\n        If the value is required. Default=False.\n     :raises CertifierParamError:\n        Value was not an integer (if required and non-None).\n   \"\"\"\n    if value is None and not required:\n        return\n\n    if not isinstance(value, int):\n        raise CertifierTypeError(\n            message=\"expected integer, but value is of type {cls!r}\".format(\n                cls=value.__class__.__name__),\n            value=value,\n            required=required,\n\n        )\n    if not negative and value < 0:\n        raise CertifierValueError(\n            message=\"expected positive integer, but value is negative\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef certify_parameter(certifier, name, value, kwargs=None):\n    try:\n        certifier(value, **kwargs or {})\n    except CertifierError as err:\n        six.raise_from(\n            CertifierParamError(\n                name,\n                value,\n            ),\n            err)", "response": "Certifier for a parameter."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef enable_from_env(state=None):\n    try:\n        x = os.environ.get(\n            ENVVAR,\n            state,\n        )\n        value = bool(int(x))\n    except Exception:  # pylint: disable=broad-except\n        value = bool(state)\n\n    return enable(value)", "response": "Enable certification for this thread based on the environment variable CERTIFIABLE_STATE."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef compete(source_x, source_o, timeout=None, memlimit=None, cgroup='tictactoe',\n            cgroup_path='/sys/fs/cgroup'):\n    \"\"\"Fights two source files.\n\n    Returns either:\n    * ('ok', 'x' | 'draw' | 'o', GAMEPLAY)\n    * ('error', GUILTY, REASON, GAMEPLAY)\n\n    REASON := utf8-encoded error string (can be up to 65k chars)\n    GAMEPLAY := [ NUM ]\n    GUILTY := 'x' | 'o' (during whose turn the error occured)\n    NUM := 1..81 | 0\n\n    NUM=0 means the move resulted in error (then ERROR_STRING is non-empty)\n    GAMEPLAY is never more than 255 characters long:\n      len(\",\".join(map(str, range(1, 81)))) == 230\n    \"\"\"\n\n    gameplay = []\n    for xo, moveresult, log in run_interactive(source_x, source_o, timeout,\n                                               memlimit, cgroup, cgroup_path):\n        if moveresult[0] == 'error':\n            return 'error', xo, moveresult[1], gameplay + [0]\n        elif moveresult[0] == 'state_coords':\n            gameplay.append(coords_to_num(moveresult[1][1]))\n            state = moveresult[1][0]\n            if state == 'draw' or state == 'x' or state == 'o':\n                return 'ok', state, gameplay", "response": "Runs interactive command and returns the status of the source file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a list of coordinates to a number.", "response": "def coords_to_num(coords):\n    \"\"\"\n    >>> coords_to_num((1,1,1,1))\n    1\n    >>> coords_to_num((3,3,3,3))\n    81\n    >>> coords_to_num((1,1,1,3))\n    3\n    >>> coords_to_num((1,3,1,1))\n    7\n    >>> coords_to_num((3,3,3,1))\n    79\n    >>> coords_to_num((3,3,2,2))\n    71\n    >>> coords_to_num((2,1,1,1))\n    28\n    >>> coords_to_num((2,2,2,2))\n    41\n    \"\"\"\n    x1, y1, x2, y2 = coords\n    row, col = (x1-1) * 3 + x2, (y1-1) * 3 + y2  # row,col on 9x9 board\n    return (row-1) * 9 + col"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _fix_key(key):\n        '''Normalize keys to Unicode strings.'''\n        if isinstance(key, unicode):\n            return key\n        if isinstance(key, str):\n            # On my system, the default encoding is `ascii`, so let's\n            # explicitly say UTF-8?\n            return unicode(key, 'utf-8')\n        raise TypeError(key)", "response": "Normalize keys to Unicode strings."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves the most common items from the cache.", "response": "def truncate_most_common(self, truncation_length):\n        '''\n        Sorts the counter and keeps only the most common items up to\n        ``truncation_length`` in place.\n\n        :type truncation_length: int\n        '''\n        keep_keys = set(v[0] for v in self.most_common(truncation_length))\n        for key in self.keys():\n            if key not in keep_keys:\n                self.pop(key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives the data and type information generate a list of strings for the RST document.", "response": "def rst(value_rule):\n    '''Given the data and type information, generate a list of strings for\n    insertion into a RST document.\n    '''\n    lines = []\n    if value_rule.has('type'):\n        value_type = value_rule['type'].value\n    else:\n        value_type = 'string'\n    if value_type=='ignore':\n        pass\n    else:\n        lines.append('A *'+value_type+'* value is expected.')\n        lines.append('')\n    if value_type==\"string\":\n        pass\n    elif value_type==\"label\":\n        pass\n    elif value_type==\"price\":\n        pass\n    elif value_type==\"qty\":\n        pass\n    elif value_type==\"percent\":\n        pass\n    elif value_type==\"check_list\":\n        pass\n    elif value_type==\"radio_select\":\n        pass\n    elif value_type==\"ignore\":\n        pass\n    elif value_type==\"unit\":\n        pass\n    elif value_type==\"angle\":\n        pass\n    elif value_type==\"file\":\n        pass\n    elif value_type==\"length\":\n        pass\n    elif value_type==\"distance\":\n        pass\n    elif value_type==\"duration\":\n        pass\n    elif value_type==\"mass\":\n        pass\n    elif value_type==\"temperature\":\n        pass\n    elif value_type==\"luminous_intensity\":\n        pass\n    elif value_type==\"current\":\n        pass\n    elif value_type==\"voltage\":\n        pass\n    elif value_type==\"frequency\":\n        pass\n    elif value_type==\"boolean\":\n        pass\n    elif value_type==\"integer\":\n        pass\n    elif value_type==\"float\":\n        pass\n    elif value_type==\"hexadecimal\":\n        pass\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef split_number_unit(string, strip_list=None):\n    ''' \n        takes a string and grabs the leading number and the following unit \n        both the number and unit returned are simple strings\n        returns a triple tuple of (successFlag, number, unit)\n        successFlag is False if the number is invalid\n    '''\n    successFlag = True\n    state = 0\n    number_so_far = \"\"\n    unit_so_far = \"\"\n    decimal_found = False\n    negate_flag = False\n    if string is None:\n        return (False, \"\", \"\")\n    string = string.strip()\n    if not strip_list:\n        strip_list = []\n    if len(string):\n        if string[0]==\"-\":\n            negate_flag = True\n            string = string[1:]\n    if len(string):\n        if string[0]==\".\":\n            string = \"0\"+string  # a string of \".12\" is actually a legit number, but the lack of a preceding 0 will confuse python, so we tack on a zero\n    if len(string):\n        for char in string:\n            if state==0:  # number state\n                if char in ['0','1','2','3','4','5','6','7','8','9']:\n                    number_so_far += char\n                elif char in strip_list:\n                    pass\n                elif char==\".\":\n                    if decimal_found:\n                        successFlag = False # units do not begin with a period. ex: 234.2.anything \n                        state=2\n                    else:\n                        number_so_far += char\n                        decimal_found = True\n                elif char==\"\\n\":\n                    state=2\n                else:\n                    unit_so_far += char\n                    state=1\n            elif state==1: # unit state\n                if char==\"\\n\":\n                    state=2\n                elif char in strip_list:\n                    pass\n                else:\n                    unit_so_far += char\n            else: # discard state\n                pass\n        # clean up \n        unit_so_far = unit_so_far.strip()\n        if len(number_so_far)==0:\n            successFlag = False\n        if negate_flag:\n            number_so_far = \"-\"+number_so_far\n        try:\n            number_so_far = decimal.Decimal(number_so_far)\n        except:\n            successFlag = False\n    else:\n        successFlag = False\n    if not successFlag:\n        return(successFlag, \"\", unit_so_far)\n    return (successFlag, number_so_far, unit_so_far)", "response": "Takes a string and grabs the leading number and the following unit returns a triple of successFlag number and unit"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef circle_touching_line(center, radius, start, end):\n\n    C, R = center, radius\n    A, B = start, end\n\n    a = (B.x - A.x)**2 + (B.y - A.y)**2\n    b = 2 * (B.x - A.x) * (A.x - C.x)       \\\n            + 2 * (B.y - A.y) * (A.y - C.y)\n    c = C.x**2 + C.y**2 + A.x**2 + A.y**2   \\\n            - 2 * (C.x * A.x + C.y * A.y) - R**2\n\n    discriminant = b**2 - 4 * a * c\n\n    if discriminant < 0:\n        return False\n    elif discriminant == 0:\n        u = v = -b / float(2 * a)\n    else:\n        u = (-b + math.sqrt(discriminant)) / float(2 * a)\n        v = (-b - math.sqrt(discriminant)) / float(2 * a)\n\n    if u < 0 and v < 0: return False\n    if u > 1 and v > 1: return False\n\n    return True", "response": "Checks if the given circle touches the given line segment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a config file for an upstart service.", "response": "def generate(self, overwrite=False):\n        \"\"\"Generate a config file for an upstart service.\n        \"\"\"\n        super(Upstart, self).generate(overwrite=overwrite)\n\n        svc_file_template = self.template_prefix + '.conf'\n        self.svc_file_path = self.generate_into_prefix + '.conf'\n\n        self.generate_file_from_template(svc_file_template, self.svc_file_path)\n        return self.files"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nyielding the tokens in the given stream item.", "response": "def tokens(self, si, k):\n        '''`si` is a stream item and `k` is a key in this feature. The purpose\n        of this method is to dereference the token pointers with\n        respect to the given stream item. That is, it translates each\n        sequence of token pointers to a sequence of `Token`.\n\n        '''\n\n        for tokens in self[k]:\n            yield [si.body.sentences[tagid][sid].tokens[tid]\n                   for tagid, sid, tid in tokens]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_lines(fname):\n    for line in fileinput.input(fname):\n        yield fileinput.filelineno(), line.strip()", "response": "Return generator with line number and line for file fname."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves token of TonicDNS API.", "response": "def get_token(username, password, server):\n    \"\"\"Retrieve token of TonicDNS API.\n\n    Arguments:\n\n        usename:  TonicDNS API username\n        password: TonicDNS API password\n        server:   TonicDNS API server\n    \"\"\"\n    method = 'PUT'\n    uri = 'https://' + server + '/authenticate'\n    token = ''\n\n    authinfo = {\n        \"username\": username,\n        \"password\": password,\n        \"local_user\": username}\n\n    token = tonicdns_client(uri, method, token, data=authinfo)\n\n    return token"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tonicdns_client(uri, method, token='', data='', keyword='',\n                    content='', raw_flag=False):\n    \"\"\"TonicDNS API client\n\n    Arguments:\n\n        uri:      TonicDNS API URI\n        method:   TonicDNS API request method\n        token:    TonicDNS API authentication token\n        data:     Post data to TonicDNS API\n        keyword:  Processing keyword of response\n        content:  data exist flag\n        raw_flag: True is return response data, False is pretty printing\n    \"\"\"\n    res = request(uri, method, data, token)\n    if token:\n        if keyword == 'serial':\n            args = {\"token\": token, \"keyword\": keyword, \"content\": content}\n            cur_soa, new_soa = response(uri, method, res, **args)\n            return cur_soa, new_soa\n\n        else:\n            if content is None:\n                args = {\"token\": token, \"keyword\": keyword,\n                        \"content\": content.get('domain')}\n                response(uri, method, res, **args)\n            else:\n                # get sub command\n                args = {\"token\": token, \"keyword\": keyword,\n                        \"raw_flag\": raw_flag}\n                data = response(uri, method, res, **args)\n                return data\n\n    else:\n        args = {\"token\": token, \"keyword\": keyword}\n        token = response(uri, method, res, **args)\n        return token", "response": "TonicDNS API client function"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef request(uri, method, data, token=''):\n    socket.setdefaulttimeout(__timeout__)\n\n    obj = urllib.build_opener(urllib.HTTPHandler)\n\n    # encoding json\n    encoded = json.JSONEncoder(object).encode(data)\n\n    # encoding utf8\n    data_utf8 = encoded.encode('utf-8')\n    req = urllib.Request(uri, data=data_utf8)\n\n    # When encoded(=data) is False, retrieve data as GET method.\n    if encoded:\n        req.add_header('Content-Type', 'application/json')\n\n    if token:\n        req.add_header('x-authentication-token', token)\n\n    req.get_method = lambda: method\n\n    try:\n        res = obj.open(req)\n        return res\n\n    except urllib.URLError as e:\n        sys.stderr.write(\"ERROR: %s\\n\" % e)\n        exit(1)\n\n    except urllib.HTTPError as e:\n        sys.stderr.write(\"ERROR: %s\\n\" % e)\n        exit(1)", "response": "Request to TonicDNS API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch target JSON - > dictionary of record datas with keyword keyword.", "response": "def search_record(datas, keyword):\n    \"\"\"Search target JSON -> dictionary\n\n    Arguments:\n\n        datas: dictionary of record datas\n        keyword: search keyword (default is null)\n\n    Key target is \"name\" or \"content\" or \"type\". default null.\n    Either key and type, or on the other hand.\n\n    When keyword has include camma \",\",\n    Separate keyword to name, type, content.\n    \"\"\"\n\n    key_name, key_type, key_content = False, False, False\n\n    if keyword.find(',') > -1:\n        if len(keyword.split(',')) == 3:\n            key_content = keyword.split(',')[2]\n        key_name = keyword.split(',')[0]\n        key_type = keyword.split(',')[1]\n\n    result = []\n\n    for record in datas['records']:\n\n        if key_name and key_type:\n            if key_content:\n                if ((record['name'].find(key_name) > -1 and\n                     record['type'] == key_type and\n                     record['content'].find(key_content) > -1)):\n                    result.append(record)\n            else:\n                if ((record['name'].find(key_name) > -1 and\n                     record['type'] == key_type)):\n                    result.append(record)\n\n        elif ((record['name'].find(keyword) >= 0 or\n               record['content'].find(keyword) >= 0 or\n               record['type'] == keyword)):\n            result.append(record)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_formatted(datas):\n    if not datas:\n        print(\"No data\")\n        exit(1)\n\n    if isinstance(datas, list):\n        # get all zones\n        # API /zone without :identifier\n        hr()\n        print('%-20s %-8s %-12s'\n              % ('name', 'type', 'notified_serial'))\n        hr()\n        for record in datas:\n\n            # print 'NAME'\n            utils.print_inline(\"%(name)-20s\" % record)\n\n            # print 'TYPE' of SOA record\n            utils.print_inline(\"%(type)-8s\" % record)\n\n            if record.get('notified_serial'):\n                print(\"%(notified_serial)s\" % record)\n            else:\n                print('')\n\n        exit(0)\n\n    elif datas.get('records'):\n        print(\"domain: %(name)s\" % datas)\n\n        if datas.get('type') == 'MASTER' and datas.get('notified_serial'):\n            print(\"serial: %(notified_serial)s\" % datas)\n\n        print(\"DNS   : %(type)s\" % datas)\n\n        # print header\n        hr()\n        print('%-33s %-5s %-25s %-5s %-3s'\n              % ('name', 'type', 'content', 'ttl', 'prio'))\n        hr()\n\n        for record in datas.get('records'):\n\n            # print 'NAME'\n            utils.print_inline(\"%(name)-33s\" % record)\n\n            # print 'TYPE' of SOA record\n            if record.get('type') == 'SOA':\n                print(\"%(type)-5s\" % record)\n\n            # print 'TYPE' of non SOA record\n            else:\n                utils.print_inline(\"%(type)-5s\" % record)\n\n            # print 'CONTENT' of non SOA\n            if record.get('type') == 'SOA':\n                utils.print_inline(\">\\t\\t%(content)-25s \" % record)\n\n            # print 'CONTENT' of SOA record\n            else:\n                utils.print_inline(\"%(content)-25s\" % record)\n\n            # print TTL, and PRIORITY for MX, SRV record\n            if record.get('priority'):\n                utils.print_inline(\"%(ttl)5s\" % record)\n                print(\"%(priority)2s\" % record)\n\n            # print ttl for non SOA record\n            else:\n                print(\"%(ttl)5s \" % record)\n\n        hr()\n\n    elif datas.get('identifier'):\n        # for template\n        print(\"identifier : %(identifier)s\" % datas)\n        print(\"description: %(description)s\" % datas)\n        hr()\n        print('%-33s %-5s %-25s %-5s %-3s'\n              % ('name', 'type', 'content', 'ttl', 'prio'))\n\n        for record in datas.get('entries'):\n\n            # print 'NAME'\n            utils.print_inline(\"%(name)-33s\" % record)\n\n            # print 'TYPE' for SOA\n            if record.get('type') == 'SOA':\n                print(\"%(type)-5s\" % record)\n\n            # print 'TYPE' for non SOA\n            else:\n                utils.print_inline(\"%(type)-5s\" % record)\n\n            # print 'CONTENT' for SOA\n            if record.get('type') == 'SOA':\n                utils.print_inline(\"> %(content)-25s \" % record)\n\n            # print 'CONTENT' for non SOA\n            else:\n                utils.print_inline(\"%(content)-24s\" % record)\n\n            # print 'TTL', and 'PRIORITY'\n            if record.get('priority') is not None:\n                utils.print_inline(\"%(ttl)5s\" % record)\n                print(\"%(priority)2s\" % record)\n\n            # print\n            else:\n                print(\"%(ttl)5s \" % record)\n        hr()\n    else:\n        print(\"No match records\")", "response": "Pretty print the data in a single line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding an effect to be executed when the state reaches the pos.", "response": "def add_deferred_effect(self, effect, pos):\n        \"\"\" Pushes an (pos, effect) tuple onto a stack to later be executed if the\n        state reaches the 'pos'.\"\"\"\n        if not isinstance(pos, (unicode, str)):\n            raise Exception(\"Invalid POS tag. Must be string not %d\" % (type(pos)))\n        if self['speaker_model']['is_syntax_stacked'] == True:\n            self.__dict__['deferred_effects'].insert(0,(pos, effect,))\n        elif self['speaker_model']['is_syntax_stacked'] == False:\n            self.__dict__['deferred_effects'].append((pos, effect,))\n        else:\n            raise Contradiction(\"Speaker Model undefined\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nevaluate deferred effects that are triggered by the prefix of the pos on the current beliefstate.", "response": "def execute_deferred_effects(self, pos):\n        \"\"\" Evaluates deferred effects that are triggered by the prefix of the\n        pos on the current beliefstate. For instance, if the effect is triggered\n        by the 'NN' pos, then the effect will be triggered by 'NN' or 'NNS'.\"\"\"\n        costs = 0\n        to_delete = []\n        for entry in self.__dict__['deferred_effects']:\n            effect_pos, effect = entry\n            if pos.startswith(effect_pos):\n                costs += effect(self)\n                to_delete.append(entry)\n        # we delete afterwards, because Python cannot delete from a list that\n        # is being iterated over without screwing up the iteration.\n        for entry in to_delete:\n            self.__dict__['deferred_effects'].remove(entry)\n        return costs"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting a variable if it is not already set", "response": "def set_environment_variable(self, key, val):\n        \"\"\" Sets a variable if that variable is not already set \"\"\"\n        if self.get_environment_variable(key) in [None, val]:\n            self.__dict__['environment_variables'][key] = val\n        else:\n            raise Contradiction(\"Could not set environment variable %s\" % (key))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\niterate over the belief state s structure breadth - first.", "response": "def iter_breadth_first(self, root=None):\n        \"\"\" Traverses the belief state's structure breadth-first \"\"\"\n        if root == None:\n            root = self\n        yield root\n        last = root \n        for node in self.iter_breadth_first(root):\n            if isinstance(node, DictCell):\n                # recurse\n                for subpart in node:\n                    yield subpart\n                    last = subpart\n            if last == node:\n                return"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_path(self, test_function=None, on_targets=False):\n        assert self.has_referential_domain(), \"need context set\"\n\n        if not test_function:\n            test_function = lambda x, y: True\n           \n        def find_path_inner(part, prefix):\n            name, structure = part\n            if test_function(name, structure):\n                yield prefix + [name]\n            if isinstance(structure, DictCell):\n                for sub_structure in structure:\n                    for prefix2 in find_path_inner(sub_structure,\\\n                            prefix[:] + [name]):\n                        yield prefix2\n\n        prefix = []\n        if on_targets:\n            # apply search to the first target\n            results = []\n            for _, instance in self.iter_singleton_referents():\n                for part in instance:\n                    for entry in find_path_inner(part, prefix[:]):\n                        results.append(['target'] + entry)\n                while results:\n                    yield results.pop()\n                break # only use first instance\n        else:\n            # apply search to self\n            for part in self:\n                for entry in find_path_inner(part, prefix[:]):\n                    yield entry", "response": "General helper method that iterates breadth - first over the referential_domain s components and returns a path to the entry in that cell."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the n - th unique value of a keypath.", "response": "def get_nth_unique_value(self, keypath, n, distance_from, open_interval=True):\n        \"\"\"\n        Returns the `n-1`th unique value, or raises\n        a contradiction if that is out of bounds\n        \"\"\"\n        unique_values = self.get_ordered_values(keypath, distance_from, open_interval)\n        if 0 <= n < len(unique_values):\n            #logging.error(\"%i th unique value is %s\" % (n, str(unique_values[n])))\n            return unique_values[n]\n        else:\n            raise Contradiction(\"n-th Unique value out of range: \" + str(n))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_ordered_values(self, keypath, distance_from, open_interval=True):\n\n        values = []\n        if keypath[0] == 'target':\n            # instances start with 'target' prefix, but \n            # don't contain it, so we remove it here.\n            keypath = keypath[1:]\n        for _, instance in self.iter_singleton_referents():\n            value = instance.get_value_from_path(keypath)\n            if hasattr(value, 'low') and value.low != value.high:\n                return []\n            values.append(float(value))\n\n        if len(values) == 0:\n            return []\n        values = np.array(values)\n        anchor = values.min()\n        diffs = values - anchor\n        if distance_from == 'max':\n            anchor = values.max()\n            diffs = anchor - values\n        if distance_from == 'mean':\n            anchor = values.mean()\n            diffs = abs(anchor - values)\n\n        sdiffs = np.unique(diffs)\n        sdiffs.sort()\n        results = []\n      \n        for ix, el in enumerate(sdiffs):\n            mask = diffs <= el\n            vals = values[mask]\n            if False:\n                # when vagueness has been made precise through an ordinal\n                results.append(IntervalCell(vals.min(), vals.max()))\n            elif distance_from == 'max':\n                if open_interval:\n                    results.append(IntervalCell(vals.min(), np.inf))\n                else:\n                    results.append(IntervalCell(vals.min(), vals.min()))\n            elif distance_from == 'min':\n                if open_interval:\n                    results.append(IntervalCell(-np.inf, vals.max()))\n                else:\n                    results.append(IntervalCell(vals.max(), vals.max()))\n            elif distance_from == 'mean':\n                if ix+1 == len(sdiffs): continue  # skip last\n                results.append(IntervalCell(vals.min(), vals.max()))\n        return results", "response": "Returns the ordered list of values for the keypath."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a list of keys returns the paths to the objects that have the specified attribute names.", "response": "def get_paths_for_attribute_set(self, keys):\n        \"\"\"\n        Given a list/set of keys (or one key), returns the parts that have\n        all of the keys in the list.\n\n        Because on_targets=True, this DOES NOT WORK WITH TOP LEVEL PROPERTIES,\n        only those of targets.\n\n        These paths are not pointers to the objects themselves, but tuples of\n        attribute names that allow us to (attempt) to look up that object in any\n        belief state.\n        \"\"\"\n        if not isinstance(keys, (list, set)):\n            keys = [keys]\n\n        has_all_keys = lambda name, structure: \\\n                all(map(lambda k: k in structure, keys))\n        return self.find_path(has_all_keys, on_targets=True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_parts(self):\n        return self.find_path(lambda x: isinstance(x[1], DictCell), on_targets=True)", "response": "Returns a list of all DictCells in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of all paths to all attributes that have a particular name.", "response": "def get_paths_for_attribute(self, attribute_name):\n        \"\"\"\n        Returns a path list to all attributes that have with a particular name.\n        \"\"\"\n        has_name = lambda name, structure:  name == attribute_name\n        return self.find_path(has_name, on_targets=True)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef merge(self, keypath, value, op='set'):\n        negated = False\n        keypath = keypath[:] # copy it \n        if keypath[0] == 'target':\n            # only pull negated if it can potentially modify target\n            negated = self.get_environment_variable('negated', pop=False, default=False)\n            if negated:\n                keypath[0] = \"distractor\"\n\n        if keypath not in self:\n            first_referent = None\n            if keypath[0] in ['target', 'distractor']:\n                has_targets = False \n                for _, referent in self.iter_singleton_referents():\n                    has_targets = True\n                    if keypath[1:] in referent:\n                        first_referent = referent\n                        break\n                if first_referent is None:\n                    # this happens when none of the available targets have the\n                    # path that is attempted to being merged to\n                    if has_targets:\n                        raise CellConstructionFailure(\"Cannot merge; no target: %s\" \\\n                            % (str(keypath)))\n                    else:\n                        # this will always happen when size is 0\n                        raise CellConstructionFailure(\"Empty belief state\")\n                # find the type and add it to the \n                cell = first_referent.get_value_from_path(keypath[1:]).stem()\n                self.add_cell(keypath, cell)\n            else:\n                # should we allow merging undefined components outside of target?\n                raise Exception(\"Could not find Keypath %s\" % (str(keypath)))\n\n        # break down keypaths into \n        cell = self\n        if not isinstance(keypath, list):\n            keypath = [keypath]\n        for key in keypath:\n            cell = cell[key]\n        # perform operation (set, <=, >= etc)\n        try:\n            return getattr(cell, op)(value)\n        except Contradiction as ctrd:\n            # add more information to the contradiction\n            raise Contradiction(\"Could not merge %s with %s: %s \" % (str(keypath), str(value), ctrd))", "response": "This method merges the value of a keypath into a single cell at a given keypath."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a new cell to the end of keypath of type cell", "response": "def add_cell(self, keypath, cell):\n        \"\"\" Adds a new cell to the end of `keypath` of type `cell`\"\"\"\n        keypath = keypath[:] # copy\n        inner = self  # the most inner dict where cell is added\n        cellname = keypath  # the name of the cell\n        assert keypath not in self, \"Already exists: %s \" % (str(keypath))\n        if isinstance(keypath, list):\n            while len(keypath) > 1:\n                cellname = keypath.pop(0)\n                if cellname not in inner:\n                    inner.__dict__['p'][cellname] = DictCell()\n                inner = inner[cellname] # move in one\n            cellname = keypath[0]\n        # now we can add 'cellname'->(Cell) to inner (DictCell)\n        inner.__dict__['p'][cellname] = cell\n        return inner[cellname]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True iff the calling instance implies the other beliefstate.", "response": "def is_entailed_by(self, other):\n        \"\"\"\n        Given two beliefstates, returns True iff the calling instance\n        implies the other beliefstate, meaning it contains at least the same\n        structure (for all structures) and all values (for all defined values).\n        \n        Inverse of `entails`.\n\n        Note: this only compares the items in the DictCell, not `pos`,\n        `environment_variables` or `deferred_effects`.\n        \"\"\"\n        for (s_key, s_val) in self:\n            if s_key in other:\n                if not hasattr(other[s_key], 'implies'):\n                    raise Exception(\"Cell for %s is missing implies()\" % s_key)\n                if not other[s_key].implies(s_val):\n                    return False\n            else:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_equal(self, other):\n        return hash(self) == hash(other)\n        for (this, that) in itertools.izip_longest(self, other):\n            if that[0] is None or this[0] != that[0]:\n                # compare attribute names\n                return False\n            if not this[1].is_equal(that[1]):\n                # compare values\n                return False\n        return True", "response": "Compare two DictCells to see if they are equal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_contradictory(self, other):\n        for (s_key, s_val) in self:\n            if s_key in other and s_val.is_contradictory(other[s_key]):\n                return True \n        return False", "response": "Return True if the other beliefstates are consistent with or accessible from the caller."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the size of the belief state.", "response": "def size(self):\n        \"\"\" Returns the size of the belief state.\n\n        Initially if there are $n$ consistent members, (the result of `self.number_of_singleton_referents()`) \n        then there are generally $2^{n}-1$ valid belief states.\n        \"\"\"\n        n = self.number_of_singleton_referents()\n        targets = list(self.iter_referents_tuples())\n        n_targets = len(targets)\n        if n == 0 or n_targets == 0:\n            return  0\n\n        #if len(self.__dict__['deferred_effects']) != 0:\n        #    return -1 \n        size1 = len(list(self.iter_referents_tuples()))\n        tlow, thigh = self['targetset_arity'].get_tuple()\n        clow, chigh = self['contrast_arity'].get_tuple()\n        return size1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iter_referents(self):\n        tlow, thigh = self['targetset_arity'].get_tuple()\n        clow, chigh = self['contrast_arity'].get_tuple()\n\n        referents = list(self.iter_singleton_referents())\n        t = len(referents)\n        low = max(1, tlow)\n        high = min([t,  thigh])\n\n        for targets in itertools.chain.from_iterable(itertools.combinations(referents, r) \\\n            for r in reversed(xrange(low, high+1))):\n            if clow <= t-len(targets) <= chigh:\n                yield  targets", "response": "Yields all target sets that are compatible with the current beliefstate."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_referents_tuples(self):\n        tlow, thigh = self['targetset_arity'].get_tuple()\n        clow, chigh = self['contrast_arity'].get_tuple()\n        singletons = list([int(i) for i,_ in self.iter_singleton_referents()])\n        t = len(singletons)\n        low = int(max(1, tlow))\n        high = int(min([t,  thigh]))\n        for elements in itertools.chain.from_iterable(itertools.combinations(singletons, r) \\\n                for r in reversed(xrange(low, high+1))):\n            if clow <= t-len(elements) <= chigh:\n                yield  elements", "response": "Generates target sets that are compatible with\n        the current beliefstate."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef number_of_singleton_referents(self):\n        if self.__dict__['referential_domain']:\n            ct = 0\n            for i in self.iter_singleton_referents():\n                ct += 1\n            return ct\n        else:\n            raise Exception(\"self.referential_domain must be defined\")", "response": "Returns the number of singleton elements of the current belief state."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating over all of the singleton members of the context set.", "response": "def iter_singleton_referents(self):\n        \"\"\"\n        Iterator of all of the singleton members of the context set.\n\n        NOTE: this evaluates entities one-at-a-time, and does not handle relational constraints.\n        \"\"\"\n        try:\n            for member in self.__dict__['referential_domain'].iter_entities():\n                if self['target'].is_entailed_by(member) and (self['distractor'].empty() or not self['distractor'].is_entailed_by(member)):\n                    yield member['num'], member\n        except KeyError:\n            raise Exception(\"No referential_domain defined\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\niterates over all of the singleton members s id number of the context set.", "response": "def iter_singleton_referents_tuples(self):\n        \"\"\"\n        Iterator of all of the singleton members's id number of the context set.\n\n        NOTE: this evaluates entities one-at-a-time, and does not handle relational constraints.\n        \"\"\"\n        try:\n            for member in self.__dict__['referential_domain'].iter_entities():\n                if self['target'].is_entailed_by(member) and (self['distractor'].empty() or not self['distractor'].is_entailed_by(member)):\n                    yield member['num'].low\n        except KeyError:\n            raise Exception(\"No referential_domain defined\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_latex(self, number=0):\n        latex = r\"\"\"\\avmfont{\\sc}\n\\avmoptions{sorted,active}\n\\avmvalfont{\\rm}\"\"\"\n        latex += \"\\n\\nb_%i = \\\\begin{avm} \\n \" % number\n        latex += DictCell.to_latex(self)\n        latex += \"\\n\\\\end{avm}\\n\"\n        return latex", "response": "Returns a LaTeX representation of the belief state as an attribute - value matrix."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a deep copy of the BeliefState.", "response": "def copy(self):\n        \"\"\"\n        Copies the BeliefState by recursively deep-copying all of\n        its parts.  Domains are not copied, as they do not change\n        during the interpretation or generation.\n        \"\"\"\n        copied = BeliefState(self.__dict__['referential_domain']) \n        for key in ['environment_variables', 'deferred_effects', 'pos', 'p']:\n            copied.__dict__[key] = copy.deepcopy(self.__dict__[key])\n        return copied"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninvoke callback that should return a tuple. representing the SOAP request and response respectively.", "response": "def processRequest(cls, ps, **kw):\n        \"\"\"invokes callback that should return a (request,response) tuple.\n        representing the SOAP request and response respectively.\n        ps -- ParsedSoap instance representing HTTP Body.\n        request -- twisted.web.server.Request\n        \"\"\"\n        resource = kw['resource']\n        method = resource.getOperation(ps, None) # This getOperation method is valid for ServiceSOAPBinding subclass\n        rsp = method(ps, **kw)[1] # return (request, response) but we only need response\n        return rsp"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_range(cls, range_list, register_flag=True):\n        s = dict_from_range(range_list)\n        obj = cls.from_serializable(s, register_flag)\n        return obj", "response": "core class method to create visible objects from a nested list of integers"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef gp_datdir(initial, topN):\n  # prepare input/output directories\n  inDir, outDir = getWorkDirs()\n  initial = initial.capitalize()\n  inDir = os.path.join(inDir, initial)\n  if not os.path.exists(inDir): # catch missing initial\n    return \"initial %s doesn't exist\" % initial\n  # prepare data\n  data = OrderedDict()\n  for file in os.listdir(inDir):\n    country = os.path.splitext(file)[0]\n    file_url = os.path.join(inDir, file)\n    data[country] = np.loadtxt(open(file_url, 'rb')) # load data\n    # set y-axis unit to 1M\n    data[country][:, 1] /= 1e6\n    if data[country].shape[1] > 2: data[country][:, 3:] /= 1e6\n  logging.debug(data) # shown if --log flag given on command line\n  # sort countries according to mean population (highest -> lowest)\n  sorted_data = OrderedDict(sorted(\n    data.items(), key = lambda t: np.mean(t[1][:,1]), reverse = True\n  ))\n  # \"pop\" (select) N most populated countries\n  top_data = OrderedDict(\n    sorted_data.popitem(last = False) for i in xrange(topN)\n    if sorted_data\n  )\n  # generate plot using ccsgp.make_plot\n  nSets = len(top_data)\n  make_plot(\n    data = top_data.values(),\n    properties = [ getOpts(i) for i in xrange(nSets) ],\n    titles = top_data.keys(), # use data keys as legend titles\n    name = os.path.join(outDir, initial),\n    key = [ 'at graph 1., 1.2', 'maxrows 2' ],\n    ylabel = 'total population ({/Symbol \\664} 10^{6})',\n    xlabel = 'year', rmargin = 0.99, tmargin = 0.85, size='8.5in,8in'\n  )\n  return 'done'", "response": "example for plotting from a text file via numpy. loadtxt\n\n"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint a running instance s metadata key", "response": "def awsReadMetadataKey():\n  \"\"\"Print key from a running instance's metadata\"\"\"\n  parser = argparse.ArgumentParser()\n\n  parser.add_argument(\"--key\",\n                      dest=\"keyname\",\n                      help=\"Which metadata key to read\")\n\n  cli = parser.parse_args()\n\n  print getMetadataKey(name=cli.keyname)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if a timestamp is valid.", "response": "def is_timestamp_valid(self, timestamp):\n        \"\"\"Timestamp must be string in %Y-%m-%dT%H:%M:%S. format \"\"\"\n\n        try:\n            timestamp_server = datetime.utcnow()\n            timestamp_client = datetime.strptime(timestamp, \"%Y-%m-%dT%H:%M:%S\")\n\n            d1_ts = time.mktime(timestamp_client.timetuple())\n            d2_ts = time.mktime(timestamp_server.timetuple())\n\n            diff = int(d2_ts-d1_ts) / 60\n\n            if diff > self.timestamp_window:\n                raise ImmediateHttpResponse(response=HttpBadRequest('Exceeded timestamp window'))\n        except Exception, e:\n            raise ImmediateHttpResponse(response=HttpBadRequest('Unknown error on timestamp validation'))\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nimport the results of the simulation from the given yaml file.", "response": "def import_results(log, pathToYamlFile):\n    \"\"\"\n    *Import the results of the simulation (the filename is an argument of this models)*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``pathToYamlFile`` -- the path to the yaml file to be imported\n\n    **Return:**\n        - None\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    import yaml\n    ## LOCAL APPLICATION ##\n\n    ################ >ACTION(S) ################\n    fileName = pathToYamlFile\n    stream = file(fileName, 'r')\n    yamlContent = yaml.load(stream)\n    snSurveyDiscoveryTimes = yamlContent['Discoveries Relative to Survey Year']\n    lightCurveDiscoveryTimes = yamlContent[\n        'Discoveries Relative to Peak Magnitudes']\n    snTypes = yamlContent['SN Types']\n    redshifts = yamlContent['Redshifts']\n    cadenceDictionary = yamlContent['Cadence Dictionary']\n    peakAppMagList = yamlContent['Peak Apparent Magnitudes']\n    snCampaignLengthList = yamlContent['Campaign Length']\n\n    # log.info('yamlContent %s' % (yamlContent,))\n    stream.close()\n\n    return snSurveyDiscoveryTimes, lightCurveDiscoveryTimes, snTypes, redshifts, cadenceDictionary, peakAppMagList, snCampaignLengthList"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef determine_sn_rate(\n        log,\n        lightCurveDiscoveryTimes,\n        snSurveyDiscoveryTimes,\n        redshifts,\n        surveyCadenceSettings,\n        surveyArea,\n        CCSNRateFraction,\n        transientToCCSNRateFraction,\n        peakAppMagList,\n        snCampaignLengthList,\n        extraSurveyConstraints,\n        pathToOutputPlotFolder,\n        lowerRedshiftLimit=0.01,\n        upperRedshiftLimit=1.0,\n        redshiftResolution=0.1\n):\n    \"\"\"\n    *Plot the SFR History as a function of redshift*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``lightCurveDiscoveryTimes`` -- the lightcurve discovery times of the SN\n        - ``snSurveyDiscoveryTimes`` -- the supernova discovery times relative to the survey year\n        - ``redshifts`` -- the redshifts of the SN\n        - ``surveyArea`` -- the area of the survey considered in square degree\n        - ``surveyCadenceSettings`` -- the cadence settings for the survey\n        - ``CCSNRateFraction`` -- the fraction of the IMF attributed to the progenitors of CCSN\n        - ``transientToCCSNRateFraction`` -- the ratio of the transient rate to the rate of CCSNe\n        - ``peakAppMagList`` -- a list of the peak magnitudes for each SN in each filter\n        - ``snCampaignLengthList`` -- a list of campaign lengths in each filter\n        - ``extraSurveyConstraints`` -- some extra survey constraints\n        - ``pathToOutputPlotDirectory`` -- path to add plots to\n        - ``lowerRedshiftLimit`` -- the lower redshist limit out to which to determine the rate\n        - ``upperRedshiftLimit`` -- the redshist limit out to which to determine the rate\n        - ``redshiftResolution`` -- the redshist resolution ued to determine the rate\n\n    **Return:**\n        - ``imageLink`` -- MD link to the output plot\n        - ``totalRate`` -- the final transient rate calculated\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    import numpy as np\n    ## LOCAL APPLICATION ##\n    import dryxPython.astrotools as da\n    import dryxPython.plotting as dp\n\n    ################ >ACTION(S) ################\n    filters = ['g', 'r', 'i', 'z']\n\n    sdssArea = 5713.\n    sdssSFRupperRedshiftLimit = 0.033\n    sdssSFR = 14787.21\n    # CCSNRateFraction = 0.007\n    # transientToCCSNRateFraction = 1./10000.\n    transientRateFraction = float(\n        CCSNRateFraction) * float(transientToCCSNRateFraction)\n\n    anchor = redshiftResolution / sdssSFRupperRedshiftLimit\n    normaiseSFR = sdssSFR * anchor**3\n    areaRatio = surveyArea / sdssArea\n    #log.info('normaiseSFR %s' % (normaiseSFR,))\n\n    anchorVolume = da.convert_redshift_to_distance(redshiftResolution)[\n        'dl_mpc']**3\n    #log.info('anchorVolume %s' % (anchorVolume,))\n    xRange = [lowerRedshiftLimit, upperRedshiftLimit, redshiftResolution]\n\n    multiplier = int(1 / redshiftResolution)\n    redshiftResolution = int(redshiftResolution * multiplier)\n    upperRedshiftLimit = int(upperRedshiftLimit * multiplier)\n\n    shelltransientRateDensityList = []\n    shellRedshiftList = []\n    discoveryRedshiftList = []\n    discoveryFractionList = []\n    tooFaintRedshiftList = []\n    tooFaintFractionList = []\n    shortCampaignRedshiftList = []\n    shortCampaignFractionList = []\n    transientShellRateList = []\n    tooFaintShellRateList = []\n    shortCampaignShellRateList = []\n\n    count = 0\n    for shellRedshift in np.arange(lowerRedshiftLimit, upperRedshiftLimit, redshiftResolution):\n        count += 1\n        shellRedshift = float(shellRedshift) / float(multiplier)\n        shellWidth = float(redshiftResolution) / float(multiplier)\n        shellMiddle = shellRedshift - shellWidth / 2.\n        shellRedshiftBottom = shellRedshift - shellWidth\n        log.debug('%s. shellRedshift %s' % (count, shellRedshift,))\n        log.debug('%s. shellWidth %s' % (count, shellWidth,))\n        log.debug('%s. shellMiddle %s' % (count, shellMiddle,))\n        log.debug('%s. shellRedshiftBottom %s' % (count, shellRedshiftBottom,))\n\n        SFH = (1. + shellMiddle)**2.5\n        if shellRedshift == 0.:\n            shellVolume = 9.\n        elif shellRedshift > shellWidth:\n            shellVolume = da.convert_redshift_to_distance(shellRedshift)[\n                'dl_mpc']**3 - da.convert_redshift_to_distance(shellRedshift - shellWidth)['dl_mpc']**3\n        else:\n            shellVolume = da.convert_redshift_to_distance(shellRedshift)[\n                'dl_mpc']**3\n        shellSFRDensity = (SFH / anchor) * normaiseSFR * \\\n            (shellVolume / anchorVolume)\n        shelltransientRateDensity = shellSFRDensity * transientRateFraction\n        shelltransientRateDensity = shelltransientRateDensity * areaRatio\n        timeDilation = 1. / (1. + shellMiddle)\n        shelltransientRateDensity = shelltransientRateDensity * timeDilation\n\n        log.debug('shelltransientRateDensity %s' %\n                  (shelltransientRateDensity,))\n        shelltransientRateDensityList.append(shelltransientRateDensity)\n        shellRedshiftList.append(shellMiddle)\n\n        discoveryFraction, tooFaintFraction, shortCampaignFraction = calculate_fraction_of_sn_discovered(\n            log, surveyCadenceSettings, snSurveyDiscoveryTimes, redshifts, peakAppMagList, snCampaignLengthList, extraSurveyConstraints, shellRedshiftBottom, shellRedshift)\n        # if discoveryFraction != 0.:\n        discoveryRedshiftList.append(shellMiddle)\n        discoveryFractionList.append(discoveryFraction)\n        log.debug('shell redshift %s, discoveryFraction %s' %\n                  (shellMiddle, discoveryFraction))\n        # if tooFaintFraction != 0.:\n        tooFaintRedshiftList.append(shellMiddle)\n        tooFaintFractionList.append(tooFaintFraction)\n        # if shortCampaignFraction != 0.:\n        shortCampaignRedshiftList.append(shellMiddle)\n        shortCampaignFractionList.append(shortCampaignFraction)\n\n        transientShellRate = discoveryFraction * shelltransientRateDensity\n        tooFaintShellRate = tooFaintFraction * shelltransientRateDensity\n        shortCampaignShellRate = shortCampaignFraction * shelltransientRateDensity\n        transientShellRateList.append(transientShellRate)\n        tooFaintShellRateList.append(tooFaintShellRate)\n        shortCampaignShellRateList.append(shortCampaignShellRate)\n\n    discoveryRedshiftListArray = np.array(discoveryRedshiftList)\n    discoveryFractionListArray = np.array(discoveryFractionList)\n    tooFaintRedshiftListArray = np.array(tooFaintRedshiftList)\n    tooFaintFractionListArray = np.array(tooFaintFractionList)\n    shortCampaignRedshiftListArray = np.array(shortCampaignRedshiftList)\n    shortCampaignFractionListArray = np.array(shortCampaignFractionList)\n    polynomialDict = {}\n    orginalDataDictionary = {}\n    pleasePlot = False\n    if len(discoveryRedshiftListArray) > 0:\n        pleasePlot = True\n        thisPoly = np.polyfit(discoveryRedshiftListArray,\n                              discoveryFractionListArray, 12)\n        discoveryRateCurve = np.poly1d(thisPoly)\n        # polynomialDict[\"Discovery Rate\"] = discoveryRateCurve\n        orginalDataDictionary[\"Discovery Rate\"] = [\n            discoveryRedshiftListArray, discoveryFractionListArray]\n    else:\n        discoveryRateCurve = False\n    if len(tooFaintRedshiftListArray) > 0:\n        pleasePlot = True\n        thisPoly = np.polyfit(tooFaintRedshiftListArray,\n                              tooFaintFractionListArray, 12)\n        tooFaintRateCurve = np.poly1d(thisPoly)\n        #polynomialDict[\"Detected - too faint to constrain as transient\"] = tooFaintRateCurve\n        orginalDataDictionary[\"Detected - too faint to constrain as transient\"] = [\n            tooFaintRedshiftListArray, tooFaintFractionListArray]\n    else:\n        tooFaintRateCurve = False\n    if len(shortCampaignRedshiftListArray) > 0:\n        pleasePlot = True\n        thisPoly = np.polyfit(shortCampaignRedshiftListArray,\n                              shortCampaignFractionListArray, 12)\n        shortCampaignRateCurve = np.poly1d(thisPoly)\n        #polynomialDict[\"Detected - campaign to short to constrain as transient\"] = shortCampaignRateCurve\n        orginalDataDictionary[\"Detected - campaign to short to constrain as transient\"] = [\n            shortCampaignRedshiftListArray, shortCampaignFractionListArray]\n    else:\n        shortCampaignRateCurve = False\n\n    if pleasePlot:\n\n        imageLink = plot_polynomial(\n            log,\n            title='PS1-transient Survey - Precentage of transient Detected',\n            polynomialDict=polynomialDict,\n            orginalDataDictionary=orginalDataDictionary,\n            pathToOutputPlotsFolder=pathToOutputPlotFolder,\n            xRange=xRange,\n            xlabel=False,\n            ylabel=False,\n            xAxisLimits=False,\n            yAxisLimits=[-0.05, 1.05],\n            yAxisInvert=False,\n            prependNum=False,\n            legend=True)\n    else:\n        imageLink = \"\"\n\n    shelltransientRateDensityArray = np.array(shelltransientRateDensityList)\n    shellRedshiftArray = np.array(shellRedshiftList)\n    log.debug('shellRedshiftArray %s' % (shellRedshiftArray,))\n    log.debug('shelltransientRateDensityArray %s' %\n              (shelltransientRateDensityArray,))\n    thisPoly = np.polyfit(shellRedshiftArray,\n                          shelltransientRateDensityArray, 3)\n    transientRateCurve = np.poly1d(thisPoly)\n    # log.info('flat %s' % (flatPoly,))\n    polynomialDict = {\"transient Rate\": transientRateCurve}\n    orginalDataDictionary = {\"transient Rate\": [\n        shellRedshiftArray, shelltransientRateDensityArray]}\n    imageLink = plot_polynomial(\n        log,\n        title='PS1 MDF transient Rate Density',\n        polynomialDict=polynomialDict,\n        orginalDataDictionary=orginalDataDictionary,\n        pathToOutputPlotsFolder=pathToOutputPlotFolder,\n        xRange=xRange,\n        xlabel=False,\n        ylabel=False,\n        xAxisLimits=False,\n        yAxisLimits=False,\n        yAxisInvert=False,\n        prependNum=False)\n\n    polynomialDict = {}\n    orginalDataDictionary = {}\n    pleasePlot = False\n    if discoveryRateCurve:\n        pleasePlot = True\n        discoveredtransientCurve = transientRateCurve * discoveryRateCurve\n        discoveredtransientCurve = np.poly1d(discoveredtransientCurve)\n        #polynomialDict['Discovered transient Rate'] = discoveredtransientCurve\n        orginalDataDictionary['Discovered transient Rate'] = [\n            shellRedshiftArray, shelltransientRateDensityArray * discoveryFractionListArray]\n    if tooFaintRateCurve:\n        pleasePlot = True\n        tooFainttransientCurve = transientRateCurve * tooFaintRateCurve\n        tooFainttransientCurve = np.poly1d(tooFainttransientCurve)\n        #polynomialDict[\"Detected - too faint to constrain as transient\"] = tooFainttransientCurve\n        orginalDataDictionary[\"Detected - too faint to constrain as transient\"] = [\n            shellRedshiftArray, shelltransientRateDensityArray * tooFaintFractionListArray]\n    if shortCampaignRateCurve:\n        pleasePlot = True\n        shortCampaigntransientCurve = transientRateCurve * shortCampaignRateCurve\n        shortCampaigntransientCurve = np.poly1d(shortCampaigntransientCurve)\n        #polynomialDict[\"Detected - campaign to short to constrain as transient\"] = shortCampaigntransientCurve\n        orginalDataDictionary[\"Detected - campaign to short to constrain as transient\"] = [\n            shellRedshiftArray, shelltransientRateDensityArray * shortCampaignFractionListArray]\n\n    maxInList = max(redshifts) * 1.1\n\n    if pleasePlot:\n        imageLink = plot_polynomial(\n            log,\n            title='PS1-transient Survey - Relative Detected Rates',\n            polynomialDict=polynomialDict,\n            orginalDataDictionary=orginalDataDictionary,\n            pathToOutputPlotsFolder=pathToOutputPlotFolder,\n            xRange=[0.01, maxInList, 0.01],\n            xlabel=False,\n            ylabel=False,\n            xAxisLimits=False,\n            yAxisLimits=[-0.05, 3.5],\n            yAxisInvert=False,\n            prependNum=False,\n            legend=True)\n    else:\n        imageLink = \"\"\n\n    log.debug('transientShellRateList: %s' % (transientShellRateList,))\n\n    totalRate = 0.\n    for item in transientShellRateList:\n        totalRate += item\n\n    tooFaintRate = 0.\n    for item in tooFaintShellRateList:\n        tooFaintRate += item\n\n    shortCampaignRate = 0.\n    for item in shortCampaignShellRateList:\n        shortCampaignRate += item\n\n    totalRate = \"%1.0f\" % (totalRate,)\n    tooFaintRate = \"%1.0f\" % (tooFaintRate,)\n    shortCampaignRate = \"%1.0f\" % (shortCampaignRate,)\n    return imageLink, totalRate, tooFaintRate, shortCampaignRate", "response": "This function will plot the SFR History as a function of redshift and the SN rate of the given species."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef log_the_survey_settings(\n        log,\n        pathToYamlFile):\n    \"\"\"\n    *Create a MD log of the survey settings*\n\n    **Key Arguments:**\n        - ``log`` -- logger\n        - ``pathToYamlFile`` -- yaml results file\n\n    **Return:**\n        - None\n    \"\"\"\n    ################ > IMPORTS ################\n    ## STANDARD LIB ##\n    ## THIRD PARTY ##\n    import yaml\n    ## LOCAL APPLICATION ##\n    from datetime import datetime, date, time\n    now = datetime.now()\n    now = now.strftime(\"%Y%m%dt%H%M%S\")\n\n    ################ >ACTION(S) ################\n    # IMPORT THE SIMULATION SETTINGS\n    fileName = pathToYamlFile\n    stream = file(fileName, 'r')\n    yamlContent = yaml.load(stream)\n    snSurveyDiscoveryTimes = yamlContent['Discoveries Relative to Survey Year']\n    lightCurveDiscoveryTimes = yamlContent[\n        'Discoveries Relative to Peak Magnitudes']\n    snTypes = yamlContent['SN Types']\n    redshifts = yamlContent['Redshifts']\n    cadenceDictionary = yamlContent['Cadence Dictionary']\n    peakAppMagList = yamlContent['Peak Apparent Magnitudes']\n    snCampaignLengthList = yamlContent['Campaign Length']\n\n    programSettings = yamlContent[\"Program Settings\"]\n\n    limitingMags = yamlContent[\"Limiting Magnitudes\"]\n    # for key in limitingMags:\n    # log.debug('filter: %s, limit: %s' % (key, limitingMags[key]))\n\n    sampleNumber = yamlContent[\"Simulation Sample\"]\n\n    peakMagnitudeDistributions = yamlContent[\n        \"SN Absolute Peak-Magnitude Distributions\"]\n    #log.debug('snDistributions[magnitude] %s' % (snDistributions[\"magnitude\"],))\n    #log.debug('snDistributions[sigma] %s' % (snDistributions[\"sigma\"],))\n\n    relativeRatesSet = yamlContent[\"Relative Rate Set to Use\"]\n    relativeSNRates = yamlContent[\"Relative SN Rates\"][relativeRatesSet]\n    #log.debug('relativeSNRates %s' % (relativeSNRates,))\n    lowerRedshiftLimit = yamlContent[\"Lower Redshift Limit\"]\n    upperRedshiftLimit = yamlContent[\"Upper Redshift Limit\"]\n    #log.debug('upperRedshiftLimit %s' % (upperRedshiftLimit,))\n    redshiftResolution = yamlContent[\"Redshift Resolution\"]\n\n    extinctionSettings = yamlContent[\"Extinctions\"]\n    extinctionType = extinctionSettings[\"constant or random\"]\n\n    hostExtinctionDistributions = extinctionSettings[\"host\"]\n    #log.debug('hostExtinctionDistributions %s' % (hostExtinctionDistributions,))\n    galacticExtinctionDistribution = extinctionSettings[\"galactic\"]\n    #log.debug('galacticExtinctionDistribution %s' % (galacticExtinctionDistribution,))\n\n    surveyCadenceSettings = yamlContent[\"Survey Cadence\"]\n    #log.debug('surveyCadenceSettings %s' % (surveyCadenceSettings,))\n\n    snLightCurves = yamlContent[\"Lightcurves\"]\n    #log.debug('snlightCurves %s' % (snlightCurves,))\n\n    surveyArea = yamlContent[\"Sky Area of the Survey (square degrees)\"]\n\n    extraSurveyConstraints = yamlContent[\"Extra Survey Constraints\"]\n\n    weatherLossFraction = surveyCadenceSettings[\n        \"Fraction of Year Lost to Weather etc\"]\n    observableFraction = surveyCadenceSettings[\"Observable Fraction of Year\"]\n    extinctionConstant = extinctionSettings[\"constant E(b-v)\"]\n    CCSNRateFraction = yamlContent[\n        \"CCSN Progenitor Population Fraction of IMF\"]\n    transientToCCSNRateFraction = yamlContent[\"Transient to CCSN Ratio\"]\n    restFrameFilter = yamlContent[\"Rest Frame Filter for K-corrections\"]\n    peakMagLimit = extraSurveyConstraints[\"Faint-Limit of Peak Magnitude\"]\n    campaignLengthLimit = extraSurveyConstraints[\n        \"Observable for at least ? number of days\"]\n\n    # CALCULATE THE SURVEY VOLUME\n    c = converter(log=log)\n    dists = c.redshift_to_distance(\n        z=float(upperRedshiftLimit),\n        WM=0.3,\n        WV=0.7,\n        H0=70.0\n    )\n    dl_mpc = dists[\"dl_mpc\"]\n    sphereOuter = (4. / 3.) * math.pi * dl_mpc**3\n\n    if float(lowerRedshiftLimit) == 0.:\n        surveyVolume = sphereOuter\n    else:\n        dists = c.redshift_to_distance(\n            z=float(lowerRedshiftLimit),\n            WM=0.3,\n            WV=0.7,\n            H0=70.0\n        )\n        dl_mpc = dists[\"dl_mpc\"]\n        sphereInner = (4. / 3.) * math.pi * dl_mpc**3\n        surveyVolume = sphereOuter - sphereInner\n    # NOW SCALE TO SKY-AREA\n    surveyVolume = surveyVolume * surveyArea / 41253\n    surveyVolume = surveyVolume / (1000.)**3\n    if surveyVolume < 1:\n        surveyVolume = \"%(surveyVolume)0.4f\" % locals()\n    elif surveyVolume < 100:\n        surveyVolume = \"%(surveyVolume)0.2f\" % locals()\n    else:\n        surveyVolume = \"%(surveyVolume)0.1f\" % locals()\n\n    # CALCULATE OVERALL DETECTION FRACTIONS\n    discoveryFraction, tooFaintFraction, shortCampaignFraction = calculate_fraction_of_sn_discovered(\n        log, surveyCadenceSettings, snSurveyDiscoveryTimes, redshifts, peakAppMagList, snCampaignLengthList, extraSurveyConstraints, lowerRedshiftLimit, upperRedshiftLimit)\n\n    discoveryFraction = discoveryFraction * 100.\n    if discoveryFraction < 1:\n        discoveryFraction = \"%(discoveryFraction)0.4f\" % locals()\n    elif discoveryFraction < 10:\n        discoveryFraction = \"%(discoveryFraction)0.2f\" % locals()\n    else:\n        discoveryFraction = \"%(discoveryFraction)0.1f\" % locals()\n\n    # log.info('yamlContent %s' % (yamlContent,))\n    stream.close()\n\n    settings_log = \"\"\"\n# SN Survey Simulation Results - %s\n\nThe *%s*-band liming magnitudes of this simulated survey are:\n\n| Filter | Magnitude |\n|:---|:----|\n\"\"\" % (now, restFrameFilter)\n    for k, v in limitingMags.iteritems():\n        settings_log += \"\"\"| %s | %s |\\n\"\"\" % (k, v,)\n    settings_log += \"\"\"\n\nA total of **%s** transients where simulated in the survey, within a **redshift-range of %s-%s** and **survey footprint of %s deg<sup>2</sup>** (a **total volume of %s Gpc<sup>-3</sup> yr<sup>-1</sup>**). **%s%% of these simulated transients had solid 'discoveries'**.  A constant galactic extinction of `E(B-V) = %s` is used, it's assumed that any given field in the sky is visible for %s of the survey year and the typical fraction of survey time lost to weather of %s is accounted for. Here are the relative rates and peak magnitude distributions of the SN used in the survey:\n\n| SN Type | Relative Rate | Peak Magnitude | Sigma Peak |\n|:---|:---|:---|:---|\n\"\"\" % (sampleNumber, lowerRedshiftLimit, upperRedshiftLimit, surveyArea, surveyVolume, discoveryFraction, extinctionConstant, observableFraction, weatherLossFraction,)\n    for k, v in peakMagnitudeDistributions['magnitude'].iteritems():\n        settings_log += \"\"\"| %s | %s | %s | %s |\\n\"\"\" % (\n            k, relativeSNRates[k], v, peakMagnitudeDistributions['sigma'][k])\n    settings_log += \"\"\"\n\nIf a transient is detected by the simulated survey, extra constraints are placed upon the detected object to secure positive identification as the object.\n\n1. The peak apparent magnitude of the object must be brighter than **%s mag**\n2. The object must be detectable for long enough to complete a follow-up campaign of longer than **%s days** within 1 survey year with any single filter.\n\nThe transient rate for the survey volume is estimated by assuming a rate of **%s** times that of the CCSN rate (itself a fraction of **%s** of the total SFR).\n\n\"\"\" % (peakMagLimit, campaignLengthLimit, transientToCCSNRateFraction, CCSNRateFraction)\n    return settings_log", "response": "This function creates a MD log of the survey settings of the current page."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a fail response.", "response": "def create_error_response(code, message, status=status.BAD_REQUEST):\n    \"\"\"Create a fail response.\n\n    Args:\n        code (str): the code of the error. The title should be lowercase and\n            underscore separated.\n        message (dict, list, str): the message of the error.\n            This can be a list, dictionary or simple string.\n        status (int): the status code. Defaults to 400.\n\n    Returns:\n        Response: the response with the error. The format of the error is the\n            following: code and message. The code could be `user_error` or\n            `internal_error`. The message contains either a string, or a list\n            or a dictionary. If not specify, the status will be a 400.\n    \"\"\"\n\n    errors = dict(code=code, message=message)\n    return Response(errors=errors, status=status)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef display_unit(self):\n        if self._display_unit:\n            return self._display_unit\n        elif self._Q:\n            config = Configuration.display.unit_systems\n            default_system = Configuration.unit_system\n            units = config.systems[default_system]\n\n            self._display_unit = units.get(self._type, self._unit)\n\n            if self._type == \"temperature\":\n                from_unit = \"deg\" + self._unit.upper()\n                to_unit = \"deg\" + self._display_unit.upper()\n            else:\n                from_unit = self._unit\n                to_unit = self._display_unit\n\n            #print(\"dv\", from_unit, to_unit)\n            self._q_unit = self._Q(\"1 \" + from_unit)\n            self._q_display = self._Q(\"1 \" + to_unit)\n            \n            \n        return self._display_unit", "response": "Return the display unit of the value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the value. If the change exceeds the change delta observers and linked values are notified.", "response": "def value(self, new_value):\n        \"\"\"\n        Updates the value.\n        If the change exceeds the change delta observers and linked values are notified.  \n        \"\"\"\n        datetime_value = None\n        if new_value:\n            datetime_value = new_value.strftime(\"%Y-%M-%dT%H:%M:%SZ\")\n        self._set_value(datetime_value)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding option to select", "response": "def add_option(self, value, text, selected=False):\n        \"\"\"\n        Add option to select\n\n        :param value: The value that the option represent.\n\n        :param text: The text that should be displayer in dropdown\n\n        :param selected: True if the option should be the default value.\n        \"\"\"\n        option = {\"value\": value, \"text\": text, \"selected\":selected}\n        self.options += [option]\n        if selected:\n            self.selected_options += [option]\n            self._value.append(value)\n            if self._persist_value:\n                self.settings.store_value(\"selected_options\", self.selected_options)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nformulate a log file name that incorporates the provided tags.", "response": "def get_logfile_name(tags):\n  \"\"\"Formulates a log file name that incorporates the provided tags.\n\n  The log file will be located in ``scgpm_seqresults_dnanexus.LOG_DIR``.\n  \n  Args:\n      tags: `list` of tags to append to the log file name. Each tag will be '_' delimited. Each tag\n          will be added in the same order as provided.\n  \"\"\"\n  if not os.path.exists(sd.LOG_DIR):\n    os.mkdir(sd.LOG_DIR)\n  filename = \"log\"\n  for tag in tags:\n    filename += \"_{}\".format(tag)\n  filename += \".txt\"\n  filename = os.path.join(sd.LOG_DIR,filename)\n  return filename"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate and adds a file handler to the specified logger.", "response": "def add_file_handler(logger,level,tags):\n  \"\"\"Creates and Adds a file handler (`logging.FileHandler` instance) to the specified logger. \n\n  Args:\n      logger: The `logging.Logger` instance to add the new file handler to.\n      level: `str`. The logging level for which the handler accepts messages, i.e. `logging.INFO`.\n      tags: `list` of tags to append to the log file name. Each tag will be '_' delimited. Each tag\n           will be added in the same order as provided.\n  \"\"\"\n  f_formatter = logging.Formatter('%(asctime)s:%(name)s:\\t%(message)s')\n  filename = get_logfile_name(tags)\n  handler = logging.FileHandler(filename=filename,mode=\"a\")\n  handler.setLevel(level)\n  handler.setFormatter(f_formatter)\n  logger.addHandler(handler)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_id(test):\n    test_id = test.id()\n    module_length = len(test.test.__module__)\n    return test_id[:module_length] + \":\" + test_id[module_length + 1:]", "response": "Return the id of the given test"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_string_counter(fc, feature_name):\n    '''Find and return a :class:`~dossier.fc.StringCounter` at\n    `feature_name` or at `DISPLAY_PREFIX` + `feature_name` in the\n    `fc`, or return None.\n\n    '''\n    if feature_name not in fc:\n        feature = fc.get(FC.DISPLAY_PREFIX + feature_name)\n    else:\n        feature = fc.get(feature_name)\n    if isinstance(feature, StringCounter):\n        return feature\n    else:\n        return None", "response": "Find and return a : class : ~dossier. fc. StringCounter at feature_name or at DISPLAY_PREFIX + feature_name in the available features."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rewrap(s, width=COLS):\n    s = ' '.join([l.strip() for l in s.strip().split('\\n')])\n    return '\\n'.join(textwrap.wrap(s, width))", "response": "Rewrap all lines from input string and return a new string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_configuration(options):\n    if options.username != None:\n        username = options.username\n    else:\n        username = prompt('Username: ')\n\n    if options.password != None:\n        password = options.password\n    else:\n        password = prompt('Password: ', hide_input=not options.show_password)\n\n    if options.app_url != None:\n        app_url = options.app_url\n    else:\n        app_url = prompt('App URL (default: https://app.jut.io just hit enter): ')\n\n    if app_url.strip() == '':\n        app_url = 'https://app.jut.io'\n\n    section = '%s@%s' % (username, app_url)\n\n    if config.exists(section):\n        raise JutException('Configuration for \"%s\" already exists' % section)\n\n    token_manager = auth.TokenManager(username=username,\n                                      password=password,\n                                      app_url=app_url)\n\n    authorization = authorizations.get_authorization(token_manager,\n                                                     app_url=app_url)\n    client_id = authorization['client_id']\n    client_secret = authorization['client_secret']\n\n    deployment_name = default_deployment(app_url,\n                                         client_id,\n                                         client_secret)\n\n    config.add(section, **{\n        'app_url': app_url,\n        'deployment_name': deployment_name,\n        'username': username,\n        'client_id': client_id,\n        'client_secret': client_secret\n    })\n\n    if options.default:\n        config.set_default(name=section)\n    else:\n        default_configuration(interactive=False)", "response": "add a new configuration"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun a WHO on a target and returns a dictionary with the keys as the keys and the values as the values.", "response": "def who(self, target):\n        \"\"\"\n        Runs a WHO on a target\n        Required arguments:\n        * target - /WHO <target>\n        Returns a dictionary, with a nick as the key and -\n            the value is a list in the form of;\n           [0] - Username\n           [1] - Priv level\n           [2] - Real name\n           [3] - Hostname\n        \"\"\"\n        with self.lock:\n            self.send('WHO %s' % target)\n            who_lst = {}\n\n            while self.readable():\n                msg = self._recv(expected_replies=('352', '315'))\n                if msg[0] == '352':\n                    raw_who = msg[2].split(None, 7)\n                    prefix = raw_who[5].replace('H', '', 1).replace('*', '', 1)\n                    channel = raw_who[0]\n                    nick = raw_who[4]\n                    if prefix == '~':\n                        self.channels[channel]['USERS'][nick] = \\\n                           ['~', '', '', '', '']\n                    elif prefix == '&':\n                        self.channels[channel]['USERS'][nick] = \\\n                           ['', '&', '', '', '']\n                    elif prefix == '@':\n                        self.channels[channel]['USERS'][nick] = \\\n                           ['', '', '@', '', '']\n                    elif prefix == '%':\n                        self.channels[channel]['USERS'][nick] = \\\n                           ['', '', '', '%', '']\n                    elif prefix == '+':\n                        self.channels[channel]['USERS'][nick] = \\\n                           ['', '', '', '', '+']\n                    else:\n                        self.channels[channel]['USERS'][nick] = \\\n                           ['', '', '', '', '']\n                    who_lst[raw_who[4]] = raw_who[1], prefix, \\\n                        raw_who[7], raw_who[2]\n                elif msg[0] == '315':\n                    return who_lst"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a WHOIS on the specified user.", "response": "def whois(self, nick):\n        \"\"\"\n        Runs a WHOIS on someone.\n        Required arguments:\n        * nick - Nick to whois.\n        Returns a dictionary:\n            IDENT == The user's ident.\n            HOST == The user's host.\n            NAME == The user's real name.\n            SERVER == The server the user is on.\n            SERVER_INFO == The name of the server the user is on.\n            CHANNELS == A list of channels the user is on.\n            IDLE == The user's idle time.\n            AWAY, present if the user is away,\n                returns a string containing their away message.\n            OP == Present if the user is an IRC operator.\n            ETC == Other data sent in response to the WHOIS query.\n        \"\"\"\n        with self.lock:\n            self.send('WHOIS %s' % nick)\n            whois_r = {'CHANNELS': []}\n\n            while self.readable():\n                msg = self._recv()\n                info = msg[2].split(None, 4)\n                if msg[0] == '311':\n                    whois_r['IDENT'] = info[1]\n                    whois_r['HOST'] = info[2]\n                    whois_r['NAME'] = info[4][1:]\n                elif msg[0] == '312':\n                    whois_r['SERVER'] = info[1]\n                    whois_r['SERVER_INFO'] = ' '.join(info[2:])[1:]\n                elif msg[0] == '319':\n                    whois_r['CHANNELS'].append(' '.join(info[1:])[1:].split())\n                elif msg[0] == '317':\n                    whois_r['IDLE'] = info[2]\n                elif msg[0] == '301':\n                    whois_r['AWAY'] = info[1][1:]\n                elif msg[0] == '313':\n                    whois_r['OP'] = ' '.join(info[1:])[1:]\n                elif msg[0] == '318':\n                    break\n                else:\n                    if 'ETC' in whois_r:\n                        whois_r['ETC'].append(msg[2])\n                    else:\n                        whois_r['ETC'] = [msg[2]]\n\n            return whois_r"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef whowas(self, nick):\n        with self.lock:\n            self.send('WHOWAS %s' % nick)\n\n            rwhowas = []\n            while self.readable():\n                msg = self._recv(expected_replies=('314', '312', '369'))\n                if msg[0] == '314':\n                    raw_whowas = msg[2].split()\n                    rwhowas = raw_whowas[0], raw_whowas[1], \\\n                        raw_whowas[2], raw_whowas[4][1:]\n                elif msg[0] == '312':\n                    pass\n                elif msg[0] == '369':\n                    return rwhowas", "response": "Runs a WHOWAS on a user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef smart_initialize(self):\n        '''Use k-means++ to initialize a good set of centroids'''\n        if self.seed is not None: # useful for obtaining consistent results\n            np.random.seed(self.seed)\n        centroids = np.zeros((self.k, self.data.shape[1]))\n        # Randomly choose the first centroid.\n        # Since we have no prior knowledge, choose uniformly at random\n        idx = np.random.randint(self.data.shape[0])\n        centroids[0] = self.data[idx,:].toarray()\n        # Compute distances from the first centroid chosen to all the other data points\n        squared_distances = pairwise_distances(self.data, centroids[0:1], metric='euclidean').flatten()**2\n        for i in range(1, self.k):\n            # Choose the next centroid randomly, so that the probability for each data point to be chosen\n            # is directly proportional to its squared distance from the nearest centroid.\n            # Roughtly speaking, a new centroid should be as far as from ohter centroids as possible.\n            idx = np.random.choice(self.data.shape[0], 1, p=squared_distances/sum(squared_distances))\n            centroids[i] = self.data[idx,:].toarray()\n            # Now compute distances from the centroids to all data points\n            squared_distances = np.min(pairwise_distances(self.data, centroids[0:i+1], metric='euclidean')**2,axis=1)\n        self.centroids=centroids\n        return centroids", "response": "Use k - means ++ to initialize a good set of centroids"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_gtfsr(path, *, from_json=False):\n    path = Path(path)\n    feed = gtfs_realtime_pb2.FeedMessage()\n\n    with path.open('rb') as src:\n        if from_json:\n            feed = json_format.Parse(src.read(), feed)\n        else:\n            feed.ParseFromString(src.read())\n\n    return feed", "response": "Reads a GTFSR feed file and returns the corresponding GTFS feed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_gtfsr(feed, path, *, to_json=False):\n    path = Path(path)\n\n    if to_json:\n        with path.open('w') as tgt:\n            tgt.write(json_format.MessageToJson(feed))\n    else:\n        with path.open('wb') as tgt:\n            tgt.write(feed.SerializeToString())", "response": "Write a GTFSR feed to a given path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a POSIX timestamp t format it as a string and return its corresponding Taxonomy timestamp.", "response": "def timestamp_to_str(t, datetime_format=DATETIME_FORMAT, *, inverse=False):\n    \"\"\"\n    Given a POSIX timestamp (integer) ``t``,\n    format it as a datetime string in the given format.\n    If ``inverse``, then do the inverse, that is, assume ``t`` is\n    a datetime string in the given format and return its corresponding\n    timestamp.\n    If ``format is None``, then return ``t`` as a string\n    (if not ``inverse``) or as an integer (if ``inverse``) directly.\n    \"\"\"\n    if not inverse:\n        if datetime_format is None:\n            result = str(t)\n        else:\n            result = dt.datetime.fromtimestamp(t).strftime(datetime_format)\n    else:\n        if format is None:\n            result = int(t)\n        else:\n            result = dt.datetime.strptime(t, datetime_format).timestamp()\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extract_delays(feed):\n    rows = []\n    for e in feed.entity:\n        if not e.HasField('trip_update'):\n            continue\n        tu = e.trip_update\n        rid = tu.trip.route_id\n        tid = tu.trip.trip_id\n        stu = tu.stop_time_update\n        for x in stu:\n            stop_sequence = int(x.stop_sequence)\n            stop_id = str(x.stop_id)\n            delay = {}\n            for key in ['arrival', 'departure']:\n                if x.HasField(key):\n                    delay[key] = getattr(x, key).delay\n                else:\n                    delay[key] = np.nan\n            rows.append((rid, tid, stop_sequence, stop_id,\n              delay['arrival'], delay['departure']))\n\n    f = pd.DataFrame(rows, columns=[\n      'route_id', 'trip_id', 'stop_sequence', 'stop_id',\n      'arrival_delay', 'departure_delay'])\n    f = f.sort_values(['route_id', 'trip_id', 'stop_sequence'])\n    f.index = range(f.shape[0])\n    return f", "response": "Given a GTFSR feed extract the delays from it and return a DataFrame with the columns route_id trip_id stop_sequence arrival_delay departure_delay."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving a list of DataFrames of the form output by the function extract_delays returns a single DataFrame containing the combined delays.", "response": "def combine_delays(delays_list):\n    \"\"\"\n    Given a list of DataFrames of the form output by the function\n    :func:`extract_delays`, combine them into a single DataFrame as\n    follows and return the result.\n    Concatenate ``delays_list`` and remove duplicate\n    [route_id, trip_id, stop_sequence]\n    entries by combining their non-null delay values into one entry.\n\n    Warning: to ensure sensible output, don't include in ``delays_list``\n    the same trips on different days.\n\n    Return an empty DataFrame if ``delays_list`` is empty.\n    \"\"\"\n    if not delays_list:\n        return pd.DataFrame()\n\n    f = pd.concat(delays_list)\n    f = f.drop_duplicates()\n    f = f.dropna(subset=['arrival_delay', 'departure_delay'],\n      how='all')\n    cols = ['route_id', 'trip_id', 'stop_sequence']\n    f = f.sort_values(cols)\n    # Backfill NaNs within each cols group.\n    # Do this without groupby(), because that would create\n    # too many groups.\n    prev_tup = None\n    new_rows = []\n    dcols = ['arrival_delay', 'departure_delay']\n    for __, row in f.iterrows():\n        tup = row[cols].values\n        if np.array_equal(tup, prev_tup):\n            # A duplicate route-trip-stop row.\n            # Its arrival delay or departure delay is non-null\n            # by virtue of our preprocessing.\n            # Use its non-null delays to backfill the previous row's delays\n            # if necessary.\n            if new_rows[-1][dcols].isnull().any():\n                for dcol in dcols:\n                    if pd.notnull(row[dcol]) and pd.isnull(new_rows[-1][dcol]):\n                        new_rows[-1][dcol] = row[dcol]\n        else:\n            new_rows.append(row)\n            prev_tup = tup\n    f = pd.DataFrame(new_rows, index=range(len(new_rows)))\n    return f"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a list of GTFS FeedMessages and a date return a DataFrame of the same length as the GTFS feed containing the arrival delay and departure delay fields.", "response": "def build_augmented_stop_times(gtfsr_feeds, gtfs_feed, date):\n    \"\"\"\n    Given a list of GTFSR feeds (FeedMessage instances), a GTFS feed\n    (GTFSTK Feed instance), and a date (YYYYMMDD string), return\n    a DataFrame of GTFS stop times for trips scheduled on the given date\n    and containing two extra columns, ``'arrival_delay'`` and\n    ``'departure_delay'``, which are delay values in seconds\n    for that stop time according to the GTFSR feeds given.\n\n    If no GTFSR feeds are given or if their dates don't alight with\n    the given date, then the resulting delay fields will be all NaN.\n    \"\"\"\n    # Get scheduled stop times for date\n    st = gt.get_stop_times(gtfs_feed, date)\n\n    # Get GTFSR timestamps pertinent to date.\n    # Use datetime format YYYYMMDDHHMMSS to be compatible with GTFS dates\n    datetime_format = '%Y%m%d%H%M%S'\n    start_time = '000000'\n    start_datetime = date + start_time\n    # Plus 20 minutes fuzz:\n    end_time = gt.timestr_to_seconds(st['departure_time'].max()) + 20*60\n    if end_time >= 24*3600:\n        end_date = str(int(date) + 1)\n    else:\n        end_date = date\n    end_time = gt.timestr_to_seconds(end_time, inverse=True)\n    end_time = gt.timestr_mod24(end_time)\n    end_time = end_time.replace(':', '')\n    end_datetime = end_date + end_time\n\n    # Extract delays\n    delays_frames = [extract_delays(f) for f in gtfsr_feeds\n      if start_datetime <= get_timestamp_str(f, datetime_format)\n      <= end_datetime]\n\n    # Combine delays\n    delays = combine_delays(delays_frames)\n    if delays.empty:\n        # Assign NaNs to delays\n        ast = (\n            st\n            .assign(arrival_delay = np.nan)\n            .assign(departure_delay = np.nan)\n        )\n    else:\n        del delays['route_id']\n\n        # Merge with stop times\n        ast = st.merge(delays, how='left',\n          on=['trip_id', 'stop_id', 'stop_sequence'])\n\n    return ast.sort_values(['trip_id', 'stop_sequence'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives an augment stop times DataFrame as output by the function :func:`build_augmented_stop_times`, a distance threshold (float) in the same units as the ``'shape_dist_traveled'`` column of ``augmented_stop_times``, if that column is present, and a delay threshold (integer number of seconds), alter the delay values of the augmented stop times as follows. Drop all delays with absolute value more than ``delay_threshold`` seconds. For each trip and for each delay type (arrival delay or departure delay) do the following. If the trip has all null values for the delay type, then leave the values as is. Otherwise: - If the first delay is more than ``dist_threshold`` distance units from the first stop, then set the first stop delay to zero (charitably); otherwise set the first stop delay to the first delay. - If the last delay is more than ``dist_threshold`` distance units from the last stop, then set the last stop delay to zero (charitably); otherwise set the last stop delay to the last delay. - Linearly interpolate the remaining stop delays by distance. Return the resulting DataFrame. If a list of delay column names is given in ``delay_cols``, then alter those columns instead of the ``arrival_delay`` and ``departure_delay`` columns. This is useful if the given stop times have extra delay columns.", "response": "def interpolate_delays(augmented_stop_times, dist_threshold,\n  delay_threshold=3600, delay_cols=None):\n    \"\"\"\n    Given an augment stop times DataFrame as output by the function\n    :func:`build_augmented_stop_times`, a distance threshold (float)\n    in the same units as the ``'shape_dist_traveled'`` column of\n    ``augmented_stop_times``, if that column is present, and a delay\n    threshold (integer number of seconds), alter the delay values\n    of the augmented stop times as follows.\n\n    Drop all delays with absolute value more than ``delay_threshold``\n    seconds.\n    For each trip and for each delay type (arrival delay or departure\n    delay) do the following.\n    If the trip has all null values for the delay type,\n    then leave the values as is.\n    Otherwise:\n\n    - If the first delay is more than ``dist_threshold`` distance units\n      from the first stop, then set the first stop delay to zero\n      (charitably);\n      otherwise set the first stop delay to the first delay.\n    - If the last delay is more than ``dist_threshold`` distance units\n      from the last stop, then set the last stop delay to zero\n      (charitably); otherwise set the last stop delay to the last delay.\n    - Linearly interpolate the remaining stop delays by distance.\n\n    Return the resulting DataFrame.\n\n    If a list of delay column names is given in ``delay_cols``,\n    then alter those columns instead of the ``arrival_delay`` and\n    ``departure_delay`` columns.\n    This is useful if the given stop times have extra delay columns.\n    \"\"\"\n    f = augmented_stop_times.copy()\n\n    if delay_cols is None or not set(delay_cols) <= set(f.columns):\n        delay_cols = ['arrival_delay', 'departure_delay']\n\n    # Return f if nothing to do\n    if 'shape_dist_traveled' not in f.columns or\\\n      not f['shape_dist_traveled'].notnull().any() or\\\n      all([f[col].count() == f[col].shape[0] for col in delay_cols]):\n        return f\n\n    # Nullify fishy delays\n    for col in delay_cols:\n        f.loc[abs(f[col]) > delay_threshold, col] = np.nan\n\n    # Fill null delays\n    def fill(group):\n        # Only columns that have at least one nonnull value.\n        fill_cols = []\n        for col in delay_cols:\n            if group[col].count() >= 1:\n                fill_cols.append(col)\n\n        for col in fill_cols:\n            # Set first and last delays\n            for i in [0, -1]:\n                j = group[col].dropna().index[i]\n                dist_diff = (abs(group['shape_dist_traveled'].iat[i] -\n                  group['shape_dist_traveled'].ix[j]))\n                if dist_diff > dist_threshold:\n                    group[col].iat[i] = 0\n                else:\n                    group[col].iat[i] = group[col].ix[j]\n\n            # Interpolate remaining delays\n            ind = np.where(group[col].notnull())[0]\n            group[col] = np.interp(group['shape_dist_traveled'],\n              group.iloc[ind]['shape_dist_traveled'],\n              group.iloc[ind][col])\n\n        return group\n\n    f = f.groupby('trip_id').apply(fill)\n\n    # Round\n    f[delay_cols] = f[delay_cols].round(0)\n\n    return f"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filter_line(line: str, context: RunContext) -> typing.Optional[str]:\n    if context.filters is not None:\n        for filter_ in context.filters:\n            if re.match(filter_, line):\n                return None\n    return line", "response": "Filters out lines that match a given regex"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decode_and_filter(line: bytes, context: RunContext) -> typing.Optional[str]:\n    line_str: str = line.decode(context.console_encoding, errors='replace')\n    filtered_line: typing.Optional[str] = filter_line(line_str, context)\n    if filtered_line:\n        return filtered_line.rstrip()\n\n    return None", "response": "Decodes a line that was captured from the running process using a given encoding and returns the decoded line back."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef capture_output_from_running_process(context: RunContext) -> None:\n    # Get the raw output one line at a time\n    _output = context.capture.readline(block=False)\n\n    if _output:\n\n        line = decode_and_filter(_output, context)\n\n        if line:\n            if not context.mute:\n\n                # Print in real time\n                _LOGGER_PROCESS.debug(line)\n\n            # Buffer the line\n            context.process_output_chunks.append(line)\n\n        # Get additional output if any\n        return capture_output_from_running_process(context)\n\n    return None", "response": "Parses output from a running sub - process and returns the raw output of the process"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes autorg. Inputs: filename: either a name of an ascii file, or an instance of Curve. mininterval: the minimum number of points in the Guinier range qminrg: the maximum value of qmin*Rg. Default of autorg is 1.0 qmaxrg: the maximum value of qmax*Rg. Default of autorg is 1.3 noprint: if the output of autorg should be redirected to the null device. Outputs: Rg as an ErrorValue I0 as an ErrorValue qmin: the lower end of the chosen Guinier range qmax: the upper end of the chosen Guinier range quality: the quality parameter, between 0 and 1 aggregation: float, the extent of aggregation", "response": "def autorg(filename, mininterval=None, qminrg=None, qmaxrg=None, noprint=True):\n    \"\"\"Execute autorg.\n\n    Inputs:\n        filename: either a name of an ascii file, or an instance of Curve.\n        mininterval: the minimum number of points in the Guinier range\n        qminrg: the maximum value of qmin*Rg. Default of autorg is 1.0\n        qmaxrg: the maximum value of qmax*Rg. Default of autorg is 1.3\n        noprint: if the output of autorg should be redirected to the null \n            device.\n\n    Outputs:\n        Rg as an ErrorValue\n        I0 as an ErrorValue\n        qmin: the lower end of the chosen Guinier range\n        qmax: the upper end of the chosen Guinier range\n        quality: the quality parameter, between 0 and 1\n        aggregation: float, the extent of aggregation\n    \"\"\"\n    if isinstance(filename, Curve):\n        curve = filename\n        with tempfile.NamedTemporaryFile('w+b',\n                                         delete=False) as f:\n            curve.save(f)\n            filename = f.name\n    cmdline = ['autorg', filename, '-f', 'ssv']\n    if mininterval is not None:\n        cmdline.extend(['--mininterval', str(mininterval)])\n    if qminrg is not None:\n        cmdline.extend(['--sminrg', str(qminrg)])\n    if qmaxrg is not None:\n        cmdline.extend(['--smaxrg', str(qmaxrg)])\n    result = execute_command(cmdline, noprint=noprint)\n    Rg, dRg, I0, dI0, idxfirst, idxlast, quality, aggregation, filename = result[0].split(None, 8)\n    try:\n        curve\n    except NameError:\n        curve = Curve.new_from_file(filename)\n    else:\n        os.unlink(filename)\n    return ErrorValue(float(Rg), float(dRg)), ErrorValue(float(I0), float(dI0)), curve.q[int(idxfirst) - 1], curve.q[\n        int(idxlast) - 1], float(quality), float(aggregation)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes the shanum program to determine the optimum qmax of the current set of Shannon channels.", "response": "def shanum(filename, dmax=None, noprint=True):\n    \"\"\"Execute the shanum program to determine the optimum qmax\n    according to an estimation of the optimum number of Shannon\n    channels.\n    \n    Inputs:\n        filename: either a name of an ascii file, or an instance\n            of Curve\n        dmax: the cut-off of the P(r) function, if known. If None,\n            this will be determined by the shanum program\n        noprint: if the printout of the program is to be suppressed.\n    \n    Outputs: dmax, nsh, nopt, qmaxopt\n        dmax: the cut-off of the P(r) function.\n        nsh: the estimated number of Shannon channels\n        nopt: the optimum number of Shannon channels\n        qmaxopt: the optimum value of the high-q cutoff\n    \"\"\"\n    if isinstance(filename, Curve):\n        curve = filename\n        with tempfile.NamedTemporaryFile('w+b', delete=False) as f:\n            curve.save(f)\n            filename = f.name\n    cmdline = ['shanum', filename]\n    if dmax is not None:\n        cmdline.append(str(float(dmax)))\n    result = execute_command(cmdline, noprint=noprint)\n    for l in result:\n        l = l.strip()\n        if l.startswith('Dmax='):\n            dmax = float(l.split('=')[1])\n        elif l.startswith('Smax='):\n            qmax = float(l.split('=')[1])\n        elif l.startswith('Nsh='):\n            nsh = float(l.split('=')[1])\n        elif l.startswith('Nopt='):\n            nopt = float(l.split('=')[1])\n        elif l.startswith('Sopt='):\n            qmaxopt = float(l.split('=')[1])\n\n    return dmax, nsh, nopt, qmaxopt"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning datcmp on the given curves.", "response": "def datcmp(*curves, alpha=None, adjust=None, test='CORMAP'):\n    \"\"\"Run datcmp on the scattering curves.\n\n    Inputs:\n        *curves: scattering curves as positional arguments\n        alpha: confidence parameter\n        adjust: adjustment type (string), see the help of datcmp for details\n        test: test (string), see the help of datcmp for details\n\n    Outputs:\n        matC: the C matrix\n        matp: the matrix of the p values comparing the i-th and j-th exposure\n        matpadj: adjusted p-matrix of the exposures\n        ok: list of the same length as the number of curves. If True, the\n            given curve does not differ significantly from the others.\n    \"\"\"\n    if len({len(c) for c in curves}) != 1:\n        raise ValueError('All curves have to be of the same length.')\n    datcmpargs = []\n    if alpha is not None:\n        datcmpargs.append('--alpha=%f' % alpha)\n    if adjust is not None:\n        datcmpargs.append('--adjust=%s' % adjust)\n    if test is not None:\n        datcmpargs.append('--test=%s' % test)\n    with tempfile.TemporaryDirectory(prefix='credolib_datcmp') as td:\n        for i, c in enumerate(curves):\n            mat = np.zeros((len(c), 3))\n            mat[:, 0] = c.q\n            mat[:, 1] = c.Intensity\n            mat[:, 2] = c.Error\n            np.savetxt(os.path.join(td, 'curve_%d.dat' % i), mat)\n        matC = np.zeros((len(curves), len(curves))) + np.nan\n        matp = np.zeros((len(curves), len(curves))) + np.nan\n        matpadj = np.zeros((len(curves), len(curves))) + np.nan\n        ok = np.zeros(len(curves)) + np.nan\n        try:\n            results = subprocess.check_output(\n                ['datcmp'] + datcmpargs + [os.path.join(td, 'curve_%d.dat' % i) for i in range(len(curves))]).decode(\n                'utf-8')\n        except subprocess.CalledProcessError:\n            pass\n        else:\n            for l in results.split('\\n'):\n                m = re.match(\n                    '^\\s*(?P<i>\\d+)\\s*vs\\.\\s*(?P<j>\\d+)\\s*(?P<C>\\d*\\.\\d*)\\s*(?P<p>\\d*\\.\\d*)\\s*(?P<adjp>\\d*\\.\\d*)[\\s\\*]{1}$',\n                    l)\n                if m is not None:\n                    i = int(m.group('i')) - 1\n                    j = int(m.group('j')) - 1\n                    matC[i, j] = matC[j, i] = float(m.group('C'))\n                    matp[i, j] = matp[j, i] = float(m.group('p'))\n                    matpadj[i, j] = matpadj[j, i] = float(m.group('adjp'))\n                else:\n                    m = re.match('\\s*(?P<i>\\d+)(?P<ack>[\\*\\s]{1})\\s*', l)\n                    if m is not None:\n                        ok[int(m.group('i')) - 1] = (m.group('ack') == '*')\n    return matC, matp, matpadj, ok"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning datporod and return the estimated Porod volume.", "response": "def datporod(gnomoutfile):\n    \"\"\"Run datporod and return the estimated Porod volume.\n\n    Returns:\n         Radius of gyration found in the input file\n         I0 found in the input file\n         Vporod: the estimated Porod volume\n    \"\"\"\n    results = subprocess.check_output(['datporod', gnomoutfile]).decode('utf-8').strip().split()\n    return float(results[0]), float(results[1]), float(results[2])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef gnom(curve, Rmax, outputfilename=None, Npoints_realspace=None, initial_alpha=None):\n    with tempfile.TemporaryDirectory(prefix='credolib_gnom') as td:\n        curve.save(os.path.join(td, 'curve.dat'))\n        print('Using curve for GNOM: qrange from {} to {}'.format(curve.q.min(), curve.q.max()))\n        if Npoints_realspace is None:\n            Npoints_realspace = \"\"\n        else:\n            Npoints_realspace = str(Npoints_realspace)\n        if initial_alpha is None:\n            initial_alpha = \"\"\n        else:\n            initial_alpha = str(initial_alpha)\n        # GNOM questions and our answers:\n        # Printer type                          [ postscr     ] : <ENTER>\n        # Input data, first file                                : <curve.dat in the temporary directory><ENTER>\n        # Output file                           [ gnom.out    ] : <gnom.out in the temporary directory><ENTER>\n        # No of start points to skip            [    0        ] : 0<ENTER>\n        # ... (just GNOM output)\n        # ... (just GNOM output)\n        # Input data, second file               [ none        ] : <ENTER>\n        # No of end points to omit              [    0        ] : 0<ENTER>\n        # ... (just GNOM output)\n        # ... (just GNOM output)\n        # Angular scale (1/2/3/4)               [    1        ] : 2<ENTER>\n        # Plot input dataa                (Y/N) [   Yes       ] : N<ENTER>\n        # File containing expert parameters     [ none        ] : <ENTER>\n        # Kernel already calculated       (Y/N) [   No        ] : N<ENTER>\n        # Type of system        (0/1/2/3/4/5/6) [    0        ] : 0<ENTER>\n        # Zero condition at r=min         (Y/N) [   Yes       ] : Y<ENTER>\n        # Zero condition at r=max         (Y/N) [   Yes       ] : Y<ENTER>\n        #   --  Arbitrary monodisperse system  --\n        #  Rmin=0,  Rmax is maximum particle diameter\n        # Rmax for evaluating p(r)                              : <Rmax * 10><ENTER>\n        # Number of points in real space        [(always different)] : <Npoints_realspace><ENTER>\n        # Kernel-storage file name              [ kern.bin    ] : <ENTER>\n        # Experimental setup            (0/1/2) [    0        ] : 0<ENTER>\n        # Initial ALPHA                         [   0.0       ] : <initial_alpha><ENTER>\n        # Plot alpha distribution         (Y/N) [   Yes       ] : N<ENTER>\n        # Plot results                    (Y/N) [   Yes       ] : N<ENTER>\n        # ... solution ...\n        # Your choice : <ENTER>\n        # Evaluate errors                 (Y/N) [   Yes       ] : Y<ENTER>\n        # Plot p(r) with errors           (Y/N) [   Yes       ] : N<ENTER>\n        # Next data set           (Yes/No/Same) [   No        ] : N<ENTER>\n        gnominput = \"\\n%s\\n%s\\n0\\n\\n0\\n2\\nN\\n\\nN\\n0\\nY\\nY\\n%f\\n%s\\n\\n0\\n%s\\nN\\nN\\n\\nY\\nN\\nN\\n\" % (\n            os.path.join(td, 'curve.dat'), os.path.join(td, 'gnom.out'), 10 * Rmax, Npoints_realspace, initial_alpha)\n        result = subprocess.run(['gnom'], stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                                input=gnominput.encode('utf-8'))\n        pr, metadata = read_gnom_pr(os.path.join(td, 'gnom.out'), True)\n        pr[:, 0] /= 10\n        metadata['q'] *= 10\n        metadata['qj'] *= 10\n        metadata['qmin'] *= 10\n        metadata['qmax'] *= 10\n        metadata['dmax'] /= 10\n        metadata['dmin'] /= 10\n        metadata['Rg_guinier'] /= 10\n        metadata['Rg_gnom'] /= 10\n        if outputfilename is not None:\n            shutil.copy(os.path.join(td, 'gnom.out'), outputfilename)\n    return pr, metadata", "response": "Run GNOM on the dataset."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets information about a user s library account", "response": "def get_account(netid, timestamp=None):\n    \"\"\"\n    The Libraries object has a method for getting information\n    about a user's library account\n    \"\"\"\n    response = _get_account(netid, timestamp=timestamp)\n    return _account_from_json(response)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nauthenticating a CMU s WebISO wall.", "response": "def authenticate(url, username, password):\n    ''' Queries an asset behind CMU's WebISO wall.\n    It uses Shibboleth authentication (see: http://dev.e-taxonomy.eu/trac/wiki/ShibbolethProtocol)\n    Note that you can use this to authenticate stuff beyond just grades! (any CMU service)\n    Sample usage:\n        s = authenticate('https://enr-apps.as.cmu.edu/audit/audit', 'wcrichto', '<wcrichto password>')\n        print s.get('https://enr-apps.as.cmu.edu/audit/audit').content\n    '''\n\n    # We're using a Requests (http://www.python-requests.org/en/latest/) session\n    s = requests.Session()\n\n    # 1. Initiate sequence by querying the protected asset\n    data = s.get(url).content\n\n    # 2. Login to CMU's Shibboleth sign-in page\n    class LoginParser(HTMLParser):\n        url = ''\n        def handle_starttag(self, tag, alist):\n            attrs = dict(alist)\n\n            # Figure out where we need to submit to\n            if tag == 'form':\n                self.url = attrs['action']\n\n    loginparser = LoginParser()\n    loginparser.feed(data.decode())\n    targeturl = 'https://login.cmu.edu' + loginparser.url\n\n    s.headers = {'Host': 'login.cmu.edu', 'Referer': targeturl}\n    form = s.post(targeturl,\n                  data={'j_username': username, 'j_password': password,\n                        'j_continue': '1', '_eventId_proceed': 'Login'}).content\n\n    # 3. Parse resultant HTML and send corresponding POST request\n    # Here, if you were in a browser, you'd get fed an HTML form\n    # that you don't actualy see--it submits instantly with some JS\n    # magic, but we don't have that luxury, so we manually parse the form.\n    class ShibbolethParser(HTMLParser):\n        url = ''\n        to_post = {}\n        def handle_starttag(self, tag, alist):\n            attrs = dict(alist)\n\n            # Figure out where we need to submit to\n            if tag == 'form':\n                self.url = attrs['action']\n\n            # Save input values\n            elif tag == 'input' and attrs['type'] != 'submit':\n                self.to_post[attrs['name']] = attrs['value']\n\n    parser = ShibbolethParser()\n    parser.feed(form.decode())\n\n    # Update headers for where we're coming from\n    s.headers = {'Host':  urlparse(url).netloc,\n                 'Origin': 'https://login.cmu.edu',\n                 'Referer': targeturl,\n                 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.14 Safari/537.36'}\n\n    # 4. Finish authentication by sending POST request\n    s.post(parser.url, data=parser.to_post).content\n\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_plugin(plugin_data,\n                  verify_plugin=True,\n                  conn=None):\n    \"\"\"\n    :param plugin_data: <dict> dict matching Plugin()\n    :param verify_plugin: <bool>\n    :param conn: <rethinkdb.DefaultConnection>\n    :return: <dict> rethinkdb insert response value\n    \"\"\"\n    assert isinstance(plugin_data, dict)\n    if verify_plugin and not verify(plugin_data, Plugin()):\n        raise ValueError(\"Invalid Plugin entry\")\n    current = find_plugin(plugin_data[SERVICE_KEY], SERVICE_KEY, conn)\n    if not current:\n        success = RPC.insert(plugin_data,\n                             conflict=\"update\").run(conn)\n    else:\n        success = MOCK_ERROR_DICT\n        error_msg = DUPLICATE_SERVICE_STRING.format(plugin_data[SERVICE_KEY])\n        MOCK_ERROR_DICT[FIRST_ERROR] = error_msg\n    return success", "response": "Create a new node in the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrecording state of a single node in the ndb", "response": "def record_state(serv_name, state, conn=None):\n    \"\"\"\n    MAKE A DOCSTRING\n    :param serv_name: <str> service name of plugin instance\n    :param state: <dictionary> plugin state\n    :param conn: <rethinkdb.DefaultConnection>\n    :return: \n    \"\"\"\n    serv_filter = {SERVICE_KEY:serv_name}\n    updated = {PLUGIN_STATE_KEY: state}\n    return RPC.filter(serv_filter).update(updated).run(conn)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends an email to the owner when user applies to a project", "response": "def sendAppliedToOwner(self, context={}):\n    \"\"\"\n    Sent to project owner when user applies to a project\n    \"\"\"\n    super(ApplyMail, self).__init__(self.apply.project.owner.email, self.async, self.apply.project.owner.locale)\n    return self.sendEmail('volunteerApplied-ToOwner', 'New volunteer', context)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_signer(self, signer):\n        if isinstance(signer, HelloSigner) and signer.validate():\n            self.signers.append(signer)\n        else:\n            if not signer.validate():\n                raise Exception(\"HelloSigner Errors %s\" % (signer.errors,))\n            else:\n                raise Exception(\"add_signer signer must be an instance of class HelloSigner\")", "response": "Adds a signer to the list of known signer objects."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_doc(self, doc):\n        if isinstance(doc, HelloDoc) and doc.validate():\n            self.docs.append(doc)\n        else:\n            if not doc.validate():\n                raise Exception(\"HelloDoc Errors %s\" % (doc.errors,))\n            else:\n                raise Exception(\"add_doc doc must be an instance of class HelloDoc\")", "response": "Adds a doc to the list of docs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(self, **kwargs):\n        auth = None\n        if 'auth' in kwargs:\n            auth = kwargs['auth']\n            del(kwargs['auth'])\n\n        self._url = '%s%s%s' % (self.base_uri, 'embedded/sign_url/', self.signature_id)\n\n        return self.embedded.sign_url.get(auth=auth, **kwargs)", "response": "Creates a new instance of the class based on the provided parameters."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef commit_analyzer(commits, label_pattern, label_position=\"footer\"):\n\n    # Internally, a real regular expression pattern is used\n    pattern_string = re.escape(label_pattern)\n\n    # Capturing group patterns\n    action_cgp = r\"(?P<type>\\w+)\"\n    scope_cgp = r\"(?P<scope>\\w*)\"\n    subject_cgp = r\"(?P<subject>.+)\"\n\n    pattern_string = pattern_string.replace(r\"\\{type\\}\", action_cgp).replace(\n        r\"\\{scope\\}\", scope_cgp\n    )\n    if label_position == \"header\":\n        pattern_string = pattern_string.replace(r\"\\{subject\\}\", subject_cgp)\n\n    regexp_pattern = re.compile(pattern_string)\n\n    semantic_commits = []\n\n    for commit in commits:\n        text = commit.header if label_position == \"header\" else commit.footer\n        match = regexp_pattern.search(text)\n\n        if not match:\n            continue\n\n        metadata = match.groupdict()\n\n        if label_position == \"footer\":\n            metadata[\"subject\"] = commit.header\n\n        sc = SemanticCommit(\n            subject=metadata[\"subject\"].strip(),\n            type=metadata[\"type\"],\n            scope=metadata.get(\"scope\") or None,\n            message=commit.message,\n        )\n\n        semantic_commits.append(sc)\n\n    return semantic_commits", "response": "Analyzes a list of git. Commit objects and returns a list of git. Commit objects that match a given message convention and extract metadata from them."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding one or more files to the index running git - add.", "response": "def add(self, *files):\n        \"\"\"Add one or more files to the index running git-add.\"\"\"\n\n        try:\n            _run_command((\"git\", \"add\") + files)\n        except CalledProcessError:\n            # Only if the command fails we check if the files\n            # exist, because git-add most of the time fails when\n            # the provided files are not found.\n            for f in files:\n                if not Path(f).exists():\n                    raise FileNotFoundError(f\"No such file or directory: {f}\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef commit(self, message, files=None):\n\n        if files:\n            self.add(*files)\n\n        return _run_command([\"git\", \"commit\", \"-m\", f'\"{message}\"'])", "response": "Run git - commit."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns git - log.", "response": "def log(self, _from=None, to=None):\n        \"\"\"Run git-log.\"\"\"\n\n        command = [\"git\", \"log\"]\n\n        if _from:\n            to = \"HEAD\" if not to else to\n            revision_range = f\"{_from}..{to}\"\n            command.append(revision_range)\n\n        git_log_text = _run_command(command)\n        commit_text_lst = _extract_commit_texts(git_log_text)\n\n        return [Commit(commit_text) for commit_text in commit_text_lst]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tag(self, name=None):\n\n        command = [\"git\", \"tag\"]\n\n        if not name:\n            command.extend(\n                [\n                    \"-l\",\n                    \"--sort=creatordate\",\n                    \"--format=%(creatordate:short)%09%(refname:strip=2)\",\n                ]\n            )\n\n            command_output = _run_command(command).strip()\n\n            if command_output == \"\":\n                return []\n\n            tag_text_list = command_output.split(\"\\n\")\n            tag_list = [Tag(text) for text in tag_text_list]\n\n            return list(reversed(tag_list))\n\n        command.extend([\"-a\", name, \"-m\", '\"\"'])\n        return _run_command(command)", "response": "Create and list tag objects running git - tag command"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register(self, prefix, viewset, base_name=None, router_class=None):\n        if base_name is None:\n            base_name = self.get_default_base_name(viewset)\n\n        if router_class is not None:\n            kwargs = {'trailing_slash': bool(self.trailing_slash)}\n            single_object_router_classes = (\n                AuthenticationRouter, SingleObjectRouter)\n\n            if issubclass(router_class, single_object_router_classes):\n                router = router_class(**kwargs)\n                router.register(prefix, viewset, base_name=base_name)\n                self._single_object_registry.append(router)\n\n        else:\n            self.registry.append((prefix, viewset, base_name))", "response": "Append the given viewset to the proper registry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nregister a nested viewset with the specified prefix.", "response": "def register_nested(\n        self, parent_prefix, prefix, viewset,\n        base_name=None, parent_lookup_name=None,\n        depth_level=1\n    ):\n        \"\"\"\n        Register a nested viewset wihtout worrying of instantiate a nested\n        router for registry.\n        \"\"\"\n        kwargs = {\n            'trailing_slash': bool(self.trailing_slash)\n        }\n\n        if parent_lookup_name is not None:\n            kwargs.update(lookup=parent_lookup_name)\n\n        # Section for the depth of the route and add more routes\n\n        if depth_level > 1:\n            routers = filter(\n                lambda r: (r._depth_level == (depth_level - 1)) and\n                r._nested_prefix == parent_prefix,\n                self._nested_object_registry\n            )\n\n            try:\n                parent_router = next(routers)\n            except StopIteration:\n                raise RuntimeError('parent registered resource not found')\n\n        else:\n            parent_router = self\n\n        nested_router = NestedSimpleRouter(\n            parent_router,\n            parent_prefix,\n            **kwargs\n        )\n\n        nested_router._nested_prefix = prefix\n        nested_router._depth_level = depth_level\n        nested_router.register(prefix, viewset, base_name)\n        self._nested_object_registry.append(nested_router)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_urls(self):\n        base_urls = super(SimpleRouter, self).get_urls()\n        single_urls = sum([r.urls for r in self._single_object_registry], [])\n        nested_urls = sum([r.urls for r in self._nested_object_registry], [])\n\n        return base_urls + single_urls + nested_urls", "response": "Generate the list of URL patterns including the registered single\n        object routers urls."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_config(path):\n        config = configparser.ConfigParser()\n\n        if path:  # if user has config with user creds in it, this will grab it\n            config.read(path)\n\n        try:\n            return {k: v for k, v in config[\"default\"].items()}\n        except KeyError:\n            return {}", "response": "parse either the config file we found or use some canned defaults"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lookup(path, cache=True, scope=None, safe=False):\n\n    result = None\n\n    found = path and cache and path in __LOOKUP_CACHE\n\n    if found:\n        result = __LOOKUP_CACHE[path]\n\n    elif path:\n\n        _eval = safe_eval if safe else eval\n\n        try:  # search among scope\n            result = _eval(path, scope)\n\n        except (NameError, SyntaxError):\n\n            # we generate a result in order to accept the result such as a None\n            generated_result = random()\n            result = generated_result\n\n            components = path.split('.')\n            index = 0\n            components_len = len(components)\n\n            module_name = components[0]\n\n            # try to resolve an absolute path\n            try:\n                result = import_module(module_name)\n\n            except ImportError:\n                # resolve element globals or locals of the from previous frame\n                previous_frame = currentframe().f_back\n\n                if module_name in previous_frame.f_locals:\n                    result = previous_frame.f_locals[module_name]\n\n                elif module_name in previous_frame.f_globals:\n                    result = previous_frame.f_globals[module_name]\n\n            found = result is not generated_result\n\n            if found:\n\n                if components_len > 1:\n\n                    index = 1\n\n                    # try to import all sub-modules/packages\n                    try:  # check if name is defined from an external module\n                        # find the right module\n                        while index < components_len:\n                            module_name = '{0}.{1}'.format(\n                                module_name, components[index]\n                            )\n                            result = import_module(module_name)\n                            index += 1\n\n                    except ImportError:\n                        # path sub-module content\n                        try:\n                            if PY26:  # when __import__ is used\n                                index = 1  # restart count of pathing\n                            while index < components_len:\n                                result = getattr(result, components[index])\n                                index += 1\n\n                        except AttributeError:\n                            raise ImportError(\n                                'Wrong path {0} at {1}'.format(\n                                    path, components[:index]\n                                )\n                            )\n                    else:  # in case of PY26\n                        if PY26:\n                            index = 1\n                            while index < components_len:\n                                result = getattr(result, components[index])\n                                index += 1\n\n        else:\n            found = True\n\n    if found:\n        if cache:  # save in cache if found\n            __LOOKUP_CACHE[path] = result\n\n    else:\n        raise ImportError('Wrong path {0}'.format(path))\n\n    return result", "response": "Lookup an element in the current execution stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the absolute path of a given element such as the opposite of the getpath behaviour.", "response": "def getpath(element):\n    \"\"\"Get full path of a given element such as the opposite of the\n    resolve_path behaviour.\n\n    :param element: must be directly defined into a module or a package and has\n        the attribute '__name__'.\n\n    :return: element absolute path.\n    :rtype: str\n\n    :raises AttributeError: if element has not the attribute __name__.\n\n    :Example:\n\n    >>> getpath(getpath)\n    b3j0f.utils.path.getpath\n    \"\"\"\n\n    if not hasattr(element, '__name__'):\n        raise AttributeError(\n            'element {0} must have the attribute __name__'.format(element)\n        )\n\n    result = element.__name__ if ismodule(element) else \\\n        '{0}.{1}'.format(element.__module__, element.__name__)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_eventclass(event_id):\n    def register(cls):\n        if not issubclass(cls, Event):\n            raise MessageException(('Cannot register a class that'\n                                    ' is not a subclass of Event'))\n        EVENT_REGISTRY[event_id] = cls\n        logger.debug('######### Event registry is now: {0}'.format(\n            EVENT_REGISTRY))\n        return cls\n    return register", "response": "Decorator for registering event classes for parsing\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unique(lst):\n    nl = []\n    [(nl.append(e) if type(e) is not list else nl.extend(e)) \\\n     for e in lst if e not in nl]\n    return nl", "response": "Unique with keeping sort / order\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _merge_fix(d):\n    if type(d) is dict:\n        for key in d.keys():\n            if key[0] in ('&', '-'):\n                d[key[1:]] = _merge_fix(d.pop(key))\n    return d", "response": "Fixes keys that start with & and -"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef json_minify(string, strip_space=True): # pragma: no cover\n    in_string = False\n    in_multi = False\n    in_single = False\n\n    new_str = []\n    index = 0\n\n    for match in re.finditer(TOKENIZER, string):\n\n        if not (in_multi or in_single):\n            tmp = string[index:match.start()]\n            if not in_string and strip_space:\n                # replace white space as defined in standard\n                tmp = re.sub('[ \\t\\n\\r]+', '', tmp)\n            new_str.append(tmp)\n\n        index = match.end()\n        val = match.group()\n\n        if val == '\"' and not (in_multi or in_single):\n            escaped = END_SLASHES_RE.search(string, 0, match.start())\n\n            # start of string or unescaped quote character to end string\n            if not in_string or (escaped is None or len(escaped.group()) % 2 == 0):\n                in_string = not in_string\n            index -= 1 # include \" character in next catch\n        elif not (in_string or in_multi or in_single):\n            if val == '/*':\n                in_multi = True\n            elif val == '//':\n                in_single = True\n        elif val == '*/' and in_multi and not (in_string or in_single):\n            in_multi = False\n        elif val in '\\r\\n' and not (in_multi or in_string) and in_single:\n            in_single = False\n        elif not ((in_multi or in_single) or (val in ' \\r\\n\\t' and strip_space)):\n            new_str.append(val)\n\n    new_str.append(string[index:])\n    return ''.join(new_str)", "response": "Removes whitespace from json strings returning the string"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resolve_template(template):\n    \"Accepts a template object, path-to-template or list of paths\"\n    if isinstance(template, (list, tuple)):\n        return loader.select_template(template)\n    elif isinstance(template, basestring):\n        try:\n            return loader.get_template(template)\n        except TemplateDoesNotExist:\n            return None\n    else:\n        return template", "response": "Accepts a template object path - to - template or list of paths"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, obj=None, **kwargs): # known special case of dict.update\n        if obj is None:\n            pass\n        elif hasattr(obj, 'iteritems'):  # iteritems saves memory and lookups\n            for k, v in obj.iteritems():\n                self[k] = v\n        elif hasattr(obj, 'keys'):\n            for k in obj.keys():\n                self[k] = obj[k]\n        else:\n            for k, v in obj:\n                self[k] = v\n        if kwargs:\n            self.update(kwargs)", "response": "Update the dictionary with the contents of obj."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntakes a string value and returns the Date based on the format", "response": "def value(self, value, *args, **kwargs):\n        \"\"\"\n        Takes a string value and returns the Date based on the format\n        \"\"\"\n        from datetime import datetime\n        value = self.obj.value(value, *args, **kwargs)\n        try:\n            rv = datetime.strptime(value, self.format)\n        except ValueError as _:  # noqa\n            rv = None\n        return rv"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef factory(cls, client, *args, **kwargs):\n\n        # Some basic sanity checks\n        if not six.callable(client):\n            raise exc.FramerException(\"Protocol factory is not a factory\")\n\n        # Cannot specify both positional and keyword arguments, but\n        # must provide one or the other\n        if not args and not kwargs:\n            raise exc.InvalidFramerSpecification(\n                \"No framers specified\")\n        elif args and kwargs:\n            raise exc.InvalidFramerSpecification(\n                \"Cannot mix positional and keyword framer specifications\")\n\n        # And a final, basic sanity check on the argument structure\n        if not args and ('send' not in kwargs or 'recv' not in kwargs):\n            raise exc.InvalidFramerSpecification(\n                \"Both send and receive framers must be specified\")\n\n        return lambda: cls(client, *args, **kwargs)", "response": "Generates and returns a callable that returns an instance of the specified class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _interpret_framer(self, args, kwargs):\n\n        # Cannot specify both positional and keyword arguments, but\n        # must provide one or the other\n        if not args and not kwargs:\n            raise exc.InvalidFramerSpecification(\n                \"No framers specified\")\n        elif args and kwargs:\n            raise exc.InvalidFramerSpecification(\n                \"Cannot mix positional and keyword framer specifications\")\n\n        # Start with the current send and receive framers\n        send = self._send_framer\n        recv = self._recv_framer\n        send_state = self._send_state\n        recv_state = self._recv_state\n\n        # Now, is it positional style?\n        if args:\n            send = args[0]\n            recv = args[0]\n\n            # Do we have a state?\n            if len(args) > 1:\n                send_state = args[1]\n                recv_state = args[1]\n            else:\n                # Allocate one\n                state = framers.FramerState()\n\n                # Initialize it\n                send.initialize_state(state)\n\n                send_state = state\n                recv_state = state\n        else:\n            # OK, it's keyword style; do we have a send framer?\n            if 'send' in kwargs:\n                send = kwargs['send']\n\n                # Do we have a send state?\n                if 'send_state' in kwargs:\n                    send_state = kwargs['send_state']\n                else:\n                    # Allocate one and initialize it\n                    send_state = framers.FramerState()\n                    send.initialize_state(send_state)\n\n            # How about a receive framer?\n            if 'recv' in kwargs:\n                recv = kwargs['recv']\n\n                # Do we have a recv state?\n                if 'recv_state' in kwargs:\n                    recv_state = kwargs['recv_state']\n                else:\n                    # Allocate one and initialize it\n                    recv_state = framers.FramerState()\n                    recv.initialize_state(recv_state)\n\n        # Create and return a FramerElement\n        return FramerElement(send, recv, send_state, recv_state)", "response": "Interprets the arguments related to a framer and returns an instance of FramerElement."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef connection_made(self, transport):\n\n        # Save the underlying transport\n        self._transport = transport\n\n        # Call connection_made() on the client protocol, passing\n        # ourself as the transport\n        self._client.connection_made(self)", "response": "Called by the underlying transport when a connection is made."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling by the underlying transport when data is received on the connection.", "response": "def data_received(self, data):\n        \"\"\"\n        Called by the underlying transport when data is received.\n\n        :param data: The data received on the connection.\n        \"\"\"\n\n        # First, add the data to the receive buffer\n        self._recv_buf += data\n\n        # Now, pass all frames we can find to the client protocol\n        while self._recv_buf and not self._recv_paused:\n            try:\n                # Extract one frame\n                frame = self._recv_framer.to_frame(self._recv_buf,\n                                                   self._recv_state)\n            except exc.NoFrames:\n                # There's data in the buffer, but no complete frames\n                break\n\n            # Now call the client protocol's frame_received() method\n            self._client.frame_received(frame)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_extra_info(self, name, default=None):\n\n        # Handle data we know about\n        if name in self._handlers:\n            return self._handlers[name](self)\n\n        # Call get_extra_info() on the transport\n        return self._transport.get_extra_info(name, default=default)", "response": "Get the extra info of a specific transport - specific message."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resume_reading(self):\n\n        # Clear the read pause status\n        self._recv_paused = False\n\n        # Call resume_reading() on the transport\n        self._transport.resume_reading()\n\n        # If there's data in the receive buffer, pass it on to the\n        # client protocol\n        if self._recv_buf:\n            self.data_received(b'')", "response": "Called by the client protocol to resume reading the message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the high - water and low - water limits for write flow control.", "response": "def set_write_buffer_limits(self, high=None, low=None):\n        \"\"\"\n        Called by the client protocol to set the high- and low-water\n        limits for write flow control.\n\n        These two values control when call the protocol's\n        ``pause_writing()`` and ``resume_writing()`` methods are\n        called.\n\n        :param high: The high-water limit.  Must be a non-negative\n                     integer greater than or equal to ``low``, if both\n                     are specified.\n        :param low: The low-water limit.  Must be a non-negative\n                    integer less than or equal to ``high``, if both\n                    are specified.  If only ``high`` is specified,\n                    defaults to an implementation-specific value less\n                    than or equal to ``high``.\n        \"\"\"\n\n        # Call set_write_buffer_limits() on the transport\n        self._transport.set_write_buffer_limits(high=high, low=low)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_frame(self, frame):\n\n        # Convert the frame to bytes and write them to the connection\n        data = self._send_framer.to_bytes(frame, self._send_state)\n        self._transport.write(data)", "response": "Send a frame to the remote peer."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npushes a new framer object to the stack and returns the new framer object.", "response": "def push_framer(self, *args, **kwargs):\n        \"\"\"\n        Called by the client protocol to temporarily switch to a new\n        send framer, receive framer, or both.  Can be called multiple\n        times.  Each call to ``push_framer()`` must be paired with a\n        call to ``pop_framer()``, which restores to the previously set\n        framer.\n\n        When called with positional arguments, the first argument\n        specifies a framer object to replace both send and receive\n        framers.  A second argument may be used to specify a state\n        object for the framers; if none is specified, a new one will\n        be allocated and initialized by calling the appropriate framer\n        initialization method.\n\n        When called with keyword arguments, the ``send`` and ``recv``\n        arguments specify the send and receive framer object,\n        respectively.  If either is not provided, the existing framer\n        for that direction will be maintained.  The ``send_state`` and\n        ``recv_state`` arguments specify optional state objects for\n        the respective framers, and will be allocated and initialized\n        by calling the appropriate framer initialization method, if\n        not provided.  If a state argument is given without a\n        corresponding replacement framer, it will be ignored.\n        \"\"\"\n\n        # First, interpret the arguments\n        elem = self._interpret_framer(args, kwargs)\n\n        # Append the element to the framer stack\n        self._framers.append(elem)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_framer(self, *args, **kwargs):\n\n        # First, interpret the arguments\n        elem = self._interpret_framer(args, kwargs)\n\n        # Now, replace the current top of the framer stack\n        self._framers[-1] = elem", "response": "Set the framer for the current send and receive time - related framers."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef menu():\n    root = MenuItem('')\n\n    for mod in droplet.modules():\n        if mod.installed:\n            module_path = mod.__class__.__module__.rsplit('.', 1)[0]\n            menu = import_module(module_path + '.menu')\n            if menu:\n                menu.menu(root)\n\n    return root", "response": "Returns global menu composed from all modules menu."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef append(self, item):\n        if self.url:\n            raise TypeError('Menu items with URL cannot have childrens')\n\n        # Look for already present common node\n        if not item.is_leaf():\n            for current_item in self.items:\n                if item.name == current_item.name:\n                    for children in item.items:\n                        current_item.append(children)\n                    return\n\n        # First insertion\n        self.items.append(item)", "response": "Add the given item as children of this menu."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_file(self, filename, skip_unreadable=False):\n        if not os.access(filename, os.R_OK):\n            if skip_unreadable:\n                return\n            raise ConfigReadingError(\"Unable to open file %s.\" % filename)\n        with open(filename, 'rt') as f:\n            return self.parse(f, name_hint=filename)", "response": "Parse a file from its name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the couchbase document s id object property.", "response": "def doc_id(self):\n        \"\"\"Returns the couchbase document's id, object property.\n\n        :returns: The document id (that is created from :attr:'doc_type' and\n            :attr:'__key_field__' value, or auto-hashed document id at first\n            saving).\n        :rtype: unicode\n        \"\"\"\n        if self.id:\n            return '%s_%s' % (self.doc_type, self.id.lower())\n        return self._hashed_key"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef touch(self, expiration):\n        if not self.cas_value or not self.doc_id:\n            raise self.DoesNotExist(self)\n        return self.bucket.touch(self.doc_id, expiration)", "response": "Updates the current document s expiration value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a filter to the collection using a dynamic field.", "response": "def dynamic_filter(self, field_name, dynamic_part, value, index_suffix=''):\n        \"\"\"\n        Add a filter to the collection, using a dynamic field. The key part of\n        the filter is composed using the field_name, which must be the field\n        name of a dynamic field on the attached model, and a dynamic part.\n        The index_suffix allow to specify which index to use. It's an empty string\n        by default for the default equal index (could be \"__eq\" or \"eq\" to have the\n        exact same result)\n        Finally return the collection, by calling self.filter\n        \"\"\"\n        field_name_parts = field_name.split('__')\n        real_field_name = field_name_parts.pop(0)\n        dynamic_field_name = self.cls.get_field(real_field_name).get_name_for(dynamic_part)\n        field_name_parts.insert(0, dynamic_field_name)\n        filter_name = '__'.join(field_name_parts)\n        if not index_suffix:\n            index_suffix = ''\n        elif not index_suffix.startswith('__'):\n            index_suffix = '__' + index_suffix\n        return self.filter(**{filter_name + index_suffix: value})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_model(self, request, obj, form, change):\n        instance = form.save(commit=False)\n        if not(instance.created):\n            instance.author = request.user\n        instance.save()\n        form.save_m2m()\n\n        return instance", "response": "Surclasse la m\u00e9thode de sauvegarde de la mod\u00e8le pour y \n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_description(status_code):\n    description = _descriptions.get(status_code)\n    if description is None:\n        description = 'code = %s (no description)' % str(status_code)\n    return description", "response": "Get the description for a status code."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a metaclass that will add the specified metrics at the specified path parametrized on the dynamic class name.", "response": "def metered_meta(metrics, base=type):\n    \"\"\"Creates a metaclass that will add the specified metrics at a path parametrized on the dynamic class name.\n\n    Prime use case is for base classes if all subclasses need separate metrics and / or the metrics need to be\n    used in base class methods, e.g., Tornado's ``RequestHandler`` like::\n\n        import tapes\n        import tornado\n        import abc\n\n        registry = tapes.Registry()\n\n        class MyCommonBaseHandler(tornado.web.RequestHandler):\n            __metaclass__ = metered_meta([\n                ('latency', 'my.http.endpoints.{}.latency', registry.timer)\n            ], base=abc.ABCMeta)\n\n            @tornado.gen.coroutine\n            def get(self, *args, **kwargs):\n                with self.latency.time():\n                    yield self.get_impl(*args, **kwargs)\n\n            @abc.abstractmethod\n            def get_impl(self, *args, **kwargs):\n                pass\n\n\n        class MyImplHandler(MyCommonBaseHandler):\n            @tornado.gen.coroutine\n            def get_impl(self, *args, **kwargs):\n                self.finish({'stuff': 'something'})\n\n\n        class MyOtherImplHandler(MyCommonBaseHandler):\n            @tornado.gen.coroutine\n            def get_impl(self, *args, **kwargs):\n                self.finish({'other stuff': 'more of something'})\n\n    This would produce two different relevant metrics,\n        - ``my.http.endpoints.MyImplHandler.latency``\n        - ``my.http.endpoints.MyOtherImplHandler.latency``\n\n    and, as an unfortunate side effect of adding it in the base class,\n    a ``my.http.endpoints.MyCommonBaseHandler.latency`` too.\n\n    :param metrics: list of (attr_name, metrics_path_template, metrics_factory)\n    :param base: optional meta base if other than `type`\n    :return: a metaclass that populates the class with the needed metrics at paths based on the dynamic class name\n    \"\"\"\n    class _MeteredMeta(base):\n        def __new__(meta, name, bases, dict_):\n            new_dict = dict(**dict_)\n            for attr_name, template, factory in metrics:\n                new_dict[attr_name] = factory(template.format(name))\n            return super(_MeteredMeta, meta).__new__(meta, name, bases, new_dict)\n\n    return _MeteredMeta"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_action_list(self, item_list, **kwargs):\r\n        ''' Generates a list of actions for sending to Elasticsearch '''\r\n\r\n        action_list = []\r\n        es_index = get2(kwargs, \"es_index\", self.es_index)\r\n        action_type = kwargs.get(\"action_type\",\"index\")\r\n        action_settings = {'_op_type': action_type,\r\n                           '_index': es_index}\r\n        doc_type = kwargs.get(\"doc_type\", self.doc_type)\r\n        if not doc_type:\r\n            doc_type = \"unk\"\r\n        id_field = kwargs.get(\"id_field\")\r\n        for item in item_list:\r\n            action = get_es_action_item(item,\r\n                                        action_settings,\r\n                                        doc_type,\r\n                                        id_field)\r\n            action_list.append(action)\r\n        return action_list", "response": "Generates a list of actions for sending to Elasticsearch"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a list of items to Elasticsearch and returns a dict of the new entries.", "response": "def bulk_save(self, action_list, **kwargs):\r\n        ''' sends a passed in action_list to elasticsearch '''\r\n\r\n        lg = logging.getLogger(\"%s.%s\" % (self.ln, inspect.stack()[0][3]))\r\n        lg.setLevel(self.log_level)\r\n        err_log = logging.getLogger(\"index.errors\")\r\n        es = self.es\r\n        es_index = get2(kwargs, \"es_index\", self.es_index)\r\n        reset_index = kwargs.get(\"reset_index\",self.reset_index)\r\n        doc_type = kwargs.get(\"doc_type\", self.doc_type)\r\n\r\n        lg.info(\"Sending %s items to Elasticsearch\",len(action_list))\r\n        # bulk_stream = helpers.streaming_bulk(es,\r\n        result = helpers.bulk(es,\r\n                              action_list,\r\n                              chunk_size=400,\r\n                              raise_on_error=False)\r\n        lg.info(\"FINISHED sending to Elasticsearch\")\r\n        if result[1]:\r\n            lg.info(\"Formating Error results\")\r\n            # action_keys = {item['_id']:i for i, item in enumerate(action_list)}\r\n            new_result = []\r\n            for item in result[1][:5]:\r\n                for action_item in action_list:\r\n                    if action_item['_id'] == item[list(item)[0]]['_id']:\r\n                        new_result.append((item, action_item,))\r\n                        break\r\n            err_log.info(\"Results for batch '%s'\\n(%s,\\n%s\\n%s)\",\r\n                         kwargs.get('batch', \"No Batch Number provided\"),\r\n                         result[0],\r\n                         json.dumps(new_result, indent=4),\r\n                         json.dumps(result[1]))\r\n            del new_result\r\n            lg.info(\"Finished Error logging\")\r\n        # for success, result in bulk_stream:\r\n        #     lg.debug(\"\\nsuccess: %s \\nresult:\\n%s\", success, pp.pformat(result))\r\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, data, **kwargs):\r\n\r\n        lg = logging.getLogger(\"%s.%s\" % (self.ln, inspect.stack()[0][3]))\r\n        lg.setLevel(self.log_level)\r\n\r\n        es = self.es\r\n        es_index = get2(kwargs, \"es_index\", self.es_index)\r\n        reset_index = kwargs.get(\"reset_index\",self.reset_index)\r\n        doc_type = kwargs.get(\"doc_type\", self.doc_type)\r\n        op_type = kwargs.get(\"op_type\", self.op_type)\r\n        id_value = kwargs.get(\"id\")\r\n        id_field = kwargs.get(\"id_field\")\r\n        if id_field:\r\n            id_value = data.get(id_field)\r\n        if op_type == \"index\":\r\n            result = es.index(index=es_index,\r\n                               id=id_value,\r\n                               doc_type=doc_type,\r\n                               body=data)\r\n        elif op_type == \"create\":\r\n            result = es.create(index=es_index,\r\n                               id=id_value,\r\n                               doc_type=doc_type,\r\n                               body=data)\r\n\r\n        lg.debug(\"Result = \\n%s\",pp.pformat(result))\r\n        return result", "response": "Sends a passed in action_list to elasticsearch"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _find_ids(self,\r\n                  data_list,\r\n                  prop,\r\n                  lookup_index,\r\n                  lookup_doc_type,\r\n                  lookup_field):\r\n        \"\"\" Reads a list of data and replaces the ids with es id of the item\r\n\r\n        args:\r\n            data_list: list of items to find in replace\r\n            prop: full prop name in es format i.e. make.id\r\n            lookup_src: dictionary with index doc_type ie.\r\n                {\"es_index\": \"reference\", \"doc_type\": \"device_make\"}\r\n            lookup_fld: field to do the lookup against in full es naming\r\n                convention i.e. make.raw\r\n        \"\"\"\r\n        lg = logging.getLogger(\"%s.%s\" % (self.ln, inspect.stack()[0][3]))\r\n        lg.setLevel(self.log_level)\r\n\r\n        rtn_list = []\r\n        first_time = IsFirst()\r\n        for item in data_list:\r\n            # the Dot class will retive and set dictionary values via dot\r\n            # notation\r\n            val = Dot(item).get(prop)\r\n            if val.startswith(\"#;lookup#;\"):\r\n                lookup_val = val.replace(\"#;lookup#;\", \"\")\r\n                lookup_obj = self.get_item(lookup_val, lookup_field)\r\n                if first_time.first():\r\n                    lg.debug(\"  lookup_obj:\\n%s\", pp.pformat(lookup_obj))\r\n                if lookup_obj:\r\n                    rtn_list.append(Dot(item).set(prop, lookup_obj['_id']))\r\n        return rtn_list", "response": "Reads a list of data and replaces the ids with es id of the item"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a single item data record or document based on the specified criteria", "response": "def get_doc(self, item_id, id_field=\"_id\", **kwargs):\r\n        \"\"\" returns a single item data record/document based on specified\r\n        criteria\r\n\r\n        args:\r\n            item_id: the id value of the desired item. Can be used in\r\n                     combination with the id_field for a paired lookup.\r\n            id_field: the field that is related to the item_id; default = '_id'\r\n                      **Example**: selecting a country using a different\r\n                      itendifier than the record id. The United States's '_id'\r\n                      value is 'US' however the record can be found by\r\n                      specifying item_id='USA', id_field='ISO 3166-1 A3'\r\n        kwargs:\r\n            used to overided any of the initialization values for the class\r\n        \"\"\"\r\n\r\n        lg = logging.getLogger(\"%s.%s\" % (self.ln, inspect.stack()[0][3]))\r\n        lg.setLevel(self.log_level)\r\n\r\n        args = inspect.getargvalues(inspect.currentframe())[3]\r\n        lg.debug(\"\\n****** Args *****:\\n%s\",\r\n                 pp.pformat(args))\r\n\r\n        es = kwargs.get(\"es\",self.es)\r\n        doc_type = kwargs.get(\"doc_type\", self.doc_type)\r\n        if id_field == \"_id\":\r\n            lg.debug(\"*** _id lookup: index: %s item_id: %s\",\r\n                     self.es_index,\r\n                     item_id)\r\n            result = es.get(index=self.es_index,\r\n                            id=item_id)\r\n        else:\r\n            dsl = {\r\n                \"query\": {\r\n                    \"constant_score\": {\r\n                        \"filter\": {\r\n                            \"term\": { id_field: item_id }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            lg.debug(\"*** id_field lookup: index: %s item_id: %s \\nDSL: %s\",\r\n                     self.es_index,\r\n                     item_id,\r\n                     pp.pformat(dsl))\r\n            result = es.search(index=self.es_index,\r\n                               doc_type=doc_type,\r\n                               body=dsl)\r\n            result = first(result.get(\"hits\",{}).get(\"hits\",[]))\r\n        lg.debug(\"\\tresult:\\n%s\", pp.pformat(result))\r\n        self.item_data = result\r\n        self.form_data = MultiDict(result)\r\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a key value list of items based on the specified criteria", "response": "def get_list(self, method=\"list\", **kwargs):\r\n        \"\"\" returns a key value list of items based on the specfied criteria\r\n\r\n        \"\"\"\r\n\r\n        lg = logging.getLogger(\"%s.%s\" % (self.ln, inspect.stack()[0][3]))\r\n        lg.setLevel(self.log_level)\r\n\r\n        args = inspect.getargvalues(inspect.currentframe())[3]\r\n        lg.debug(\"\\n****** Args *****:\\n%s\",\r\n                 pp.pformat(args))\r\n\r\n        es = kwargs.get(\"es\",self.es)\r\n        doc_type = get2(kwargs, \"doc_type\", self.doc_type)\r\n        id_field = get2(kwargs, \"id_field\", \"_id\")\r\n        value_fld = kwargs.get(\"value_fld\")\r\n        fields = kwargs.get(\"fields\")\r\n        sort_dir = get2(kwargs,\"sort_dir\", \"asc\")\r\n        sort_fields = get2(kwargs,\"sort_fields\", get2(kwargs, \"fields\", [value_fld]))\r\n        size = get2(kwargs,\"size\",2000)\r\n        term = get2(kwargs,\"term\",'').replace(\"/\",\"//\")\r\n        filter_field = kwargs.get('filter_field')\r\n        filter_value = kwargs.get('filter_value')\r\n        dsl = {}\r\n        # set retutn to only return the fields specified or return the whole\r\n        # document if not specified\r\n        if fields is not None:\r\n            dsl[\"_source\"] = fields\r\n        elif value_fld is not None:\r\n            dsl[\"_source\"] = [value_fld]\r\n            fields = [value_fld]\r\n        else:\r\n            fields = []\r\n        # set query parameters based on the return method \"list\" or \"search\"\r\n        if sort_dir != \"none\" and method == \"list\":\r\n            dsl[\"sort\"] = []\r\n            for fld in sort_fields:\r\n                if fld is not None:\r\n                    dsl[\"sort\"].append({ fld: sort_dir })\r\n        if method == \"search\":\r\n            # query in elasticsearch breaks if the is a single open parenthesis\r\n            # remove a single parenthesis from the search term\r\n            if \"(\" in term and \")\" not in term:\r\n                search_term = term.replace(\"(\", \"\")\r\n            else:\r\n                search_term = term\r\n            size = 5\r\n            dsl['query'] =  {\r\n                \"bool\": {\r\n                    \"should\": [\r\n                        {\r\n                            \"query_string\" : {\r\n                                \"analyze_wildcard\": {\r\n                                    \"query\": \"*%s*\" % search_term\r\n                                }\r\n\r\n                            }\r\n                        },\r\n                        {\r\n                            \"query_string\" : {\r\n                                \"query\": \"*%s*\" % search_term,\r\n                                \"analyzer\": \"default\",\r\n                                \"analyze_wildcard\": True,\r\n                                \"fields\": fields,\r\n                                \"boost\": 10\r\n                            }\r\n                        }\r\n                    ]\r\n                }\r\n            }\r\n        else:\r\n            pass\r\n        if filter_value:\r\n            dsl['filter'] = {\r\n                \"term\": { filter_field: filter_value }\r\n            }\r\n        lg.info(\"\\n-------- size: %s\\ndsl:\\n%s\", size, json.dumps(dsl,indent=4))\r\n        result = es.search(index=self.es_index,\r\n                           size=size,\r\n                           doc_type=doc_type,\r\n                           body=dsl)\r\n        if kwargs.get(\"calc\"):\r\n            result = self._calc_result(result, kwargs['calc'])\r\n        lg.debug(pp.pformat(result))\r\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _calc_result(self, results, calc):\r\n        lg = logging.getLogger(\"%s.%s\" % (self.ln, inspect.stack()[0][3]))\r\n        lg.setLevel(self.log_level)\r\n        # if the calculation is empty exit\r\n        if calc is None:\r\n            return results\r\n        lg.debug(\"calc %s\", calc)\r\n        # perform concatenation\r\n        hits = results.get('hits',{}).get('hits',[])\r\n        for item in hits:\r\n            lg.debug(\"\\n*** item:\\n%s\", pp.pformat(item))\r\n            if \"+\" in calc:\r\n                calc_parts = calc.split(\"+\")\r\n                calc_str = \"\"\r\n                for i, part in enumerate(calc_parts):\r\n                    if '\"' in part:\r\n                        calc_parts[i] = part.replace('\"','')\r\n                    else:\r\n                        if part.startswith(\"_\"):\r\n                            calc_parts[i] = item.get(part)\r\n                        else:\r\n                            calc_parts[i] = Dot(item['_source']).get(part)\r\n                lg.debug(\" calc result: %s\", \"\".join(calc_parts))\r\n                item['_source']['__calc'] = \"\".join(calc_parts)\r\n        lg.debug(\"calc %s\", calc)\r\n        return results", "response": "Parse the calc string and return the new value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef authorize_role(self, role, protocol, from_port, to_port, cidr_ip):\n    if (protocol != 'tcp' and protocol != 'udp'):\n      raise RuntimeError('error: expected protocol to be tcp or udp '\\\n                         'but got %s' % (protocol))\n    \n    self._check_role_name(role)\n    role_group_name = self._group_name_for_role(role)\n    # Revoke first to avoid InvalidPermission.Duplicate error\n    self.ec2.revoke_security_group(role_group_name,\n                                             ip_protocol=protocol,\n                                             from_port=from_port,\n                                             to_port=to_port, cidr_ip=cidr_ip)\n    self.ec2.authorize_security_group(role_group_name,\n                                                ip_protocol=protocol,\n                                                from_port=from_port,\n                                                to_port=to_port,\n                                                cidr_ip=cidr_ip)", "response": "Authorize access to machines in a given role from a given network."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_running(self, role, number):\n    instances = self.get_instances_in_role(role, \"running\")\n    if len(instances) != number:\n      print \"Expected %s instances in role %s, but was %s %s\" % \\\n        (number, role, len(instances), instances)\n      return False\n    else:\n      return instances", "response": "Check that a certain number of instances in a role are running."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting all the instances in a role filtered by state.", "response": "def get_instances_in_role(self, role, state_filter=None):\n    \"\"\"\n    Get all the instances in a role, filtered by state.\n\n    @param role: the name of the role\n    @param state_filter: the state that the instance should be in\n      (e.g. \"running\"), or None for all states\n    \"\"\"\n    self._check_role_name(role)\n    instances = []\n    \n    for instance in self._get_instances(self._group_name_for_role(role), \n                                       state_filter):            \n      instances.append(Instance(instance.id, instance.dns_name, \n                                instance.private_dns_name, \n                                instance.private_ip_address))\n      \n    return instances"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_instances(self, state_filter=None):\n\n    instances = []\n    for instance in self._get_instances(self._get_cluster_group_name(), \n                                        state_filter):\n      instances.append(Instance(instance.id, instance.dns_name, \n                                instance.private_dns_name, \n                                instance.private_ip_address))\n    return instances", "response": "Get all the instances in the cluster group filtered by state."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprints the status of instances in the given roles filtered by state.", "response": "def print_status(self, roles=None, state_filter=\"running\"):\n    \"\"\"\n    Print the status of instances in the given roles, filtered by state.\n    \"\"\"\n    if not roles:\n      for instance in self._get_instances(self._get_cluster_group_name(),\n                                          state_filter):\n        self._print_instance(\"\", instance)\n    else:\n      for role in roles:\n        for instance in self._get_instances(self._group_name_for_role(role),\n                                            state_filter):\n          self._print_instance(role, instance)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a block device mapping for the given image and instance type.", "response": "def CreateBlockDeviceMap(self, image_id, instance_type):\n      \"\"\"\n      If you launch without specifying a manual device block mapping, you may \n      not get all the ephemeral devices available to the given instance type.\n      This will build one that ensures all available ephemeral devices are\n      mapped.      \n      \"\"\"\n      # get the block device mapping stored with the image\n      image = self.ec2.get_image(image_id)\n      block_device_map = image.block_device_mapping\n      assert(block_device_map)\n      # update it to include the ephemeral devices      \n      # max is 4... is it an error for instances with fewer than 4 ?  \n      # see: http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/\n      # InstanceStorage.html#StorageOnInstanceTypes\n      ephemeral_device_names = ['/dev/sdb', '/dev/sdc', '/dev/sdd', '/dev/sde']\n      for i, device_name in enumerate(ephemeral_device_names):\n        name = 'ephemeral%d' % (i)\n        bdt = blockdevicemapping.BlockDeviceType(ephemeral_name = name)\n        block_device_map[device_name] = bdt\n      return block_device_map"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the placement group for this cluster type instance.", "response": "def get_cluster_placement_group(self):\n    \"\"\"\n    Return the placement group, create it if it doesn't yet exist. \n    (needed for cluster type instances).\n    \"\"\"\n    placement_group_name = 'pg-%s' % (self._name)\n    try:\n      self.ec2.create_placement_group(placement_group_name, \n                                                 strategy = 'cluster')\n    except:\n      pass\n    return placement_group_name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate the security groups for a given role.", "response": "def _create_security_groups(self, role):\n    \"\"\"\n    Create the security groups for a given role, including a group for the\n    cluster if it doesn't exist.\n    \"\"\"\n    self._check_role_name(role)\n    security_group_names = self._get_all_group_names()\n\n    cluster_group_name = self._get_cluster_group_name()\n    if not cluster_group_name in security_group_names:\n      self.ec2.create_security_group(cluster_group_name,\n                                               \"Cluster (%s)\" % (self._name))\n      self.ec2.authorize_security_group(cluster_group_name,\n                                                  cluster_group_name)\n      # Allow SSH from anywhere\n      self.ec2.authorize_security_group(cluster_group_name,\n                                                  ip_protocol=\"tcp\",\n                                                  from_port=22, to_port=22,\n                                                  cidr_ip=\"0.0.0.0/0\")\n\n    role_group_name = self._group_name_for_role(role)\n    if not role_group_name in security_group_names:\n      self.ec2.create_security_group(role_group_name,\n        \"Role %s (%s)\" % (role, self._name))\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _delete_security_groups(self):\n    group_names = self._get_all_group_names_for_cluster()\n    for group in group_names:\n      self.ec2.delete_security_group(group)", "response": "Delete security groups for each role in the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef argument_from_option(parser, component, opt_name, prefix=\"\"):\n    assert component.has_option(opt_name), \"'%s' is not an option of the given component\" % opt_name\n    option = component.options[opt_name]\n    argument_name = \"%s%s\" % (prefix, opt_name)\n    otype = option.otype\n    config = {}\n    config[\"action\"] = \"store\"\n    config[\"dest\"] = argument_name\n    config[\"help\"] = otype.help\n    config[\"default\"] = otype.default\n    if otype.choices is not None:\n        config[\"choices\"] = otype.choices\n\n    if isinstance(otype, Boolean):\n        config[\"action\"] = \"store_true\"\n        if config[\"default\"]:\n            config[\"action\"] = \"store_false\"\n            # ADD a \"not\" in the name\n            argument_name = \"%snot-%s\" % (prefix, opt_name)\n    else:\n        # Not boolean\n        def check_type(value):\n            try:\n                value = option.parse(value)\n                option.validate(value)\n            except ValidationError as err_list:\n                raise argparse.ArgumentTypeError(\"\\n\".join(err for err in err_list))\n            return value\n        config[\"type\"] = check_type\n\n    parser.add_argument(\n        \"--%s\" % argument_name,\n        **config\n    )", "response": "Add an argument to a parse from one option of one : class : Optionable."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd argparse arguments from all options of one optionable component to a dummy optionable component.", "response": "def arguments_from_optionable(parser, component, prefix=\"\"):\n    \"\"\" Add argparse arguments from all options of one :class:`Optionable`\n\n    >>> # Let's build a dummy optionable component:\n    >>> comp = Optionable()\n    >>> comp.add_option(\"num\", Numeric(default=1, max=12, help=\"An exemple of option\"))\n    >>> comp.add_option(\"title\", Text(help=\"The title of the title\"))\n    >>> comp.add_option(\"ok\", Boolean(help=\"is it ok ?\", default=True))\n    >>> comp.add_option(\"cool\", Boolean(help=\"is it cool ?\", default=False))\n    >>>\n    >>> # one can then register all the options of this component to a arg parser\n    >>> parser = argparse.ArgumentParser(prog=\"PROG\")\n    >>> arguments_from_optionable(parser, comp)\n    >>> parser.print_help()\n    usage: PROG [-h] [--num NUM] [--title TITLE] [--not-ok] [--cool]\n    <BLANKLINE>\n    optional arguments:\n      -h, --help     show this help message and exit\n      --num NUM      An exemple of option\n      --title TITLE  The title of the title\n      --not-ok       is it ok ?\n      --cool         is it cool ?\n    \n    The option values for a componant can then be retrieved with :func:`get_config_for`\n\n    .. doctest::\n        :hide:\n\n        >>> import argparse\n        >>> args = argparse.Namespace()\n        >>> args.num = 1\n        >>> args.title = \"My title\"\n        >>> args.ok = True\n        >>> args.cool = False\n\n    >>> args = parser.parse_args() # doctest: +SKIP\n    >>> config = get_config_for(args, comp)\n    >>> comp(\"input\", **config) # doctest: +SKIP\n    \"comp_result\"\n    \"\"\"\n    for option in component.options:\n        if component.options[option].hidden:\n            continue\n        argument_from_option(parser, component, option, prefix=prefix)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dictionary of option values for a given component", "response": "def get_config_for(args, component, prefix=\"\"):\n    \"\"\" Returns a dictionary of option value for a given component\n    \n    See :func:`arguments_from_optionable` documentation\n    \"\"\"\n    config = {}\n    vargs = vars(args)\n    for option in component.options:\n        if component.options[option].hidden:\n            continue\n        config[option] = vargs[\"%s%s\" % (prefix, option)]\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef serialize(expr):\n\n    result = None\n\n    if isinstance(expr, string_types):\n        result = expr\n\n    elif expr is not None:\n        result = '=py:{0}'.format(expr)\n\n    return result", "response": "Serialize input expr into a parsable value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _ref(\n        pname, conf=None, configurable=None, cname=None, path=None, history=0\n):\n    \"\"\"Resolve a parameter value.\n\n    :param Configuration conf: configuration to use.\n    :param str pname: parameter name.\n    :param Configurable configurable: configurable.\n    :param str cname: category name.\n    :param str path: conf path.\n    :param int history: parameter history research.\n    :return: parameter.\n    :raises: ParserError if conf and configurable are None.\n    \"\"\"\n\n    result = None\n\n    if configurable is not None:\n\n        kwargs = {}\n\n        if conf is not None:\n            kwargs['conf'] = conf\n\n        if path is not None:\n            kwargs['paths'] = path\n\n        if conf is None:\n            conf = configurable.getconf(**kwargs)\n\n    if conf is None:\n        raise ParserError(\n            'Wrong ref parameters. Conf and configurable are both None.'\n        )\n\n    result = conf.param(pname=pname, cname=cname, history=history)\n\n    return result", "response": "Resolve a parameter value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmount the given dev to the given mountpoint by using the given flags.", "response": "def mount(dev, mountpoint, flags='', log=None):\n    '''Mount the given dev to the given mountpoint by using the given flags'''\n    ensureDirectory(mountpoint)\n    systemCall('mount %s %s %s' % (flags, dev, mountpoint),\n               log=log)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extensions(self, component):\n        classes = ComponentMeta._registry.get(self.interface, ())\n        components = [component.compmgr[cls] for cls in classes]\n        return [c for c in components if c]", "response": "Return a list of components that declare to implement the\n        extension point interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns whether the given component class is enabled.", "response": "def is_enabled(self, cls):\n        \"\"\"Return whether the given component class is enabled.\"\"\"\n        if cls not in self.enabled:\n            self.enabled[cls] = self.is_component_enabled(cls)\n        return self.enabled[cls]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nforces a component to be disabled.", "response": "def disable_component(self, component):\n        \"\"\"Force a component to be disabled.\n\n        :param component: can be a class or an instance.\n        \"\"\"\n        if not isinstance(component, type):\n            component = component.__class__\n        self.enabled[component] = False\n        self.components[component] = None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef gotMessage(self, message_id, message):\n        d = defer.maybeDeferred(self._handle_message, message)\n        d.addCallback(self.generate_response)\n        d.addCallback(lambda resp: self.reply(message_id, resp))\n        return d", "response": "Handle a message received from the broker."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_response(self, response):\n        if not response:\n            return self.__serializer__.dump({})\n\n        return self.__serializer__.dump(response.to_dict())", "response": "Serializes the response object and returns the the\n            raw form."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef size(self):\n        old = self.__file.tell()        # old position\n\n        self.__file.seek(0, 2)          # end of file\n        n_bytes = self.__file.tell()    # file size in bytes\n\n        self.__file.seek(old)           # back to old position\n\n        return n_bytes", "response": "Calculate and return the file size in bytes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prev(self, n=1):\n        # Current position - #data\n        i = abs(self.tell - n)\n\n        # Get the next n data starting from i\n        return self.get(i, n)", "response": "Get the previous n data from file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, i, n=1):\n        # If there is nothing to get...\n        if self.size == 0:\n            return None\n\n        if n < 1:\n            return []\n\n        # Current byte position - (n * data_size)\n        offset = i * self.__strct.size\n\n        # Set file pointer to -(#data)\n        self.__file.seek(offset)\n\n        # Unpack raw data to struct\n        data = map(lambda x: self.unpack(x), self.raw(n))\n        data = map(lambda x: x if len(x) > 1 else x[0], data)\n        data = list(data)\n\n        # If n is 1, return a single unpacked data.\n        # Otherwise, return a list of unpacked data\n        return data[0] if n == 1 else data", "response": "Get the n data starting from the ith struct."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef last(self):\n        # End of file\n        self.__file.seek(0, 2)\n\n        # Get the last struct\n        data = self.get(self.length - 1)\n\n        return data", "response": "Get the last object in file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef raw(self, n=1):\n        size = self.__strct.size  # struct size\n        dataset = list()          # list of raw data\n\n        try:\n            # For n times...\n            for _ in range(n):\n                data = self.__file.read(size)  # get raw data from file\n                dataset.append(data)           # save raw data in the list\n        finally:\n            return dataset", "response": "Get the data from file*."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite the value into the file.", "response": "def append(self, value):\n        \"\"\"Write the value into the file.\n\n        Keyword arguments:\n            value -- value to be writen (tuple)\n        \"\"\"\n        # Pack value\n        data = self.pack(value)\n\n        # End of file\n        self.__file.seek(0, 2)\n\n        # Write packed value\n        self.__file.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting value in ith position in file.", "response": "def write(self, i, value):\n        \"\"\"Write value in ith position in file.\n\n        Keyword arguments:\n            i -- position in file\n            value -- value to be packed (tuple)\n        \"\"\"\n        # Current byte position - (n * data_size)\n        offset = i * self.__strct.size\n\n        # Set file pointer to -(#data)\n        self.__file.seek(offset)\n\n        # Pack value\n        data = self.pack(value)\n\n        # Write packed value\n        self.__file.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef truncate(self, n):\n        # Current byte position - (n * data_size)\n        size = self.size - n * self.__strct.size\n\n        # Erase [size] bytes from file.tell()\n        self.__file.truncate(size)", "response": "Erase [ n elements ] from file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef checkMaxSessions(self, nMax=None):\r\n        if nMax is None:\r\n            nMax = self.opts['maxSessions']\r\n        l = self.stateNames()\r\n        if len(l) > nMax:\r\n            for f in l[:len(l) - nMax]:\r\n                self.tmp_dir_session.remove(str(f))", "response": "check whether max. number of saved sessions is reached\r\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stateNames(self):\r\n#         if self.current_session:\r\n        s = self.tmp_dir_session\r\n        l = [x for x in s.listdir() if s.join(x).isdir()]\r\n        naturalSorting(l)\r\n        # else:\r\n        #    l=[]\r\n        # bring autosave to first position:\r\n        if 'autoSave' in l:\r\n            l.remove('autoSave')\r\n            l.insert(0, 'autoSave')\r\n        return l", "response": "Returns a list of names of all saved session names"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninspects the command - line - args and give them to appBase", "response": "def _inspectArguments(self, args):\r\n        \"\"\"inspect the command-line-args and give them to appBase\"\"\"\r\n        if args:\r\n            self.exec_path = PathStr(args[0])\r\n        else:\r\n            self.exec_path = None\r\n\r\n        session_name = None\r\n        args = args[1:]\r\n\r\n        openSession = False\r\n        for arg in args:\r\n            if arg in ('-h', '--help'):\r\n                self._showHelp()\r\n            elif arg in ('-d', '--debug'):\r\n                print('RUNNGING IN DEBUG-MODE')\r\n                self.opts['debugMode'] = True\r\n            elif arg in ('-l', '--log'):\r\n                print('CREATE LOG')\r\n                self.opts['createLog'] = True\r\n            elif arg in ('-s', '--server'):\r\n                self.opts['server'] = True\r\n            elif arg in ('-o', '--open'):\r\n                openSession = True\r\n            elif openSession:\r\n                session_name = arg\r\n            else:\r\n                print(\"Argument '%s' not known.\" % arg)\r\n                return self._showHelp()\r\n        return session_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(self):\r\n        if self.path:\r\n            self._saveState(self.path)\r\n        else:\r\n            self.saveAs()", "response": "save the current session override if session was saved earlier"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef open(self):\r\n        filename = self.dialogs.getOpenFileName(filter=\"*.%s\" % self.FTYPE)\r\n        if filename:\r\n            self.new(filename)", "response": "open a session to define in a dialog in an extra window"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef new(self, filename=None):\r\n        path = (self.exec_path,)\r\n        if self.exec_path.filetype() in ('py', 'pyw', 'pyz', self.FTYPE):\r\n            # get the absolute path to the python-executable\r\n            p = find_executable(\"python\")\r\n            path = (p, 'python') + path\r\n        else:\r\n            # if run in frozen env (.exe):\r\n            # first arg if execpath of the next session:\r\n            path += (self.exec_path,)\r\n        if filename:\r\n            path += ('-o', filename)\r\n        os.spawnl(os.P_NOWAIT, *path)", "response": "start a new session an independent process"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _saveState(self, path):\r\n        self.addSession()  # next session\r\n        self._save(str(self.n_sessions), path)", "response": "save current state and add a new state"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _autoSave(self):\r\n        a = 'autoSave'\r\n        path = self.path\r\n        if not path:\r\n            path = self.dir.join('%s.%s' % (a, self.FTYPE))\r\n            self._createdAutosaveFile = path\r\n        self.tmp_dir_save_session = self.tmp_dir_session.join(a).mkdir()\r\n        self._save(a, path)", "response": "save state into autosave"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef blockingSave(self, path):\r\n        self.tmp_dir_save_session = self.tmp_dir_session.join('block').mkdir()\r\n        state = {'session': dict(self.opts),\r\n                 'dialogs': self.dialogs.saveState()}\r\n        self.saveThread.prepare('0', path, self.tmp_dir_session, state)\r\n        self.sigSave.emit(self)\r\n        self.saveThread.run()", "response": "save a session to file - returns after finish\r\n        only called by interactiveTutorial - save at the moment"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave into stateName to pyz - path", "response": "def _save(self, stateName, path):\r\n        \"\"\"save into 'stateName' to pyz-path\"\"\"\r\n        print('saving...')\r\n\r\n        state = {'session': dict(self.opts),\r\n                 'dialogs': self.dialogs.saveState()}\r\n\r\n        self.sigSave.emit(state)\r\n        self.saveThread.prepare(stateName, path, self.tmp_dir_session, state)\r\n        self.saveThread.start()\r\n\r\n        self.current_session = stateName\r\n\r\n        r = self.opts['recent sessions']\r\n        try:\r\n            # is this session already exists: remove it\r\n            r.pop(r.index(path))\r\n        except ValueError:\r\n            pass\r\n        # add this session at the beginning\r\n        r.insert(0, path)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _recusiveReplaceArrayWithPlaceholder(self, state):\r\n        arrays = {}\r\n\r\n        def recursive(state):\r\n            for key, val in state.items():\r\n                if isinstance(val, dict):\r\n                    recursive(val)\r\n                else:\r\n                    if isinstance(val, np.ndarray):\r\n                        name = 'arr_%i' % recursive.c\r\n                        arrays[name] = val\r\n                        state[key] = name\r\n                        recursive.c += 1\r\n        recursive.c = 0\r\n        recursive(state)\r\n        return arrays", "response": "Replace all numpy. array within the state dict with a placeholder"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef start_indexing(self):\n        for filepath in self.filepaths:\n            with open(filepath) as fp:\n                blob = fp.read()\n                self.words.extend(self.tokenize(blob))", "response": "Read all the files and tokenize their text into words and accumulate all the words in a list."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrap JSONified output for JSONP requests.", "response": "def api(func):\n    \"\"\"Wraps JSONified output for JSONP requests.\"\"\"\n    @wraps(func)\n    def decorated_function(*args, **kwargs):\n        try:\n            value = func(*args, **kwargs)\n        except BaseException as e:\n            value = {\n                \"status\": \"failed\",\n                \"error\": \"Unkonwn error!\"\n            }\n            flask.current_app.logger.error(\"Unkonwn error: %s\" % str(e))\n            flask.current_app.logger.exception(e)\n\n        status = 200\n        mimetype = 'application/json'\n        content = json.dumps(value)\n        callback = flask.request.args.get('callback', False)\n        if callback:\n            content = str(callback) + '(' + content + ')'\n            mimetype = 'application/javascript'\n\n        return flask.current_app.response_class(content, status=status, mimetype=mimetype)\n    return decorated_function"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets one document store into LinShare.", "response": "def get(self, uuid):\n        \"\"\" Get one document store into LinShare.\"\"\"\n        #return self.core.get(\"documents/\" + uuid)\n        documents = (v for v in self.list() if v.get('uuid') == uuid)\n        for i in documents:\n            self.log.debug(i)\n            return i\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef upload(self, file_path, description=None, async=False):\n        url = \"documents?async={a}\".format(a=async)\n        return self.core.upload(file_path, url, description)", "response": "Uploads a file to LinShare using its rest api."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupload a file to LinShare using its rest api.", "response": "def update_file(self, uuid, file_path, async=False):\n        \"\"\" Upload a file to LinShare using its rest api.\n        The uploaded document uuid will be returned\"\"\"\n        url = \"documents/{u}/upload?async={a}\".format(u=uuid, a=async)\n        return self.core.upload(file_path, url, http_method='PUT')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _do_debug(self, cmd, args):\n        if not args:\n            self.stdout.write('on' if self.debug else 'off')\n            self.stdout.write('\\n')\n            return\n        if len(args) > 1:\n            self.stderr.write('debug: too many arguments: {}\\n'.format(args))\n            return\n        action = args[0]\n        if action == 'on':\n            self.debug = True\n        elif action == 'off':\n            self.debug = False\n        elif action == 'shell':\n            return 'DEBUG'\n        elif action == 'toggle':\n            self.debug = not self.debug\n            self.stdout.write('on' if self.debug else 'off')\n            self.stdout.write('\\n')\n        else:\n            self.stderr.write('debug: unrecognized argument: {}\\n'.format(action))", "response": "Internal function to handle the debug command."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsplit a query name into field name operator and whether it is inverted.", "response": "def parse_name(name):\n    \"\"\" Split a query name into field name, operator and whether it is\n    inverted. \"\"\"\n    inverted, op = False, OP_EQ\n    if name is not None:\n        for op_ in (OP_NIN, OP_IN, OP_NOT, OP_LIKE):\n            if name.endswith(op_):\n                op = op_\n                name = name[:len(name) - len(op)]\n                break\n        if name.startswith('!'):\n            inverted = True\n            name = name[1:]\n    return name, inverted, op"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect_db(database_name=\":memory:\"):\n    db = repo.Repo.connect_db(database_name)\n    base.Repo.db = db\n    query.Repo.db = db", "response": "Connect lazy_record to the database at the specified path specified in database_name."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncloses the connection to the database opened in connect_db", "response": "def close_db():\n    \"\"\"\n    Close the connection to the database opened in `connect_db`\n    \"\"\"\n    db = repo.Repo.db\n    if db is not None:\n        db.close()\n    repo.Repo.db = None\n    base.Repo.db = None\n    query.Repo.db = None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_schema(schema):\n    with repo.Repo.db:\n        repo.Repo.db.executescript(schema)", "response": "Load a schema file into the database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_values(self, min=None, max=None, conflict='warning'):\n\t\tconflict_txt = None\n\t\tif min is not None:\n\t\t\tif min > self.min:\n\t\t\t\tif min > self.max:\n\t\t\t\t\tself.max = self.highest\n\t\t\t\t\tself.prefer_highest = False\n\t\t\t\t\tconflict_txt = 'Minimum {0:s} conflicts with maximum {1:s}; minimum is higher so it takes precedence, but lower values in range are not preferred.'.format('{0:d}.{1:d}'.format(*self.to_tup(min)), '{0:d}.{1:d}'.format(*self.to_tup(self.max)))\n\t\t\t\tself.min = min\n\t\tif max is not None:\n\t\t\tif max < self.max:\n\t\t\t\tif max >= self.min:\n\t\t\t\t\tself.max = max\n\t\t\t\telse:\n\t\t\t\t\tself.prefer_highest = False\n\t\t\t\t\tconflict_txt = 'Maximum {0:s} conflicts with minimum {1:s}; minimum is higher so takes it precedence, but lower values in range are now preferred.'.format('{0:d}.{1:d}'.format(*self.to_tup(max)), '{0:d}.{1:d}'.format(*self.to_tup(self.min)))\n\t\tif conflict_txt:\n\t\t\tversion_problem_notify(conflict_txt, conflict=conflict)", "response": "Update the boundaries of the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrestrict the range given a selection string :param selection: A single selection (without comma), like '>=1.3'. :param conflict: What to do in case of failure: 'silent', 'warning' or 'error'.", "response": "def add_selection(self, selection, conflict = 'warning'):\n\t\t\"\"\"\n\t\tRestrict the range given a selection string\n\n\t\t:param selection: A single selection (without comma), like '>=1.3'.\n\t\t:param conflict: What to do in case of failure: 'silent', 'warning' or 'error'.\n\t\t\"\"\"\n\t\tselection = selection.replace(' ', '').replace('=.', '=0.')\n\t\tif not selection:\n\t\t\treturn\n\t\tif selection.count(',') or selection.count('_'):\n\t\t\traise VersionFormatError(('Version string \"{0:s}\" is incorrect. Perhaps you\\'re trying to add a combined one; ' +\n\t\t\t\t'you should use add_selections for that').format(selection))\n\t\tif selection.count('.') > 1:\n\t\t\traise VersionFormatError(('Version string \"{0:s}\" is incorrect. Perhaps it contains a version longer than 2 numbers ' +\n\t\t\t\t'(e.g. \"3.14)\" which is intentionally not supported. Version numbers beyond the second are for bugfixes only.').format(selection))\n\t\tregex = r'^([><=]=?)(\\d+|\\*)(?:\\.(\\d*|\\*))?$'\n\t\tfound = findall(regex, selection)\n\t\tif not found:\n\t\t\traise VersionFormatError('Version string \"{0:s}\" not properly formatted according to \"{1:s}\".'.format(selection, regex))\n\t\toperation, majorstr, minorstr = found[0]\n\t\tif majorstr == '*':\n\t\t\treturn\n\t\tmajor = int(majorstr)\n\t\tif minorstr == '*':\n\t\t\tself.update_values(conflict=conflict,\n\t\t\t\tmin = self.to_nr(major, 0),\n\t\t\t\tmax = self.to_nr(major + 1, 0) - 1,\n\t\t\t)\n\t\t\treturn\n\t\texclusive = int(not operation.endswith('='))\n\t\tmajor_only = int(not minorstr)\n\t\tnr = self.to_nr(major, int(minorstr or 0))\n\t\tif operation.startswith('='):\n\t\t\tself.update_values(conflict=conflict,\n\t\t\t\tmin = nr,\n\t\t\t\tmax = nr + major_only * self.limit - major_only,\n\t\t\t)\n\t\telif operation.startswith('<'):\n\t\t\tself.update_values(conflict=conflict,\n\t\t\t\tmax = nr - exclusive + (not exclusive) * (major_only * self.limit - major_only),\n\t\t\t)\n\t\telif operation.startswith('>'):\n\t\t\tself.update_values(conflict=conflict,\n\t\t\t\tmin = nr + exclusive + exclusive * (major_only * self.limit - major_only),\n\t\t\t)\n\t\telse:\n\t\t\traise VersionFormatError('Version (in)equality operator \"{0:s}\" not recognized. ' +\n\t\t\t\t'Full operation \"{1:s}\"'.format(operation, selection))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef choose(self, versions, conflict='silent'):\n\t\tassert conflict in ('silent', 'warning', 'error')\n\t\tif not versions:\n\t\t\traise VersionRangeMismatch('No versions to choose from')\n\t\tversion_map = {}\n\t\tfor version in versions:\n\t\t\tversion_map[version] = str2nr(version, mx=self.limit)\n\t\ttop_version, top_nr = None, 0\n\t\t\"\"\" Try to find the highest value in range. \"\"\"\n\t\tfor version, nr in version_map.items():\n\t\t\tif nr >= top_nr:\n\t\t\t\tif self.min <= nr <= self.max:\n\t\t\t\t\ttop_version, top_nr = version, nr\n\t\tif top_version:\n\t\t\treturn top_version\n\t\t\"\"\" We need to look outside the range, so maybe give a warning. \"\"\"\n\t\tversion_problem_notify('No matching version found for range \"{0:s}\" from options \"{1:s}\"; other options might be considered.'.format(\n\t\t\tstr(self), '/'.join(str(v) for v in versions)), conflict=conflict)\n\t\t\"\"\" Failing the above, try to find the lowest value above the range. \"\"\"\n\t\ttop_nr = self.highest\n\t\tfor version, nr in version_map.items():\n\t\t\tif nr < top_nr:\n\t\t\t\tif nr >= self.max:\n\t\t\t\t\ttop_version, top_nr = version, nr\n\t\tif top_version:\n\t\t\treturn top_version\n\t\t\"\"\" Failing the above two, try to highest value below the range (so just the highest). \"\"\"\n\t\ttop_nr = 0\n\t\tfor version, nr in version_map.items():\n\t\t\tif nr > top_nr:\n\t\t\t\ttop_version, top_nr = version, nr\n\t\tif top_version:\n\t\t\treturn top_version", "response": "Choose the highest version in the range."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_slice_or_dim_range_request(key, depth=0):\n    '''\n    Checks if a particular key is a slice, DimensionRange or\n    list of those types\n    '''\n    # Slice, DimensionRange, or list of those elements\n    return (is_slice_or_dim_range(key) or\n            # Don't check more than the first depth\n            (depth == 0 and non_str_len_no_throw(key) > 0 and\n             all(is_slice_or_dim_range_request(subkey, depth+1) for subkey in key)))", "response": "Checks if a particular key is a slice DimensionRange or list of those types\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting negative indices to positive ones and indices above length to length - 1 depending on lengthAllowed.", "response": "def get_restricted_index(index, length, length_index_allowed=True):\n    '''\n    Converts negative indices to positive ones and indices above length to length or\n    length-1 depending on lengthAllowed.\n    '''\n    if index and index >= length:\n        index = length if length_index_allowed else length-1\n    return get_non_negative_index(index, length)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_true_slice(dims, data_len):\n    '''\n    Converts various size tuples or slices representing data ranges returns a\n    new slice with all non-negative (or None) values.\n    '''\n    rangeLen = non_str_len_no_throw(dims)\n\n    # Get the range qualifier for length\n    if isinstance(dims, slice):\n        start = get_restricted_index(int(dims.start), data_len) if dims.start != None else dims.start\n        stop = get_restricted_index(int(dims.stop), data_len) if dims.stop != None else dims.stop\n        step = get_restricted_index(int(dims.step), data_len) if dims.step != None else dims.step\n    elif rangeLen > 3:\n        raise AttributeError(str(dims)+' length is > 3')\n    elif rangeLen == 3:\n        start = get_restricted_index(int(dims[0]), data_len) if dims[0] != None else dims[0]\n        stop = get_restricted_index(int(dims[1]), data_len) if dims[1] != None else dims[1]\n        step = get_restricted_index(int(dims[2]), data_len) if dims[2] != None else dims[2]\n    elif rangeLen == 2:\n        start = get_restricted_index(int(dims[0]), data_len) if dims[0] != None else dims[0]\n        stop = get_restricted_index(int(dims[1]), data_len) if dims[1] != None else dims[1]\n        step = None\n    elif rangeLen == 1:\n        start = get_restricted_index(int(dims[0]), data_len) if dims[0] != None else dims[0]\n        stop = get_restricted_index(int(dims[0]), data_len)+1 if dims[0] != None else dims[0]\n        step = None\n    elif dims != None:\n        start = get_restricted_index(int(dims), data_len) if dims != None else dims\n        stop = get_restricted_index(int(dims), data_len)+1 if dims != None else dims\n        step = None\n    else:\n        start = None\n        stop = None\n        step = None\n\n    return slice(start, stop, step)", "response": "Converts various size tuples or slices representing data ranges returns a\n    new slice with all non - negative values or None values."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a slice representing the dimension range restrictions applied to a list of length data_len.", "response": "def slice_on_length(self, data_len, *addSlices):\n        '''\n        Returns a slice representing the dimension range\n        restrictions applied to a list of length data_len.\n\n        If addSlices contains additional slice requirements,\n        they are processed in the order they are given.\n        '''\n        if len(self.ordered_ranges) + len(addSlices) == 0:\n            return slice(None,None,None)\n        ranges = self.ordered_ranges\n        if len(addSlices) > 0:\n            ranges = ranges + DimensionRange(*addSlices).ordered_ranges\n        return self._combine_lists_of_ranges_on_length(data_len, *ranges)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _combine_ranges_on_length(self, data_len, first, second):\n        '''\n        Combines a first range with a second range, where the second\n        range is considered within the scope of the first.\n        '''\n        first = get_true_slice(first, data_len)\n        second = get_true_slice(second, data_len)\n        final_start, final_step, final_stop = (None, None, None)\n\n        # Get our start\n        if first.start == None and second.start == None:\n            final_start = None\n        else:\n            final_start = (first.start if first.start else 0)+(second.start if second.start else 0)\n\n        # Get our stop\n        if second.stop == None:\n            final_stop = first.stop\n        elif first.stop == None:\n            final_stop = (first.start if first.start else 0) + second.stop\n        else:\n            final_stop = min(first.stop, (first.start if first.start else 0) + second.stop)\n\n        # Get our step\n        if first.step == None and second.step == None:\n            final_step = None\n        else:\n            final_step = (first.step if first.step else 1)*(second.step if second.step else 1)\n\n        # If we have a start above our stop, set them to be equal\n        if final_start > final_stop:\n            final_start = final_stop\n\n        return slice(final_start, final_stop, final_step)", "response": "Combines two sets of data_len - > range"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _combine_lists_of_ranges_on_length(self, data_len, first, *range_list):\n        '''\n        Combines an arbitrary length list of ranges into a single slice.\n        '''\n        current_range = first\n        for next_range in range_list:\n            current_range = self._combine_ranges_on_length(data_len, current_range, next_range)\n        return current_range", "response": "Combines an arbitrary length list of ranges into a single slice."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_single_depth(self, multi_index):\n        '''\n        Helper method for determining how many single index entries there\n        are in a particular multi-index\n        '''\n        single_depth = 0\n        for subind in multi_index:\n            if is_slice_or_dim_range(subind):\n                break\n            single_depth += 1\n        return single_depth", "response": "Helper method for determining how many single index entries there are in a particular multi - index."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_single_index_request(self, index, set_to_value=False, value=None):\n        '''\n        Helper function which implements single index requests for __getitem__.\n        '''\n        adjusted_index = index\n        # Multiply by step length\n        if self.range.step:\n            step = self.range.step\n            adjusted_index *= self.range.step\n        else:\n            step = 1\n\n        # Adjust for negative indicies\n        adjusted_index = get_non_negative_index(adjusted_index, self._length)\n        # Push forward by start length\n        if self.range.start != None:\n            adjusted_index += self.range.start\n        # Push forward by start length\n        stop_index = self.range.stop if self.range.stop != None else self._length*step\n        if adjusted_index > stop_index:\n            raise IndexError(index)\n        elem = self._data[adjusted_index]\n        # Check if we have further dimension requirements\n        # NOTE: if we're given dimensions for non-dimensional data,\n        # this will blow up with an IndexError -- user should\n        # not define this dimension with any restrictions\n        if len(self._dim_ranges) > 1:\n            if not has_len(elem):\n                # We throw an IndexError instead of an AttributeError\n                # because if can be caused by either sublist requests\n                # or a bad constructor, and it's usually the former.\n                raise IndexError(\"Element restricted by dimension_ranges \"+\n                                 str(self._dim_ranges[1:])+\" is not subscriptable: \"+\n                                 \"Dimension cannot be applied to elements with no len()\")\n            return self.builder(elem, *self._dim_ranges[1:])\n        else:\n            if set_to_value:\n                self._data[adjusted_index] = value\n            return elem", "response": "Helper function which returns a single index request for the given index."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting the internal dimension ranges on lists into lists of restricted size.", "response": "def compress_ranges_to_lists(self):\n        '''\n        Converts the internal dimension ranges on lists into\n        list of the restricted size. Thus all dimension rules\n        are applied to all dimensions of the list wrapper\n        and returned as a list (of lists).\n        '''\n        clist = []\n        for elem in self:\n            if isinstance(elem, FixedListSubset):\n                clist.append(elem.compress_ranges_to_lists())\n            else:\n                clist.append(elem)\n        return clist"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _generate_splice(self, slice_ind):\n        '''\n        Creates a splice size version of the ZeroList\n        '''\n        step_size = slice_ind.step if slice_ind.step else 1\n        # Check for each of the four possible scenarios\n        if slice_ind.start != None:\n            if slice_ind.stop != None:\n                newListLen = ((get_non_negative_index(slice_ind.stop, self._length) -\n                               get_non_negative_index(slice_ind.start, self._length)) // step_size)\n            else:\n                newListLen = ((self._length -\n                               get_non_negative_index(slice_ind.start, self._length)) // step_size)\n        else:\n            if slice_ind.stop != None:\n                newListLen = ((get_non_negative_index(slice_ind.stop, self._length)) // step_size)\n            else:\n                newListLen = (self._length // step_size)\n\n        return ZeroList(newListLen)", "response": "Generates a splice size version of the ZeroList."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave the record to the database.", "response": "def save(self, update_site=False, *args, **kwargs):\n        \"\"\"\n        Set the site to the current site when the record is first\n        created, or the ``update_site`` argument is explicitly set\n        to ``True``.\n        \"\"\"\n        if update_site or (self.id is None and self.site_id is None):\n            self.site_id = current_site_id()\n        super(SiteRelated, self).save(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the description field on save.", "response": "def save(self, *args, **kwargs):\n        \"\"\"\n        Set the description field on save.\n        \"\"\"\n        if self.gen_description:\n            self.description = strip_tags(self.description_from_content())\n        super(MetaData, self).save(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the first block or sentence of the first content - like field.", "response": "def description_from_content(self):\n        \"\"\"\n        Returns the first block or sentence of the first content-like\n        field.\n        \"\"\"\n        description = \"\"\n        # Use the first RichTextField, or TextField if none found.\n        for field_type in (RichTextField, models.TextField):\n            if not description:\n                for field in self._meta.fields:\n                    if (isinstance(field, field_type) and\n                            field.name != \"description\"):\n                        description = getattr(self, field.name)\n                        if description:\n                            from yacms.core.templatetags.yacms_tags \\\n                                                    import richtext_filters\n                            description = richtext_filters(description)\n                            break\n        # Fall back to the title if description couldn't be determined.\n        if not description:\n            description = str(self)\n        # Strip everything after the first block or sentence.\n        ends = (\"</p>\", \"<br />\", \"<br/>\", \"<br>\", \"</ul>\",\n                \"\\n\", \". \", \"! \", \"? \")\n        for end in ends:\n            pos = description.lower().find(end)\n            if pos > -1:\n                description = TagCloser(description[:pos]).html\n                break\n        else:\n            description = truncatewords_html(description, 100)\n        try:\n            description = unicode(description)\n        except NameError:\n            pass  # Python 3.\n        return description"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting default for publish_date.", "response": "def save(self, *args, **kwargs):\n        \"\"\"\n        Set default for ``publish_date``. We can't use ``auto_now_add`` on\n        the field as it will be blank when a blog post is created from\n        the quick blog form in the admin dashboard.\n        \"\"\"\n        if self.publish_date is None:\n            self.publish_date = now()\n        super(Displayable, self).save(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the short_url attribute of the current object if it does not already have one.", "response": "def set_short_url(self):\n        \"\"\"\n        Generates the ``short_url`` attribute if the model does not\n        already have one. Used by the ``set_short_url_for`` template\n        tag and ``TweetableAdmin``.\n\n        If no sharing service is defined (bitly is the one implemented,\n        but others could be by overriding ``generate_short_url``), the\n        ``SHORT_URL_UNSET`` marker gets stored in the DB. In this case,\n        ``short_url`` is temporarily (eg not persisted) set to\n        host + ``get_absolute_url`` - this is so that we don't\n        permanently store ``get_absolute_url``, since it may change\n        over time.\n        \"\"\"\n        if self.short_url == SHORT_URL_UNSET:\n            self.short_url = self.get_absolute_url_with_host()\n        elif not self.short_url:\n            self.short_url = self.generate_short_url()\n            self.save()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_short_url(self):\n        from yacms.conf import settings\n        if settings.BITLY_ACCESS_TOKEN:\n            url = \"https://api-ssl.bit.ly/v3/shorten?%s\" % urlencode({\n                \"access_token\": settings.BITLY_ACCESS_TOKEN,\n                \"uri\": self.get_absolute_url_with_host(),\n            })\n            response = loads(urlopen(url).read().decode(\"utf-8\"))\n            if response[\"status_code\"] == 200:\n                return response[\"data\"][\"url\"]\n        return SHORT_URL_UNSET", "response": "Generate a short URL for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets next or previous object by publish date.", "response": "def _get_next_or_previous_by_publish_date(self, is_next, **kwargs):\n        \"\"\"\n        Retrieves next or previous object by publish date. We implement\n        our own version instead of Django's so we can hook into the\n        published manager and concrete subclasses.\n        \"\"\"\n        arg = \"publish_date__gt\" if is_next else \"publish_date__lt\"\n        order = \"publish_date\" if is_next else \"-publish_date\"\n        lookup = {arg: self.publish_date}\n        concrete_model = base_concrete_model(Displayable, self)\n        try:\n            queryset = concrete_model.objects.published\n        except AttributeError:\n            queryset = concrete_model.objects.all\n        try:\n            return queryset(**kwargs).filter(**lookup).order_by(order)[0]\n        except IndexError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef with_respect_to(self):\n        try:\n            name = self.order_with_respect_to\n            value = getattr(self, name)\n        except AttributeError:\n            # No ``order_with_respect_to`` specified on the model.\n            return {}\n        # Support for generic relations.\n        field = getattr(self.__class__, name)\n        if isinstance(field, GenericForeignKey):\n            names = (field.ct_field, field.fk_field)\n            return dict([(n, getattr(self, n)) for n in names])\n        return {name: value}", "response": "Returns a dict to use as a filter for ordering operations\n        containing the original Meta. order_with_respect_to value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves the object to the database.", "response": "def save(self, *args, **kwargs):\n        \"\"\"\n        Set the initial ordering value.\n        \"\"\"\n        if self._order is None:\n            lookup = self.with_respect_to()\n            lookup[\"_order__isnull\"] = False\n            concrete_model = base_concrete_model(Orderable, self)\n            self._order = concrete_model.objects.filter(**lookup).count()\n        super(Orderable, self).save(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete the related record sets.", "response": "def delete(self, *args, **kwargs):\n        \"\"\"\n        Update the ordering values for siblings.\n        \"\"\"\n        lookup = self.with_respect_to()\n        lookup[\"_order__gte\"] = self._order\n        concrete_model = base_concrete_model(Orderable, self)\n        after = concrete_model.objects.filter(**lookup)\n        after.update(_order=models.F(\"_order\") - 1)\n        super(Orderable, self).delete(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets next or previous object by order.", "response": "def _get_next_or_previous_by_order(self, is_next, **kwargs):\n        \"\"\"\n        Retrieves next or previous object by order. We implement our\n        own version instead of Django's so we can hook into the\n        published manager, concrete subclasses and our custom\n        ``with_respect_to`` method.\n        \"\"\"\n        lookup = self.with_respect_to()\n        lookup[\"_order\"] = self._order + (1 if is_next else -1)\n        concrete_model = base_concrete_model(Orderable, self)\n        try:\n            queryset = concrete_model.objects.published\n        except AttributeError:\n            queryset = concrete_model.objects.filter\n        try:\n            return queryset(**kwargs).get(**lookup)\n        except concrete_model.DoesNotExist:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_editable(self, request):\n        return request.user.is_superuser or request.user.id == self.user_id", "response": "Returns True if the object is editable."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns all subclasses of the concrete model.", "response": "def get_content_models(cls):\n        \"\"\" Return all subclasses of the concrete model.  \"\"\"\n        concrete_model = base_concrete_model(ContentTyped, cls)\n        return [m for m in apps.get_models()\n                if m is not concrete_model and issubclass(m, concrete_model)]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_content_model(self):\n        if not self.content_model:\n            is_base_class = (\n                base_concrete_model(ContentTyped, self) == self.__class__)\n            self.content_model = (\n                None if is_base_class else self.get_content_model_name())", "response": "Sets the content_model to the child class s related name or None if this is the base class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef indent(s, spaces=4):\n    new = re.sub('(\\n+)', '\\\\1%s' % (' ' * spaces), s)\n    return (' ' * spaces) + new.strip()", "response": "Indent a string s by spaces spaces"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread the contents of a file into a sequence of base classes.", "response": "def read_file(filename):\n    '''\n    Reads files\n\n    :param filename:\n        The full path of the file to read\n    :returns:\n        The content of the file as string (if `filename` exists)\n\n\n    .. note:: If `filename`'s content is empty, ``None`` will also returned.\n\n        To check if a file really exists\n        use :func:`util.locations.search_location`\n    '''\n\n    if filename and _path.exists(filename):\n        with open(filename, 'r') as f:\n            return f.read()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_yaml(filename, add_constructor=None):\n    '''\n    Reads YAML files\n\n    :param filename:\n        The full path to the YAML file\n    :param add_constructor:\n        A list of yaml constructors (loaders)\n    :returns:\n        Loaded YAML content as represented data structure\n\n    .. seealso::\n        :func:`util.structures.yaml_str_join`,\n        :func:`util.structures.yaml_loc_join`\n    '''\n\n    y = read_file(filename)\n    if add_constructor:\n        if not isinstance(add_constructor, list):\n            add_constructor = [add_constructor]\n        for a in add_constructor:\n            _yaml.add_constructor(*a)\n    if y:\n        return _yaml.load(y)", "response": "Reads the YAML file filename and returns a dictionary of the data structure."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites the content of the file to the specified file.", "response": "def write_file(filename, content):\n    '''\n    Writes files\n\n    :param filename:\n        The full path of the file to write\n        (enclosing folder must already exist)\n    :param content:\n        The content to write\n    :returns:\n        The size of the data written\n    '''\n\n    if filename and _path.exists(_path.dirname(filename)) and content:\n        with open(filename, 'w') as f:\n            return f.write(content)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting a YAML file with the content of the object content to the file filename.", "response": "def write_yaml(filename, content):\n    '''\n    Writes YAML files\n\n    :param filename:\n        The full path to the YAML file\n    :param content:\n        The content to dump\n    :returns:\n        The size written\n    '''\n\n    y = _yaml.dump(content, indent=4, default_flow_style=False)\n    if y:\n        return write_file(filename, y)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites a json file containing the content of the object content to the file filename.", "response": "def write_json(filename, content):\n    '''\n    Writes json files\n\n    :param filename:\n        The full path to the json file\n    :param content:\n        The content to dump\n    :returns:\n        The size written\n    '''\n\n    j = _dumps(content, indent=4, sort_keys=True)\n    if j:\n        return write_file(filename, j)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a PEP 386 - compliant version number from VERSION.", "response": "def get_version():\n    \"Returns a PEP 386-compliant version number from VERSION.\"\n    assert len(VERSION) == 5\n    assert VERSION[3] in ('alpha', 'beta', 'rc', 'final')\n\n    # Now build the two parts of the version number:\n    # main = X.Y[.Z]\n    # sub = .devN - for pre-alpha releases\n    #     | {a|b|c}N - for alpha, beta and rc releases\n\n    parts = 2 if VERSION[2] == 0 else 3\n    main = '.'.join(str(x) for x in VERSION[:parts])\n\n    sub = ''\n    if VERSION[3] != 'final':\n        mapping = {'alpha': 'a', 'beta': 'b', 'rc': 'c'}\n        sub = mapping[VERSION[3]] + str(VERSION[4])\n\n    return str(main + sub)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_template(name):\n    path = 'templates/' + name\n    b_stream = pkg_resources.resource_stream('vr.imager', path)\n    return b_stream.read().decode('utf-8')", "response": "Look for name in the vr. runners. templates folder. Return its contents."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef query_multiple_endpoints(urls, query: PyQuery):\n    urls = list(urls)\n    return _query_multiple_endpoints(urls, query)", "response": "Query multiple endpoints in a single page."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compile_query(query: dict) -> PyQuery:\n\n    def _pair_to_dict(pair):\n        if isinstance(pair, dict):\n            return pair\n        return {pair[0]: pair[1]}\n\n    def _reduce(pair):\n        try:\n            return {'and': (_pair_to_dict(pair[0]), _pair_to_dict(pair[1]))}\n        except (KeyError, IndexError):\n            return _pair_to_dict(pair)\n\n    def _get_first_pair(d: dict):\n        return list(query.items())[0]\n\n    if len(query) < 2:\n        return compile_single_item(*_get_first_pair(query))\n    try:\n        reduced = reduce(lambda x, y: _reduce((x, y)), query.items())\n    except KeyError:\n        print(query)\n        reduced = query\n        raise\n    return compile_single_item(*_get_first_pair(reduced))", "response": "Returns a PyQuery object that compiles a query dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates K columns with unique random integers from 0 to N - 1", "response": "def block_idxmat_shuffle(numdraws, numblocks, random_state=None):\n    \"\"\"Create K columns with unique random integers from 0 to N-1\n\n    Purpose:\n    --------\n    - Create K blocks for k-fold cross-validation\n\n    Parameters:\n    -----------\n    numdraws : int\n        number of observations N or sample size N\n\n    numblocks : int\n        number of blocks K\n\n    Example:\n    --------\n        import pandas as pd\n        import numpy as np\n        import oxyba as ox\n\n        X = np.random.normal(size=(7,5), scale=50).round(1)\n        N,_ = X.shape\n\n        K = 3;  #number of blocks\n        idxmat, dropped = ox.block_idxmat_shuffle(N,K)\n\n        for b in range(K):\n            print('\\nBlock:',b)\n            print(pd.DataFrame(X[idxmat[:,b],:], index=idxmat[:,b]))\n\n        print('\\nDropped observations\\n', X[dropped,:] )\n        print('\\nrow indicies of dropped observations:', dropped, '\\')\n\n    Why is this useful?\n    -------------------\n    - Avoid creating copies of dataset X during run time\n    - Shuffle the indicies of a data point rather than the\n        data points themselve\n\n    Links:\n    ------\n    - How numpy's permutation works, https://stackoverflow.com/a/15474335\n    \"\"\"\n    # load modules\n    import numpy as np\n\n    # minimum block size: bz=int(N/K)\n    blocksize = int(numdraws / numblocks)\n\n    # shuffle vector indicies: from 0 to N-1\n    if random_state:\n        np.random.seed(random_state)\n    obsidx = np.random.permutation(numdraws)\n\n    # how many to drop? i.e. \"numdrop = N - bz*K\"\n    numdrop = numdraws % numblocks\n    dropped = obsidx[:numdrop]\n    obsidx = obsidx[numdrop:]\n\n    # reshape the remaing vector indicies into a matrix\n    idxmat = obsidx.reshape((blocksize, numblocks))\n\n    # output the indicies for the blocks, and indicies of dropped obserations\n    return idxmat, dropped"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking a Guinier plot. This is simply a wrapper around plotsascurve.", "response": "def guinierplot(*args, **kwargs):\n    \"\"\"Make a Guinier plot. This is simply a wrapper around plotsascurve().\"\"\"\n    ret=plotsascurve(*args, **kwargs)\n    plt.xscale('power',exponent=2)\n    plt.yscale('log')\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main():\n    pypitools.common.setup_main()\n    config = pypitools.common.ConfigData()\n    module_name = os.path.basename(os.getcwd())\n    args = []\n    if config.use_sudo:\n        args.extend([\n            'sudo',\n            '-H',\n        ])\n    args.extend([\n        '{}'.format(config.pip),\n        'install',\n        '--upgrade',\n        '{module_name}'.format(module_name=module_name),\n    ])\n    if config.pip_quiet:\n        args.extend([\n            '--quiet',\n        ])\n    if config.install_in_user_folder:\n        args.extend([\n            '--user',\n        ])\n    pypitools.common.check_call_no_output(args)\n    output = subprocess.check_output([\n        '{}'.format(config.pip),\n        'show',\n        '{module_name}'.format(module_name=module_name),\n    ]).decode()\n    for line in output.split(\"\\n\"):\n        if line.startswith(\"Version\"):\n            print(line)", "response": "Install a package from pypi or gemfury\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting value to <type bool >", "response": "def boolean(value, boolmap=_BOOL_MAP):\n    \"\"\"\n    Convert value to <type bool>.\n\n    Uses the boolean mapping dict to attempt to determine the conversion\n    of the given value. If the value is not found in the mapping, it falls\n    back to the built-in Python bool conversion. Optionally, a custom\n    mapping dict can be passed to use for the value lookups.\n\n    The default mapping dict allows quick and easy conversion of some\n    common string values that have logical meaning as being true or false.\n\n    This alternative allows one to consider a separate mapping when\n    converting values to a boolean that are not what Python would\n    inherently consider the value as. This is particularly useful for\n    environment variables which are almost always retrieved as strings\n    instead of whatever their inherent data type actually is.\n\n    Because of how Python treats strings, this means that an environment\n    variable which has been given the value of ``\"False\"`` ends up\n    evaluating to ``True`` even though that was probably not the intention.\n    \"\"\"\n    if boolmap == _BOOL_MAP and isinstance(value, str):\n        result = boolmap.get(value.lower())\n    else:\n        result = boolmap.get(value)\n\n    if result is None:\n        result = bool(value)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of lists of Cells with the cooked value and note for each cell.", "response": "def to_cell_table(self, merged=True):\n    \"\"\"Returns a list of lists of Cells with the cooked value and note for each cell.\"\"\"\n    new_rows = []\n    for row_index, row in enumerate(self.rows(CellMode.cooked)):\n      new_row = []\n      for col_index, cell_value in enumerate(row):\n        new_row.append(Cell(cell_value, self.get_note((col_index, row_index))))\n      new_rows.append(new_row)\n    if merged:\n      for cell_low, cell_high in self.merged_cell_ranges():\n        anchor_cell = new_rows[cell_low[1]][cell_low[0]]\n        for row_index in range(cell_low[1], cell_high[1]):\n          for col_index in range(cell_low[0], cell_high[0]):\n            # NOTE: xlrd occassionally returns ranges that don't have cells.\n            try:\n              new_rows[row_index][col_index] = anchor_cell.copy()\n            except IndexError:\n              pass\n    return new_rows"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a sequence of parsed rows from the worksheet.", "response": "def rows(self, cell_mode=CellMode.cooked):\n    \"\"\"Generates a sequence of parsed rows from the worksheet. The cells are parsed according to the\n    cell_mode argument.\n    \"\"\"\n    for row_index in range(self.nrows):\n      yield self.parse_row(self.get_row(row_index), row_index, cell_mode)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_row(self, row, row_index, cell_mode=CellMode.cooked):\n    return [self.parse_cell(cell, (col_index, row_index), cell_mode) \\\n            for col_index, cell in enumerate(row)]", "response": "Parse a row according to the given cell_mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_cell(self, coords, cell_mode=CellMode.cooked):\n    return self.parse_cell(self.get_row(coords[1])[coords[0]], coords, cell_mode)", "response": "Get a cell from the worksheet according to the given coords and parse it according to the cell_mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tuple_to_datetime(self, date_tuple):\n    year, month, day, hour, minute, second = date_tuple\n    if year == month == day == 0:\n      return time(hour, minute, second)\n    elif hour == minute == second == 0:\n      return date(year, month, day)\n    else:\n      return datetime(year, month, day, hour, minute, second)", "response": "Converts a tuple to a date time or datetime object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sheets(self, index=None):\n    if self._sheets is None:\n      self._sheets = [self.get_worksheet(s, i) for i, s in enumerate(self.iterate_sheets())]\n    if index is None:\n      return self._sheets\n    else:\n      return self._sheets[index]", "response": "Return either a list of all sheets if index is None or the sheet at the given index."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_available_pack_names():\n    installed_pack_names = [pack.name.lower() for pack in Pack.objects.all()]\n    fortunes_path = get_fortunes_path()\n    for path in fortunes_path.iterdir():\n        if path.is_dir():\n            pass\n        elif path.suffix == \".dat\":\n            pass\n        elif path.name.lower() in installed_pack_names:\n            pass\n        else:\n            yield path.name.lower()", "response": "Return a list of ( lower - cased ) names if available Packs."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_fortunes_path():\n    app_config = apps.get_app_config(\"fortune\")\n    return Path(os.sep.join([app_config.path, \"fortunes\"]))", "response": "Return the path to the fortunes data packs."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nselects the entries in the table.", "response": "def select(self, column, agg=None, _as=None, distinct=False):\n        \"\"\"\n        What columnns to select in query.\n        :column should be a column name or equation to produce column **not** aggregated\n        :agg should be a valid aggregate method used to producte the figure\n        :_as should be a string used to represent the column. Required when agg present\n        \"\"\"\n        if agg and not _as:\n            raise ValueError(\"Aggregate colunns require `_as` to be specified\")\n        if column is False:\n            self._selects = {}\n        else:\n            self._selects.setdefault((_as or column), (column, agg, _as, distinct))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef profile_fields(user):\n    fields = OrderedDict()\n    try:\n        profile = get_profile_for_user(user)\n        user_fieldname = get_profile_user_fieldname()\n        exclude = tuple(settings.ACCOUNTS_PROFILE_FORM_EXCLUDE_FIELDS)\n        for field in profile._meta.fields:\n            if field.name not in (\"id\", user_fieldname) + exclude:\n                value = getattr(profile, field.name)\n                fields[field.verbose_name.title()] = value\n    except ProfileNotConfigured:\n        pass\n    return list(fields.items())", "response": "Returns the profile fields as a dict for the given user."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the user s username for display or an alternate attribute if ACCOUNTS_NO_USERNAME is set to True.", "response": "def username_or(user, attr):\n    \"\"\"\n    Returns the user's username for display, or an alternate attribute\n    if ``ACCOUNTS_NO_USERNAME`` is set to ``True``.\n    \"\"\"\n    if not settings.ACCOUNTS_NO_USERNAME:\n        attr = \"username\"\n    value = getattr(user, attr)\n    if callable(value):\n        value = value()\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process_tarball(tarball, output_directory=None, context=False):\n    if not output_directory:\n        # No directory given, so we use the same path as the tarball\n        output_directory = os.path.abspath(\"{0}_files\".format(tarball))\n\n    extracted_files_list = untar(tarball, output_directory)\n    image_list, tex_files = detect_images_and_tex(extracted_files_list)\n\n    if tex_files == [] or tex_files is None:\n        raise NoTexFilesFound(\"No TeX files found in {0}\".format(tarball))\n\n    converted_image_mapping = convert_images(image_list)\n    return map_images_in_tex(\n        tex_files,\n        converted_image_mapping,\n        output_directory,\n        context\n    )", "response": "Process one tarball end - to - end."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef map_images_in_tex(tex_files, image_mapping,\n                      output_directory, context=False):\n    \"\"\"Return caption and context for image references found in TeX sources.\"\"\"\n    extracted_image_data = []\n    for tex_file in tex_files:\n        # Extract images, captions and labels based on tex file and images\n        partly_extracted_image_data = extract_captions(\n            tex_file,\n            output_directory,\n            image_mapping.keys()\n        )\n        if partly_extracted_image_data:\n            # Convert to dict, add proper filepaths and do various cleaning\n            cleaned_image_data = prepare_image_data(\n                partly_extracted_image_data,\n                output_directory,\n                image_mapping,\n            )\n            if context:\n                # Using prev. extracted info, get contexts for each image found\n                extract_context(tex_file, cleaned_image_data)\n\n            extracted_image_data.extend(cleaned_image_data)\n\n    return extracted_image_data", "response": "Map images found in TeX files to caption and context."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds paths to CONF_DIRS.", "response": "def _addconfig(config, *paths):\n    \"\"\"Add path to CONF_DIRS if exists.\"\"\"\n\n    for path in paths:\n        if path is not None and exists(path):\n            config.append(path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new fMRI for given experiment by uploading a local file.", "response": "def create(url, filename):\n        \"\"\"Create new fMRI for given experiment by uploading local file.\n        Expects an tar-archive.\n\n        Parameters\n        ----------\n        url : string\n            Url to POST fMRI create request\n        filename : string\n            Path to tar-archive on local disk\n\n        Returns\n        -------\n        string\n            Url of created functional data resource\n        \"\"\"\n        # Upload file to create fMRI resource. If response is not 201 the\n        # uploaded file is not a valid functional data archive\n        files = {'file': open(filename, 'rb')}\n        response = requests.post(url, files=files)\n        if response.status_code != 201:\n            raise ValueError('invalid file: ' + filename)\n            return references_to_dict(response.json()['links'])[REF_SELF]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, user_name: str) -> User:\n        user = current_user()\n        if user.is_admin or user.name == user_name:\n            return self._get_or_abort(user_name)\n        else:\n            abort(403)", "response": "Gets the User Resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef put(self, user_name: str) -> User:\n        current = current_user()\n        if current.name == user_name or current.is_admin:\n            user = self._get_or_abort(user_name)\n            self.update(user)\n            session.commit()\n            session.add(user)\n            return user\n        else:\n            abort(403)", "response": "Updates the User Resource with the specified name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self, user_name: str):\n        user = self._get_or_abort(user_name)\n        session.delete(user)\n        session.commit()\n        return '', 204", "response": "Deletes the resource with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef try_pop(d, key, default):\n    value = d.get(key, default)\n    if key in d:\n        d.pop(key)\n    return value", "response": "Try to pop a key from a hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a node instance.", "response": "def node(self):\n        \"\"\"Create a :py:class:`Node` instance.\n\n        All args and kwargs are forwarded to the node.\n\n        :returns: a :py:class:`Node` instance\n        \"\"\"\n\n        if self.node_class is None:\n            raise ValueError(\"You have to create an ``Item`` by calling ``__init__`` with ``node_class`` argument\"\n                             \" or by decorating a ``Node`` class.\")\n\n        node = self.node_class(*self.node_args, **self.node_kwargs)\n        node.__item__ = self\n\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nresolving the value. Either apply missing or serialize", "response": "def _resolve_value(self, value, environment=None):\n        \"\"\"Resolve the value.\n\n        Either apply missing or leave the value as is.\n\n        :param value: the value either from deserialize or serialize\n        :param environment: an optional environment\n        \"\"\"\n\n        # here we care about Undefined values\n        if value == values.Undefined:\n            if isinstance(self._missing, type) and issubclass(self._missing, Missing):\n                # instantiate the missing thing\n                missing = self._missing(self, environment)\n\n                # invoke missing callback\n                # the default is to raise a MissingValue() exception\n                value = missing(value)\n\n            elif hasattr(self._missing, \"__call__\"):\n                value = self._missing()\n\n            else:\n                # we just assign any value\n                value = self._missing\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nopens a file based on the extension of the file.", "response": "def open(filepath, mode='rb', buffcompress=None):\n    '''\n    Open a file based on the extension of the file\n    if the filepath ends in .gz then use gzip module's open otherwise\n    use the normal builtin open\n\n    :param str filepath: Path to .gz or any other file\n    :param str mode: mode to open file\n    :param int buffcompress: 3rd option for builtin.open or gzip.open\n    :return: tuple(filehandle, fileextension)\n    '''\n    root, ext = splitext(filepath.replace('.gz', ''))\n    # get rid of period\n    ext = ext[1:]\n    if filepath.endswith('.gz'):\n        compress = buffcompress\n        if compress is None:\n            compress = 9\n        handle = gzip.open(filepath, mode, compress)\n    else:\n        buffer = buffcompress\n        if buffer is None:\n            buffer = -1\n        handle = builtins.open(filepath, mode, buffer)\n    return (handle, ext)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_repeat_masker_string(s):\n  parts = s.split()\n\n  if len(parts) != 15 and len(parts) != 14:\n    raise RetrotransposonError(\"incorrectly formated RepeatMasker entry: \" + s)\n\n  # get rid of those pesky parentheses\n  for i in [11, 12, 13]:\n    parts[i] = parts[i].strip()\n    if parts[i][0] == \"(\":\n      parts[i] = parts[i][1:]\n    if parts[i][-1] == \")\":\n      parts[i] = parts[i][0:-1]\n\n  # the first 11, invariant columns...\n  # score = float(parts[0])  -- we don't use this\n  # p_div = float(parts[1])  -- we don't use this\n  # p_del = float(parts[2])  -- we don't use this\n  # p_ins = float(parts[3])  -- we don't use this\n  q_seq = parts[4].strip()\n  q_seq_start = int(parts[5])\n  q_seq_end = int(parts[6]) + 1\n  # left_qseq = parts[7].strip() -- we don't use this\n  strand = \"-\" if parts[8].strip() in COMPLEMENT_CHARS else \"+\"\n  repeat_name = parts[9].strip()\n  repeat_family = parts[10].strip()\n\n  # the three columns the define match location in the consensus\n  con_pos_start = int(parts[11]) if strand is \"+\" else int(parts[13])\n  con_pos_end = int(parts[12]) + 1\n  con_pos_left = int(parts[13]) if strand is \"+\" else int(parts[11])\n\n  # might get ID, mgiht not -- its sometimes missing.\n  repeat_id = int(parts[14].strip()) if len(parts) == 15 else None\n\n  # we can compute the length of the consensus using the 'leftover' index\n  con_seq_len = con_pos_end + con_pos_left\n\n  rt = Retrotransposon(repeat_name, repeat_family)\n  return RetrotransposonOccurrence(q_seq, q_seq_start, q_seq_end, strand,\n                                   con_pos_start, con_pos_end, con_seq_len,\n                                   rt, uniq_id=repeat_id)", "response": "Parse a RepeatMasker string and return a dictionary of the values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef liftover(self, intersecting_region):\n\n    # a little sanity check here to make sure intersecting_region really does..\n    if not self.intersects(intersecting_region):\n      raise RetrotransposonError(\"trying to lift \" + str(intersecting_region) +\n                                 \" from genomic to transposon coordinates \" +\n                                 \"in \" + str(self) + \", but it doesn't \" +\n                                 \"intersect!\")\n\n    if self.pairwise_alignment is not None:\n      return self.pairwise_alignment.liftover(self.chrom, self.repeat_name(),\n                                              intersecting_region.start,\n                                              intersecting_region.end,\n                                              trim=True)\n    return self.liftover_coordinates(intersecting_region)", "response": "Returns a list of GenomicIntervals that are part of the same genomic occurrence and overlaps the given region."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of GenomicInterval objects that are only valid if the genomic occurrence of the retrotransposon is intersecting with the given region.", "response": "def liftover_coordinates(self, intersecting_region):\n    \"\"\"\n    Lift a region that overlaps the genomic occurrence of the retrotransposon\n    to consensus sequence co-ordinates. Use only the coordinates of the\n    occurrence and the consensus match (i.e. ignore a full alignment, even\n    if one is present). If the genomic size of the match is the same as the\n    size of the match in the consensus sequence then it is assumed no indels\n    are present in either sequence, otherwise indels are assumed to exist\n    uniformly distributed along the sequences to make their lengths match.\n\n    :param intersect_region: a region that intersects this occurrence.\n    :return: list of GenomicInterval objects. This is a list because a genomic\n             deletion of part of the retrotransposon can fragment the\n             intersecting region and result in more than one returned interval.\n    \"\"\"\n    # a little sanity check here to make sure intersecting_region really does..\n    if not self.intersects(intersecting_region):\n      raise RetrotransposonError(\"trying to lift \" + str(intersecting_region) +\n                                 \" from genomic to transposon coordinates \" +\n                                 \"in \" + str(self) + \", but it doesn't \" +\n                                 \"intersect!\")\n\n    consensus_match_length = self.consensus_end - self.consensus_start\n    size_dif = consensus_match_length - len(self)\n\n    if size_dif == 0:\n      # put this in a list, even though we know we're getting only one\n      # interval, to make the return type consistent\n      return [self.__liftover_coordinates_size_match(intersecting_region)]\n    else:\n      return self.__liftover_coordinates_genomic_indels(intersecting_region)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a GenomicInterval representing the region that overlaps the retrotransposon sequence coordinates using just the coordinates of the intersecting region.", "response": "def __liftover_coordinates_size_match(self, intersecting_region):\n    \"\"\"\n    Lift a region that overlaps the genomic occurrence of the retrotransposon\n    to consensus sequence coordinates using just the coordinates (not the full)\n    alignment, when they have the same length. This is an internal helper\n    method. The above length constraint must be true, otherwise an assertion\n    is failed.\n\n    :param intersect_region: a region that intersects this occurrence.\n    :return: GenomicInterval representing the region after lifting to consensus\n    :note: no checks are made for whether the interval really intersects!!\n    \"\"\"\n    # should always pass, but check anyway...\n    consensus_match_length = self.consensus_end - self.consensus_start\n    assert(consensus_match_length - len(self) == 0)\n\n    if self.consensus_match_strand is '+':\n      s = max(intersecting_region.start - self.start, 0) +\\\n          self.consensus_start\n      e = min(max(intersecting_region.end - self.start, 0) +\n              self.consensus_start, self.consensus_len)\n      g = GenomicInterval(self.repeat_name(), s, e, intersecting_region.name,\n                          intersecting_region.score, self.strand)\n      return g\n    elif self.consensus_match_strand is '-':\n      e = (self.consensus_end -\n           max(intersecting_region.start - self.start, 0))\n      s = (self.consensus_end -\n           min(max(intersecting_region.end - self.start, 0), len(self)))\n      g = GenomicInterval(self.repeat_name(), s, e, intersecting_region.name,\n                          intersecting_region.score, self.strand)\n      return g\n    else:\n      raise RetrotransposonError(\"couldn't determine strand of \" +\n                                 \"retrotransposon occurrance \" + str(self))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __liftover_coordinates_genomic_indels(self, intersect_region):\n    # should never happen, but check anyway...\n    consensus_match_length = self.consensus_end - self.consensus_start\n    size_dif = consensus_match_length - len(self)\n    assert(size_dif != 0)\n\n    if size_dif < 0:\n      # genomic region longer; assume genomic region contains insertions\n      return self.__liftover_coordinates_genomic_insertions(intersect_region)\n    else:\n      # genomic region shorter; assume genomic region contains deletions\n      return self.__liftover_coordinates_genomic_deletions(intersect_region)", "response": "This method takes a region that overlaps the genomic occurrence of the retrotransposon and returns a list of GenomicInterval objects that are created by the _liftover_genomic_indels method."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlifts a region that overlaps the genomic occurrence of this repeat to the consensus sequence coordinates using just coordinates (not the full alignment, even if it is avaialble), when the length of the genomic match is greater than the concensus match. We assume there are insertions in the genomic sequence (i.e. gaps in the consensus match). We uniformly distribute the gaps through the consensus match. e.g. if the genomic region is 100nt long and the consensus match is 90nt long, we will consider an insertion to occurr every 10nt in the genomic sequence. The start and end coordinates of the region after lifting will be reduced by the number of genomic insertions that would have come before them. :param intersecting_region: a region that intersects this occurrence. :return: list of GenomicInterval objects. This is a list because, although the liftover can produce only one genomic interval in consensus, it might also produce none (if the interval overlaps only insertions in the genomic sequence), hence an empty list is possible.", "response": "def __liftover_coordinates_genomic_insertions(self, intersecting_region):\n    \"\"\"\n    Lift a region that overlaps the genomic occurrence of this repeat to the\n    consensus sequence coordinates using just coordinates (not the full\n    alignment, even if it is avaialble), when the length of the genomic match\n    is greater than the concensus match. We assume there are insertions in\n    the genomic sequence (i.e. gaps in the consensus match). We uniformly\n    distribute the gaps through the consensus match. e.g. if the genomic\n    region is 100nt long and the consensus match is 90nt long, we will consider\n    an insertion to occurr every 10nt in the genomic sequence. The start and\n    end coordinates of the region after lifting will be reduced by the number\n    of genomic insertions that would have come before them.\n\n    :param intersecting_region: a region that intersects this occurrence.\n    :return: list of GenomicInterval objects. This is a list because, although\n             the liftover can produce only one genomic interval in consensus,\n             it might also produce none (if the interval overlaps only\n             insertions in the genomic sequence), hence an empty list is\n             possible.\n    \"\"\"\n    # should never happen, but check anyway...\n    consensus_match_length = self.consensus_end - self.consensus_start\n    size_dif = consensus_match_length - len(self)\n    assert(size_dif < 0)\n\n    gap_interval = len(self) / (-1 * size_dif)\n    s_dist_to_gen_start = max(intersecting_region.start - self.start, 0)\n    e_dist_to_gen_start = max(intersecting_region.end - self.start, 0)\n\n    if self.consensus_match_strand is '+':\n      s = s_dist_to_gen_start + self.consensus_start\n      e = e_dist_to_gen_start + self.consensus_start\n      s = s - (s_dist_to_gen_start / gap_interval)\n      e = min(e - (e_dist_to_gen_start / gap_interval), self.consensus_len)\n    else:\n      e = self.consensus_end - s_dist_to_gen_start\n      s = self.consensus_end - e_dist_to_gen_start\n      s = max(s + (e_dist_to_gen_start / gap_interval),\n              self.consensus_start)\n      e = min(e + (s_dist_to_gen_start / gap_interval), self.consensus_end)\n\n    res = [] if s == e else [GenomicInterval(self.repeat_name(), s, e,\n                                             intersecting_region.name,\n                                             intersecting_region.score,\n                                             self.strand)]\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __liftover_coordinates_genomic_deletions(self, intersecting_region):\n    # should never happen, but check anyway...\n    consensus_match_length = self.consensus_end - self.consensus_start\n    size_dif = consensus_match_length - len(self)\n    assert(size_dif > 0)\n\n    name = self.repeat_name()\n    gap_interval = int(math.ceil(len(self) / float(size_dif)))\n    s_dist_to_gen_start = max(intersecting_region.start - self.start, 0)\n    e_dist_to_gen_start = min(max(intersecting_region.end -\n                                  self.start, 0), len(self))\n    gaps_before = s_dist_to_gen_start / gap_interval\n    gaps_in = ((e_dist_to_gen_start - 1) / gap_interval) - gaps_before\n    gen_s_dist = s_dist_to_gen_start\n    left_to_lift = (min(self.end, intersecting_region.end) -\n                    max(self.start, intersecting_region.start))\n    res = []\n    if self.consensus_match_strand is '+':\n      s = s_dist_to_gen_start + self.consensus_start\n      s = s + gaps_before\n      for i in range(0, gaps_in):\n        e = s + min((gap_interval - (gen_s_dist % gap_interval)), left_to_lift)\n        res.append(GenomicInterval(name, s, e, intersecting_region.name,\n                                   intersecting_region.score, self.strand))\n        gen_s_dist += (e - s)\n        left_to_lift -= (e - s)\n        s = e + 1\n      e = min(s + min(gap_interval, left_to_lift), self.consensus_end)\n      if e - s != 0:\n        res.append(GenomicInterval(name, s, e, intersecting_region.name,\n                                   intersecting_region.score, self.strand))\n    else:\n      e = self.consensus_end - s_dist_to_gen_start\n      e = e - gaps_before\n      for i in range(0, gaps_in):\n        s = e - min((gap_interval - (gen_s_dist % gap_interval)), left_to_lift)\n        res.append(GenomicInterval(name, s, e, intersecting_region.name,\n                                   intersecting_region.score, self.strand))\n        gen_s_dist += (e - s)\n        left_to_lift -= (e - s)\n        e = s - 1\n      s = max(e - min(gap_interval, left_to_lift), self.consensus_start)\n      if e - s != 0:\n        res.append(GenomicInterval(name, s, e, intersecting_region.name,\n                                   intersecting_region.score, self.strand))\n    return res", "response": "Private method to perform liftover in coordinate space\n    when the length of the concensus match is smaller than the concensus match. This method is used to determine if the concensus match is smaller than the concensus match."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_exception(exc, uuid=None):\n        if not isinstance(exc, Error):\n            exc = Error(code=500, message=str(exc))\n\n        return Result(\n            uuid=exc.extra.get(\"uuid\", uuid or random_uuid()),\n            retcode=exc.code, stderr=exc.message,\n            retval=dict(error=ErrorSchema().dump(exc))\n        )", "response": "Serialize an exception into a result object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search_value(self, xpath, default=None, single_value=True):\n        matches = [match.value for match in parse(xpath).find(self.retval)]\n        if len(matches) == 0:\n            return default\n        return matches[0] if single_value is True else matches", "response": "Try to find a value in the result set by xpath."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the device object for this system.", "response": "def device(self):\n        \"\"\"\n        The underlaying ``pyudev.Device`` instance can be accessed by using the\n        ``device`` property. This propety is cached, so only one lookup is\n        performed to obtain the device object. This cache is invalidated by\n        :py:meth:`~refresh` method.\n        \"\"\"\n        # We always create a new context and look up the devices because they\n        # may disappear or change their state between lookups.\n        if not self._device:\n            ctx = pyudev.Context()\n            devs = ctx.list_devices(sys_name=self.name)\n            try:\n                self._device = list(devs)[0]\n            except IndexError:\n                raise ValueError(\n                    'Device {} no longer present in context'.format(self.name))\n        return self._device"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef devid(self):\n        d = self.device\n        vend_id = d.get('ID_VENDOR_ID')\n        model_id = d.get('ID_MODEL_ID')\n        return (vend_id, model_id)", "response": "Two - tuple containing vendor ID and model ID."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_first(self, keys, default=None):\n        d = self.device\n        for k in keys:\n            v = d.get(k)\n            if not v is None:\n                return v\n        return default", "response": "Returns the first value for given keys."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef aliases(self):\n        links = list(self.device.device_links)\n        links.insert(0, self.node)\n        return links", "response": "Return a list of device aliases that match this device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_migration(self, migration: 'Migration'):\n        if migration.from_ver >= migration.to_ver:\n            raise ValueError('Migration cannot downgrade verson')\n        if migration.from_ver != self._final_ver:\n            raise ValueError('Cannot register disjoint migration')\n        self._migrations[migration.from_ver] = migration\n        self._final_ver = migration.to_ver", "response": "Register a migration.\n\n        You can only register migrations in order.  For example, you can\n        register migrations from version 1 to 2, then 2 to 3, then 3 to\n        4.  You cannot register 1 to 2 followed by 3 to 4."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmigrates a database as needed.", "response": "def migrate(self, conn):\n        \"\"\"Migrate a database as needed.\n\n        This method is safe to call on an up-to-date database, on an old\n        database, on a newer database, or an uninitialized database\n        (version 0).\n\n        This method is idempotent.\n        \"\"\"\n        while self.should_migrate(conn):\n            current_version = get_user_version(conn)\n            migration = self._get_migration(current_version)\n            assert migration.from_ver == current_version\n            logger.info(f'Migrating database from {migration.from_ver}'\n                        f' to {migration.to_ver}')\n            self._migrate_single(conn, migration)\n            set_user_version(conn, migration.to_ver)\n            logger.info(f'Migrated database to {migration.to_ver}')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _migrate_single(self, conn, migration):\n        with contextlib.ExitStack() as stack:\n            for wrapper in self._wrappers:\n                stack.enter_context(wrapper(conn))\n            migration.func(conn)", "response": "Perform a single migration starting from the given version."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef makeService(self, options):\n        return BrokerService(\n            port=options['port'],\n            debug=options['debug'],\n            activate_ssh_server=options['activate-ssh-server'],\n            ssh_user=options['ssh-user'],\n            ssh_password=options['ssh-password'],\n            ssh_port=options['ssh-port']\n        )", "response": "Construct a BrokerService object from options."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_work_items(self, **filters):\n        '''\n        Get a work item's information\n        :param filters: A series of key value pairs to filter on\n        :return: list of Workitems or None\n        '''\n        filter_string = \"\"\n        for key, val in filters.iteritems():\n            filter_string += \"%s='%s'\" % (key, val)\n        url = \"/rpt/repository/workitem?fields=workitem/workItem[%s]/(\" \\\n              \"*|\\\n               owner/name|\\\n               state/name|\\\n               projectArea/name|\\\n               type/name|\\\n               comments/*|\\\n               comments/creator/*|\\\n               stringComplexity/*|\\\n               category/*|\\\n               creator/*|\\\n               tags/*|\\\n               priority/*|\\\n               severity/*\\\n               )\" % filter_string\n        try:\n            response = self.get(url)\n        except requests.exceptions.ReadTimeout:\n            return \"Request timed out :(\"\n\n        if response.status_code != 200:\n            return None\n\n        output = xmltodict.parse(response.text)\n        if \"workItem\" not in output[\"workitem\"]:\n            return None\n        else:\n            workitems = []\n            if isinstance(output[\"workitem\"][\"workItem\"], list):\n                for wi in output[\"workitem\"][\"workItem\"]:\n                    workitems.append(Workitem(wi))\n            else:\n                workitems.append(Workitem(output[\"workitem\"][\"workItem\"]))\n            return workitems", "response": "Get a list of Workitems from the repository."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_work_item_by_id(self, wi_id):\n        '''\n        Retrieves a single work item based off of the supplied ID\n\n        :param wi_id: The work item ID number\n        :return: Workitem or None\n        '''\n        work_items = self.get_work_items(id=wi_id)\n        if work_items is not None:\n            return work_items[0]\n        return None", "response": "Retrieves a single work item based off of the supplied ID."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the cone_search object", "response": "def get(self):\n        \"\"\"\n        *get the cone_search object*\n\n        **Return:**\n            - ``results`` -- the results of the conesearch\n\n        \"\"\"\n        self.log.info('starting the ``get`` method')\n\n        # sort results by angular separation\n        from operator import itemgetter\n        results = list(self.squareResults)\n        results = sorted(\n            results, key=itemgetter('separation_arcsec'), reverse=True)\n\n        # order of results\n        headers = [\"sdss_name\", \"type\", \"ra\", \"dec\", \"specz\", \"specz_err\", \"photoz\",\n                   \"photoz_err\", \"separation_arcsec\", \"separation_north_arcsec\", \"separation_east_arcsec\"]\n\n        import collections\n        orderDict = collections.OrderedDict(sorted({}.items()))\n\n        # filter out results greater than the search radius\n        filteredResults = []\n        for row in results:\n            if float(row[\"separation_arcsec\"]) < self.searchRadius:\n                orderDict = collections.OrderedDict(sorted({}.items()))\n                for h in headers:\n                    if h in row.keys():\n                        orderDict[h] = row[h]\n                filteredResults.append(orderDict)\n            else:\n                pass\n\n        if self.nearest and len(filteredResults):\n            orderDict = collections.OrderedDict(sorted({}.items()))\n            for h in headers:\n                if h in filteredResults[0].keys():\n                    orderDict[h] = row[h]\n            filteredResults = [orderDict]\n            # filteredResults = [filteredResults[0]]\n\n        if not len(filteredResults):\n            orderDict = collections.OrderedDict(sorted({}.items()))\n            for h in headers:\n                if self.galaxyType == \"all\" or self.galaxyType == False or (self.galaxyType == \"specz\" and h not in [\"photoz_err\", \"photoz\"]) or (self.galaxyType == \"photoz\" and h not in [\"specz\", \"specz_err\"]):\n                    orderDict[h] = \"\"\n            filteredResults = [orderDict]\n\n        # pretty format print\n        dataSet = list_of_dictionaries(\n            log=self.log,\n            listOfDictionaries=list(reversed(filteredResults))\n        )\n        if self.outputFormat == \"csv\":\n            results = dataSet.csv()\n        else:\n            results = dataSet.table()\n\n        # sdss only allows 60 hits per minute\n        sleep(1)\n\n        self.log.info('completed the ``get`` method')\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving the versions of the project in PyPI by project_name.", "response": "def package_releases(self, project_name):\n        \"\"\" Retrieve the versions from PyPI by ``project_name``.\n\n        Args:\n            project_name (str): The name of the project we wish to retrieve\n                the versions of.\n\n        Returns:\n            list: Of string versions.\n        \"\"\"\n        try:\n            return self._connection.package_releases(project_name)\n        except Exception as err:\n            raise PyPIClientError(err)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the package versions of the available available for the given project.", "response": "def set_package_releases(self, project_name, versions):\n        \"\"\" Storage package information in ``self.packages``\n\n        Args:\n            project_name (str): This will be used as a the key in the\n                dictionary.\n            versions (list): List of ``str`` representing the available\n                versions of a project.\n        \"\"\"\n        self.packages[project_name] = sorted(versions, reverse=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload object by dotted path.", "response": "def load_object(s):\n    \"\"\" Load backend by dotted path.\n    \"\"\"\n    try:\n        m_path, o_name = s.rsplit('.', 1)\n    except ValueError:\n        raise ImportError('Cant import backend from path: {}'.format(s))\n\n    module = import_module(m_path)\n    return getattr(module, o_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nencoding incoming text using encoding.", "response": "def safe_encode(text, incoming=None,\n                encoding='utf-8', errors='strict'):\n    \"\"\"Encodes incoming text/bytes string using `encoding`.\n\n    If incoming is not specified, text is expected to be encoded with\n    current python's default encoding. (`sys.getdefaultencoding`)\n\n    :param incoming: Text's current encoding\n    :param encoding: Expected encoding for text (Default UTF-8)\n    :param errors: Errors handling policy. See here for valid\n        values http://docs.python.org/2/library/codecs.html\n    :returns: text or a bytestring `encoding` encoded\n                representation of it.\n    :raises TypeError: If text is not an instance of str\n    \"\"\"\n    if not isinstance(text, (six.string_types, six.binary_type)):\n        raise TypeError(\"%s can't be encoded\" % type(text))\n\n    if not incoming:\n        incoming = (sys.stdin.encoding or\n                    sys.getdefaultencoding())\n\n    if isinstance(text, six.text_type):\n        return text.encode(encoding, errors)\n    elif text and encoding != incoming:\n        # Decode text before encoding it with `encoding`\n        text = safe_decode(text, incoming, errors)\n        return text.encode(encoding, errors)\n    else:\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_ui_parameters(self):\n        if isinstance(self.PARAMETER_UI_STUFF, dict):\n            for param in self.PARAMETER_UI_STUFF.keys():\n                # check parameter value can be found\n                if not hasattr(self, param) and not hasattr(Task, param):\n                    raise TaskValidationError('task \"{}\" defines parameter \"{}\" but a task attribute with that name '\n                                              'could not be found'.format(self.NAME, param))\n\n                # parameter cannot be None if not explicitly allowed\n                if (getattr(self, param) is None\n                    and (KEY_NONE_ALLOWED not in self.PARAMETER_UI_STUFF[param]\n                         or not self.PARAMETER_UI_STUFF[param][KEY_NONE_ALLOWED])):\n                    raise TaskValidationError('parameter \"{}\" is None and None is not explicitly allowed'\n                                              ''.format(param))", "response": "Checks that the parameters exist in the task and are of the right type."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_pause(self):\n\n        # todo task_runner vs model\n\n        pause_time = 0.0\n        sleep_time = 0.1\n        if self.model.tasks_paused:\n            while self.model.tasks_paused:\n                sleep(pause_time)\n                pause_time += sleep_time\n        return pause_time", "response": "Check if the task was paused for a long running task."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclean the slug of the current instance.", "response": "def clean_slug(self):\n        \"\"\"\n        Save the old slug to be used later in PageAdmin.save_model()\n        to make the slug change propagate down the page tree, and clean\n        leading and trailing slashes which are added on elsewhere.\n        \"\"\"\n        self.instance._old_slug = self.instance.slug\n        new_slug = self.cleaned_data['slug']\n        if not isinstance(self.instance, Link) and new_slug != \"/\":\n            new_slug = clean_slashes(self.cleaned_data['slug'])\n        return new_slug"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the user has permission on the requested page.", "response": "def check_permission(self, request, page, permission):\n        \"\"\"\n        Runs the custom permission check and raises an\n        exception if False.\n        \"\"\"\n        if not getattr(page, \"can_\" + permission)(request):\n            raise PermissionDenied"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nredirects to the add view for the first page model.", "response": "def add_view(self, request, **kwargs):\n        \"\"\"\n        For the ``Page`` model, redirect to the add view for the\n        first page model, based on the ``ADD_PAGE_ORDER`` setting.\n        \"\"\"\n        if self.model is Page:\n            return HttpResponseRedirect(self.get_content_models()[0].add_url)\n        return super(PageAdmin, self).add_view(request, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nenforces custom permissions for the page instance.", "response": "def change_view(self, request, object_id, **kwargs):\n        \"\"\"\n        Enforce custom permissions for the page instance.\n        \"\"\"\n        page = get_object_or_404(Page, pk=object_id)\n        content_model = page.get_content_model()\n\n        kwargs.setdefault(\"extra_context\", {})\n        kwargs[\"extra_context\"].update({\n            \"hide_delete_link\": not content_model.can_delete(request),\n            \"hide_slug_field\": content_model.overridden(),\n        })\n\n        return super(PageAdmin, self).change_view(request, object_id, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_view(self, request, object_id, **kwargs):\n        page = get_object_or_404(Page, pk=object_id)\n        content_model = page.get_content_model()\n        self.check_permission(request, content_model, \"delete\")\n        return super(PageAdmin, self).delete_view(request, object_id, **kwargs)", "response": "Enforces custom delete permissions for the page instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_model(self, request, obj, form, change):\n        if change and obj._old_slug != obj.slug:\n            # _old_slug was set in PageAdminForm.clean_slug().\n            new_slug = obj.slug or obj.generate_unique_slug()\n            obj.slug = obj._old_slug\n            obj.set_slug(new_slug)\n\n        # Force parent to be saved to trigger handling of ordering and slugs.\n        parent = request.GET.get(\"parent\")\n        if parent is not None and not change:\n            obj.parent_id = parent\n            obj.save()\n        super(PageAdmin, self).save_model(request, obj, form, change)", "response": "Override save_model to set the ID of the parent page if passed in via querystring and change the slug."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaintaining the parent ID in the querystring for response_add and response_change.", "response": "def _maintain_parent(self, request, response):\n        \"\"\"\n        Maintain the parent ID in the querystring for response_add and\n        response_change.\n        \"\"\"\n        location = response._headers.get(\"location\")\n        parent = request.GET.get(\"parent\")\n        if parent and location and \"?\" not in location[1]:\n            url = \"%s?parent=%s\" % (location[1], parent)\n            return HttpResponseRedirect(url)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef response_add(self, request, obj):\n        response = super(PageAdmin, self).response_add(request, obj)\n        return self._maintain_parent(request, response)", "response": "Enforces page permissions and maintain the parent ID in the the\n        querystring."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef response_change(self, request, obj):\n        response = super(PageAdmin, self).response_change(request, obj)\n        return self._maintain_parent(request, response)", "response": "Maintain the parent ID in the passed object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns all the content models that are admin registered ordered by the ADD_PAGE_ORDER setting.", "response": "def get_content_models(self):\n        \"\"\"\n        Return all Page subclasses that are admin registered, ordered\n        based on the ``ADD_PAGE_ORDER`` setting.\n        \"\"\"\n        models = super(PageAdmin, self).get_content_models()\n\n        order = [name.lower() for name in settings.ADD_PAGE_ORDER]\n\n        def sort_key(page):\n            name = \"%s.%s\" % (page._meta.app_label, page._meta.object_name)\n            unordered = len(order)\n            try:\n                return (order.index(name.lower()), \"\")\n            except ValueError:\n                return (unordered, page.meta_verbose_name)\n        return sorted(models, key=sort_key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_form(self, request, form, change):\n        obj = form.save(commit=False)\n        if not obj.id and \"in_sitemap\" not in form.fields:\n            obj.in_sitemap = False\n        return super(LinkAdmin, self).save_form(request, form, change)", "response": "Don t show links in the sitemap."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _request_titles_xml() -> ET.ElementTree:\n    response = api.titles_request()\n    return api.unpack_xml(response.text)", "response": "Request AniDB titles file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _unpack_titles(etree: ET.ElementTree) -> 'Generator':\n    for anime in etree.getroot():\n        yield Titles(\n            aid=int(anime.get('aid')),\n            titles=tuple(unpack_anime_title(title) for title in anime),\n        )", "response": "Unpack Titles from titles XML."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting list of Titles.", "response": "def get(self, force=False) -> 'List[Titles]':\n        \"\"\"Get list of Titles.\n\n        Pass force=True to bypass the cache.\n        \"\"\"\n        try:\n            if force:\n                raise CacheMissingError\n            return self._cache.load()\n        except CacheMissingError:\n            titles = self._requester()\n            self._cache.save(titles)\n            return titles"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nuse internally to safely increment `backend`s task count. Returns the overall count of tasks for `backend`.", "response": "def _sending_task(self, backend):\n        \"\"\"\n        Used internally to safely increment `backend`s task count. Returns the \n        overall count of tasks for `backend`.\n        \"\"\"\n        with self.backend_mutex:\n            self.backends[backend] += 1\n            self.task_counter[backend] += 1\n            this_task = self.task_counter[backend]\n        return this_task"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _canceling_task(self, backend):\n        with self.backend_mutex:\n            self.backends[backend] -= 1\n            self.task_counter[backend] -= 1", "response": "Used internally to decrement backend s current and total task counts \n        when the backend is reached."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexpand a host name to a tuple.", "response": "def _expand_host(self, host):\n        \"\"\"\n        Used internally to add the default port to hosts not including \n        portnames.\n        \"\"\"\n        if isinstance(host, basestring):\n            return (host, self.default_port)\n        return tuple(host)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls internally by callback. Does cb and error_cb selection.", "response": "def _do_cb(self, task, cb, error_cb, *args, **kw):\n        \"\"\"\n        Called internally by callback(). Does cb and error_cb selection.\n        \"\"\"\n        try:\n            res = self.work(task, *args, **kw)\n        except BackendProcessingError as e:\n            if error_cb is None:\n                self.log(ERROR, e.__traceback__)\n                show_err()\n            elif error_cb:\n                error_cb(e)\n        else:\n            # Success, let's call away!\n            cb(res)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nusing internally. Simply wraps the arguments up in a list and encodes the list.", "response": "def _package(self, task, *args, **kw):\n        \"\"\"\n        Used internally. Simply wraps the arguments up in a list and encodes \n        the list.\n        \"\"\"\n        # Implementation note: it is faster to use a tuple than a list here, \n        # because json does the list-like check like so (json/encoder.py:424):\n        #   isinstance(o, (list, tuple))\n        # Because of this order, it is actually faster to create a list:\n        #   >>> timeit.timeit('L = [1,2,3]\\nisinstance(L, (list, tuple))')\n        #   0.41077208518981934\n        #   >>> timeit.timeit('L = (1,2,3)\\nisinstance(L, (list, tuple))')\n        #   0.49509215354919434\n        # Whereas if it were the other way around, using a tuple would be \n        # faster:\n        #   >>> timeit.timeit('L = (1,2,3)\\nisinstance(L, (tuple, list))')\n        #   0.3031749725341797\n        #   >>> timeit.timeit('L = [1,2,3]\\nisinstance(L, (tuple, list))')\n        #   0.6147568225860596\n        return self.codec.encode([task, args, kw])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _work(self, backend, package, ident='', log=True):\n        num = self._sending_task(backend)\n        if log:\n            self.log(INFO, 'Starting %s backend task #%s (%s)' % \n                           (backend, num, ident))\n        try:\n            conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            conn.connect(backend)\n            self.send(conn, package)\n            result = self.recv(conn)\n            self.log(DEBUG, result)\n            result = self.codec.decode(result)\n        except Exception as e:\n            self._canceling_task(backend)\n            raise\n        else:\n            self._closing_task(backend)\n            if log:\n                self.log(INFO, 'Finished %s backend task #%s (%s)' % \n                               (backend, num, ident))\n        finally:\n            conn.close()\n        \n        if result[0] == 'error':\n            # We reraise errors in our own way.\n            raise BackendProcessingError(*result[1:])\n        else:\n            return result[1]", "response": "This function is the main worker function."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends the signal to the backend. Raises BackendNotAvailableError if backend is not available.", "response": "def send_signal(self, backend, signal):\n        \"\"\"\n        Sends the `signal` signal to `backend`. Raises ValueError if `backend` \n        is not registered with the client. Returns the result.\n        \"\"\"\n        backend = self._expand_host(backend)\n        if backend in self.backends:\n            try:\n                return self._work(backend, self._package(signal), log=False)\n            except socket.error:\n                raise BackendNotAvailableError\n        else:\n            raise ValueError('No such backend!')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a string of the tasks running on a specific backend.", "response": "def get_tasks(self, backend):\n        \"\"\"\n        Gets a string of the tasks running on `backend`. This string will \n        either be an integer if the backend is up, or else 'down'.Raises \n        ValueError if `backend` is not registered with the client.\n        \n        Example:\n        \n        >>> frontend = FrontEnd(['localhost', '****'])\n        >>> frontend.get_tasks('localhost')\n        '5'\n        >>> frontend.get_tasks('****')\n        'down'\n        >>> frontend.get_tasks('unregistered')\n        Traceback (most recent call last):\n        [...]\n        ValueError: No such backend!\n        \"\"\"\n        try:\n            res = self.send_signal(backend, STATUS)\n        except BackendNotAvailableError:\n            res = 'down'\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a set of backends to the internal dict.", "response": "def add_backends(self, *backends):\n        \"\"\"\n        See the documentation for __init__() to see an explanation of the \n        *backends argument.\n        \"\"\"\n        for backend in backends:\n            full = self._expand_host(backend)\n            self.backends[full] = 0\n            self.task_counter[full] = 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle pushing out the task and getting the response.", "response": "def work(self, task, *args, **kw):\n        \"\"\"\n        Handles pushing out the task and getting the response. Can be called \n        directly to wait for the response.\n        \n        task -- the server-side identifier for the desired task\n        *args and **kw will be passed to the task on the server-side.\n        \n        Return value is generally the same as on the server-side, so if the \n        server has a task for list() named 'list', calling \n          frontend.work('list', '123456')\n        should return\n          ['1', '2', '3', '4', '5', '6']\n        \n        All errors are converted into informational BackendProcessingError()s; \n        for example, following the example above,\n          frontend.work('list', 42)\n        should raise\n          BackendProcessingError('TypeError', [\"'int' object is not iterable\"])\n        Which could then be inspected:\n          >>> e.type\n          'TypeError'\n          >>> e.args\n          [\"'int' object is not iterable\"]\n        \"\"\"\n        package = self._package(task, *args, **kw)\n        backends = sorted(self.backends, key=self._sorter)\n        \n        for backend in backends:\n            try:\n                return self._work(backend, package, task)\n            except socket.error:\n                # We want to just move onto the next backend if we couldn't \n                # connect to this one\n                pass\n        # Didn't not get a backend, let the caller know!\n        raise BackendNotAvailableError"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef callback(self, task, cb, error_cb, *args, **kw):\n        threaded(self._do_cb, (task, cb, error_cb) + args, kw)", "response": "This function runs a callback on success or error."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ignore(self, task, *args, **kw):\n        # We want to silence errors\n        self.callback(task, null_cb, False, *args, **kw)", "response": "Ignore the error from a task."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd the current page to the template context and runs its set_helper method.", "response": "def page(request):\n    \"\"\"\n    Adds the current page to the template context and runs its\n    ``set_helper`` method. This was previously part of\n    ``PageMiddleware``, but moved to a context processor so that\n    we could assign these template context variables without\n    the middleware depending on Django's ``TemplateResponse``.\n    \"\"\"\n    context = {}\n    page = getattr(request, \"page\", None)\n    if isinstance(page, Page):\n        # set_helpers has always expected the current template context,\n        # but here we're just passing in our context dict with enough\n        # variables to satisfy it.\n        context = {\"request\": request, \"page\": page, \"_current_page\": page}\n        page.set_helpers(context)\n    return context"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef config_from_url(u, **kwargs):\n\n    \"\"\"\n    Returns dict containing zmq configuration arguments\n    parsed from xbahn url\n\n    Arguments:\n\n        - u (urlparse.urlparse result)\n\n    Returns:\n\n        dict:\n            - id (str): connection index key\n            - typ_str (str): string representation of zmq socket type\n            - typ (int): zmq socket type (PUB, SUB, REQ, REP, PUSH, PULL)\n            - topic (str): subscription topic\n            - url (str): url to use with zmq's bind function\n    \"\"\"\n\n    path = u.path.lstrip(\"/\").split(\"/\")\n    if len(path) > 2 or not path:\n        raise AssertionError(\"zmq url format: zmq://<host>:<port>/<pub|sub>/<topic>\")\n\n    typ = path[0].upper()\n\n    try:\n        topic = path[1]\n    except IndexError as _:\n        topic = ''\n\n    param = dict(urllib.parse.parse_qsl(u.query))\n\n    #FIXME: should come from schema, maybe zmq+tcp:// ?\n    transport = param.get(\"transport\", \"tcp\")\n\n    _id = \"%s-%s-%s-%s\" % (typ, topic, transport, u.netloc)\n    if kwargs.get(\"prefix\") is not None:\n        _id = \"%s-%s\" % (kwargs.get(\"prefix\"), _id)\n\n    return {\n        \"id\" : _id,\n        \"typ_str\" : typ,\n        \"typ\" : getattr(zmq, typ),\n        \"topic\" : topic,\n        \"transport\" : transport,\n        \"url\" : \"%s://%s\" % (transport, u.netloc)\n    }", "response": "Returns a dictionary containing zmq configuration arguments parsed from xbahn url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrecording the dictionay in the blank attribute based on the list_blank attribute", "response": "def _record_blank(self, current, dict_obj):\n        \"\"\"\n        records the dictionay in the the 'blank' attribute based on the\n        'list_blank' path\n\n        args:\n        -----\n            current: the current dictionay counts\n            dict_obj: the original dictionary object\n        \"\"\"\n        if not self.list_blank:\n            return\n        if self.list_blank not in current:\n            self.blank.append(dict_obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _count_objs(self, obj, path=None, **kwargs):\n        sub_val = None\n        # pdb.set_trace()\n        if isinstance(obj, dict):\n            for key, value in obj.items():\n                if isinstance(value, (list, dict)):\n                    kwargs = self._count_objs(value,\n                                              self.make_path(key, path),\n                                              **kwargs)\n                else:\n                    if self.make_path(key, path) == self.sub_total:\n                        # pdb.set_trace()\n                        sub_val = value\n                    kwargs['current'] = self._increment_prop(key,\n                                                             path,\n                                                             **kwargs)\n        elif isinstance(obj, list):\n            for item in obj:\n                if isinstance(item, (list, dict)):\n                    kwargs = self._count_objs(item, path, **kwargs)\n                else:\n                    if path == self.sub_total:\n                        pdb.set_trace()\n                        sub_val = item\n                    kwargs['current'] = self._increment_prop(path, **kwargs)\n        else:\n            kwargs['current'] = self._increment_prop(path, **kwargs)\n            if path == self.sub_total:\n                pdb.set_trace()\n                sub_val = item\n        if kwargs.get('sub_val') is None:\n            kwargs['sub_val'] = sub_val\n        return kwargs", "response": "Counts the object and adds in count values for current call."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nincrement the property path count", "response": "def _increment_prop(self, prop, path=None, **kwargs):\n        \"\"\"\n        increments the property path count\n\n        args:\n        -----\n            prop: the key for the prop\n            path: the path to the prop\n\n        kwargs:\n        -------\n            current: dictionary count for the current dictionay\n        \"\"\"\n        new_path = self.make_path(prop, path)\n        if self.method == 'simple':\n            counter = kwargs['current']\n        else:\n            counter = self.counts\n        try:\n            counter[new_path] += 1\n        except KeyError:\n            counter[new_path] = 1\n        return counter"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the counts for the class instance based on the current dictionary", "response": "def update_counts(self, current):\n        \"\"\"\n        updates counts for the class instance based on the current dictionary\n        counts\n\n        args:\n        -----\n            current: current dictionary counts\n        \"\"\"\n        for item in current:\n            try:\n                self.counts[item] += 1\n            except KeyError:\n                self.counts[item] = 1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_subtotals(self, current, sub_key):\n\n        if not self.sub_counts.get(sub_key):\n            self.sub_counts[sub_key] = {}\n        for item in current:\n            try:\n                self.sub_counts[sub_key][item] += 1\n            except KeyError:\n                self.sub_counts[sub_key][item] = 1", "response": "Updates the sub_total counts for the class instance based on the current dictionary counts\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint the summray statistics of the current instance of the class.", "response": "def print(self):\n        \"\"\"\n        prints to terminal the summray statistics\n        \"\"\"\n        print(\"TOTALS -------------------------------------------\")\n        print(json.dumps(self.counts, indent=4, sort_keys=True))\n        if self.sub_total:\n            print(\"\\nSUB TOTALS --- based on '%s' ---------\" % self.sub_total)\n            print(json.dumps(self.sub_counts, indent=4, sort_keys=True))\n        if self.list_blank:\n            print(\"\\nMISSING nodes for '%s':\" % self.list_blank,\n                  len(self.blank))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles directives: adds the reference and allocates space for the content", "response": "def handle_directive(self, words):\n\t\t\"\"\"\n\t\thandles directives: adds the reference and allocates space for the content\t\n\t\t\"\"\"\n\t\trefname = words[1]\n\t\tlogging.debug(\"Handling directive \" + str(self.getdirective(words[0])))\n\t\tlogging.debug(\"First argument is \" + str(words[1]))\n\n\t\tif(self.getdirective(words[0]).isstatic()):\n\t\t\tif(refname in self.static_refs):\n\t\t\t\traise ReferenceError(\"[line {}]:{} already defined here (word) {} (line) {}\".format(self.line_count,\n\t\t\t\t\t\t\trefname, self.static_refs[refname][0], self.static_refs[refname][1]))\n\t\t\tself.static_refs[refname] = (self.word_count, self.line_count)\n\t\telse:\n\t\t\tif(refname in self.refs):\n\t\t\t\traise ReferenceError(\"[line {}]:{} already defined here (word) {} (line) {}\".format(self.line_count,\n\t\t\t\t\t\t\trefname, self.refs[refname][0], self.refs[refname][1]))\n\t\t\tself.refs[refname] = (self.word_count, self.line_count)\n\t\tdirective = self.getdirective(words[0])\n\t\tself.word_count += directive.get_word_count(words[2:])\n\t\tlogging.debug(\"Directive allocates {} words.\".format(directive.get_word_count(words[2:])))\n\t\treturn (self.line_count, \"data\", directive, words[2:])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef argument_run(self, sp_r):\n\t\targ_run = []\n\n\t\tfor line in sp_r:\n\t\t\tlogging.debug(\"argument run: handling: \" + str(line))\n\t\t\tif(line[1] == \"data\"):\n\t\t\t\targ_run.append( (line[0], line[1], line[2], line[2].get_words(line[3])))\n\t\t\t\tcontinue\n\t\t\tif(line[1] == \"command\"):\n\t\t\t\tself.checkargs(line[0], line[2], line[3])\n\t\t\t\targ_run.append( (line[0], line[1], line[2], [a for a in self.convert_args(line[2], line[3])]))\n\t\treturn arg_run", "response": "_argument_run converts Arguments according to to_int"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the arguments fit the requirements of the command.", "response": "def checkargs(self, lineno, command, args):\n\t\t\"\"\"\n\t\tCheck if the arguments fit the requirements of the command.\n\n\t\tRaises ArgumentError_, if an argument does not fit.\n\t\t\"\"\"\n\t\tfor wanted, arg in zip(command.argtypes(), args):\n\t\t\twanted = wanted.type_\n\t\t\tif(wanted == \"register\" and (not arg in self.register)):\n\t\t\t\traise ArgumentError(\"[line {}]: Command '{}' wants argument of type register, but {} is not a register\".format(lineno, command.mnemonic(), arg))\n\t\t\tif(wanted == \"const\" and (arg in self.register)):\n\t\t\t\traise ArgumentError(\"[line {}]: Command '{}' wants argument of type const, but {} is a register.\".format(lineno, command.mnemonic(), arg))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef convert_args(self, command, args):\n\n\t\tfor wanted, arg in zip(command.argtypes(), args):\n\t\t\twanted = wanted.type_\n\t\t\tif(wanted == \"const\"):\n\t\t\t\ttry:\n\t\t\t\t\tyield to_int(arg)\n\t\t\t\texcept:\n\t\t\t\t\tif(arg in self.processor.constants):\n\t\t\t\t\t\tyield self.processor.constants[arg]\n\t\t\t\t\telse:\n\t\t\t\t\t\tyield arg\n\t\t\tif(wanted == \"register\"):\n\t\t\t\tyield self.register_indices[arg]", "response": "Convert the arguments of a command into a list of indices and constants."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef program_run(self, der_r):\n\n\t\tprogram = []\n\t\tfor line in der_r:\n\t\t\tprogram.extend(line[2])\n\t\treturn program", "response": "_program_run generates an iterable that can be programmed onto the register machine."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef base_concrete_model(abstract, model):\n    if hasattr(model, 'objects'):\n        # \"model\" is a model class\n        return (model if model._meta.abstract else\n                _base_concrete_model(abstract, model))\n    # \"model\" is a model instance\n    return (\n        _base_concrete_model(abstract, model.__class__) or\n        model.__class__)", "response": "Returns the base concrete model that is abstract or model."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the path to the file that should be uploaded to the specified field.", "response": "def upload_to(field_path, default):\n    \"\"\"\n    Used as the ``upload_to`` arg for file fields - allows for custom\n    handlers to be implemented on a per field basis defined by the\n    ``UPLOAD_TO_HANDLERS`` setting.\n    \"\"\"\n    from yacms.conf import settings\n    for k, v in settings.UPLOAD_TO_HANDLERS.items():\n        if k.lower() == field_path.lower():\n            return import_dotted_path(v)\n    return default"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read(self):\n\t\tself.repr_.setvalue(ord(self.open_stream_in.read(1)))\n\t\treturn self.value.getvalue()", "response": "Read a string from the open_stream_in and convert it to an integer\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading enough bytes from the open_stream_in to fill the width ranks and converts them to an int. Returns self. value.", "response": "def read(self):\n\t\t\"\"\"\n\t\tReads enough bytes from ``open_stream_in`` to fill the ``width`` \n\t\t(if available) and converts them to an ``int``. Returns this ``int``.\n\t\t\"\"\"\n\t\tint_ = bytes_to_int(self.open_stream_in.read(math.ceil(self.width / 8)), self.width)\n\t\tself.repr_.setvalue(int_)\n\t\treturn self.value.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting the given word to the output stream.", "response": "def write(self, word):\n\t\t\"\"\"\n\t\tConverts the ``int`` ``word`` to a ``bytes`` object and writes them to\n\t\t``open_stream_out``.\n\n\t\tSee ``int_to_bytes``.\n\t\t\"\"\"\n\t\tbytes_ = int_to_bytes(word, self.width)\n\t\tself.open_stream_out.write(bytes_)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize a new logging. Logger object.", "response": "def initialize(logger_name=LOGGER_NAME,\n               log_filename=LOG_FILENAME,\n               app_logging_level=APP_LOGGING_LEVEL,\n               dep_logging_level=DEP_LOGGING_LEVEL,\n               format=None,\n               logger_class=None,\n               handlers=[],\n               global_logger=True):\n    \"\"\"\n    Constructs and initializes a `logging.Logger` object.\n\n    Returns :class:`logging.Logger` object.\n\n    :param logger_name: name of the new logger.\n    :param log_filename: The log file location :class:`str` or None.\n    :param app_logging_level: The logging level to use for the application.\n    :param dep_logging_level: The logging level to use for dependencies.\n    :param format: The format string to use :class: `str` or None.\n    :param logger_class: The logger class to use\n    :param handlers: List of handler instances to add.\n    :param global_logger: If true set threepio's global logger variable to this logger.\n    \"\"\"\n    # If there is no format, use a default format.\n    if not format:\n        format = \"%(asctime)s %(name)s-%(levelname)s \"\\\n                 + \"[%(pathname)s %(lineno)d] %(message)s\"\n    formatter = logging.Formatter(format)\n\n    # Setup the root logging for dependencies, etc.\n    if log_filename:\n        logging.basicConfig(\n            level=dep_logging_level,\n            format=format,\n            filename=log_filename,\n            filemode='a+')\n    else:\n        logging.basicConfig(\n            level=dep_logging_level,\n            format=format)\n\n    # Setup and add separate application logging.\n    if logger_class:\n        original_class = logging.getLoggerClass()\n        logging.setLoggerClass(logger_class)\n        new_logger = logging.getLogger(logger_name)\n        logging.setLoggerClass(original_class)\n    else:\n        new_logger = logging.getLogger(logger_name)\n\n    # Set the app logging level.\n    new_logger.setLevel(app_logging_level)  # required to get level to apply.\n\n    # Set the global_logger by default.\n    if global_logger:\n        global logger\n        logger = new_logger\n\n    for handler in handlers:\n        handler.setFormatter(formatter)\n        handler.setLevel(app_logging_level)\n        new_logger.addHandler(handler)\n    return new_logger"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn all GoScale plugins that are on site.", "response": "def get_plugins(sites=None):\n    \"\"\"\n    Returns all GoScale plugins\n\n    It ignored all other django-cms plugins\n    \"\"\"\n    plugins = []\n    # collect GoScale plugins\n    for plugin in CMSPlugin.objects.all():\n        if plugin:\n            cl = plugin.get_plugin_class().model\n            if 'posts' in cl._meta.get_all_field_names():\n                instance = plugin.get_plugin_instance()[0]\n                plugins.append(instance)\n        # Filter by sites\n    if sites and len(sites) > 0:\n        onsite = []\n        for plugin in plugins:\n            try:\n                if plugin.page.site in sites:\n                    onsite.append(plugin)\n            except AttributeError:\n                continue\n        return onsite\n    return plugins"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_plugin(plugin_id):\n    try:\n        instance = CMSPlugin.objects.get(id=plugin_id).get_plugin_instance()[0]\n        instance.update()\n    except:\n        return None, 0\n    return instance, instance.posts.count()", "response": "Updates a single plugin by ID\n    Returns a plugin instance and the number of posts that have been updated"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_show(self, cmd, args):\n        if not args:\n            self.stdout.write(os.getcwd())\n            self.stdout.write('\\n')\n            return\n        fname = args[0]\n        with open(fname, 'r', encoding = 'utf8') as f:\n            self.stdout.write(f.read())\n            self.stdout.write('\\n')", "response": "\\ show - Show the contents of a file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload all installed and supported browsers into BrowserCookies. browsers", "response": "def loadBrowsers():\n        \"\"\" Loads all installed and supported browsers into BrowserCookies.browsers\n        \n        Loops through all classes that subclass BrowserCookies and checks the installed\n        attribute. If the browser is installed, it's instance is loaded into\n        BrowserCookies.browsers in the format of browsers[browser.name] = browser\n        \"\"\"\n        for browser in BrowserCookies.__subclasses__():\n            if browser.installed:\n                BrowserCookies.browsers[browser.name] = browser"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite all given cookies to the given browser", "response": "def setCookies(browser, domain, cookieJar):\n        \"\"\" Writes all given cookies to the given browser\n        \n        Returns:\n           bool - True if successful, false otherwise\n        \"\"\"\n        return BrowserCookies.browsers[browser].writeCookies(domain, cookieJar)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprograms the words in the iterable prog starting with the optional offset.", "response": "def program(self, prog, offset = 0):\n\t\t\"\"\"\n\t\t.. _program:\n\n\t\tWrite the content of the iterable ``prog`` starting with the optional offset ``offset``\n\t\tto the device.\n\n\t\tInvokes program_word_.\n\t\t\"\"\"\n\t\tfor addr, word in enumerate(prog):\n\t\t\tself.program_word(offset + addr, word)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding multiprocessing guards. Forces a connection to be reconnected if it is detected as having been shared to a sub-process.", "response": "def _add_process_guards(self, engine):\n        \"\"\"Add multiprocessing guards.\n\n        Forces a connection to be reconnected if it is detected\n        as having been shared to a sub-process.\n\n        \"\"\"\n\n        @sqlalchemy.event.listens_for(engine, \"connect\")\n        def connect(dbapi_connection, connection_record):\n            connection_record.info['pid'] = os.getpid()\n\n        @sqlalchemy.event.listens_for(engine, \"checkout\")\n        def checkout(dbapi_connection, connection_record, connection_proxy):\n            pid = os.getpid()\n            if connection_record.info['pid'] != pid:\n                self.logger.debug(\n                    \"Parent process %(orig)s forked (%(newproc)s) with an open database connection, \"\n                    \"which is being discarded and recreated.\" % {\"newproc\": pid, \"orig\": connection_record.info['pid']})\n                connection_record.connection = connection_proxy.connection = None\n                raise exc.DisconnectionError(\n                    \"Connection record belongs to pid %s, attempting to check out in pid %s\" % (\n                        connection_record.info['pid'], pid)\n                )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndisplay the current database revision", "response": "def current(self):\n        \"\"\"\n        Display the current database revision\n        \"\"\"\n\n        config = self.alembic_config()\n        script = ScriptDirectory.from_config(config)\n\n        revision = 'base'\n\n        def display_version(rev, context):\n            for rev in script.get_all_current(rev):\n                nonlocal revision\n                revision = rev.cmd_format(False)\n\n            return []\n\n        with EnvironmentContext(config, script, fn=display_version):\n            script.run_env()\n\n        return revision"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef revision(self, message):\n        alembic.command.revision(self.alembic_config(), message=message)", "response": "Create a new revision file for this asset"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cleanup(args):\n    with _catalog(args) as cat:\n        n, d, r = len(cat), [], []\n        for obj in cat:\n            if not obj.bitstreams:\n                if obj.is_special:\n                    print('removing {0} from catalog'.format(obj.id))\n                    r.append(obj)\n                else:\n                    print('deleting {0} from CDSTAR'.format(obj.id))\n                    d.append(obj)\n        for obj in d:\n            cat.delete(obj)\n        for obj in r:\n            cat.remove(obj)\n        args.log.info('{0} objects deleted'.format(n - len(cat)))\n        return n - len(cat)", "response": "Clean up the objects in the sequence of objects in the CDSTAR catalog."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(args):\n    with _catalog(args) as cat:\n        cat.update_metadata(\n            args.args[0], dict([arg.split('=', 1) for arg in args.args[1:]]))", "response": "cdstarcat update OID [ KEY = VALUE ]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsanitize the qualifiers of a base object.", "response": "def sanitize_qualifiers(repos=None, followers=None, language=None):\n    '''\n    qualifiers = c repos:+42 followers:+1000 language:\n    params = {'q': 'tom repos:>42 followers:>1000'}\n    '''\n    qualifiers = ''\n\n    if repos:\n        qualifiers += 'repos:{0} '.format(repos)\n        qualifiers = re.sub(r\"([+])([=a-zA-Z0-9]+)\", r\">\\2\", qualifiers)\n        qualifiers = re.sub(r\"([-])([=a-zA-Z0-9]+)\", r\"<\\2\", qualifiers)\n\n    if followers:\n        qualifiers += 'followers:{0} '.format(followers)\n        qualifiers = re.sub(r\"([+])([=a-zA-Z0-9]+)\", r\">\\2\", qualifiers)\n        qualifiers = re.sub(r\"([-])([=a-zA-Z0-9]+)\", r\"<\\2\", qualifiers)\n\n    try:\n        if language in ALLOWED_LANGUAGES and not language == '':\n            qualifiers += 'language:{0} '.format(language)\n        elif language == '':\n            qualifiers += ''\n        else:\n            raise AllowedLanguagesException\n    except AllowedLanguagesException as e:\n        print(e)\n\n    return qualifiers"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tag(self, *tags):\n        if any([not isinstance(tag, collections.Hashable) for tag in tags]):\n            raise TypeError('Every tag should be hashable')\n\n        if not all(isinstance(tag, collections.Hashable) for tag in tags):\n            raise TypeError('Tags must be hashable')\n        self.tags.update(tags)\n        return self", "response": "Tags the job with one or more unique indentifiers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef at(self, time_str):\n        assert self.unit in ('days', 'hours') or self.start_day\n        hour, minute = time_str.split(':')\n        minute = int(minute)\n        if self.unit == 'days' or self.start_day:\n            hour = int(hour)\n            assert 0 <= hour <= 23\n        elif self.unit == 'hours':\n            hour = 0\n        assert 0 <= minute <= 59\n        self.at_time = datetime.time(hour, minute)\n        return self", "response": "Schedule the job every day at a specific time."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_status(self):\n        # this function should be part of the server\n\n        if (self.status is not None) and self.status > 0:\n            # status is already final\n            return False\n\n        old_status = self.status\n       \n        job_dir = self.run_dir + os.sep + self.id\n\n        if os.path.isfile(run_dir + os.sep + 'FAILURE'):\n            self.status = self.FAILED\n        elif os.path.isfile(run_dir + os.sep + 'FINISHED'):\n            self.status = self.FINISHED\n        else:\n            self.status = self.RUNNING\n\n        if self.status != old_status:\n            return True\n        else:\n            return False", "response": "returns True if status has changed"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if filename is FASTA based on extension Return True if FASTA else False", "response": "def is_fasta(filename):\n    \"\"\"Check if filename is FASTA based on extension\n\n    Return:\n       Boolean\n    \"\"\"\n    if re.search(\"\\.fa*s[ta]*$\", filename, flags=re.I):\n        return True\n    elif re.search(\"\\.fa$\", filename, flags=re.I):\n        return True\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots the individual and the gene", "response": "def plot(self):\n\t\t'''\n\t\tPlot the individual and the gene\n\t\t'''\n\t\tpl.plot(self.x, self.y, '.')\n\t\tpl.plot(self.x_int, self.y_int)\n\t\tpl.grid(True)\n\t\tpl.show()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a random mutation of the gene.", "response": "def mutation(self, strength = 0.1):\n\t\t'''\n\t\tSingle gene mutation\n\t\t'''\n\t\tmutStrengthReal = strength\n\t\tmutMaxSizeReal = self.gLength/2\n\t\tmutSizeReal = int(numpy.random.random_integers(1,mutMaxSizeReal))\n\t\tmutationPosReal = int(numpy.random.random_integers(0+mutSizeReal-1,self.y.shape[0]-1-mutSizeReal))\n\t\tmutationSignReal = pl.rand()\n\t\tmutationReal = pl.rand()\n\n\t\tif mutationSignReal > 0.5:\n\t\t\tfor i in range(-mutSizeReal/2, mutSizeReal/2):\n\t\t\t\tself.y.real[mutationPosReal+i] = self.y.real[mutationPosReal+i] + mutStrengthReal*self.y.real[mutationPosReal+i]*mutationReal\n\t\telse:\n\t\t\tfor i in range(-mutSizeReal/2, mutSizeReal/2):\n\t\t\t\tself.y.real[mutationPosReal+i] = self.y.real[mutationPosReal+i] - mutStrengthReal*self.y.real[mutationPosReal+i]*mutationReal\n\n\t\tself.birth()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd mutations to the gene.", "response": "def mutations(self, nbr, strength):\n\t\t'''\n\t\tMultiple gene mutations\n\t\t'''\n\t\tfor i in range(nbr):\n\t\t\tself.mutation(strength)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef birth(self):\n\t\t'''\n\t\tCreate the individual (compute the spline curve)\n\t\t'''\n\t\tspline = scipy.interpolate.splrep(self.x, self.y)\n\t\tself.y_int = scipy.interpolate.splev(self.x_int,spline)", "response": "compute the spline curve"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mutation(self,strength = 0.1):\n\t\t'''\n\t\tSingle gene mutation - Complex version\n\t\t'''\n\t\t# Mutation du gene - real\n\t\tmutStrengthReal = strength\n\t\tmutMaxSizeReal = self.gLength/2\n\t\tmutSizeReal = int(numpy.random.random_integers(1,mutMaxSizeReal))\n\t\tmutationPosReal = int(numpy.random.random_integers(0+mutSizeReal-1,self.y.shape[0]-1-mutSizeReal))\n\t\tmutationSignReal = pl.rand()\n\t\tmutationReal = pl.rand()\n\n\t\t# Mutation du gene - imag\n\t\tmutStrengthImag = strength\n\t\tmutMaxSizeImag = self.gLength/2\n\t\tmutSizeImag = int(numpy.random.random_integers(1,mutMaxSizeImag))\n\t\tmutationPosImag = int(numpy.random.random_integers(0+mutSizeImag-1,self.y.shape[0]-1-mutSizeImag))\n\t\tmutationSignImag = pl.rand()\n\t\tmutationImag = pl.rand()\n\n\t\tif mutationSignReal > 0.5:\n\t\t\tfor i in range(-mutSizeReal/2, mutSizeReal/2):\n\t\t\t\tself.y.real[mutationPosReal+i] = self.y.real[mutationPosReal+i] + mutStrengthReal*self.y.real[mutationPosReal+i]*mutationReal\n\t\telse:\n\t\t\tfor i in range(-mutSizeReal/2, mutSizeReal/2):\n\t\t\t\tself.y.real[mutationPosReal+i] = self.y.real[mutationPosReal+i] - mutStrengthReal*self.y.real[mutationPosReal+i]*mutationReal\n\n\t\tif mutationSignImag > 0.5:\n\t\t\tfor i in range(-mutSizeImag/2, mutSizeImag/2):\n\t\t\t\tself.y.imag[mutationPosImag+i] = self.y.imag[mutationPosImag+i] + mutStrengthImag*self.y.imag[mutationPosImag+i]*mutationImag\n\t\telse:\n\t\t\tfor i in range(-mutSizeImag/2, mutSizeImag/2):\n\t\t\t\tself.y.imag[mutationPosImag+i] = self.y.imag[mutationPosImag+i] - mutStrengthImag*self.y.imag[mutationPosImag+i]*mutationImag\n\n\t\t# Compute the individual\n\t\tself.birth()", "response": "Generate a random mutation of the gene."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute the spline curve", "response": "def birth(self):\n\t\t'''\n\t\tCreate the individual (compute the spline curve)\n\t\t'''\n\t\tsplineReal = scipy.interpolate.splrep(self.x, self.y.real)\n\t\tself.y_int.real = scipy.interpolate.splev(self.x_int,splineReal)\n\t\tsplineImag = scipy.interpolate.splrep(self.x, self.y.imag)\n\t\tself.y_int.imag = scipy.interpolate.splev(self.x_int,splineImag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the ranking of each individual in the population.", "response": "def rankingEval(self):\n\t\t'''\n\t\tSorting the pop. base on the fitnessEval result\n\t\t'''\n\t\tfitnessAll = numpy.zeros(self.length)\n\t\tfitnessNorm = numpy.zeros(self.length)\n\n\t\tfor i in range(self.length):\n\t\t\tself.Ind[i].fitnessEval()\n\t\t\tfitnessAll[i] = self.Ind[i].fitness\n\n\t\tmaxFitness = fitnessAll.max()\n\t\tfor i in range(self.length):\n\t\t\tfitnessNorm[i] = (maxFitness - fitnessAll[i]) / maxFitness\n\t\tfitnessSorted = fitnessNorm.argsort()\n\n\t\t# Compute the selection probabilities of each individual\n\t\tprobability = numpy.zeros(self.length)\n\t\tS = 2.0\n\t\tfor i in range(self.length):\n\t\t\tprobability[fitnessSorted[i]] = ((2-S)/self.length) + (2*i*(S-1))/(self.length*(self.length-1))\n\t\tself.rankingComputed = 1\n\t\tself.fitness = \tfitnessAll\n\n\t\treturn [fitnessAll, fitnessSorted[::-1], probability]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sortedbyAge(self):\n\t\t'''\n\t\tSorting the pop. base of the age\n\t\t'''\n\t\tageAll = numpy.zeros(self.length)\n\t\tfor i in range(self.length):\n\t\t\tageAll[i] = self.Ind[i].age\n\t\tageSorted = ageAll.argsort()\n\t\treturn ageSorted[::-1]", "response": "sort the pop. base of the age\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef RWSelection(self, mating_pool_size):\n\t\t'''\n\t\tMake Selection of the mating pool with the roulette wheel algorithm\n\t\t'''\n\t\tA = numpy.zeros(self.length)\n\t\tmating_pool = numpy.zeros(mating_pool_size)\n\t\n\t\t[F,S,P] = self.rankingEval()\n\t\t\n\t\tP_Sorted = numpy.zeros(self.length)\n\t\tfor i in range(self.length):\n\t\t\tP_Sorted[i] = P[S[i]]\n\t\n\t\tfor i in range(self.length):\n\t\t\tA[i] = P_Sorted[0:(i+1)].sum()\n\n\t\ti = 0\n\t\tj = 0\n\t\twhile j < mating_pool_size:\n\t\t\tr = numpy.random.random()\n\t\t\ti = 0\n\t\t\twhile A[i] < r:\n\t\t\t\ti += 1\n\t\t\tif numpy.shape(numpy.where(mating_pool==i))[1] == 0:\n\t\t\t\tmating_pool[j] =S[i]\n\t\t\t\tj += 1\n\n\t\treturn mating_pool", "response": "This method returns the Selection of the mating pool with the roulette wheel algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes Selection of the mating pool with the stochastic universal sampling algorithm", "response": "def SUSSelection(self, mating_pool_size):\n\t\t'''\n\t\tMake Selection of the mating pool with the\n\t\tstochastic universal sampling algorithm\n\t\t'''\n\t\tA = numpy.zeros(self.length)\n\t\tmating_pool = numpy.zeros(mating_pool_size)\n\t\tr = numpy.random.random()/float(mating_pool_size)\n\t\t[F,S,P] = self.rankingEval()\n\t\t\n\t\tP_Sorted = numpy.zeros(self.length)\n\t\tfor i in range(self.length):\n\t\t\tP_Sorted[i] = P[S[i]]\n\t\n\t\tfor i in range(self.length):\n\t\t\tA[i] = P_Sorted[0:(i+1)].sum()\n\n\t\ti = 0\n\t\tj = 0\n\t\twhile j < mating_pool_size:\n\t\t\ti = 0\n\t\t\twhile A[i] <= r:\n\t\t\t\ti += 1\n\t\t\tmating_pool[j] = S[i]\n\t\t\tj += 1 \n\t\t\tr += (1/float(mating_pool_size))\n\n\t\treturn mating_pool"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rescale(img, size, mode=None):\n\n    assert size[0] or size[1], \"Must provide a width or a height\"\n\n    size = list(size)\n    crop = size[0] and size[1]\n\n    if not size[0]:\n        size[0] = int(img.size[0] * size[1] / float(img.size[1]))\n    if not size[1]:\n        size[1] = int(img.size[1] * size[0] / float(img.size[0]))\n\n    if crop:\n        b = img.size[0] > img.size[1]\n        crop_size = (img.size[b], int(img.size[b] * size[0] / float(size[1])))\n\n        if mode ==  CROP_TL:\n            img = img.crop((0, 0, crop_size[0], crop_size[1]))\n        elif mode == CROP_BR:\n            img = img.crop((\n                img.size[0] - crop_size[0],\n                img.size[1] - crop_size[1],\n                img.size[0],\n                img.size[1]\n            ))\n\n    return img.resize(size, Image.ANTIALIAS)", "response": "Resizes an image to given size."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_comm(cls, pub):\n        '''\n        Convert communication namedtuple to this class.\n\n        Args:\n            pub (obj): :class:`.Publication` instance which will be converted.\n\n        Returns:\n            obj: :class:`DBPublication` instance.\n        '''\n        filename = None\n        if pub.b64_data:\n            filename = cls._save_to_unique_filename(pub)\n\n        return cls(\n            title=pub.title,\n            author=pub.author,\n            pub_year=pub.pub_year,\n            isbn=pub.isbn,\n            urnnbn=pub.urnnbn,\n            uuid=pub.uuid,\n            aleph_id=pub.aleph_id,\n            producent_id=pub.producent_id,\n            is_public=pub.is_public,\n            filename=pub.filename,\n            is_periodical=pub.is_periodical,\n            path=pub.path,\n\n            file_pointer=filename\n        )", "response": "Convert a communication namedtuple to this class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_comm(self, light_request=False):\n        '''\n        Convert `self` to :class:`.Publication`.\n\n        Returns:\n            obj: :class:`.Publication` instance.\n        '''\n        data = None\n        if not light_request:\n            data = read_as_base64(self.file_pointer)\n\n        return Publication(\n            title=self.title,\n            author=self.author,\n            pub_year=self.pub_year,\n            isbn=self.isbn,\n            urnnbn=self.urnnbn,\n            uuid=self.uuid,\n            aleph_id=self.aleph_id,\n            producent_id=self.producent_id,\n            is_public=self.is_public,\n            filename=self.filename,\n            is_periodical=self.is_periodical,\n            path=self.path,\n\n            b64_data=data,\n            url=self.url,\n            file_pointer=self.file_pointer,\n        )", "response": "Converts self to a Publication object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef loop(self, intro=None):\n        self.fire(\"preloop\")\n        if intro is not None:\n            self.intro = intro\n        if self.intro is not None:\n            self.stdout.write(self.intro + \"\\n\")\n            self.stdout.flush()\n        stop = None\n        while not stop:\n            if self.use_rawinput:\n                try:\n                    line = self.inputter(self.prompt)\n                except EOFError:\n                    line = self._eof\n            else:\n                self.stdout.write(self.prompt)\n                self.stdout.flush()\n                line = self.stdin.readline()\n                if not len(line):\n                    line = self._eof\n                else:\n                    line = line.rstrip(\"\\r\\n\")\n            line = self.fire(\"precmd\", line)\n            stop, results = self.onecmd(line)\n            stop, results = self.fire(\"postcmd\", stop, results, line)\n        self.fire(\"postloop\")", "response": "This is the main loop for the command line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the given string converted to a string that can be used for a clean filename.", "response": "def get_valid_filename(s):\n    \"\"\"\n    Returns the given string converted to a string that can be used for a clean\n    filename. Specifically, leading and trailing spaces are removed; other\n    spaces are converted to underscores; and anything that is not a unicode\n    alphanumeric, dash, underscore, or dot, is removed.\n    >>> get_valid_filename(\"john's portrait in 2004.jpg\")\n    'johns_portrait_in_2004.jpg'\n    \"\"\"\n    s = s.strip().replace(\" \", \"_\")\n    return re.sub(r\"(?u)[^-\\w.]\", \"\", s)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef safe_join(base, *paths):\n    base = base\n    paths = [p for p in paths]\n    final_path = abspath(os.path.join(base, *paths))\n    base_path = abspath(base)\n    base_path_len = len(base_path)\n\n    # Ensure final_path starts with base_path (using normcase to ensure we\n    # don't false-negative on case insensitive operating systems like Windows)\n    # and that the next character after the final path is os.sep (or nothing,\n    # in which case final_path must be equal to base_path).\n    if not os.path.normcase(final_path).startswith(os.path.normcase(base_path)) \\\n       or final_path[base_path_len:base_path_len + 1] not in (\"\", os.path.sep):\n        raise ValueError(\"The joined path (%s) is located outside of the base \"\n                         \"path component (%s)\" % (final_path, base_path))\n    return final_path", "response": "Returns a normalized absolute version of the final path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filepath_to_uri(path):\n    if path is None:\n        return path\n\n    # I know about `os.sep` and `os.altsep` but I want to leave\n    # some flexibility for hardcoding separators.\n    return urllib.quote(path.replace(\"\\\\\", \"/\"), safe=b\"/~!*()'\")", "response": "Converts a file system path to a URI portion that can be used as a base URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self, once=True):\n        print(\"\\n- Actor %s \" % self.name)\n        for m in self.submons:\n            res = m.monitor(once=once)\n            print(\"   |\u00a0Submonitor %s : %s\" % (self.name, res))\n            # print(\"%s %s %s %s lst %s\" % (self.name, m.fid, m.last, m.counter, m.last))\n            self.get_kv().update(KVector.Entry(m.fid, agent=self.name, value=m.last, timestamp=m.counter))\n        res = self.monitor.monitor(once=once)\n        print(\"  Main monitor %s : %s\" % (self.name, res))", "response": "Run main monitor and all submons"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_actors(self, actor):\n        if isinstance(actor, list):\n            self.actors.extend(actor)\n        elif isinstance(actor, Actor):\n            self.actors.append(actor)\n        return self", "response": "Adds an actor to the system s actors\n        list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget an actor by name", "response": "def get_actor(self, name):\n        \"\"\"\n        Get an actor by name\n        :param name: str\n        :return:\n        \"\"\"\n        return next((x for x in self.actors if x.name == name), None)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_monitors(self):\n        submons = []\n        for a in self.actors:\n            # Get all remote formula\n            remotes = a.formula.walk(filter_type=At)\n            # Compute formula hash\n            for f in remotes:\n                f.compute_hash(sid=a.name)\n\n            # Create the global monitor for the actor\n            a.monitor = Dtlmon(a.formula, a.trace)\n\n            # Create the remote sub monitors for each @Formula\n            for f in remotes:\n                remote_actor = self.get_actor(f.agent)\n                remote_actor.submons.append(Dtlmon(formula=f.inner, trace=remote_actor.trace, parent=remote_actor.monitor, fid=f.fid))\n                submons.append({\"fid\": f.fid, \"actor\": remote_actor.name})\n\n            # Create the com entry in the system\n            for a2 in self.actors:\n                self.coms[\"%s->%s\" % (a.name, a2.name)] = []\n                self.coms[\"%s->%s\" % (a2.name, a.name)] = []\n\n        # Create the general KV structure\n        kv = self.kv_implementation()\n        for m in submons:\n            kv.add_entry(self.kv_implementation.Entry(m[\"fid\"], agent=m[\"actor\"], value=Boolean3.Unknown, timestamp=0))\n\n        # Add a copy of KV structure for each actor\n        for a in self.actors:\n            a.monitor.KV = copy.deepcopy(kv)", "response": "Generate monitors for each actor in the system\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning the system :param once :return:", "response": "def run(self, once=True):\n        \"\"\"\n        Run the system\n        :param once\n        :return:\n        \"\"\"\n        print(Color(\"{autored}\\n====== System round %s ======{/red}\" % self.turn))\n        print(Color(\"{autoblue}== Updating actors events...{/blue}\"))\n        # Handling OUT messages\n        for a in self.actors:\n            if self.turn < len(a.events):\n                es = a.events[self.turn]\n                for e in es:\n                    if e.e_type == Actor.Event.EventType.OUT:\n                        # register\n                        # print(\"Sending from %s to %s %s\" % (a.name, e.target, a.get_kv()))\n                        if e.target is \"*\":\n                            print(\"Broadcasting\")\n                            for ac in self.actors:\n                                self.coms[\"%s->%s\" % (a.name, ac.name)].append(copy.deepcopy(a.get_kv()))\n                        else:\n                            self.coms[\"%s->%s\" % (a.name, e.target)].append(copy.deepcopy(a.get_kv()))\n\n        # Handling IN messages\n        for a in self.actors:\n            if self.turn < len(a.events):\n                es = a.events[self.turn]\n                for e in es:\n                    if e.e_type == Actor.Event.EventType.IN:\n                        # Update KV and check pop the send\n                        print(\"%s received a message from %s ...\" % (a.name, e.target))\n                        if len(self.coms[\"%s->%s\" % (e.target, a.name)]) > 0:\n                            a.update_kv(self.coms[\"%s->%s\" % (e.target, a.name)].pop(0))\n                            print(\" - IN %s %s\" % (a.name, a.get_kv()))\n                        else:\n                            print(\" - Error %s trying to receive a message from %s that was not sent by %s\" % (a.name, e.target, e.target))\n\n        print(Color(\"{autoblue}\\n== Running monitors on each actor...{/blue}\"))\n        for a in self.actors:\n            for i in range(a.speed):\n                a.run(once=once)\n        self.turn += 1"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parseJSON(js):\n        decoded = json.JSONDecoder().decode(js)\n        actors = decoded.get(\"actors\")\n        if actors is None:\n            raise Exception(\"No actors found in the system !\")\n        s = System()\n        for a in actors:\n            # Getting actor info\n            a_name = a.get(\"name\")\n            a_formula = a.get(\"formula\")\n            a_trace = a.get(\"trace\")\n            sa_events = a.get(\"events\")\n            a_events = []\n            a_speed = 1 if a.get(\"speed\") is None else int(a[\"speed\"])\n\n            # Parsing actor info\n            for e in sa_events:\n                tmp = e.split(\"|\")\n                tmp2 = []\n                for x in tmp:\n                    tmp2.append(Actor.Event.parse(x))\n                a_events.append(tmp2)\n            a_formula = eval(a_formula)\n            a_trace = Trace.parse(a_trace)\n\n            # Creating the actor\n            actor = Actor(name=a_name, formula=a_formula, trace=a_trace, events=a_events, speed=a_speed)\n\n            # Add actor to the system\n            s.add_actors(actor)\n        s.generate_monitors()\n        return s", "response": "Parses the JSON string and returns a new object with the info."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef data_file(self):\n        path = os.getcwd() + '/' + self.lazy_folder\n        return path + self.data_filename", "response": "Gets the full path to the data file for the current lazy folder."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the full path to the file in which to load the configuration schema.", "response": "def schema_file(self):\n        \"\"\" Gets the full path to the file in which to load configuration schema. \"\"\"\n        path = os.getcwd() + '/' + self.lazy_folder\n        return path + self.schema_filename"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_ignore(self):\n        path = self.lazy_folder + self.ignore_filename\n        \n        # If the file exists, return.\n        if os.path.isfile(os.path.realpath(path)):\n            return None\n\n        sp, sf = os.path.split(self.data_file)\n\n        #Write the file.\n        try:\n            handle = open(path,'w')\n            handle.write(sf + '\\n')\n        except IOError as e:\n            raise e\n\n        # Close the handle and return.\n        handle.close()\n        return None", "response": "Writes a. gitignore file to ignore the generated data file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef choose_schema(self, out_file):\n\n        path = os.path.dirname(lazyconf.__file__) + '/schema/'\n        self.prompt.header('Choose a template for your config file: ')\n\n        i = 0\n        choices = []\n\n        for filename in os.listdir(path):\n            if filename.endswith('.json'):\n                try:\n                    template = self._load(path + filename)\n                    description = template.get('_meta.description')\n                    prompt_string = str(i + 1) + '. ' + filename\n                    i += 1\n\n                    if description:\n                        self.prompt.notice(prompt_string + ': ' + description)\n                    else:\n                        self.prompt.notice(prompt_string)\n\n                    choices.append(template)\n\n                except IOError as e:\n                    print self.prompt.error(str(e))\n\n        val = 0\n        while val is 0 or val > i:\n            val = self.prompt.int('Choice', default = 1)\n            if val is 0 or val > i:\n                self.prompt.error('Please choose a value between 1 and ' + str(i) + '.')\n        \n        schema = choices[val-1]\n        \n        if '_meta' in schema.data.keys():\n            del(schema.data['_meta'])\n        \n        schema.save(out_file, as_schema=True)\n        sp, sf = os.path.split(out_file)\n        self.prompt.success('Saved to ' + self.lazy_folder + sf + '.')\n        return schema", "response": "Find all schema templates and prompts to choose one. Copies the file to self. lazy_folder."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef configure_data(self, data, key_string = ''):\n\n        # If there's no keys in this dictionary, we have nothing to do.\n        if len(data.keys()) == 0:\n            return\n\n        # Split the key string by its dots to find out how deep we are.\n        key_parts = key_string.rsplit('.')\n        prefix = '  ' * (len(key_parts) - 1)\n\n        # Attempt to get a label for this key string.\n        label = self.data.get_label(key_string)\n\n        # If we are have any key string or label, write the header for this section.\n        if label:\n            p = prefix\n            if len(p) > 0:\n                p += ' '\n            self.prompt.header(p + '[' + label + ']')\n\n        # Add to the prefix to indicate options on this level.\n        prefix = prefix + '   '\n\n        # If this section has an '_enabled' key, process it first, as it could enable or disable this whole section.\n        if '_enabled' in data.keys():\n            s = self.data.get_key_string(key_string, '_enabled')\n\n            #Prompt whether to enable this section. Use the existing value as the default.\n            data['_enabled'] = self.prompt.bool(prefix + self.data.get_label(s), None, data['_enabled'])\n\n            # Return if this section is now disabled.\n            if data['_enabled'] is False:\n                return\n\n        # Loop through the rest of the dictionary and prompt for every key. If the value is a dictionary, call this function again for the next level.\n        for k, v in data.iteritems():\n\n            # If we hit the '_enabled' key, we've already processed it (but still need it in the dictionary for saving). Ignore it.\n            if k == '_enabled':\n                continue\n            \n            # Get the type of the value at this key, and the dot-noted format of this key.\n            t = type(v)\n            s = self.data.get_key_string(key_string, k)\n\n            # If the value type is a dictionary, call this function.\n            if t is dict:\n                self.configure_data(v, s)\n\n            # Otherwise, parse the value.\n            else:\n                label = prefix + self.data.get_label(s)\n                self.parse_value(data, label, s, None, v)", "response": "This function will configure the options of the specified key_string in the specified dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_value(self, inner_dict, label, key, value, default):\n        t = type(default)\n\n        if t is dict:\n            return\n    \n        select = self.data.get_select(key)\n        k = key.split('.')[-1]\n\n        if select:\n            inner_dict[k] = self.prompt.select(label, select, value, default = default)\n\n        # If the value type is a boolean, prompt a boolean.\n        elif t is bool:\n            inner_dict[k] = self.prompt.bool(label, value, default = default)\n\n        # If the value is an int, prompt and int.\n        elif t is int:\n            inner_dict[k] = self.prompt.int(label, value, default = default)\n\n        # If someone has put a list in data, we default it to an empty string. If it had come from the schema, it would already be a string.\n        elif t is list:\n            inner_dict[k] = self.prompt.prompt(label + ':', value, default = '')\n\n        # If none of the above are true, it's a string.\n        else:\n            inner_dict[k] = self.prompt.prompt(label + ':', value, default = default)", "response": "Parses a single value and sets it in an inner dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting a single value in a preconfigured data file.", "response": "def set(self, key, value):\n        \"\"\" Sets a single value in a preconfigured data file.\n\n            Arguments:\n            key -- The full dot-notated key to set the value for.\n            value -- The value to set.\n        \"\"\"\n        d = self.data.data\n        keys = key.split('.')\n        latest = keys.pop()\n        for k in keys:\n            d = d.setdefault(k, {})\n\n        schema = Schema().load(self.schema_file)\n\n        self.data.internal = schema.internal\n        self.parse_value(d, '', key, value, schema.get(key))\n        self.data.save(self.data_file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads a data file and sets it to self. data.", "response": "def load(self, data_file = None):\n        \"\"\" Loads a data file and sets it to self.data.\n\n            Arguments:\n            data_file -- The filename to load.\n        \"\"\"\n\n        if not data_file:\n            data_file = ''\n        elif data_file[-1] != '/':\n            data_file += '/'\n\n        if data_file[-6:] != self.lazy_folder:\n            data_file += self.lazy_folder\n        \n        data_file += self.data_filename\n\n        self.data = self._load(data_file)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_for(self, query_type, value):\n        from yacms.twitter.models import Query\n        lookup = {\"type\": query_type, \"value\": value}\n        query, created = Query.objects.get_or_create(**lookup)\n        if created:\n            query.run()\n        elif not query.interested:\n            query.interested = True\n            query.save()\n        return query.tweets.all()", "response": "Get all tweets for a given type and value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getEncodableAttributes(self, obj, **kwargs):\n        attrs = pyamf.ClassAlias.getEncodableAttributes(self, obj, **kwargs)\n\n        if not self.exclude_sa_key:\n            # primary_key_from_instance actually changes obj.__dict__ if\n            # primary key properties do not already exist in obj.__dict__\n            attrs[self.KEY_ATTR] = self.mapper.primary_key_from_instance(obj)\n\n        if not self.exclude_sa_lazy:\n            lazy_attrs = []\n\n            for attr in self.properties:\n                if attr not in obj.__dict__:\n                    lazy_attrs.append(attr)\n\n            attrs[self.LAZY_ATTR] = lazy_attrs\n\n        return attrs", "response": "Returns a dictionary of static and dynamic attributes for the class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef untar(original_tarball, output_directory):\n    if not tarfile.is_tarfile(original_tarball):\n        raise InvalidTarball\n\n    tarball = tarfile.open(original_tarball)\n    # set mtimes of members to now\n    epochsecs = int(time())\n    for member in tarball.getmembers():\n        member.mtime = epochsecs\n    tarball.extractall(output_directory)\n\n    file_list = []\n\n    for extracted_file in tarball.getnames():\n        if extracted_file == '':\n            break\n        if extracted_file.startswith('./'):\n            extracted_file = extracted_file[2:]\n        # ensure we are actually looking at the right file\n        extracted_file = os.path.join(output_directory, extracted_file)\n\n        # Add to full list of extracted files\n        file_list.append(extracted_file)\n\n    return file_list", "response": "Untar given tarball file into directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetecting images and TeX files in a list of files.", "response": "def detect_images_and_tex(\n        file_list,\n        allowed_image_types=('eps', 'png', 'ps', 'jpg', 'pdf'),\n        timeout=20):\n    \"\"\"Detect from a list of files which are TeX or images.\n\n    :param: file_list (list): list of absolute file paths\n    :param: allowed_image_types (list): list of allows image formats\n    :param: timeout (int): the timeout value on shell commands.\n\n    :return: (image_list, tex_file) (([string, string, ...], string)):\n        list of images in the tarball and the name of the TeX file in the\n        tarball.\n    \"\"\"\n    tex_file_extension = 'tex'\n\n    image_list = []\n    might_be_tex = []\n\n    for extracted_file in file_list:\n        # Ignore directories and hidden (metadata) files\n        if os.path.isdir(extracted_file) \\\n           or os.path.basename(extracted_file).startswith('.'):\n            continue\n\n        magic_str = magic.from_file(extracted_file, mime=True)\n\n        if magic_str == \"application/x-tex\":\n            might_be_tex.append(extracted_file)\n        elif magic_str.startswith('image/') \\\n                or magic_str == \"application/postscript\":\n            image_list.append(extracted_file)\n\n        # If neither, maybe it is TeX or an image anyway, otherwise,\n        # we don't care.\n        else:\n            _, dotted_file_extension = os.path.splitext(extracted_file)\n            file_extension = dotted_file_extension[1:]\n\n            if file_extension == tex_file_extension:\n                might_be_tex.append(extracted_file)\n            elif file_extension in allowed_image_types:\n                image_list.append(extracted_file)\n\n    return image_list, might_be_tex"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert images from list of images to given format.", "response": "def convert_images(image_list, image_format=\"png\", timeout=20):\n    \"\"\"Convert images from list of images to given format, if needed.\n\n    Figure out the types of the images that were extracted from\n    the tarball and determine how to convert them into PNG.\n\n    :param: image_list ([string, string, ...]): the list of image files\n        extracted from the tarball in step 1\n    :param: image_format (string): which image format to convert to.\n        (PNG by default)\n    :param: timeout (int): the timeout value on shell commands.\n\n    :return: image_mapping ({new_image: original_image, ...]): The mapping of\n        image files when all have been converted to PNG format.\n    \"\"\"\n    png_output_contains = 'PNG image'\n    image_mapping = {}\n    for image_file in image_list:\n        if os.path.isdir(image_file):\n            continue\n\n        if not os.path.exists(image_file):\n            continue\n\n        cmd_out = check_output(['file', image_file], timeout=timeout)\n        if cmd_out.find(png_output_contains) > -1:\n            # Already PNG\n            image_mapping[image_file] = image_file\n        else:\n            # we're just going to assume that ImageMagick can convert all\n            # the image types that we may be faced with\n            # for sure it can do EPS->PNG and JPG->PNG and PS->PNG\n            # and PSTEX->PNG\n            converted_image_file = get_converted_image_name(image_file)\n            try:\n                convert_image(image_file, converted_image_file, image_format)\n            except (MissingDelegateError, ResourceLimitError):\n                # Too bad, cannot convert image format.\n                continue\n            if os.path.exists(converted_image_file):\n                image_mapping[converted_image_file] = image_file\n\n    return image_mapping"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convert_image(from_file, to_file, image_format):\n    with Image(filename=from_file) as original:\n        with original.convert(image_format) as converted:\n            converted.save(filename=to_file)\n    return to_file", "response": "Convert an image from given format to given format."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rotate_image(filename, line, sdir, image_list):\n    file_loc = get_image_location(filename, sdir, image_list)\n    degrees = re.findall('(angle=[-\\\\d]+|rotate=[-\\\\d]+)', line)\n\n    if len(degrees) < 1:\n        return False\n\n    degrees = degrees[0].split('=')[-1].strip()\n\n    if file_loc is None or file_loc == 'ERROR' or\\\n            not re.match('-*\\\\d+', degrees):\n        return False\n\n    if degrees:\n        try:\n            degrees = int(degrees)\n        except (ValueError, TypeError):\n            return False\n\n        if not os.path.exists(file_loc):\n            return False\n\n        with Image(filename=file_loc) as image:\n            with image.clone() as rotated:\n                rotated.rotate(degrees)\n                rotated.save(filename=file_loc)\n        return True\n    return False", "response": "Rotate a image.\n\n    Given a filename and a line, figure out what it is that the author\n    wanted to do wrt changing the rotation of the image and convert the\n    file so that this rotation is reflected in its presentation.\n\n    :param: filename (string): the name of the file as specified in the TeX\n    :param: line (string): the line where the rotate command was found\n\n    :output: the image file rotated in accordance with the rotate command\n    :return: True if something was rotated"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_by_owner(cls, owner):\n        return cls.query(cls.owner==cls._get_key(owner))", "response": "get all entities owned by specified owner"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclean the data and throws ValidationError on failure", "response": "def clean(self):\n        \"\"\" Cleans the data and throws ValidationError on failure \"\"\"\n        errors = {}\n        cleaned = {}\n\n        for name, validator in self.validate_schema.items():\n            val = getattr(self, name, None)\n            try:\n                cleaned[name] = validator.to_python(val)\n            except formencode.api.Invalid, err:\n                errors[name] = err\n\n        if errors:\n            raise ValidationError('Invalid data', errors)\n        return cleaned"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds all keyword arguments to self. args", "response": "def set_defaults(self, **defaults):\n        \"\"\"\n        Add all keyword arguments to self.args\n\n        args:\n            **defaults:\n                key and value represents dictionary key and value\n        \"\"\"\n        try:\n            defaults_items = defaults.iteritems()\n        except AttributeError:\n            defaults_items = defaults.items()\n        for key, val in defaults_items:\n            if key not in self.args.keys():\n                self.args[key] = val"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_args(self, **kwargs):\n        try:\n            kwargs_items = kwargs.iteritems()\n        except AttributeError:\n            kwargs_items = kwargs.items()\n        for key, val in kwargs_items:\n            self.args[key] = val", "response": "Set more arguments to self. args\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking all the variables needed are defined in the class attribute.", "response": "def check_important_variables(self):\n        \"\"\"\n        Check all the variables needed are defined\n        \"\"\"\n        if len(self.important_variables - set(self.args.keys())):\n            raise TypeError(\"Some important variables are not set\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_rmse(self, data_x=None, data_y=None):\n        if data_x is None:\n            data_x = np.array(self.args[\"x\"])\n        if data_y is None:\n            data_y = np.array(self.args[\"y\"])\n        if len(data_x) != len(data_y):\n            raise ValueError(\"Lengths of data_x and data_y are different\")\n        rmse_y = self.bestfit_func(data_x)\n        return np.sqrt(np.mean((rmse_y - data_y) ** 2))", "response": "Get Root Mean Square Error using self. bestfit_func\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting Mean Absolute Error using self. bestfit_func args", "response": "def get_mae(self, data_x=None, data_y=None):\n        \"\"\"\n        Get Mean Absolute Error using\n        self.bestfit_func\n\n        args:\n            data_x: array_like, default=x\n                x value used to determine rmse, used if only a section\n                of x is to be calculated\n            data_y: array_like, default=y\n                y value used to determine rmse, used if only a section\n                of y is to be calculated\n        \"\"\"\n        if data_x is None:\n            data_x = np.array(self.args[\"x\"])\n        if data_y is None:\n            data_y = np.array(self.args[\"y\"])\n        if len(data_x) != len(data_y):\n            raise ValueError(\"Lengths of data_x and data_y are different\")\n        mae_y = self.bestfit_func(data_x)\n        return np.mean(abs(mae_y - data_y))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _backup_bytes(target, offset, length):\n    click.echo('Backup {l} byes at position {offset} on file {file} to .bytes_backup'.format(\n        l=length, offset=offset, file=target))\n\n    with open(target, 'r+b') as f:\n        f.seek(offset)\n\n        with open(target + '.bytes_backup', 'w+b') as b:\n            for _ in xrange(length):\n                byte = f.read(1)\n                b.write(byte)\n            b.flush()\n\n        f.flush()", "response": "Read and write bytes from one file and write them to a\nTaxonomy file with the. bytes_backup suffix"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _smudge_bytes(target, offset, magic_bytes):\n    click.echo('Writing {c} magic byes at position {offset} on file {file}'.format(\n        c=len(magic_bytes), offset=offset, file=target))\n\n    with open(target, 'r+b') as f:\n        f.seek(offset)\n        f.write(magic_bytes)\n        f.flush()\n\n    click.echo('Changes written')", "response": "Write magic bytes to a file relative from a file offset"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsmudge magic bytes with a known type", "response": "def smudge(newtype, target):\n    \"\"\"\n        Smudge magic bytes with a known type\n    \"\"\"\n\n    db = smudge_db.get()\n\n    magic_bytes = db[newtype]['magic']\n    magic_offset = db[newtype]['offset']\n\n    _backup_bytes(target, magic_offset, len(magic_bytes))\n    _smudge_bytes(target, magic_offset, magic_bytes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef smudgeraw(target, offset, magicbytes):\n    magicbytes = magicbytes.replace('\\\\x', '').decode('hex')\n\n    _backup_bytes(target, offset, len(magicbytes))\n    _smudge_bytes(target, offset, magicbytes)", "response": "Smudge magic bytes with raw bytes\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrestores a smudged file from. bytes_backup", "response": "def restore(source, offset):\n    \"\"\"\n        Restore a smudged file from .bytes_backup\n    \"\"\"\n    backup_location = os.path.join(\n        os.path.dirname(os.path.abspath(source)), source + '.bytes_backup')\n    click.echo('Reading backup from: {location}'.format(location=backup_location))\n\n    if not os.path.isfile(backup_location):\n        click.echo('No backup found for: {source}'.format(source=source))\n        return\n\n    with open(backup_location, 'r+b') as b:\n        data = b.read()\n\n    click.echo('Restoring {c} bytes from offset {o}'.format(c=len(data), o=offset))\n    with open(source, 'r+b') as f:\n        f.seek(offset)\n        f.write(data)\n        f.flush()\n\n    click.echo('Changes written')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists available types for smudge", "response": "def available():\n    \"\"\"\n        List available types for 'smudge'\n    \"\"\"\n\n    db = smudge_db.get()\n\n    click.echo('{:<6} {:<6} {:<50}'.format('Type', 'Offset', 'Magic'))\n    for k, v in db.items():\n        click.echo('{type:<6} {offset:<6} {magic}'.format(\n            type=k, magic=v['magic'].encode('hex'), offset=v['offset']))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets upcoming releases for this product.", "response": "def upcoming_releases(self, product):\n        \"\"\"\n        Get upcoming releases for this product.\n\n        Specifically we search for releases with a GA date greater-than or\n        equal to today's date.\n\n        :param product: str, eg. \"ceph\"\n        :returns: deferred that when fired returns a list of Munch (dict-like)\n                  objects representing all releases, sorted by shortname.\n        \"\"\"\n        url = 'api/v6/releases/'\n        url = url + '?product__shortname=' + product\n        url = url + '&ga_date__gte=' + date.today().strftime('%Y-%m-%d')\n        url = url + '&ordering=shortname_sort'\n        releases = yield self._get(url)\n        result = munchify(releases)\n        defer.returnValue(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the shortname of the newest upcoming release for a product.", "response": "def newest_release(self, product):\n        \"\"\"\n        Get the shortname of the newest upcoming release for a product.\n\n        :param product: str, eg. \"ceph\"\n        :returns: deferred that when fired returns the shortname of the newest\n                  release.\n        \"\"\"\n        releases = yield self.upcoming_releases(product)\n        if not releases:\n            raise ProductPagesException('no upcoming releases')\n        defer.returnValue(releases[0].shortname)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a human - friendly URL for this product.", "response": "def product_url(self, product):\n        \"\"\"\n        Return a human-friendly URL for this product.\n\n        :param product: str, eg. \"ceph\"\n        :returns: str, URL\n        \"\"\"\n        url = 'product/%s' % product\n        return posixpath.join(self.url, url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef release(self, shortname):\n        url = 'api/v6/releases/?shortname=%s' % shortname\n        releases = yield self._get(url)\n        # Note, even if this shortname does not exist, _get() will not errback\n        # for this url. It simply returns an empty list. So check that here:\n        if not releases:\n            raise ReleaseNotFoundException('no release %s' % shortname)\n        release = Release.fromDict(releases[0])\n        release.connection = self\n        defer.returnValue(release)", "response": "Get a specific release by its shortname."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a human - friendly URL for this release.", "response": "def schedule_url(self, release):\n        \"\"\"\n        Return a human-friendly URL for this release.\n\n        :param release: str, release shortname eg. \"ceph-3-0\"\n        :returns: str, URL\n        \"\"\"\n        product, _ = release.split('-', 1)\n        url = 'product/%s/release/%s/schedule/tasks' % (product, release)\n        return posixpath.join(self.url, url)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a JSON API endpoint and return the parsed data.", "response": "def _get(self, url, headers={}):\n        \"\"\" Get a JSON API endpoint and return the parsed data.\n\n        :param url: str, *relative* URL (relative to pp-admin/ api endpoint)\n        :param headers: dict (optional)\n        :returns: deferred that when fired returns the parsed data from JSON\n                  or errbacks with ProductPagesException\n        \"\"\"\n        # print('getting %s' % url)\n        headers = headers.copy()\n        headers['Accept'] = 'application/json'\n        url = posixpath.join(self.url, url)\n        try:\n            response = yield treq.get(url, headers=headers, timeout=5)\n            if response.code != 200:\n                err = '%s returned %s' % (url, response.code)\n                raise ProductPagesException(err)\n            else:\n                content = yield treq.json_content(response)\n                defer.returnValue(content)\n        except Exception as e:\n            # For example, if treq.get() timed out, or if treq.json_content()\n            # could not parse the JSON, etc.\n            # TODO: better handling here for the specific errors?\n            # I suspect it's not good to catch Exception with inlineCallbacks\n            raise ProductPagesException('treq error: %s' % e.message)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_timestamp(d):\n    if isinstance(d, datetime.date) and not isinstance(d, datetime.datetime):\n        d = datetime.datetime.combine(d, datetime.time(0, 0, 0, 0))\n\n    msec = str(d.microsecond).rjust(6).replace(' ', '0')\n\n    return float('%s.%s' % (calendar.timegm(d.utctimetuple()), msec))", "response": "Returns a UTC timestamp for a C { datetime. datetime object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_datetime(secs):\n    if negative_timestamp_broken and secs < 0:\n        return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=secs)\n\n    return datetime.datetime.utcfromtimestamp(secs)", "response": "Return a UTC date from a timestamp."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of properties for the object", "response": "def get_properties(obj):\n    \"\"\"\n    Returns a list of properties for L{obj}\n\n    @since: 0.5\n    \"\"\"\n    if hasattr(obj, 'keys'):\n        return obj.keys()\n    elif hasattr(obj, '__dict__'):\n        return obj.__dict__.keys()\n\n    return []"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_attrs(obj, attrs):\n    o = setattr\n\n    if hasattr(obj, '__setitem__'):\n        o = type(obj).__setitem__\n\n    [o(obj, k, v) for k, v in attrs.iteritems()]", "response": "Applies a collection of attributes C{attrs to object C{obj in the most\n    generic way possible."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntrying to find a suitable L { pyamf. ClassAlias subclass for the given class.", "response": "def get_class_alias(klass):\n    \"\"\"\n    Tries to find a suitable L{pyamf.ClassAlias} subclass for C{klass}.\n    \"\"\"\n    for k, v in pyamf.ALIAS_TYPES.iteritems():\n        for kl in v:\n            try:\n                if issubclass(klass, kl):\n                    return k\n            except TypeError:\n                # not a class\n                if hasattr(kl, '__call__'):\n                    if kl(klass) is True:\n                        return k"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_class_sealed(klass):\n    mro = inspect.getmro(klass)\n    new = False\n\n    if mro[-1] is object:\n        mro = mro[:-1]\n        new = True\n\n    for kls in mro:\n        if new and '__dict__' in kls.__dict__:\n            return False\n\n        if not hasattr(kls, '__slots__'):\n            return False\n\n    return True", "response": "Returns True if the supplied class is sealed."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_class_meta(klass):\n    if not isinstance(klass, python.class_types) or klass is object:\n        raise TypeError('klass must be a class object, got %r' % type(klass))\n\n    meta = {\n        'static_attrs': None,\n        'exclude_attrs': None,\n        'readonly_attrs': None,\n        'proxy_attrs': None,\n        'amf3': None,\n        'dynamic': None,\n        'alias': None,\n        'external': None,\n        'synonym_attrs': None\n    }\n\n    if not hasattr(klass, '__amf__'):\n        return meta\n\n    a = klass.__amf__\n\n    if type(a) is dict:\n        in_func = lambda x: x in a\n        get_func = a.__getitem__\n    else:\n        in_func = lambda x: hasattr(a, x)\n        get_func = lambda x: getattr(a, x)\n\n    for prop in ['alias', 'amf3', 'dynamic', 'external']:\n        if in_func(prop):\n            meta[prop] = get_func(prop)\n\n    for prop in ['static', 'exclude', 'readonly', 'proxy', 'synonym']:\n        if in_func(prop):\n            meta[prop + '_attrs'] = get_func(prop)\n\n    return meta", "response": "Returns a C { dict} containing meta data based on the supplied class useful\n    for class aliasing."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading and return a module based on mod_name.", "response": "def get_module(mod_name):\n    \"\"\"\n    Load and return a module based on C{mod_name}.\n    \"\"\"\n    if mod_name is '':\n        raise ImportError('Unable to import empty module')\n\n    mod = __import__(mod_name)\n    components = mod_name.split('.')\n\n    for comp in components[1:]:\n        mod = getattr(mod, comp)\n\n    return mod"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lower_underscore(string, prefix='', suffix=''):\n\n    return require_valid(append_underscore_if_keyword('_'.join(\n        word.lower()\n        for word in en.words(' '.join([prefix, string, suffix])))\n    ))", "response": "Generate an underscore - separated lower - case identifier given an English text prefix and optional suffix."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef upper_underscore(string, prefix='', suffix=''):\n\n    return require_valid(append_underscore_if_keyword('_'.join(\n        word.upper()\n        for word in en.words(' '.join([prefix, string, suffix])))\n    ))", "response": "Generate an underscore - separated upper - case identifier."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef upper_camel(string, prefix='', suffix=''):\n\n    return require_valid(append_underscore_if_keyword(''.join(\n        upper_case_first_char(word)\n        for word in en.words(' '.join([prefix, string, suffix])))\n    ))", "response": "Generate a camel - case identifier with the first word capitalised."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lower_camel(string, prefix='', suffix=''):\n\n    return require_valid(append_underscore_if_keyword(''.join(\n        word.lower() if index == 0 else upper_case_first_char(word)\n        for index, word in enumerate(en.words(' '.join([prefix, string, suffix]))))\n    ))", "response": "Generate a camel - case identifier."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_valid(identifier):\n\n    return (\n        isinstance(identifier, six.string_types)\n        and bool(NAME_RE.search(identifier))\n        and not keyword.iskeyword(identifier)\n    )", "response": "Check if the identifier is valid for Python."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn receiver instance from connection url string kwargs", "response": "def receiver(url, **kwargs):\n    \"\"\"\n    Return receiver instance from connection url string\n\n    url <str> connection url eg. 'tcp://0.0.0.0:8080'\n    \"\"\"\n    res = url_to_resources(url)\n    fnc = res[\"receiver\"]\n    return fnc(res.get(\"url\"), **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sender(url, **kwargs):\n\n    res = url_to_resources(url)\n    fnc = res[\"sender\"]\n    return fnc(res.get(\"url\"), **kwargs)", "response": "Returns sender instance from connection url string kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbinds and return a connection instance from url", "response": "def listen(url, prefix=None, **kwargs):\n    \"\"\"\n    bind and return a connection instance from url\n\n    arguments:\n        - url (str): xbahn connection url\n    \"\"\"\n    return listener(url, prefix=get_prefix(prefix), **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(url, prefix=None, **kwargs):\n    return connection(url, prefix=get_prefix(prefix), **kwargs)", "response": "Connect and return a connection instance from url\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_data(self, message):\n\n        \"\"\"\n        make data string from message according to transport_content_type\n\n        Returns:\n\n            str: message data\n        \"\"\"\n\n        if not isinstance(message, Message):\n            return message\n        return message.export(self.transport_content_type)", "response": "make data string from message according to transport_content_type"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_message(self, data):\n\n        \"\"\"\n        Create a Message instance from data, data will be loaded\n        via munge according to the codec specified in the\n        transport_content_type attribute\n\n        Returns:\n\n            Message: message object\n        \"\"\"\n\n        data = self.codec.loads(data)\n        msg = Message(\n            data.get(\"data\"),\n            *data.get(\"args\",[]),\n            **data.get(\"kwargs\",{})\n        )\n        msg.meta.update(data.get(\"meta\"))\n        self.trigger(\"make_message\", data, msg)\n        return msg", "response": "Create a Message instance from data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates and return a message from data", "response": "def receive(self, data):\n        \"\"\"\n        Create and return a message from data, also triggers the\n        **receive** event\n\n        Returns:\n\n            - Message: message object\n        \"\"\"\n        self.log_debug(\"Received: %s\" % (data))\n        message =  self.make_message(data)\n        self.trigger(\"receive\", data=data, message=message)\n        return message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if user has permission to use docker.", "response": "def check_permissions():\n    \"\"\"\n    Checks if current user can access docker\n    \"\"\"\n    if (\n        not grp.getgrnam('docker').gr_gid in os.getgroups()\n        and not os.geteuid() == 0\n    ):\n        exitStr = \"\"\"\n        User doesn't have permission to use docker.\n        You can do either of the following,\n        1. Add user to the 'docker' group (preferred)\n        2. Run command as superuser using either 'sudo' or 'su -c'\n        \"\"\"\n        exit(exitStr)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding the base image", "response": "def build_base_image_cmd(self, force):\n        \"\"\"\n        Build the glusterbase image\n        \"\"\"\n        check_permissions()\n\n        basetag = self.conf.basetag\n        basedir = self.conf.basedir\n        verbose = self.conf.verbose\n\n        if self.image_exists(tag=basetag):\n            if not force:\n                echo(\"Image with tag '{0}' already exists\".format(basetag))\n                return self.image_by_tag(basetag)\n            else:\n                self.remove_image(basetag)\n        echo(\"Building base image\")\n        stream = self.build(path=basedir, rm=True, tag=basetag)\n        err = self.__handle_build_stream(stream, verbose)\n        if err:\n            echo(\"Building base image failed with following error:\")\n            echo(err)\n            return None\n\n        image = self.image_by_tag(basetag)\n        echo(\"Built base image {0} (Id: {1})\".format(basetag, image['Id']))\n        return image"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild the main image", "response": "def build_main_image_cmd(self, srcdir, force):\n        \"\"\"\n        Build the main image to be used for launching containers\n        \"\"\"\n        check_permissions()\n\n        basetag = self.conf.basetag\n        basedir = self.conf.basedir\n        maintag = self.conf.maintag\n\n        if not self.image_exists(tag=basetag):\n            if not force:\n                exit(\"Base image with tag {0} does not exist\".format(basetag))\n            else:\n                echo(\"FORCE given. Forcefully building the base image.\")\n                self.build_base_image_cmd(force)\n\n        if self.image_exists(tag=maintag):\n            self.remove_image(tag=maintag)\n\n        build_command = \"/build/make-install-gluster.sh\"\n        container = self.create_container(image=basetag, command=build_command,\n                                          volumes=[\"/build\", \"/src\"])\n\n        self.start(container, binds={basedir: \"/build\", srcdir: \"/src\"})\n        echo('Building main image')\n        while self.inspect_container(container)[\"State\"][\"Running\"]:\n            time.sleep(5)\n\n        if not self.inspect_container(container)[\"State\"][\"ExitCode\"] == 0:\n            echo(\"Build failed\")\n            echo(\"Dumping logs\")\n            echo(self.logs(container))\n            exit()\n\n        # The docker remote api expects the repository and tag to be seperate\n        # items for commit\n        repo = maintag.split(':')[0]\n        tag = maintag.split(':')[1]\n        image = self.commit(container['Id'], repository=repo, tag=tag)\n        echo(\"Built main image {0} (Id: {1})\".format(maintag, image['Id']))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlaunches n docker containers using the main image", "response": "def launch_cmd(self, n, force):\n        \"\"\"\n        Launch the specified docker containers using the main image\n        \"\"\"\n        check_permissions()\n\n        prefix = self.conf.prefix\n        maintag = self.conf.maintag\n\n        commandStr = \"supervisord -c /etc/supervisor/conf.d/supervisord.conf\"\n\n        for i in range(1, n+1):\n            cName = \"{0}-{1}\".format(prefix, i)\n\n            if self.container_exists(name=cName):\n                if not force:\n                    exit(\"Container with name {0} already \"\n                         \"exists.\".format(cName))\n                else:\n                    if self.container_running(name=cName):\n                        self.stop(cName)\n                    self.remove_container(cName, v=True)\n\n            c = self.create_container(image=maintag, name=cName,\n                                      command=commandStr, volumes=[\"/bricks\"])\n            self.start(c['Id'], privileged=True)\n            time.sleep(2)  # Wait for container to startup\n\n            echo(\"Launched {0} (Id: {1})\".format(cName, c['Id']))\n            c = None\n            cName = None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stop_cmd(self, name, force):\n        check_permissions()\n\n        if name:\n            echo(\"Would stop container {0}\".format(name))\n        else:\n            echo(\"Would stop all containers\")\n        echo(\"For now use 'docker stop' to stop the containers\")", "response": "Stop the specified docker containers"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ssh_cmd(self, name, ssh_command):\n        if not self.container_exists(name=name):\n            exit(\"Unknown container {0}\".format(name))\n\n        if not self.container_running(name=name):\n            exit(\"Container {0} is not running\".format(name))\n\n        ip = self.get_container_ip(name)\n        if not ip:\n            exit(\"Failed to get network address for \"\n                 \"container {0}\".format(name))\n        if ssh_command:\n            ssh.do_cmd('root', ip, 'password', \" \".join(ssh_command))\n        else:\n            ssh.launch_shell('root', ip, 'password')", "response": "SSH into given container and executre command if given\n clf is set"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ip_cmd(self, name):\n        if not self.container_exists(name=name):\n            exit('Unknown container {0}'.format(name))\n\n        ip = self.get_container_ip(name)\n        if not ip:\n            exit(\"Failed to get network address for\"\n                 \" container {0}\".format(name))\n        else:\n            echo(ip)", "response": "Print ip of given container"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pack(self, message_type, client_id, client_storage, args, kwargs):\n        return pickle.dumps(\n            (message_type, client_id, client_storage, args, kwargs), protocol=2)", "response": "Packs a message into a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dispatch_message(self, message_type, client_id, client_storage, args, kwargs):\n        logger.debug(\"Backend message ({message_type}) : {args} {kwargs}\".format(\n            message_type=dict(MESSAGES_TYPES)[message_type], args=args, kwargs=kwargs))\n\n        if message_type in [ON_OPEN, ON_CLOSE, ON_RECEIVE]:\n            # Find if client exists in clients_list\n            client = next(\n                (c for c in self.factory.clients_list if c._client_id == client_id), None)\n\n            # Create a fake client if it doesn't exists\n            if not client:\n                client = FakeClient(storage=client_storage, factory=self.factory)\n\n        if message_type == ON_OPEN:\n            reactor.callInThread(\n                self.factory.mease.call_openers, client, self.factory.clients_list)\n\n        elif message_type == ON_CLOSE:\n            reactor.callInThread(\n                self.factory.mease.call_closers, client, self.factory.clients_list)\n\n        elif message_type == ON_RECEIVE:\n            reactor.callInThread(\n                self.factory.mease.call_receivers,\n                client,\n                self.factory.clients_list,\n                kwargs.get('message', ''))\n\n        elif message_type == ON_SEND:\n            routing = kwargs.pop('routing')\n\n            reactor.callInThread(\n                self.factory.mease.call_senders,\n                routing,\n                self.factory.clients_list,\n                *args,\n                **kwargs)", "response": "Dispatches a message from the client to the client storage."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _loop(self, *args, **kwargs):\n        self.on_start(*self.on_start_args, **self.on_start_kwargs)\n        try:\n            while not self._stop_signal:\n                self.target(*args, **kwargs)\n        finally:\n            self.on_stop(*self.on_stop_args, **self.on_stop_kwargs)\n            self._stop_signal = False\n            self._lock.set()", "response": "Loops the target function\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstarting the loop Tries to start the loop. Raises RuntimeError if the loop is currently running. :param subthread: True/False value that specifies whether or not to start the loop within a subthread. If True the threading.Thread object is found in Loop._loop_thread.", "response": "def start(self, subthread=True):\n        \"\"\"Starts the loop\n\n        Tries to start the loop. Raises RuntimeError if the loop is currently running.\n\n        :param subthread: True/False value that specifies whether or not to start the loop within a subthread. If True\n        the threading.Thread object is found in Loop._loop_thread.\n        \"\"\"\n        if self.is_running():\n            raise RuntimeError('Loop is currently running')\n        else:\n            self._lock.clear()\n            self._stop_signal = False  # just in case\n            self._in_subthread = subthread\n            if subthread:\n                self._loop_thread = threading.Thread(target=self._loop,\n                                                     args=self.args,\n                                                     kwargs=self.kwargs)\n                self._loop_thread.start()\n            else:\n                self._loop(*self.args, **self.kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stop(self, silent=False):\n        self.send_stop_signal(silent)\n        self._lock.wait()", "response": "Sends a stop signal to the loop thread and waits until it stops"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_stop_signal(self, silent=False):\n        if self.is_running():\n            self._stop_signal = True\n        elif not silent:\n            raise RuntimeError('Loop is currently not running')", "response": "Sends a stop signal to the loop thread\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrestart the loop function with the current thread.", "response": "def restart(self, subthread=None):\n        \"\"\"Restarts the loop function\n\n        Tries to restart the loop thread using the current thread. Raises RuntimeError if a previous call to Loop.start\n        was not made.\n\n        :param subthread: True/False value used when calling Loop.start(subthread=subthread). If set to None it uses the\n        same value as the last call to Loop.start.\n        \"\"\"\n        if self._in_subthread is None:\n            raise RuntimeError('A call to start must first be placed before restart')\n        self.stop(silent=True)\n        if subthread is None:\n            subthread = self._in_subthread\n        self.__init__(self.target, self.args, self.kwargs, self.on_stop)\n        self.start(subthread=subthread)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a property class from the given property definitions.", "response": "def make_property(prop_defs, prop_name, cls_names=[], hierarchy=[]):\n    \"\"\" Generates a property class from the defintion dictionary\n\n    args:\n        prop_defs: the dictionary defining the property\n        prop_name: the base name of the property\n        cls_name: the name of the rdf_class with which the property is\n                  associated\n    \"\"\"\n    register = False\n    try:\n        cls_names.remove('RdfClassBase')\n    except ValueError:\n        pass\n    if cls_names:\n        new_name = \"%s_%s\" % (prop_name.pyuri, \"_\".join(cls_names))\n        prop_defs['kds_appliesToClass'] = cls_names\n    elif not cls_names:\n        cls_names = [Uri('kdr_AllClasses')]\n        register = True\n        new_name = prop_name\n    else:\n        new_name = prop_name\n\n    new_prop = types.new_class(new_name,\n                               (RdfPropertyBase, list,),\n                               {'metaclass': RdfPropertyMeta,\n                                'prop_defs': prop_defs,\n                                'class_names': cls_names,\n                                'prop_name': prop_name,\n                                'hierarchy': hierarchy})\n    if register:\n        global properties\n        global domain_props\n        properties[new_name] = new_prop\n        for domain in new_prop.rdfs_domain:\n            try:\n                # domain_props[domain].append(new_prop)\n                domain_props[domain][prop_name] = prop_defs\n            except KeyError:\n                # domain_props[domain] = [new_prop]\n                domain_props[domain] = {}\n                domain_props[domain][prop_name] = prop_defs\n            except TypeError:\n                pass\n    return new_prop"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a property class linked to the class that is linked to the given property", "response": "def link_property(prop, cls_object):\n    \"\"\" Generates a property class linked to the rdfclass\n\n    args:\n        prop: unlinked property class\n        cls_name: the name of the rdf_class with which the property is\n                  associated\n        cls_object: the rdf_class\n    \"\"\"\n    register = False\n    cls_name = cls_object.__name__\n    if cls_name and cls_name != 'RdfBaseClass':\n        new_name = \"%s_%s\" % (prop._prop_name, cls_name)\n    else:\n        new_name = prop._prop_name\n\n    new_prop = types.new_class(new_name,\n                               (prop,),\n                               {'metaclass': RdfLinkedPropertyMeta,\n                                'cls_name': cls_name,\n                                'prop_name': prop._prop_name,\n                                'linked_cls': cls_object})\n    return new_prop"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncycling through the class definiton and returns all properties", "response": "def get_properties(cls_def):\n    \"\"\" cycles through the class definiton and returns all properties \"\"\"\n    # pdb.set_trace()\n    prop_list = {prop: value for prop, value in cls_def.items() \\\n                 if 'rdf_Property' in value.get('rdf_type', \"\") or \\\n                 value.get('rdfs_domain')}\n\n    return prop_list"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread through the prop_defs and returns a dictionary filtered by the class_names", "response": "def filter_prop_defs(prop_defs, hierarchy, cls_names):\n    \"\"\" Reads through the prop_defs and returns a dictionary filtered by the\n        current class\n\n    args:\n        prop_defs: the defintions from the rdf vocabulary defintion\n        cls_object: the class object to tie the property\n        cls_names: the name of the classes\n    \"\"\"\n\n    def _is_valid(test_list, valid_list):\n        \"\"\" reads the list of classes in appliesToClass and returns whether\n            the test_list matches\n\n        args:\n            test_list: the list of clasees to test against\n            valid_list: list of possible matches\n        \"\"\"\n\n        for test in test_list:\n            if test in valid_list:\n                return True\n        return False\n\n    new_dict = {}\n    valid_classes = [Uri('kdr_AllClasses')] + cls_names + hierarchy\n    for def_name, value in prop_defs.items():\n        new_dict[def_name] = []\n        empty_def = []\n        try:\n            for item in value:\n                if item.get('kds_appliesToClass'):\n                    if _is_valid(item['kds_appliesToClass'], valid_classes):\n                        new_dict[def_name].append(item)\n                else:\n                    empty_def.append(item)\n            if not new_dict[def_name]:\n                new_dict[def_name] = empty_def\n        except AttributeError:\n            new_dict[def_name] = value\n    return new_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexamines and adds any missing defs to the prop_defs dictionary for the specified property name and class names.", "response": "def prepare_prop_defs(prop_defs, prop_name, cls_names):\n    \"\"\"\n    Examines and adds any missing defs to the prop_defs dictionary for\n    use with the RdfPropertyMeta.__prepare__ method\n\n    Args:\n    -----\n        prop_defs: the defintions from the rdf vocabulary defintion\n        prop_name: the property name\n        cls_names: the name of the associated classes\n\n    Returns:\n    --------\n        prop_defs\n    \"\"\"\n    def get_def(prop_defs, def_fields, default_val=None):\n        \"\"\" returns the cross corelated fields for delealing with mutiple\n            vocabularies\n\n        args:\n            prop_defs: the propertry definition object\n            def_fields: list of the mapped field names\n            default_val: Default value if none of the fields are found\n        \"\"\"\n        rtn_list = []\n        for fld in def_fields:\n            if prop_defs.get(fld):\n                rtn_list += prop_defs.get(fld)\n        if not rtn_list and default_val:\n            rtn_list.append(default_val)\n        elif rtn_list:\n            try:\n                rtn_list = list(set(rtn_list))\n            except TypeError as e:\n                # This deals with a domain that required a conjunction of two\n                # rdf_Classes\n                # pdb.set_trace()\n                new_rtn = []\n                for item in rtn_list:\n                    if isinstance(item, MODULE.rdfclass.RdfClassBase):\n                        new_rtn.append(\\\n                                \"|\".join(merge_rdf_list(item['owl_unionOf'])))\n                    elif isinstance(item, list):\n                        new_rtn.append(\"|\".join(item))\n                    else:\n                        new_rtn.append(item)\n                rtn_list = list(set(new_rtn))\n                new_rtn = []\n                for item in rtn_list:\n                    if \"|\" in item:\n                        new_rtn.append([Uri(domain) \\\n                                        for domain in item.split(\"|\")])\n                    else:\n                        new_rtn.append(Uri(item))\n                rtn_list = new_rtn\n\n                # pdb.set_trace()\n        return rtn_list\n\n    required_def_defaults = {\n        Uri('kds_rangeDef'): [{}],\n        Uri('rdfs_range'): [Uri(\"xsd_string\")],\n        Uri('rdfs_domain'): cls_names,\n        Uri('rdfs_label'): [NSM.nouri(prop_name)],\n        Uri('kds_formDefault'): [{\n            Uri('kds:appliesToClass'): Uri('kdr:AllClasses'),\n            Uri('kds:formFieldName'): \"emailaddr\",\n            Uri('kds:formLabelName'): [NSM.nouri(prop_name)],\n            Uri('kds:formFieldHelp'): find_values(DESCRIPTION_FIELDS,\n                                                  prop_defs,\n                                                  None),\n            Uri('kds:fieldType'): {\n                Uri('rdf:type'): Uri('kdr:TextField')\n            }\n        }],\n        Uri('kds_propertyValidation'): [],\n        Uri('kds_propertySecurity'): [],\n        Uri('kds_propertyProcessing'): []\n    }\n    for prop in required_def_defaults:\n        if prop not in prop_defs.keys():\n            prop_defs[prop] = required_def_defaults[prop]\n    prop_defs['rdfs_domain'] = get_def(prop_defs, DOMAIN_FIELDS, cls_names)\n    prop_defs['rdfs_range'] = get_def(prop_defs, RANGE_FIELDS,\n                                      Uri('xsd_string'))\n\n    return prop_defs"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntie the property to the class", "response": "def tie_prop_to_class(prop, cls_name):\n    \"\"\" reads through the prop attributes and filters them for the associated\n    class and returns a dictionary for meta_class __prepare__\n\n    args:\n        prop: class object to read\n        cls_name: the name of the class to tie the porperty to\n    \"\"\"\n    attr_list = [attr for attr in dir(prop) if type(attr, Uri)]\n    prop_defs = kwargs.pop('prop_defs')\n    prop_name = kwargs.pop('prop_name')\n    cls_name = kwargs.pop('cls_name')\n    if cls_name == 'RdfClassBase':\n        return {}\n    doc_string = make_doc_string(name,\n                                 prop_defs,\n                                 bases,\n                                 None)\n    new_def = prepare_prop_defs(prop_defs, prop_name, cls_name)\n    new_def['__doc__'] = doc_string\n    new_def['_cls_name'] = cls_name\n    new_def['_prop_name'] = prop_name\n    if prop_name == 'rdf_type':\n        new_def['append'] = unique_append\n    # if prop_name == 'rdf_type':\n    #     pdb.set_trace()\n    new_def['_init_processors'] = get_processors('kds_initProcessor',\n                                                 prop_defs)\n    new_def['_es_processors'] = get_processors('kds_esProcessor',\n                                               prop_defs,\n                                               'es_values')\n    # pdb.set_trace()\n    return new_def"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfunctions for only appending unique items to a list", "response": "def unique_append(self, value):\n    \"\"\" function for only appending unique items to a list.\n    #! consider the possibility of item using this to a set\n    \"\"\"\n    if value not in self:\n        try:\n            super(self.__class__, self).append(Uri(value))\n        except AttributeError as err:\n            if isinstance(value, MODULE.rdfclass.RdfClassBase):\n                super(self.__class__, self).append(value)\n            else:\n                raise err"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_processors(processor_cat, prop_defs, data_attr=None):\n    processor_defs = prop_defs.get(processor_cat,[])\n    processor_list = []\n    for processor in processor_defs:\n        proc_class = PropertyProcessor[processor['rdf_type'][0]]\n        processor_list.append(proc_class(processor.get('kds_params', [{}]),\n                                         data_attr))\n    return processor_list", "response": "Reads the prop defs and adds applicable property processors to the property\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef merge_rdf_list(rdf_list):\n    # pdb.set_trace()\n    if isinstance(rdf_list, list):\n        rdf_list = rdf_list[0]\n    rtn_list = []\n    # for item in rdf_list:\n    item = rdf_list\n    if item.get('rdf_rest') and item.get('rdf_rest',[1])[0] != 'rdf_nil':\n        rtn_list += merge_rdf_list(item['rdf_rest'][0])\n    if item.get('rdf_first'):\n        rtn_list += item['rdf_first']\n    rtn_list.reverse()\n    return rtn_list", "response": "takes an rdf list and merges it into a python list"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the es mapping for the property", "response": "def es_mapping(cls, base_class, **kwargs):\n        \"\"\" Returns the es mapping for the property\n        \"\"\"\n\n        es_map = {}\n        ranges = cls.rdfs_range # pylint: disable=no-member\n        rng_defs = get_prop_range_defs(cls.class_names, cls.kds_rangeDef)\n        rng_def = get_prop_range_def(rng_defs)\n        if rng_def.get(\"kds_esIndexClass\"):\n            ranges = rng_def['kds_esIndexClass'].copy()\n        # pdb.set_trace()\n        # if cls._prop_name == \"bf_partOf\":\n        #     pdb.set_trace()\n        idx_types = get_idx_types(rng_def, ranges)\n        if 'es_Ignored' in idx_types:\n            return {'type': 'text',\n                    'index': es_idx_types['es_NotIndexed']}\n        if 'es_Nested' in idx_types:\n            if (kwargs.get('depth', 0) >= 1 and \\\n                    kwargs.get('class') == ranges[0]) or \\\n                    kwargs.get('depth', 0) > 2:\n                return {\"type\" : \"keyword\"}\n            nested_map = getattr(MODULE.rdfclass,\n                                 ranges[0]).es_mapping(base_class,\n                                                       'es_Nested',\n                                                       **kwargs)\n            es_map['properties'] = nested_map\n            es_map['type'] = \"nested\"\n        elif len(idx_types) > 1:\n            fields = {}\n            for idx in idx_types:\n                fields.update(es_idx_types[idx])\n            es_map['fields'] = fields\n        elif len(idx_types) == 1:\n            if cls._prop_name == 'rdf_type': # pylint: disable=no-member\n                es_map['type'] = 'keyword'\n            elif idx_types[0] == 'es_NotIndexed':\n                es_map['index'] = False\n            else:\n                es_map['type'] = es_idx_types[idx_types[0]]\n        try:\n            if not es_map.get('type'):\n                fld_type = BaseRdfDataType[ranges[0]].es_type\n                es_map['type'] = fld_type\n                if cls._prop_name == 'rdf_type':\n                    es_map['type'] = 'keyword'\n        except (KeyError, AttributeError):\n            if cls._prop_name == 'rdf_type': # pylint: disable=no-member\n                es_map['type'] = 'keyword'\n            else:\n                es_map['type'] = 'text'\n        if es_map['type'] == \"nested\":\n            del es_map['type']\n        try:\n            fld_format = BaseRdfDataType[ranges[0]].es_format\n            es_map['format'] = fld_format\n        except (KeyError, AttributeError):\n            pass\n        return es_map"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the es mapping for the property", "response": "def es_indexers(cls, base_class, **kwargs):\n        \"\"\" Returns the es mapping for the property\n        \"\"\"\n        indexer_list = []\n        ranges = cls.rdfs_range # pylint: disable=no-member\n        rng_defs = get_prop_range_defs(cls.class_names, cls.kds_rangeDef)\n        rng_def = get_prop_range_def(rng_defs)\n        if rng_def.get(\"kds_esIndexClass\"):\n            ranges = rng_def['kds_esIndexClass'].copy()\n        idx_types = get_idx_types(rng_def, ranges)\n        if 'es_Ignored' in idx_types:\n            return []\n        if 'es_Nested' in idx_types:\n            if (kwargs.get('depth', 0) >= 1 and \\\n                    kwargs.get('class') == ranges[0]) or \\\n                    kwargs.get('depth', 0) > 2:\n                return []\n            indexer_list = getattr(MODULE.rdfclass,\n                                   ranges[0]).es_indexers(base_class,\n                                                          'es_Nested',\n                                                          **kwargs)\n        return indexer_list"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a JSON object of the property for insertion into es", "response": "def es_json(self, **kwargs):\n        \"\"\" Returns a JSON object of the property for insertion into es\n        \"\"\"\n        rtn_list = []\n        rng_defs = get_prop_range_defs(self.class_names, self.kds_rangeDef)\n        # if self.__class__._prop_name == 'bf_partOf':\n        #     pdb.set_trace()\n        rng_def = get_prop_range_def(rng_defs)\n        idx_types = rng_def.get('kds_esIndexType', []).copy()\n        if 'es_Ignore' in idx_types:\n            return rtn_list\n        ranges = self.rdfs_range # pylint: disable=no-member\n        # copy the current data into the es_values attribute then run\n        # the es_processors to manipulate that data\n        self.es_values = self.copy()\n        # determine if using inverseOf object\n        if rng_def.get('kds_esLookup'):\n            self.es_values += self.dataset.json_qry(\"%s.$\" % getattr(self,\n                    rng_def['kds_esLookup'][0])[0].pyuri,\n                    {'$':self.bound_class.subject})\n            self.es_values = list(set(self.es_values))\n\n        self._run_processors(self._es_processors)\n        if not idx_types:\n            nested = False\n            for rng in ranges:\n                if range_is_obj(rng, MODULE.rdfclass):\n                    nested = True\n                    break\n\n            value_class = [value.__class__ for value in self.es_values\n                           if isinstance(value, MODULE.rdfclass.RdfClassBase)]\n            if value_class or nested:\n                nested = True\n            else:\n                nested = False\n            if nested:\n                idx_types.append('es_Nested')\n        rtn_obj = {}\n        if 'es_Nested' in idx_types:\n            if kwargs.get('depth', 0) > 6:\n                return  [val.subject.sparql_uri for val in self]\n\n            for value in self.es_values:\n                try:\n                    new_value = value.es_json('es_Nested', **kwargs)\n                except AttributeError:\n                    new_value = convert_value_to_es(value,\n                                                    ranges,\n                                                    self,\n                                                    \"missing_obj\")\n                rtn_list.append(new_value)\n                if rng_def.get(\"kds_esField\"):\n                    es_value_fld = rng_def['kds_esValue'][0] \\\n                            if rng_def['kds_esValue'] else None\n                    es_field = rng_def['kds_esField'][0]\n                    for item in value.get(es_field):\n                        if new_value.get(es_value_fld):\n                            val = new_value.get(es_value_fld , [])\n                            try:\n                                rtn_obj[item.pyuri] += val\n                            except KeyError:\n                                rtn_obj[item.pyuri] = val\n        else:\n            for value in self.es_values:\n                rtn_list.append(convert_value_to_es(value, ranges, self))\n        if rtn_obj:\n            return rtn_obj\n        return rtn_list"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse(batch_cmd):\n        cmd_array                    = shlex.split(batch_cmd)\n        (cmd_array, batch_to_file_s) = BatchCommand._parse_in_batches(cmd_array)\n        (cmd_array, batch_from_file) = BatchCommand._parse_out_batch(cmd_array)\n        return (list2cmdline(cmd_array), batch_to_file_s, batch_from_file)", "response": "Parse the command line and return a dict of the command line and the command line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind patterns that match to `in_batches_pat` and replace them into `STDIN` or `TMPFILE`. :param cmd_array: `shlex.split`-ed command :rtype: ([cmd_array], ( batch_to_file, batch_to_file, ... ) ) :returns: Modified `cmd_array` and tuple to show how each IN_BATCH is instantiated (TMPFILE or STDIN). Returned `cmd_array` drops IN_BATCH related tokens. :raises: `IndexError` if IN_BATCHes don't have sequential ID starting from 0", "response": "def _parse_in_batches(cmd_array):\n        \"\"\"Find patterns that match to `in_batches_pat` and replace them into `STDIN` or `TMPFILE`.\n\n        :param cmd_array: `shlex.split`-ed command\n        :rtype:   ([cmd_array], ( batch_to_file, batch_to_file, ... ) )\n        :returns: Modified `cmd_array` and tuple to show how each IN_BATCH is instantiated (TMPFILE or STDIN).\n            Returned `cmd_array` drops IN_BATCH related tokens.\n        :raises:  `IndexError` if IN_BATCHes don't have sequential ID starting from 0\n        \"\"\"\n        res_cmd_array      = cmd_array[:]\n        res_batch_to_file_s = []\n\n        in_batches_cmdidx  = BatchCommand._in_batches_cmdidx(cmd_array)\n        for batch_id, cmdidx in enumerate(in_batches_cmdidx):\n            if cmdidx > 0 and cmd_array[cmdidx - 1] == '<':  # e.g. `< IN_BATCH0`\n                res_batch_to_file_s.append(BatchToFile('STDIN'))\n                del res_cmd_array[cmdidx], res_cmd_array[cmdidx - 1]\n\n            else:  # IN_BATCHx is TMPFILE\n                batch_to_file = BatchToFile('TMPFILE')\n                res_batch_to_file_s.append(batch_to_file)\n                res_cmd_array[cmdidx] = batch_to_file.tmpfile_path()\n\n        return (res_cmd_array, tuple(res_batch_to_file_s))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_out_batch(cmd_array):\n        res_cmd_array     = cmd_array[:]\n        res_batch_from_file = None\n\n        out_batch_cmdidx = BatchCommand._out_batch_cmdidx(cmd_array)\n        if out_batch_cmdidx is None:\n            return (res_cmd_array, res_batch_from_file)\n\n        if out_batch_cmdidx > 0 and cmd_array[out_batch_cmdidx - 1] == '>':  # e.g. `> OUT_BATCH`\n            res_batch_from_file = BatchFromFile('STDOUT')\n            del res_cmd_array[out_batch_cmdidx], res_cmd_array[out_batch_cmdidx - 1]\n\n        else:  # OUT_BATCH is TMPFILE\n            res_batch_from_file = BatchFromFile('TMPFILE')\n            res_cmd_array[out_batch_cmdidx]  = res_batch_from_file.tmpfile_path()\n\n        return (res_cmd_array, res_batch_from_file)", "response": "Parse the OUT_BATCH command and return a list of modified and tuple that contains the patterns that match to out_batch_pat and replace them into STDOUT or TMPFILE."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a tuple of the indices of IN_BATCH0 - IN_BATCH1 - IN_BATCH0 - IN_BATCH1 - IN_BATCHx is not used sequentially in cmd_array.", "response": "def _in_batches_cmdidx(cmd_array):\n        \"\"\"Raise `IndexError` if IN_BATCH0 - IN_BATCHx is not used sequentially in `cmd_array`\n\n        :returns: (IN_BATCH0's cmdidx, IN_BATCH1's cmdidx, ...)\n            $ cat a.txt IN_BATCH1 IN_BATCH0 b.txt c.txt IN_BATCH2 => (3, 2, 5)\n        \"\"\"\n        in_batches_cmdidx_dict = {}\n        for cmdidx, tok in enumerate(cmd_array):\n            mat = BatchCommand.in_batches_pat.match(tok)\n            if mat:\n                batch_idx = int(mat.group(1))\n                if batch_idx in in_batches_cmdidx_dict:\n                    raise IndexError(\n                        'IN_BATCH%d is used multiple times in command below, while IN_BATCH0 - IN_BATCH%d must be used:%s$ %s' %\n                        (batch_idx, len(in_batches_cmdidx_dict) - 1, os.linesep, list2cmdline(cmd_array)))\n                in_batches_cmdidx_dict[batch_idx] = cmdidx\n\n        in_batches_cmdidx = []\n        for batch_idx in range(len(in_batches_cmdidx_dict)):\n            try:\n                cmdidx = in_batches_cmdidx_dict[batch_idx]\n                in_batches_cmdidx.append(cmdidx)\n            except KeyError:\n                raise IndexError('IN_BATCH%d is not found in command below, while IN_BATCH0 - IN_BATCH%d must be used:%s$ %s' %\n                                 (batch_idx, len(in_batches_cmdidx_dict) - 1, os.linesep, list2cmdline(cmd_array)))\n\n        return tuple(in_batches_cmdidx)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _out_batch_cmdidx(cmd_array):\n        out_batch_cmdidx = None\n        for cmdidx, tok in enumerate(cmd_array):\n            mat = BatchCommand.out_batch_pat.match(tok)\n            if mat:\n                if out_batch_cmdidx:\n                    raise IndexError(\n                        'OUT_BATCH is used multiple times in command below:%s$ %s' %\n                        (os.linesep, list2cmdline(cmd_array)))\n                out_batch_cmdidx = cmdidx\n        return out_batch_cmdidx", "response": "Return the index of the OUT_BATCH command in cmd_array or None if OUT_BATCH is used multiple times in command below."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a builder object for a wordlist", "response": "def get_builder(self, corpus):\n        ''' creates a builder object for a wordlist '''\n        builder = WordBuilder(chunk_size=self.chunk_size)\n        builder.ingest(corpus)\n        return builder"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing lists of common name words", "response": "def get_common(self, filename):\n        ''' Process lists of common name words '''\n        word_list = []\n        words = open(filename)\n        for word in words.readlines():\n            word_list.append(word.strip())\n        return word_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_scientific_name(self):\n        ''' Get a new flower name '''\n        genus = self.genus_builder.get_word()\n        species = self.species_builder.get_word()\n        return '%s %s' % (genus, species)", "response": "Get a new flower name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a flower s common name", "response": "def get_common_name(self):\n        ''' Get a flower's common name '''\n        name = random.choice(self.common_first)\n        if random.randint(0, 1) == 1:\n            name += ' ' + random.choice(self.common_first).lower()\n        name += ' ' + random.choice(self.common_second).lower()\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef certify_dict_schema(\n    value, schema=None, key_certifier=None, value_certifier=None, required=None, allow_extra=None,\n):\n    \"\"\"\n    Certify the dictionary schema.\n\n    :param dict|Mapping|MutableMapping value:\n        The mapping value to certify against the schema.\n    :param object schema:\n        The schema to validate with.\n    :param callable key_certifier:\n        A certifier to use on the dictionary's keys.\n    :param callable value_certifier:\n        A certifier to use on the dictionary's values.\n    :param bool required:\n        Whether the value can't be `None`. Defaults to True.\n    :param bool allow_extra:\n        Set to `True` to ignore extra keys.\n    :return:\n        The certified mapping\n    :rtype:\n        dict|Mapping|MutableMapping\n    \"\"\"\n    if key_certifier is not None or value_certifier is not None:\n        for key, val in value.items():\n            if key_certifier is not None:\n                key_certifier(key)\n            if value_certifier is not None:\n                value_certifier(val)\n\n    if schema:\n        if not isinstance(schema, dict):\n            raise CertifierParamError(\n                name='schema',\n                value=schema,\n            )\n\n        for key, certifier in schema.items():\n            if key not in value:\n                raise CertifierValueError(\n                    message=\"key \\'{key}\\' missing from dictionary\".format(\n                        key=key),\n                    required=required,\n                )\n            val = value[key]\n            certifier(value=val)\n\n        if not allow_extra and set(schema) != set(value):\n            values = set(value) - set(schema)\n            raise CertifierValueError(\n                message=\"encountered unexpected keys: {unexpected!r}\".format(\n                    unexpected=values),\n                value=values,\n                required=required,\n            )", "response": "Certify the dictionary schema."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncertifying a dictionary against a schema.", "response": "def certify_dict(\n    value, schema=None, allow_extra=False, required=True, key_certifier=None, value_certifier=None,\n    include_collections=False,\n):\n    \"\"\"\n    Certifies a dictionary, checking it against an optional schema.\n\n    The schema should be a dictionary, with keys corresponding to the expected keys in `value`,\n    but with the values replaced by functions which will be called to with the corresponding\n    value in the input.\n\n    A simple example:\n\n        >>> certifier = certify_dict(schema={\n        ...    'id': certify_key(kind='Model'),\n        ...    'count': certify_int(min=0),\n        ...    })\n        >>> certifier({'id': self.key, 'count': self.count})\n\n    :param dict|Mapping|MutableMapping value:\n        The value to be certified.\n    :param dict schema:\n        The schema against which the value should be checked.\n    :param bool allow_extra:\n        Set to `True` to ignore extra keys.\n    :param bool required:\n        Whether the value can't be `None`. Defaults to True.\n    :param callable key_certifier:\n        callable that receives the key to certify (ignoring schema keys).\n    :param callable value_certifier:\n        callable that receives the value to certify (ignoring schema values).\n    :param bool include_collections:\n        Include types from collections.\n    :return:\n        The certified dict.\n    :rtype:\n        dict|Mapping|MutableMapping\n    :raises CertifierTypeError:\n        The type is invalid\n    :raises CertifierValueError:\n        The value is invalid\n    \"\"\"\n    cls = dict\n\n    # Certify our kwargs:\n    certify_params(\n        (certify_bool, 'allow_extra', allow_extra),\n        (certify_bool, 'include_collections', include_collections),\n    )\n    if certify_required(\n        value=value,\n        required=required,\n    ):\n        return\n\n    # Check the type(s):\n    types = [cls]\n    if include_collections:\n        types.extend([Mapping, MutableMapping])\n    types = tuple(types)\n    if not isinstance(value, types):\n        raise CertifierTypeError(\n            message=\"Expected {t} but the type is {cls!r}\".format(\n                cls=cls,\n                t=value.__class__.__name__,\n            ),\n            value=value,\n            required=required,\n        )\n    certify_dict_schema(\n        value=value,\n        schema=schema,\n        key_certifier=key_certifier,\n        value_certifier=value_certifier,\n        required=required,\n        allow_extra=allow_extra,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncertifying an iterable against a schema.", "response": "def certify_iterable_schema(value, schema=None, required=True):\n    \"\"\"\n    Certify an iterable against a schema.\n\n    :param iterable value:\n        The iterable to certify against the schema.\n    :param iterable schema:\n        The schema to use\n    :param bool required:\n        Whether the value can't be `None`. Defaults to True.\n    :return:\n        The validated iterable.\n    :rtype:\n        iterable\n    \"\"\"\n    if schema is not None:\n        if len(schema) != len(value):\n            raise CertifierValueError(\n                \"encountered {extra} extra items\".format(\n                    extra=len(value) - len(schema)),\n                value=value,\n                required=required,\n            )\n\n        for index, certifier in enumerate(schema):\n            try:\n                certifier(value=value[index])\n            except CertifierError as exc:\n                six.raise_from(\n                    CertifierValueError(\n                        message=\"invalid value {value!r} for item {index}\".format(\n                            index=index, value=value[index]),\n                        value=value,\n                        required=required,\n                    ),\n                    exc,\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncertifies for the given iterable.", "response": "def certify_iterable(\n    value, types, certifier=None, min_len=None, max_len=None, schema=None,\n    required=True\n):\n    \"\"\"\n    Validates an iterable sequence, checking it against an optional schema.\n\n    The schema should be a list of expected values replaced by functions which will be called to\n    with the corresponding value in the input.\n\n    :param iterable value:\n        The value to be certified.\n    :param tuple(object) types:\n        A tuple of types of the expected iterable.\n    :param func|None certifier:\n        A function to be called on each value in the iterable to check that it is valid.\n    :param int|None min_len:\n        The minimum acceptable length for the iterable.  If None, the minimum length is not checked.\n    :param int|None max_len:\n        The maximum acceptable length for the iterable.  If None, the maximum length is not checked.\n    :param tuple|None schema:\n        The schema against which the value should be checked.\n        For single-item tuple make sure to add comma at the end of schema tuple, that is,\n        for example: schema=(certify_int(),)\n    :param bool required:\n        Whether the value can't be `None`. Defaults to True.\n    :return:\n        The certified iterable.\n    :rtype:\n        iterable\n    :raises CertifierTypeError:\n        The type is invalid\n    :raises CertifierValueError:\n        The valid is invalid.\n    \"\"\"\n    certify_required(\n        value=value,\n        required=required,\n    )\n    certify_params(\n        (_certify_int_param, 'max_len', max_len, dict(negative=False, required=False)),\n        (_certify_int_param, 'min_len', min_len, dict(negative=False, required=False)),\n    )\n    # Check the type(s):\n    if types and not isinstance(value, types):\n        raise CertifierTypeError(\n            message=\"value is not an expected type ({value_type!r})\".format(\n                value_type=value.__class__.__name__\n            ),\n            value=value,\n            required=required,\n        )\n    if min_len is not None and len(value) < min_len:\n        raise CertifierValueError(\n            message=\"expected at least {expected} elements, \"\n                    \"but set is of length {actual}\".format(expected=min_len, actual=len(value)),\n            value=value,\n            required=required,\n        )\n\n    if max_len is not None and len(value) > max_len:\n        raise CertifierValueError(\n            message=(\"expected at most {expected} elements, \"\n                     \"but {cls} is of length {actual}\").format(\n                expected=max_len,\n                actual=len(value),\n                cls=types,\n            ),\n            value=value,\n            required=required,\n        )\n    # Apply the certifier to all values:\n    if certifier is not None:\n        map(certifier, value)\n    certify_iterable_schema(\n        value=value,\n        schema=schema,\n        required=required,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncertify for a set.", "response": "def certify_set(\n    value, certifier=None, min_len=None, max_len=None, include_collections=False,\n    required=True,\n):\n    \"\"\"\n    Certifier for a set.\n\n    :param set value:\n        The set to be certified.\n    :param func certifier:\n        A function to be called on each value in the list to check that it is valid.\n    :param int min_len:\n        The minimum acceptable length for the list. If None, the minimum length is not checked.\n    :param int max_len:\n        The maximum acceptable length for the list. If None, the maximum length is not checked.\n    :param bool include_collections:\n        Include types from collections.\n    :param bool required:\n        Whether the value can be `None`. Defaults to True.\n    :return:\n        The certified set.\n    :rtype:\n        set\n    :raises CertifierTypeError:\n        The type is invalid\n    :raises CertifierValueError:\n        The valid is invalid\n    \"\"\"\n    certify_bool(include_collections, required=True)\n    certify_iterable(\n        value=value,\n        types=tuple([set, MutableSet, Set]) if include_collections else tuple([set]),\n        certifier=certifier,\n        min_len=min_len,\n        max_len=max_len,\n        schema=None,\n        required=required,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef certify_tuple(value, certifier=None, min_len=None, max_len=None, required=True, schema=None):\n    certify_iterable(\n        value=value,\n        types=tuple([tuple]),\n        certifier=certifier,\n        min_len=min_len,\n        max_len=max_len,\n        schema=schema,\n        required=required,\n    )", "response": "Validates a tuple against a schema."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef certify_list(\n    value, certifier=None, min_len=None, max_len=None, required=True, schema=None,\n    include_collections=False,\n):\n    \"\"\"\n    Certifier for a list.\n\n    :param list value:\n        The array to be certified.\n    :param func certifier:\n        A function to be called on each value in the iterable to check that it is valid.\n    :param int min_len:\n        The minimum acceptable length for the iterable.  If None, the minimum length is not checked.\n    :param int max_len:\n        The maximum acceptable length for the iterable.  If None, the maximum length is not checked.\n    :param bool required:\n        Whether the value can't be `None`. Defaults to True.\n    :param tuple schema:\n        The schema against which the value should be checked.\n        For single-item tuple make sure to add comma at the end of schema tuple, that is,\n        for example: schema=(certify_int(),)\n    :param bool include_collections:\n        Include types from collections.\n    :return:\n        The certified list.\n    :rtype:\n        list\n    :raises CertifierTypeError:\n        The type is invalid\n    :raises CertifierValueError:\n        The valid is invalid\n    \"\"\"\n    certify_bool(include_collections, required=True)\n    certify_iterable(\n        value=value,\n        types=tuple([list, MutableSequence, Sequence]) if include_collections else tuple([list]),\n        certifier=certifier,\n        min_len=min_len,\n        max_len=max_len,\n        schema=schema,\n        required=required,\n    )", "response": "Certifier for a list."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef certify_email(value, required=True):\n    certify_required(\n        value=value,\n        required=required,\n    )\n    certify_string(value, min_length=3, max_length=320)\n\n    try:\n        certification_result = email_validator.validate_email(\n            value,\n            check_deliverability=False,\n        )\n    except email_validator.EmailNotValidError as ex:\n        six.raise_from(\n            CertifierValueError(\n                message=\"{value!r} is not a valid email address: {ex}\".format(\n                    value=value,\n                    # email_validator returns unicode characters in exception string\n                    ex=six.u(repr(ex))\n                ),\n                value=value,\n                required=required,\n            ),\n            ex\n        )\n    else:\n        if certification_result['email'] != value:\n            raise CertifierValueError(\n                message=\"{value!r} is not normalized, should be {normalized!r}\".format(\n                    value=value, normalized=certification_result['email']),\n                value=value,\n                required=required,\n            )", "response": "Certifier which verifies that the value is well - formed."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new task.", "response": "def create_task(self, *command_tokens, **command_env):\n\t\t\"\"\"\n\t\t:return: WLauncherScheduleTask\n\t\t\"\"\"\n\t\treturn self.__scheduled_task_cls(self.basic_command(), *command_tokens, **command_env)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_valid(self, model, validator=None):\n    if self.property_name and self.is_property_specific:\n      arg0 = getattr(model, self.property_name)\n    else:\n      arg0 = model\n\n    if self.is_simple:\n      is_valid = self.callback(arg0)\n    else:\n      is_valid = self.callback(arg0, validator)\n\n    return (is_valid, None if is_valid else (self.message or \"is invalid\"))", "response": "Returns true if the model passes the validation and false if not."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck the model against all filters and runs the validation.", "response": "def validate(self, model, validator=None):\n    \"\"\"Checks the model against all filters, and if it shoud be validated, runs the validation. if\n    the model is invalid, an error is added to the model. Then the validity value is returned.\n    \"\"\"\n    for filter_ in self.filters:\n      if not filter_(model):\n        return True\n\n    is_valid, message = self.is_valid(model, validator)\n    if not is_valid:\n      model.add_error(self.pretty_property_name or self.property_name, message)\n    return is_valid"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _is_present(val):\n    if val is None:\n      return False\n    if isinstance(val, str):\n      return len(val) > 0\n    return True", "response": "Returns True if the value is not None and length > 0."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_length(property_name, *, min_length=1, max_length=None, present_optional=False):\n    def check(val):\n      \"\"\"Checks that a value matches a scope-enclosed set of length parameters.\"\"\"\n      if not val:\n        return present_optional\n      else:\n        if len(val) >= min_length:\n          if max_length is None:\n            return True\n          else:\n            return len(val) <= max_length\n        else:\n          return False\n\n    if max_length:\n      message = \"must be at least {0} characters long\".format(min_length)\n    else:\n      message = \"must be between {0} and {1} characters long\".format(min_length, max_length)\n\n    return Validation(check, property_name, message)", "response": "Returns a Validation that checks the length of a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a Validation that checks a property against a regex.", "response": "def matches(property_name, regex, *, present_optional=False, message=None):\n    \"\"\"Returns a Validation that checks a property against a regex.\"\"\"\n    def check(val):\n      \"\"\"Checks that a value matches a scope-enclosed regex.\"\"\"\n      if not val:\n        return present_optional\n      else:\n        return True if regex.search(val) else False\n\n    return Validation(check, property_name, message)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a Validation that checks a property as a number.", "response": "def is_numeric(property_name, *, numtype=\"float\", min=None, max=None,\n                 present_optional=False, message=None):\n    \"\"\"Returns a Validation that checks a property as a number, with optional range constraints.\"\"\"\n    if numtype == \"int\":\n      cast = util.try_parse_int\n    elif numtype == \"decimal\":\n      cast = util.try_parse_decimal\n    elif numtype == \"float\":\n      cast = util.try_parse_float\n    else:\n      raise ValueError(\"numtype argument must be one of: int, decimal, float\")\n\n    def check(val):\n      \"\"\"Checks that a value can be parsed as a number.\"\"\"\n      if val is None:\n        return present_optional\n      else:\n        is_num, new_val = cast(val)\n        if not is_num:\n          return False\n        else:\n          if min is not None and new_val < min:\n            return False\n          if max is not None and new_val > max:\n            return False\n          return True\n\n    if not message:\n      msg = [\"must be a\"]\n      if numtype == \"int\":\n        msg.append(\"whole number\")\n      else:\n        msg.append(\"number\")\n      if min is not None and max is not None:\n        msg.append(\"between {0} and {1}\".format(min, max))\n      elif min is not None:\n        msg.append(\"greater than or equal to {0}\".format(min))\n      elif max is not None:\n        msg.append(\"less than or equal to {0}\".format(max))\n      message = \" \".join(msg)\n\n    return Validation(check, property_name, message)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_date(property_name, *, format=None, present_optional=False, message=None):\n    # NOTE: Not currently using format param\n    def check(val):\n      \"\"\"Checks that a value can be parsed as a date.\"\"\"\n      if val is None:\n        return present_optional\n      else:\n        is_date, _ = util.try_parse_date(val)\n        return is_date\n\n    return Validation(check, property_name, message)", "response": "Returns a Validation that checks a value is a date."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_datetime(property_name, *, format=None, present_optional=False, message=None):\n    # NOTE: Not currently using format param\n    def check(val):\n      \"\"\"Checks that a value can be parsed as a datetime.\"\"\"\n      if val is None:\n        return present_optional\n      else:\n        is_date, _ = util.try_parse_datetime(val)\n        return is_date\n\n    return Validation(check, property_name, message)", "response": "Returns a Validation that checks a value is a datetime."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a Validation that checks that a value is contained within a given set.", "response": "def is_in(property_name, set_values, *, present_optional=False, message=None):\n    \"\"\"Returns a Validation that checks that a value is contained within a given set.\"\"\"\n    def check(val):\n      \"\"\"Checks that a value is contained within a scope-enclosed set.\"\"\"\n      if val is None:\n        return present_optional\n      else:\n        return val in set_values\n\n    return Validation(check, property_name, message)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_unique(keys, *, scope=None, comparison_operators=None, present_optional=False,\n                message=None):\n    \"\"\"Returns a Validation that makes sure the given value is unique for a table and optionally a\n    scope.\n    \"\"\"\n    def check(pname, validator):\n      \"\"\"Checks that a value is unique in its column, with an optional scope.\"\"\"\n      # pylint: disable=too-many-branches\n      model = validator.model\n      data_access = validator.data_access\n      pkname = model.primary_key_name\n      pkey = model.primary_key\n\n      if isinstance(keys, str):\n        key = getattr(model, keys)\n\n        if present_optional and key is None:\n          return True\n\n        if comparison_operators:\n          if isinstance(comparison_operators, str):\n            op = comparison_operators\n          else:\n            op = comparison_operators[0]\n        else:\n          op = \" = \"\n\n        constraints = [(keys, key, op)]\n      else:\n        if comparison_operators:\n          ops = comparison_operators\n        else:\n          ops = [\" = \"] * len(keys)\n\n        constraints = list(zip(keys, [getattr(model, key) for key in keys], ops))\n\n      if scope:\n        if comparison_operators:\n          ops = comparison_operators[len(constraints):]\n        else:\n          ops = [\" = \"] * len(scope)\n\n        constraints.extend(zip(scope, [getattr(model, col) for col in scope], ops))\n\n      dupe = data_access.find(model.table_name, constraints, columns=pkname)\n\n      if dupe is None:\n        return True\n      if isinstance(pkname, str):\n        return dupe[0] == pkey\n      else:\n        return tuple(dupe) == tuple(pkey)\n\n    return Validation(check, keys, message or \"is already taken\", is_simple=False)", "response": "Returns a Validation that makes sure the given value is unique for a table and optionally a scope."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate(self, model, data_access=None, *, fail_fast=None):\n    if fail_fast is None:\n      fail_fast = self.fail_fast\n\n    self.model = model\n    self.data_access = data_access\n    is_valid = True\n    for validation in self.validations:\n      if not validation.validate(model, self):\n        is_valid = False\n        if fail_fast:\n          break\n    return is_valid", "response": "Validates a model against the collection of Validations. Returns True if all Validations pass False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _check_output(self, command):\n        try:\n            if sys.version_info[0] > 2:\n                return check_output(self.base_command + command, stderr=STDOUT).decode('utf8')\n            else:\n                return check_output(self.base_command + command, stderr=STDOUT)\n        except CalledProcessError as command_error:\n            raise GitCommandException(*command_error.args)", "response": "Wrap the call to subprocess. check_output to raise customized exceptions and always return strings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nuse with lambda to sort fields", "response": "def es_field_sort(fld_name):\n    \"\"\" Used with lambda to sort fields \"\"\"\n    parts = fld_name.split(\".\")\n    if \"_\" not in parts[-1]:\n        parts[-1] = \"_\" + parts[-1]\n    return \".\".join(parts)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncommand line entry point for the tags2sdists command.", "response": "def main():\n    \"\"\"bin/tags2sdists: create an sdist for a directory of checkouts.\"\"\"\n    usage = (\"Usage: %prog CHECKOUTDIR SDISTDIR\\n\"\n             \"    CHECKOUTDIR: directory with checkouts\\n\"\n             \"    SDISTDIR: directory with sdist package directories\")\n    parser = optparse.OptionParser(usage=usage)\n    parser.add_option(\"-v\", \"--verbose\",\n                      action=\"store_true\", dest=\"verbose\", default=False,\n                      help=\"Show debug output\")\n    parser.add_option(\"-q\", \"--quiet\",\n                      action=\"store_true\", dest=\"quiet\", default=False,\n                      help=\"Show minimal output\")\n    (options, args) = parser.parse_args()\n\n    if len(args) != 2:\n        parser.print_help()\n        return 1\n    checkouts_dir = args[0]\n    sdists_dir = args[1]\n    checkouts_dir = os.path.abspath(checkouts_dir)\n    sdists_dir = os.path.abspath(sdists_dir)\n    if options.verbose:\n        log_level = logging.DEBUG\n    elif options.quiet:\n        log_level = logging.WARN\n    else:\n        log_level = logging.INFO\n    logging.basicConfig(level=log_level,\n                        format=\"%(levelname)s: %(message)s\")\n\n    logger.info(\"Looking in %s for new sdists to generate into %s.\",\n                checkouts_dir, sdists_dir)\n    package_dir = packagedir.PackageDir(sdists_dir)\n    package_dir.parse()\n    checkout_base_dir = checkoutdir.CheckoutBaseDir(checkouts_dir)\n    for directory in checkout_base_dir.checkout_dirs():\n        logger.debug(\"Looking at directory %s...\", directory)\n        checkout_dir = checkoutdir.CheckoutDir(directory)\n        package = checkout_dir.package\n        if 'Traceback' in package:\n            # Some error in the setup.py and we don't want to have a Traceback\n            # directory in our sdists dir :-)\n            continue\n        for tag in checkout_dir.missing_tags(\n            existing_sdists=package_dir.packages[package]):\n            tarball = checkout_dir.create_sdist(tag)\n            package_dir.add_tarball(tarball, package)\n            checkout_dir.cleanup()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef app_routes(app):\n    _routes = []\n    for rule in app.url_map.iter_rules():\n        _routes.append({\n            'path': rule.rule,\n            'name': rule.endpoint,\n            'methods': list(rule.methods)\n        })\n    return jsonify({'routes': _routes})", "response": "list of routes of an app"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting an unique input type.", "response": "def set_input_type(self, type_or_parse):\n        \"\"\" Set an unique input type.\n\n        If you use this then you have only one input for the play.\n        \"\"\"\n        self._inputs = OrderedDict()\n        default_inputs = self.engine.in_name\n        if len(default_inputs) > 1:\n            raise ValueError(\"Need more than one input, you sould use `add_input` for each of them\")\n        self.add_input(default_inputs[0], type_or_parse)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_input(self, in_name, type_or_parse=None):\n        if type_or_parse is None:\n            type_or_parse = GenericType()\n        elif not isinstance(type_or_parse, GenericType) and callable(type_or_parse):\n            type_or_parse = GenericType(parse=type_or_parse)\n        elif not isinstance(type_or_parse, GenericType):\n            raise ValueError(\"the given 'type_or_parse' is invalid\")\n        self._inputs[in_name] = type_or_parse", "response": "Declare a possible input in_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_outputs(self, *outputs):\n        self._outputs = OrderedDict()\n        for output in outputs:\n            out_name = None\n            type_or_serialize = None\n            if isinstance((list, tuple), output):\n                if len(output) == 1:\n                    out_name = output[0]\n                elif len(output) == 2:\n                    out_name = output[0]\n                    type_or_serialize = output[1]\n                else:\n                    raise ValueError(\"invalid output format\")\n            else:\n                out_name = output\n            self.add_output(out_name, type_or_serialize)", "response": "Set the outputs of the view"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeclaring an output and add it to the internal dictionary.", "response": "def add_output(self, out_name, type_or_serialize=None, **kwargs):\n        \"\"\" Declare an output\n        \"\"\"\n        if out_name not in self.engine.all_outputs():\n            raise ValueError(\"'%s' is not generated by the engine %s\" % (out_name, self.engine.all_outputs()))\n        if type_or_serialize is None:\n            type_or_serialize = GenericType()\n        if not isinstance(type_or_serialize, GenericType) and callable(type_or_serialize):\n            type_or_serialize = GenericType(serialize=type_or_serialize)\n        elif not isinstance(type_or_serialize, GenericType):\n            raise ValueError(\"the given 'type_or_serialize' is invalid\")\n        # register outpurs\n        self._outputs[out_name] = {\n            'serializer': type_or_serialize,\n            'parameters': kwargs if kwargs else {}\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the request for the play command.", "response": "def parse_request(self):\n        \"\"\" Parse request for :func:`play`\n        \"\"\"\n        data = {}\n        options = {}\n        ### get data\n        if request.headers['Content-Type'].startswith('application/json'):\n            # data in JSON\n            data = request.json\n            assert data is not None #FIXME: better error than assertError ?\n            if \"options\" in data:\n                options = data[\"options\"]\n                del data[\"options\"]\n        else:\n            # data in URL/post\n            data = dict()\n            data.update(request.form)\n            data.update(request.args)\n            for key, value in six.iteritems(data):\n                if isinstance(value, list) and len(value) == 1:\n                    data[key] = value[0]\n            # manage config in url\n            options = self._config_from_url()\n        return data, options"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning the engine and block according to some inputs data and options.", "response": "def run(self, inputs_data, options):\n        \"\"\" Run the engine/block according to some inputs data and options\n        \n        It is called from :func:`play`\n        \n        :param inputs_data: dict of input data\n        :param options: engine/block configuration dict\n        \"\"\"\n        ### configure the engine\n        try:\n            self.engine.configure(options)\n        except ValueError as err:\n            raise\n            abort(406, err)  # Not Acceptable\n\n        ### Check inputs\n        needed_inputs = self.engine.needed_inputs()\n        # add default\n        for inname in needed_inputs:\n            #print(inname)\n            if inname not in inputs_data \\\n                    and inname in self._inputs \\\n                    and self._inputs[inname].default is not None:\n                inputs_data[inname] = self._inputs[inname].default\n        # check if all needed inputs are possible\n        if not all(inname in self._inputs for inname in needed_inputs):\n            #Note: this may be check staticly\n            missing = [inname for inname in needed_inputs if inname not in self._inputs]\n            raise ValueError(\"Inputs %s are needed but not declared.\" % missing)\n        # check if all inputs are given\n        if not all(inname in inputs_data for inname in needed_inputs):\n            # configuration error\n            missing = [inname for inname in needed_inputs if inname not in inputs_data]\n            raise ValueError(\"Inputs %s are missing.\" % missing)\n        #\n        ### parse inputs (and validate)\n        inputs = {}\n        for inname in needed_inputs:\n            input_val = self._inputs[inname].parse(inputs_data[inname])\n            self._inputs[inname].validate(input_val)\n            inputs[inname] = input_val\n        #\n        ### run the engine\n        error = False # by default ok\n        try:\n            raw_res = self.engine.play(**inputs)\n        except ReliurePlayError as err:\n            # this is the Reliure error that we can handle\n            error = True\n        finally:\n            pass\n        #\n        ### prepare outputs\n        outputs = {}\n        results = {}\n        if not error:\n            # prepare the outputs\n            for out_name, raw_out in six.iteritems(raw_res):\n                if out_name not in self._outputs:\n                    continue\n                serializer = self._outputs[out_name]['serializer']\n                params = self._outputs[out_name].get('parameters', {})\n                # serialise output\n                if serializer is not None:\n                    results[out_name] = serializer.serialize(raw_res[out_name], **params)\n                else:\n                    results[out_name] = raw_res[out_name]\n        ### prepare the retourning json\n        # add the results\n        outputs[\"results\"] = results\n        ### serialise play metadata\n        outputs['meta'] = self.engine.meta.as_dict()\n        #note: meta contains the error (if any)\n        return outputs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef options(self):\n        #configure engine with an empty dict to ensure default selection/options\n        self.engine.configure({})\n        conf = self.engine.as_dict()\n        conf[\"returns\"] = [oname for oname in six.iterkeys(self._outputs)]\n        # Note: we overide args to only list the ones that are declared in this view\n        conf[\"args\"] = [iname for iname in six.iterkeys(self._inputs)]\n        return jsonify(conf)", "response": "Engine options discover HTTP entry point"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _config_from_url(self):\n        config = {\n            \"name\": self._blk.name,\n            \"options\": {}\n        }\n        for key, value in six.iteritems(request.args):\n            if isinstance(value, list) and len(value) == 1:\n                config[\"options\"][key] = value[0]\n            else:\n                config[\"options\"][key] = value\n        return config", "response": "Manage block configuration from requests. args"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_view(self, view, url_prefix=None):\n        if url_prefix is None:\n            if view.name is None:\n                raise ValueError(\"EngineView has no name and path is not specified\")\n            url_prefix = view.name\n        # bind entry points\n        self.add_url_rule('/%s' % url_prefix, '%s_options' % url_prefix, view.options, methods=[\"GET\"])\n        self.add_url_rule('/%s' % url_prefix, '%s' % url_prefix, view.play, methods=[\"POST\"])\n        # url\n        self.add_url_rule('/%s/options' % url_prefix, '%s_options_OLD' % url_prefix, view.options, methods=[\"GET\"])\n        self.add_url_rule('/%s/play' % url_prefix, '%s_OLD' % url_prefix, view.play, methods=[\"POST\"])\n\n        # manage short route\n        for route in view._short_routes:\n            self.add_url_rule(\n                '/%s/%s' % (url_prefix, route),\n                '%s_short_play' % url_prefix,\n                view.short_play, methods=[\"GET\"]\n            )", "response": "Associate a EngineView with this API."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists of routes (you should have the app where this is register)", "response": "def _routes(self, app):\n        \"\"\" list of routes (you should have the app where this is register)\n        \"\"\"\n        _routes = []\n        prefix = self.url_prefix if self.url_prefix is not None else \"\"\n        for rule in app.url_map.iter_rules():\n            if str(rule).startswith(prefix):\n                _routes.append({\n                    'path':rule.rule,\n                    'name':rule.endpoint,\n                    'methods':list(rule.methods)\n                })\n        returns = {\n            'api': self.name,\n            'url_root': request.url_root,\n            'routes': _routes\n        }\n        return jsonify(returns)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef forward(self, **kwargs):\n        # rewrite url path  \n        prefix = self.url_prefix\n        path= \"\" if request.path == \"/\" else request.path\n        path = path[len(prefix):]\n        url = '%s%s'% ( self.url_root[:-1], path )\n\n        if request.method == 'GET':\n            resp = requests.get(url, params=request.args)\n            data = json.loads(resp.content)\n        elif request.method == 'POST':\n            if request.headers['Content-Type'].startswith('application/json'):\n                # data in JSON\n                resp = requests.post(url, json=request.json)\n                data = request.json\n            else :\n                resp = requests.post(url, json=request.form)\n                data = request.form\n            data = json.loads(resp.content)\n        else:\n            # method not allowed aborting\n            abort(405) # XXX\n\n        return jsonify(data)", "response": "remote http call to api endpoint \n        accept *ONLY * GET and POST"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing a file of rest and return a list of dicts", "response": "def interpret(self, infile):\n        \"\"\" Process a file of rest and return list of dicts \"\"\"\n\n        data = []\n\n        for record in self.generate_records(infile):\n            data.append(record)\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsplit file into lines return dict with line = input depth = n", "response": "def generate_lines(self, infile):\n        \"\"\" Split file into lines\n\n        return dict with line=input, depth=n\n        \"\"\"\n        pound = '#'\n        \n        for line in infile:\n\n            heading = 0\n\n            if line.startswith(pound):\n                heading = self.hash_count(line)\n\n            yield dict(line=line, heading=heading)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses a file of rest and yield dictionaries", "response": "def generate_records(self, infile):\n        \"\"\" Process a file of rest and yield dictionaries \"\"\"\n\n        state = 0\n        record = {}\n\n        for item in self.generate_lines(infile):\n\n            line = item['line']\n            heading = item['heading']\n            \n            # any Markdown heading is just a caption, no image\n            if heading:\n                record['heading'] = True\n                record['caption'] = line[1:].strip()\n\n                state = 'caption'\n                continue\n\n            if not line[0].isspace():\n                # at a potential image\n                if state == 'caption':\n                    yield record\n                    record = {}\n                    state = 0\n\n            if state == 'caption':\n                record['caption'] += '\\n' + line[:-1]\n                continue\n\n            fields = line.split(',')\n\n            # nothing there, carry on\n            if not fields: continue\n\n            image = fields[0].strip()\n\n            if not image: continue\n\n            record['image'] = image\n\n            try:\n                time = float(fields[1])\n            except:\n                time = 0\n\n            record['time'] = time\n\n            try:\n                caption = fields[2].strip()\n            except:\n                caption = None\n\n            if caption:\n                record['caption'] = caption\n\n            # yield it if we have anything\n            if record:\n                yield record\n                record = {}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a named profile from the CONFIG_FILE.", "response": "def read_profile(name):\n    \"\"\"Get a named profile from the CONFIG_FILE.\n\n    Args:\n\n        name\n            The name of the profile to load.\n\n    Returns:\n        A dictionary with the profile's ``repo`` and ``token`` values.\n\n    \"\"\"\n    config = configparser.ConfigParser()\n    config.read(CONFIG_FILE)\n    profile = config[name]\n    repo = profile[\"repo\"]\n    token = profile[\"token\"]\n    return {\"repo\": repo, \"token\": token}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving a profile to the CONFIG_FILE.", "response": "def write_profile(name, repo, token):\n    \"\"\"Save a profile to the CONFIG_FILE.\n\n    After you use this method to save a profile, you can load it anytime\n    later with the ``read_profile()`` function defined above.\n\n    Args:\n\n        name\n            The name of the profile to save.\n\n        repo\n            The Github repo you want to connect to. For instance,\n            this repo is ``jtpaasch/simplygithub``.\n\n        token\n            A personal access token to connect to the repo. It is\n            a hash that looks something like ``ff20ae42dc...``\n\n    Returns:\n        A dictionary with the profile's ``repo`` and ``token`` values.\n\n    \"\"\"\n    make_sure_folder_exists(CONFIG_FOLDER)\n    config = configparser.ConfigParser()\n    config.read(CONFIG_FILE)\n    profile = {\"repo\": repo, \"token\": token}\n    config[name] = profile\n    with open(CONFIG_FILE, \"w\") as configfile:\n        config.write(configfile)\n    return profile"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nredirect to the changelist view if we only have one preference object redirect to it otherwise display listing.", "response": "def changelist_view(self, request, extra_context=None):\n        \"\"\"\n        If we only have a single preference object redirect to it,\n        otherwise display listing.\n        \"\"\"\n        model = self.model\n        if model.objects.all().count() > 1:\n            return super(HTMLSitemapAdmin, self).changelist_view(request)\n        else:\n            obj = model.singleton.get()\n            return redirect(reverse('admin:jmbo_sitemap_%s_change' % \\\n                    model._meta.module_name, args=(obj.id,)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an argument parser for lk", "response": "def build_parser():\n    \"\"\"\n    Returns an argparse.ArgumentParser instance to parse the command line\n    arguments for lk\n    \"\"\"\n    import argparse\n    description = \"A programmer's search tool, parallel and fast\"\n    parser = argparse.ArgumentParser(description=description)\n    parser.add_argument('pattern', metavar='PATTERN', action='store',\n                        help='a python re regular expression')\n    parser.add_argument('--ignore-case', '-i',  dest='ignorecase', action='store_true',\n                        default=False, help='ignore case when searching')\n    parser.add_argument('--no-unicode', '-u', dest='unicode', action='store_false',\n                        default=True, help='unicode-unfriendly searching')\n    parser.add_argument('--no-multiline', '-l', dest='multiline',\n                        action='store_false', default=True,\n                        help='don\\'t search over multiple lines')\n    parser.add_argument('--dot-all', '-a', dest='dot_all',\n                        action='store_true', default=False,\n                        help='dot in PATTERN matches newline')\n    parser.add_argument('--escape', '-e', dest='escape',\n                        action='store_true', default=False,\n                        help='treat PATTERN as a string instead of a regex')\n\n    if sys.version_info >= (2, 6):\n        parser.add_argument('--follow-links', '-s', dest='follow_links',\n                            action='store_true', default=False,\n                            help='follow symlinks (Python >= 2.6 only)')\n    parser.add_argument('--hidden', '-n', dest='search_hidden',\n                        action='store_true', default=False,\n                        help='search hidden files and directories')\n    parser.add_argument('--binary', '-b', dest='search_binary',\n                        action='store_true', default=False,\n                        help='search binary files')\n    parser.add_argument('--no-colors', '-c', dest='use_ansi_colors',\n                        action='store_false', default=True,\n                        help=\"don't print ANSI colors\")\n    parser.add_argument('--stats', '-t', dest='print_stats',\n                        action='store_true', default=False,\n                        help='print statistics')\n    parser.add_argument('--num-processes', '-p', dest='number_processes',\n                        action='store', default=10, type=int,\n                        help='number of child processes to concurrently search with')\n    parser.add_argument('--exclude', '-x', metavar='PATH_PATTERN', dest='exclude_path_patterns',\n                        action='append', default=[], type=str,\n                        help='exclude paths matching PATH_PATTERN')\n    parser.add_argument('--open-with', '-o', metavar='COMMAND',\n                        dest='command_strings', action='append', default=[],\n                        type=str,\n                        help='run each COMMAND where COMMAND is a string with a placeholder, %%s, for the absolute path of the matched file')\n    parser.add_argument('directory', metavar='DIRECTORY', nargs='?',\n                        default=getcwd(), help='a directory to search in (default cwd)')\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_file_contents(path, binary=False):\n    # if this isn't a text file, we should raise an IOError\n    f = open(path, 'r')\n    file_contents = f.read()\n    f.close()\n    if not binary and file_contents.find('\\000') >= 0:\n        raise IOError('Expected text file, got binary file')\n    return file_contents", "response": "Return the contents of the text file at path."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a search of the directory to the queue", "response": "def enqueue_directory(self, directory):\n        \"\"\"\n        add a search of the directory to the queue\n        \"\"\"\n\n        exclude_path_regexes = self.exclude_path_regexes[:]\n\n        if not self.search_hidden:\n            exclude_path_regexes.append(self.hidden_file_regex)\n        else:\n            exclude_path_regexes.remove(self.hidden_file_regex)\n\n        self.mark = datetime.datetime.now()\n\n        def is_path_excluded(path):\n            \"\"\"\n            return True if name matches on of the regexes in\n            exclude_path_regexes, False otherwise\n            \"\"\"\n            for exclude_path_regex in exclude_path_regexes:\n                for found in exclude_path_regex.finditer(path):\n                    return False\n            return True\n\n        def search_walk():\n            try:\n                walk_generator = walk(directory, followlinks=self.follow_links)\n            except TypeError:\n                # for python less than 2.6\n                walk_generator = walk(directory)\n\n            for packed in walk_generator:\n                directory_path, directory_names, file_names = packed\n                directory_names[:] = filter(is_path_excluded, directory_names)\n                file_names[:] = filter(is_path_excluded, file_names)\n                yield directory_path, directory_names, file_names\n\n        writer = ColorWriter(sys.stdout, self.use_ansi_colors)\n        def print_directory_result(directory_result):\n            writer.print_result(directory_result)\n            for command_string in self.command_strings:\n                if command_string.find('%s') < 0:\n                    command_string += ' %s'\n                for file_name, line_result in directory_result.iter_line_results_items():\n                    file_path = path.join(directory_result.directory_path, file_name)\n                    Popen(command_string % file_path, shell=True)\n                    break\n\n        for directory_path, directory_names, file_names in search_walk():\n            process = Process(target=self.search_worker,\n                             args=(self.regex,\n                                   directory_path,\n                                   file_names,\n                                   self.search_binary,\n                                   print_directory_result))\n            self.queue.append(process)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild a DirectoryResult for the given regex, directory path, and file names", "response": "def search_worker(self, regex, directory_path, names, binary=False,\n                      callback=None):\n        \"\"\"\n        build a DirectoryResult for the given regex, directory path, and file names\n        \"\"\"\n        try:\n            result = DirectoryResult(directory_path)\n            def find_matches(name):\n                full_path = path.join(directory_path, name)\n                file_contents = get_file_contents(full_path, binary)\n                start = 0\n                match = regex.search(file_contents, start)\n                while match:\n                    result.put(name, file_contents, match)\n                    start = match.end()\n                    match = regex.search(file_contents, start)\n            for name in names:\n                try:\n                    find_matches(name)\n                except IOError:\n                    pass\n            if callback:\n                callback(result)\n        except KeyboardInterrupt, e:\n            exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints out the contents of the directory result using ANSI color codes", "response": "def print_result(self, directory_result):\n        \"\"\"\n        Print out the contents of the directory result, using ANSI color codes if\n        supported\n        \"\"\"\n        for file_name, line_results_dict in directory_result.iter_line_results_items():\n            full_path = path.join(directory_result.directory_path, file_name)\n            self.write(full_path, 'green')\n            self.write('\\n')\n            for line_number, line_results in sorted(line_results_dict.items()):\n                self.write('%s: ' % (line_results[0].line_number))\n                out = list(line_results[0].left_of_group + line_results[0].group + line_results[0].right_of_group)\n                offset = 0\n                for line_result in line_results:\n                    group_length = len(line_result.group)\n                    out.insert(offset+line_result.left_offset-1, self.colors['blue'])\n                    out.insert(offset+line_result.left_offset+group_length, self.colors['end'])\n                    offset += group_length + 1\n                self.write(''.join(out)+'\\n')\n            self.write('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate or gets a RequestInfo instance from the given request.", "response": "def create_or_get_from_request(request):\n        \"\"\"Returns `RequestInfo` instance.\n\n        If object was already created during ``request`` it is\n        returned. Otherwise new instance is created with details\n        populated from ``request``. New instance is then cached for reuse\n        on subsequential calls.\n        \"\"\"\n        saved = getattr(request, REQUEST_CACHE_FIELD, None)\n        if isinstance(saved, RequestInfo):\n            return saved\n        req = RequestInfo()\n        req.user_ip = request.META.get('REMOTE_ADDR')\n        req.user_host = request.META.get('REMOTE_HOST')\n        req.user_agent = request.META.get('HTTP_USER_AGENT')\n        req.full_path = request.build_absolute_uri(\n            request.get_full_path())\n        req.method = request.META.get('REQUEST_METHOD')\n        req.referer = request.META.get('HTTP_REFERER')\n        req.save()\n        setattr(request, REQUEST_CACHE_FIELD, req)\n        return req"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning instance of TrackedModel created from current History snapshot.", "response": "def materialize(self):\n        \"\"\"Returns instance of ``TrackedModel`` created from\n        current ``History`` snapshot.\n        To rollback to current snapshot, simply call ``save``\n        on materialized object.\n        \"\"\"\n        if self.action_type == ActionType.DELETE:\n            # On deletion current state is dumped to change_log\n            # so it's enough to just restore it to object\n            data = serializer.from_json(self.change_log)\n            obj = serializer.restore_model(self._tracked_model, data)\n            return obj\n\n        changes = History.objects.filter(\n            model_name=self.model_name, app_label=self.app_label,\n            table_id=self.table_id)\n        changes = changes.filter(revision_ts__lte=self.revision_ts)\n        changes = list(changes.order_by('revision_ts'))\n\n        creation = changes.pop(0)\n        data = serializer.from_json(creation.change_log)\n        obj = serializer.restore_model(self._tracked_model, data)\n\n        for change in changes:\n            change_log = serializer.from_json(change.change_log)\n            for field in change_log:\n                next_val = change_log[field][Field.NEW]\n                setattr(obj, field, next_val)\n\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _is_plugin_disabled(plugin):\n    item = _registered.get(plugin.name)\n    if not item:\n        return False\n\n    _, props = item\n    return bool(props.get('disabled'))", "response": "Determines if the given plugin is disabled from running for the\n        active task."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling setup or teardown of event hook registration for the provided plugin. class.", "response": "def _setup_events(plugin):\n    \"\"\" Handles setup or teardown of event hook registration for the provided\n        plugin.\n\n        `plugin`\n            ``Plugin`` class.\n        \"\"\"\n\n    events = plugin.events\n\n    if events and isinstance(events, (list, tuple)):\n        for event in [e for e in events if e in _EVENT_VALS]:\n            register('event', event, plugin)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _setup_options(plugin):\n\n    options = plugin.options\n\n    if options and isinstance(options, (list, tuple)):\n        for props in options:\n            if isinstance(props, dict):\n                if 'block' in props and 'options' in props:  # block\n                    block = props['block']\n                    option_list = props['options']\n\n                    # options for this block\n                    for props in option_list:\n                        if isinstance(props, dict):\n                            name = props.pop('name', None)\n\n                            if name:\n                                key = \"{0}_{1}\".format(block, name)\n                                register('option', key, plugin, props)\n\n                else:  # non-block option\n                    name = props.pop('name', None)\n\n                    if name:\n                        register('option', name, plugin, props)", "response": "Handles setup or teardown of option hook registration for the provided plugin.\n            class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register(hook_type, key, plugin_cls, properties=None):\n\n    def fetch_plugin():\n        \"\"\" This function is used as a lazy evaluation of fetching the\n            specified plugin. This is required, because at the time of\n            registration of hooks (metaclass creation), the plugin class won't\n            exist yet in the class namespace, which is required for the\n            `Registry.get()` method. One benefit of this implementation is that\n            we can reference the same object instance in each of the hook\n            registries instead of making a new instance of the plugin for every\n            registry that links to the same plugin.\n            \"\"\"\n        return _registered.get(plugin_cls.name)[0]  # extended, strip type info\n\n    # type information for plugin in main registry\n    type_info = {}\n\n    # register a command for plugin\n    if hook_type == 'command':\n        _command_hooks.register(key, fetch_plugin)\n        type_info['command'] = True\n\n    # register event chain for plugin\n    elif hook_type == 'event':\n        if not key in _event_hooks:\n            _event_hooks[key] = []\n        _event_hooks[key].append((plugin_cls.name, fetch_plugin))\n        type_info['event'] = True\n\n    # register an option for plugin\n    elif hook_type == 'option':\n        _option_hooks.register(key, fetch_plugin, properties or {})\n        type_info['option'] = True\n\n    else:\n        return\n\n    # register this class in main registry\n    _registered.register(plugin_cls.name, plugin_cls, type_info)", "response": "Registers a new hook in the global registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setup_sudo_access(plugin):\n\n    def run_root(self, command):\n        \"\"\" Executes a shell command as root.\n\n            `command`\n                Shell command string.\n\n            Returns boolean.\n            \"\"\"\n        try:\n            return not (common.shell_process('sudo ' + command) is None)\n\n        except KeyboardInterrupt:  # user cancelled\n            return False\n\n    plugin.run_root = types.MethodType(run_root, plugin)", "response": "Injects a run_root method into the provided plugin instance that checks if the user has permission to run the command using sudo."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a generator of registered plugins matching filters.", "response": "def get_registered(option_hooks=None, event_hooks=None,\n                   command_hooks=None, root_access=None,\n                   task_active=True):\n    \"\"\" Returns a generator of registered plugins matching filters.\n\n        `option_hooks`\n            Boolean to include or exclude plugins using option hooks.\n        `event_hooks`\n            Boolean to include or exclude task event plugins.\n        `command_hooks`\n            Boolean to include or exclude command plugins.\n        `root_access`\n            Boolean to include or exclude root plugins.\n        `task_active`\n            Set to ``False`` to not filter by task-based plugins.\n\n        Returns list of ``Plugin`` instances.\n        \"\"\"\n\n    plugins = []\n\n    for _, item in _registered:\n        plugin, type_info = item\n\n        # filter out any task-specific plugins\n        if task_active:\n            if type_info.get('disabled'):\n                continue\n        else:\n            if plugin.options or plugin.task_only:\n                continue\n\n        if not option_hooks is None:\n            if option_hooks != bool(type_info.get('option')):\n                continue\n\n        if not event_hooks is None:\n            if event_hooks != bool(type_info.get('event')):\n                continue\n\n        if not command_hooks is None:\n            if command_hooks != bool(type_info.get('command')):\n                continue\n\n        if not root_access is None:\n            if root_access != plugin.needs_root:\n                continue\n\n        plugins.append(plugin)\n\n    return plugins"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_command_hook(command, task_active=True):\n\n    plugin_obj = _command_hooks.get(command)\n\n    if plugin_obj:\n        if task_active or (not plugin_obj.options and\n                           not plugin_obj.task_only):\n\n            if not _is_plugin_disabled(plugin_obj):\n                return plugin_obj\n\n    return None", "response": "Returns registered command hook for the provided command."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run_event_hooks(event, task):\n\n    # get chain of classes registered for this event\n    call_chain = _event_hooks.get(event)\n\n    if call_chain:\n        # lookup the associated class method for this event\n        event_methods = {\n            'task_start': 'on_taskstart',\n            'task_run': 'on_taskrun',\n            'task_end': 'on_taskend'\n        }\n        method = event_methods.get(event)\n\n        if method:\n            for _, get_plugin in call_chain:\n                plugin_obj = get_plugin()\n\n                if not _is_plugin_disabled(plugin_obj):\n                    try:\n                        getattr(plugin_obj, method)(task)  # execute\n                    except Exception:\n                        # TODO: log these issues for plugin author or user\n                        pass", "response": "Executes registered task event plugins for the provided event and task."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting registered plugins using option hooks for the provided parser instance.", "response": "def run_option_hooks(parser, disable_missing=True):\n    \"\"\" Executes registered plugins using option hooks for the provided\n        ``SettingParser`` instance.\n\n        `parser`\n            ``SettingParser`` instance.\n        `disable_missing`\n            Set to ``True`` to disable any plugins using option hooks whose\n            defined option hooks are not available in the data returned from\n            the parser.\n\n        * Raises ``InvalidTaskConfig`` if task config parsing failed.\n        \"\"\"\n\n    plugins = []\n    state = {}  # state information\n\n    def _raise_error(msg, block):\n        \"\"\" Raises ``InvalidTaskConfig`` exception with given message.\n            \"\"\"\n        if block:\n            msg += u' (block: \"{0}\")'.format(block)\n\n        raise errors.InvalidTaskConfig(parser.filename, reason=msg)\n\n    def _run_hooks(options, block):\n        \"\"\" Runs option hooks for the block and options provided.\n            \"\"\"\n\n        for option, value_list in options:\n            key = '{0}_{1}'.format(block, option) if block else option\n            item = _option_hooks.get(key)\n\n            if item:\n                plugin_obj, props = item\n\n                # enforce some properties\n                if not key in state:\n                    state[key] = 0\n                state[key] += 1\n\n                # currently only supports 'allow_duplicates'\n                if not props.get('allow_duplicates', True) and state[key] > 1:\n                    msg = u'Duplicate option \"{0}\"'.format(option)\n                    _raise_error(msg, block)\n\n                try:\n                    plugin_obj.parse_option(option, block, *value_list)\n                    plugins.append(plugin_obj)\n\n                except TypeError:  # invalid value length\n                    msg = u'Value mismatch for option \"{0}\"'.format(option)\n                    _raise_error(msg, block)\n\n                except ValueError as exc:\n                    msg = unicode(exc)\n                    if not msg:\n                        msg = (u'Invalid value provided for option \"{0}\"'\n                               .format(option))\n\n                    _raise_error(msg, block)\n\n            else:  # invalid key found\n                msg = u'Invalid option \"{0}\" found'.format(option)\n                _raise_error(msg, block)\n\n    # run hooks for non-block options\n    _run_hooks(parser.options, None)\n\n    # run hooks for blocks\n    for block, option_list in parser.blocks:\n        _run_hooks(option_list, block)\n\n    # disable any plugins using option hooks that didn't match parser data\n    if disable_missing:\n        reg_plgs = get_registered(option_hooks=True)\n\n        for plugin in [p for p in reg_plgs if p not in plugins]:\n            disable_plugin_instance(plugin)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a flattened dictionary of key stacks -> value container", "response": "def _create_flat_pointers(dct, key_stack=()):\n    # type: (Dict[str, Any], Tuple[str, ...]) -> Generator[Tuple[Tuple[str, ...], Dict[str, Any], str], None, None]\n    \"\"\"Create a flattened dictionary of \"key stacks\" -> (value container, key)\n    \"\"\"\n    for k in dct.keys():\n        current_key = key_stack + (k,)\n        if isinstance(dct[k], BaseMapping):\n            for flat_ptr in _create_flat_pointers(dct[k], current_key):\n                yield flat_ptr\n        else:\n            yield (current_key, dct, k)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef apply(self, config, raise_on_unknown_key=True):\n        # type: (Dict[str, Any], bool) -> None\n        \"\"\"Apply additional configuration from a dictionary\n\n        This will look for dictionary items that exist in the base_config any apply their values on the current\n        configuration object\n        \"\"\"\n        _recursive_merge(self._data, config, raise_on_unknown_key)", "response": "Apply additional configuration from a dictionary containing the current configuration"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\napplies additional configuration from any Python object that exists in the base_config and applies their values on the current configuration object.", "response": "def apply_object(self, config_obj, apply_on=None):\n        # type: (object, Optional[Tuple[str, ...]]) -> None\n        \"\"\"Apply additional configuration from any Python object\n\n        This will look for object attributes that exist in the base_config and apply their values  on the current\n        configuration object\n        \"\"\"\n        self._init_flat_pointers()\n        try:\n            config_obj_keys = vars(config_obj).keys()  # type: Iterable[str]\n        except TypeError:\n            config_obj_keys = filter(lambda k: k[0] != '_', dir(config_obj))\n\n        for config_key in config_obj_keys:\n            if apply_on:\n                flat_key = apply_on + (config_key, )\n            else:\n                flat_key = (config_key, )\n\n            if flat_key in self._flat_pointers:\n                container, orig_key = self._flat_pointers[flat_key]\n                container[orig_key] = getattr(config_obj, config_key)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying additional configuration from a flattened dictionary.", "response": "def apply_flat(self, config, namespace_separator='_', prefix=''):\n        # type: (Dict[str, Any], str, str) -> None\n        \"\"\"Apply additional configuration from a flattened dictionary\n\n        This will look for dictionary items that match flattened keys from base_config and apply their values on the\n        current configuration object.\n\n        This can be useful for applying configuration from environment variables and flat configuration file formats\n        such as INI files.\n        \"\"\"\n        self._init_flat_pointers()\n        for key_stack, (container, orig_key) in self._flat_pointers.items():\n            flat_key = '{prefix}{joined_key}'.format(prefix=prefix, joined_key=namespace_separator.join(key_stack))\n            if flat_key in config:\n                container[orig_key] = config[flat_key]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cross(environment, book, row, sheet_source, column_source, column_key):\n    a = book.sheets[sheet_source]\n\n    return environment.copy(a.get(**{column_key: row[column_key]})[column_source])", "response": "Cross - applies a cross - applies to a column from a different dataset matching by the key."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef column(environment, book, sheet_name, sheet_source, column_source, column_key):\n    a = book.sheets[sheet_source]\n    b = book.sheets[sheet_name]\n\n    return environment.copy([a.get(**{column_key: row[column_key]})[column_source] for row in b.all()])", "response": "Returns an array of values from a column from a different dataset ordered as the key."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting an image file to a Leaflet map.", "response": "def main(input_file, output, format):\n    \"\"\"Converts an image file to a Leaflet map.\"\"\"\n\n    try:\n        process_image(input_file, subfolder=output, ext=format)\n    except Exception as e:\n        sys.exit(e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef with_lock(lock, func, *args, **kwargs):\n    d = lock.acquire()\n\n    def release_lock(result):\n        deferred = lock.release()\n        return deferred.addCallback(lambda x: result)\n\n    def lock_acquired(lock):\n        return defer.maybeDeferred(func, *args, **kwargs).addBoth(release_lock)\n\n    d.addCallback(lock_acquired)\n    return d", "response": "A context manager for performing operations requiring a lock."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates the table and columnfamily if it doesn t already exist.", "response": "def ensure_schema(client, table_name):\n        \"\"\"\n        Create the table/columnfamily if it doesn't already exist.\n\n        :param client: A Cassandra CQL client\n        :type client: silverberg.client.CQLClient\n\n        :param lock_table: A table/columnfamily table name for holding locks.\n        :type lock_table: str\n        \"\"\"\n        query = ''.join([\n            'CREATE TABLE {cf} ',\n            '(\"lockId\" ascii, \"claimId\" timeuuid, PRIMARY KEY(\"lockId\", \"claimId\"));'])\n\n        def errback(failure):\n            failure.trap(InvalidRequestException)\n\n        return client.execute(query.format(cf=table_name),\n                              {}, ConsistencyLevel.QUORUM).addErrback(errback)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef drop_schema(client, table_name):\n        query = 'DROP TABLE {cf}'\n        return client.execute(query.format(cf=table_name),\n                              {}, ConsistencyLevel.QUORUM)", "response": "Drop the schema of the given table."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nacquires the lock. If the lock can't be acquired immediately, retry a specified number of times, with a specified wait time.", "response": "def acquire(self):\n        \"\"\"\n        Acquire the lock.\n\n        If the lock can't be acquired immediately, retry a specified number of\n        times, with a specified wait time.\n        \"\"\"\n        retries = [0]\n        self._acquire_start_seconds = self._reactor.seconds()\n\n        def log_lock_acquired(result):\n            self._lock_acquired_seconds = self._reactor.seconds()\n            seconds = self._lock_acquired_seconds - self._acquire_start_seconds\n            self._log.msg('Acquired lock in {0} seconds'.format(seconds),\n                          lock_acquire_time=seconds, **self._log_kwargs)\n            return result\n\n        def acquire_lock():\n            d = self._write_lock()\n            d.addCallback(self._read_lock)\n            d.addCallback(self._verify_lock)\n            if self._log:\n                d.addCallback(log_lock_acquired)\n            d.addErrback(lock_not_acquired)\n            return d\n\n        def lock_not_acquired(failure):\n            failure.trap(BusyLockError, NoLockClaimsError)\n            retries[0] += 1\n            if retries[0] <= self._max_retry:\n                return task.deferLater(self._reactor, self._retry_wait, acquire_lock)\n            else:\n                return failure\n\n        def log_lock_acquire_failure(failure):\n            if self._log:\n                seconds = self._reactor.seconds() - self._acquire_start_seconds\n                self._log.msg(\n                    'Could not acquire lock in {0} seconds due to {1}'.format(seconds, failure),\n                    lock_acquire_fail_time=seconds, reason=failure, **self._log_kwargs)\n            return failure\n\n        return acquire_lock().addErrback(log_lock_acquire_failure)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef koji_instance(config, message, instance=None, *args, **kw):\n\n    instance = kw.get('instance', instance)\n    if not instance:\n        return False\n\n    instances = [item.strip() for item in instance.split(',')]\n    return message['msg'].get('instance') in instances", "response": "Return True if message is part of a koji build system."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register(self, name):\n        def decorator(func):\n            \"\"\"Inner decorator, not used directly.\n\n            Args:\n                func: obj. Parameterless function to register.\n\n            Returns:\n                func: decorated function.\n            \"\"\"\n            self.logic[name] = func\n            @wraps(func)\n            def wrapper():\n                \"\"\"Wrapper, not used directly.\"\"\"\n                raise RuntimeError('working outside of request context')\n            return wrapper\n        return decorator", "response": "Decorator for registering a named function in the sesion logic."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pass_session_attributes(self):\n        for key, value in six.iteritems(self.request.session.attributes):\n            self.response.sessionAttributes[key] = value", "response": "Copies request attributes to response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dispatch(self):\n\n        if self.request.request.type == 'IntentRequest':\n            name = self.request.request.intent.name\n        else:\n            name = self.request.request.type\n\n        if name in self.logic:\n            self.logic[name]()\n        else:\n            error = 'Unable to find a registered logic function named: {}'\n            raise KeyError(error.format(name))", "response": "Calls the matching logic function by request type or intent name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process(self, body, url=None, sig=None):\n        self.request = RequestBody()\n        self.response = ResponseBody()\n\n        self.request.parse(body)\n\n        app_id = self.request.session.application.application_id\n        stamp = self.request.request.timestamp\n        if not self.valid.request(app_id, body, stamp, url, sig):\n            return False\n\n        self.pass_session_attributes()\n\n        self.dispatch()\n\n        if self.request.request.type == 'SessionEndedRequest':\n            self.terminate()\n\n        return self.response.to_json()", "response": "Process the request body given skill logic."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef B3(formula):\n    if isinstance(formula, true) or formula is True or formula == Boolean3.Top.name or formula == Boolean3.Top.value:\n        return Boolean3.Top\n    if isinstance(formula, false) or formula is False or formula == Boolean3.Bottom.name or formula == Boolean3.Bottom.value:\n        return Boolean3.Bottom\n    else:\n        return Boolean3.Unknown", "response": "Rewrite formula eval result into Boolean3"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\niterating tree in pre - order wide - first search order", "response": "def walk(self, filters: str=None, filter_type: type=None, pprint=False, depth=-1):\n        \"\"\"\n        Iterate tree in pre-order wide-first search order\n\n        :param filters: filter by python expression\n        :param filter_type: Filter by class\n        :return:\n        \"\"\"\n        children = self.children()\n        if children is None:\n            children = []\n        res = []\n\n        if depth == 0:\n            return res\n        elif depth != -1:\n            depth -= 1\n\n        for child in children:\n            if isinstance(child, Formula):\n                tmp = child.walk(filters=filters, filter_type=filter_type, pprint=pprint, depth=depth)\n                if tmp:\n                    res.extend(tmp)\n\n        if filter_type is None:\n            if filters is not None:\n                if eval(filters) is True:\n                    res.append(self)\n            else:\n                res.append(self)\n        elif isinstance(self, filter_type):\n            if filters is not None:\n                if eval(filters) is True:\n                    res.append(self)\n            else:\n                res.append(self)\n\n        if pprint:\n            res = [str(x) + \" \" for x in res]\n            res = \"\\n\".join(res)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef red_workshift(request, message=None):\n    '''\n    Redirects to the base workshift page for users who are logged in\n    '''\n    if message:\n        messages.add_message(request, messages.ERROR, message)\n    return HttpResponseRedirect(reverse('workshift:view_semester'))", "response": "Redirects to the base workshift page for users who are logged in"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresolves user settings dict from django settings module.", "response": "def _user_settings(self):\n        \"\"\"\n        Resolve settings dict from django settings module.\n        Validate that all the required keys are present and also that none of\n        the removed keys do.\n        Result is cached.\n        \"\"\"\n        user_settings = getattr(settings, self._name, {})\n        if not user_settings and self._required:\n            raise ImproperlyConfigured(\"Settings file is missing dict options with name {}\".format(self._name))\n        keys = frozenset(user_settings.keys())\n\n        required = self._required - keys\n        if required:\n            raise ImproperlyConfigured(\"Following options for {} are missing from settings file: {}\".format(self._name, ', '.join(sorted(required))))\n\n        removed = keys & self._removed\n        if removed:\n            raise ImproperlyConfigured(\"Following options for {} have been removed: {}\".format(self._name, ', '.join(sorted(removed))))\n\n        return user_settings"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an independent copy of the current object.", "response": "def copy(self, empty=False):\n        \"\"\"returns an independent copy of the current object.\"\"\"\n        \n        # Create an empty object\n        newobject = self.__new__(self.__class__)\n        if empty:\n            return\n        \n        # And fill it !\n        for prop in [\"_properties\",\"_side_properties\",\n                     \"_derived_properties\",\"_build_properties\"\n                     ]:\n            if prop not in dir(self):\n                continue\n            try: # Try to deep copy because but some time it does not work (e.g. wcs) \n                newobject.__dict__[prop] = copy.deepcopy(self.__dict__[prop])\n            except:\n                newobject.__dict__[prop] = copy.copy(self.__dict__[prop])\n                \n        # This be sure things are correct\n        newobject._update_()\n        # and return it\n        return newobject"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef shell_notify(msg, state=False, more=None, exitcode=None, verbose=True):\n    '''\n    A pretty long wrapper for a :py:func:`print` function.\n    But this :py:func:`print` is the only one in Photon.\n\n    .. note:: |use_photon_m|\n\n    :param msg:\n        The message to show\n    :param state:\n        The message will be prefixed with [`state`]\n\n        * If ``False`` (default): Prefixed with ~\n\n        * If ``None``: Prefixed with [WARNING]\n\n        * If ``True``: Prefixed with [FATAL] and the exitcode \\\n        will be set (see below)\n\n    :param more:\n        Something to add to the message (see below)\n\n        * Anything you have. Just for further information.\n\n        * Will be displayed after the message, \\\n        pretty printed using :py:func:`pprint.pformat`\n\n    :param exitcode:\n        |appteardown| with given code\n    :param verbose:\n        Show message or not (see below)\n\n        * If set to ``False``, you can use :func:`shell_notify` \\\n        for the dictionary it returns.\n\n        * Will be overruled if `exitcode` is set.\n\n    :returns:\n        A dictionary containing untouched `msg`, `more` and `verbose`\n    '''\n\n    if state is True:\n        state = '[FATAL]'\n        exitcode = 23\n    elif state is None:\n        state = '[WARNING]'\n    elif state is False:\n        state = '~'\n    else:\n        state = '[%s]' % (str(state))\n    m = ' %s %s' % (state, str(msg))\n    if more:\n        m += '\\n\\t' + _pformat(more).replace('\\n', '\\n\\t')\n    if verbose or isinstance(exitcode, int):\n        print(m)\n    if isinstance(exitcode, int):\n        _exit(exitcode)\n    return dict(message=msg, more=more, verbose=verbose)", "response": "Print a message to the console and return a dictionary containing untouched message more and verbose."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef shell_run(cmd,\n              cin=None, cwd=None, timeout=10, critical=True, verbose=True):\n    '''\n    Runs a shell command within a controlled environment.\n\n    .. note:: |use_photon_m|\n\n    :param cmd: The command to run\n\n        * A string one would type into a console like \\\n        :command:`git push -u origin master`.\n\n        * Will be split using :py:func:`shlex.split`.\n\n        * It is possible to use a list here, but then no splitting is done.\n\n    :param cin:\n        Add something to stdin of `cmd`\n    :param cwd:\n        Run `cmd` insde specified current working directory\n    :param timeout:\n        Catch infinite loops (e.g. ``ping``).\n        Exit after `timeout` seconds\n    :param critical:\n        If set to ``True``: |appteardown| on failure of `cmd`\n    :param verbose:\n        Show messages and warnings\n    :returns:\n        A dictionary containing the results from\n        running `cmd` with the following:\n\n        * 'command': `cmd`\n\n        * 'stdin': `cin` (If data was set in `cin`)\n\n        * 'cwd': `cwd` (If `cwd` was set)\n\n        * 'exception': exception message (If an exception was thrown)\n\n        * 'timeout': `timeout` (If a timeout exception was thrown)\n\n        * 'stdout': List from stdout (If any)\n\n        * 'stderr': List from stderr (If any)\n\n        * 'returncode': The returncode (If not any exception)\n\n        * 'out': The most urgent message as joined string. \\\n        ('exception' > 'stderr' > 'stdout')\n    '''\n\n    res = dict(command=cmd)\n    if cin:\n        cin = str(cin)\n        res.update(dict(stdin=cin))\n    if cwd:\n        res.update(dict(cwd=cwd))\n\n    if isinstance(cmd, str):\n        cmd = _split(cmd)\n\n    try:\n        p = _Popen(\n            cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE,\n            bufsize=1, cwd=cwd, universal_newlines=True\n        )\n    except Exception as ex:\n        res.update(dict(exception=str(ex)))\n    else:\n\n        try:\n            out, err = p.communicate(input=cin, timeout=timeout)\n            if out:\n                res.update(dict(\n                    stdout=[o for o in out.split('\\n') if o]\n                ))\n            if err:\n                res.update(dict(\n                    stderr=[e for e in err.split('\\n') if e]\n                ))\n            res.update(dict(returncode=p.returncode))\n\n        except _TimeoutExpired as ex:\n            res.update(dict(exception=str(ex), timeout=timeout))\n            p.kill()\n        except Exception as ex:\n            res.update(dict(exception=str(ex)))\n\n    res.update(\n        out=(\n            res.get('exception') or\n            '\\n'.join(res.get('stderr') or res.get('stdout', ''))\n        )\n    )\n\n    if res.get('returncode', -1) != 0:\n        res.update(dict(critical=critical))\n\n        shell_notify(\n            'error in shell command \\'%s\\'' % (res.get('command')),\n            state=True if critical else None,\n            more=res,\n            verbose=verbose\n        )\n\n    return res", "response": "Runs a command within a controlled environment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_timestamp(time=True, precice=False):\n    '''\n    What time is it?\n\n    :param time:\n        Append ``-%H.%M.%S`` to the final string.\n    :param precice:\n        Append ``-%f`` to the final string.\n        Is only recognized when `time` is set to ``True``\n    :returns:\n        A timestamp string of now in the format ``%Y.%m.%d-%H.%M.%S-%f``\n\n    .. seealso:: `strftime.org <http://strftime.org/>`_ is awesome!\n    '''\n\n    f = '%Y.%m.%d'\n    if time:\n        f += '-%H.%M.%S'\n        if precice:\n            f += '-%f'\n    return _datetime.now().strftime(f)", "response": "Returns a timestamp string of the current time."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_hostname():\n    '''\n    Determines the current hostname by probing  ``uname -n``.\n    Falls back to ``hostname`` in case of problems.\n\n    |appteardown| if both failed (usually they don't but consider\n    this if you are debugging weird problems..)\n\n    :returns:\n        The hostname as string. Domain parts will be split off\n    '''\n\n    h = shell_run('uname -n', critical=False, verbose=False)\n    if not h:\n        h = shell_run('hostname', critical=False, verbose=False)\n    if not h:\n        shell_notify('could not retrieve hostname', state=True)\n    return str(h.get('out')).split('.')[0]", "response": "Determines the current hostname by probing uname - n and then getting hostname."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef render(self):\n        return '<span class=\"icon-stack\">%s</span>' % (\n            ''.join([item.render(['icon-stack-base'] if i == 0 else []) for (i, item) in enumerate(self.items)])\n        )", "response": "Render the icon stack."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef open_connection(self, verbose=False):\n\n        # Connect to server\n        hostname = self.configs.get('IMAP', 'hostname')\n        if verbose:\n            print('Connecting to ' + hostname)\n        connection = imaplib.IMAP4_SSL(hostname)\n\n        # Authenticate\n        username = self.configs.get('IMAP', 'username')\n        password = self.configs.get('IMAP', 'password')\n        if verbose:\n            print('Logging in as', username)\n        connection.login(username, password)\n\n        return connection", "response": "Open a new IMAP4_SSL connection to an email server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract and returns the decoded body from an EmailMessage object", "response": "def get_body(self, msg):\n        \"\"\" Extracts and returns the decoded body from an EmailMessage object\"\"\"\n\n        body = \"\"\n        charset = \"\"\n\n        if msg.is_multipart():\n            for part in msg.walk():\n                ctype = part.get_content_type()\n                cdispo = str(part.get('Content-Disposition'))\n\n                # skip any text/plain (txt) attachments\n                if ctype == 'text/plain' and 'attachment' not in cdispo:\n                    body = part.get_payload(decode=True)  # decode\n                    charset = part.get_content_charset()\n                    break\n\n        # not multipart - i.e. plain text, no attachments, keeping fingers crossed\n        else:\n            body = msg.get_payload(decode=True)\n            charset = msg.get_content_charset()\n\n        return body.decode(charset)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_subject(self, msg):\n\n        text, encoding = decode_header(msg['subject'])[-1]\n\n        try:\n            text = text.decode(encoding)\n\n        # If it's already decoded, ignore error\n        except AttributeError:\n            pass\n\n        return text", "response": "Extracts the subject line from an EmailMessage object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching all messages at IMAP4_SSL connection at IMAP4_SSL directory.", "response": "def fetch_all_messages(self, conn, directory, readonly):\n        \"\"\" Fetches all messages at @conn from @directory.\n\n            Params:\n                conn        IMAP4_SSL connection\n                directory   The IMAP directory to look for\n                readonly    readonly mode, true or false\n            Returns:\n                List of subject-body tuples\n        \"\"\"\n\n        conn.select(directory, readonly)\n\n        message_data = []\n\n        typ, data = conn.search(None, 'All')\n\n        # Loop through each message object\n        for num in data[0].split():\n\n            typ, data = conn.fetch(num, '(RFC822)')\n\n            for response_part in data:\n\n                if isinstance(response_part, tuple):\n\n                    email_parser = email.parser.BytesFeedParser()\n                    email_parser.feed(response_part[1])\n\n                    msg = email_parser.close()\n\n                    body = self.get_body(msg)\n                    subject = self.get_subject(msg)\n\n                    message_data.append((subject, body))\n\n        return message_data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntransfer the given module name plus the async module then run it", "response": "def run(self, conn, tmp, module_name, module_args, inject):\n        ''' transfer the given module name, plus the async module, then run it '''\n\n        # shell and command module are the same\n        if module_name == 'shell':\n            module_name = 'command'\n            module_args += \" #USE_SHELL\"\n\n        (module_path, is_new_style, shebang) = self.runner._copy_module(conn, tmp, module_name, module_args, inject)\n        self.runner._low_level_exec_command(conn, \"chmod a+rx %s\" % module_path, tmp)\n\n        return self.runner._execute_module(conn, tmp, 'async_wrapper', module_args,\n           async_module=module_path,\n           async_jid=self.runner.generated_jid,\n           async_limit=self.runner.background,\n           inject=inject\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getparams(self, param):\n\n        return list(cparam for cparam in self.values() if cparam == param)", "response": "Get parameters which match with input param."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the arguments and use them to create a ExistCli object", "response": "def main():\n    \"\"\" Parse the arguments and use them to create a ExistCli object \"\"\"\n    version = 'Python Exist %s' % __version__\n    arguments = docopt(__doc__, version=version)\n    ExistCli(arguments)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads credentials from the config file", "response": "def read_config(self):\n        \"\"\" Read credentials from the config file \"\"\"\n        with open(self.config_file) as cfg:\n            try:\n                self.config.read_file(cfg)\n            except AttributeError:\n                self.config.readfp(cfg)\n\n        self.client_id = self.config.get('exist', 'client_id')\n        self.client_secret = self.config.get('exist', 'client_secret')\n        self.access_token = self.config.get('exist', 'access_token')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_config(self, access_token):\n        self.config.add_section('exist')\n\n        # TODO: config is reading 'None' as string during authorization, so clearing this out\n        # if no id or secret is set - need to fix this later\n        if self.client_id:\n            self.config.set('exist', 'client_id', self.client_id)\n        else:\n            self.config.set('exist', 'client_id', '')\n\n        if self.client_secret:\n            self.config.set('exist', 'client_secret', self.client_secret)\n        else:\n            self.config.set('exist', 'client_secret', '')\n\n        self.config.set('exist', 'access_token', access_token)\n\n        with open(self.config_file, 'w') as cfg:\n            self.config.write(cfg)\n        print('Credentials written to %s' % self.config_file)", "response": "Write the credentials to the config file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_resource(self, arguments):\n        attribute_name = arguments['<attribute_name>']\n        limit = arguments['--limit']\n        page = arguments['--page']\n        date_min = arguments['--date_min']\n        date_max = arguments['--date_max']\n\n        # feed in the config we have, and let the Exist class figure out the best\n        # way to authenticate\n        exist = Exist(self.client_id, self.client_secret, self.access_token)\n\n        # TODO: Tidy this up since we are repeating ourselves a lot below\n        if arguments['user']:\n            result = exist.user()\n        elif arguments['attributes']:\n            result = exist.attributes(attribute_name, limit, page, date_min, date_max)\n        elif arguments['insights']:\n            result = exist.insights(attribute_name, limit, page, date_min, date_max)\n        elif arguments['averages']:\n            result = exist.averages(attribute_name, limit, page, date_min, date_max)\n        elif arguments['correlations']:\n            result = exist.correlations(attribute_name, limit, page, date_min, date_max)\n        elif arguments['acquire_attributes']:\n            attributes_dict = [{'name': x.split(':')[0], 'active': x.split(':')[1]} for x in arguments['<attribute:value>']]\n            result = exist.arquire_attributes(attributes_dict)\n        elif arguments['release_attributes']:\n            attributes_dict = [{'name': x} for x in arguments['<attribute_name>']]\n            result = exist.release_attributes(attributes_dict)\n        elif arguments['owned_attributes']:\n            result = exist.owned_attributes()\n        elif arguments['update_attributes']:\n            attributes_dict = [{'name': x.split(':')[0], 'date': x.split(':')[1], 'value': x.split(':')[2]} for x in arguments['<attribute:date:value>']]\n            result = exist.update_attributes(attributes_dict)\n\n        pp = PrettyPrinter(indent=4)\n        if isinstance(result, list):\n            pp.pprint([res.data for res in result])\n        else:\n            pp.pprint(result.data)", "response": "Gets the resource requested in the arguments"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nauthorize a user using the CherryPy server and write the resulting credentials to a config file.", "response": "def authorize(self, api_token=None, username=None, password=None):\n        \"\"\"\n        Authorize a user using the browser and a CherryPy server, and write\n        the resulting credentials to a config file.\n        \"\"\"\n\n        access_token = None\n\n        if username and password:\n            # if we have a username and password, go and collect a token\n            auth = ExistAuthBasic(username, password)\n            auth.authorize()\n            if auth.token:\n                access_token = auth.token['access_token']\n        elif api_token:\n            # if we already have a token, just use that\n            access_token = api_token\n        else:\n            # if we have a client_id and client_secret, we need to\n            # authorize through the browser\n            auth = ExistAuth(self.client_id, self.client_secret, 'code', self.redirect_uri)\n            auth.browser_authorize()\n            if auth.token:\n                access_token = auth.token['access_token']\n\n        # store the access token in the config file\n        if access_token:\n            self.write_config(access_token)\n        else:\n            print('ERROR: We were unable to authorize to use the Exist API.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef refresh_token(self, arguments):\n\n        new_access_token = None\n\n        auth = ExistAuth(self.client_id, self.client_secret)\n        resp = auth.refresh_token(self.access_token)\n        if auth.token:\n            new_access_token = auth.token['access_token']\n            print('OAuth token refreshed: %s' % new_access_token)\n            self.write_config(new_access_token)\n        else:\n            print('ERROR: We were unable to refresh the OAuth token | %s' % json.dumps(resp))", "response": "Refresh a user s access token using existing the refresh token received in the auth flow."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a repr of a property based class quickly", "response": "def rep(obj, *attrs, **kwargs):\n    \"\"\"Create a repr of a property based class quickly\n    Args:\n        obj      -- instance of class\n        *attrs   -- list of attrs to add to the representation\n        **kwargs -- Extra arguments to add that are not captured as attributes\n\n    Returns: A string representing the class\n    \"\"\"\n    s = obj.__class__.__name__\n    args = chain(((attr, getattr(obj, attr)) for attr in attrs), kwargs.items())\n    s += '(%s)' % ','.join('{}={!r}'.format(k, v) for k, v in args)\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _version_find_existing():\n    _tool_run('git fetch origin -t')\n    git_tags = [x for x in (y.strip() for y in (_tool_run('git tag -l')\n                                                .stdout.split('\\n'))) if x]\n    return {tuple(int(n) if n else 0 for n in m.groups())\n            for m in (_version_re.match(t) for t in git_tags) if m}", "response": "Find existing versions in this repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nenable the given branch name.", "response": "def _git_enable_branch(desired_branch):\n    \"\"\"Enable desired branch name.\"\"\"\n    preserved_branch = _git_get_current_branch()\n    try:\n        if preserved_branch != desired_branch:\n            _tool_run('git checkout ' + desired_branch)\n        yield\n    finally:\n        if preserved_branch and preserved_branch != desired_branch:\n            _tool_run('git checkout ' + preserved_branch)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mk_travis_config():\n    t = dedent(\"\"\"\\\n        language: python\n        python: 3.4\n        env:\n        {jobs}\n        install:\n            - pip install -r requirements/ci.txt\n        script:\n            - invoke ci_run_job $TOX_JOB\n        after_success:\n            coveralls\n    \"\"\")\n    jobs = [env for env in parseconfig(None, 'tox').envlist\n            if not env.startswith('cov-')]\n    jobs += 'coverage',\n    print(t.format(jobs=('\\n'.join(('    - TOX_JOB=' + job)\n                                   for job in jobs))))", "response": "Generate configuration for travis."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new release branch.", "response": "def mkrelease(finish='yes', version=''):\n    \"\"\"Allocates the next version number and marks current develop branch\n    state as a new release with the allocated version number.\n    Syncs new state with origin repository.\n    \"\"\"\n    if not version:\n        version = _version_format(_version_guess_next())\n\n    if _git_get_current_branch() != 'release/' + version:\n        _tool_run('git checkout develop',\n                  'git flow release start ' + version)\n\n    _project_patch_version(version)\n    _project_patch_changelog()\n    patched_files = ' '.join([VERSION_FILE, CHANGES_FILE])\n\n    run('git diff ' + patched_files, pty=True)\n    _tool_run(('git commit -m \"Bump Version to {0!s}\" {1!s}'\n               .format(version, patched_files)))\n\n    if finish not in ('no', 'n', ):\n        _tool_run(\"git flow release finish -m '{0}' {0}\".format(version),\n                  env={b'GIT_MERGE_AUTOEDIT': b'no', })\n        _tool_run('git push origin --tags develop master')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_cache_key(cache_key, alternative_cache_key, *func_args, **func_kwargs):\n    if not cache_key:\n        key = hashlib.sha1('%s.%s.%s' % (alternative_cache_key, func_args, func_kwargs)).hexdigest() #alternative_cache_key + str(func_args) + str(func_kwargs)\n    elif isinstance(cache_key, (str, unicode)):\n        key = hashlib.sha1(cache_key % locals()).hexdigest()\n    elif callable(cache_key):\n        key = hashlib.sha1(cache_key(*func_args, **func_kwargs)).hexdigest()\n    return key", "response": "This is a helper function to retrieve the cache key for a specific function. It is used to create a cache key for a specific function."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_cached_item(cache_key, alternative_cache_key, *func_args, **func_kwargs):\n    key = get_cache_key(cache_key, func, *func_args, **func_kwargs)\n    return cache.get(key)", "response": "This is a decorator that returns the cached item for a specific key created via get_cache_key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if the user can edit the post.", "response": "def get_allow_future(self):\n        \"\"\"\n        Only superusers and users with the permission can edit the post.\n        \"\"\"\n        qs = self.get_queryset()\n        post_edit_permission = '{}.edit_{}'.format(\n            qs.model._meta.app_label, qs.model._meta.model_name\n        )\n        if self.request.user.has_perm(post_edit_permission):\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nyields the current set of requirements if changes have occurred.", "response": "def update_changed_requirements():\n    \"\"\"\n    Checks for changes in the requirements file across an update,\n    and gets new requirements if changes have occurred.\n    \"\"\"\n    reqs_path = join(env.proj_path, env.reqs_path)\n    get_reqs = lambda: run(\"cat %s\" % reqs_path, show=False)\n    old_reqs = get_reqs() if env.reqs_path else \"\"\n    yield\n    if old_reqs:\n        new_reqs = get_reqs()\n        if old_reqs == new_reqs:\n            # Unpinned requirements should always be checked.\n            for req in new_reqs.split(\"\\n\"):\n                if req.startswith(\"-e\"):\n                    if \"@\" not in req:\n                        # Editable requirement without pinned commit.\n                        break\n                elif req.strip() and not req.startswith(\"#\"):\n                    if not set(\">=<\") & set(req):\n                        # PyPI requirement without version.\n                        break\n            else:\n                # All requirements are pinned.\n                return\n        pip(\"-r %s/%s\" % (env.proj_path, env.reqs_path))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(command, show=True, *args, **kwargs):\n    if show:\n        print_command(command)\n    with hide(\"running\"):\n        return _run(command, *args, **kwargs)", "response": "Runs a shell comand on the remote server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun a command as sudo on the remote server.", "response": "def sudo(command, show=True, *args, **kwargs):\n    \"\"\"\n    Runs a command as sudo on the remote server.\n    \"\"\"\n    if show:\n        print_command(command)\n    with hide(\"running\"):\n        return _sudo(command, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_templates():\n    injected = {}\n    for name, data in templates.items():\n        injected[name] = dict([(k, v % env) for k, v in data.items()])\n    return injected", "response": "Returns each of the templates with env vars injected."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nuploads a template only if it has changed and reloads the the ArcGIS service.", "response": "def upload_template_and_reload(name):\n    \"\"\"\n    Uploads a template only if it has changed, and if so, reload the\n    related service.\n    \"\"\"\n    template = get_templates()[name]\n    local_path = template[\"local_path\"]\n    if not os.path.exists(local_path):\n        project_root = os.path.dirname(os.path.abspath(__file__))\n        local_path = os.path.join(project_root, local_path)\n    remote_path = template[\"remote_path\"]\n    reload_command = template.get(\"reload_command\")\n    owner = template.get(\"owner\")\n    mode = template.get(\"mode\")\n    remote_data = \"\"\n    if exists(remote_path):\n        with hide(\"stdout\"):\n            remote_data = sudo(\"cat %s\" % remote_path, show=False)\n    with open(local_path, \"r\") as f:\n        local_data = f.read()\n        # Escape all non-string-formatting-placeholder occurrences of '%':\n        local_data = re.sub(r\"%(?!\\(\\w+\\)s)\", \"%%\", local_data)\n        if \"%(db_pass)s\" in local_data:\n            env.db_pass = db_pass()\n        local_data %= env\n    clean = lambda s: s.replace(\"\\n\", \"\").replace(\"\\r\", \"\").strip()\n    if clean(remote_data) == clean(local_data):\n        return\n    upload_template(local_path, remote_path, env, use_sudo=True, backup=False)\n    if owner:\n        sudo(\"chown %s %s\" % (owner, remote_path))\n    if mode:\n        sudo(\"chmod %s %s\" % (mode, remote_path))\n    if reload_command:\n        sudo(reload_command)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rsync_upload():\n    excludes = [\"*.pyc\", \"*.pyo\", \"*.db\", \".DS_Store\", \".coverage\",\n                \"local_settings.py\", \"/static\", \"/.git\", \"/.hg\"]\n    local_dir = os.getcwd() + os.sep\n    return rsync_project(remote_dir=env.proj_path, local_dir=local_dir,\n                         exclude=excludes)", "response": "Uploads the project with rsync excluding some files and folders."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef vcs_upload():\n    if env.deploy_tool == \"git\":\n        remote_path = \"ssh://%s@%s%s\" % (env.user, env.host_string,\n                                         env.repo_path)\n        if not exists(env.repo_path):\n            run(\"mkdir -p %s\" % env.repo_path)\n            with cd(env.repo_path):\n                run(\"git init --bare\")\n        local(\"git push -f %s master\" % remote_path)\n        with cd(env.repo_path):\n            run(\"GIT_WORK_TREE=%s git checkout -f master\" % env.proj_path)\n            run(\"GIT_WORK_TREE=%s git reset --hard\" % env.proj_path)\n    elif env.deploy_tool == \"hg\":\n        remote_path = \"ssh://%s@%s/%s\" % (env.user, env.host_string,\n                                          env.repo_path)\n        with cd(env.repo_path):\n            if not exists(\"%s/.hg\" % env.repo_path):\n                run(\"hg init\")\n                print(env.repo_path)\n            with fab_settings(warn_only=True):\n                push = local(\"hg push -f %s\" % remote_path)\n                if push.return_code == 255:\n                    abort()\n            run(\"hg update\")", "response": "Uploads the project with the selected VCS tool."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef postgres(command):\n    show = not command.startswith(\"psql\")\n    return sudo(command, show=show, user=\"postgres\")", "response": "Runs the given command as the postgres user."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning SQL against the project s database.", "response": "def psql(sql, show=True):\n    \"\"\"\n    Runs SQL against the project's database.\n    \"\"\"\n    out = postgres('psql -c \"%s\"' % sql)\n    if show:\n        print_command(sql)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbacks up the project database.", "response": "def backup(filename):\n    \"\"\"\n    Backs up the project database.\n    \"\"\"\n    tmp_file = \"/tmp/%s\" % filename\n    # We dump to /tmp because user \"postgres\" can't write to other user folders\n    # We cd to / because user \"postgres\" might not have read permissions\n    # elsewhere.\n    with cd(\"/\"):\n        postgres(\"pg_dump -Fc %s > %s\" % (env.proj_name, tmp_file))\n    run(\"cp %s .\" % tmp_file)\n    sudo(\"rm -f %s\" % tmp_file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef python(code, show=True):\n    setup = \"import os;\" \\\n            \"os.environ[\\'DJANGO_SETTINGS_MODULE\\']=\\'%s.settings\\';\" \\\n            \"import django;\" \\\n            \"django.setup();\" % env.proj_app\n    full_code = 'python -c \"%s%s\"' % (setup, code.replace(\"`\", \"\\\\\\`\"))\n    with project():\n        if show:\n            print_command(code)\n        result = run(full_code, show=False)\n    return result", "response": "Runs Python code in the project s virtual environment with Django loaded."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninstalls the base system and Python requirements for the entire server.", "response": "def install():\n    \"\"\"\n    Installs the base system and Python requirements for the entire server.\n    \"\"\"\n    # Install system requirements\n    sudo(\"apt-get update -y -q\")\n    apt(\"nginx libjpeg-dev python-dev python-setuptools git-core \"\n        \"postgresql libpq-dev memcached supervisor python-pip\")\n    run(\"mkdir -p /home/%s/logs\" % env.user)\n\n    # Install Python requirements\n    sudo(\"pip install -U pip virtualenv virtualenvwrapper mercurial\")\n\n    # Set up virtualenv\n    run(\"mkdir -p %s\" % env.venv_home)\n    run(\"echo 'export WORKON_HOME=%s' >> /home/%s/.bashrc\" % (env.venv_home,\n                                                              env.user))\n    run(\"echo 'source /usr/local/bin/virtualenvwrapper.sh' >> \"\n        \"/home/%s/.bashrc\" % env.user)\n    print(green(\"Successfully set up git, mercurial, pip, virtualenv, \"\n                \"supervisor, memcached.\", bold=True))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the environment needed to host the project.", "response": "def create():\n    \"\"\"\n    Creates the environment needed to host the project.\n    The environment consists of: system locales, virtualenv, database, project\n    files, SSL certificate, and project-specific Python requirements.\n    \"\"\"\n    # Generate project locale\n    locale = env.locale.replace(\"UTF-8\", \"utf8\")\n    with hide(\"stdout\"):\n        if locale not in run(\"locale -a\"):\n            sudo(\"locale-gen %s\" % env.locale)\n            sudo(\"update-locale %s\" % env.locale)\n            sudo(\"service postgresql restart\")\n            run(\"exit\")\n\n    # Create project path\n    run(\"mkdir -p %s\" % env.proj_path)\n\n    # Set up virtual env\n    run(\"mkdir -p %s\" % env.venv_home)\n    with cd(env.venv_home):\n        if exists(env.proj_name):\n            if confirm(\"Virtualenv already exists in host server: %s\"\n                       \"\\nWould you like to replace it?\" % env.proj_name):\n                run(\"rm -rf %s\" % env.proj_name)\n            else:\n                abort()\n        run(\"virtualenv %s\" % env.proj_name)\n\n    # Upload project files\n    if env.deploy_tool in env.vcs_tools:\n        vcs_upload()\n    else:\n        rsync_upload()\n\n    # Create DB and DB user\n    pw = db_pass()\n    user_sql_args = (env.proj_name, pw.replace(\"'\", \"\\'\"))\n    user_sql = \"CREATE USER %s WITH ENCRYPTED PASSWORD '%s';\" % user_sql_args\n    psql(user_sql, show=False)\n    shadowed = \"*\" * len(pw)\n    print_command(user_sql.replace(\"'%s'\" % pw, \"'%s'\" % shadowed))\n    psql(\"CREATE DATABASE %s WITH OWNER %s ENCODING = 'UTF8' \"\n         \"LC_CTYPE = '%s' LC_COLLATE = '%s' TEMPLATE template0;\" %\n         (env.proj_name, env.proj_name, env.locale, env.locale))\n\n    # Set up SSL certificate\n    if not env.ssl_disabled:\n        conf_path = \"/etc/nginx/conf\"\n        if not exists(conf_path):\n            sudo(\"mkdir %s\" % conf_path)\n        with cd(conf_path):\n            crt_file = env.proj_name + \".crt\"\n            key_file = env.proj_name + \".key\"\n            if not exists(crt_file) and not exists(key_file):\n                try:\n                    crt_local, = glob(join(\"deploy\", \"*.crt\"))\n                    key_local, = glob(join(\"deploy\", \"*.key\"))\n                except ValueError:\n                    parts = (crt_file, key_file, env.domains[0])\n                    sudo(\"openssl req -new -x509 -nodes -out %s -keyout %s \"\n                         \"-subj '/CN=%s' -days 3650\" % parts)\n                else:\n                    upload_template(crt_local, crt_file, use_sudo=True)\n                    upload_template(key_local, key_file, use_sudo=True)\n\n    # Install project-specific requirements\n    upload_template_and_reload(\"settings\")\n    with project():\n        if env.reqs_path:\n            pip(\"-r %s/%s\" % (env.proj_path, env.reqs_path))\n        pip(\"gunicorn setproctitle psycopg2 \"\n            \"django-compressor python-memcached\")\n    # Bootstrap the DB\n        manage(\"createdb --noinput --nodata\")\n        python(\"from django.conf import settings;\"\n               \"from django.contrib.sites.models import Site;\"\n               \"Site.objects.filter(id=settings.SITE_ID).update(domain='%s');\"\n               % env.domains[0])\n        for domain in env.domains:\n            python(\"from django.contrib.sites.models import Site;\"\n                   \"Site.objects.get_or_create(domain='%s');\" % domain)\n        if env.admin_pass:\n            pw = env.admin_pass\n            user_py = (\"from django.contrib.auth import get_user_model;\"\n                       \"User = get_user_model();\"\n                       \"u, _ = User.objects.get_or_create(username='admin');\"\n                       \"u.is_staff = u.is_superuser = True;\"\n                       \"u.set_password('%s');\"\n                       \"u.save();\" % pw)\n            python(user_py, show=False)\n            shadowed = \"*\" * len(pw)\n            print_command(user_py.replace(\"'%s'\" % pw, \"'%s'\" % shadowed))\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove the current project from the system.", "response": "def remove():\n    \"\"\"\n    Blow away the current project.\n    \"\"\"\n    if exists(env.venv_path):\n        run(\"rm -rf %s\" % env.venv_path)\n    if exists(env.proj_path):\n        run(\"rm -rf %s\" % env.proj_path)\n    for template in get_templates().values():\n        remote_path = template[\"remote_path\"]\n        if exists(remote_path):\n            sudo(\"rm %s\" % remote_path)\n    if exists(env.repo_path):\n        run(\"rm -rf %s\" % env.repo_path)\n    sudo(\"supervisorctl update\")\n    psql(\"DROP DATABASE IF EXISTS %s;\" % env.proj_name)\n    psql(\"DROP USER IF EXISTS %s;\" % env.proj_name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef deploy():\n    if not exists(env.proj_path):\n        if confirm(\"Project does not exist in host server: %s\"\n                   \"\\nWould you like to create it?\" % env.proj_name):\n            create()\n        else:\n            abort()\n\n    # Backup current version of the project\n    with cd(env.proj_path):\n        backup(\"last.db\")\n    if env.deploy_tool in env.vcs_tools:\n        with cd(env.repo_path):\n            if env.deploy_tool == \"git\":\n                    run(\"git rev-parse HEAD > %s/last.commit\" % env.proj_path)\n            elif env.deploy_tool == \"hg\":\n                    run(\"hg id -i > last.commit\")\n        with project():\n            static_dir = static()\n            if exists(static_dir):\n                run(\"tar -cf static.tar --exclude='*.thumbnails' %s\" %\n                    static_dir)\n    else:\n        with cd(join(env.proj_path, \"..\")):\n            excludes = [\"*.pyc\", \"*.pio\", \"*.thumbnails\"]\n            exclude_arg = \" \".join(\"--exclude='%s'\" % e for e in excludes)\n            run(\"tar -cf {0}.tar {1} {0}\".format(env.proj_name, exclude_arg))\n\n    # Deploy latest version of the project\n    with update_changed_requirements():\n        if env.deploy_tool in env.vcs_tools:\n            vcs_upload()\n        else:\n            rsync_upload()\n    with project():\n        manage(\"collectstatic -v 0 --noinput\")\n        manage(\"migrate --noinput\")\n    for name in get_templates():\n        upload_template_and_reload(name)\n    restart()\n    return True", "response": "Deploy latest version of the project."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rollback():\n    with update_changed_requirements():\n        if env.deploy_tool in env.vcs_tools:\n            with cd(env.repo_path):\n                if env.deploy_tool == \"git\":\n                        run(\"GIT_WORK_TREE={0} git checkout -f \"\n                            \"`cat {0}/last.commit`\".format(env.proj_path))\n                elif env.deploy_tool == \"hg\":\n                        run(\"hg update -C `cat last.commit`\")\n            with project():\n                with cd(join(static(), \"..\")):\n                    run(\"tar -xf %s/static.tar\" % env.proj_path)\n        else:\n            with cd(env.proj_path.rsplit(\"/\", 1)[0]):\n                run(\"rm -rf %s\" % env.proj_name)\n                run(\"tar -xf %s.tar\" % env.proj_name)\n    with cd(env.proj_path):\n        restore(\"last.db\")\n    restart()", "response": "Rollbacks the current state of the project to the last deploy."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_item(self, path):\n        try:\n            f = tempfile.NamedTemporaryFile()\n            self.blob_service.get_blob_to_path(self.container_name, path, f.name)\n            f.seek(0)\n            image = Image.open(f.name)\n            f.close()\n\n            return image\n        except AzureMissingResourceHttpError:\n            return False", "response": "Get resource item\n        :param path: string\n        :return: Image"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates cached item from path and content", "response": "def create_cached_item(self, path, content):\n        \"\"\"\n        Create cached resource item\n        :param path: str\n        :param content: PIL.Image\n        :return: str\n        \"\"\"\n        if isinstance(content, Image.Image):\n            f = tempfile.NamedTemporaryFile()\n            content.save(f.name, format=content.format)\n\n            item_path = '%s/%s' % (\n                self.cache_folder,\n                path.strip('/')\n            )\n\n            self.blob_service.create_blob_from_path(self.container_name, item_path, f.name)\n\n            return self._generate_url(item_path)\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_cached_item(self, path):\n        item_path = '%s/%s' % (\n                self.cache_folder,\n                path.strip('/')\n            )\n\n        try:\n            f = tempfile.NamedTemporaryFile()\n            self.blob_service.get_blob_to_path(self.container_name, item_path, f.name)\n            f.seek(0)\n            image = Image.open(f.name)\n            f.close()\n\n            return image\n        except AzureMissingResourceHttpError:\n            return False", "response": "Get cached resource item by path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_cached_item(self, path):\n        item_path = '%s/%s' % (\n                self.cache_folder,\n                path.strip('/')\n            )\n\n        if self.blob_service.exists(self.container_name, item_path):\n            return self._generate_url(item_path)\n        else:\n            return False", "response": "Check if a cached resource item exists in the cache folder."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving cached item from the cache folder.", "response": "def remove_cached_item(self, path):\n        \"\"\"\n        Remove cached resource item\n        :param path: str\n        :return: PIL.Image\n        \"\"\"\n        item_path = '%s/%s' % (\n                self.cache_folder,\n                path.strip('/')\n            )\n\n        self.blob_service.delete_blob(self.container_name, item_path)\n\n        while self.blob_service.exists(self.container_name, item_path):\n            time.sleep(0.5)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting a single or all sites under a domain.", "response": "def cli(ctx, dname, site, delete_code, no_prompt):\n    \"\"\"\n    Deletes a single site if both <domain> and <site> are specified, or ALL sites under a domain if only the <domain>\n    is specified.\n    \"\"\"\n    assert isinstance(ctx, Context)\n\n    # Get the domain\n    dname = domain_parse(dname)\n    domain = Domain.get(dname)\n    if not domain:\n        click.secho('No such domain: {dn}'.format(dn=domain.name), fg='red', bold=True, err=True)\n        return\n\n    domain_sites = {site.name.lower(): site for site in domain.sites}\n\n    # Single site?\n    if site:\n        if site.lower() not in domain_sites:\n            click.secho('No such site \"{sn}\" under the domain {dn}'.format(sn=site, dn=domain.name))\n        site = domain_sites[site.lower()]\n\n        delete_single(site, domain, delete_code, no_prompt)\n        return\n\n    # Delete the entire domain\n    delete_all(domain, delete_code, no_prompt)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes a single site and domain.", "response": "def delete_single(site, domain, delete_code=False, no_prompt=False):\n    \"\"\"\n    Delete a single site\n    @type   site:           Site\n    @type   domain:         Domain\n    @type   delete_code:    bool\n    @type   no_prompt:      bool\n    \"\"\"\n    click.secho('Deleting installation \"{sn}\" hosted on the domain {dn}'.format(sn=site.name, dn=domain.name),\n                fg='yellow', bold=True)\n    if not no_prompt:\n        if delete_code:\n            warn_text = click.style('WARNING! THIS WILL PERMANENTLY DELETE THIS SITE AND ALL OF THE ASSOCIATED '\n                                    'PROJECT CODE FILES!\\nTHIS MEANS ALL DATA FILES, INCLUDING ANY CREATED CUSTOM '\n                                    'APPLICATIONS AND PLUGINS WILL BE PERMANENTLY AND IRREVOCABLY ERASED!',\n                                    fg='red', bold=True)\n            click.echo(warn_text)\n            prompt_text = click.style('In order to continue, please re-input the site name', fg='white', bold=True)\n            prompt = click.prompt(prompt_text)\n\n            # If our prompt doesn't match, abort\n            if prompt != site.name:\n                click.secho('Site name did not match, site will not be deleted. Aborting.', fg='red', bold=True)\n                raise click.Abort('Site name prompt did not match')\n\n        else:\n            prompt_text = click.style('Are you sure you want to delete this site entry? Your project files will '\n                                      'still be preserved.', fg='white', bold=True)\n            click.confirm(prompt_text, abort=True)\n\n    site.delete()\n\n    if delete_code:\n        _remove_code(site)\n\n    # If this is the only site left in the domain, remove the domain now as well\n    domain_sites = [ds for ds in domain.sites if ds.id != site.id]\n    if not len(domain_sites):\n        Session.delete(domain)\n\n    Session.commit()\n    click.secho('{sn} removed'.format(sn=site.name), fg='yellow', bold=True)\n\n    # Restart Nginx\n    FNULL = open(os.devnull, 'w')\n    subprocess.check_call(['service', 'nginx', 'restart'], stdout=FNULL, stderr=subprocess.STDOUT)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes all code in the current project", "response": "def _remove_code(site):\n    \"\"\"\n    Delete project files\n    @type   site:   Site\n    \"\"\"\n    def handle_error(function, path, excinfo):\n        click.secho('Failed to remove path ({em}): {p}'.format(em=excinfo.message, p=path), err=True, fg='red')\n\n    if os.path.exists(site.root):\n        shutil.rmtree(site.root, onerror=handle_error)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_backend(tasks, default_host=('127.0.0.1', DEFAULT_PORT), *args, \n                  **kw):\n    \"\"\"\n    Most of these args are passed directly to BackEnd(). However, default_host \n    is used a bit differently. It should be a (host, port) pair, and may be \n    overridden with cmdline args:\n      file.py localhost\n      file.py localhost 54545\n    \"\"\"\n    host, port = default_host\n    if len(sys.argv) > 1:\n        host = sys.argv[1]\n    if len(sys.argv) > 2:\n        port = sys.argv[2]\n    \n    return BackEnd(tasks, host, port, *args, **kw)", "response": "Build a backend for the given list of tasks."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _handler(self, conn):\n        incoming = self.recv(conn)\n        self.log(DEBUG, incoming)\n        try:\n            # E.g. ['twister', [7, 'invert'], {'guess_type': True}]\n            task, args, kw = self.codec.decode(incoming)\n            \n            # OK, so we've received the information. Now to use it.\n            self.log(INFO, 'Fulfilling task %r' % task)\n            self.started_task()\n            \n            pass_backend = False\n            obj = self.tasks[task]\n            if _is_iter(obj):\n                # (callable, bool)\n                obj, pass_backend = obj\n            if pass_backend:\n                # Have to do this, since args is a list\n                args = [self] + args\n            \n            # Get and package the result\n            res = ['success', obj(*args, **kw)]\n        except Exception as e:\n            self.log(ERROR, 'Error while fullfilling task %r: %r' % (task, e))\n            res = ['error', e.__class__.__name__, e.args]\n            if self.tracebacks:\n                show_err()\n        else:\n            self.log(INFO, 'Finished fulfilling task %r' % task)\n        finally:\n            self.send(conn, self.codec.encode(res))\n            self.finished_task()\n            conn.close()", "response": "This is the main thread that handles the connection to the server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef subtask(self, func, *args, **kw):\n        self.started_task()\n        try:\n            func(*args, **kw)\n        except Exception:\n            self.log(ERROR, 'Subtask %s(*%s, **%s) failed!' % (func, args, kw))\n        finally:\n            self.finished_task()", "response": "A function that runs a subtask. Takes care of \n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstop receiving connections wait for all tasks to end and then terminate the server.", "response": "def stop_server(self):\n        \"\"\"\n        Stop receiving connections, wait for all tasks to end, and then \n        terminate the server.\n        \"\"\"\n        self.stop = True\n        while self.task_count:\n            time.sleep(END_RESP)\n        self.terminate = True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef main(self):\n        try:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.sock.bind((self.host, self.port))\n            self.sock.listen(5)\n            self.sock.settimeout(END_RESP)\n            \n            self.stop = self.terminate = False\n            \n            while not (self.stop or self.terminate):\n                try:\n                    conn, addr = self.sock.accept()\n                except socket.error:\n                    # We have timed out, hurry and get back to accept those \n                    # connections!\n                    pass\n                except KeyboardInterrupt:\n                    # We've been told to quit, do so!\n                    self.terminate_server()\n                else:\n                    threaded(self._handler, (conn,))\n            \n            while not self.terminate:\n                time.sleep(END_RESP)\n            # We are done, the finally will close the socket.\n        finally:\n            self.sock.close()", "response": "Runs the mainloop. Blocks. Can be halted with over a network, or by \n        with either stop_server() or terminate_server()."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fastqIteratorSimple(fn, verbose=False, allowNameMissmatch=False):\n  fh = fn\n  if type(fh).__name__ == \"str\":\n    fh = open(fh)\n\n  # try to get an idea of how much data we have...\n  if verbose:\n    try:\n      totalLines = os.path.getsize(fh.name)\n      pind = ProgressIndicator(totalToDo=totalLines,\n                               messagePrefix=\"completed\",\n                               messageSuffix=\"of processing \"\n                                             + fh.name)\n    except AttributeError:\n      sys.stderr.write(\"fastqIterator -- warning: \" +\n                       \"unable to show progress for stream\")\n      verbose = False\n\n  while True:\n    # read four lines.. if we can't get four lines, something is wrong\n    lines = []\n    gotLines = 0\n    while gotLines < 4:\n      l = fh.readline()\n      if verbose:\n        pind.done = fh.tell()\n        pind.showProgress()\n\n      if l == \"\":\n        # end of file found...\n        if gotLines == 0:\n          # ok, not in the middle of a sequence\n          break\n        else:\n          raise FastqFileFormatError(\"reached end of file in the \"\n                                     + \"middle of sequence data\")\n\n      l = l.strip()\n      if l == \"\":\n        continue\n      lines.append(l)\n      gotLines += 1\n\n    # couldn't get any more data.. we're done\n    if gotLines == 0:\n      break\n\n    # got our 4 lines, assemble our read..\n    # first check that names match\n    if lines[0][1:] != lines[2][1:] and not allowNameMissmatch:\n      raise FastqFileFormatError(\"names in sequence don't match : \" +\n                                 str(lines[0][1:]) + \" != \" +\n                                 str(lines[2][1:]))\n    name = lines[0][1:]\n    seq = lines[1]\n    qual = lines[3]\n    yield NGSRead(seq, name, qual)", "response": "A simple generator function that yields all the sequence objects in a CASVA file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fastqIteratorComplex(fn, useMutableString=False, verbose=False):\n  fh = fn\n  if type(fh).__name__ == \"str\":\n    fh = open(fh)\n  prevLine = None\n\n  # try to get an idea of how much data we have...\n  pind = None\n  if verbose:\n    try:\n      totalLines = linesInFile(fh.name)\n      pind = ProgressIndicator(totalToDo=totalLines,\n                               messagePrefix=\"completed\",\n                               messageSuffix=\"of processing \"\n                                             + fh.name)\n    except AttributeError:\n      sys.stderr.write(\"fastqIterator -- warning: \"\n                       + \"unable to show progress for stream\")\n      verbose = False\n\n  while True:\n    # either we have a sequence header left over from the\n    # prev call, or we need to read a new one from the file...\n    # try to do that now\n    name, prevLine = fastq_complex_parse_seq_header(fh, prevLine,\n                                                    pind, verbose)\n\n    # read lines until we hit a qual header --> this is our sequence data\n    seqdata, line = fastq_complex_parse_seq(fh, pind, verbose)\n\n    # <line> is now a qual header, keep reading until we see\n    # a sequence header.. or we run out of lines.. this is our quality data\n    qualdata, line, prevLine = fastq_complex_parse_qual(fh, line, prevLine,\n                                                        verbose, pind)\n\n    # package it all up..\n    yield NGSRead(seqdata, name, qualdata, useMutableString)\n    if verbose:\n      pind.showProgress()\n\n    # remember where we stopped for next call, or finish\n    prevLine = line\n    if prevLine == \"\":\n      break", "response": "Returns a generator function which yields FastqSequence objects from a file or a string stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts an S3 resource name in the form s3://bucket/key to a tuple containing bucket and key.", "response": "def resource_to_bucket_and_key(resource_name):\n        \"\"\"\n        S3Meterer.resource_to_bucket_and_key(resource_name) -> (str, str)\n\n        Convert an S3 resource name in the form 's3://bucket/key' to a tuple\n        of ('bucket', 'key').\n        \"\"\"\n        if not resource_name.startswith(S3Meterer.s3_url_prefix):\n            raise ValueError(\"Expected resource_name to start with %s\" %\n                             S3Meterer.s3_url_prefix)\n\n        s3_bucket_and_key = resource_name[len(S3Meterer.s3_url_prefix):]\n\n        try:\n            bucket, key = s3_bucket_and_key.split(\"/\", 1)\n            if not bucket:\n                raise ValueError(\"Bucket name cannot be empty in URL %r\" %\n                                 resource_name)\n\n            return (bucket, key)\n        except ValueError:\n            raise ValueError(\"No key specified in URL %r\" % resource_name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef during(rrule, duration=None, timestamp=None, **kwargs):\n\n    result = False\n\n    # if rrule is a string expression\n    if isinstance(rrule, string_types):\n        rrule_object = rrule_class.rrulestr(rrule)\n\n    else:\n        rrule_object = rrule_class(**rrule)\n\n    # if timestamp is None, use now\n    if timestamp is None:\n        timestamp = time()\n\n    # get now object\n    now = datetime.fromtimestamp(timestamp)\n\n    # get delta object\n    duration_delta = now if duration is None else relativedelta(**duration)\n\n    # get last date\n    last_date = rrule_object.before(now, inc=True)\n\n    # if a previous date exists\n    if last_date is not None:\n        next_date = last_date + duration_delta\n\n        # check if now is between last_date and next_date\n        result = last_date <= now <= next_date\n\n    return result", "response": "Check if input timestamp is in rrule + duration period."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _any(confs=None, **kwargs):\n\n    result = False\n\n    if confs is not None:\n        # ensure confs is a list\n        if isinstance(confs, string_types) or isinstance(confs, dict):\n            confs = [confs]\n        for conf in confs:\n            result = run(conf, **kwargs)\n            if result:  # leave function as soon as a result if True\n                break\n\n    return result", "response": "True if at least one input condition is equivalent to True. False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if all input confs are True.", "response": "def _all(confs=None, **kwargs):\n    \"\"\"\n    True iif all input confs are True.\n\n    :param confs: confs to check.\n    :type confs: list or dict or str\n    :param kwargs: additional task kwargs.\n\n    :return: True if all conditions are checked. False otherwise.\n    :rtype: bool\n    \"\"\"\n\n    result = False\n\n    if confs is not None:\n        # ensure confs is a list\n        if isinstance(confs, string_types) or isinstance(confs, dict):\n            confs = [confs]\n        # if at least one conf exists, result is True by default\n        result = True\n        for conf in confs:\n            result = run(conf, **kwargs)\n            # stop when a result is False\n            if not result:\n                break\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _not(condition=None, **kwargs):\n\n    result = True\n\n    if condition is not None:\n        result = not run(condition, **kwargs)\n\n    return result", "response": "Return the opposite of input condition."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef condition(condition=None, statement=None, _else=None, **kwargs):\n\n    result = None\n\n    checked = False\n\n    if condition is not None:\n        checked = run(condition, **kwargs)\n\n    if checked:  # if condition is checked\n        if statement is not None:  # process statement\n            result = run(statement, **kwargs)\n\n    elif _else is not None:  # else process _else statement\n        result = run(_else, **kwargs)\n\n    return result", "response": "Run an arbitrary statement if input condition is checked and return statement result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef switch(\n        confs=None, remain=False, all_checked=False, _default=None, **kwargs\n):\n    \"\"\"\n    Execute first statement among conf where task result is True.\n    If remain, process all statements conf starting from the first checked\n    conf.\n\n    :param confs: task confs to check. Each one may contain a task action at\n        the key 'action' in conf.\n    :type confs: str or dict or list\n    :param bool remain: if True, execute all remaining actions after the\n        first checked condition.\n    :param bool all_checked: execute all statements where conditions are\n        checked.\n    :param _default: default task to process if others have not been checked.\n    :type _default: str or dict\n\n    :return: statement result or list of statement results if remain.\n    :rtype: list or object\n    \"\"\"\n\n    # init result\n    result = [] if remain else None\n\n        # check if remain and one task has already been checked.\n    remaining = False\n\n    if confs is not None:\n        if isinstance(confs, string_types) or isinstance(confs, dict):\n            confs = [confs]\n\n        for conf in confs:\n            # check if task has to be checked or not\n            check = remaining\n\n            if not check:\n                # try to check current conf\n                check = run(conf=conf, **kwargs)\n\n            # if task is checked or remaining\n            if check:\n\n                if STATEMENT in conf:  # if statements exist, run them\n                    statement = conf[STATEMENT]\n                    statement_result = run(statement, **kwargs)\n\n                    # save result\n                    if not remain:  # if not remain, result is statement_result\n                        result = statement_result\n\n                    else:  # else, add statement_result to result\n                        result.append(statement_result)\n\n                # if remain\n                if remain:\n                    # change of remaining status\n                    if not remaining:\n                        remaining = True\n\n                elif all_checked:\n                    pass\n\n                else:  # leave execution if one statement has been executed\n                    break\n\n    # process _default statement if necessary\n    if _default is not None and (remaining or (not result) or all_checked):\n        last_result = run(_default, **kwargs)\n\n        if not remain:\n            result = last_result\n\n        else:\n            result.append(last_result)\n\n    return result", "response": "Execute all statements in the specified list of confs and return the result of the statement."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\noverrides error to control printing output", "response": "def error(self, message):\n        \"\"\"Overrides error to control printing output\"\"\"\n        if self._debug:\n            import pdb\n            _, _, tb = sys.exc_info()\n            if tb:\n                pdb.post_mortem(tb)\n            else:\n                pdb.set_trace()\n        self.print_usage(sys.stderr)\n        self.exit(2, ('\\nERROR: {}\\n').format(message))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef format_help(self):\n        formatter = self._get_formatter()\n\n        # usage\n        formatter.add_usage(self.usage, self._actions,\n                            self._mutually_exclusive_groups)\n\n        # description\n        formatter.add_text(self.description)\n\n        # positionals, optionals and user-defined groups, except SubParsers\n        for action_group in self._action_groups:\n            if is_subparser(action_group):\n                continue\n            formatter.start_section(action_group.title)\n            formatter.add_text(action_group.description)\n            formatter.add_arguments(action_group._group_actions)\n            formatter.end_section()\n\n        # epilog\n        formatter.add_text(self.epilog)\n\n        # determine help from format above\n        return formatter.format_help()", "response": "Override format_help to not print subparsers"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nopening the attributes file for the current instance of this object.", "response": "def open_attributes_file(self):\n        '''\n        Called during initialization. Only needs to be explicitly\n        called if save_and_close_attributes is explicitly called\n        beforehand.\n        '''\n        if not self.saveable():\n            raise AttributeError(\"Cannot open attribute file without a valid file\")\n        if self._db_closed:\n            self._fd = FileDict(self._file_name, db_ext=self._db_ext,\n                                   read_only=self._read_only, clear=False, cache_size=0,\n                                   immutable_vals=False, stringify_keys=False,\n                                   cache_misses=False)\n            self._db_closed = False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave the attributes of the current object to the database.", "response": "def save_attributes(self):\n        '''\n        Saves the attributes without closing the attributes file.\n        This should probably be called after the attribute holder\n        sets/overrides the attributes in initialization as the del\n        method is not guaranteed to be called.\n        '''\n        if not self.saveable():\n            raise AttributeError(\"Cannot save attribute file without a valid file\")\n        if self._read_only:\n            raise AttributeError(\"Cannot save read-only data\")\n        if not self._db_closed:\n            self._fd.clear()\n            for attr_name in self._saved_attrs:\n                self._fd[attr_name] = getattr(self._target, attr_name)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform the same function as save_attributes but also closes the attribute file.", "response": "def save_and_close_attributes(self):\n        '''\n        Performs the same function as save_attributes but also closes\n        the attribute file.\n        '''\n        if not self.saveable():\n            raise AttributeError(\"Cannot save attribute file without a valid file\")\n        if not self._db_closed:\n            self._db_closed = True\n            if not self._read_only:\n                self.save_attributes()\n            self._fd.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef split_task_parameters(line):\n    if line is None:\n        result = []\n    else:\n        result = [parameter.strip() for parameter in line.split(\",\")]\n    return result", "response": "Split a string of comma separated words."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_tasks(lines):\n    tasks = []\n    linenumbers = []\n    pattern = re.compile(TASK_PATTERN)\n    for n, line in enumerate(lines):\n        if \"#\" in line and \"<-\" in line:\n            m = pattern.match(line)\n            if m is not None:\n                groupdict = m.groupdict()\n                linenumbers.append(n)\n                for key in groupdict:\n                    groupdict[key] = split_task_parameters(groupdict[key])\n                    logging.debug(\n                        \"{0}: {1}\".format(key, \", \".join(groupdict[key])))\n                tasks.append(groupdict)\n    linenumbers.append(len(lines))\n    return tasks, linenumbers", "response": "Find task lines and corresponding line numbers in a list of lines."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a dictionary of variables obtained from the preamble of the task file and the environment that the program is running on.", "response": "def create_environment(preamble):\n    \"\"\"\n    Create a dictionary of variables obtained from the preamble of\n    the task file and the environment the program is running on.\n    \"\"\"\n    environment = copy.deepcopy(os.environ)\n    for line in preamble:\n        logging.debug(line)\n        if \"=\" in line and not line.startswith(\"#\"):\n            tmp = line.split(\"=\")\n            key = tmp[0].strip()\n            value = tmp[1].strip()\n            logging.debug(\n                \"Found variable {} with value {}\".format(key, value))\n            environment.update({key: value})\n    logging.debug(\"Env {}\".format(environment))\n    return environment"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_input_file(text, variables=None):\n    text = find_includes(text)\n    lines = text.splitlines()\n    tasks, linenumbers = find_tasks(lines)\n    preamble = [line for line in lines[:linenumbers[0]]]\n    logging.debug(\"Preamble:\\n{}\".format(\"\\n\".join(preamble)))\n    if variables is not None:\n        preamble += \"\\n\" + \"\\n\".join(variables)\n    environment = create_environment(preamble)\n    code_sections = []\n    for n in range(len(linenumbers) - 1):\n        code_sections.append((linenumbers[n], linenumbers[n+1]))\n    for n, task in zip(code_sections, tasks):\n        task[\"code\"] = lines[n[0]: n[1]]\n        task[\"environment\"] = environment\n    clean_tasks = []\n    for task in tasks:\n        clean_tasks.append(Task(**task))\n    return clean_tasks", "response": "Parser for a file with syntax somewhat similar to Drake."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _to_fields(self, *values):\n        result = []\n        for related_instance in values:\n            if not isinstance(related_instance, model.RedisModel):\n                related_instance = self.related_field._model(related_instance)\n            result.append(getattr(related_instance, self.related_field.name))\n        return result", "response": "Takes a list of values and returns a list of related fields."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreversing call to the related_method on each value in the set of related items.", "response": "def _reverse_call(self, related_method, *values):\n        \"\"\"\n        Convert each value to a related field, then call the method on each\n        field, passing self.instance as argument.\n        If related_method is a string, it will be the method of the related field.\n        If it's a callable, it's a function which accept the related field and\n        self.instance.\n        \"\"\"\n        related_fields = self._to_fields(*values)\n        for related_field in related_fields:\n            if callable(related_method):\n                related_method(related_field, self.instance._pk)\n            else:\n                getattr(related_field, related_method)(self.instance._pk)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndoing a set call with self. instance as parameter for each value. Values must be primary keys of the related model.", "response": "def srem(self, *values):\n        \"\"\"\n        Do a \"set\" call with self.instance as parameter for each value. Values\n        must be primary keys of the related model.\n        \"\"\"\n        self._reverse_call(lambda related_field, value: related_field.delete(), *values)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef lrem(self, *values):\n        self._reverse_call(lambda related_field, value: related_field.lrem(0, value), *values)", "response": "Do a lrem call with self. instance as parameter for each value. Values are the primary keys of the related model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd the values of the related objects to the set.", "response": "def zadd(self, *args, **kwargs):\n        \"\"\"\n        For each score/value given as paramter, do a \"zadd\" call with\n        score/self.instance as parameter call for each value. Values must be\n        primary keys of the related model.\n        \"\"\"\n        if 'values_callback' not in kwargs:\n            kwargs['values_callback'] = self._to_fields\n        pieces = fields.SortedSetField.coerce_zadd_args(*args, **kwargs)\n        for (score, related_field) in zip(*[iter(pieces)] * 2):\n            related_method = getattr(related_field, 'zadd')\n            related_method(score, self.instance._pk, values_callback=None)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef arg_comparitor(name):\n    if name.endswith(\"__in\"):\n        return name[:-4], contains\n    elif name.endswith(\"__ge\"):\n        return name[:-4], ge\n    elif name.endswith(\"__gt\"):\n        return name[:-4], gt\n    elif name.endswith(\"__le\"):\n        return name[:-4], le\n    elif name.endswith(\"__lt\"):\n        return name[:-4], lt\n    if name.endswith(\"__eq\"):\n        return name[:-4], eq\n    if name.endswith(\"__ne\"):\n        return name[:-4], ne\n    else:\n        return name, eq", "response": "returns a proper comparitor for the given argument name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef arg_match(m_arg, arg, comparator=eq, default=False):\n    if m_arg is None:\n        return default\n    if isinstance(m_arg, dict):\n        for name, value in m_arg.items():\n            name, _comparator = arg_comparitor(name)\n            subarg = getattr(arg, name, InvalidArg)\n            if subarg is InvalidArg:\n                return subarg\n            matched = arg_match(subarg, value, _comparator, default)\n            if not matched or matched is InvalidArg:\n                return False\n        return True\n    else:\n        if hasattr(m_arg, \"__call__\"):\n            return m_arg(arg)\n        else:\n            return comparator(arg, m_arg)", "response": "returns True if m_arg matches arg False otherwise"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef args_match(m_args, m_kwargs, default, *args, **kwargs):\n    if len(m_args) > len(args):\n        return False\n    for m_arg, arg in zip(m_args, args):\n        matches = arg_match(m_arg, arg, eq)\n        if not matches or matches is InvalidArg:\n            return False  # bail out\n\n    if m_kwargs:\n        for name, m_arg in m_kwargs.items():\n            name, comparator = arg_comparitor(name)\n            arg = kwargs.get(name)\n            if not arg_match(m_arg, arg, comparator, default):\n                return False  # bail out\n    return True", "response": "Returns True if all the arguments match."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef loaded(self, request, *args, **kwargs):\n        serializer = self.get_serializer(list(Pack.objects.all()),\n                                         many=True)\n        return Response(serializer.data)", "response": "Return a list of loaded Packs."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of available ( unloaded ) Pack names.", "response": "def available(self, request, *args, **kwargs):\n        \"\"\"Return a list of available (unloaded) Pack names.\n        \"\"\"\n        packs = []\n        for pack_name in get_available_pack_names():\n            packs.append(pack_name)\n        return Response(packs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef indexed_file(self, f):\n    filename, handle = f\n    if handle is None and filename is not None:\n      handle = open(filename)\n    if (handle is None and filename is None) or \\\n       (filename != self._indexed_filename) or \\\n       (handle != self._indexed_file_handle):\n      self.index = {}\n    if ((handle is not None or filename is not None) and\n       (self.record_iterator is None or self.record_hash_function is None)):\n      raise IndexError(\"Setting index file failed; reason: iterator \"\n                       \"(self.record_iterator) or hash function \"\n                       \"(self.record_hash_function) have to be set first\")\n    self._indexed_filename = filename\n    self._indexed_file_handle = handle", "response": "Sets the index for the file this object indexes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __build_index(self, until=None, flush=False, verbose=False):\n    assert(self._indexed_file_handle is not None)\n    if flush:\n      self._index = {}\n\n    file_loc = self._indexed_file_handle.tell()\n\n    if verbose:\n      self._indexed_file_handle.seek(0, 2)  # seek to end\n      total = self._indexed_file_handle.tell() - file_loc\n      self._indexed_file_handle.seek(file_loc)  # back to where we were\n      pind = ProgressIndicator(totalToDo=total,\n                               messagePrefix=\"completed\",\n                               messageSuffix=\"of building out index\")\n\n    for item in self.record_iterator(self._indexed_file_handle):\n      hash_val = self.record_hash_function(item)\n      self._index[hash_val] = file_loc\n      file_loc = self._indexed_file_handle.tell()\n      if until is not None and hash_val == until:\n        break\n      if verbose:\n        pind.done = file_loc\n        pind.showProgress()", "response": "Builds the index for this file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting this index to a file.", "response": "def write_index(self, fh, to_str_func=str, generate=True, verbose=False):\n    \"\"\"\n    Write this index to a file.\n\n    Only the index dictionary itself is stored, no informatiom about the\n    indexed file, or the open filehandle is retained. The Output format is\n    just a tab-separated file, one record per line. The last column is the\n    file location for the record and all columns before that are collectively\n    considered to be the hash key for that record (which is probably only 1\n    column, but this allows us to permit tabs in hash keys).\n\n    :param fh:           either a string filename or a stream-like object to\n                         write to.\n    :param to_str_func:  a function to convert hash values to strings. We'll\n                         just use str() if this isn't provided.\n    :param generate:     build the full index from the indexed file if it\n                         hasn't already been built. This is the default, and\n                         almost certainly what you want, otherwise just the\n                         part of the index already constructed is written\n                         (which might be nothing...)\n    :param verbose:      if True, output progress messages to stderr.\n    \"\"\"\n    try:\n      handle = open(fh, \"w\")\n    except TypeError:\n      # okay, not a filename, try to treat it as a stream to write to.\n      handle = fh\n    if generate:\n      self.__build_index(verbose=verbose)\n    for key in self._index:\n      handle.write(to_str_func(key) + \"\\t\" + str(self._index[key]) + \"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_index(self, fh, indexed_fh, rec_iterator=None,\n                 rec_hash_func=None, parse_hash=str, flush=True,\n                 no_reindex=True, verbose=False):\n    \"\"\"\n    Populate this index from a file. Input format is just a tab-separated file,\n    one record per line. The last column is the file location for the record\n    and all columns before that are collectively considered to be the hash key\n    for that record (which is probably only 1 column, but this allows us to\n    permit tabs in hash keys). Lines consisting only of whitespace are skipped.\n\n    :param fh:            filename or stream-like object to read from.\n    :param indexed_fh:    either the filename of the indexed file or handle to\n                          it.\n    :param rec_iterator:  a function that will return an interator for the\n                          indexed file type (not the iterator for the file\n                          itself). This function must take a single argument\n                          which is the name the file to iterate over, or a\n                          stream like object similar to a filestream.\n    :param rec_hash_func: a function that accepts the record type produced by\n                          the iterator and produces a unique hash for each\n                          record.\n    :param parse_hash:    a function to convert the string representation of\n                          the hash into whatever type is needed. By default,\n                          we just leave these as strings.\n    :param flush:         remove everything currently in the index and discard\n                          any details about a file that is already\n                          fully/partially indexed by this object. This is the\n                          default behavior. If False, then data from <fh> is\n                          just added to the existing index data (potentially\n                          overwriting some of it) and the existing index can\n                          continue to be used as before.\n    :param no_reindex:    if True, after loading the index, a missing key will\n                          cause an exception, rather than trigger re-scanning\n                          the indexed file for the associated record. The only\n                          reason to set this to False would be if your index\n                          was incomplete.\n    :param verbose:       output status message to STDERR about progress\n                          reading the index (if possible).\n\n    :raise IndexError: on malformed line in input file/stream\n    \"\"\"\n    # set the record iterator and hash functions, if they were given\n    if rec_iterator is not None:\n      self.record_iterator = rec_iterator\n    if rec_hash_func is not None:\n      self.record_hash_function = rec_hash_func\n\n    # disable re-indexing?\n    self._no_reindex = no_reindex\n\n    # figure out what kind of index identifier we got: handle or filename?\n    handle = fh\n    try:\n      handle = open(fh)\n    except TypeError:\n      # okay, not a filename, we'll try treating it as a stream to read from.\n      pass\n\n    # clear this index?\n    if flush:\n      self._index = {}\n      self._indexed_file_handle = None\n      self._indexed_file_name = None\n\n    # replace the name/handle for the indexed file\n    indexed_fn = None\n    try:\n      # try treating this as a filename\n      self.indexed_file = (indexed_fh, None)\n      indexed_fn = indexed_fh\n    except TypeError:\n      try:\n        # try treating this as a file handle\n        self.indexed_file = (None, indexed_fh)\n      except TypeError:\n        fn = \" from \" + str(fh) if indexed_fn is not None else \"\"\n        raise IndexError(\"failed to read index\" + fn + \"; \"\n                         \"reason: expected indexed filename or stream-like \"\n                         \"object, got \" + str(type(indexed_fh)))\n\n    # try to get an idea of how much data we have...\n    if verbose:\n      try:\n        total = os.path.getsize(handle.name)\n        pind = ProgressIndicator(totalToDo=total, messagePrefix=\"completed\",\n                                 messageSuffix=\"of loading \" + handle.name)\n      except AttributeError as e:\n        sys.stderr.write(str(e))\n        sys.stderr.write(\"completed [unknown] of loading index\")\n        verbose = False\n\n    # read the index file and populate this object\n    for line in handle:\n      line = line.rstrip()\n\n      if verbose:\n        pind.done = handle.tell()\n        pind.showProgress()\n\n      if line.isspace():\n        continue\n      parts = line.split(\"\\t\")\n      if len(parts) < 2:\n        raise IndexError(\"failed to parse line: '\" + line + \"'\")\n      key = parse_hash(\"\\t\".join(parts[:-1]))\n      value = parts[-1]\n      self._index[key] = int(value)", "response": "Populate the index from a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef steps(self):\n        def _iter(uri, acc):\n            acc.appendleft(uri.name if uri.name else '')\n            return _iter(uri.parent, acc) if uri.parent else acc\n        return _iter(self, acc=deque())", "response": "Returns an iterable containing the steps to this Uri from the root Uri including the root Uri."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(cls, addr):\n        if addr.endswith('/'):\n            raise ValueError(\"Uris must not end in '/'\")  # pragma: no cover\n        parts = addr.split('/')\n        if ':' in parts[0]:\n            node, parts[0] = parts[0], ''\n        else:\n            node = None\n\n        ret = None  # Uri(name=None, parent=None, node=node) if node else None\n        for step in parts:\n            ret = Uri(name=step, parent=ret, node=node)\n            node = None  # only set the node on the root Uri\n        return ret", "response": "Parses a string representation of a URI into a new Uri instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef scopes_as(self, new_scopes):\n        old_scopes, self.scopes = self.scopes, new_scopes\n        yield\n        self.scopes = old_scopes", "response": "Replace my scope with new_scopes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef new_scope(self, new_scope={}):\n        old_scopes, self.scopes = self.scopes, self.scopes.new_child(new_scope)\n        yield\n        self.scopes = old_scopes", "response": "Add a new innermost scope for the duration of the with block."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef new(self, val):\n        if len(self.things) >= self.max_things:\n            raise LimitationError('too many things')\n        self.things.add(val)\n        return val", "response": "Add a new value to me."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef new_child(self):\n        child = Environment(self.globals, self.max_things)\n        child.scopes = self.scopes.new_child()\n        child.things = WeakSet(self.things)\n        return child", "response": "Get a new child Environment."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef eval(self, expr):\n        if self.depth >= self.max_depth:\n            raise LimitationError('too much nesting')\n        if self.steps >= self.max_steps:\n            raise LimitationError('too many steps')\n        self.depth += 1\n        self.steps += 1\n        res = expr.eval(self)\n        self.depth -= 1\n        return res", "response": "Evaluate an expression. This does not add its argument to the object. This does not add it to the object. This does not add its argument to the object. This does not add it to the object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef devnull():\n\n    try:\n        original_stderr = os.dup(sys.stderr.fileno())\n        original_stdout = os.dup(sys.stdout.fileno())\n        null = open(os.devnull, 'w')\n        os.dup2(null.fileno(), sys.stderr.fileno())\n        os.dup2(null.fileno(), sys.stdout.fileno())\n        yield\n\n    finally:\n        if original_stderr is not None:\n            os.dup2(original_stderr, sys.stderr.fileno())\n        if original_stdout is not None:\n            os.dup2(original_stdout, sys.stdout.fileno())\n        if null is not None:\n            null.close()", "response": "Temporarily redirect stdout and stderr to / dev / null."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndisplays error message via stderr or GUI.", "response": "def error(*args):\n    \"\"\"Display error message via stderr or GUI.\"\"\"\n    if sys.stdin.isatty():\n        print('ERROR:', *args, file=sys.stderr)\n    else:\n        notify_error(*args)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef failure(path, downloader):\n    base = os.path.basename(path)\n    if sys.stdin.isatty():\n        print('INFO [{}]: Failed to download {!r}'.format(downloader, base))\n    else:\n        notify_failure(base, downloader)", "response": "Display a failure message via stderr or GUI."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef have(cmd):\n\n    try:\n        # Python 3.3+ only\n        from shutil import which\n    except ImportError:\n        def which(cmd):\n            \"\"\"\n            Given a command, return the path which conforms to the given mode\n            on the PATH, or None if there is no such file.\n            \"\"\"\n\n            def _access_check(path):\n                \"\"\"\n                Check that a given file can be accessed with the correct mode.\n                Additionally check that `path` is not a directory.\n                \"\"\"\n                return (os.path.exists(path) and os.access(\n                    path, os.F_OK | os.X_OK) and not os.path.isdir(path))\n\n            # If we're given a path with a directory part, look it up directly\n            # rather than referring to PATH directories. This includes checking\n            # relative to the current directory, e.g. ./script\n            if os.path.dirname(cmd):\n                if _access_check(cmd):\n                    return cmd\n                return None\n\n            paths = os.environ.get('PATH', os.defpath.lstrip(':')).split(':')\n\n            seen = set()\n            for path in paths:\n                if path not in seen:\n                    seen.add(path)\n                    name = os.path.join(path, cmd)\n                    if _access_check(name):\n                        return name\n            return None\n\n    return which(cmd) is not None", "response": "Determine whether the supplied argument is a command on the PATH."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexecutes multiple processes at once.", "response": "def multithreader(args, paths):\n    \"\"\"Execute multiple processes at once.\"\"\"\n\n    def shellprocess(path):\n        \"\"\"Return a ready-to-use subprocess.\"\"\"\n        import subprocess\n        return subprocess.Popen(args + [path],\n                                stderr=subprocess.DEVNULL,\n                                stdout=subprocess.DEVNULL)\n\n    processes = [shellprocess(path) for path in paths]\n\n    for process in processes:\n        process.wait()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse command - line arguments and return options and arguments.", "response": "def parse(args, epilog):\n    \"\"\"\n    Parse command-line arguments. Arguments may consist of any\n    combination of directories, files, and options.\n    \"\"\"\n\n    import argparse\n    from locale import getlocale\n\n    # set the default language\n    default_language = getlocale()[0].split('_')[0].lower()\n\n    parser = argparse.ArgumentParser(\n        add_help=False,\n        description=__description__,\n        epilog=epilog,\n        prog=__program__,\n        usage='%(prog)s [OPTIONS] FILES|FOLDERS')\n    parser.add_argument(\n        '-d', '--downloader',\n        default=Config.DOWNLOADER_DEFAULT,\n        dest='downloader',\n        help='indicate downloader to use')\n    parser.add_argument(\n        '-l', '--language',\n        default=default_language,\n        dest='language',\n        help='indicate language to use [{}]'.format(default_language))\n    parser.add_argument(\n        '-q', '--quiet',\n        action='store_true',\n        dest='quiet',\n        help='do not display failure notifications via notify-send')\n    parser.add_argument(\n        '-r', '--rename',\n        action='store_true',\n        dest='rename',\n        help='prompt to rename video files')\n    parser.add_argument(\n        '-s', '--scan',\n        action='store_true',\n        dest='scan',\n        help='remove advertising from subtitle files')\n    parser.add_argument(\n        '-h', '--help',\n        action='help',\n        help=argparse.SUPPRESS)\n    parser.add_argument(\n        '--version',\n        action='version',\n        version='%(prog)s ' + __version__)\n    parser.add_argument(\n        action='append',\n        dest='targets',\n        help=argparse.SUPPRESS,\n        nargs='*')\n\n    options = parser.parse_args(args)\n    arguments = options.targets[0]\n\n    return options, arguments"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prompt_gui(path):\n\n    import subprocess\n\n    filepath, extension = os.path.splitext(path)\n    basename = os.path.basename(filepath)\n    dirname = os.path.dirname(filepath)\n\n    retry_text = 'Sorry, please try again...'\n    icon = 'video-x-generic'\n\n    # detect and configure dialog program\n    if have('yad'):\n        args = ['yad',\n                '--borders=5',\n                '--entry',\n                '--entry-label=Filename:',\n                '--entry-text=' + basename,\n                '--title=Batch Tool',\n                '--window-icon=' + icon]\n        retry_args = args + ['--text=<b>' + retry_text + '</b>',\n                             '--text-align=center']\n\n    elif have('zenity'):\n        base = ['zenity',\n                '--entry',\n                '--entry-text=' + basename,\n                '--title=Batch Tool',\n                '--window-icon=info']\n        args = base + ['--text=Filename:']\n        retry_args = base + ['--text=' + retry_text]\n\n    else:\n        fatal('Please install yad (or zenity)')\n\n    # display filename prompt\n    try:\n        new_basename = subprocess.check_output(\n            args, universal_newlines=True).strip()\n    except subprocess.CalledProcessError:\n        sys.exit(1)\n\n    # retry prompt if new filename already exists\n    while os.path.exists(os.path.join(dirname, new_basename + extension)) and \\\n            new_basename != basename:\n        try:\n            new_basename = subprocess.check_output(\n                retry_args, universal_newlines=True).strip()\n        except subprocess.CalledProcessError:\n            sys.exit(1)\n\n    if new_basename == '':\n        new_basename = basename\n\n    return os.path.join(dirname, new_basename + extension)", "response": "Prompt for a new filename via GUI."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprompting for a new filename via terminal.", "response": "def prompt_terminal(path):\n    \"\"\"Prompt for a new filename via terminal.\"\"\"\n\n    def rlinput(prompt_msg, prefill=''):\n        \"\"\"\n        One line is read from standard input. Display `prompt_msg` on\n        standard error. `prefill` is placed into the editing buffer\n        before editing begins.\n        \"\"\"\n        import readline\n        readline.set_startup_hook(lambda: readline.insert_text(prefill))\n        try:\n            return input(prompt_msg)\n        finally:\n            readline.set_startup_hook()\n\n    filepath, extension = os.path.splitext(path)\n    basename = os.path.basename(filepath)\n    dirname = os.path.dirname(filepath)\n\n    # display filename prompt\n    new_basename = rlinput('Filename: ', basename)\n\n    # retry prompt if new filename already exists\n    while os.path.exists(os.path.join(dirname, new_basename + extension)) and \\\n            new_basename != basename:\n        new_basename = rlinput('Sorry, please try again... Filename: ',\n                               basename)\n\n    if new_basename == '':\n        new_basename = basename\n\n    return os.path.join(dirname, new_basename + extension)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrename a file if necessary.", "response": "def rename(path):\n    \"\"\"Rename a file if necessary.\"\"\"\n\n    new_path = prompt(path)\n\n    if path != new_path:\n        try:\n            from shutil import move\n        except ImportError:\n            from os import rename as move\n\n        move(path, new_path)\n\n    return new_path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nscanning the subtitles for advertising and return the next available subtitle.", "response": "def scan(subtitles):\n    \"\"\"Remove advertising from subtitles.\"\"\"\n\n    from importlib.util import find_spec\n\n    try:\n        import subnuker\n    except ImportError:\n        fatal('Unable to scan subtitles. Please install subnuker.')\n\n    # check whether aeidon is available\n    aeidon = find_spec('aeidon') is not None\n\n    if sys.stdin.isatty():\n        # launch subnuker from the existing terminal\n        args = (['--aeidon'] if aeidon else []) + \\\n            ['--gui', '--regex'] + subtitles\n        subnuker.main(args)\n    else:\n        # launch subnuker from a new terminal\n        args = (['--aeidon'] if aeidon else []) + \\\n            ['--gui', '--regex']\n        execute(Config.TERMINAL,\n                '--execute',\n                'subnuker',\n                *args + subtitles)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndisplay warning message via stderr or GUI.", "response": "def warning(*args):\n    \"\"\"Display warning message via stderr or GUI.\"\"\"\n    if sys.stdin.isatty():\n        print('WARNING:', *args, file=sys.stderr)\n    else:\n        notify_warning(*args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getavailable(self):\n\n        from importlib import import_module\n\n        available = []\n\n        for script in self.SCRIPTS:\n            if have(script):\n                available.append(script)\n\n        for module in self.MODULES:\n            try:\n                import_module(module)\n                available.append(module)\n            except ImportError:\n                pass\n\n        return sorted(available)", "response": "Return a list of subtitle downloaders available."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getdefault(self):\n\n        if not self.available:\n            error('No supported downloaders available')\n            print('\\nPlease install one of the following:', file=sys.stderr)\n            print(self.SUPPORTED, file=sys.stderr)\n            sys.exit(1)\n\n        default = Config.DOWNLOADER_DEFAULT\n\n        if default in self.available:\n            return default\n        else:\n            alternative = self.available[0]\n            warning('Default downloader {!r} not available, using {!r} instead'\n                    .format(Config.DOWNLOADER_DEFAULT, alternative))\n            return alternative", "response": "Return an available default downloader."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndownload subtitles via a number of tools.", "response": "def download(self, paths, tool, language):\n        \"\"\"Download subtitles via a number of tools.\"\"\"\n\n        if tool not in self.available:\n            fatal('{!r} is not installed'.format(tool))\n\n        try:\n            from . import plugins\n            downloader = plugins.__getattribute__(tool)\n        except AttributeError:\n            fatal('{!r} is not a supported download tool'.format(tool))\n\n        try:\n            if downloader.__code__.co_argcount is 2:\n                downloader(paths, language)\n            elif downloader.__code__.co_argcount is 1:\n                downloader(paths)\n        except:  # pylint: disable=bare-except\n            if not check_connectivity():\n                error('Internet connectivity appears to be disabled')\n            else:\n                error('{!r} experienced an unknown error'.format(tool))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning text formatted for the usage description s epilog.", "response": "def epilog(self):\n        \"\"\"Return text formatted for the usage description's epilog.\"\"\"\n\n        bold = '\\033[1m'\n        end = '\\033[0m'\n        available = self.available.copy()\n        index = available.index(Config.DOWNLOADER_DEFAULT)\n        available[index] = bold + '(' + available[index] + ')' + end\n        formatted = '  |  '.join(available)\n        return 'Downloaders available: ' + formatted"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef use_mock(self, mock, *args, **kwarg):\n        return UseMockDefinition(mock, self, *args, **kwarg)", "response": "Decorator to use a coroutine as mock of service\n        endpoint in a test."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new mock object.", "response": "def _create_mock(self, endpoint_desc, session, request_params, mock_desc, loop):\n        \"\"\"\n        The class imported should have the __call__ function defined to be an object directly callable\n        \"\"\"\n        try:\n            mock_def = mock_manager.next_mock(self.service_client.name,\n                                              endpoint_desc['endpoint'])\n\n            if isinstance(mock_def, PatchMockDescDefinition):\n                mock_desc.update(mock_def.patch)\n            else:\n                return mock_def.mock\n        except NoMock:\n            pass\n\n        return self.loader.factory(mock_desc.get('mock_type'),\n                                   endpoint_desc, session,\n                                   request_params, mock_desc,\n                                   loop=loop)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting up the acl user group and dynamic groups plugin to hold all intranet users and addable types for the ploneintranet policy", "response": "def post_install(context):\n    \"\"\"\n    - sets an acl user group to hold all intranet users\n    - setup the dynamic groups plugin\n    - sets the addable types for the ploneintranet policy\n    \"\"\"\n    marker = 'ploneintranet-workspace.marker'\n    if context.readDataFile(marker) is None:\n        return\n\n    portal = api.portal.get()\n\n    # Set up a group to hold all intranet users\n    if api.group.get(groupname=INTRANET_USERS_GROUP_ID) is None:\n        api.group.create(groupname=INTRANET_USERS_GROUP_ID)\n        # All users have Reader role on portal root\n        api.group.grant_roles(groupname=INTRANET_USERS_GROUP_ID,\n                              roles=['Reader', ],\n                              obj=portal)\n\n    # Set up dynamic groups plugin to put all users into the above group\n    pas = api.portal.get_tool('acl_users')\n    if DYNAMIC_GROUPS_PLUGIN_ID not in pas.objectIds():\n        addDynamicGroupsPlugin(\n            pas,\n            DYNAMIC_GROUPS_PLUGIN_ID,\n            \"ploneintranet.workspace Dynamic Groups\"\n        )\n        plugin = pas[DYNAMIC_GROUPS_PLUGIN_ID]\n        plugin.addGroup(\n            group_id=INTRANET_USERS_GROUP_ID,\n            predicate='python: True',\n            title='All Intranet Users',\n            description='',\n            active=True,\n        )\n        # activate the plugin (all interfaces)\n        activatePluginInterfaces(portal, DYNAMIC_GROUPS_PLUGIN_ID)\n\n    # deactivate the enumerate groups interface for collective.workspace\n    activatePluginInterfaces(portal, 'workspace_groups',\n                             disable=['IGroupEnumerationPlugin'])\n\n    # Set up the ploneintranet policy for all addable types\n    default_types = []\n    types = api.portal.get_tool('portal_types')\n    for type_info in types.listTypeInfo():\n        if type_info.global_allow:\n            default_types.append(type_info.getId())\n\n    if default_types:\n        pwftool = api.portal.get_tool('portal_placeful_workflow')\n        policy = pwftool['ploneintranet_policy']\n        policy.setChainForPortalTypes(default_types, ('(Default)',))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nabstract method to check if a value is correct ( type. Should raise TypeError if the type is wrong.", "response": "def validate(self, value):\n        \"\"\" Abstract method, check if a value is correct (type).\n        Should raise :class:`TypeError` if the type the validation fail.\n        \n        :param value: the value to validate\n        :return: the given value (that may have been converted)\n        \"\"\"\n        for validator in self.validators:\n            errors = []\n            try:\n                validator(value)\n            except ValidationError as err:\n                errors.append(err)\n            if errors:\n                raise ValidationError(errors)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef as_dict(self):\n        info = {}\n        info[\"type\"] = self.__class__.__name__\n        info[\"help\"] = self.help\n        info[\"default\"] = self.default\n        info[\"multi\"] = self.multi\n        info[\"uniq\"] = self.uniq\n        info[\"choices\"] = self.choices\n        # TODO appel rec sur les attrs\n        #info[\"attrs\"] = self.attrs\n        return info", "response": "returns the option as a dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef evaluate(expr, **variables):\n    module = ast.parse(expr)  # Module(body=[Expr(value=...)])\n    if len(module.body) != 1:\n        raise BadExpression(\n            \"One expression expected, got %d.\" % len(module.body))\n\n    expression = module.body[0]\n    if not isinstance(expression, ast.Expr):\n        raise BadExpression(\n            \"Expression expected, got %s instead.\"\n            % expression.__class__.__name__\n        )\n\n    return _eval(expression.value, variables)", "response": ">>> evaluate('2**6')\n    64\n    >>> evaluate('1 + 2*3**(2 + 2) / (6 + -7)')\n    -161.0\n    >>> evaluate('5 < 4')\n    False\n    >>> evaluate('5 < a < 10', a=6)\n    True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef db_schema(db, table):\n  typedict = [('int', int), ('double', float),\n              ('timestamp', datetime),\n              ('date', date), ('time', dttime),\n              ('text', str), ('char', str)]\n  ret = {}\n  q = '''select column_name, data_type\n          from information_schema.columns\n          where table_name = %s;'''\n  #q = \"\"\"select c.name, c.type from sys.columns as c, sys.tables as t where table_id = t.id and t.name = %s;\"\"\"\n  # and data_type != 'date' and position('time' in data_type) =\n  # 0 and column_name != 'humidity'\n  for row in query(db, q, (table,)):\n      name, dtype = tuple( row[:2] )\n      name = str(name)\n      for tn, tt in typedict:\n          if tn in dtype:\n              ret[name] = tt\n              break\n      if name not in ret:\n          msg = \"can't find type of %s\\t%s\"\n          raise RuntimeError(msg % (name, dtype))\n  return ret", "response": "return a dictionary of column name - > data type of the table"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef complete_message(buf):\r\n  \"returns msg,buf_remaining or None,buf\"\r\n  # todo: read dollar-length for strings; I dont think I can blindly trust newlines. learn about escaping\r\n  # note: all the length checks are +1 over what I need because I'm asking for *complete* lines.\r\n  lines=buf.split('\\r\\n')\r\n  if len(lines)<=1: return None,buf\r\n  nargs_raw=lines.pop(0)\r\n  assert nargs_raw[0]=='*'\r\n  nargs=int(nargs_raw[1:])\r\n  args=[]\r\n  while len(lines)>=2: # 2 because if there isn't at least a blank at the end, we're missing a terminator\r\n    if lines[0][0]=='+': args.append(lines.pop(0))\r\n    elif lines[0][0]==':': args.append(int(lines.pop(0)[1:]))\r\n    elif lines[0][0]=='$':\r\n      if len(lines)<3: return None,buf\r\n      slen,s=int(lines[0][1:]),lines[1]\r\n      if slen!=len(s): raise ValueError('length mismatch %s %r'%(slen,s)) # probably an escaping issue\r\n      lines=lines[2:]\r\n      args.append(s)\r\n    else: raise ValueError('expected initial code in %r'%lines)\r\n  if len(args)==nargs: return args,'\\r\\n'.join(lines)\r\n  else: return None,buf", "response": "returns msg buf_remaining or None buf"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_playbook_from_file(self, path, vars={}):\n        '''\n        run top level error checking on playbooks and allow them to include other playbooks.\n        '''\n\n        playbook_data  = utils.parse_yaml_from_file(path)\n        accumulated_plays = []\n        play_basedirs = []\n\n        if type(playbook_data) != list:\n            raise errors.AnsibleError(\"parse error: playbooks must be formatted as a YAML list\")\n\n        basedir = os.path.dirname(path) or '.'\n        utils.plugins.push_basedir(basedir)\n        for play in playbook_data:\n            if type(play) != dict:\n                raise errors.AnsibleError(\"parse error: each play in a playbook must a YAML dictionary (hash), recieved: %s\" % play)\n            if 'include' in play:\n                tokens = shlex.split(play['include'])\n\n                items = ['']\n                for k in play.keys():\n                    if not k.startswith(\"with_\"):\n                        # These are the keys allowed to be mixed with playbook includes\n                        if k in (\"include\", \"vars\"):\n                            continue\n                        else:\n                            raise errors.AnsibleError(\"parse error: playbook includes cannot be used with other directives: %s\" % play)\n                    plugin_name = k[5:]\n                    if plugin_name not in utils.plugins.lookup_loader:\n                        raise errors.AnsibleError(\"cannot find lookup plugin named %s for usage in with_%s\" % (plugin_name, plugin_name))\n                    terms = utils.template_ds(basedir, play[k], vars)\n                    items = utils.plugins.lookup_loader.get(plugin_name, basedir=basedir, runner=None).run(terms, inject=vars)\n\n                for item in items:\n                    incvars = vars.copy()\n                    incvars['item'] = item\n                    if 'vars' in play:\n                        if isinstance(play['vars'], dict):\n                            incvars.update(play['vars'])\n                        elif isinstance(play['vars'], list):\n                            for v in play['vars']:\n                                incvars.update(v)\n                    for t in tokens[1:]:\n                        (k,v) = t.split(\"=\", 1)\n                        incvars[k] = utils.template_ds(basedir, v, incvars)\n                    included_path = utils.path_dwim(basedir, tokens[0])\n                    (plays, basedirs) = self._load_playbook_from_file(included_path, incvars)\n                    for p in plays:\n                        if 'vars' not in p:\n                            p['vars'] = {}\n                        if isinstance(p['vars'], dict):\n                            p['vars'].update(incvars)\n                        elif isinstance(p['vars'], list):\n                            p['vars'].extend([dict(k=v) for k,v in incvars.iteritems()])\n                    accumulated_plays.extend(plays)\n                    play_basedirs.extend(basedirs)\n            else:\n                accumulated_plays.append(play)\n                play_basedirs.append(basedir)\n\n        return (accumulated_plays, play_basedirs)", "response": "Load a playbook from a file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning all patterns in the playbook", "response": "def run(self):\n        ''' run all patterns in the playbook '''\n        plays = []\n        matched_tags_all = set()\n        unmatched_tags_all = set()\n\n        # loop through all patterns and run them\n        self.callbacks.on_start()\n        for (play_ds, play_basedir) in zip(self.playbook, self.play_basedirs):\n            play = Play(self, play_ds, play_basedir)\n            matched_tags, unmatched_tags = play.compare_tags(self.only_tags)\n            matched_tags_all = matched_tags_all | matched_tags\n            unmatched_tags_all = unmatched_tags_all | unmatched_tags\n\n            # if we have matched_tags, the play must be run.\n            # if the play contains no tasks, assume we just want to gather facts\n            if (len(matched_tags) > 0 or len(play.tasks()) == 0):\n                plays.append(play)\n\n        # if the playbook is invoked with --tags that don't exist at all in the playbooks\n        # then we need to raise an error so that the user can correct the arguments.\n        unknown_tags = set(self.only_tags) - (matched_tags_all | unmatched_tags_all)\n        unknown_tags.discard('all')\n\n        if len(unknown_tags) > 0:\n            unmatched_tags_all.discard('all')\n            msg = 'tag(s) not found in playbook: %s.  possible values: %s'\n            unknown = ','.join(sorted(unknown_tags))\n            unmatched = ','.join(sorted(unmatched_tags_all))\n            raise errors.AnsibleError(msg % (unknown, unmatched))\n\n        for play in plays:\n            if not self._run_play(play):\n                break\n\n        # summarize the results\n        results = {}\n        for host in self.stats.processed.keys():\n            results[host] = self.stats.summarize(host)\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlaunch an async job", "response": "def _async_poll(self, poller, async_seconds, async_poll_interval):\n        ''' launch an async job, if poll_interval is set, wait for completion '''\n\n        results = poller.wait(async_seconds, async_poll_interval)\n\n        # mark any hosts that are still listed as started as failed\n        # since these likely got killed by async_wrapper\n        for host in poller.hosts_to_poll:\n            reason = { 'failed' : 1, 'rc' : None, 'msg' : 'timed out' }\n            self.runner_callbacks.on_failed(host, reason)\n            results['contacted'][host] = reason\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _list_available_hosts(self, *args):\n        ''' returns a list of hosts that haven't failed and aren't dark '''\n\n        return [ h for h in self.inventory.list_hosts(*args) if (h not in self.stats.failures) and (h not in self.stats.dark)]", "response": "returns a list of hosts that haven t failed and aren t dark"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning a particular module step in a playbook", "response": "def _run_task_internal(self, task):\n        ''' run a particular module step in a playbook '''\n\n        hosts = self._list_available_hosts()\n        self.inventory.restrict_to(hosts)\n\n        runner = cirruscluster.ext.ansible.runner.Runner(\n            pattern=task.play.hosts, inventory=self.inventory, module_name=task.module_name,\n            module_args=task.module_args, forks=self.forks,\n            remote_pass=self.remote_pass, module_path=self.module_path,\n            timeout=self.timeout, remote_user=task.play.remote_user,\n            remote_port=task.play.remote_port, module_vars=task.module_vars,\n            private_key_file=self.private_key_file,\n            private_key=self.private_key,\n            setup_cache=self.SETUP_CACHE, basedir=task.play.basedir,\n            conditional=task.only_if, callbacks=self.runner_callbacks,\n            sudo=task.sudo, sudo_user=task.sudo_user,\n            transport=task.transport, sudo_pass=task.sudo_pass, is_playbook=True\n        )\n\n        if task.async_seconds == 0:\n            results = runner.run()\n        else:\n            results, poller = runner.run_async(task.async_seconds)\n            self.stats.compute(results)\n            if task.async_poll_interval > 0:\n                # if not polling, playbook requested fire and forget, so don't poll\n                results = self._async_poll(poller, task.async_seconds, task.async_poll_interval)\n\n        contacted = results.get('contacted',{})\n        dark      = results.get('dark', {})\n\n        self.inventory.lift_restriction()\n\n        if len(contacted.keys()) == 0 and len(dark.keys()) == 0:\n            return None\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun a single task in the playbook and recursively run any subtasks.", "response": "def _run_task(self, play, task, is_handler):\n        ''' run a single task in the playbook and recursively run any subtasks.  '''\n\n        self.callbacks.on_task_start(utils.template(play.basedir, task.name, task.module_vars, lookup_fatal=False), is_handler)\n\n        # load up an appropriate ansible runner to run the task in parallel\n        results = self._run_task_internal(task)\n\n        # if no hosts are matched, carry on\n        hosts_remaining = True\n        if results is None:\n            hosts_remaining = False\n            results = {}\n \n        contacted = results.get('contacted', {})\n        self.stats.compute(results, ignore_errors=task.ignore_errors)\n\n        # add facts to the global setup cache\n        for host, result in contacted.iteritems():\n            # Skip register variable if host is skipped\n            if result.get('skipped', False):\n                continue\n            facts = result.get('ansible_facts', {})\n            self.SETUP_CACHE[host].update(facts)\n            # extra vars need to always trump - so update  again following the facts\n            self.SETUP_CACHE[host].update(self.extra_vars)\n            if task.register:\n                if 'stdout' in result:\n                    result['stdout_lines'] = result['stdout'].splitlines()\n                self.SETUP_CACHE[host][task.register] = result\n\n        # flag which notify handlers need to be run\n        if len(task.notify) > 0:\n            for host, results in results.get('contacted',{}).iteritems():\n                if results.get('changed', False):\n                    for handler_name in task.notify:\n                        self._flag_handler(play, utils.template(play.basedir, handler_name, task.module_vars), host)\n\n        return hosts_remaining"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _flag_handler(self, play, handler_name, host):\n        '''\n        if a task has any notify elements, flag handlers for run\n        at end of execution cycle for hosts that have indicated\n        changes have been made\n        '''\n\n        found = False\n        for x in play.handlers():\n            if handler_name == utils.template(play.basedir, x.name, x.module_vars):\n                found = True\n                self.callbacks.on_notify(host, x.name)\n                x.notified_by.append(host)\n        if not found:\n            raise errors.AnsibleError(\"change handler (%s) is not defined\" % handler_name)", "response": "Flag handlers for a task that has any notify elements flag them for run\n        at end of execution cycle for hosts that have indicated\n        changes have been made\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets facts from the remote system", "response": "def _do_setup_step(self, play):\n        ''' get facts from the remote system '''\n\n        host_list = self._list_available_hosts(play.hosts)\n\n        if play.gather_facts is False:\n            return {}\n        elif play.gather_facts is None:\n            host_list = [h for h in host_list if h not in self.SETUP_CACHE or 'module_setup' not in self.SETUP_CACHE[h]]\n            if len(host_list) == 0:\n                return {}\n\n        self.callbacks.on_setup()\n        self.inventory.restrict_to(host_list)\n\n        # push any variables down to the system\n        setup_results = cirruscluster.ext.ansible.runner.Runner(\n            pattern=play.hosts, module_name='setup', module_args={}, inventory=self.inventory,\n            forks=self.forks, module_path=self.module_path, timeout=self.timeout, remote_user=play.remote_user,\n            remote_pass=self.remote_pass, remote_port=play.remote_port, private_key_file=self.private_key_file,\n            private_key=self.private_key,\n            setup_cache=self.SETUP_CACHE, callbacks=self.runner_callbacks, sudo=play.sudo, sudo_user=play.sudo_user,\n            transport=play.transport, sudo_pass=self.sudo_pass, is_playbook=True, module_vars=play.vars,\n        ).run()\n        self.stats.compute(setup_results, setup=True)\n\n        self.inventory.lift_restriction()\n\n        # now for each result, load into the setup cache so we can\n        # let runner template out future commands\n        setup_ok = setup_results.get('contacted', {})\n        for (host, result) in setup_ok.iteritems():\n            self.SETUP_CACHE[host].update({'module_setup': True})\n            self.SETUP_CACHE[host].update(result.get('ansible_facts', {}))\n        return setup_results"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a list of tasks for a given pattern", "response": "def _run_play(self, play):\n        ''' run a list of tasks for a given pattern, in order '''\n\n        self.callbacks.on_play_start(play.name)\n        # if no hosts matches this play, drop out\n        if not self.inventory.list_hosts(play.hosts):\n            self.callbacks.on_no_hosts_matched()\n            return True\n\n        # get facts from system\n        self._do_setup_step(play)\n\n        # now with that data, handle contentional variable file imports!\n\n        all_hosts = self._list_available_hosts(play.hosts)\n        play.update_vars_files(all_hosts)\n\n        serialized_batch = []\n        if play.serial <= 0:\n            serialized_batch = [all_hosts]\n        else:\n            # do N forks all the way through before moving to next\n            while len(all_hosts) > 0:\n                play_hosts = []\n                for x in range(play.serial):\n                    if len(all_hosts) > 0:\n                        play_hosts.append(all_hosts.pop())\n                serialized_batch.append(play_hosts)\n\n        for on_hosts in serialized_batch:\n\n            self.inventory.also_restrict_to(on_hosts)\n\n            for task in play.tasks():\n\n                # only run the task if the requested tags match\n                should_run = False\n                for x in self.only_tags:\n                    for y in task.tags:\n                        if (x==y):\n                            should_run = True\n                            break\n                if should_run:\n                    if not self._run_task(play, task, False):\n                        # whether no hosts matched is fatal or not depends if it was on the initial step.\n                        # if we got exactly no hosts on the first step (setup!) then the host group\n                        # just didn't match anything and that's ok\n                        return False\n\n                host_list = self._list_available_hosts(play.hosts)\n\n                # if no hosts remain, drop out\n                if not host_list:\n                    self.callbacks.on_no_hosts_remaining()\n                    return False\n\n            # run notify actions\n            for handler in play.handlers():\n                if len(handler.notified_by) > 0:\n                    self.inventory.restrict_to(handler.notified_by)\n                    self._run_task(play, handler, True)\n                    self.inventory.lift_restriction()\n                    handler.notified_by = []\n\n            self.inventory.lift_also_restriction()\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking that some string word or text are palindrome.", "response": "def check(somestr, check = STRING, interchange = ALL):\n\t\"\"\"\n\t\tChecks that some string, word or text are palindrome. Checking performs case-insensitive\n\t\t\n\t\t:param str somestr:\n\t\t    It is some string that will be checked for palindrome\n\t\t\n\t\t:keyword int check:\n\t\t    It is mode of checking. Follows modes are available:\n\t\t\t\n\t\t       - STRING - means that checking of string performs as string. See more at help(palindromus.checkstring)\n\t\t       - WORD - means that checking of string performs as word. See more at help(palindromus.checkword)\n\t\t       - MULTILINE - means that checking of string performs as multiline palindrome. See more at help(palindromus.checkmultiline)\n\t\t       - TEXT - means that checking of string performs as text. See more at help(palindromus.checktext)\n\t\t\t   - SUPER - means that checking of string performs as superpalindrome. See more at help(palindromus.checksuper)\n\t\t\t\n\t\t    The STRING-mode is default\n\t\t\t\n\t\t:keyword dict interchange:\n\t\t    It is dictionary of interchangeable letters\n\t\t\t\n\t\t:except TypeError:\n\t\t    If the checked string is not a string\n\t\t\t\n\t\t:except TypeError:\n\t\t    If checking mode is not specified as integer\n\t\t\t\n\t\t:except ValueError:\n\t\t    If value of checking mode is not valid.\n\t\t    If value of checking mode in [STRING, WORD, MULTILINE, TEXT, SUPER] then it is valid\n\t\t\t\n\t\t:return bool:\n\t\"\"\"\n\t# check invalid data types\n\tOnlyStringsCanBeChecked(somestr)\n\tif not isinstance(check, int):\n\t\traise TypeError('keyword argument \"check\" must be an int')\n\t\t\n\tif check == STRING:\n\t\t# check that string is palindrome\n\t\treturn checkstring(somestr, interchange = interchange)\n\telif check == WORD:\n\t\t# check that word is palindrome\n\t\treturn checkword(somestr, interchange = interchange)\n\telif check == MULTILINE:\n\t\t# check that text is multiline palindrome\n\t\treturn checkmultiline(somestr, interchange = interchange)\n\telif check == TEXT:\n\t\t# check that text is palindrome\n\t\treturn checktext(somestr, interchange = interchange)\n\telif check == SUPER:\n\t\t# check that text is super palindrome\n\t\treturn checksuper(somestr, interchange = interchange)\n\telse:\n\t\t# all other cases\n\t\traise ValueError('Unknown mode %i' % check)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks that some string is palindrome.", "response": "def checkstring(somestr, interchange = ALL):\n\t\"\"\"\n\t\tChecks that some string is palindrome. Checking performs case-insensitive\n\t\t\n\t\t:param str somestr:\n\t\t    It is some string that will be checked for palindrome as string.\n\t\t\t\n\t\t    The string is any string that you want. The string also can be multiline.\n\t\t\t\n\t\t    If the checked string does not contains any alphabetic characters or numbers or \n\t\t    it is empty then it will never be palindrome\n\t\t\t\n\t\t:keyword dict interchange:\n\t\t    It is dictionary of interchangeable letters\n\t\t\t\n\t\t:except TypeError:\n\t\t    If the checked string is not a string\n\n\t\t:return bool:\n\t\"\"\"\n\t# check invalid data types\n\tOnlyStringsCanBeChecked(somestr)\n\t\n\tif somestr != \"\":\n\t\t# remove all special symbols\n\t\tpattern = r'[^\\w]+|[_]+'\n\t\tpurestr = re.sub(pattern, '', somestr.casefold().strip(), flags = re.IGNORECASE | re.MULTILINE)\n\t\t\n\t\tfor k,v in interchange.items():\n\t\t\tic_pattern = '|'.join(v)\n\t\t\tpurestr = re.sub(ic_pattern, k, purestr, flags = re.IGNORECASE | re.MULTILINE)\n\t\t\n\t\t# reverse pure string\n\t\treversstr = purestr[-1::-1]\n\t\t\n\t\t# if purestr == \"\" that means that specified string contains \n\t\t# only special symbols. This string is not palindrome\n\t\tif purestr != \"\" and reversstr == purestr:\n\t\t\treturn True\n\t# in other cases\n\treturn False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef checkword(someword, interchange = ALL):\n\t# check invalid data types\n\tOnlyStringsCanBeChecked(someword)\n\t\t\n\tif isword(someword):\n\t\treturn checkstring(someword, interchange = interchange)\n\telse:\n\t\treturn False", "response": "Checks that some word is palindrome."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck that some text is a multiline palindrome.", "response": "def checkmultiline(sometext, interchange = ALL):\n\t\"\"\"\n\t\tChecks that some text is multiline palindrome. Checking performs case-insensitive\n\t\t\n\t\t:param str sometext:\n\t\t    It is some string that will be checked for palindrome as multiline palindrome.\n\t\t\t\n\t\t    The multiline palindrome is text that contains palindrome at each line \n\t\t    (what is the text see at help(palindromus.istext)).\n\t\t\t\n\t\t    Only multiline text can be the multiline palindrome.\n\t\t\t\n\t\t:keyword dict interchange:\n\t\t    It is dictionary of interchangeable letters\n\t\t\t\n\t\t:except TypeError:\n\t\t    If the checked text is not a string\n\t\t\t\n\t\t:return bool:\n\t\"\"\"\n\t# check invalid data types\n\tOnlyStringsCanBeChecked(sometext)\n\t\n\tif istext(sometext):\n\t\tlines = re.split(r'\\r\\n|\\n|\\r', sometext)\n\t\tif len(lines) > 1:\n\t\t\tfor line in lines:\n\t\t\t\tif line.strip() == \"\":\n\t\t\t\t\tcontinue # skip empty lines\n\t\t\t\tif not checkstring(line, interchange = interchange):\n\t\t\t\t\treturn False\n\t\t\treturn True\n\t# in other cases\n\treturn False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef checktext(sometext, interchange = ALL):\n\t# check invalid data types\n\tOnlyStringsCanBeChecked(sometext)\n\t\n\tif istext(sometext):\n\t\treturn checkstring(sometext, interchange = interchange)\n\telse:\n\t\treturn False", "response": "Checks that some text is palindrome."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef checksuper(sometext, interchange = ALL):\n\tdef text_by_columns(text, columns):\n\t\tcolumn_idx = 0\n\t\tresult_text = \"\"\n\t\twhile column_idx+1 <= columns:\n\t\t\tfor idx in range(columns):\n\t\t\t\tresult_text += text[idx*columns + column_idx]\n\t\t\tcolumn_idx += 1\n\t\treturn result_text\n\t\n\t# check invalid data types\n\tOnlyStringsCanBeChecked(sometext)\n\t\n\tif istext(sometext):\n\t\t# get only alphabetic\n\t\tmatches = re.findall(r'\\w+', sometext)\n\t\t\n\t\tif len(matches):\n\t\t\talphabetic = (''.join(matches)).replace('_', '')\n\t\t\t\n\t\t\t# get matrix size\n\t\t\tn = math.sqrt(len(alphabetic))\n\t\t\tif math.ceil(n) == int(n):\n\t\t\t\tn = int(n) # float to integer\n\t\t\t\tif checkstring(alphabetic, interchange = interchange):\n\t\t\t\t\t# read by columns\n\t\t\t\t\talphabetic_by_col = text_by_columns(alphabetic, n)\n\t\t\t\t\tif checkstring(alphabetic_by_col, interchange = interchange):\n\t\t\t\t\t\treturn True\n\t# in other cases\n\treturn False", "response": "Checks that some text is superpalindrome."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef isword(somestr):\n\t# check invalid data types\n\tOnlyStringsCanBeChecked(somestr)\n\t\n\tif somestr.isalpha() and len(somestr) > 1:\n\t\t# find characters that repeats more then 2 times in a row\n\t\tmatches = re.search(r'(.)(\\1)(\\1)', somestr, flags = re.IGNORECASE)\n\t\tif matches == None:\n\t\t\t# russian\n\t\t\t# check first character\n\t\t\tif somestr.casefold()[0:1] not in ['\u044a', '\u044c']:\n\t\t\t\treturn True\n\t# in other cases\n\treturn False", "response": "Checks that some string is a word in the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck that some string is a special word.", "response": "def isspecword(somestr):\n\t\"\"\"\n\t\tChecks that some string is a special word\n\t\t\n\t\t:param str somestr:\n\t\t    It is some string that will be checked for special word.\n\t\t\t\n\t\t    The special word is a string that contains only alphabetic characters, \n\t\t    its length not less 1 character and not more 2 characters and \n\t\t    also noone characters does not reeats more than 1 times in a row.\n\t\t\t\n\t\t    The special word can not be multiline.\n\t\t\t\n\t\t    For example, special word is preposition\n\t\t\t\n\t\t:except TypeError:\n\t\t    If the checked special word is not a string\n\t\t\t\n\t\t:return bool:\n\t\"\"\"\n\t# check invalid data types\n\tOnlyStringsCanBeChecked(somestr)\n\t\n\tif somestr.isalpha() and len(somestr) in [1, 2]:\n\t\t# find characters that repeats more then 1 times in a row\n\t\tmatches = re.search(r'(.)(\\1)', somestr, flags = re.IGNORECASE)\n\t\tif matches == None:\n\t\t\t# russian\n\t\t\t# check first character\n\t\t\tif somestr.casefold()[0:1] not in ['\u044a', '\u044c']:\n\t\t\t\treturn True\n\t# in other cases\n\treturn False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef istext(somestr):\n\t# check invalid data types\n\tOnlyStringsCanBeChecked(somestr)\n\t\n\t# get all matches\n\tmatches = re.findall(r'\\w+', somestr.strip(), flags = re.IGNORECASE | re.MULTILINE)\n\tif not len(matches):\n\t\treturn False\n\telse:\n\t\tfor match in matches:\n\t\t\tif match.find(\"_\") >= 0 or (not isspecword(match) and not isword(match)):\n\t\t\t\treturn False\n\t\treturn True", "response": "check that some string is a text - type string"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _deserialize(self, value, environment=None):\n\n        if not isinstance(value, CollectionABC):\n            raise exc.Invalid(self)\n\n        items_class = self.items.__class__\n        invalids = []\n\n        # traverse items and match against validated struct\n        collection = self.collection_type()\n\n        for i, subvalue in enumerate(value):\n            item = items_class(name=i)\n            try:\n                self.collection_pusher(collection, item.deserialize(subvalue, environment=environment))\n\n            except exc.Invalid as ex:\n                invalids.append(ex)\n\n        if invalids:\n            # on invalids this item is also ``Invalid``\n            raise exc.InvalidChildren(self, invalids)\n\n        return collection", "response": "A collection traverses over something to deserialize its value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_cmdLine_instructions(args):\n    instructions = dict()\n    rargs = list()\n    for arg in args:\n        if arg[:2] == '--':\n            tmp = arg[2:]\n            bits = tmp.split('=', 1)\n            if len(bits) == 1:\n                bits.append('')\n            instructions[bits[0]] = bits[1]\n        else:\n            rargs.append(arg)\n    return instructions, rargs", "response": "Parses command - line arguments and returns a dict of instructions and the list of command - line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\napplying the given instructions on the manager m.", "response": "def execute_cmdLine_instructions(instructions, m, l):\n    \"\"\" Applies the instructions given via\n        <instructions> on the manager <m> \"\"\"\n    opt_lut = dict()\n    inst_lut = dict()\n    for k, v in six.iteritems(instructions):\n        bits = k.split('-', 1)\n        if len(bits) == 1:\n            if v not in m.modules:\n                raise KeyError(\"No such module: %s\" % v)\n            inst_lut[bits[0]] = v\n        else:\n            if not bits[0] in opt_lut:\n                opt_lut[bits[0]] = list()\n            opt_lut[bits[0]].append((bits[1], v))\n    inst_list = sort_by_successors(\n        six.viewkeys(inst_lut),\n        lambda inst: [v for (k, v) in opt_lut.get(inst, ())\n                      if k in m.modules[inst_lut[inst]].deps]\n    )\n    for k in reversed(tuple(inst_list)):\n        if k in m.insts:\n            raise NotImplementedError(\n                \"Overwriting instancens not yet supported\")\n        settings = dict()\n        if k in opt_lut:\n            for k2, v2 in opt_lut[k]:\n                settings[k2] = v2\n        m.create_instance(k, inst_lut[k], settings)\n    for k in opt_lut:\n        if k in inst_lut:\n            continue\n        for k2, v2 in opt_lut[k]:\n            if k not in m.insts:\n                raise ValueError(\"No such instance %s\" % k)\n            m.change_setting(k, k2, v2)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main():\n    sarah.coloredLogging.basicConfig(level=logging.DEBUG,\n                                     formatter=MirteFormatter())\n    l = logging.getLogger('mirte')\n    instructions, args = parse_cmdLine_instructions(sys.argv[1:])\n    m = Manager(l)\n    load_mirteFile(args[0] if args else 'default', m, logger=l)\n    execute_cmdLine_instructions(instructions, m, l)\n    m.run()", "response": "Entry - point for the mirte command line tool."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if a class is installed in the middlewares.", "response": "def installed(cls):\n        \"\"\"\n        Used in ``yacms.pages.views.page`` to ensure\n        ``PageMiddleware`` or a subclass has been installed. We cache\n        the result on the ``PageMiddleware._installed`` to only run\n        this once. Short path is to just check for the dotted path to\n        ``PageMiddleware`` in ``MIDDLEWARE_CLASSES`` - if not found,\n        we need to load each middleware class to match a subclass.\n        \"\"\"\n        try:\n            return cls._installed\n        except AttributeError:\n            name = \"yacms.pages.middleware.PageMiddleware\"\n            mw_setting = get_middleware_setting()\n            installed = name in mw_setting\n            if not installed:\n                for name in mw_setting:\n                    if issubclass(import_dotted_path(name), cls):\n                        installed = True\n                        break\n            setattr(cls, \"_installed\", installed)\n            return installed"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef process_view(self, request, view_func, view_args, view_kwargs):\n\n        # Load the closest matching page by slug, and assign it to the\n        # request object. If none found, skip all further processing.\n        slug = path_to_slug(request.path_info)\n        pages = Page.objects.with_ascendants_for_slug(slug,\n                        for_user=request.user, include_login_required=True)\n        if pages:\n            page = pages[0]\n            setattr(request, \"page\", page)\n            context_processors.page(request)\n        else:\n            return\n\n        # Handle ``page.login_required``.\n        if page.login_required and not request.user.is_authenticated():\n            return redirect_to_login(request.get_full_path())\n\n        # If the view isn't yacms's page view, try to return the result\n        # immediately. In the case of a 404 with an URL slug that matches a\n        # page exactly, swallow the exception and try yacms's page view.\n        #\n        # This allows us to set up pages with URLs that also match non-page\n        # urlpatterns. For example, a page could be created with the URL\n        # /blog/about/, which would match the blog urlpattern, and assuming\n        # there wasn't a blog post with the slug \"about\", would raise a 404\n        # and subsequently be rendered by yacms's page view.\n        if view_func != page_view:\n            try:\n                return view_func(request, *view_args, **view_kwargs)\n            except Http404:\n                if page.slug != slug:\n                    raise\n\n        # Run page processors.\n        extra_context = {}\n        model_processors = page_processors.processors[page.content_model]\n        slug_processors = page_processors.processors[\"slug:%s\" % page.slug]\n        for (processor, exact_page) in slug_processors + model_processors:\n            if exact_page and not page.is_current:\n                continue\n            processor_response = processor(request, page)\n            if isinstance(processor_response, HttpResponse):\n                return processor_response\n            elif processor_response:\n                try:\n                    for k, v in processor_response.items():\n                        if k not in extra_context:\n                            extra_context[k] = v\n                except (TypeError, ValueError):\n                    name = \"%s.%s\" % (processor.__module__, processor.__name__)\n                    error = (\"The page processor %s returned %s but must \"\n                             \"return HttpResponse or dict.\" %\n                             (name, type(processor_response)))\n                    raise ValueError(error)\n\n        return page_view(request, slug, extra_context=extra_context)", "response": "Process the view function and return the result."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unshare(flags):\n    res = lib.unshare(flags)\n    if res != 0:\n        _check_error(ffi.errno)", "response": "Disassociate parts of the process execution context."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _reset(self):\n\n        self._name = None\n        self._start_time = None\n        self._owner = os.getuid()\n        self._paths['task_dir'] = None\n        self._paths['task_config'] = None\n        self._loaded = False", "response": "Resets the internal state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave current task information to active file.", "response": "def _save_active_file(self):\n        \"\"\" Saves current task information to active file.\n\n            Example format::\n                active_task {\n                    name \"task name\";\n                    start_time \"2012-04-23 15:18:22\";\n                }\n            \"\"\"\n\n        _parser = parser.SettingParser()\n\n        # add name\n        _parser.add_option(None, 'name', common.to_utf8(self._name))\n\n        # add start time\n        start_time = self._start_time.strftime('%Y-%m-%d %H:%M:%S.%f')\n        _parser.add_option(None, 'start_time', start_time)\n\n        # write it to file\n        return _parser.write(self._paths['active_file'],\n                             self.HEADER_ACTIVE_FILE)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _clean_prior(self):\n\n        if self._loaded:\n            try:\n                pid_file = daemon.get_daemon_pidfile(self)\n\n                # check if it exists so we don't raise\n                if os.path.isfile(pid_file):\n                    # read pid from file\n                    pid = int(common.readfile(pid_file))\n\n                    # check if pid file is stale\n                    if pid and not daemon.pid_exists(pid):\n                        common.safe_remove_file(pid_file)\n                        raise ValueError\n\n            except (ValueError, TypeError):\n                self._clean()\n                return True\n\n        return False", "response": "Cleanes up from a previous task that didn t exit cleanly. Returns True if previous task was cleaned."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading a task from the active file.", "response": "def load(self):\n        \"\"\" Loads a task if the active file is available.\n            \"\"\"\n\n        try:\n            _parser = parser.parse_config(self._paths['active_file'],\n                                          self.HEADER_ACTIVE_FILE)\n\n            # parse expected options into a dict to de-dupe\n            keys = ('name', 'start_time')\n            opts = dict(o for o in _parser.options if o[0] in keys)\n\n            # check for all keys\n            for k in keys:\n                if not opts.get(k):\n                    return False\n            task_name = opts.get('name')[0]\n\n            # setup the paths\n            task_dir = self._get_task_dir(task_name)\n            task_config = os.path.join(task_dir, 'task.cfg')\n\n            # validate start time\n            value = opts.get('start_time')[0]\n            start_time = datetime.datetime.strptime(value,\n                                                    '%Y-%m-%d %H:%M:%S.%f')\n\n            # get user id for process ownership when running task\n            # here, we use the owner of the active file\n            file_meta = os.stat(self._paths['active_file'])\n            owner = file_meta.st_uid\n\n            # parse task config and send its options to registered plugins\n            _parser = parser.parse_config(task_config, self.HEADER_TASK_CONFIG)\n            registration.run_option_hooks(_parser)\n\n            self._name = common.from_utf8(task_name)\n            self._start_time = start_time\n            self._owner = owner\n            self._paths['task_dir'] = task_dir\n            self._paths['task_config'] = task_config\n            self._loaded = True\n\n        except (parser.ParseError, ValueError, TypeError, OSError):\n            # something failed, cleanup\n            self._clean()\n\n        self._clean_prior()\n        return self._loaded"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef exists(self, task_name):\n\n        try:\n            return os.path.exists(self._get_task_dir(task_name))\n\n        except OSError:\n            return False", "response": "Determines if a task directory exists."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new task directory.", "response": "def create(self, task_name, clone_task=None):\n        \"\"\" Creates a new task directory.\n\n            `task_name`\n                Task name.\n            `clone_task`\n                Existing task name to use as a template for new task.\n\n            Returns boolean.\n\n            * Raises ``Value`` if task name is invalid, ``TaskExists`` if task\n              already exists, or ``TaskNotFound`` if task for `clone_from`\n              doesn't exist.\n            \"\"\"\n\n        if not task_name or task_name.startswith('-'):\n            raise ValueError('Invalid task name')\n\n        try:\n            task_dir = self._get_task_dir(task_name)\n\n            if self.exists(task_dir):\n                raise errors.TaskExists(task_name)\n\n            task_cfg = self.get_config_path(task_name)\n\n            if clone_task:\n                if not self.exists(clone_task):\n                    raise errors.TaskNotFound(clone_task)\n\n                # copy task directory\n                shutil.copytree(self._get_task_dir(clone_task), task_dir)\n\n            else:\n                os.mkdir(task_dir)\n\n                # write default task configuration\n                shutil.copy(self._default_task_config, task_cfg)\n\n            return True\n\n        except OSError:\n            shutil.rmtree(task_dir, ignore_errors=True)\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rename(self, old_task_name, new_task_name):\n\n        if not old_task_name or old_task_name.startswith('-'):\n            raise ValueError('Old task name is invalid')\n\n        if not new_task_name or new_task_name.startswith('-'):\n            raise ValueError('New new task name is invalid')\n\n        if old_task_name == new_task_name:\n            raise ValueError('Cannot rename task to itself')\n\n        try:\n            old_task_dir = self._get_task_dir(old_task_name)\n            if not self.exists(old_task_dir):\n                raise errors.TaskNotFound(old_task_name)\n\n            new_task_dir = self._get_task_dir(new_task_name)\n            if self.exists(new_task_dir):\n                raise errors.TaskExists(new_task_name)\n\n            os.rename(old_task_dir, new_task_dir)\n            return True\n\n        except OSError:\n            return False", "response": "Renames an existing task directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove(self, task_name):\n\n        try:\n            task_dir = self._get_task_dir(task_name)\n            shutil.rmtree(task_dir)\n            return True\n\n        except OSError:\n            return False", "response": "Removes an existing task directory."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_list_info(self, task_name=None):\n        try:\n            tasks = []\n\n            # get all tasks dirs\n            tasks_dir = os.path.join(self._paths['base_dir'], 'tasks')\n\n            if task_name:\n                # if task folder doesn't exist, return nothing\n                if not os.path.isdir(os.path.join(tasks_dir, task_name)):\n                    return []\n\n                task_names = [task_name]\n\n            else:\n                task_names = [name for name in os.listdir(tasks_dir)\n                              if os.path.isdir(os.path.join(tasks_dir, name))]\n                task_names.sort()\n\n            for name in task_names:\n                try:\n                    # parse task config and run option hooks\n                    task_config = os.path.join(tasks_dir, name, 'task.cfg')\n                    parser_ = parser.parse_config(task_config,\n                                                  self.HEADER_TASK_CONFIG)\n                    registration.run_option_hooks(parser_,\n                                                  disable_missing=False)\n\n                    tasks.append((name, parser_.options, parser_.blocks))\n\n                except (parser.ParseError, errors.InvalidTaskConfig):\n                    tasks.append((name, None, None))\n\n            return tasks\n\n        except OSError:\n            return []", "response": "Lists all tasks and associated information."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(self, task_name):\n\n        self._clean_prior()\n\n        if self._loaded:\n            raise errors.ActiveTask\n\n        # get paths\n        task_dir = os.path.join(self._paths['base_dir'], 'tasks', task_name)\n        task_config = os.path.join(task_dir, 'task.cfg')\n\n        if not os.path.isdir(task_dir):\n            raise errors.TaskNotFound(task_name)\n\n        try:\n            # raise if task config is missing\n            if not os.path.isfile(task_config):\n                reason = u\"Config file could not be found.\"\n                raise errors.InvalidTaskConfig(task_config, reason=reason)\n\n            # parse task config and send its options to registered plugins\n            _parser = parser.parse_config(task_config, self.HEADER_TASK_CONFIG)\n            registration.run_option_hooks(_parser)\n\n        except parser.ParseError as exc:\n            raise errors.InvalidTaskConfig(task_config,\n                                           reason=unicode(exc))\n\n        # populate task info\n        self._name = common.from_utf8(task_name)\n        self._start_time = datetime.datetime.now()\n        self._owner = os.getuid()\n        self._paths['task_dir'] = task_dir\n        self._paths['task_config'] = task_config\n        self._loaded = True\n\n        # task is setup, save active file\n        # note, order is *important*; this is needed first\n        # for the daemon to load\n        self._save_active_file()\n\n        # shell the focusd daemon\n        try:\n            started = daemon.shell_focusd(self._paths['base_dir'])\n\n        # user cancelled or passwords failed?\n        except (KeyboardInterrupt, ValueError):\n            self._clean()\n            return False\n\n        # no event plugins registered, carry on\n        except errors.NoPluginsRegistered:\n            return True\n\n        # failed, cleanup our mess\n        if not started:\n            self._clean()\n            raise errors.DaemonFailStart\n\n        return True", "response": "Starts a new task matching the provided name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstop the current task and cleans up its configuration file.", "response": "def stop(self):\n        \"\"\" Stops the current task and cleans up, including removing active\n            task config file.\n\n            * Raises ``NoActiveTask`` exception if no active task found.\n            \"\"\"\n\n        self._clean_prior()\n\n        if not self._loaded:\n            raise errors.NoActiveTask\n\n        self._clean()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the total task duration in minutes.", "response": "def set_total_duration(self, duration):\n        \"\"\" Set the total task duration in minutes.\n            \"\"\"\n        if duration < 1:\n            raise ValueError(u'Duration must be postive')\n\n        elif self.duration > duration:\n            raise ValueError(u'{0} must be greater than current duration')\n\n        self._total_duration = duration"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns if the task is active.", "response": "def active(self):\n        \"\"\" Returns if task is active.\n            \"\"\"\n        if not os.path.isfile(self._paths['active_file']):\n            return False\n        return self._loaded"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef duration(self):\n\n        if not self._loaded:\n            return 0\n\n        delta = datetime.datetime.now() - self._start_time\n        total_secs = (delta.microseconds +\n                      (delta.seconds + delta.days * 24 * 3600) *\n                      10 ** 6) / 10 ** 6\n\n        return max(0, int(round(total_secs / 60.0)))", "response": "Returns the current duration in minutes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prepare(query, params):\n    def repl(match):\n        name = match.group(1)[1:]\n        if name in params:\n            return marshal(params[name])\n        return \":%s\" % name\n\n    new, count = re.subn(_param_re, repl, query)\n\n    if len(params) > count:\n        raise cql.ProgrammingError(\"More keywords were provided \"\n                                   \"than parameters\")\n    return new", "response": "Prepares the query string for the current language."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndefine selector for a node.", "response": "def define_selector(by, value, el_class):\n    \"\"\"\n    :param by:\n    :param value:\n    :param el_class:\n    :rtype: tuple[type, str|tuple[str, str]]\n    :return:\n    \"\"\"\n    el = el_class\n    selector = by\n    if isinstance(value, six.string_types):\n        selector = (by, value)\n    elif value is not None:\n        el = value\n\n    if el is None:\n        el = elements.PageElement\n\n    return el, selector"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds a locator from a selector string.", "response": "def build_locator(selector):\n    \"\"\"\n    - ID = \"#valid_id\"\n    - CLASS_NAME = \".valid_class_name\"\n    - TAG_NAME = \"valid_tag_name\"\n    - XPATH = start with \"./\" or \"//\" or \"$x:\"\n    - LINK_TEXT = start with \"$link_text:\"\n    - PARTIAL_LINK_TEXT = start with \"$partial_link_text:\"\n    - NAME = \"@valid_name_attribute_value\"\n\n    CSS_SELECTOR = all other that starts with *|.|#|[\\w-]|\\[|:\n\n    :type selector: str|tuple\n    :param selector:\n    :rtype: tuple[selenium.webdriver.common.by.By, str]\n    :return:\n    \"\"\"\n    if type(selector) is tuple:\n        return selector\n    if not isinstance(selector, six.string_types):\n        raise InvalidSelectorException(\"Invalid locator values passed in\")\n\n    s = selector.strip()\n    for test, by, index in selectors:\n        if test(s):\n            return by, s[index:]\n    raise InvalidSelectorException(\"Invalid locator values passed in: {}\".format(selector))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef all_elements(self):\n        return [(k, getattr(self, k)) for k, v in get_members_safety(self.__class__)\n                if not k.startswith(\"_\") and isinstance(v, (BasePageElement,))]", "response": "returns all public page elements grouped by this element and it parent ( s )\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef child_element(self, by=By.ID, value=None, el_class=None):\n        el, selector = define_selector(by, value, el_class)\n        return self._init_element(el(selector))", "response": "Returns the child element of the current element."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef child_elements(self, by=By.ID, value=None, el_class=None):\n        el, selector = define_selector(by, value, el_class)\n        return self._init_element(elements.PageElementsList(selector, el))", "response": "alias for ``find_elements``\n        :param by:\n        :param value:\n        :param el_class:\n        :return:"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_element(self, by=By.ID, value=None, el_class=None):\n        el = self.child_element(by, value, el_class)\n        el.reload()\n        return el", "response": "find element in the hierarchy by id or value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_elements(self, by=By.ID, value=None, el_class=None):\n        els = self.child_elements(by, value, el_class)\n        els.reload()\n        return els", "response": "find elements in the hierarchy by id or value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef eval(self, cmd):\n        tokens = cmd.upper().split()\n        if len(tokens) == 2 and tokens[0] == 'LIST':\n            if tokens[1] == 'EXPERIMENTS':\n                return self.list_objects(self.sco.experiments_list())\n            elif tokens[1] == 'IMAGES':\n                return self.list_objects(self.sco.image_groups_list())\n            elif tokens[1] == 'MODELS':\n                return self.list_objects(self.sco.models_list())\n            elif tokens[1] == 'SUBJECTS':\n                return self.list_objects(self.sco.subjects_list())\n            else:\n                raise SCOCmdSyntaxError(cmd, 'unknown type: ' + cmd.split()[1])\n        else:\n            raise SCOCmdSyntaxError(cmd, 'unknown command')", "response": "Evaluate a given command and return the result of the command."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_objects(self, resources):\n        result = []\n        for res in resources:\n            result.append('\\t'.join([res.identifier, res.name, str(res.timestamp)[:19]]))\n        return result", "response": "Generate a listing of a set of resource handles consisting of\n        resource identifier name and timestamp."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn locale from GET lang param or automatically.", "response": "def set_locale(request):\n    \"\"\"Return locale from GET lang param or automatically.\"\"\"\n    return request.query.get('lang', app.ps.babel.select_locale_by_request(request))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef value(self):\n        f = types.FunctionType(\n            self.code.value, self.globals, self.name, self.defaults, self.closure\n        )\n        d = self.dict.copy()\n        for attr in PY3_ATTRS:\n            try:\n                setattr(f, attr, d.pop(attr, None))\n            except TypeError:\n                pass\n        for attr in OPT_ATTRS:\n            val = d.pop(attr, _missing)\n            if val is not _missing:\n                setattr(f, attr, val)\n        __self__ = d.pop('__self__', _missing)\n        __class__ = d.pop('im_class', _missing)\n        getattr(f, DICT_ATTR).update(d)\n        if __self__ is not _missing:\n            if METHOD_HAS_CLASS:\n                if __class__ is _missing:\n                    __class__ = __self__.__class__\n                f = types.MethodType(f, __self__, __class__)\n            else:\n                f = types.MethodType(f, __self__)\n                if __class__ is not _missing:\n                    f.im_class = __class__\n        return f", "response": "The value of self as a ( not serializable ) types. FunctionType object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding the globals of self by importing self. module.", "response": "def globals(self):\n        \"\"\"Find the globals of `self` by importing `self.module`\"\"\"\n        try:\n            return vars(__import__(self.module, fromlist=self.module.split('.')))\n        except ImportError:\n            if self.warn_import:\n                warnings.warn(ImportWarning(\n                    'Cannot import module {} for SerializableFunction. Restricting to builtins.'.format(self.module)\n                ))\n            return {'__builtins__': __builtins__}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nimport the constant from self. module", "response": "def value(self):\n        \"\"\"Import the constant from `self.module`\"\"\"\n        module = __import__(self.module, fromlist=self.module.split('.'))\n        if self.name is None:\n            return module\n        return getattr(module, self.name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\napplies the aggregation function func on each group in the GroubyTable and leaves the results in a new column with the name of the aggregation function.", "response": "def agg(self, func, *fields, **name):\n        \"\"\"\n        Calls the aggregation function `func` on each group in the GroubyTable,\n        and leaves the results in a new column with the name of the aggregation\n        function.\n\n        Call `.agg` with `name='desired_column_name' to choose a column\n        name for this aggregation.\n        \"\"\"\n        if name:\n            if len(name) > 1 or 'name' not in name:\n                raise TypeError(\"Unknown keyword args passed into `agg`: %s\"\n                                % name)\n            name = name.get('name')\n            if not isinstance(name, basestring):\n                raise TypeError(\"Column names must be strings, not `%s`\"\n                                % type(name))\n            else:\n                name = name\n        elif func.__name__ == '<lambda>':\n            name = \"lambda%04d\" % self.__lambda_num\n            self.__lambda_num += 1\n            name += \"(%s)\" % ','.join(fields)\n        else:\n            name = func.__name__\n            name += \"(%s)\" % ','.join(fields)\n\n        aggregated_column = []\n\n        if len(fields) > 1:\n            for groupkey in self.__grouptable['groupkey']:\n                agg_data = [tuple([row[field] for field in fields])\n                            for row in self.__key_to_group_map[groupkey]]\n                aggregated_column.append(func(agg_data))\n        elif len(fields) == 1:\n            field = fields[0]\n            for groupkey in self.__grouptable['groupkey']:\n                agg_data = [row[field]\n                            for row in self.__key_to_group_map[groupkey]]\n                aggregated_column.append(func(agg_data))\n        else:\n            for groupkey in self.__grouptable['groupkey']:\n                agg_data = self.__key_to_group_map[groupkey]\n                aggregated_column.append(func(agg_data))\n\n        self.__grouptable[name] = aggregated_column\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef collect(self):\n        # The final order of columns is determined by the\n        # group keys and the aggregation columns\n        final_field_order = list(self.__groupfields) + self.__grouptable.fields\n\n        # Transform the group key rows into columns\n        col_values = izip(*self.__grouptable['groupkey'])\n\n        # Assign the columns to the table with the relevant name\n        for groupfield, column in izip(self.__groupfields, col_values):\n            self.__grouptable[groupfield] = column\n\n        # Reorder the columns as defined above\n        self.__grouptable.reorder(final_field_order)\n\n        del self.__grouptable['groupkey']\n        return self.__grouptable", "response": "This method combines the groupby operation by converting the groupbyTable into a DataTable."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef procesa_tareas_paralelo(lista_tareas, dict_data, func_process,\n                            titulo=None, usar_multithread=True, max_threads=100, verbose=True):\n    \"\"\"\n    Procesa las tareas diarias en paralelo, limitando a un MAX de n\u00ba de threads.\n    Especialmente \u00fatil para realizar requests simult\u00e1neos a un servidor web concreto.\n        :param lista_tareas: Recibe una lista de tareas \u00fanicas (key_tarea) a realizar\n        :param dict_data: Diccionario de la forma '{key_tarea : variable_in_out}', de forma que cada hilo de ejecuci\u00f3n\n                            opera con su clave de tarea, tomando los datos del diccionario y depositando su salida\n                            en el mismo lugar.\n        :param func_process: Necesita el puntero a funci\u00f3n 'func_process', cuya definici\u00f3n debe ser de la forma:\n                            'func_process(key_tarea, dict_data_in_out)\n        :param titulo:\n        :param usar_multithread: True por defecto\n        :param max_threads: 100 por defecto\n        :param verbose: True por defecto\n    \"\"\"\n\n    num_tareas = len(lista_tareas)\n    if titulo and num_tareas > 1:\n        print(titulo % num_tareas)\n    if num_tareas > 1 and usar_multithread:\n        tic_init = time.time()\n        threads = [threading.Thread(target=func_process, args=(tarea, dict_data,)) for tarea in lista_tareas]\n        lista_threads = [threads[i:i + int(max_threads)] for i in np.arange(0, len(threads), int(max_threads))]\n        cont_tareas = 0\n        for th in lista_threads:\n            tic = time.time()\n            [thread.start() for thread in th]\n            [thread.join() for thread in th]\n            if verbose:\n                print(\"Procesado de tareas en paralelo [%lu->%lu, %%=%.1f]: %.2f seg [%.4f seg/tarea]\"\n                      % (cont_tareas + 1, cont_tareas + len(th), 100. * (cont_tareas + len(th)) / float(num_tareas),\n                         (time.time() - tic), (time.time() - tic) / len(th)))\n            cont_tareas += len(th)\n        tic_fin = (time.time() - tic_init)\n        if num_tareas > 1 and usar_multithread and len(lista_threads) > 1 and verbose:\n            print(\"Tiempo de proceso de tareas en paralelo TOTAL ({} tareas): {:.2f} seg [{:.4f} seg/tarea]\"\n                  .format(num_tareas, tic_fin, tic_fin / num_tareas))\n    else:\n        for tarea in lista_tareas:\n            if num_tareas > 3 and verbose:\n                print('Tarea: %s' % str(tarea))\n            func_process(tarea, dict_data)", "response": "Procesa las tareas diarias en paralelo."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nformat the given dictionary d into a key - value pair.", "response": "def kv_format_dict(d, keys=None, separator=DEFAULT_SEPARATOR):\n    \"\"\"Formats the given dictionary ``d``.\n\n    For more details see :func:`kv_format`.\n\n    :param collections.Mapping d:\n        Dictionary containing values to format.\n    :param collections.Iterable keys:\n        List of keys to extract from the dict.\n    :param str separator:\n        Value between two pairs.\n    :return:\n        Key-Value formatted content generated from ``d``.\n    :rtype:\n        :data:`six.text_type <six:six.text_type>`\n    \"\"\"\n    return _format_pairs(dump_dict(d, keys), separator=separator)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef kv_format_object(o, keys=None, separator=DEFAULT_SEPARATOR):\n    if keys is None:\n        key_values = []\n        for k, v in ((x, getattr(o, x)) for x in sorted(dir(o))):\n            if k.startswith('_') or isroutine(v):\n                continue\n            key_values += (k, v),\n    else:\n        key_values = ((k, getattr(o, k)) for k in keys)\n\n    return kv_format_pairs(key_values, separator)", "response": "Formats an object s attributes. Useful for object representation\n    implementation."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat any given list of Key - Value pairs or dictionaries in the given order.", "response": "def kv_format(*args, **kwargs):\n    \"\"\"Formats any given list of Key-Value pairs or dictionaries in ``*args``\n    and any given keyword argument in ``**kwargs``.\n\n    Any item within a given list or dictionary will also be visited and\n    added to the output.  Strings will be escaped to prevent leaking binary\n    data, ambiguous characters or other control sequences.  Strings with\n    escaped characters or spaces  will be encapsulated in quotes.\n    Other objects will be converted into a string and will be treated\n    as a string afterwards.\n\n    :param \\*args:\n        Values to format.\n    :type \\*args:\n        any Iterable or Mapping\n    :param \\*\\*kwargs:\n        Keyword Values to format\n    :return:\n        Formatted content of ``*args`` and ``**kwargs``.\n    :rtype:\n        :data:`six.text_type <six:six.text_type>`\n    \"\"\"\n    pairs = ((dump_dict(arg) if isinstance(arg, Mapping)\n              else (dump_key_values(arg) if isinstance(arg, Iterable)\n                    else None))\n             for arg in args + (kwargs, ))\n    return _format_pairs(chain.from_iterable(p for p in pairs if p))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntrigger the task that sends invitation messages", "response": "def post(self, request, *args, **kwargs):\n        \"\"\" Triggers the task that sends invitation messages\n        \"\"\"\n        status = 201\n        accepted = {\"accepted\": True}\n        send_invite_messages.apply_async()\n        return Response(accepted, status=status)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef post(self, request):\n        '''Create a user and token, given an email. If user exists just\n        provide the token.'''\n        serializer = CreateUserSerializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n\n        email = serializer.validated_data.get('email')\n        try:\n            user = User.objects.get(username=email)\n        except User.DoesNotExist:\n            user = User.objects.create_user(email, email=email)\n        token, created = Token.objects.get_or_create(user=user)\n\n        return Response(\n            status=status.HTTP_201_CREATED, data={'token': token.key})", "response": "Create a user and token given an email. If user exists just\n        provide the token."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nredefines parent s method.", "response": "def dispatch(self, request, *args, **kwargs):\n        \"\"\"\n        Redefine parent's method.\n\n        Called on each new request from user.\n\n        Main difference between Django's approach and ours - we don't push\n        a 'request' to a method call. We use 'self.request' instead.\n        \"\"\"\n        # this part copied from django source code\n        if request.method.lower() in self.http_method_names:\n            handler = getattr(self, request.method.lower(),\n                              self.http_method_not_allowed)\n        else:\n            handler = self.http_method_not_allowed\n        # we changed only this line - removed first 'request' argument\n        return handler(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend html document to user.", "response": "def html(self, data=None, template=None):\n        \"\"\"\n        Send html document to user.\n\n        Args:\n        - data: Dict to render template, or string with rendered HTML.\n        - template: Name of template to render HTML document with passed data.\n        \"\"\"\n        if data is None:\n            data = {}\n        if template:\n            return render(self.request, template, data)\n        return HttpResponse(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfilters queryset by a comma delimeted skill list", "response": "def by_skills(queryset, skill_string=None):\n  \"\"\" Filter queryset by a comma delimeted skill list \"\"\"\n  if skill_string:\n    operator, items = get_operator_and_items(skill_string)\n    q_obj = SQ()\n    for s in items:\n      if len(s) > 0:\n        q_obj.add(SQ(skills=s), operator)\n    queryset = queryset.filter(q_obj)\n  return queryset"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfiltering queryset by a comma delimeted cause list", "response": "def by_causes(queryset, cause_string=None):\n  \"\"\" Filter queryset by a comma delimeted cause list \"\"\"\n  if cause_string:\n    operator, items = get_operator_and_items(cause_string)\n    q_obj = SQ()\n    for c in items:\n      if len(c) > 0:\n        q_obj.add(SQ(causes=c), operator)\n    queryset = queryset.filter(q_obj)\n  return queryset"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef by_published(queryset, published_string='true'):\n  if published_string == 'true':\n    queryset = queryset.filter(published=1)\n  elif published_string == 'false':\n    queryset = queryset.filter(published=0)\n  # Any other value will return both published and unpublished\n  return queryset", "response": "Filter queryset by published status"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef by_name(queryset, name=None):\n  if name:\n    queryset = queryset.filter(name=name)\n  return queryset", "response": "Filter queryset by name with word wide auto - completion"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef by_address(queryset, address='', project=False):\n  if address:\n    address = json.loads(address)\n    if u'address_components' in address:\n      q_objs = []\n\n      \"\"\"\n      Caribbean filter\n      \"\"\"\n      if len(address[u'address_components']):\n        if address[u'address_components'][0]['long_name'] == 'Caribbean':\n          queryset = queryset.filter(\n            SQ(address_components=helpers.whoosh_raw(u\"{}-{}\".format('Jamaica', 'country').strip())) |\n            SQ(address_components=helpers.whoosh_raw(u\"{}-{}\".format('Haiti', 'country').strip())) |\n            SQ(address_components=helpers.whoosh_raw(u\"{}-{}\".format('Saint Lucia', 'country').strip())) |\n            SQ(address_components=helpers.whoosh_raw(u\"{}-{}\".format('Suriname', 'country').strip())) |\n            SQ(address_components=helpers.whoosh_raw(u\"{}-{}\".format('Trinidad & Tobago', 'country').strip()))\n          )\n\n          return queryset\n\n        for component in address[u'address_components']:\n          q_obj = SQ()\n          test = ''\n\n          for component_type in component[u'types']:\n            type_string = helpers.whoosh_raw(u\"{}-{}\".format(component[u'long_name'], component_type).strip())\n            q_obj.add(SQ(address_components=type_string), SQ.OR)\n\n          q_objs.append(q_obj)\n\n        # Filter all address components\n        for obj in q_objs:\n          queryset = queryset.filter(obj)\n      else: # remote projects\n        if project:\n          queryset = queryset.filter(can_be_done_remotely=1)\n  return queryset", "response": "Filter queryset by publish status."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove unwanted results from queryset", "response": "def filter_out(queryset, setting_name):\n  \"\"\"\n  Remove unwanted results from queryset\n  \"\"\"\n  kwargs = helpers.get_settings().get(setting_name, {}).get('FILTER_OUT', {})\n  queryset = queryset.exclude(**kwargs)\n  return queryset"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_apps():\n    return [(d.split('.')[-1], d.split('.')[-1]) for d in os.listdir(\n        os.getcwd()) if is_app(u\"{}/{}\".format(os.getcwd(), d))]", "response": "It returns a list of applications contained in PROJECT_APPS\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef slug(self):\n        if self.is_root_node():\n            return \"\"\n        if self.slugable and self.parent.parent:\n            if not self.page.regex or (self.page.regex and not self.page.show_regex) or self.is_leaf_node():\n                return u\"{0}/{1}\".format(self.parent.slug, self.page.slug)\n            elif self.page.regex and self.value_regex and self.page.show_regex:\n                return u'{0}/{1}/{2}'.format(self.parent.slug, self.page.slug, self.value_regex)\n            elif not self.hide_in_url:\n                return u'{0}/{1}'.format(self.parent.slug, self.name)\n        elif self.slugable:\n            if not self.page.regex or (self.page.regex and not self.page.show_regex) or self.is_leaf_node():\n                return u\"{0}\".format(self.page.slug)\n            elif self.page.regex and self.value_regex and self.page.show_regex:\n                return u'{0}/{1}'.format(self.page.slug, self.value_regex)\n            elif not self.hide_in_url:\n                return u'{0}'.format(self.name)\n        return \"\"", "response": "It returns the slug of the current node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if the node is slugable in the following cases False otherwise.", "response": "def slugable(self):\n        \"\"\"\n        A node is slugable in following cases:\n        1 - Node doesn't have children.\n        2 - Node has children but its page doesn't have a regex.\n        3 - Node has children, its page has regex but it doesn't show it.\n        4 - Node has children, its page shows his regex and node has a default value for regex.\n        5 - Node hasn't a page but it ins't hidden in url.\n        \"\"\"\n        if self.page:\n            if self.is_leaf_node():\n                return True\n            if not self.is_leaf_node() and not self.page.regex:\n                return True\n            if not self.is_leaf_node() and self.page.regex and not self.page.show_regex:\n                return True\n            if not self.is_leaf_node() and self.page.regex and self.page.show_regex and self.value_regex:\n                return True\n        elif not self.is_leaf_node() and not self.hide_in_url:\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_pattern(self):\n        if self.is_root_node():\n            return \"\"\n        else:\n            parent_pattern = self.parent.get_pattern()\n            if parent_pattern != \"\":\n                parent_pattern = u\"{}\".format(parent_pattern)\n            if not self.page and not self.is_leaf_node():\n                if self.hide_in_url:\n                    return u'{0}'.format(parent_pattern)\n                else:\n                    return u'{0}{1}'.format(parent_pattern, self.name)\n            else:\n                if self.is_leaf_node() and self.page.regex and self.page.show_regex:\n                    return u'{0}{1}/{2}'.format(parent_pattern, self.page.slug, self.page.regex)\n                elif self.is_leaf_node() and (not self.page.regex or not self.page.show_regex):\n                    return u'{0}{1}/'.format(parent_pattern, self.page.slug)\n                elif not self.is_leaf_node() and self.page.regex and self.page.show_regex:\n                    return u'{0}{1}/{2}/'.format(parent_pattern, self.page.slug, self.page.regex)\n                else:\n                    return u'{0}{1}/'.format(parent_pattern, self.page.slug)", "response": "It returns its url pattern"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef presentation_type(self):\n        if self.page and self.page.presentation_type:\n            return self.page.presentation_type\n        return \"\"", "response": "It returns page s presentation_type"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef view_path(self):\n        if self.scheme_name is None or self.scheme_name == \"\":\n            return self.view.view_path\n        else:\n            return self.scheme_name", "response": "It returns view s view path"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_static_vars(self, node):\n        if self.static_vars == \"\" and hasattr(self, \"template\"):\n            self.static_vars = {\n                'upy_context': {\n                    'template_name': u\"{}/{}\".format(self.template.app_name, self.template.file_name)\n                }\n            }\n        elif hasattr(self, \"template\"):\n            self.static_vars = literal_eval(self.static_vars)\n            self.static_vars['upy_context']['template_name'] = u\"{}/{}\".format(\n                self.template.app_name, self.template.file_name\n            )\n        self.static_vars['upy_context']['NODE'] = node\n        self.static_vars['upy_context']['PAGE'] = self", "response": "This function checks if a Page has static vars"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset or unsets your away status.", "response": "def away(self, msg=''):\n        \"\"\"\n        Sets/unsets your away status.\n        Optional arguments:\n        * msg='' - Away reason.\n        \"\"\"\n        with self.lock:\n            self.send('AWAY :%s' % msg)\n            if self.readable():\n                msg = self._recv(expected_replies=('306', '305'))\n                if msg[0] == '306':\n                    self.is_away = True\n                elif msg[0] == '305':\n                    self.is_away = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rehash(self):\n        with self.lock:\n            self.send('REHASH')\n            if self.readable():\n                msg = self._recv(expected_replies=('382',))\n                if msg[0] == '382':\n                    pass", "response": "Rehashes the configuration file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntell the IRCd to die.", "response": "def die(self, password=''):\n        \"\"\"\n        Tells the IRCd to die.\n        Optional arguments:\n        * password='' - Die command password.\n        \"\"\"\n        with self.lock:\n            self.send('DIE :%s' % password, error_check=True)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntelling the IRCd to restart.", "response": "def restart(self, password=''):\n        \"\"\"\n        Tells the IRCd to restart.\n        Optional arguments:\n        * password='' - Restart command password.\n        \"\"\"\n        with self.lock:\n            self.send('RESTART :%s' % password, error_check=True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef userhost(self, nicks):\n        with self.lock:\n            self.send('USERHOST :%s' % nicks)\n            userhosts = []\n            if self.readable():\n                msg = self._recv(expected_replies=('302',))\n                if msg[0] == '302':\n                    userhosts = msg[2].replace(':', '', 1).split()\n            return userhosts", "response": "Returns a list of userhosts for a given nick."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ison(self, nicks):\n        with self.lock:\n            self.send('ISON :%s' % ' '.join(nicks))\n            online_nicks = []\n            if self.readable():\n                msg = self._recv(expected_replies=('303',))\n                if msg[0] == '303':\n                    online_nicks = msg[2].replace(':', '', 1).split()\n            return online_nicks", "response": "Checks if a nick is on or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_token(self):\n\n        response = self._make_request()\n        self.auth = response\n        self.token = response['token']", "response": "Make a request to generate a token."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef linreg_ols_svd(y, X, rcond=1e-15):\n    import numpy as np\n    try:  # solve OLS formula\n        beta, _, _, singu = np.linalg.lstsq(b=y, a=X, rcond=rcond)\n    except np.linalg.LinAlgError:\n        print(\"LinAlgError: computation does not converge.\")\n        return None\n\n    # check singu\n    if np.any(singu < 0.0):\n        print(\"Error: A singular value of X is numerically not well-behaved.\")\n        return None\n\n    # return estimated model parameters\n    return beta", "response": "Linear Regression OLS inv by SVD"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef genrepl(scope):\n\n    def repl(match):\n        \"\"\"Internal replacement function.\"\"\"\n\n        name = match.group('name')\n\n        value = lookup(name, scope=scope)\n\n        result = name.replace('.', '_')\n        scope[result] = value\n\n        return result\n\n    return repl", "response": "Replacement function with specific scope."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nresolving a python expression to a single object.", "response": "def resolvepy(\n        expr,\n        safe=DEFAULT_SAFE, tostr=DEFAULT_TOSTR, scope=DEFAULT_SCOPE,\n        besteffort=DEFAULT_BESTEFFORT\n    ):\n    \"\"\"Resolve input expression.\n\n    :param str expr: configuration expression to resolve in this language.\n    :param bool safe: safe run execution context (True by default).\n    :param bool tostr: format the result.\n    :param dict scope: execution scope (contains references to expression\n        objects).\n    :param bool besteffort: try to resolve unknown variable name with execution\n        runtime.\"\"\"\n\n    result = None\n\n    _eval = safe_eval if safe else eval\n\n    _expr = expr\n\n    scope = {} if scope is None else scope.copy()\n\n    while True:\n\n        try:\n            result = _eval(_expr, scope)\n\n        except (AttributeError, NameError) as nex:\n\n            if not besteffort:\n                raise\n\n            arg = nex.args[0]\n            missing = MISSING_NAME_REGEX.findall(arg)[-1]\n\n            try:\n                _expr = sub(\n                    MISSING_VARIABLE.format(missing),\n                    genrepl(scope=scope),\n                    _expr\n                )\n\n            except ImportError:\n                raise nex\n\n        else:\n            break\n\n    if tostr:\n        result = str(result)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nround a datetime to 5 minutes boundary.", "response": "def round_to_5_minutes(moment):\n    '''Round datetime to 5 minutes boundary:\n\n    - if moment.minute < 5 -> moment.minute = 0\n    - if moment.minute >= 5 -> moment.minute = 0\n\n    :param moment: a :class:`datetime.datetime` instance.\n    '''\n    return moment - timedelta(minutes=moment.minute % 5, seconds=moment.second)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef image(radar, at=None):\n    '''Retrieve a radar image.\n\n    :param radar: radar station no.\n    :param at: stat datetime, defaults to now.\n    '''\n    at = round_to_5_minutes(at or datetime.utcnow())\n\n    return ''.join([\n        'http://image.nmc.cn/product',\n        '/{0}'.format(at.year),\n        '/{0}'.format(at.strftime('%Y%m')),\n        '/{0}'.format(at.strftime('%Y%m%d')),\n        '/RDCP/medium/SEVP_AOC_RDCP_SLDAS_EBREF_',\n        '{0}_L88_PI_'.format(radar),\n        '{0}00000.GIF'.format(at.strftime('%Y%m%d%H%M'))\n    ])", "response": "Retrieve a radar image."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pickle_compress(obj, print_compression_info=False):\n    p = pickle.dumps(obj)\n    c = zlib.compress(p)\n    if print_compression_info:\n        print (\"len = {:,d} compr={:,d} ratio:{:.6f}\".format(len(p), len(c), float(len(c))/len(p)))\n    return c", "response": "pickle and compress an object"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves data from BT Home Hub 5 and return parsed result.", "response": "def get_devicelist(home_hub_ip='192.168.1.254'):\n    \"\"\"Retrieve data from BT Home Hub 5 and return parsed result.\n    \"\"\"\n\n    url = 'http://{}/'.format(home_hub_ip)\n\n    try:\n        response = requests.get(url, timeout=5)\n    except requests.exceptions.Timeout:\n        _LOGGER.exception(\"Connection to the router timed out\")\n        return\n    if response.status_code == 200:\n        return parse_devicelist(response.text)\n    else:\n        _LOGGER.error(\"Invalid response from Home Hub: %s\", response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_devicelist(data_str):\n\n    p = HTMLTableParser()\n    p.feed(data_str)\n\n    known_devices = p.tables[9]\n\n    devices = {}\n\n    for device in known_devices:\n        if len(device) == 5 and device[2] != '':\n            devices[device[2]] = device[1]\n\n    return devices", "response": "Parse the BT Home Hub 5 data format."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef comments_for(context, obj):\n    form_class = import_dotted_path(settings.COMMENT_FORM_CLASS)\n    form = form_class(context[\"request\"], obj)\n    context_form = context.get(\"posted_comment_form\", form)\n    context.update({\n        'posted_comment_form':\n            context_form if context_form.target_object == obj else form,\n        'unposted_comment_form': form,\n        'comment_url': reverse(\"comment\"),\n        'object_for_comments': obj,\n    })\n    return context", "response": "Provides a generic context variable name for the object that\n    comments are being rendered for."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of child comments for the given parent.", "response": "def comment_thread(context, parent):\n    \"\"\"\n    Return a list of child comments for the given parent, storing all\n    comments in a dict in the context when first called, using parents\n    as keys for retrieval on subsequent recursive calls from the\n    comments template.\n    \"\"\"\n    if \"all_comments\" not in context:\n        comments = defaultdict(list)\n        if \"request\" in context and context[\"request\"].user.is_staff:\n            comments_queryset = parent.comments.all()\n        else:\n            comments_queryset = parent.comments.visible()\n        for comment in comments_queryset.select_related(\"user\"):\n            comments[comment.replied_to_id].append(comment)\n        context[\"all_comments\"] = comments\n    parent_id = parent.id if isinstance(parent, ThreadedComment) else None\n    try:\n        replied_to = int(context[\"request\"].POST[\"replied_to\"])\n    except KeyError:\n        replied_to = 0\n    context.update({\n        \"comments_for_thread\": context[\"all_comments\"].get(parent_id, []),\n        \"no_comments\": parent_id is None and not context[\"all_comments\"],\n        \"replied_to\": replied_to,\n    })\n    return context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndisplaying the most recent comments.", "response": "def recent_comments(context):\n    \"\"\"\n    Dashboard widget for displaying recent comments.\n    \"\"\"\n    latest = context[\"settings\"].COMMENTS_NUM_LATEST\n    comments = ThreadedComment.objects.all().select_related(\"user\")\n    context[\"comments\"] = comments.order_by(\"-id\")[:latest]\n    return context"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef comment_filter(comment_text):\n    filter_func = settings.COMMENT_FILTER\n    if not filter_func:\n        def filter_func(s):\n            return linebreaksbr(urlize(s, autoescape=True), autoescape=True)\n    elif not callable(filter_func):\n        filter_func = import_dotted_path(filter_func)\n    return filter_func(comment_text)", "response": "Returns the comment text that should be rendered through the function defined\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nattempts to convert the given argument into a log level.", "response": "def log_level(level):\n    \"\"\"\n    Attempt to convert the given argument into a log level.\n\n    Log levels are represented as integers, where higher values are more \n    severe.  If the given level is already an integer, it is simply returned.  \n    If the given level is a string that can be converted into an integer, it is \n    converted and that value is returned.  Finally, if the given level is a \n    string naming one of the levels defined in the logging module, return that \n    level.  If none of those conditions are met, raise a ValueError.\n    \"\"\"\n    from six import string_types\n\n    if isinstance(level, int):\n        return level\n\n    if isinstance(level, string_types):\n        try: return int(level)\n        except ValueError: pass\n\n        try: return getattr(logging, level.upper())\n        except AttributeError: pass\n\n    raise ValueError(\"cannot convert '{}' into a log level\".format(level))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef verbosity(verbosity):\n    verbosity = int(verbosity)\n\n    if verbosity == 0:\n        return logging.WARNING\n    if verbosity == 1:\n        return logging.INFO\n    if verbosity == 2:\n        return logging.DEBUG\n    if verbosity >= 3:\n        return 0\n    else:\n        raise ValueError", "response": "Convert the number of times the user specified - v on the command - line \n    into a log level."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconfigure the logging module.", "response": "def config(stream=sys.stderr,\n           level=logging.NOTSET,\n           format='%(levelname)s [%(name)s:%(lineno)s] %(message)s',\n           file=None,\n           file_level=None,\n           file_format=None):\n    \"\"\"\n    Configure logging to stream and file concurrently.\n\n    Allows setting a file and stream to log to concurrently with differing \n    level if desired.  Must provide either stream or file.\n\n    Parameters\n    ----------\n    stream: File like:\n        Stream to write file to [Default: sys.stderr]. If none, will not write \n        to stream.\n\n    level: str|int\n        Log level. Allowable levels are those recognized by the logging module.\n\n    format: str\n        Format string for the emitted logs. Default: 'log_level [logger_name] \n        message'\n\n    file: str\n        Path to write log to file. If None, will not log to file.\n\n    file_level: str|int|None\n        Overwrite log level for the file. Will default to `level` if None.\n\n    file_format: str|None\n        Overwrite format of logs for file. Will default to `format` if None.\n    \"\"\"\n    # It doesn't make sense to configure a logger with no handlers.\n    assert file is not None or stream is not None\n\n    # Set the formats.\n    stream_format = format\n    if file_format is None:\n        file_format = stream_format\n\n    # Get the log levels\n    stream_level = log_level(level)\n    if file_level is None:\n        file_level = stream_level\n    else:\n        file_level = log_level(file_level)\n\n    # Everything falls to pieces if I don't use basicConfig.\n    if stream is not None:\n        logging.basicConfig(stream=stream,\n                            level=stream_level,\n                            format=stream_format)\n        # Configure file\n        if file is not None:\n            file = logging.FileHandler(filename=file)\n            file.setLevel(file_level)\n            file.setFormatter(logging.Formatter(file_format))\n            logging.getLogger().addHandler(file)\n    elif file is not None:\n        logging.basicConfig(filename=file,\n                            level=file_level,\n                            format=file_format)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlogs a message at the given log level.", "response": "def _log(level, message, frame_depth=2, **kwargs):\n    \"\"\"\n    Log the given message with the given log level using a logger named based \n    on the scope of the calling code.  This saves you time because you will be \n    able to see where all your log messages are being generated from without \n    having to type anything.  This function is meant to be called by one or \n    more wrapper functions, so the `frame_depth` argument is provided to \n    specify which scope should be used to name the logger.\n    \"\"\"\n    import inspect\n\n    try:\n        # Inspect variables two frames up from where we currently are (by \n        # default).  One frame up is assumed to be one of the helper methods \n        # defined in this module, so we aren't interested in that.  Two frames \n        # up should be the frame that's actually trying to log something.\n\n        frame = inspect.stack()[frame_depth][0]\n        frame_below = inspect.stack()[frame_depth-1][0]\n        \n        # Collect all the variables in the scope of the calling code, so they \n        # can be substituted into the message.\n\n        scope = {}\n        scope.update(frame.f_globals)\n        scope.update(frame.f_locals)\n\n        # If the calling frame is inside a class (deduced based on the presence \n        # of a 'self' variable), name the logger after that class.  Otherwise \n        # if the calling frame is inside a function, name the logger after that \n        # function.  Otherwise name it after the module of the calling scope.\n\n        self = frame.f_locals.get('self')\n        function = inspect.getframeinfo(frame).function\n        module = frame.f_globals['__name__']\n\n        if self is not None:\n            name = '.'.join([\n                    self.__class__.__module__,\n                    self.__class__.__name__\n            ])\n\n        elif function != '<module>':\n            name = '.'.join([module, function])\n\n        else:\n            name = module\n\n        # Trick the logging module into reading file names and line numbers \n        # from the correct frame by monkey-patching logging.currentframe() with \n        # a function that returns the frame below the real calling frame (this \n        # indirection is necessary because the logging module will look one \n        # frame above whatever this function returns).  Undo all this after \n        # logging our message, to avoid interfering with other loggers.\n\n        with _temporarily_set_logging_frame(frame_below):\n            logger = logging.getLogger(name)\n            logger.log(level, message.format(**scope), **kwargs)\n\n    finally:\n        try: del frame\n        except UnboundLocalError: pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __search_book_html(self, anywords, page):\n        _params = {\n            'dt': 'ALL',\n            'cl': 'ALL',\n            'dp': '20',\n            'sf': 'M_PUB_YEAR',\n            'ob': 'DESC',\n            'sm': 'table',\n            'dept': 'ALL',\n            'ecx': '0',\n            'anywords': '',  # not anywords..\n            'page': 1\n        }\n\n        _headers = {\n            'Host': 'lib.wyu.edu.cn',\n            'Referer': 'http://lib.wyu.edu.cn/opac/search.aspx',\n            'Accept-Language': ':zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4'\n        }\n\n        # url\u8981\u5bf9\u4e2d\u6587\u7f16\u7801..\n        _params['anywords'] = anywords.decode('utf-8').encode('gbk')\n        _params['page'] = page\n        r = requests.get(url=WyuLibrary.url_search, headers=_headers, params=_params, timeout=self._timeout)\n        # _.d(r.content.decode(_.get_charset(r.content)))\n        return r.content.decode(_.get_charset(r.content))", "response": "Search book for a set of words."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef search_book(self, anywords, page=1):\n        result = []\n        html = self.__search_book_html(anywords, page)\n        soup = BeautifulSoup(html)\n        tds = soup.select(selector='tbody')[0].select('td')\n        cursor = 1\n        while cursor < len(tds) / 9:\n            s = (cursor - 1) * 9\n            num = tds[s].get_text()\n            ctrlno = tds[s].input.attrs['value']\n            name = tds[s + 1].get_text()\n            author = tds[s + 2].get_text()\n            press = tds[s + 3].get_text()\n            press_time = tds[s + 4].get_text()\n            index_num = tds[s + 5].get_text()\n            total = tds[s + 6].get_text()\n            left = tds[s + 7].get_text()\n            addtion = tds[s + 8].get_text().strip('\\r\\n')  # \u76f8\u5173\u8d44\u6e90\n            book = {\n                'num': num,  # \u5e8f\u53f7\n                'ctrlno': ctrlno,  # \u56fe\u4e66\u9986\u7cfb\u7edf\u63a7\u5236\u53f7(\u5728\u56fe\u4e66\u9986\u7684\u552f\u4e00\u7f16\u53f7)\n                'name': name,  # \u540d\u79f0\n                'author': author,  # \u4f5c\u8005\n                'press': press,  # \u51fa\u7248\u793e\n                'press_time': press_time,  # \u51fa\u7248\u65f6\u95f4\n                'index_num': index_num,  # \u7d22\u53d6\u53f7\n                'total': total,  # \u9986\u85cf\n                'left': left,  # \u5269\u4f59\n            }\n            result.append(book)\n            cursor += 1\n\n        return result", "response": "Search for a set of words in the book."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets WYU - Library status html.", "response": "def __book_status_html(self, ctrlno):\n        \"\"\"\n        \u83b7\u53d6\u56fe\u4e66\u501f\u9605\u9875\u9762\n        :param ctrlno:\n        :return:\n        \"\"\"\n        _params = {\n            'ctrlno': ctrlno\n        }\n        _headers = {\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n            'Accept-Encoding': 'gzip, deflate, sdch',\n            'Accept-Language': 'zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4',\n            'Host': 'lib.wyu.edu.cn',\n            'Referer': 'http://lib.wyu.edu.cn/opac/searchresult.aspx'\n        }\n        r = requests.get(url=WyuLibrary.url_book_info, headers=_headers, params=_params, timeout=self._timeout)\n        # _.d(r.content.decode(_.get_charset(r.content)))\n        return r.content.decode(_.get_charset(r.content))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting ISBN \u4ece\u56fe\u4e66\u501f\u9605\u72b6\u6001\u9875\u9762\u4e2d\u83b7\u53d6 ISBN", "response": "def __get_isbn(self, html):\n        \"\"\"\n        \u4ece\u56fe\u4e66\u501f\u9605\u72b6\u6001\u9875\u9762\u4e2d\u83b7\u53d6isbn\n        :param html:\n        :return:\n        \"\"\"\n\n        import re\n\n        reg = re.compile(r'getBookCover\\(\".*\",\"(.*)\"\\);')\n        res = reg.findall(html)\n        if len(res) > 0:\n            return res[0]\n        else:\n            return ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_switch_state_changed(\n            self, func: Callable[['BaseUnit', SwitchNumber, Optional[bool]], None]):\n        \"\"\"\n        Define the switch state changed callback implementation.\n\n        Expected signature is:\n            switch_state_changed_callback(base_unit, switch_number, state)\n\n        base_unit:      the device instance for this callback\n        switch_number:  the switch whose state has changed\n        state:          True if switch turned on, or False if switch turned off\n        \"\"\"\n        self._on_switch_state_changed = func", "response": "Define the switch state changed callback implementation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart monitoring the base unit.", "response": "def start(self) -> None:\n        \"\"\"\n        Start monitoring the base unit.\n        \"\"\"\n\n        self._shutdown = False\n\n        # Start listening (if server) / Open connection (if client)\n        if isinstance(self._protocol, Server):\n            self.create_task(self._async_listen)\n        elif isinstance(self._protocol, Client):\n            self.create_task(self._async_open)\n        else:\n            raise NotImplementedError"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stop(self) -> None:\n\n        self._shutdown = True\n\n        # Close connection if needed\n        self._protocol.close()\n\n        # Cancel any pending tasks\n        self.cancel_pending_tasks()", "response": "Stop monitoring the base unit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclear the alarm and warning LEDs on base unit and stop siren.", "response": "async def async_clear_status(self, password: str = '') -> None:\n        \"\"\"\n        Clear the alarm/warning LEDs on base unit and stop siren.\n\n        :param password: if specified, will be used instead of the password\n                         property when issuing the command\n        \"\"\"\n\n        await self._protocol.async_execute(\n            ClearStatusCommand(),\n            password=password)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nchange settings for a specific device on the base unit.", "response": "async def async_change_device(\n            self, device_id: int, group_number: int, unit_number: int,\n            enable_status: ESFlags, switches: SwitchFlags) -> None:\n        \"\"\"\n        Change settings for a device on the base unit.\n\n        :param device_id: unique identifier for the device to be changed\n        :param group_number: group number the device is to be assigned to\n        :param unit_number: unit number the device is to be assigned to\n        :param enable_status: flags indicating settings to enable\n        :param switches: indicates switches that will be activated when device is triggered\n        \"\"\"\n\n        # Lookup device using zone to obtain an accurate index and current\n        # values, which will be needed to perform the change command\n        device = self._devices[device_id]\n\n        # If it is a Special device, automatically use the other function\n        # instead (without changing any of the special fields)\n        if isinstance(device, SpecialDevice):\n            await self.async_change_special_device(\n                device_id, group_number, unit_number, enable_status, switches,\n                device.special_status, device.high_limit, device.low_limit,\n                device.control_high_limit, device.control_low_limit)\n            return\n\n        response = await self._protocol.async_execute(\n            GetDeviceCommand(device.category, device.group_number, device.unit_number))\n        if isinstance(response, DeviceInfoResponse):\n            response = await self._protocol.async_execute(\n                ChangeDeviceCommand(\n                    device.category, response.index, group_number, unit_number,\n                    enable_status, switches))\n            if isinstance(response, DeviceSettingsResponse):\n                device._handle_response(response) # pylint: disable=protected-access\n        if isinstance(response, DeviceNotFoundResponse):\n            raise ValueError(\"Device to be changed was not found\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nchange settings for a Special device on the base unit.", "response": "async def async_change_special_device(\n            self, device_id: int, group_number: int, unit_number: int,\n            enable_status: ESFlags, switches: SwitchFlags,\n            special_status: SSFlags, high_limit: Optional[Union[int, float]],\n            low_limit: Optional[Union[int, float]],\n            control_high_limit: Optional[Union[int, float]],\n            control_low_limit: Optional[Union[int, float]]) -> None:\n        \"\"\"\n        Change settings for a 'Special' device on the base unit.\n\n        :param device_id: unique identifier for the device to be changed\n        :param group_number: group number the device is to be assigned to\n        :param unit_number: unit number the device is to be assigned to\n        :param enable_status: flags indicating settings to enable\n        :param switches: indicates switches that will be activated when device is triggered\n        :param special_status: flags indicating 'Special' settings to enable\n        :param high_limit: triggers on readings higher than value\n        :param low_limit: triggers on readings lower than value\n        :param control_high_limit: trigger switch for readings higher than value\n        :param control_low_limit: trigger switch for readings lower than value\n        \"\"\"\n\n        # Lookup device using zone to obtain an accurate index and current\n        # values, which will be needed to perform the change command\n        device = self._devices[device_id]\n\n        # Verify it is a Special device\n        if not isinstance(device, SpecialDevice):\n            raise ValueError(\"Device to be changed is not a Special device\")\n\n        response = await self._protocol.async_execute(\n            GetDeviceCommand(device.category, device.group_number, device.unit_number))\n        if isinstance(response, DeviceInfoResponse):\n            # Control limits only specified when they are supported\n            if response.control_limit_fields_exist:\n                command = ChangeSpecial2DeviceCommand(\n                    device.category, response.index, group_number, unit_number,\n                    enable_status, switches, response.current_status, response.down_count,\n                    response.message_attribute, response.current_reading, special_status,\n                    high_limit, low_limit, control_high_limit, control_low_limit)\n            else:\n                command = ChangeSpecialDeviceCommand(\n                    device.category, response.index, group_number, unit_number,\n                    enable_status, switches, response.current_status, response.down_count,\n                    response.message_attribute, response.current_reading, special_status,\n                    high_limit, low_limit)\n            response = await self._protocol.async_execute(command)\n            if isinstance(response, DeviceSettingsResponse):\n                device._handle_response(response) # pylint: disable=protected-access\n        if isinstance(response, DeviceNotFoundResponse):\n            raise ValueError(\"Device to be changed was not found\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def async_delete_device(self, device_id: int) -> None:\n\n        # Lookup device using zone to obtain an accurate index, which is\n        # needed to perform the delete command\n        device = self._devices[device_id]\n        response = await self._protocol.async_execute(\n            GetDeviceCommand(device.category, device.group_number, device.unit_number))\n        if isinstance(response, DeviceInfoResponse):\n            response = await self._protocol.async_execute(\n                DeleteDeviceCommand(device.category, response.index))\n            if isinstance(response, DeviceDeletedResponse):\n                self._devices._delete(device) # pylint: disable=protected-access\n                if self._on_device_deleted:\n                    try:\n                        self._on_device_deleted(self, device)  # pylint: disable=protected-access\n                    except Exception: # pylint: disable=broad-except\n                        _LOGGER.error(\n                            \"Unhandled exception in on_device_deleted callback\",\n                            exc_info=True)\n        if isinstance(response, DeviceNotFoundResponse):\n            raise ValueError(\"Device to be deleted was not found\")", "response": "Delete an enrolled device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def async_get_datetime(self) -> Optional[datetime]:\n\n        response = await self._protocol.async_execute(\n            GetDateTimeCommand())\n        if isinstance(response, DateTimeResponse):\n            return response.remote_datetime\n        return None", "response": "Get the date and time on the base unit."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def async_get_event_log(self, index: int) -> Optional[EventLogResponse]:\n\n        response = await self._protocol.async_execute(\n            GetEventLogCommand(index))\n        if isinstance(response, EventLogResponse):\n            return response\n        return None", "response": "Get an entry from the event log."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget an entry from the Special sensor log.", "response": "async def async_get_sensor_log(self, index: int) -> Optional[SensorLogResponse]:\n        \"\"\"\n        Get an entry from the Special sensor log.\n\n        :param index: Index for the sensor log entry to be obtained.\n        :return: Response containing the sensor log entry, or None if not found.\n        \"\"\"\n\n        response = await self._protocol.async_execute(\n            GetSensorLogCommand(index))\n        if isinstance(response, SensorLogResponse):\n            return response\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the operation mode on the base unit.", "response": "async def async_set_operation_mode(\n            self, operation_mode: OperationMode, password: str = '') -> None:\n        \"\"\"\n        Set the operation mode on the base unit.\n\n        :param operation_mode: the operation mode to change to\n        :param password: if specified, will be used instead of the password\n                         property when issuing the command\n        \"\"\"\n\n        await self._protocol.async_execute(\n            SetOpModeCommand(operation_mode),\n            password=password)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nturns a switch on or off.", "response": "async def async_set_switch_state(\n            self, switch_number: SwitchNumber, state: bool) -> None:\n        \"\"\"\n        Turn a switch on or off.\n\n        :param switch_number: the switch to be set.\n        :param state: True to turn on, False to turn off.\n        \"\"\"\n\n        await self._protocol.async_execute(\n            SetSwitchCommand(\n                switch_number,\n                SwitchState.On if state else SwitchState.Off))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef as_dict(self) -> Dict[str, Any]:\n        def _on_filter(obj: Any, name: str) -> bool:\n            # Filter out any callbacks\n            if isinstance(obj, BaseUnit):\n                if name.startswith('on_'):\n                    return False\n            return True\n\n        return serializable(self, on_filter=_on_filter)", "response": "Converts to a dict of attributes for easier serialization."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self):\n        '''\n        Update our object's data\n        '''\n        self._json = self._request(\n            method='GET',\n            url=self.API\n        )._json", "response": "Update our object s data"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the address of this object minus the scheme hostname and port of the bridge", "response": "def address(self):\n        '''\n        Return the address of this \"object\", minus the scheme, hostname\n        and port of the bridge\n        '''\n        return self.API.replace(\n            'http://{}:{}'.format(\n                self._bridge.hostname,\n                self._bridge.port\n            ), ''\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the bundle map from Clarify.", "response": "def _load_bundle_map(self):\n        '''\n        Return a map of all bundles in the Clarify app that have an external_id set for them.\n        The bundles with external_ids set are assumed to be the ones we have inserted from Brightcove.\n        The external_id contains the Brightcove video id.\n        '''\n        bundle_map = {}\n        next_href = None\n        has_next = True\n\n        while has_next:\n            bundles = self.clarify_client.get_bundle_list(href=next_href, embed_items=True)\n            items = get_embedded_items(bundles)\n            for item in items:\n                bc_video_id = item.get('external_id')\n                if bc_video_id is not None and len(bc_video_id) > 0:\n                    bundle_map[bc_video_id] = item\n            next_href = get_link_href(bundles, 'next')\n            if next_href is None:\n                has_next = False\n        return bundle_map"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate the searchable metadata that we ll store in the bundle for the video", "response": "def _metadata_from_video(self, video):\n        '''Generate the searchable metadata that we'll store in the bundle for the video'''\n        long_desc = video['long_description']\n        if long_desc is not None:\n            long_desc = long_desc[:MAX_METADATA_STRING_LEN]\n\n        tags = video.get('tags')\n\n        metadata = {\n            'name': default_to_empty_string(video.get('name')),\n            'description': default_to_empty_string(video.get('description')),\n            'long_description': default_to_empty_string(long_desc),\n            'tags': tags if tags is not None else [],\n            'updated_at': video.get('updated_at'),\n            'created_at': video.get('created_at'),\n            'state': video.get('state')\n        }\n        return metadata"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the url for the video media that we can send to Clarify", "response": "def _src_media_url_for_video(self, video):\n        '''Get the url for the video media that we can send to Clarify'''\n        src_url = None\n        best_height = 0\n        best_source = None\n\n        # TODO: This assumes we have ingested videos. For remote videos, check if the remote flag is True\n        # and if so, use the src url from the Asset endpoint.\n        video_sources = self.bc_client.get_video_sources(video['id'])\n        # Look for codec H264 with good resolution\n        for source in video_sources:\n            height = source.get('height', 0)\n            codec = source.get('codec')\n            if source.get('src') and codec and codec.upper() == 'H264' and height <= 1080 and height > best_height:\n                best_source = source\n\n        if best_source is not None:\n            src_url = best_source['src']\n        return src_url"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _update_metadata_for_video(self, metadata_href, video):\n        '''\n        Update the metadata for the video if video has been updated in Brightcove since the bundle\n        metadata was last updated.\n        '''\n        current_metadata = self.clarify_client.get_metadata(metadata_href)\n        cur_data = current_metadata.get('data')\n\n        if cur_data.get('updated_at') != video['updated_at']:\n            self.log('Updating metadata for video {0}'.format(video['id']))\n            if not self.dry_run:\n                metadata = self._metadata_from_video(video)\n                self.clarify_client.update_metadata(metadata_href, metadata=metadata)\n            self.sync_stats['updated'] += 1", "response": "Update the metadata for the video if the video has been updated since the bundle was last updated."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding options to nosetests.", "response": "def options(self, parser, env=os.environ):\n        \"Add options to nosetests.\"\n        parser.add_option(\"--%s-record\" % self.name,\n                          action=\"store\",\n                          metavar=\"FILE\",\n                          dest=\"record_filename\",\n                          help=\"Record actions to this file.\")\n        parser.add_option(\"--%s-playback\" % self.name,\n                          action=\"store\",\n                          metavar=\"FILE\",\n                          dest=\"playback_filename\",\n                          help=\"Playback actions from this file.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ningests CSV data into a sequence number.", "response": "def ingest_csv(csv_data, message_set):\n    \"\"\" Expecting data in the following format:\n    message_id,en,safe,af,safe,zu,safe,xh,safe,ve,safe,tn,safe,ts,safe,ss,safe,st,safe,nso,safe,nr,safe\n    \"\"\"\n    records = csv.DictReader(csv_data)\n    for line in records:\n        for key in line:\n            # Ignore non-content keys and empty keys\n            if key not in [\"message_id\", \"safe\"] and line[key] != \"\":\n                try:\n                    with transaction.atomic():\n                        message = Message()\n                        message.message_set = message_set\n                        message.sequence_number = line[\"message_id\"]\n                        message.lang = key\n                        message.content = line[key]\n                        message.save()\n                except (IntegrityError, ValueError) as e:\n                    message = None\n                    # crappy CSV data\n                    standard_logger.error(e)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ensure_one_subscription():\n    cursor = connection.cursor()\n    cursor.execute(\"UPDATE subscription_subscription SET active = False \\\n                    WHERE id NOT IN \\\n                   (SELECT MAX(id) as id FROM \\\n                    subscription_subscription GROUP BY to_addr)\")\n    affected = cursor.rowcount\n    vumi_fire_metric.delay(\n        metric=\"subscription.duplicates\", value=affected, agg=\"last\")\n    return affected", "response": "Ensure that only one subscription is active"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntrying to find meta tag in given dom.", "response": "def _get_encoding(dom, default=\"utf-8\"):\n    \"\"\"\n    Try to look for meta tag in given `dom`.\n\n    Args:\n        dom (obj): pyDHTMLParser dom of HTML elements.\n        default (default \"utr-8\"): What to use if encoding is not found in\n                                   `dom`.\n\n    Returns:\n        str/default: Given encoding or `default` parameter if not found.\n    \"\"\"\n    encoding = dom.find(\"meta\", {\"http-equiv\": \"Content-Type\"})\n\n    if not encoding:\n        return default\n\n    encoding = encoding[0].params.get(\"content\", None)\n\n    if not encoding:\n        return default\n\n    return encoding.lower().split(\"=\")[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries to convert html to utf - 8.", "response": "def handle_encodnig(html):\n    \"\"\"\n    Look for encoding in given `html`. Try to convert `html` to utf-8.\n\n    Args:\n        html (str): HTML code as string.\n\n    Returns:\n        str: HTML code encoded in UTF.\n    \"\"\"\n    encoding = _get_encoding(\n        dhtmlparser.parseString(\n            html.split(\"</head>\")[0]\n        )\n    )\n\n    if encoding == \"utf-8\":\n        return html\n\n    return html.decode(encoding).encode(\"utf-8\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if the element object matches rest of the parameters and content.", "response": "def is_equal_tag(element, tag_name, params, content):\n    \"\"\"\n    Check is `element` object match rest of the parameters.\n\n    All checks are performed only if proper attribute is set in the HTMLElement.\n\n    Args:\n        element (obj): HTMLElement instance.\n        tag_name (str): Tag name.\n        params (dict): Parameters of the tag.\n        content (str): Content of the tag.\n\n    Returns:\n        bool: True if everyhing matchs, False otherwise.\n    \"\"\"\n    if tag_name and tag_name != element.getTagName():\n        return False\n\n    if params and not element.containsParamSubset(params):\n        return False\n\n    if content is not None and content.strip() != element.getContent().strip():\n        return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef call_api_fetch(self, params, get_latest_only=True):\n\n        output_format = 'application/json'\n        url_string = self.request_info.url_string()\n\n\n        # passing the username and required output format\n        headers_list = {\"Accept\": output_format, \"Host\": self.request_info.host}\n\n        try:\n            hub_result = requests.get(url_string, headers=headers_list, timeout=10.000, verify=False)\n            if hub_result.ok == False:\n                raise ConnectionRefusedError(\"Connection to Triangulum hub refused: \" + hub_result.reason)\n        except:\n            raise ConnectionError(\"Error connecting to Triangulum hub - check internet connection.\")\n\n        result = {}\n        result_content_json = hub_result.json()\n        result['ok'] = hub_result.ok\n\n        result['content'] = json.dumps(result_content_json)\n        if \"Items\" in result_content_json:\n            available_matches = len(result_content_json['Items'])\n        else:\n            available_matches = 1\n\n        # No Date params allowed in call to hub, so apply get latest only to hub results here...\n        if (get_latest_only and self.request_info.last_fetch_time != None):\n            try:\n                # Filter python objects with list comprehensions\n                new_content = [x for x in result_content_json['Items']\n                          if self.get_date_time(x['Timestamp']) > self.request_info.last_fetch_time]\n\n                result_content_json['Items'] = new_content\n                result['content'] = json.dumps(result_content_json)\n                result['ok'] = True\n            except ValueError as e:\n                result['ok'] = False\n                result['reason'] = str(e)\n            except Exception as e:\n                result['ok'] = False\n                result['reason'] = 'Problem sorting results by date to get latest only. ' + str(e)\n\n        result['available_matches'] = available_matches\n        if 'Items' in result_content_json:\n            result['returned_matches'] = len(result_content_json['Items'])\n        else:\n            result['returned_matches'] = 1\n\n\n        # Set last_fetch_time for next call\n        if (get_latest_only):\n            if (len(result_content_json['Items']) > 0):\n                try:\n                    newlist = sorted(result_content_json['Items'],\n                                     key=lambda k: self.get_date_time(k[\"Timestamp\"]),\n                                     reverse=True)\n\n                    most_recent = newlist[0][\"Timestamp\"]\n                    self.request_info.last_fetch_time = self.get_date_time(most_recent)\n                except ValueError as e:\n                    result['ok'] = False\n                    result['reason'] = str(e)\n                except Exception as e:\n                    result['ok'] = False\n                    result['reason'] = 'Problem sorting results by date to get latest only. ' + str(e)\n\n        return result", "response": "This method is called by the hub to get the list of available items from the Triangulum hub."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreact to given AMQP message.", "response": "def reactToAMQPMessage(message, send_back):\n    \"\"\"\n    React to given (AMQP) message. `message` is expected to be\n    :py:func:`collections.namedtuple` structure from :mod:`.structures` filled\n    with all necessary data.\n\n    Args:\n        message (object): One of the request objects defined in\n                          :mod:`.structures`.\n        send_back (fn reference): Reference to function for responding. This is\n                  useful for progress monitoring for example. Function takes\n                  one parameter, which may be response structure/namedtuple, or\n                  string or whatever would be normally returned.\n\n    Returns:\n        object: Response class from :mod:`structures`.\n\n    Raises:\n        ValueError: if bad type of `message` structure is given.\n    \"\"\"\n    _hnas_protection()\n\n    if _instanceof(message, SaveRequest):\n        # Tree\n        if _instanceof(message.record, Tree):\n            tree_handler().add_tree(message.record)\n\n            return TreeInfo(\n                path=message.record.path,\n                url_by_path=_compose_tree_url(message.record),\n                url_by_issn=_compose_tree_url(message.record, issn_url=True),\n            )\n\n        # Publication\n        save_fn = save_publication\n        class_ref = DBPublication\n\n        # Archive\n        if _instanceof(message.record, Archive):\n            save_fn = save_archive\n            class_ref = DBArchive\n\n        return save_fn(\n            class_ref.from_comm(message.record)\n        )\n\n    elif _instanceof(message, SearchRequest):\n        # Publication\n        search_fn = search_publications\n        class_ref = DBPublication\n\n        # Archive\n        if _instanceof(message.query, Archive):\n            search_fn = search_archives\n            class_ref = DBArchive\n\n        results = search_fn(\n            class_ref.from_comm(message.query)\n        )\n\n        return SearchResult(\n            records=[\n                record.to_comm(light_request=message.light_request)\n                for record in results\n            ]\n        )\n\n    raise ValueError(\"'%s' is unknown type of request!\" % str(type(message)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_redis_url(redis_url):\n    '''\n    >>> parse_redis_url('redis://:pass%20@localhost:1234/selecteddb%20')\n    ('localhost', 1234, 'pass ', 'selecteddb ')\n    >>> parse_redis_url('redis://:pass%20@localhost:1234/')\n    ('localhost', 1234, 'pass ', None)\n    >>> parse_redis_url('redis://localhost:1234/')\n    ('localhost', 1234, None, None)\n    >>> parse_redis_url('redis://localhost:1234')\n    ('localhost', 1234, None, None)\n    >>> parse_redis_url('redis://localhost/')\n    ('localhost', 6379, None, None)\n    >>> parse_redis_url('redis://')\n    ('localhost', 6379, None, None)\n    >>> parse_redis_url('redis://')\n    ('localhost', 6379, None, None)\n    '''\n    (use, pas, hos, por, pat) = _parse_url(redis_url, 'redis://', def_port=6379)\n    return (hos, por, pas, pat)", "response": "Parses a Redis url into a sequence of nodes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding a file path from the given list of paths and return the contents.", "response": "def read(*paths):\r\n    \"\"\"Build a file path from *paths* and return the contents.\"\"\"\r\n    p = os.path.join(*paths)\r\n    if os.path.exists(p):\r\n        with open(p, 'r') as f:\r\n            return f.read()\r\n    return ''"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning webcam pipeline and optionally record the video to the specified output file path.", "response": "def run(self, output_path, device_config=None, bitrate=350 << 3 << 10,\n            sink=None):\n        '''\n        Run webcam pipeline and optionally record the video to the specified\n        output file path.\n\n        __NB__ The output file container is determined based on the extension\n        of the output file path.  Supported containers are `avi` and `mp4`.  In\n        either case, the video is encoded in MPEG4 format.\n\n        Arguments\n        ---------\n\n         - `output_path`: Output file path.\n         - `device_config`:\n           * Configuration dictionary or a `pandas.Series` in the format of a\n             row of a frame returned by `caps.get_device_configs()`.\n           * If not provided, the GStreamer `autovideosrc` is used.\n         - `bitrate`: Target encode bit rate in bits/second (default=350kB/s)\n        '''\n        # Create GStreamer pipeline\n        self.pipeline = Gst.Pipeline()\n\n        # Create bus to get events from GStreamer pipeline\n        self.bus = self.pipeline.get_bus()\n        self.bus.add_signal_watch()\n        self.bus.connect('message::error', self.on_error)\n\n        # This is needed to make the video output in our DrawingArea:\n        self.bus.enable_sync_message_emission()\n\n        # Create GStreamer elements\n        if device_config is None:\n            self.src = Gst.ElementFactory.make('autovideosrc', 'source')\n        else:\n            self.src = get_video_source()\n            device_key = get_video_device_key()\n            self.src.set_property(device_key, device_config['device'])\n        if sink is None:\n            self.sink = Gst.ElementFactory.make('autovideosink', 'sink')\n        else:\n            self.sink = sink\n        self.sink.set_property('sync', False)\n\n        self.filter_ = Gst.ElementFactory.make('capsfilter', 'filter')\n        tee = Gst.ElementFactory.make('tee', None)\n\n        sink_queue = Gst.ElementFactory.make('queue', None)\n        capture_queue = Gst.ElementFactory.make('queue', None)\n        encoder = Gst.ElementFactory.make('avenc_mpeg4', None)\n        encoder.set_property('bitrate', bitrate)\n        encoder.set_property('bitrate-tolerance', 500 << 10)\n        if path(output_path).ext.lower() == '.mp4':\n            muxer = Gst.ElementFactory.make('mp4mux', None)\n        elif path(output_path).ext.lower() == '.avi':\n            muxer = Gst.ElementFactory.make('avimux', None)\n        else:\n            raise ValueError('Unsupported output file type: %s' %\n                             path(output_path).ext)\n        filesink = Gst.ElementFactory.make('filesink', None)\n        filesink.set_property('location', output_path)\n\n        videorate = Gst.ElementFactory.make('videorate', None)\n        filter1 = Gst.ElementFactory.make('capsfilter', None)\n        filter1.set_property('caps',\n                             Gst.Caps('video/x-raw,framerate={framerate_numerator}/{framerate_denominator}'\n                                      .format(**device_config)))\n\n        caps = Gst.Caps(get_caps_str(device_config))\n        self.filter_.set_property('caps', caps)\n\n        src_elements = (self.src, self.filter_, videorate, filter1, tee)\n        sink_elements = (sink_queue, self.sink)\n        capture_elements = (capture_queue, encoder, muxer, filesink)\n\n        # Add elements to the pipeline\n        for d in src_elements + sink_elements + capture_elements:\n            self.pipeline.add(d)\n\n        for elements in (src_elements, sink_elements, capture_elements):\n            for i, j in zip(elements[:-1], elements[1:]):\n                i.link(j)\n\n        tee.link(sink_elements[0])\n        tee.link(capture_elements[0])\n\n\n        self.output_path = output_path\n        self.tee = tee\n        self.muxer = muxer\n        self.src_elements = src_elements\n        self.sink_elements = sink_elements\n        self.capture_elements = capture_elements\n\n        self.pipeline.set_state(Gst.State.PLAYING)\n        self._alive = True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef gant(ctx, conf, basedir, basetag, maintag, prefix, verbose):\n    ctx.obj.initConf(basetag, maintag, basedir, prefix, verbose)\n    ctx.obj.gd.setConf(ctx.obj.conf)", "response": "GAnt is a GlusterFS helper for creating GlusterFS development and testing environments using Docker\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef paint(self):\n        # nice blue color\n        self.image = Image.new(mode='RGB', size=(self.width, self.height),\n                               color=(47, 98, 135))\n        self.paint_pattern()\n        self.image.save(fp=self.filename)", "response": "Paints the wallpaper as the specified filename."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cdn_get_conf(self, cname, environment):\n        response = self.client.service.cdn_get_conf(cname, environment)\n        cdn_config = CotendoCDN(response)\n        return cdn_config", "response": "Get the existing origin configuration and token from the CDN"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cdn_set_conf(self, cname, originConf, environment, token):\n        return self.client.service.cdn_set_conf(\n            cname, originConf, environment, token)", "response": "This method allows the user to update an existing CDN configuration file in the CDN."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dns_get_conf(self, domainName, environment):\n        response = self.client.service.dns_get_conf(domainName, environment)\n        dns_config = CotendoDNS(response)\n        return dns_config", "response": "Get the existing domain configuration and token from the ADNS\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nimport a dns configuration file into the helper", "response": "def ImportDNS(self, config, token=None):\n        \"\"\"\n        Import a dns configuration file into the helper\n\n        Note: This requires that you have the latest token.\n        To get the latest token, run the GrabDNS command first.\n        \"\"\"\n        if not token:\n            raise Exception(\"You must have the dns token set first.\")\n        self.dns = CotendoDNS([token, config])\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_connection(self, service_name):\n        service = self.services.get(service_name, {})\n        connection_class = service.get('connection', None)\n\n        if not connection_class:\n            msg = \"Connection for '{0}' is not present in the cache.\"\n            raise NotCached(msg.format(\n                service_name\n            ))\n\n        return connection_class", "response": "Retrieves a connection class from the cache if available."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets a connection class within the cache.", "response": "def set_connection(self, service_name, to_cache):\n        \"\"\"\n        Sets a connection class within the cache.\n\n        :param service_name: The service a given ``Connection`` talks to. Ex.\n            ``sqs``, ``sns``, ``dynamodb``, etc.\n        :type service_name: string\n\n        :param to_cache: The class to be cached for the service.\n        :type to_cache: class\n        \"\"\"\n        self.services.setdefault(service_name, {})\n        self.services[service_name]['connection'] = to_cache"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_resource(self, service_name, resource_name, base_class=None):\n        classpath = self.build_classpath(base_class)\n        service = self.services.get(service_name, {})\n        resources = service.get('resources', {})\n        resource_options = resources.get(resource_name, {})\n        resource_class = resource_options.get(classpath, None)\n\n        if not resource_class:\n            msg = \"Resource '{0}' for {1} is not present in the cache.\"\n            raise NotCached(msg.format(\n                resource_name,\n                service_name\n            ))\n\n        return resource_class", "response": "Retrieves a resource class from the cache if available."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_resource(self, service_name, resource_name, to_cache):\n        self.services.setdefault(service_name, {})\n        self.services[service_name].setdefault('resources', {})\n        self.services[service_name]['resources'].setdefault(resource_name, {})\n        options = self.services[service_name]['resources'][resource_name]\n        classpath = self.build_classpath(to_cache.__bases__[0])\n\n        if classpath == 'kotocore.resources.Resource':\n            classpath = 'default'\n\n        options[classpath] = to_cache", "response": "Sets the class that is used to cache the given resource."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting a resource class for a given service.", "response": "def del_resource(self, service_name, resource_name, base_class=None):\n        \"\"\"\n        Deletes a resource class for a given service.\n\n        Fails silently if no connection is found in the cache.\n\n        :param service_name: The service a given ``Resource`` talks to. Ex.\n            ``sqs``, ``sns``, ``dynamodb``, etc.\n        :type service_name: string\n\n        :param base_class: (Optional) The base class of the object. Prevents\n            \"magically\" loading the wrong class (one with a different base).\n            Default is ``default``.\n        :type base_class: class\n        \"\"\"\n         # Unlike ``get_resource``, this should be fire & forget.\n        # We don't really care, as long as it's not in the cache any longer.\n        try:\n            classpath = self.build_classpath(base_class)\n            opts = self.services[service_name]['resources'][resource_name]\n            del opts[classpath]\n        except KeyError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve a class from the cache if available.", "response": "def get_collection(self, service_name, collection_name, base_class=None):\n        \"\"\"\n        Retrieves a collection class from the cache, if available.\n\n        :param service_name: The service a given ``Collection`` talks to. Ex.\n            ``sqs``, ``sns``, ``dynamodb``, etc.\n        :type service_name: string\n\n        :param collection_name: The name of the ``Collection``. Ex.\n            ``QueueCollection``, ``NotificationCollection``,\n            ``TableCollection``, etc.\n        :type collection_name: string\n\n        :param base_class: (Optional) The base class of the object. Prevents\n            \"magically\" loading the wrong class (one with a different base).\n            Default is ``default``.\n        :type base_class: class\n\n        :returns: A <kotocore.collections.Collection> subclass\n        \"\"\"\n        classpath = self.build_classpath(base_class)\n        service = self.services.get(service_name, {})\n        collections = service.get('collections', {})\n        collection_options = collections.get(collection_name, {})\n        collection_class = collection_options.get(classpath, None)\n\n        if not collection_class:\n            msg = \"Collection '{0}' for {1} is not present in the cache.\"\n            raise NotCached(msg.format(\n                collection_name,\n                service_name\n            ))\n\n        return collection_class"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_collection(self, service_name, collection_name, to_cache):\n        self.services.setdefault(service_name, {})\n        self.services[service_name].setdefault('collections', {})\n        self.services[service_name]['collections'].setdefault(collection_name, {})\n        options = self.services[service_name]['collections'][collection_name]\n        classpath = self.build_classpath(to_cache.__bases__[0])\n\n        if classpath == 'kotocore.collections.Collection':\n            classpath = 'default'\n\n        options[classpath] = to_cache", "response": "Sets a collection class within the cache."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef del_collection(self, service_name, collection_name, base_class=None):\n         # Unlike ``get_collection``, this should be fire & forget.\n        # We don't really care, as long as it's not in the cache any longer.\n        try:\n            classpath = self.build_classpath(base_class)\n            opts = self.services[service_name]['collections'][collection_name]\n            del opts[classpath]\n        except KeyError:\n            pass", "response": "Deletes a collection for a given service."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef chunk(seq, n):\n    # http://stackoverflow.com/a/312464/190597 (Ned Batchelder)\n    \"\"\" Yield successive n-sized chunks from seq.\"\"\"\n    for i in range(0, len(seq), n):\n        yield seq[i:i + n]", "response": "Yield successive n - sized chunks from seq."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _convert_coordinates_to_decimal_degrees(\n            self):\n        \"\"\"\n        *convert coordinates to decimal degrees*\n        \"\"\"\n        self.log.info(\n            'starting the ``_convert_coordinates_to_decimal_degrees`` method')\n\n        converter = unit_conversion(\n            log=self.log\n        )\n\n        # CONVERT ALL COORDINATES TO DECIMAL DEGREES\n        if len(self.listOfCoordinates) and isinstance(self.listOfCoordinates[0], str):\n            sources = []\n            sources[:] = [s.split(\" \") for s in self.listOfCoordinates]\n\n        else:\n            sources = self.listOfCoordinates\n        self.listOfCoordinates = []\n\n        # TEST IF CONVERSION IS REQUIRED\n        try:\n            ra = float(sources[0][0])\n            convert = False\n        except:\n            convert = True\n\n        if convert == True:\n            raDegs = []\n            raDegs[:] = [converter.ra_sexegesimal_to_decimal(\n                ra=s[0]) for s in sources]\n            decDegs = []\n            decDegs[:] = [converter.dec_sexegesimal_to_decimal(\n                dec=s[1]) for s in sources]\n            self.listOfCoordinates = []\n            self.listOfCoordinates[:] = [[raDeg, decDeg]\n                                         for raDeg, decDeg in zip(raDegs, decDegs)]\n\n        else:\n            self.listOfCoordinates = []\n            self.listOfCoordinates[:] = [[float(s[0]), float(s[1])]\n                                         for s in sources]\n\n        self.log.info(\n            'completed the ``_convert_coordinates_to_decimal_degrees`` method')\n        return None", "response": "convert coordinates to decimal degrees"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_the_ned_position_results(\n            self,\n            ra,\n            dec,\n            nedResults):\n        \"\"\"\n        *parse the ned results*\n\n        **Key Arguments:**\n            - ``ra`` -- the search ra\n            - ``dec`` -- the search dec\n\n        **Return:**\n            - ``results`` -- list of result dictionaries\n        \"\"\"\n        self.log.info('starting the ``_parse_the_ned_results`` method')\n\n        results = []\n        resultLen = 0\n        if nedResults:\n            # OPEN THE RESULT FILE FROM NED\n            pathToReadFile = nedResults\n            try:\n                self.log.debug(\"attempting to open the file %s\" %\n                               (pathToReadFile,))\n                readFile = codecs.open(\n                    pathToReadFile, encoding='utf-8', mode='rb')\n                thisData = readFile.read()\n                readFile.close()\n            except IOError, e:\n                message = 'could not open the file %s' % (pathToReadFile,)\n                self.log.critical(message)\n                raise IOError(message)\n            readFile.close()\n\n            # CHECK FOR ERRORS\n            if \"Results from query to  NASA/IPAC Extragalactic Database\" not in thisData:\n                print \"something went wrong with the NED query\"\n                self.log.error(\n                    \"something went wrong with the NED query\" % locals())\n                sys.exit(0)\n\n            # SEARCH FROM MATCHES IN RESULTS FILE\n            matchObject = re.search(\n                r\"No\\.\\|Object Name.*?\\n(.*)\", thisData, re.S)\n            if matchObject:\n                theseLines = string.split(matchObject.group(), '\\n')\n                resultLen = len(theseLines)\n                csvReader = csv.DictReader(\n                    theseLines, dialect='excel', delimiter='|', quotechar='\"')\n                for row in csvReader:\n                    thisEntry = {\"searchRa\": ra, \"searchDec\": dec,\n                                 \"matchName\": row[\"Object Name\"].strip()}\n                    results.append(thisEntry)\n                    if self.nearestOnly:\n                        break\n\n        self.log.info('completed the ``_parse_the_ned_results`` method')\n        return results, resultLen", "response": "Parse the NED position results file and return a list of dictionaries."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse_the_ned_object_results(\n            self):\n        \"\"\"\n        *parse the ned results*\n\n        **Key Arguments:**\n            # -\n\n        **Return:**\n            - None\n\n        .. todo::\n\n            - @review: when complete, clean _parse_the_ned_results method\n            - @review: when complete add logging\n        \"\"\"\n        self.log.info('starting the ``_parse_the_ned_results`` method')\n\n        results = []\n        headers = [\"objectName\", \"objectType\", \"raDeg\", \"decDeg\",\n                   \"redshift\", \"redshiftFlag\"]\n        if self.nedResults:\n            pathToReadFile = self.nedResults\n            try:\n                self.log.debug(\"attempting to open the file %s\" %\n                               (pathToReadFile,))\n                readFile = codecs.open(\n                    pathToReadFile, encoding='utf-8', mode='rb')\n                thisData = readFile.read()\n                readFile.close()\n            except IOError, e:\n                message = 'could not open the file %s' % (pathToReadFile,)\n                self.log.critical(message)\n                raise IOError(message)\n            readFile.close()\n\n            matchObject = re.search(\n                r\"No\\.\\|Object Name.*?\\n(.*)\", thisData, re.S)\n            if matchObject:\n                # Print the header for stdout\n                thisHeader = \"| \"\n                for head in headers:\n                    thisHeader += str(head).ljust(self.resultSpacing,\n                                                  ' ') + \" | \"\n                if not self.quiet:\n                    print thisHeader\n                theseLines = string.split(matchObject.group(), '\\n')\n                csvReader = csv.DictReader(\n                    theseLines, dialect='excel', delimiter='|', quotechar='\"')\n                for row in csvReader:\n                    thisDict = {}\n                    thisRow = \"| \"\n                    thisDict[\"raDeg\"] = row[\"RA(deg)\"].strip()\n                    thisDict[\"decDeg\"] = row[\"DEC(deg)\"].strip()\n                    thisDict[\"redshift\"] = row[\"Redshift\"].strip()\n                    thisDict[\"redshiftFlag\"] = row[\"Redshift Flag\"].strip()\n                    thisDict[\"objectName\"] = row[\"Object Name\"].strip()\n                    thisDict[\"objectType\"] = row[\"Type\"].strip()\n\n                    results.append(thisDict)\n                    for head in headers:\n                        thisRow += str(thisDict[head]\n                                       ).ljust(self.resultSpacing, ' ') + \" | \"\n                    if not self.quiet:\n                        print thisRow\n\n            else:\n                for head in headers:\n                    thisRow += str(\"\").ljust(self.resultSpacing, ' ') + \" | \"\n                if not self.quiet:\n                    print thisRow\n        else:\n            # Print the header for stdout\n            thisHeader = \"| \"\n            for head in headers:\n                thisHeader += str(head).ljust(self.resultSpacing, ' ') + \" | \"\n            if not self.quiet:\n                print thisHeader\n            thisRow = \"| \"\n            for head in headers:\n                thisRow += str(\"\").ljust(self.resultSpacing, ' ') + \" | \"\n            if not self.quiet:\n                print thisRow\n\n        self.log.info('completed the ``_parse_the_ned_results`` method')\n        return results", "response": "Parse the ned object names and return a list of dictionaries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert html to csv", "response": "def _convert_html_to_csv(\n            self):\n        \"\"\"\n        *contert html to csv*\n\n        **Key Arguments:**\n            # -\n\n        **Return:**\n            - None\n\n        .. todo::\n\n            - @review: when complete, clean _convert_html_to_csv method\n            - @review: when complete add logging\n        \"\"\"\n        self.log.info('starting the ``_convert_html_to_csv`` method')\n\n        import codecs\n        allData = \"\"\n        regex1 = re.compile(\n            r'.*<PRE><strong>   (.*?)</strong>(.*?)</PRE></TABLE>.*', re.I | re.S)\n        regex2 = re.compile(r'\\|(\\w)\\|', re.I | re.S)\n        for thisFile in self.nedResults:\n            pathToReadFile = thisFile\n            try:\n                self.log.debug(\"attempting to open the file %s\" %\n                               (pathToReadFile,))\n                readFile = codecs.open(\n                    pathToReadFile, encoding='utf-8', mode='r')\n                thisData = readFile.read()\n                readFile.close()\n            except IOError, e:\n                message = 'could not open the file %s' % (pathToReadFile,)\n                self.log.critical(message)\n                raise IOError(message)\n            except:\n                if pathToReadFile == None:\n                    message = 'we have no file to open'\n                    self.log.error(message)\n                    continue\n            readFile.close()\n\n            self.log.debug(\"regex 1 - sub\")\n            thisData = regex1.sub(\"\\g<1>\\g<2>\", thisData)\n            self.log.debug(\"regex 2 - sub\")\n            thisData = regex2.sub(\"abs(\\g<1>)\", thisData)\n            self.log.debug(\"replace text\")\n            thisData = thisData.replace(\"|b|\", \"abs(b)\")\n\n            writeFile = codecs.open(pathToReadFile, encoding='utf-8', mode='w')\n            writeFile.write(thisData)\n            writeFile.close()\n\n        self.log.info('completed the ``_convert_html_to_csv`` method')\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_the_ned_list_results(\n            self):\n        \"\"\"\n        *parse the ned results*\n\n        **Key Arguments:**\n            # -\n\n        **Return:**\n            - None\n\n        .. todo::\n\n            - @review: when complete, clean _parse_the_ned_results method\n            - @review: when complete add logging\n        \"\"\"\n        self.log.info('starting the ``_parse_the_ned_list_results`` method')\n\n        results = []\n\n        # CHOOSE VALUES TO RETURN\n        allHeaders = [\"searchIndex\", \"searchRa\", \"searchDec\", \"row_number\", \"input_note\", \"input_name\", \"ned_notes\", \"ned_name\", \"ra\", \"dec\", \"eb-v\", \"object_type\", \"redshift\", \"redshift_err\", \"redshift_quality\", \"magnitude_filter\",\n                      \"major_diameter_arcmin\", \"minor_diameter_arcmin\", \"morphology\", \"hierarchy\", \"galaxy_morphology\", \"radio_morphology\", \"activity_type\", \"distance_indicator\", \"distance_mod\", \"distance\"]\n        if self.verbose == True:\n            headers = [\"searchIndex\", \"searchRa\", \"searchDec\", \"row_number\", \"input_note\", \"input_name\", \"ned_notes\", \"ned_name\", \"ra\", \"dec\", \"eb-v\", \"object_type\", \"redshift\", \"redshift_err\", \"redshift_quality\", \"magnitude_filter\",\n                       \"major_diameter_arcmin\", \"minor_diameter_arcmin\", \"morphology\", \"hierarchy\", \"galaxy_morphology\", \"radio_morphology\", \"activity_type\", \"distance_indicator\", \"distance_mod\", \"distance\"]\n        else:\n            headers = [\n                \"searchIndex\", \"searchRa\", \"searchDec\", \"ned_name\", \"ra\", \"dec\", \"object_type\", \"redshift\"]\n\n        if self.theseBatchParams == False:\n            allHeaders = allHeaders[3:]\n            headers = headers[3:]\n\n        for thisFile in self.nedResults:\n            if thisFile:\n                pathToReadFile = thisFile\n                # FIND THE BATCH INDEX NUMBER\n                thisIndex = int(thisFile.split(\"/\")[-1].split(\"_\")[0])\n                try:\n                    self.log.debug(\"attempting to open the file %s\" %\n                                   (pathToReadFile,))\n                    readFile = codecs.open(\n                        pathToReadFile, encoding='utf-8', mode='rb')\n                    thisData = readFile.read()\n                    readFile.close()\n                except IOError, e:\n                    message = 'could not open the file %s' % (pathToReadFile,)\n                    self.log.critical(message)\n                    raise IOError(message)\n                readFile.close()\n\n                # GRAB THE ROWS OF DATA\n                matchObject = re.search(\n                    r\"\\n1\\s*?\\|\\s*?.*\", thisData, re.S)\n                thisRow = \"\"\n                if matchObject:\n                    thisHeader = \"\"\n                    for head in allHeaders:\n                        thisHeader += str(head).ljust(self.resultSpacing,\n                                                      ' ') + \" | \"\n                    theseLines = string.split(matchObject.group(), '\\n')[1:]\n\n                    if self.theseBatchParams:\n                        newLines = []\n                        for t, b in zip(theseLines, self.theseBatchParams[thisIndex]):\n                            t = \"%s | %s | %s | %s \" % (\n                                b[\"searchIndex\"], b[\"searchRa\"], b[\"searchDec\"], t)\n                            newLines.append(t)\n                        theseLines = newLines\n\n                    theseLines = [thisHeader] + theseLines\n                    csvReader = csv.DictReader(\n                        theseLines, dialect='excel', delimiter='|', quotechar='\"')\n                    for row in csvReader:\n                        thisDict = {}\n                        row = dict(row)\n                        if not row.keys():\n                            continue\n                        if None in row.keys():\n                            continue\n                        if \"ned_name\" not in (\"\").join(row.keys()).lower():\n                            continue\n                        for k, v in row.iteritems():\n                            try:\n                                # self.log.debug(\"attempting to strip ned key\")\n                                k = k.strip()\n                            except Exception, e:\n                                self.log.error(\n                                    'cound not strip ned key (%(k)s, %(v)s)' % locals())\n                                self.log.error(\n                                    \"could not strip ned key - failed with this error: %s \" % (str(e),))\n                                break\n                            if (k == \"ra\" or k == \"dec\"):\n                                v = v.replace(\"h\", \":\").replace(\n                                    \"m\", \":\").replace(\"d\", \":\").replace(\"s\", \"\")\n                            if isinstance(v, str):\n                                v = v.strip()\n                            thisDict[k] = v\n                        results.append(thisDict)\n\n                os.remove(thisFile)\n\n        self.log.info('completed the ``_parse_the_ned_list_results`` method')\n        return results, headers", "response": "Parse the ned list results and return a list of the ned items."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd contextual information to the log record.", "response": "def filter(self, record):\n        \"\"\"Add contextual information to the log record\n\n        :param record: the log record\n        :type record: :class:`logging.LogRecord`\n        :returns: True, if log should get sent\n        :rtype: :class:`bool`\n        :raises: None\n        \"\"\"\n        record.sitename = self.sitename\n        record.platform = self.platform\n        record.jobid = self.jobid\n        record.submitter = self.logname\n        record.jobname = self.jobname\n        record.queue = self.queue\n        record.fqdn = self.fqdn\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef auth_user_get_url(self):\n\t\t'Build authorization URL for User Agent.'\n\t\tif not self.client_id: raise AuthenticationError('No client_id specified')\n\t\treturn '{}?{}'.format(self.auth_url_user, urllib.urlencode(dict(\n\t\t\tclient_id=self.client_id, state=self.auth_state_check,\n\t\t\tresponse_type='code', redirect_uri=self.auth_redirect_uri )))", "response": "Build authorization URL for User Agent."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef listdir(self, folder_id='0', offset=None, limit=None, fields=None):\n\t\t'Get Box object, representing list of objects in a folder.'\n\t\tif fields is not None\\\n\t\t\tand not isinstance(fields, types.StringTypes): fields = ','.join(fields)\n\t\treturn self(\n\t\t\tjoin('folders', folder_id, 'items'),\n\t\t\tdict(offset=offset, limit=limit, fields=fields) )", "response": "Get Box object representing list of objects in a folder."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndownloading and return an object or a specified byte_range from it.", "response": "def get(self, file_id, byte_range=None, version=None):\n\t\t'''Download and return an file (object) or a specified byte_range from it.\n\t\t\tVersion keyword is API-specific, see \"etag\" file info key:\n\t\t\t\thttp://developers.box.com/docs/#files-file-object-2\n\t\t\tSee HTTP Range header (rfc2616) for possible byte_range formats,\n\t\t\t\tsome examples: \"0-499\" - byte offsets 0-499 (inclusive), \"-500\" - final 500 bytes.'''\n\t\tkwz = dict()\n\t\tif byte_range: kwz['headers'] = dict(Range='bytes={}'.format(byte_range))\n\t\treturn self(join('files', bytes(file_id), 'content'), dict(version=version), raw=True, **kwz)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef put(self, path_or_tuple, folder_id='0', file_id=None, file_etag=None):\n\t\t'''Upload a file, returning error if a file with the same \"name\" attribute exists,\n\t\t\t\tunless valid file_id (and optionally file_etag,\n\t\t\t\tto avoid race conditions, raises error 412) is provided.\n\t\t\tfolder_id is the id of a folder to put file into,\n\t\t\t\tbut only used if file_id keyword is not passed.'''\n\t\tname, src = (basename(path_or_tuple), open(path_or_tuple))\\\n\t\t\tif isinstance(path_or_tuple, types.StringTypes)\\\n\t\t\telse (path_or_tuple[0], path_or_tuple[1])\n\t\tfolder_id = dict(parent_id=folder_id) if file_id is None else dict()\n\t\treturn self(\n\t\t\tjoin('files', 'content') if file_id is None else join('files', bytes(file_id), 'content'),\n\t\t\tmethod='post', upload=True,\n\t\t\theaders={'If-Match': file_etag} if file_etag else dict(),\n\t\t\tfiles=dict(filename=(name, src), **folder_id) )", "response": "Upload a file into a folder."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mkdir(self, name=None, folder_id='0'):\n\t\t'''Create a folder with a specified \"name\" attribute.\n\t\t\tfolder_id allows to specify a parent folder.'''\n\t\treturn self( 'folders', method='post', encode='json',\n\t\t\tdata=dict(name=name, parent=dict(id=folder_id)) )", "response": "Create a folder with a specified name attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_file(self, file_id, file_etag=None):\n\t\t'''Delete specified file.\n\t\t\tPass file_etag to avoid race conditions (raises error 412).'''\n\t\treturn self( join('files', bytes(file_id)), method='delete',\n\t\t\theaders={'If-Match': file_etag} if file_etag else dict() )", "response": "Delete specified file.\n\t\t\tPass file_etag to avoid race conditions (raises error 412)."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_folder(self, folder_id, folder_etag=None, recursive=None):\n\t\t'''Delete specified folder.\n\t\t\tPass folder_etag to avoid race conditions (raises error 412).\n\t\t\trecursive keyword does just what it says on the tin.'''\n\t\treturn self( join('folders', folder_id),\n\t\t\tdict(recursive=recursive), method='delete',\n\t\t\theaders={'If-Match': folder_etag} if folder_etag else dict() )", "response": "Delete specified folder.\n\t\t\tPass folder_etag to avoid race conditions (raises error 412).\n\t\t\trecursive keyword does just what it says on the tin."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrefreshing or acquire access_token.", "response": "def auth_get_token(self, check_state=True):\n\t\t'Refresh or acquire access_token.'\n\t\tres = self.auth_access_data_raw = yield self._auth_token_request()\n\t\tdefer.returnValue(self._auth_token_process(res, check_state=check_state))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nresolving a path to a root object.", "response": "def resolve_path( self, path,\n\t\t\troot_id='0', objects=False ):\n\t\t'''Return id (or metadata) of an object, specified by chain\n\t\t\t\t(iterable or fs-style path string) of \"name\" attributes of it's ancestors,\n\t\t\t\tor raises DoesNotExists error.\n\t\t\tRequires a lot of calls to resolve each name in path, so use with care.\n\t\t\troot_id parameter allows to specify path\n\t\t\t\t relative to some folder_id (default: 0).'''\n\t\tif path:\n\t\t\tif isinstance(path, types.StringTypes):\n\t\t\t\tpath = filter(None, path.split(os.sep))\n\t\t\tif path:\n\t\t\t\ttry:\n\t\t\t\t\tfor i, name in enumerate(path):\n\t\t\t\t\t\troot_id = dict(it.imap(\n\t\t\t\t\t\t\top.itemgetter('name', 'id'), (yield self.listdir(root_id)) ))[name]\n\t\t\t\texcept (KeyError, ProtocolError) as err:\n\t\t\t\t\tif isinstance(err, ProtocolError) and err.code != 404: raise\n\t\t\t\t\traise DoesNotExists(root_id, path[i:])\n\t\tdefer.returnValue(root_id if not objects else (yield self.info(root_id)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of objects in the specified folder_id.", "response": "def listdir( self, folder_id='0',\n\t\t\ttype_filter=None, offset=None, limit=None, **listdir_kwz ):\n\t\t'''Return a list of objects in the specified folder_id.\n\t\t\tlimit is passed to the API, so might be used as optimization.\n\t\t\t\tNone means \"fetch all items, with several requests, if necessary\".\n\t\t\ttype_filter can be set to type (str) or sequence\n\t\t\t\tof object types to return, post-api-call processing.'''\n\t\tres = yield super(txBox, self).listdir(\n\t\t\tfolder_id=folder_id, offset=offset,\n\t\t\tlimit=limit if limit is not None else 900, **listdir_kwz )\n\t\tlst = res['entries']\n\t\tif limit is None: # treat it as \"no limit\", using several requests to fetch all items\n\t\t\twhile res['total_count'] > res['offset'] + res['limit']:\n\t\t\t\toffset = res['offset'] + res['limit']\n\t\t\t\tres = yield super(txBox, self).listdir(\n\t\t\t\t\tfolder_id=folder_id, offset=offset, limit=900, **listdir_kwz )\n\t\t\t\tlst.extend(res['entries'])\n\t\tif type_filter:\n\t\t\tif isinstance(type_filter, types.StringTypes): type_filter = {type_filter}\n\t\t\tlst = list(obj for obj in lst if obj['type'] in type_filter)\n\t\tdefer.returnValue(lst)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_quota(self):\n\t\t'Return tuple of (bytes_available, bytes_quota).'\n\t\tdu, ds = op.itemgetter('space_used', 'space_amount')\\\n\t\t\t((yield super(txBox, self).info_user()))\n\t\tdefer.returnValue((ds - du, ds))", "response": "Return tuple of ( bytes_available bytes_quota).'"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretries a function or method until it got True. - ``delay`` sets the initial delay in seconds - ``back_off`` sets the factor by which - ``raise_msg`` if not '', it'll raise an Exception", "response": "def retry(tries, delay=0, back_off=1, raise_msg=''):\n    \"\"\"Retries a function or method until it got True.\n\n    - ``delay`` sets the initial delay in seconds\n    - ``back_off`` sets the factor by which\n    - ``raise_msg`` if not '', it'll raise an Exception\n    \"\"\"\n\n    if back_off < 1:\n        raise ValueError('back_off must be 1 or greater')\n\n    tries = math.floor(tries)\n    if tries < 0:\n        raise ValueError('tries must be 0 or greater')\n\n    if delay < 0:\n        raise ValueError('delay must be 0 or greater')\n\n    def deco_retry(f):\n        def f_retry(*args, **kwargs):\n            max_tries, max_delay = tries, delay  # make mutable\n\n            while max_tries > 0:\n                rv = f(*args, **kwargs)  # first attempt\n                if rv:  # Done on success\n                    return rv\n\n                max_tries -= 1  # consume an attempt\n                time.sleep(max_delay)  # wait...\n                max_delay *= back_off  # make future wait longer\n            else:\n                if raise_msg:\n                    raise Exception(raise_msg)\n                return\n\n        return f_retry  # true decorator -> decorated function\n\n    return deco_retry"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef later(periods=10.0, precision=2.0, offset=0.0, check_interval=0.1, only_run_once=True):\n\n    def dec_fn(fn):\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            try:\n                while True:\n                    # \u68c0\u6d4b\u65f6\u95f4\n                    _st = time.time()\n\n                    # \u5982\u679c precision \u4e0d\u4e3a 0, \u5219\u89e6\u53d1\u68c0\u67e5\u5bb9\u5fcd\u5468\u671f\n                    _ready = not precision\n                    if not _ready:\n                        # \u5f53\u524d\u65f6\u95f4 - \u504f\u79fb \u5bf9\u5468\u671f\u53d6\u4f59 \u6ee1\u8db3\u5c0f\u4e8e\u7cbe\u5ea6, \u5219\u8fd0\u884c\n                        _ready = (_st - offset) % periods <= precision\n\n                    if _ready:\n                        # \u6761\u4ef6\u7b26\u5408, \u5219\u8fd0\u884c\u5904\u7406\u51fd\u6570\n                        fn(*args, **kwargs)\n                        # \u8ba1\u7b97\u51fd\u6570\u8fd0\u884c\u65f6\u95f4\n                        _es = time.time() - _st\n                        # \u5982\u679c\u8981\u4fdd\u8bc1\u53ea\u8fd0\u884c\u4e00\u6b21, \u4e14\u51fd\u6570\u5904\u7406\u65f6\u95f4 \u5c0f\u4e8e \u7cbe\u5ea6\u7f13\u51b2\u65f6\u95f4,\n                        # \u4e3a\u4e86\u4fdd\u8bc1\u53ea\u8fd0\u884c\u4e00\u6b21, \u9700\u8981\u989d\u5916\u7b49\u5f85 (\u7cbe\u5ea6 - \u5904\u7406\u65f6\u95f4)\n                        # \u5982\u679c\u5468\u671f\u5c0f\u4e8e\u7cbe\u5ea6, \u5219\u53d6\u4e24\u8005\u6700\u5c0f\u503c\n                        _extra_max_wait = min(periods, precision)\n                        if only_run_once and _es < _extra_max_wait:\n                            time.sleep(_extra_max_wait - _es)\n                    time.sleep(check_interval)\n            except KeyboardInterrupt as ____:\n                raise SystemExit(1)\n                # except Exception as err:\n                #     print('error of later: {}'.format(err))\n\n        return wrapper\n\n    return dec_fn", "response": "A function that runs the next time period of the current language."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _async_raise(tid, exctype):\n    tid = ctypes.c_long(tid)\n    if not inspect.isclass(exctype):\n        exctype = type(exctype)\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))\n    if res == 0:\n        raise ValueError(\"invalid thread id\")\n    elif res != 1:\n        # \"\"\"if it returns a number greater than one, you're in trouble,\n        # and you should call it again with exc=NULL to revert the effect\"\"\"\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None)\n        raise SystemError(\"PyThreadState_SetAsyncExc failed\")\n    print('force close: {} {}'.format(tid, datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')))", "response": "Raises the exception in the thread with the given id."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef block_until_expired(timeout):\n    if not callable(timeout):\n        def dec(fn):\n            @wraps(fn)\n            def wrapper_(*args, **kwargs):\n                class TimeLimited(threading.Thread):\n                    def __init__(self, _error=None, ):\n                        threading.Thread.__init__(self)\n                        self.error_ = _error\n                        self.result = None\n                        self.stopped = False\n\n                    def run(self):\n                        self.result = fn(*args, **kwargs)\n\n                try:\n                    float(timeout)\n                except ValueError as err:\n                    print('err: ', err)\n                    return None, None\n\n                t = TimeLimited()\n                t.start()\n\n                if timeout > 0:\n                    t.join(timeout)\n\n                    if t.isAlive():\n                        print('[timeout running out for {}]'.format(fn.__name__))\n                        _async_raise(t.ident, SystemExit)\n                        return None, None\n\n                    return t.error_, t.result\n\n            return wrapper_\n\n        return dec", "response": "A decorator that blocks until the specified timeout is reached."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef catch(do, my_exception=TypeError, hints='', do_raise=None, prt_tb=True):\n    if not hasattr(do, '__call__'):\n        def dec(fn):\n            @wraps(fn)\n            def wrapper_(*args, **kwargs):\n                if not do:\n                    return fn(*args, **kwargs)\n\n                try:\n                    return fn(*args, **kwargs)\n                except my_exception as e:\n                    log.error(\"{}({})>{}: has err({})\".format(\n                        fn.__code__.co_filename.split('/')[-1],\n                        fn.__code__.co_firstlineno,\n                        fn.__name__, e))\n                    if prt_tb:\n                        traceback.print_exc()\n                    if hints:\n                        print(hints)\n                    if do_raise:\n                        raise do_raise(\n                            hints or \"{}({}):{}\".format(\n                                fn.__code__.co_filename.split('/')[-1],\n                                fn.__code__.co_firstlineno,\n                                fn.__name__)\n                        )\n\n            return wrapper_\n\n        return dec\n\n    @wraps(do)\n    def wrapper(*args, **kwargs):\n        try:\n            return do(*args, **kwargs)\n        except my_exception as e:\n            log.error(\"{}({})>{}: has err({})\".format(\n                do.__code__.co_filename.split('/')[-1],\n                do.__code__.co_firstlineno,\n                do.__name__, e\n            ))\n            if prt_tb:\n                traceback.print_exc()\n            if hints:\n                print(hints)\n            if do_raise:\n                raise do_raise(\n                    hints or \"{}({}):{}\".format(\n                        do.__code__.co_filename.split('/')[-1],\n                        do.__code__.co_firstlineno,\n                        do.__name__)\n                )\n\n    return wrapper", "response": "\u9632\u6b62\u7a0b\u5e8f\u51fa\u73b0 exception\u540e\u5f02\u5e38\u9000\u51fa,\n    \u4f46\u662f\u8fd9\u91cc\u7684\u5f02\u5e38\u6355\u83b7\u673a\u5236\u4ec5\u4ec5\u662f\u4e3a\u4e86\u9632\u6b62\u7a0b\u5e8f\u9000\u51fa, \u65e0\u6cd5\u505a\u76f8\u5e94\u5904\u7406\n    \u53ef\u4ee5\u652f\u6301\u6709\u53c2\u6570\u6216\u8005\u65e0\u53c2\u6570\u6a21\u5f0f\n\n    -  ``do == True`` , \u5219\u542f\u7528\u6355\u83b7\u5f02\u5e38\n    -  \u65e0\u53c2\u6570\u4e5f\u542f\u7528 try-catch\n\n    .. code:: python\n\n            @catch\n            def fnc():\n                pass\n\n    -  \u5728\u6709\u53ef\u80fd\u51fa\u9519\u7684\u51fd\u6570\u524d\u6dfb\u52a0, \u4e0d\u8981\u5728\u6700\u5916\u5c42\u6dfb\u52a0,\n    -  \u8fd9\u4e2acatch \u4f1a\u6355\u83b7\u4ece\u8be5\u51fd\u6570\u5f00\u59cb\u7684\u6240\u6709\u5f02\u5e38, \u4f1a\u9690\u85cf\u4e0b\u4e00\u7ea7\u51fd\u6570\u8c03\u7528\u7684\u9519\u8bef.\n    -  \u4f46\u662f\u5982\u679c\u5728\u5185\u5c42\u7684\u51fd\u6570\u4e5f\u6709\u6355\u83b7\u65b9\u6cd5, \u5219\u90fd\u4f1acatch\u5230\u5f02\u5e38.\n\n    :param do:\n    :type do:\n    :param my_exception:\n    :type my_exception:\n    :param hints:\n    :type hints:\n    :return:\n    :rtype:"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_to_tree(text):\n    xml_text = cabocha.as_xml(text)\n    tree = Tree(xml_text)\n    return tree", "response": "Parse text using CaboCha then return Tree instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean(self):\n        super(AtLeastOneRequiredInlineFormSet, self).clean()\n        if any(self.errors):\n            return\n        if not any(cleaned_data and not cleaned_data.get('DELETE', False) for cleaned_data in self.cleaned_data):\n            raise forms.ValidationError('\u041f\u0440\u0438\u043a\u0440\u0435\u043f\u0438\u0442\u0435 \u043d\u0435 \u043c\u0435\u043d\u0435\u0435 \u043e\u0434\u043d\u043e\u0433\u043e \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430')", "response": "Check that at least one service has been entered."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _stage2_bootstrap():\n    from couchbase_ffi.result import (\n        Item,\n        Result,\n        ObserveInfo,\n        MultiResult,\n        ValueResult,\n        OperationResult,\n        HttpResult,\n        AsyncResult\n    )\n    from couchbase_ffi.n1ql import _N1QLParams\n\n    globals().update(locals())\n    from couchbase_ffi.bucket import Bucket\n    globals()['Bucket'] = Bucket\n\n    from couchbase import _bootstrap\n    globals()['Transcoder'] = None\n    import couchbase.transcoder\n\n    class _Transcoder(couchbase.transcoder.TranscoderPP):\n        def _do_json_encode(self, value):\n            return PyCBC.json_encode(value)\n\n        def _do_json_decode(self, value):\n            return PyCBC.json_decode(value)\n\n        def _do_pickle_encode(self, value):\n            return PyCBC.pickle_encode(value)\n\n        def _do_pickle_decode(self, value):\n            return PyCBC.pickle_decode(value)\n\n    globals()['Transcoder'] = _Transcoder\n    couchbase.transcoder.Transcoder = _Transcoder", "response": "This stage is called by stage1 to load the base object and create the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef activate_page(self, page_id):\n        if page_id == \"next\":\n            page_keys = list(self._pages.keys())\n            key_count = len(page_keys)\n            if key_count > 0:\n                idx = page_keys.index(self._active_page.page_id)\n                if idx >= key_count-1:\n                    idx = 0\n                else:\n                    idx += 1\n                self._active_page = self._pages[page_keys[idx]]\n                self._active_page._render()\n                self._page_changed(self._active_page)\n\n        elif page_id in self._pages:\n            self._active_page = self._pages[page_id]\n            self._page_changed(self._active_page)\n        else:\n            raise ValueError(\"Page with {page_id} not found in page list\".format(page_id = page_id))", "response": "r Activates a display page."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_font(self, size=8, name=\"PressStart2P.ttf\"):\n        import kervi.vision as vision\n        from PIL import ImageFont\n        vision_path = os.path.dirname(vision.__file__)\n        fontpath = os.path.join(vision_path, \"fonts\", name)\n        font = ImageFont.truetype(fontpath, size)\n        return font", "response": "Returns a font that can be used by PIL image functions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a decimal. Decimal instance to a float.", "response": "def convert_Decimal(x, encoder):\n    \"\"\"\n    Called when an instance of U{decimal.Decimal<http://\n    docs.python.org/library/decimal.html#decimal-objects>} is about to be\n    encoded to an AMF stream.\n\n    @return: If the encoder is in 'strict' mode then C{x} will be converted to\n        a float. Otherwise an L{pyamf.EncodeError} with a friendly message is\n        raised.\n    \"\"\"\n    if encoder.strict is False:\n        return float(x)\n\n    raise pyamf.EncodeError('Unable to encode decimal.Decimal instances as '\n        'there is no way to guarantee exact conversion. Use strict=False to '\n        'convert to a float.')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run():\n    data_items = [\n        [u\"mushroom\", u\"fungus\"],\n        [u\"tomato\", u\"fruit\"],\n        [u\"topaz\", u\"mineral\"],\n        [u\"iron\", u\"metal\"],\n        [u\"dr\u00f3\u017ck\u0105\", u\"utf-8 sample\"],\n        [u\"apple\", u\"fruit\"],\n        [u\"cheese\", u\"dairy\"],\n        [u\"peach\", u\"fruit\"],\n        [u\"celery\", u\"vegetable\"],\n        [u\"pear\", u\"fruit\"],\n        [u\"ruby\", u\"mineral\"],\n        [u\"titanium\", u\"metal\"],\n        [u\"cat\", u\"animal\"],\n        [u\"orange\", u\"fruit\"],\n        [u\"W\u0104\u017b\", u\"utf-8 sample\"],\n    ]\n\n    results = certain_kind_tap(data_items)\n\n    fruits, metals = results\n\n    print(\"=== fruits ===\")\n    for fruit in fruits:\n        print(fruit)\n\n    print(\"=== metals ===\")\n    for metal in metals:\n        print(metal)", "response": "Run the composition of csv_file_consumer and information tap\n    with the csv files in the input directory and collect all results from each file and print both kinds of results."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns last td tag in el DOM.", "response": "def _get_last_td(el):\n    \"\"\"\n    Return last <td> found in `el` DOM.\n\n    Args:\n        el (obj): :class:`dhtmlparser.HTMLElement` instance.\n\n    Returns:\n        obj: HTMLElement instance if found, or None if there are no <td> tags.\n    \"\"\"\n    if not el:\n        return None\n\n    if type(el) in [list, tuple, set]:\n        el = el[0]\n\n    last = el.find(\"td\")\n\n    if not last:\n        return None\n\n    return last[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the last td tag from the details.", "response": "def _get_td_or_none(details, ID):\n    \"\"\"\n    Get <tr> tag with given `ID` and return content of the last <td> tag from\n    <tr> root.\n\n    Args:\n        details (obj): :class:`dhtmlparser.HTMLElement` instance.\n        ID (str): id property of the <tr> tag.\n\n    Returns:\n        str: Content of the last <td> as strign.\n    \"\"\"\n    content = details.find(\"tr\", {\"id\": ID})\n    content = _get_last_td(content)\n\n    # if content is None, return it\n    if not content:\n        return None\n\n    content = content.getContent().strip()\n\n    # if content is blank string, return None\n    if not content:\n        return None\n\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_title(dom, details):\n    title = details.find(\"h1\")\n\n    # if the header is missing, try to parse title from the <title> tag\n    if not title:\n        title = dom.find(\"title\")\n        assert title, \"Can't find <title> tag!\"\n\n        return title[0].getContent().split(\"|\")[0].strip()\n\n    return title[0].getContent().strip()", "response": "Parse title of the book."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_authors(details):\n    authors = details.find(\n        \"tr\",\n        {\"id\": \"ctl00_ContentPlaceHolder1_tblRowAutor\"}\n    )\n\n    if not authors:\n        return []  # book with unspecified authors\n\n    # parse authors from HTML and convert them to Author objects\n    author_list = []\n    for author in authors[0].find(\"a\"):\n        author_obj = Author(author.getContent())\n\n        if \"href\" in author.params:\n            author_obj.URL = author.params[\"href\"]\n\n        author_list.append(author_obj)\n\n    return author_list", "response": "Parse authors of the book."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing publisher of the book.", "response": "def _parse_publisher(details):\n    \"\"\"\n    Parse publisher of the book.\n\n    Args:\n        details (obj): HTMLElement containing slice of the page with details.\n\n    Returns:\n        str/None: Publisher's name as string or None if not found.\n    \"\"\"\n    publisher = _get_td_or_none(\n        details,\n        \"ctl00_ContentPlaceHolder1_tblRowNakladatel\"\n    )\n\n    # publisher is not specified\n    if not publisher:\n        return None\n\n    publisher = dhtmlparser.removeTags(publisher).strip()\n\n    # return None instead of blank string\n    if not publisher:\n        return None\n\n    return publisher"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses number of pages and binding of the book.", "response": "def _parse_pages_binding(details):\n    \"\"\"\n    Parse number of pages and binding of the book.\n\n    Args:\n        details (obj): HTMLElement containing slice of the page with details.\n\n    Returns:\n        (pages, binding): Tuple with two string or two None.\n    \"\"\"\n    pages = _get_td_or_none(\n        details,\n        \"ctl00_ContentPlaceHolder1_tblRowRozsahVazba\"\n    )\n\n    if not pages:\n        return None, None\n\n    binding = None  # binding info and number of pages is stored in same string\n    if \"/\" in pages:\n        binding = pages.split(\"/\")[1].strip()\n        pages = pages.split(\"/\")[0].strip()\n\n    if not pages:\n        pages = None\n\n    return pages, binding"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse ISBN and EAN.", "response": "def _parse_ISBN_EAN(details):\n    \"\"\"\n    Parse ISBN and EAN.\n\n    Args:\n        details (obj): HTMLElement containing slice of the page with details.\n\n    Returns:\n        (ISBN, EAN): Tuple with two string or two None.\n    \"\"\"\n    isbn_ean = _get_td_or_none(\n        details,\n        \"ctl00_ContentPlaceHolder1_tblRowIsbnEan\"\n    )\n\n    if not isbn_ean:\n        return None, None\n\n    ean = None\n    isbn = None\n    if \"/\" in isbn_ean:  # ISBN and EAN are stored in same string\n        isbn, ean = isbn_ean.split(\"/\")\n        isbn = isbn.strip()\n        ean = ean.strip()\n    else:\n        isbn = isbn_ean.strip()\n\n    if not isbn:\n        isbn = None\n\n    return isbn, ean"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the description of the book.", "response": "def _parse_description(details):\n    \"\"\"\n    Parse description of the book.\n\n    Args:\n        details (obj): HTMLElement containing slice of the page with details.\n\n    Returns:\n        str/None: Details as string with currency or None if not found.\n    \"\"\"\n    description = details.find(\"div\", {\"class\": \"detailPopis\"})\n\n    # description not found\n    if not description:\n        return None\n\n    # remove links to ebook version\n    ekniha = description[0].find(\"div\", {\"class\": \"ekniha\"})\n    if ekniha:\n        ekniha[0].replaceWith(dhtmlparser.HTMLElement(\"\"))\n\n    # remove links to other books from same cathegory\n    detail = description[0].find(\"p\", {\"class\": \"detailKat\"})\n    if detail:\n        detail[0].replaceWith(dhtmlparser.HTMLElement(\"\"))\n\n    # remove all HTML elements\n    description = dhtmlparser.removeTags(description[0]).strip()\n\n    # description is blank\n    if not description:\n        return None\n\n    return description"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _process_book(book_url):\n    data = DOWNER.download(book_url)\n    dom = dhtmlparser.parseString(data)\n\n    details_tags = dom.find(\"div\", {\"id\": \"contentDetail\"})\n\n    assert details_tags, \"Can't find details of the book.\"\n\n    details = details_tags[0]\n\n    # parse required informations\n    title = _parse_title(dom, details)\n    authors = _parse_authors(details)\n    publisher = _parse_publisher(details)\n    price = _parse_price(details)\n    pages, binding = _parse_pages_binding(details)\n\n    pub = Publication(\n        title,\n        authors,\n        price,\n        publisher\n    )\n\n    # parse optional informations\n    pub.optionals.URL = book_url\n    pub.optionals.binding = binding\n\n    pub.optionals.pages = pages\n    pub.optionals.ISBN, pub.optionals.EAN = _parse_ISBN_EAN(details)\n    pub.optionals.edition = _parse_edition(details)\n    pub.optionals.description = _parse_description(details)\n\n    return pub", "response": "Parse the book details page and return a Publication object with the book details."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting list of publication offered by ben. cz.", "response": "def get_publications():\n    \"\"\"\n    Get list of publication offered by ben.cz.\n\n    Returns:\n        list: List of :class:`structures.Publication` objects.\n    \"\"\"\n    data = DOWNER.download(URL)\n    dom = dhtmlparser.parseString(data)\n\n    book_list = dom.find(\"div\", {\"class\": \"seznamKniha\"})\n\n    assert book_list, \"Can't find <div> with class 'seznamKniha'!\"\n\n    books = []\n    for html_chunk in book_list:\n        a = html_chunk.find(\"a\")\n\n        assert a, \"Can't find link to the details of the book!\"\n\n        if a[0].find(\"span\", {\"class\": \"ruzek pripravujeme\"}):\n            continue\n\n        books.append(\n            _process_book(a[0].params[\"href\"])\n        )\n\n    return books"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstore a value to DB", "response": "def store_value(self, name, value):\n        \"\"\"Store a value to DB\"\"\"\n        self.spine.send_command(\"storeSetting\", self.group, name, value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef retrieve_value(self, name, default_value=None):\n        value = self.spine.send_query(\"retrieveSetting\", self.group, name, processes=[\"kervi-main\"])\n        if value is None:\n            return default_value\n        elif isinstance(value, list) and len(value) == 0:\n            return default_value\n        elif isinstance(default_value, int):\n            return int(value)\n        elif isinstance(default_value, float):\n            return float(value)\n        else:\n            return value", "response": "Retrieve a value from DB"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntruncating the exponential backoff of the given amount of time.", "response": "def truncated_exponential_backoff(\n    slot_delay, collision=0, max_collisions=5,\n    op=operator.mul, in_range=True):\n    \"\"\"Truncated Exponential Backoff\n    see https://en.wikipedia.org/wiki/Exponential_backoff\n    \"\"\"\n    truncated_collision = collision % max_collisions\n    if in_range:\n        slots = random.randint(0, truncated_collision)\n    else:\n        slots = truncated_collision\n    return op(slot_delay, slots)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef uri(self, context=None):\n        if context is None:\n            context = self.context\n        else:\n            ctx = copy.deepcopy(self.context)\n            ctx.update(context)\n            context = ctx\n        return self.uri_format.format(**context)", "response": "returns the uri for the butcket name given the context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget rate limiters configuration at application level", "response": "def get_configs(cls):\n        \"\"\"Get rate limiters configuration\n        specified at application level\n\n        :rtype: dict of configurations\n        \"\"\"\n        import docido_sdk.config\n        http_config = docido_sdk.config.get('http') or {}\n        session_config = http_config.get('session') or {}\n        rate_limits = session_config.get('rate_limit') or {}\n        return rate_limits"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_config(cls, service, config=None):\n        config = config or cls.get_configs()\n        return config[service]", "response": "Get the configuration of the specified rate limiter"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload a rate - limiter from the configuration.", "response": "def get(cls, service, config=None, persistence_kwargs=None, **context):\n        \"\"\"Load a rate-limiter from configuration\n\n        :param str service:\n          rate limiter name to retrieve\n        :param dict config:\n          alternate configuration object to use. If `None`, then use the global\n          application configuration\n        :context:\n          Uniquely describe the consumed resource. Used by the persistence layer\n          to forge the URI describing the resource.\n\n        :rtype: :py:class:`RateLimiter` or :py:class:`MultiRateLimiter`\n        \"\"\"\n        rl_config = cls.get_config(service, config)\n        context.update(service=service)\n        if isinstance(rl_config, (dict, Mapping)):\n            if persistence_kwargs is not None:\n                rl_config.update(persistence_kwargs=persistence_kwargs)\n            return RateLimiter(context, **rl_config)\n        else:\n            def _rl(conf):\n                conf.setdefault('persistence_kwargs',\n                                persistence_kwargs or {})\n                return RateLimiter(context, **conf)\n            return MultiRateLimiter(\n                [_rl(config) for config in rl_config]\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef norm_page_cnt(page, max_number=None):\n    if page == None or page < 1:\n        page = 1\n\n    if max_number != None:\n        if page > max_number:\n            page = max_number\n    return page", "response": "Normalize a page number."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts pi to integer", "response": "def pi_to_number(self, page=1, item=1):\n        \"\"\"\n    Convert subpage & subitem to a integer\n\n    * if page == 1, then return 0, since the item count is the true # of items\n    * if page == 2, then return, page-1 * items_per_page, since we are\n      returning the # of items on a full page.\n\n    Args:\n        * None\n\n    Returns:\n        * Integer - Which represents the number of items up to the page.\n        \"\"\"\n        if page > 1:\n            return ((page - 1) * self.page_items) + item\n        else:\n            return 0 + item"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a single item in a page to a number.", "response": "def sub_pi_to_number(self, subpage=1, subitem=1):\n        \"\"\"\n    Convert subpage & subitem to a integer\n\n    * if page == 1, then return 0, since the item count is the true # of items\n    * if page == 2, then return, page-1 * items_per_page, since we are\n      returning the # of items on a full page.\n\n    Args:\n        * None\n\n    Returns:\n        * Integer - Which represents the number of items up to the page.\n        \"\"\"\n        if subitem == None:\n            subitem = 0\n\n        if subpage == None:\n            return 0\n        else:\n            if subpage > 1:\n                return ((subpage - 1) * self.subpage_items) + subitem\n            else:\n                return 0 + subitem"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert current spi to a number.", "response": "def current_spi_to_number(self):\n        \"\"\"\n    Convert subpage & subitem to a integer\n\n    * if page == 1, then return 0, since the item count is the true # of items\n    * if page == 2, then return, page-1 * items_per_page, since we are\n      returning the # of items on a full page.\n\n    Args:\n        * None\n\n    Returns:\n        * Integer - Which represents the number of items up to the page.\n        \"\"\"\n        if self.slots['subpage'] == None:\n            return self.sub_pi_to_number(0, 0)\n        else:\n            return self.sub_pi_to_number(self.slots['subpage'],\n                                         self.slots['subitem'])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchanging the page number of the page.", "response": "def change_page(self, offset=None, max_page_count=None, nom=True):\n        \"\"\"\n    Args:\n        * offset - Integer - The positive / negative change to apply\n          to the page.\n        * max_page_count - The maximum number of pages available.\n        * nom - None on Max or Min - If max number of pages reached,\n          return none instead of forcing back into range.\n\n    Returns:\n        Boolean - True if successful, False if nom is True and the\n        value was forced back within the boundry.\n        \"\"\"\n        if offset == None:\n            return\n\n        if self.slots['page'] == None:\n            self.slots['page'] = 1\n\n        if (self.slots['page']+offset > max_page_count) and nom:\n            return None\n        elif (self.slots['page']+offset < 1) and nom:\n            return None\n        else:\n            self.slots['page'] = norm_page_cnt(self.slots['page']+offset,\n                                               max_page_count)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef change_subpage(self, offset=None, max_page_count=None, nom=True):\n        if offset == None:\n            return\n\n        if self.slots['subpage'] == None:\n            self.slots['subpage'] = 1\n\n        if (self.slots['subpage']+offset > max_page_count) and nom:\n            return None\n        elif (self.slots['subpage']+offset < 1) and nom:\n            return None\n        else:\n            self.slots['subpage'] = norm_page_cnt(\\\n                self.slots['subpage']+offset,\n                max_page_count)\n        return True", "response": "Change the subpage of the page."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef change_item(self, offset=None, max_item_count=None, nom=True):\n        if offset == None:\n            return\n\n        if self.slots['item'] == None:\n            self.slots['item'] = 1\n\n        new_item = self.slots['item']+offset\n        if new_item > max_item_count:\n            new_item -= max_item_count\n            self.change_page(offset=+1, nom=False)\n        elif new_item < 1 and self.current_page() > 1:\n            self.change_page(offset=-1, nom=False)\n            if max_item_count != None:\n                new_item += max_item_count\n            else:\n                new_item += self.page_items\n\n        self.slots['item'] = new_item\n        return True", "response": "Change the item in the current page."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef change_subitem(self, offset=None, max_item_count=None, nom=True):\n        if offset == None:\n            return\n\n        if self.slots['subitem'] == None:\n            self.slots['subitem'] = 1\n\n        new_item = self.slots['subitem']+offset\n        if new_item > max_item_count:\n            new_item -= max_item_count\n            self.change_subpage(offset=+1, nom=False)\n        elif new_item < 1 and self.current_subpage() > 1:\n            self.change_subpage(offset=-1, nom=False)\n            if max_item_count != None:\n                new_item += max_item_count\n            else:\n                new_item += self.page_items\n\n        self.slots['subitem'] = new_item\n        return True", "response": "Change the subitem of the current page."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef return_current_uri_page_only(self):\n        uri = post_slash(\"%s%s\" % (post_slash(self.current_dir()),\n                         self.slots['page']))\n        return uri", "response": "Returns the current URI only if the current page is only."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the current URI of the current page and subpage.", "response": "def return_current_uri_subpage(self):\n        \"\"\"\n        Args:\n            * None\n\n        Returns:\n            String - Returns the full postpath & semantic components\n\n        *NOTE* may not contain the server & port numbers.  That depends on\n        what was provided to the parser.\n\n        \"\"\"\n        uri = post_slash(\"%s%s/%s/%s\" % (post_slash(self.current_dir()),\n                         self.slots['page'], self.slots['item'],\n                         self.slots['subpage']))\n        return uri"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef return_current_uri(self):\n        uri = post_slash(\"%s\" % self.current_dir())\n        for uri_part in self.slots.keys():\n            if self.slots[uri_part] != None:\n                uri += \"%s/\" % self.slots[uri_part]\n        return uri", "response": "Returns the current URI for the current class."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the number of items on page. Args: * page = The Page to test for * total_items = the total item count Returns: * Integer - Which represents the calculated number of items on page.", "response": "def return_item_count_on_page(self, page=1, total_items=1):\n        \"\"\"\n    Return the number of items on page.\n\n    Args:\n        * page = The Page to test for\n        * total_items = the total item count\n\n    Returns:\n        * Integer - Which represents the calculated number of items on page.\n        \"\"\"\n        up_to_page = ((page - 1) * self.page_items)\n        #   Number of items up to the page in question\n\n        if total_items > up_to_page:\n            #   Remove all the items up to the page in question\n            #\n            count = total_items - up_to_page\n\n        if count >= self.page_items:\n            # The remaining items are greater than the items per page\n            # so the answer is a full page\n            return self.page_items\n        else:\n            #   There are less items than a full page,\n            #\n            return count"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the number of items on page. Args: * page = The Page to test for * total_items = the total item count Returns: * Integer - Which represents the calculated number of items on page.", "response": "def return_item_count_on_subpage(self, subpage=1, total_items=1):\n        \"\"\"\n    Return the number of items on page.\n\n    Args:\n        * page = The Page to test for\n        * total_items = the total item count\n\n    Returns:\n        * Integer - Which represents the calculated number of items on page.\n        \"\"\"\n        up_to_subpage = ((subpage - 1) * self.subpage_items)\n        #   Number of items up to the page in question\n\n        if total_items > up_to_subpage:\n            #   Remove all the items up to the page in question\n            #\n            count = total_items - up_to_subpage\n        else:\n            count = total_items\n\n        if count >= self.subpage_items:\n            # The remaining items are greater than the items per page\n            # so the answer is a full page\n            return self.subpage_items\n        else:\n            #   There are less items than a full page,\n            #\n            return count"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the URI of the page and item.", "response": "def parse_uri(self, postpath=None):\n        \"\"\"\n    postpath - a url broken in to a list (postpath from twisted)\n    e.g. [\"127.0.0.1:8888\", \"albums\", \"2\", \"3\", \"44\", \"99\"]\n\n    Decode the postpath list, and deconstruct the\n\n    * Page\n    * Item\n    * subpage   (Archives)\n    * subitem   (Archives)\n\n    code::\n\n        import gallery\n        test =[\"127.0.0.1:8888\", \"albums\", \"2\", \"3\", \"44\", \"99\"]\n        gallery.new_decode_semantic_url(test)\n        ctx={}\n        test =[\"127.0.0.1:8888\", \"albums\", \"2\", \"3\", \"44\", \"99\"]\n        postpath, ctx[\"surl\"] = gallery.new_decode_semantic_url(test)\n\n        \"\"\"\n        def find_next_empty():\n            \"\"\"\n            return next open slot key\n            \"\"\"\n            for x in self.slots.keys():\n                if self.slots[x] == None:\n                    return x\n\n        if postpath == None:\n            self._current_dir = postpath\n            return\n\n        self.original_uri = copy.deepcopy(postpath)\n        path_to_parse = postpath\n        self.slots = collections.OrderedDict([('page', None),\n                                              ('item', None),\n                                              ('subpage', None),\n                                              ('subitem', None)])\n        self._current_dir = None\n        if path_to_parse in [[], '', None]:\n            self._current_dir = postpath\n\n        for x_postpath in range(0, len(postpath)):\n            if is_int(postpath[x_postpath].strip()):\n                self.slots[find_next_empty()] = int(postpath[x_postpath])\n\n        for removal in self.slots.keys():\n            if self.slots[removal] != None:\n                postpath.remove(str(self.slots[removal]))\n\n        self._current_dir = postpath"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, uuid):\n        for token in self.list():\n            if token.get('uuid') == uuid:\n                return token\n        raise LinShareException(-1, \"Can find uuid:\" + uuid)", "response": "Get the entry point with the given uuid"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the grading status of a course.", "response": "def get_grading_status(section_id, act_as=None):\n    \"\"\"\n    Return a restclients.models.gradepage.GradePageStatus object\n    on the given course\n    \"\"\"\n    url = \"{}/{}\".format(url_prefix, quote(section_id))\n    headers = {}\n\n    if act_as is not None:\n        headers[\"X-UW-Act-as\"] = act_as\n\n    response = get_resource(url, headers)\n    return _object_from_json(url, response)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_dict(self):\n        plain_dict = dict()\n        for k, v in self.items():\n            if self.__fields__[k].is_list:\n                if isinstance(self.__fields__[k], ViewModelField):\n                    plain_dict[k] = tuple(vt.to_dict() for vt in v)\n                    continue\n\n                plain_dict[k] = tuple(copy.deepcopy(vt) for vt in v)\n                continue\n\n            if isinstance(self.__fields__[k], ViewModelField):\n                plain_dict[k] = v.to_dict()\n                continue\n\n            plain_dict[k] = copy.deepcopy(v)\n\n        return plain_dict", "response": "Returns a dictionary representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrestoring from previously simplified data.", "response": "def restore(cls, data_dict):\n        \"\"\"\n        Restore from previously simplified data. Data is supposed to be valid,\n        no checks are performed!\n        \"\"\"\n        obj = cls.__new__(cls)  # Avoid calling constructor\n        object.__setattr__(obj, '_simplified', data_dict)\n        object.__setattr__(obj, '_storage', dict())\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef interrupt(self):\n\t\tself.image = io.BytesIO()\n\t\tself.renderer.screen.save(self.image, \"png\")", "response": "Interrupt the current thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the great circle distance between two points on earth in Kilometers and on the earth", "response": "def haversine(lon1, lat1, lon2, lat2, earth_radius=6357000):\n    \"\"\"Calculate the great circle distance between two points on earth in Kilometers\n    on the earth (specified in decimal degrees)\n\n    .. seealso:: :func:`distance_points`\n\n    :param float lon1: longitude of first place (decimal degrees)\n    :param float lat1: latitude of first place (decimal degrees)\n    :param float lon2: longitude of second place (decimal degrees)\n    :param float lat2: latitude of second place (decimal degrees)\n    :param earth_radius: earth_radius (use 6367 for KM 6367000 for meters 3956 for miles\n        - http://stackoverflow.com/questions/5283900/what-earth-radius-should-i-use-to-calculate-distances-near-the-poles\n\n    :Example:\n        >>> London_long=-0.126 ; London_lat=51.50; Paris_long = 2.350; Paris_lat = 48.856\n        >>> haversine(London_long, London_lat, Paris_long, Paris_lat)\n        342.55375272454864\n\n    :returns: float distance in Kilometers\n\n    \"\"\"\n    # convert decimal degrees to radiant\n    lon1, lat1, lon2, lat2 = list(map(math.radians, [lon1, lat1, lon2, lat2]))\n    # haversine formula\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2\n    c = 2 * math.asin(math.sqrt(a))\n    distance = earth_radius * c  # 6371 # Radius of earth in kilometers. Use 3956 for miles\n    return distance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dms2dd(degrees, minutes, seconds, direction):\n    dd = (degrees + minutes/60.0) + (seconds/3600.0)           # 60.0 fraction for python 2+ compatibility\n    return dd * -1 if direction == 'S' or direction == 'W' else dd", "response": "convert degrees minutes seconds to dd"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show():\n    if not is_configured():\n        raise JutException('No configurations available, please run: `jut config add`')\n\n    info('Available jut configurations:')\n    index = 0\n    for configuration in _CONFIG.sections():\n        username = _CONFIG.get(configuration, 'username')\n        app_url = _CONFIG.get(configuration, 'app_url')\n\n        if app_url != defaults.APP_URL:\n            if _CONFIG.has_option(configuration, 'default'):\n                info(' %d: %s@%s (default)', index + 1, username, app_url)\n            else:\n                info(' %d: %s@%s', index + 1, username, app_url)\n\n        else:\n            if _CONFIG.has_option(configuration, 'default'):\n                info(' %d: %s (default)' % (index + 1, username))\n            else:\n                info(' %d: %s' % (index + 1, username))\n\n        index += 1", "response": "Prints the available jut configuration to stdout"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the default configuration by name", "response": "def set_default(name=None, index=None):\n    \"\"\"\n    set the default configuration by name\n\n    \"\"\"\n    default_was_set = False\n    count = 1\n\n    for configuration in _CONFIG.sections():\n        if index != None:\n            if count == index:\n                _CONFIG.set(configuration, 'default', True)\n                default_was_set = True\n            else:\n                _CONFIG.remove_option(configuration, 'default')\n\n        if name != None:\n            if configuration == name:\n                _CONFIG.set(configuration, 'default', True)\n                default_was_set = True\n            else:\n                _CONFIG.remove_option(configuration, 'default')\n\n        count += 1\n\n    if not default_was_set:\n        raise JutException('Unable to find %s configuration' % name)\n\n    with open(_CONFIG_FILEPATH, 'w') as configfile:\n        _CONFIG.write(configfile)\n\n    info('Configuration updated at %s' % _JUT_HOME)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add(name, **kwargs):\n    _CONFIG.add_section(name)\n\n    for (key, value) in kwargs.items():\n        _CONFIG.set(name, key, value)\n\n    with open(_CONFIG_FILEPATH, 'w') as configfile:\n        _CONFIG.write(configfile)\n\n    info('Configuration updated at %s' % _JUT_HOME)", "response": "add a new configuration with the specified name and all of the keywords as attributes of that configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_default():\n\n    if not is_configured():\n        raise JutException('No configurations available, please run `jut config add`')\n\n    for configuration in _CONFIG.sections():\n        if _CONFIG.has_option(configuration, 'default'):\n            return dict(_CONFIG.items(configuration))", "response": "get the default configuration"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves the specified configuration", "response": "def remove(name=None, index=None):\n    \"\"\"\n    remove the specified configuration\n\n    \"\"\"\n\n    removed = False\n    count = 1\n    for configuration in _CONFIG.sections():\n        if index != None:\n            if count == index:\n                _CONFIG.remove_section(configuration)\n                removed = True\n                break\n\n        if name != None:\n            if configuration == name:\n                _CONFIG.remove_section(configuration)\n                removed = True\n                break\n\n        count += 1\n\n    if not removed:\n        raise JutException('Unable to find %s configuration' % name)\n\n    with open(_CONFIG_FILEPATH, 'w') as configfile:\n        _CONFIG.write(configfile)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True if the specified configuration is the default one", "response": "def is_default(name=None, index=None):\n    \"\"\"\n    returns True if the specified configuration is the default one\n\n    \"\"\"\n\n    if not is_configured():\n        raise JutException('No configurations available, please run `jut config add`')\n\n    count = 1\n    for configuration in _CONFIG.sections():\n\n        if index != None:\n            if _CONFIG.has_option(configuration, 'default') and count == index:\n                return True\n\n        if name != None:\n            if _CONFIG.has_option(configuration, 'default') and configuration == name:\n                return True\n\n        count += 1\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef disconnect(self, user):\n        self.remove_user(user)\n        self.send_message(create_message('RoomServer', 'Please all say goodbye to {name}!'.format(name=user.id.name)))\n        self.send_message(create_disconnect(user.id.name))", "response": "Disconnect a user and send a message to the \n            connected clients"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a user with given username if connected returns None if not found", "response": "def get_user(self, username):\n        \"\"\" gets a user with given username if connected \"\"\"\n        for user in self.users:\n            if user.id.name == username:\n                return user\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend a message to all the users", "response": "def send_message(self, message):\n        \"\"\" send a message to each of the users \"\"\"\n        for handler in self.users:\n            logging.info('Handler: ' + str(handler))\n            handler.write_message(message)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef welcome(self, user):\n        self.send_message(create_message('RoomServer', 'Please welcome {name} to the server!\\nThere are currently {i} users online -\\n {r}\\n'.format(name=user.id, \n                          i=self.amount_of_users_connected, \n                          r=' '.join(self.user_names))))\n        logging.debug('Welcoming user {user} to {room}'.format(user=user.id.name, room=self.name))", "response": "welcomes a user to the roomserver"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef float_range(string, minimum, maximum, inf, sup):\n    return _inrange(float(string), minimum, maximum, inf, sup)", "response": "Validate that a string is a number and that it is within a certain range."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef length_range(string, minimum, maximum):\n    int_range(len(string), minimum, maximum)\n    return string", "response": "Ensures that the length of the string is in a certain range."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef int_option(string, options):\n    i = int(string)\n    if i in options:\n        return i\n\n    raise ValueError('Not in allowed options')", "response": "Validate that a string is in the list of options."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dictionary of triggers and their corresponding matches from the code.", "response": "def collectTriggers(self, rgx, code):\n        \"\"\"Return a dictionary of triggers and their corresponding matches\n        from the code.\n\n        \"\"\"\n\n        return {m.group(0): m for m in re.finditer(rgx, code)}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list out template outputs based on the triggers found in the code and the template they create.", "response": "def genOutputs(self, code, match):\n        \"\"\"Return a list out template outputs based on the triggers found in\n        the code and the template they create.\n\n        \"\"\"\n\n        out = sorted((k, match.output(m)) for (k, m) in\n                     self.collectTriggers(match.match, code).items())\n        out = list(map(lambda a: a[1], out))\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the source code in text filled with autogenerated code starting at start.", "response": "def gen(self, text, start=0):\n        \"\"\"Return the source code in text, filled with autogenerated code\n        starting at start.\n\n        \"\"\"\n\n        for cc in self.chunkComment(text, start):\n            c = self.extractChunkContent(cc)\n            cc = ''.join(cc)\n            m = self.matchComment(c)\n            idx = text.index(cc, start)\n            e = idx + len(cc)\n            if m:\n                assert text[idx:e] == cc\n\n                try:\n                    end = text.index('\\n\\n', e - 1) + 1\n                except ValueError:\n                    end = len(text)\n                text = text[:e] + text[end:]\n                new = self.genOutputs(self.code(text), m)\n                new = ''.join(new)\n                text = text[:e] + new + text[e:]\n\n                return self.gen(text, e + len(new))\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes beta of two values", "response": "def beta(a, b):\n  \"\"\"use gamma function or inbuilt math.gamma() to compute vals of beta func\"\"\"\n  beta = math.exp(math.lgamma(a) + math.lgamma(b) - math.lgamma(a + b))\n  return beta"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reg_incomplete_beta(a, b, x):\n\n  if (x == 0):\n    return 0\n  elif (x == 1):\n    return 1\n  else:\n    lbeta = (math.lgamma(a + b) - math.lgamma(a) - math.lgamma(b) +\n             a * math.log(x) + b * math.log(1 - x))\n    if (x < (a + 1) / (a + b + 2)):\n      return math.exp(lbeta) * __contfractbeta(a, b, x) / a\n    else:\n      return 1 - math.exp(lbeta) * __contfractbeta(b, a, 1 - x) / b", "response": "Incomplete beta function ; code translated from Numerical Recipes in Numerical Recipes in C.\n : code translated from Numerical Recipes in C.\n  : param a b x"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef beta_pdf(x, a, b):\n  bc = 1 / beta(a, b)\n  fc = x ** (a - 1)\n  sc = (1 - x) ** (b - 1)\n  return bc * fc * sc", "response": "Beta distirbution probability density function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the dynamic field that matches the given name.", "response": "def _get_dynamic_field_for(cls, field_name):\n        \"\"\"\n        Return the dynamic field within this class that match the given name.\n        Keep an internal cache to speed up future calls wieh same field name.\n        (The cache store the field for each individual class and subclasses, to\n        keep the link between a field and its direct model)\n        \"\"\"\n        from .fields import DynamicFieldMixin  # here to avoid circular import\n\n        if cls not in ModelWithDynamicFieldMixin._dynamic_fields_cache:\n            ModelWithDynamicFieldMixin._dynamic_fields_cache[cls] = {}\n\n        if field_name not in ModelWithDynamicFieldMixin._dynamic_fields_cache[cls]:\n            ModelWithDynamicFieldMixin._dynamic_fields_cache[cls][field_name] = None\n            for a_field_name in cls._fields:\n                field = cls.get_field(a_field_name)\n                if isinstance(field, DynamicFieldMixin) and field._accept_name(field_name):\n                    ModelWithDynamicFieldMixin._dynamic_fields_cache[cls][field_name] = field\n                    break\n\n        field = ModelWithDynamicFieldMixin._dynamic_fields_cache[cls][field_name]\n\n        if field is None:\n            raise ValueError('No DynamicField matching \"%s\"' % field_name)\n\n        return field"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the current class has a field with the name field_name", "response": "def has_field(cls, field_name):\n        \"\"\"\n        Check if the current class has a field with the name \"field_name\"\n        Add management of dynamic fields, to return True if the name matches an\n        existing dynamic field without existing copy for this name.\n        \"\"\"\n        if super(ModelWithDynamicFieldMixin, cls).has_field(field_name):\n            return True\n\n        try:\n            cls._get_dynamic_field_for(field_name)\n        except ValueError:\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a single field from the model.", "response": "def get_class_field(cls, field_name):\n        \"\"\"\n        Add management of dynamic fields: if a normal field cannot be retrieved,\n        check if it can be a dynamic field and in this case, create a copy with\n        the given name and associate it to the model.\n        \"\"\"\n        try:\n            field = super(ModelWithDynamicFieldMixin, cls).get_class_field(field_name)\n        except AttributeError:\n            # the \"has_field\" returned True but getattr raised... we have a DynamicField\n            dynamic_field = cls._get_dynamic_field_for(field_name)\n            field = cls._add_dynamic_field_to_model(dynamic_field, field_name)\n\n        return field"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the instance field for the given name.", "response": "def get_instance_field(self, field_name):\n        \"\"\"\n        Add management of dynamic fields: if a normal field cannot be retrieved,\n        check if it can be a dynamic field and in this case, create a copy with\n        the given name and associate it to the instance.\n        \"\"\"\n        try:\n            field = super(ModelWithDynamicFieldMixin, self).get_instance_field(field_name)\n        except AttributeError:\n            # the \"has_field\" returned True but getattr raised... we have a DynamicField\n            dynamic_field = self._get_dynamic_field_for(field_name)  # it's a model bound field\n            dynamic_field = self.get_field(dynamic_field.name)  # we now have an instance bound field\n            field = self._add_dynamic_field_to_instance(dynamic_field, field_name)\n\n        return field"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a copy of the DynamicField field to the current class and its subclasses using the field_name name", "response": "def _add_dynamic_field_to_model(cls, field, field_name):\n        \"\"\"\n        Add a copy of the DynamicField \"field\" to the current class and its\n        subclasses using the \"field_name\" name\n        \"\"\"\n        # create the new field\n        new_field = field._create_dynamic_version()\n        new_field.name = field_name\n        new_field._attach_to_model(cls)\n\n        # set it as an attribute on the class, to be reachable\n        setattr(cls, \"_redis_attr_%s\" % field_name, new_field)\n\n        # NOTE: don't add the field to the \"_fields\" list, to avoid use extra\n        #       memory to each future instance that will create a field for each\n        #       dynamic one created\n\n        # # add the field to the list to avoid to done all of this again\n        # # (_fields is already on this class only, not subclasses)\n        # cls._fields.append(field_name)\n\n        # each subclass needs its own copy\n        for subclass in cls.__subclasses__():\n            subclass._add_dynamic_field_to_model(field, field_name)\n\n        return new_field"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _add_dynamic_field_to_instance(self, field, field_name):\n        # create the new field\n        new_field = field._create_dynamic_version()\n        new_field.name = field_name\n        new_field._attach_to_instance(self)\n\n        # add the field to the list to avoid doing all of this again\n        if field_name not in self._fields:  # (maybe already in it via the class)\n            if id(self._fields) == id(self.__class__._fields):\n                # unlink the list from the class\n                self._fields = list(self._fields)\n            self._fields.append(field_name)\n\n        # if the field is an hashable field, add it to the list to allow calling\n        # hmget on these fields\n        if isinstance(field, limpyd_fields.InstanceHashField):\n            if id(self._instancehash_fields) == id(self.__class__._instancehash_fields):\n                # unlink the link from the class\n                self._instancehash_fields = list(self._instancehash_fields)\n            self._instancehash_fields.append(field_name)\n\n        # set it as an attribute on the instance, to be reachable\n        setattr(self, field_name, new_field)\n\n        return new_field", "response": "Add a copy of the DynamicField field to the current instance using the field_name name"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives the name of a dynamic field and a dynamic part return the name of the final dynamic field that will be used with get_field.", "response": "def get_field_name_for(cls, field_name, dynamic_part):\n        \"\"\"\n        Given the name of a dynamic field, and a dynamic part, return the\n        name of the final dynamic field to use. It will then be used with\n        get_field.\n        \"\"\"\n        field = cls.get_field(field_name)\n        return field.get_name_for(dynamic_part)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprograming entry point. :param argv: command-line arguments :type argv: :class:`list`", "response": "def main(argv):\n    \"\"\"Program entry point.\n\n    :param argv: command-line arguments\n    :type argv: :class:`list`\n    \"\"\"\n    author_strings = []\n    for name, email in zip(metadata.authors, metadata.emails):\n        author_strings.append('Author: {0} <{1}>'.format(name, email))\n\n    epilog = '''\n{project} {version}\n\n{authors}\nURL: <{url}>\n'''.format(\n        project=metadata.project,\n        version=metadata.version,\n        authors='\\n'.join(author_strings),\n        url=metadata.url)\n\n    arg_parser = argparse.ArgumentParser(\n        prog=argv[0],\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=metadata.description,\n        epilog=epilog)\n    arg_parser.add_argument(\n        '-V', '--version',\n        action='version',\n        version='{0} {1}'.format(metadata.project, metadata.version))\n\n    arg_parser.parse_args(args=argv[1:])\n\n    print(epilog)\n\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses the command line arguments for the Growth command line.", "response": "def process_arguments():\n    \"\"\"\n    Process the command line arguments. The arguments are:\n     * the table to generate random from;\n     * -l (or --length) for the length of generated words (default: 10);\n     * -p (or --prefix) for the maximum of prefixes to consider (default: 0);\n     * -c (or --count) for the number of words to generate (default: 10);\n     * -s (or --start) for generating only words starting in table;\n     * -e (or --end) for generating only words ending in table;\n     * -f (or --flatten) if the table must be flattened before generation.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"Generate random words from \"\n                                                 \"the given content\",\n                                     epilog=\"This script can generate random\"\n                                            \"words from tables, trees or \"\n                                            \"texts. If a tree is given, \"\n                                            \"the length of the generated \"\n                                            \"words depend on the tree. If a \"\n                                            \"table is given, the table is \"\n                                            \"used to generate words, except \"\n                                            \"if --end option is given. If a \"\n                                            \"text is given, \"\n                                            \"the corresponding table is \"\n                                            \"built, and also the tree if \"\n                                            \"needed.\")\n    parser.add_argument(\"content\", help=\"the content\")\n    parser.add_argument(\"--length\", \"-l\", type=nonzero_natural, default=10,\n                        dest=\"length\", help=\"the length of generated words \"\n                                            \"(default: 10)\")\n    parser.add_argument(\"--prefix\", \"-p\", type=natural, default=0,\n                        dest=\"prefix\", help=\"if not 0, the maximum length of \"\n                                            \"prefixes to consider when \"\n                                            \"choosing the next character \"\n                                            \"(default: 0)\")\n    parser.add_argument(\"--count\", \"-c\", type=natural, default=10,\n                        dest=\"count\", help=\"the number of words to generate \"\n                                           \"(default: 10)\")\n    parser.add_argument(\"--start\", \"-s\", action=\"store_true\", default=False,\n                        dest=\"start\", help=\"only starting words\")\n    parser.add_argument(\"--end\", \"-e\", action=\"store_true\", default=False,\n                        dest=\"end\", help=\"only ending words\")\n    parser.add_argument(\"--flatten\", \"-f\", action=\"store_true\", default=False,\n                        dest=\"flatten\", help=\"flatten the table\")\n    return parser.parse_args()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate an image object on local disk from the given file.", "response": "def create_object(self, filename, img_properties=None):\n        \"\"\"Create an image object on local disk from the given file. The file\n        is copied to a new local directory that is created for the image object.\n        The optional list of image properties will be associated with the new\n        object together with the set of default properties for images.\n\n        Parameters\n        ----------\n        filename : string\n            Path to file on disk\n        img_properties : Dictionary, optional\n            Set of image properties.\n\n        Returns\n        -------\n        ImageHandle\n            Handle for created image object\n        \"\"\"\n        # Get the file name, i.e., last component of the given absolute path\n        prop_name = os.path.basename(os.path.normpath(filename))\n        # Ensure that the image file has a valid suffix. Currently we do not\n        # check whether the file actually is an image. If the suffix is valid\n        # get the associated Mime type from the dictionary.\n        prop_mime = None\n        pos = prop_name.rfind('.')\n        if pos >= 0:\n            suffix = prop_name[pos:].lower()\n            if suffix in VALID_IMGFILE_SUFFIXES:\n                prop_mime = VALID_IMGFILE_SUFFIXES[suffix]\n        if not prop_mime:\n            raise ValueError('unsupported image type: ' + prop_name)\n        # Create a new object identifier.\n        identifier = str(uuid.uuid4()).replace('-','')\n        # The sub-folder to store the image is given by the first two\n        # characters of the identifier.\n        image_dir = self.get_directory(identifier)\n        # Create the directory if it doesn't exists\n        if not os.access(image_dir, os.F_OK):\n            os.makedirs(image_dir)\n        # Create the initial set of properties for the new image object.\n        properties = {\n            datastore.PROPERTY_NAME: prop_name,\n            datastore.PROPERTY_FILENAME : prop_name,\n            datastore.PROPERTY_FILESIZE : os.path.getsize(filename),\n            datastore.PROPERTY_MIMETYPE : prop_mime\n        }\n        # Add additional image properties (if given). Note that this will not\n        # override the default image properties.\n        if not img_properties is None:\n            for prop in img_properties:\n                if not prop in properties:\n                    properties[prop] = img_properties[prop]\n        # Copy original file to new object's directory\n        shutil.copyfile(filename, os.path.join(image_dir, prop_name))\n        # Create object handle and store it in database before returning it\n        obj = ImageHandle(identifier, properties, image_dir)\n        self.insert_object(obj)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate an ImageHandle from a JSON document retrieved from database.", "response": "def from_dict(self, document):\n        \"\"\"Create image object from JSON document retrieved from database.\n\n        Parameters\n        ----------\n        document : JSON\n            Json document in database\n\n        Returns\n        -------\n        ImageHandle\n            Handle for image object\n        \"\"\"\n        # Get object properties from Json document\n        identifier = str(document['_id'])\n        active = document['active']\n        timestamp = datetime.datetime.strptime(document['timestamp'], '%Y-%m-%dT%H:%M:%S.%f')\n        properties = document['properties']\n        # The directory is not materilaized in database to allow moving the\n        # base directory without having to update the database.\n        directory = self.get_directory(identifier)\n        # Cretae image handle\n        return ImageHandle(identifier, properties, directory, timestamp=timestamp, is_active=active)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nimplementing the policy for naming directories for image objects.", "response": "def get_directory(self, identifier):\n        \"\"\"Implements the policy for naming directories for image objects. Image\n        object directories are name by their identifier. In addition, these\n        directories are grouped in parent directories named by the first two\n        characters of the identifier. The aim is to avoid having too many\n        sub-folders in a single directory.\n\n        Parameters\n        ----------\n        identifier : string\n            Unique object identifier\n\n        Returns\n        -------\n        string\n            Path to image objects data directory\n        \"\"\"\n        return os.path.join(\n            os.path.join(self.directory, identifier[:2]),\n            identifier\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_object(self, name, images, filename, options=None, object_identifier=None, read_only=False):\n        # Raise an exception if given image group is not valied.\n        self.validate_group(images)\n        # Create a new object identifier if none is given.\n        if object_identifier is None:\n            identifier = str(uuid.uuid4()).replace('-','')\n        else:\n            identifier = object_identifier\n        # Create the initial set of properties.\n        prop_filename = os.path.basename(os.path.normpath(filename))\n        prop_mime = 'application/x-tar' if filename.endswith('.tar') else 'application/x-gzip'\n        properties = {\n            datastore.PROPERTY_NAME: name,\n            datastore.PROPERTY_FILENAME : prop_filename,\n            datastore.PROPERTY_FILESIZE : os.path.getsize(filename),\n            datastore.PROPERTY_MIMETYPE : prop_mime\n        }\n        if read_only:\n            properties[datastore.PROPERTY_READONLY] = True\n        # Directories are simply named by object identifier\n        directory = os.path.join(self.directory, identifier)\n        # Create the directory if it doesn't exists\n        if not os.access(directory, os.F_OK):\n            os.makedirs(directory)\n        # Move original file to object directory\n        shutil.copyfile(filename, os.path.join(directory, prop_filename))\n        # Get dictionary of given options. If none are given opts will be an\n        # empty dictionary. If duplicate attribute names are present an\n        # exception will be raised.\n        opts = attribute.to_dict(options, self.attribute_defs)\n        # Create the image group object and store it in the database before\n        # returning it.\n        obj = ImageGroupHandle(\n            identifier,\n            properties,\n            directory,\n            images,\n            opts\n        )\n        self.insert_object(obj)\n        return obj", "response": "Create an image group object with the given list of images and a local file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_dict(self, document):\n        # Get object attributes from Json document\n        identifier = str(document['_id'])\n        # Create list of group images from Json\n        images = list()\n        for grp_image in document['images']:\n            images.append(GroupImage(\n                grp_image['identifier'],\n                grp_image['folder'],\n                grp_image['name'],\n                os.path.join(\n                    self.image_manager.get_directory(grp_image['identifier']),\n                    grp_image['name']\n                )\n            ))\n        # Create list of properties and add group size\n        properties = document['properties']\n        properties[PROPERTY_GROUPSIZE] = len(document['images'])\n        # Directories are simply named by object identifier\n        directory = os.path.join(self.directory, identifier)\n        # Create image group handle.\n        return ImageGroupHandle(\n            identifier,\n            properties,\n            directory,\n            images,\n            attribute.attributes_from_dict(document['options']),\n            timestamp=datetime.datetime.strptime(\n                document['timestamp'],\n                '%Y-%m-%dT%H:%M:%S.%f'\n            ),\n            is_active=document['active']\n        )", "response": "Create image group object from JSON document retrieved from database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting identifier of all collections that contain a given image.", "response": "def get_collections_for_image(self, image_id):\n        \"\"\"Get identifier of all collections that contain a given image.\n\n        Parameters\n        ----------\n        image_id : string\n            Unique identifierof image object\n\n        Returns\n        -------\n        List(string)\n            List of image collection identifier\n        \"\"\"\n        result = []\n        # Get all active collections that contain the image identifier\n        for document in self.collection.find({'active' : True, 'images.identifier' : image_id}):\n            result.append(str(document['_id']))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of all images in the object store for the specified image group.", "response": "def list_images(self, identifier, offset=-1, limit=-1):\n        \"\"\"\n        Parameters\n        ----------\n        identifier : string\n            Unique image group identifier\n        limit : int\n            Limit number of results in returned object listing\n        offset : int\n            Set offset in list (order as defined by object store)\n\n        Returns\n        -------\n        ObjectListing\n            Listing of group images or None if image group does not exist\n        \"\"\"\n        # Get image group to ensure that it exists. The object contains the full\n        # list of group images\n        img_grp = self.get_object(identifier)\n        if img_grp is None:\n            return None\n        # Extract subset of group images based on offset and limit arguments\n        total_count = len(img_grp.images)\n        items = []\n        if offset < total_count:\n            if limit > 0:\n                list_end = min((offset + limit), total_count)\n            else:\n                list_end = total_count\n            for i in range(offset, list_end):\n                items.append(img_grp.images[i])\n        # Return object listing\n        return datastore.ObjectListing(items, offset, limit, total_count)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a Json - like dictionary for image group. Extends the basic object with an array of image identifiers.", "response": "def to_dict(self, img_coll):\n        \"\"\"Create a Json-like dictionary for image group. Extends the basic\n        object with an array of image identifiers.\n\n        Parameters\n        ----------\n        img_coll : ImageGroupHandle\n\n        Returns\n        -------\n        (JSON)\n            Json-like object, i.e., dictionary.\n        \"\"\"\n        # Get the basic Json object from the super class\n        json_obj = super(DefaultImageGroupManager, self).to_dict(img_coll)\n        # Add list of images as Json array\n        images = []\n        for img_group in img_coll.images:\n            images.append({\n                'identifier' : img_group.identifier,\n                'folder' : img_group.folder,\n                'name' : img_group.name\n            })\n        json_obj['images'] = images\n        # Transform dictionary of options into list of elements, one per typed\n        # attribute in the options set.\n        json_obj['options'] = attribute.attributes_to_dict(img_coll.options)\n        return json_obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_object_options(self, identifier, options):\n        # Retrieve object from database to ensure that it exists\n        img_group = self.get_object(identifier)\n        if img_group is None:\n            return None\n        # Replace existing object in database with object having given options.\n        # Raises an exception of attributes with duplicate names appear in the\n        # list.\n        img_group.options = attribute.to_dict(options, self.attribute_defs)\n        self.replace_object(img_group)\n        # Return image group handle\n        return img_group", "response": "Updates the options of an object with the given options. Raises a ValueError if any of the given options violates the attribute definitions associated with image\n        groups. Returns ImageGroupHandle Returns None if object is not found."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates that the combination of folder and name for all images in a group is unique. Raises a ValueError exception if uniqueness constraint is violated.", "response": "def validate_group(images):\n        \"\"\"Validates that the combination of folder and name for all images in\n        a group is unique. Raises a ValueError exception if uniqueness\n        constraint is violated.\n\n        Parameters\n        ----------\n        images : List(GroupImage)\n            List of images in group\n        \"\"\"\n        image_ids = set()\n        for image in images:\n            key = image.folder + image.name\n            if key in image_ids:\n                raise ValueError('Duplicate images in group: ' + key)\n            else:\n                image_ids.add(key)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_object(self, name, image_sets):\n        # Create a new object identifier\n        identifier = str(uuid.uuid4()).replace('-','')\n        properties = {datastore.PROPERTY_NAME: name}\n        # Create the image group object and store it in the database before\n        # returning it.\n        obj = PredictionImageSetHandle(identifier, properties, image_sets)\n        self.insert_object(obj)\n        return obj", "response": "Create a prediction image set list and store it in the database."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_dict(self, document):\n        return PredictionImageSetHandle(\n            str(document['_id']),\n            document['properties'],\n            [PredictionImageSet.from_dict(img) for img in document['images']],\n            timestamp=datetime.datetime.strptime(\n                document['timestamp'],\n                '%Y-%m-%dT%H:%M:%S.%f'\n            ),\n            is_active=document['active']\n        )", "response": "Create a prediction image set resource from a dictionary serialization."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a dictionary serialization for a prediction image set handle.", "response": "def to_dict(self, img_sets):\n        \"\"\"Create a dictionary serialization for a prediction image set handle.\n\n        Parameters\n        ----------\n        img_sets : PredictionImageSetHandle\n\n        Returns\n        -------\n        dict\n            Dictionary serialization of the resource\n        \"\"\"\n        # Get the basic Json object from the super class\n        json_obj = super(DefaultPredictionImageSetManager, self).to_dict(img_sets)\n        # Add list of image sets as Json array\n        json_obj['images'] = [img_set.to_dict() for img_set in img_sets.images]\n        return json_obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _load_tasks(self, tasks, vars={}, additional_conditions=[]):\n        ''' handle task and handler include statements '''\n\n        results = []\n        if tasks is None:\n            # support empty handler files, and the like.\n            tasks = []\n\n        for x in tasks:\n            task_vars = self.vars.copy()\n            task_vars.update(vars)\n            if 'include' in x:\n                tokens = shlex.split(x['include'])\n                items = ['']\n                included_additional_conditions = list(additional_conditions)\n                for k in x:\n                    if k.startswith(\"with_\"):\n                        plugin_name = k[5:]\n                        if plugin_name not in utils.plugins.lookup_loader:\n                            raise errors.AnsibleError(\"cannot find lookup plugin named %s for usage in with_%s\" % (plugin_name, plugin_name))\n                        terms = utils.template_ds(self.basedir, x[k], task_vars)\n                        items = utils.plugins.lookup_loader.get(plugin_name, basedir=self.basedir, runner=None).run(terms, inject=task_vars)\n                    elif k.startswith(\"when_\"):\n                        included_additional_conditions.append(utils.compile_when_to_only_if(\"%s %s\" % (k[5:], x[k])))\n                    elif k in (\"include\", \"vars\", \"only_if\"):\n                        pass\n                    else:\n                        raise errors.AnsibleError(\"parse error: task includes cannot be used with other directives: %s\" % k)\n\n                if 'vars' in x:\n                    task_vars.update(x['vars'])\n                if 'only_if' in x:\n                    included_additional_conditions.append(x['only_if'])\n\n                for item in items:\n                    mv = task_vars.copy()\n                    mv['item'] = item\n                    for t in tokens[1:]:\n                        (k,v) = t.split(\"=\", 1)\n                        mv[k] = utils.template_ds(self.basedir, v, mv)\n                    include_file = utils.template(self.basedir, tokens[0], mv)\n                    data = utils.parse_yaml_from_file(utils.path_dwim(self.basedir, include_file))\n                    results += self._load_tasks(data, mv, included_additional_conditions)\n            elif type(x) == dict:\n                results.append(Task(self,x,module_vars=task_vars, additional_conditions=additional_conditions))\n            else:\n                raise Exception(\"unexpected task type\")\n\n        for x in results:\n            if self.tags is not None:\n                x.tags.extend(self.tags)\n\n        return results", "response": "handle task and handler include statements"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading the vars section from a play accounting for all sorts of variable features and prompting and conditional includes of the first available variable features.", "response": "def _get_vars(self):\n        ''' load the vars section from a play, accounting for all sorts of variable features\n        including loading from yaml files, prompting, and conditional includes of the first\n        file found in a list. '''\n\n        if self.vars is None:\n            self.vars = {}\n\n        if type(self.vars) not in [dict, list]:\n            raise errors.AnsibleError(\"'vars' section must contain only key/value pairs\")\n\n        vars = {}\n\n        # translate a list of vars into a dict\n        if type(self.vars) == list:\n            for item in self.vars:\n                if getattr(item, 'items', None) is None:\n                    raise errors.AnsibleError(\"expecting a key-value pair in 'vars' section\")\n                k, v = item.items()[0]\n                vars[k] = v\n        else:\n            vars.update(self.vars)\n\n        if type(self.playbook.extra_vars) == dict:\n            vars.update(self.playbook.extra_vars)\n\n        if type(self.vars_prompt) == list:\n            for var in self.vars_prompt:\n                if not 'name' in var:\n                    raise errors.AnsibleError(\"'vars_prompt' item is missing 'name:'\")\n\n                vname = var['name']\n                prompt = var.get(\"prompt\", vname)\n                default = var.get(\"default\", None)\n                private = var.get(\"private\", True)\n\n                confirm = var.get(\"confirm\", False)\n                encrypt = var.get(\"encrypt\", None)\n                salt_size = var.get(\"salt_size\", None)\n                salt = var.get(\"salt\", None)\n\n                if vname not in self.playbook.extra_vars:\n                    vars[vname] = self.playbook.callbacks.on_vars_prompt (\n                                     vname, private, prompt, encrypt, confirm, salt_size, salt, default\n                                  )\n\n        elif type(self.vars_prompt) == dict:\n            for (vname, prompt) in self.vars_prompt.iteritems():\n                prompt_msg = \"%s: \" % prompt\n                if vname not in self.playbook.extra_vars:\n                    vars[vname] = self.playbook.callbacks.on_vars_prompt(\n                                     varname=vname, private=False, prompt=prompt_msg, default=None\n                                  )\n\n        else:\n            raise errors.AnsibleError(\"'vars_prompt' section is malformed, see docs\")\n\n        results = self.playbook.extra_vars.copy()\n        results.update(vars)\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compare_tags(self, tags):\n        ''' given a list of tags that the user has specified, return two lists:\n        matched_tags:   tags were found within the current play and match those given\n                        by the user\n        unmatched_tags: tags that were found within the current play but do not match\n                        any provided by the user '''\n\n        # gather all the tags in all the tasks into one list\n        all_tags = []\n        for task in self._tasks:\n            all_tags.extend(task.tags)\n\n        # compare the lists of tags using sets and return the matched and unmatched\n        all_tags_set = set(all_tags)\n        tags_set = set(tags)\n        matched_tags = all_tags_set & tags_set\n        unmatched_tags = all_tags_set - tags_set\n\n        return matched_tags, unmatched_tags", "response": "given a list of tags that the user has specified return two lists that are matched and unmatched tags that are not provided by the user"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a keystroke event into a corresponding key name.", "response": "def key_event_to_name(event):\n    \"\"\" Converts a keystroke event into a corresponding key name.\n    \"\"\"\n    key_code = event.key()\n    modifiers = event.modifiers()\n    if modifiers & QtCore.Qt.KeypadModifier:\n        key = keypad_map.get(key_code)\n    else:\n        key = None\n    if key is None:\n        key = key_map.get(key_code)\n \n    name = ''\n    if modifiers & QtCore.Qt.ControlModifier:\n        name += 'Ctrl'\n \n    if modifiers & QtCore.Qt.AltModifier:\n        name += '-Alt' if name else 'Alt'\n \n    if modifiers & QtCore.Qt.MetaModifier:\n        name += '-Meta' if name else 'Meta'\n \n    if modifiers & QtCore.Qt.ShiftModifier and ((name != '') or (key is not None and len(key) > 1)):\n        name += '-Shift' if name else 'Shift'\n \n    if key:\n        if name:\n            name += '-'\n        name += key\n    return name"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget children as time series", "response": "def get_children_as_time_series(self, json_children, time_field=['entity','occurred']):\n        result = []\n        time_field_as_path_list = time_field.strip().split(\".\")\n        if len(time_field_as_path_list) == 0:\n            return result\n\n        \"\"\"\n        FROM:\n        {\n            \"id\": \"60411677\",\n            \"uri\": \"https://api.cityverve.org.uk/v1/entity/crime/60411677\",\n            \"type\": \"crime\",\n            \"name\": \"Anti Social Behaviour - On or near Manor Road\",\n            \"loc\": {},\n            \"entity\": {\n                \"category\": \"Anti Social Behaviour\",\n                \"occurred\": \"2017-10-01\",\n                \"area\": \"On or near Manor Road\",\n                \"outcome\": {\n                    \"status\": null,\n                    \"resolved\": null\n                }\n            },\n            \"instance\": {...},\n            \"legal\": [..]\n        }, {}, {}, ...\n\n        TO:\n        {\n            \"time\": \"2017-10-01\",\n            \"value\": \"556\"\n        },\n        {...}, {...}, ...\"\"\"\n\n        # get times\n        result_dict = {}\n        for child in json_children:\n            time = self.get_time(child[0], time_field_as_path_list)\n            if time in result_dict:\n                result_dict[time] += 1\n            else:\n                result_dict[time] = 1\n\n        # turn lookup dict (result_dict) into final list\n        for key, value in result_dict.items():\n            temp = {'time': key, 'value': value}\n            result.append(temp)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readmodule(module, path=None):\n    '''Backwards compatible interface.\n\n    Call readmodule_ex() and then only keep Class objects from the\n    resulting dictionary.'''\n\n    res = {}\n    for key, value in _readmodule(module, path or []).items():\n        if isinstance(value, Class):\n            res[key] = value\n    return res", "response": "Backwards compatible interface.\n    Call readmodule_ex and then only keep Class objects from the\n    resulting dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _readmodule(module, path, inpackage=None):\n    '''Do the hard work for readmodule[_ex].\n\n    If INPACKAGE is given, it must be the dotted name of the package in\n    which we are searching for a submodule, and then PATH must be the\n    package search path; otherwise, we are searching for a top-level\n    module, and PATH is combined with sys.path.\n    '''\n    # Compute the full module name (prepending inpackage if set)\n    if inpackage is not None:\n        fullmodule = \"%s.%s\" % (inpackage, module)\n    else:\n        fullmodule = module\n\n    # Check in the cache\n    if fullmodule in _modules:\n        return _modules[fullmodule]\n\n    # Initialize the dict for this module's contents\n    dict = OrderedDict()\n\n    # Check if it is a built-in module; we don't do much for these\n    if module in sys.builtin_module_names and inpackage is None:\n        _modules[module] = dict\n        return dict\n\n    # Check for a dotted module name\n    i = module.rfind('.')\n    if i >= 0:\n        package = module[:i]\n        submodule = module[i + 1:]\n        parent = _readmodule(package, path, inpackage)\n        if inpackage is not None:\n            package = \"%s.%s\" % (inpackage, package)\n        return _readmodule(submodule, parent['__path__'], package)\n\n    # Search the path for the module\n    f = None\n    if inpackage is not None:\n        f, fname, (_s, _m, ty) = imp.find_module(module, path)\n    else:\n        f, fname, (_s, _m, ty) = imp.find_module(module, path + sys.path)\n    if ty == imp.PKG_DIRECTORY:\n        dict['__path__'] = [fname]\n        path = [fname] + path\n        f, fname, (_s, _m, ty) = imp.find_module('__init__', [fname])\n    _modules[fullmodule] = dict\n    if ty != imp.PY_SOURCE:\n        # not Python source, can't do anything with this module\n        f.close()\n        return dict\n\n    stack = []  # stack of (class, indent) pairs\n\n    g = tokenize.generate_tokens(f.readline)\n    try:\n        for tokentype, token, start, _end, _line in g:\n            if tokentype == DEDENT:\n                lineno, thisindent = start\n                # close nested classes and defs\n                while stack and stack[-1][1] >= thisindent:\n                    del stack[-1]\n            elif token == 'def':\n                lineno, thisindent = start\n                # close previous nested classes and defs\n                while stack and stack[-1][1] >= thisindent:\n                    del stack[-1]\n                tokentype, meth_name, start = g.next()[0:3]\n                if tokentype != NAME:\n                    continue  # Syntax error\n                if stack:\n                    cur_class = stack[-1][0]\n                    if isinstance(cur_class, Class):\n                        # it's a method\n                        cur_class._addmethod(meth_name, lineno)\n                        # else it's a nested def\n                else:\n                    # it's a function\n                    dict[meth_name] = Function(fullmodule, meth_name,\n                                               fname, lineno)\n                stack.append((None, thisindent))  # Marker for nested fns\n            elif token == 'class':\n                lineno, thisindent = start\n                # close previous nested classes and defs\n                while stack and stack[-1][1] >= thisindent:\n                    del stack[-1]\n                tokentype, class_name, start = g.next()[0:3]\n                if tokentype != NAME:\n                    continue  # Syntax error\n                # parse what follows the class name\n                tokentype, token, start = g.next()[0:3]\n                inherit = None\n                if token == '(':\n                    names = []  # List of superclasses\n                    # there's a list of superclasses\n                    level = 1\n                    super = []  # Tokens making up current superclass\n                    while True:\n                        tokentype, token, start = g.next()[0:3]\n                        if token in (')', ',') and level == 1:\n                            n = \"\".join(super)\n                            if n in dict:\n                                # we know this super class\n                                n = dict[n]\n                            else:\n                                c = n.split('.')\n                                if len(c) > 1:\n                                    # super class is of the form\n                                    # module.class: look in module for\n                                    # class\n                                    m = c[-2]\n                                    c = c[-1]\n                                    if m in _modules:\n                                        d = _modules[m]\n                                        if c in d:\n                                            n = d[c]\n                            names.append(n)\n                            super = []\n                        if token == '(':\n                            level += 1\n                        elif token == ')':\n                            level -= 1\n                            if level == 0:\n                                break\n                        elif token == ',' and level == 1:\n                            pass\n                        # only use NAME and OP (== dot) tokens for type name\n                        elif tokentype in (NAME, OP) and level == 1:\n                            super.append(token)\n                            # expressions in the base list are not supported\n                    inherit = names\n                cur_class = Class(fullmodule, class_name, inherit,\n                                  fname, lineno)\n                if not stack:\n                    dict[class_name] = cur_class\n                stack.append((cur_class, thisindent))\n            elif token == 'import' and start[1] == 0:\n                modules = _getnamelist(g)\n                for mod, _mod2 in modules:\n                    try:\n                        # Recursively read the imported module\n                        if inpackage is None:\n                            _readmodule(mod, path)\n                        else:\n                            try:\n                                _readmodule(mod, path, inpackage)\n                            except ImportError:\n                                _readmodule(mod, [])\n                    except:\n                        # If we can't find or parse the imported module,\n                        # too bad -- don't die here.\n                        pass\n            elif token == 'from' and start[1] == 0:\n                mod, token = _getname(g)\n                if not mod or token != \"import\":\n                    continue\n                names = _getnamelist(g)\n                try:\n                    # Recursively read the imported module\n                    d = _readmodule(mod, path, inpackage)\n                except:\n                    # If we can't find or parse the imported module,\n                    # too bad -- don't die here.\n                    continue\n                # add any classes that were defined in the imported module\n                # to our name space if they were mentioned in the list\n                for n, n2 in names:\n                    if n in d:\n                        dict[n2 or n] = d[n]\n                    elif n == '*':\n                        # don't add names that start with _\n                        for n in d:\n                            if n[0] != '_':\n                                dict[n] = d[n]\n            elif tokentype == NAME and start[1] == 0:\n                name = token\n                line = _line\n                tokentype, token = g.next()[0:2]\n                if tokentype == OP and token == \"=\":\n                    dict[name] = Global(fullmodule, name, fname, _line)\n    except StopIteration:\n        pass\n\n    f.close()\n    return dict", "response": "Read a module and return a dictionary of the contents of that module."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a valid access token.", "response": "def access_token(self):\n        \"\"\"\n        **access_token**\n\n        Returns a valid access token.  If the user is not currently logged in, attempts to do so.\n        If the current time exceeds the grace period, attempts to retrieve a new access token.\n\n        Input:\n            * None\n\n        Output:\n            * A valid access token\n\n        Example::\n\n            print \"Your access token is currently %s\" % client.user.access_token()\n        \"\"\"\n        if not self._access_token:\n            self.login()\n\n        if time() > (self.access_token_expires - self.access_token_grace):\n            self.login({\"refreshtoken\": self.refresh_token})\n\n        return self._access_token"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrefresh the user object with data from the Gett service.", "response": "def refresh(self):\n        \"\"\"\n        **refresh**\n\n        Refresh this user object with data from the Gett service\n\n        Input:\n            * None\n\n        Output:\n            * ``True``\n\n        Example::\n\n            if client.user.refresh():\n                print \"User data refreshed!\"\n                print \"You have %s bytes of storage remaining.\" % ( client.user.storage_limit - client_user.storage_used )\n\n        \"\"\"\n        response = GettRequest().get(\"/users/me?accesstoken=%s\" % self.access_token())\n\n        if response.http_status == 200:\n            self.userid = response.response['userid']\n            self.fullname = response.response['fullname']\n            self.storage_used = response.response['storage']['used']\n            self.storage_limit = response.response['storage']['limit']\n\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _basic_field_data(field, obj):\n    value = field.value_from_object(obj)\n    return {Field.TYPE: FieldType.VAL, Field.VALUE: value}", "response": "Returns obj. field data as a dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a dict containing related pk info and some meta information for reconstructing objects.", "response": "def _related_field_data(field, obj):\n    \"\"\"Returns relation ``field`` as a dict.\n\n    Dict contains related pk info and some meta information\n    for reconstructing objects.\n    \"\"\"\n    data = _basic_field_data(field, obj)\n    relation_info = {\n        Field.REL_DB_TABLE: field.rel.to._meta.db_table,\n        Field.REL_APP: field.rel.to._meta.app_label,\n        Field.REL_MODEL: field.rel.to.__name__\n    }\n    data[Field.TYPE] = FieldType.REL\n    data[Field.REL] = relation_info\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _m2m_field_data(field, obj):\n    data = _basic_field_data(field, obj)\n    data[Field.TYPE] = FieldType.M2M\n    related = field.rel.to\n    relation_info = {\n        Field.REL_DB_TABLE: related._meta.db_table,\n        Field.REL_APP: related._meta.app_label,\n        Field.REL_MODEL: related.__name__\n    }\n    data[Field.REL] = relation_info\n    value = data[Field.VALUE]\n    value = [x[0] for x in value.values_list('pk')]\n    data[Field.VALUE] = value\n    return data", "response": "Returns m2m field as a dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dump_model(obj):\n    data = {}\n    for field in obj._meta.fields:\n        if isinstance(field, RELATED_FIELDS):\n            field_data = _related_field_data(field, obj)\n        else:\n            field_data = _basic_field_data(field, obj)\n        data[field.name] = field_data\n\n    if obj.pk:\n        for m2m in obj._meta.many_to_many:\n            field_data = _m2m_field_data(m2m, obj)\n            data[m2m.name] = field_data\n\n    return data", "response": "Dump the object obj as a dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning instance of cls with attributed loaded from data dict.", "response": "def restore_model(cls, data):\n    \"\"\"Returns instance of ``cls`` with attributed loaded\n    from ``data`` dict.\n    \"\"\"\n    obj = cls()\n    for field in data:\n        setattr(obj, field, data[field][Field.VALUE])\n\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving an object from Redis using a pipeline.", "response": "def retrieve_object(cache, template, indexes):\n    \"\"\"Retrieve an object from Redis using a pipeline.\n\n    Arguments:\n        template: a dictionary containg the keys for the object and\n            template strings for the corresponding redis keys. The template\n            string uses named string interpolation format. Example:\n\n            {\n                'username': 'user:$(id)s:username',\n                'email': 'user:$(id)s:email',\n                'phone': 'user:$(id)s:phone'\n            }\n\n        indexes: a dictionary containing the values to use to cosntruct the\n            redis keys: Example:\n\n            {\n                'id': 342\n            }\n\n    Returns: a dictionary with the same keys as template, but containing\n        the values retrieved from redis, if all the values are retrieved.\n        If any value is missing, returns None. Example:\n\n        {\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'phone': '555-555-5555'\n        }\n\n    \"\"\"\n    keys = []\n    with cache as redis_connection:\n        pipe = redis_connection.pipeline()\n        for (result_key, redis_key_template) in template.items():\n            keys.append(result_key)\n            pipe.get(redis_key_template % indexes)\n        results = pipe.execute()\n    return None if None in results else dict(zip(keys, results))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_object(cache, template, indexes, data):\n    # TODO(mattmillr): Handle expiration times\n    with cache as redis_connection:\n        pipe = redis_connection.pipeline()\n        for key in set(template.keys()) & set(data.keys()):\n            pipe.set(template[key] % indexes, str(data[key]))\n        pipe.execute()", "response": "Set an object in Redis using a pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_object(cache, template, indexes):\n    with cache as redis_connection:\n        pipe = redis_connection.pipeline()\n        for key in set(template.keys()):\n            pipe.delete(template[key] % indexes)\n        pipe.execute()", "response": "Delete an object in Redis using a pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_value(cache, key, value):\n    with cache as redis_connection:\n        return redis_connection.set(key, value)", "response": "Set a value by key."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds a subfolder in the given directory that contains a Freesurfer anatomy.", "response": "def get_freesurfer_dir(directory):\n    \"\"\"Find a subfolder in the given directory that contains a Freesurfer\n    anatomy (this may be the directory itself). Currently, the test is whether\n    there are sub-folders with name 'surf' and 'mri'. Processes all sub-folders\n    recursively until a freesurfer directory is found. If no matching folder is\n    found the result is None.\n\n    Parameters\n    ----------\n    directory : string\n        Directory on local disk containing unpacked files\n\n    Returns\n    -------\n    string\n        Sub-directory containing a Freesurfer files or None if no such\n        directory is found.\n    \"\"\"\n    dir_files = [f for f in os.listdir(directory)]\n    # Look for sub-folders 'surf' and 'mri'\n    if 'surf' in dir_files and 'mri' in dir_files:\n        return directory\n    # Directory is not a valid freesurfer directory. Continue to search\n    # recursively until a matching directory is found.\n    for f in os.listdir(directory):\n        sub_dir = os.path.join(directory, f)\n        if os.path.isdir(sub_dir):\n            if get_freesurfer_dir(sub_dir):\n                return sub_dir\n    # The given directory does not contain a freesurfer anatomy directory\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new subject at given SCO - API by uploading a local file.", "response": "def create(url, filename, properties):\n        \"\"\"Create new subject at given SCO-API by uploading local file.\n        Expects an tar-archive containing FreeSurfer archive file. Allows to\n        update properties of created resource.\n\n        Parameters\n        ----------\n        url : string\n            Url to POST image group create request\n        filename : string\n            Path to tar-archive on local disk\n        properties : Dictionary\n            Set of additional properties for subject (may be None)\n\n        Returns\n        -------\n        string\n            Url of created subject resource\n        \"\"\"\n        # Ensure that the file has valid suffix\n        if not has_tar_suffix(filename):\n            raise ValueError('invalid file suffix: ' + filename)\n        # Upload file to create subject. If response is not 201 the uploaded\n        # file is not a valid FreeSurfer archive\n        files = {'file': open(filename, 'rb')}\n        response = requests.post(url, files=files)\n        if response.status_code != 201:\n            raise ValueError('invalid file: ' + filename)\n        # Get image group HATEOAS references from successful response\n        links = references_to_dict(response.json()['links'])\n        resource_url = links[REF_SELF]\n        # Update subject properties if given\n        if not properties is None:\n            obj_props = []\n            # Catch TypeErrors if properties is not a list.\n            try:\n                for key in properties:\n                    obj_props.append({'key':key, 'value':properties[key]})\n            except TypeError as ex:\n                raise ValueError('invalid property set')\n            try:\n                req = urllib2.Request(links[REF_UPSERT_PROPERTIES])\n                req.add_header('Content-Type', 'application/json')\n                response = urllib2.urlopen(\n                    req,\n                    json.dumps({'properties' : obj_props})\n                )\n            except urllib2.URLError as ex:\n                raise ValueError(str(ex))\n        return resource_url"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getdata(inputfile, argnum=None, close=False):\n    # get data and converts them to list\n    # outputtype - list, dict, all\n    output = []\n    add_data = {}\n    line_num = 0\n    for line in inputfile:\n        line_num += 1\n        if (\"#\" not in line) and (line != \"\"):\n            linesplit = line.split()\n            if argnum is not None and len(linesplit) != int(argnum):\n                raise ValueError(\n                    \"Line {:d} has {:d} arguments (need {:d})\".format(\n                        line_num, len(linesplit), argnum))\n            output.append(linesplit)\n        # additional float variable\n        if \"#f\" in line:\n            data = line.split()[1].split(\"=\")\n            add_data[data[0]] = float(data[1])\n        # additional list float variable\n        if \"#l\" in line:\n            data = line.split()[1].split(\"=\")\n            add_data[data[0]] = [float(e) for e in data[1].split(\",\")]\n    if close:\n        inputfile.close()\n    output = cleandata(output)\n    return {\n        \"data\": np.array(output),\n        \"variables\": add_data,\n    }", "response": "Get data from the. dat files\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cleandata(inputlist):\n    output = []\n    for e in inputlist:\n        new = []\n        for f in e:\n            if f == \"--\":\n                new.append(None)\n            else:\n                new.append(float(f))\n        output.append(new)\n    return output", "response": "Helper function for parse. getData.\n    Removes empty variables convert strings to float"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef install_supervisor(self, update=False):\n        script = supervisor.Recipe(\n            self.buildout,\n            self.name,\n            {'user': self.options.get('user'),\n             'program': self.options.get('program'),\n             'command': templ_cmd.render(config=self.conf_filename, prefix=self.prefix),\n             'stopwaitsecs': '30',\n             'killasgroup': 'true',\n             })\n        return script.install(update)", "response": "install supervisor config for redis\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat a value accoding to its type.", "response": "def _format(val, valtype, floatfmt, missingval=\"\", has_invisible=True):\n    \"\"\"Format a value accoding to its type.\n\n    Unicode is supported:\n\n    >>> hrow = ['\\u0431\\u0443\\u043a\\u0432\\u0430', '\\u0446\\u0438\\u0444\\u0440\\u0430'] ; \\\n        tbl = [['\\u0430\\u0437', 2], ['\\u0431\\u0443\\u043a\\u0438', 4]] ; \\\n        good_result = '\\\\u0431\\\\u0443\\\\u043a\\\\u0432\\\\u0430      \\\\u0446\\\\u0438\\\\u0444\\\\u0440\\\\u0430\\\\n-------  -------\\\\n\\\\u0430\\\\u0437             2\\\\n\\\\u0431\\\\u0443\\\\u043a\\\\u0438           4' ; \\\n        tabulate(tbl, headers=hrow) == good_result\n    True\n\n    \"\"\"\n    if val is None:\n        return missingval\n\n    if valtype in [int, _long_type, _text_type]:\n        return \"{0}\".format(val)\n    elif valtype is _binary_type:\n        try:\n            return _text_type(val, \"ascii\")\n        except TypeError:\n            return _text_type(val)\n    elif valtype is float:\n        is_a_colored_number = has_invisible and isinstance(val, (_text_type, _binary_type))\n        if is_a_colored_number:\n            raw_val = _strip_invisible(val)\n            formatted_val = format(float(raw_val), floatfmt)\n            return val.replace(raw_val, formatted_val)\n        else:\n            return format(float(val), floatfmt)\n    else:\n        return \"{0}\".format(val)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _main():\n    import getopt\n    import sys\n    import textwrap\n    usage = textwrap.dedent(_main.__doc__)\n    try:\n        opts, args = getopt.getopt(sys.argv[1:],\n                     \"h1o:s:F:f:\",\n                     [\"help\", \"header\", \"output\", \"sep=\", \"float=\", \"format=\"])\n    except getopt.GetoptError as e:\n        print(e)\n        print(usage)\n        sys.exit(2)\n    headers = []\n    floatfmt = \"g\"\n    tablefmt = \"simple\"\n    sep = r\"\\s+\"\n    outfile = \"-\"\n    for opt, value in opts:\n        if opt in [\"-1\", \"--header\"]:\n            headers = \"firstrow\"\n        elif opt in [\"-o\", \"--output\"]:\n            outfile = value\n        elif opt in [\"-F\", \"--float\"]:\n            floatfmt = value\n        elif opt in [\"-f\", \"--format\"]:\n            if value not in tabulate_formats:\n                print(\"%s is not a supported table format\" % value)\n                print(usage)\n                sys.exit(3)\n            tablefmt = value\n        elif opt in [\"-s\", \"--sep\"]:\n            sep = value\n        elif opt in [\"-h\", \"--help\"]:\n            print(usage)\n            sys.exit(0)\n    files = [sys.stdin] if not args else args\n    with (sys.stdout if outfile == \"-\" else open(outfile, \"w\")) as out:\n        for f in files:\n            if f == \"-\":\n                f = sys.stdin\n            if _is_file(f):\n                _pprint_file(f, headers=headers, tablefmt=tablefmt,\n                             sep=sep, floatfmt=floatfmt, file=out)\n            else:\n                with open(f) as fobj:\n                    _pprint_file(fobj, headers=headers, tablefmt=tablefmt,\n                                 sep=sep, floatfmt=floatfmt, file=out)", "response": "Main function for the tabulate command line interface."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the model to use in the filter_class by inspecting the queryset or using a declared auto_filters_model field.", "response": "def get_view_model(cls):\n    \"\"\"\n    Get the model to use in the filter_class by inspecting\n    the queryset or by using a declared auto_filters_model\n    \"\"\"\n    msg = 'When using get_queryset you must set a auto_filters_model field in the viewset'\n    if cls.queryset is not None:\n        return cls.queryset.model\n    else:\n        assert hasattr(cls, 'auto_filters_model'), msg\n        return cls.auto_filters_model"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef auto_filters(cls):\n    msg = 'Viewset must have auto_filters_fields or auto_filters_exclude attribute when using auto_filters decorator'\n    if not hasattr(cls, 'auto_filters_fields') and not hasattr(cls, 'auto_filters_exclude'):\n        raise AssertionError(msg)\n    dict_ = {}\n\n    view_model = get_view_model(cls)\n    auto_filters_fields = get_auto_filters_fields(cls, view_model)\n\n    for auto_filter in auto_filters_fields:\n        dict_[auto_filter] = AutoFilters(name=auto_filter)\n\n    # create the inner Meta class and then the filter class\n    dict_['Meta'] = type('Meta', (object, ), {'model': view_model, 'fields': ()})\n    filter_class = type('DynamicFilterClass', (FilterSet, ), dict_)\n    cls.filter_class = filter_class\n    return cls", "response": "Decorator to add dynamic filters to a viewset"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef env(*_vars, **kwargs):\n    for v in _vars:\n        value = os.environ.get(v, None)\n        if value:\n            return value\n    return kwargs.get('default', '')", "response": "Search for the first environment variable defined in _vars or return the default if no environment variable is defined in kwargs."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_option_parser(self, description, version):\n        parser = argparse.ArgumentParser(\n            description=description,\n            add_help=False, )\n        parser.add_argument(\n            '--version',\n            action='version',\n            version=__version__, )\n        parser.add_argument(\n            '-v', '--verbose', '--debug',\n            action='count',\n            dest='verbose_level',\n            default=self.DEFAULT_VERBOSE_LEVEL,\n            help=_('Increase verbosity of output and show tracebacks on'\n                   ' errors. You can repeat this option.'))\n        parser.add_argument(\n            '-q', '--quiet',\n            action='store_const',\n            dest='verbose_level',\n            const=0,\n            help=_('Suppress output except warnings and errors.'))\n        parser.add_argument(\n            '-h', '--help',\n            action=HelpAction,\n            nargs=0,\n            default=self,  # tricky\n            help=_(\"Show this help message and exit.\"))\n        parser.add_argument(\n            '-r', '--retries',\n            metavar=\"NUM\",\n            type=check_non_negative_int,\n            default=0,\n            help=_(\"How many times the request to the Neutron server should \"\n                   \"be retried if it fails.\"))\n        # FIXME(bklei): this method should come from keystoneauth1\n        self._append_global_identity_args(parser)\n\n        return parser", "response": "Build an argument parser for this application."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _bash_completion(self):\n        commands = set()\n        options = set()\n        for option, _action in self.parser._option_string_actions.items():\n            options.add(option)\n        for _name, _command in self.command_manager:\n            commands.add(_name)\n            cmd_factory = _command.load()\n            cmd = cmd_factory(self, None)\n            cmd_parser = cmd.get_parser('')\n            for option, _action in cmd_parser._option_string_actions.items():\n                options.add(option)\n        print(' '.join(commands | options))", "response": "Prints all of the commands and options for bash - completion."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconfirms user has provided all of the authentication info we need.", "response": "def authenticate_user(self):\n        \"\"\"Confirm user authentication\n\n        Make sure the user has provided all of the authentication\n        info we need.\n        \"\"\"\n        cloud_config = os_client_config.OpenStackConfig().get_one_cloud(\n            cloud=self.options.os_cloud, argparse=self.options,\n            network_api_version=self.api_version,\n            verify=not self.options.insecure)\n        verify, cert = cloud_config.get_requests_verify_args()\n\n        # TODO(singhj): Remove dependancy on HTTPClient\n        # for the case of token-endpoint authentication\n\n        # When using token-endpoint authentication legacy\n        # HTTPClient will be used, otherwise SessionClient\n        # will be used.\n        if self.options.os_token and self.options.os_url:\n            auth = None\n            auth_session = None\n        else:\n            auth = cloud_config.get_auth()\n\n            auth_session = session.Session(\n                auth=auth, verify=verify, cert=cert,\n                timeout=self.options.http_timeout)\n\n        interface = self.options.os_endpoint_type or self.endpoint_type\n        if interface.endswith('URL'):\n            interface = interface[:-3]\n        self.client_manager = clientmanager.ClientManager(\n            retries=self.options.retries,\n            raise_errors=False,\n            session=auth_session,\n            url=self.options.os_url,\n            token=self.options.os_token,\n            region_name=cloud_config.get_region_name(),\n            api_version=cloud_config.get_api_version('network'),\n            service_type=cloud_config.get_service_type('network'),\n            service_name=cloud_config.get_service_name('network'),\n            endpoint_type=interface,\n            auth=auth,\n            insecure=not verify,\n            log_credentials=True)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef configure_logging(self):\n        root_logger = logging.getLogger('')\n\n        # Set up logging to a file\n        root_logger.setLevel(logging.DEBUG)\n\n        # Send higher-level messages to the console via stderr\n        console = logging.StreamHandler(self.stderr)\n        console_level = {self.WARNING_LEVEL: logging.WARNING,\n                         self.INFO_LEVEL: logging.INFO,\n                         self.DEBUG_LEVEL: logging.DEBUG,\n                         }.get(self.options.verbose_level, logging.DEBUG)\n        # The default log level is INFO, in this situation, set the\n        # log level of the console to WARNING, to avoid displaying\n        # useless messages. This equals using \"--quiet\"\n        if console_level == logging.INFO:\n            console.setLevel(logging.WARNING)\n        else:\n            console.setLevel(console_level)\n        if logging.DEBUG == console_level:\n            formatter = logging.Formatter(self.DEBUG_MESSAGE_FORMAT)\n        else:\n            formatter = logging.Formatter(self.CONSOLE_MESSAGE_FORMAT)\n        logging.getLogger('iso8601.iso8601').setLevel(logging.WARNING)\n        logging.getLogger('urllib3.connectionpool').setLevel(logging.WARNING)\n        console.setFormatter(formatter)\n        root_logger.addHandler(console)\n        return", "response": "Configure logging for any log output."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef max_substring(words, position=0, _last_letter=''):\n\n    # If end of word is reached, begin reconstructing the substring\n    try:\n        letter = [word[position] for word in words]\n    except IndexError:\n        return _last_letter\n\n    # Recurse if position matches, else begin reconstructing the substring\n    if all(l == letter[0] for l in letter) is True:\n        _last_letter += max_substring(words, position=position + 1,\n                                      _last_letter=letter[0])\n        return _last_letter\n    else:\n        return _last_letter", "response": "Finds the max substring shared by all strings starting at position"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nactivating the containment container", "response": "def activate():\n    \"\"\"\n    Usage:\n      containment activate\n    \"\"\"\n    # This is derived from the clone\n    cli = CommandLineInterface()\n    cli.ensure_config()\n    cli.write_dockerfile()\n    cli.build()\n    cli.run()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\napplies f to the results of the given generator.", "response": "def _map_generator(f, generator):\n    \"\"\"Apply ``f`` to the results of the given bi-directional generator.\n\n    Unfortunately, generator comprehension (``f(x) for x in gen``) does not\n    work for as expected for bi-directional generators. It won't send\n    exceptions and results back.\n\n    This function implements a map function for generators that sends values\n    and exceptions back and forth as expected.\n    \"\"\"\n    item = next(generator)\n    while True:\n        try:\n            result = yield f(item)\n        except Exception:\n            item = generator.throw(*sys.exc_info())\n        else:\n            item = generator.send(result)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef gen(function, io_loop=None):\n\n    @functools.wraps(function)  # TODO: use wrapt instead?\n    def new_function(*args, **kwargs):\n        try:\n            value = function(*args, **kwargs)\n        except _RETURNS as result:\n            return SimpleAction(\n                lambda ctx: ctx.value,\n                lambda _: None,\n                result,\n            )\n        else:\n            if isinstance(value, types.GeneratorType):\n                return _TornadoGeneratorAction(value, io_loop)\n            else:\n                return SimpleAction(\n                    lambda _: value,\n                    lambda _: None,\n                    None,\n                )\n\n    return new_function", "response": "A generator that returns a list of actions that can be executed in parallel."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compile_markdown_file(source_file):\n  '''Compiles a single markdown file to a remark.js slideshow.'''\n  template = pkg_resources.resource_string('md2remark.resources.templates', 'slideshow.mustache')\n\n  renderer = pystache.Renderer(search_dirs='./templates')\n\n  f = open(source_file, 'r')\n  slideshow_md = f.read()\n  f.close()\n  slideshow_name = os.path.split(source_file)[1].split('.')[0]\n\n  rendered_text = renderer.render(template, {'title': slideshow_name, 'slideshow': slideshow_md})  \n\n  if not os.path.exists('md2remark_build'):\n    os.makedirs('md2remark_build')\n  \n  f = open(os.path.join('md2remark_build', slideshow_name + '.html'), 'w')\n  f.write(rendered_text)\n  f.close()", "response": "Compiles a single markdown file to a remark. js slideshow."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compile_slides(source):\n  '''Compiles the source to a remark.js slideshow.'''\n  # if it's a directory, do all md files.\n  if os.path.isdir(source):\n    for f in os.listdir(source):\n      if f.lower().endswith('.md'):\n        compile_markdown_file(os.path.join(source, f))\n  else:\n    compile_markdown_file(source)", "response": "Compiles the source to a remark. js slideshow."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the command line arguments", "response": "def parse_cl_args(arg_vector):\n  '''Parses the command line arguments'''\n  parser = argparse.ArgumentParser(description='Compiles markdown files into html files for remark.js')\n  parser.add_argument('source', metavar='source', help='the source to compile. If a directory is provided, all markdown files in that directory are compiled. Output is saved in the current working directory under a md2remark_build subdirectory.')\n\n  return parser.parse_args(arg_vector)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconstructing a SQL query that includes all groups that would have been added to the outer join of the current object.", "response": "def to_outer_join_sql(self, orig_where = []):\n    \"\"\"\n    Construct a SQL query that includes all groups that would have\n    existed (exists in the orig_where clause) if the WHERE clause were not present\n    \"\"\"\n    if not self.group:\n      return str(self)\n\n    select = str(self.select)\n    fr = ','.join(self.fr)\n    filter_q = \"SELECT * FROM %s\" % fr\n    if self.where:\n      filter_q += \" WHERE %s\" % self.wherestr\n\n    select_clause = self.select.coalesced_str()\n    groupby = ','.join(list(self.group))\n    if self.order:\n      orderby = ','.join(list(self.order))\n    else:\n      orderby = groupby\n\n    if orig_where:\n      orig_where = self.__wherestr__(orig_where)\n      orig_where = ' WHERE %s' % orig_where\n    else:\n      orig_where = ''\n\n    sql = \"\"\"with bar as (%s)\n    select %s\n    from \n      ((select distinct %s from %s %s) as foo\n        left outer join  \n      bar using (%s)) \n    GROUP BY %s\n    ORDER BY %s;\"\"\" % (filter_q, select_clause, groupby, fr, orig_where, groupby, groupby, orderby)\n    print sql\n    return sql\n\n    \"\"\"\n    with right as (select * from lqm where WHERECLAUSE)\n    select coalesce(sum(total_cost), 0), ccm_payor \n    from \n      ((select distinct ccm_payor from lqm) as payors \n        left outer join  \n      right using (ccm_payor)) \n    GROUP BY ccm_payor;\n    \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a copy of this Query object with additional where clauses for the keys in the argument", "response": "def get_filter_qobj(self, keys=None):\n    \"\"\"\n    Return a copy of this Query object with additional where clauses for the \n    keys in the argument\n    \"\"\"\n    # only care about columns in aggregates right?\n    cols = set()\n    for agg in self.select.aggregates:\n        cols.update(agg.cols)\n    sels = [SelectExpr(col, [col], col, None) for col in cols]\n    select = Select(sels)\n    where = list(self.where)\n    if keys:\n      keys = list(keys)\n      keys = map(sqlize, list(keys))\n      expr = self.select.nonaggs[0].expr\n\n      clause = []\n      if None in keys:\n        clause.append(\"%s is null\" % expr)\n      if len([k for k in keys if k is not None]) > 0:\n        clause.append(\"%s in %%s\" % expr)\n      clause = \" or \".join(clause)\n      where.append(clause)\n    else:\n      where.append( '%s = %%s' % (self.select.nonaggs[0].expr ) )\n    q = Query(self.db, select, self.fr, where)\n    return q"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the total build duration for a specific build chain run", "response": "def total_build_duration_for_chain(self, build_chain_id):\n        \"\"\"Returns the total duration for one specific build chain run\"\"\"\n        return sum([\n            int(self.__build_duration_for_id(id))\n            for id in self.__build_ids_of_chain(build_chain_id)\n        ])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_cycle_time(self, build_id):\n        json_form = self.__retrieve_as_json(self.builds_path % build_id)\n        return BuildCycleTime(\n            build_id,\n            json_form[u'buildTypeId'],\n            as_date(json_form, u'startDate'),\n            (as_date(json_form, u'finishDate') - as_date(json_form, u'queuedDate')).seconds * 1000\n        )", "response": "Returns a BuildCycleTime object for the given build"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_stats_for_chain(self, build_chain_id):\n        json_form = self.__retrieve_as_json(self.build_chain_path % build_chain_id)\n        builds = [{'build_id': build[u'id'], 'configuration_id': build[u'buildTypeId']} for build in json_form[u'build']]\n\n        return [\n            BuildStat(\n                build['build_id'],\n                build['configuration_id'],\n                self.__build_duration_for_id(build['build_id']),\n                self.__build_start_date_for_id(build['build_id']))\n            for build in builds\n        ]", "response": "Returns a list of BuildStat objects for all elements in the build chain."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef quadratic_2d(data):\n    arg_data_max = np.argmax(data)\n    i, j = np.unravel_index(arg_data_max, data.shape)\n    z_ = data[i-1:i+2, j-1:j+2]\n    # our quadratic function is defined as\n    # f(x, y | a, b, c, d, e, f) := a + b * x + c * y + d * x^2 + e * xy + f * y^2\n    # therefore, the best fit coeffiecients are given as\n    # note that they are unique and the uncertainty in each of them (#TODO) can be\n    # computed following the derivations done by Vakili & Hogg (2016) and\n    # Teague & Foreman-Mackey (2018)\n    try:\n        a = (-z_[0,0] + 2*z_[0,1] - z_[0,2] + 2*z_[1,0] + 5*z_[1,1] + 2*z_[1,2] -\n             z_[2,0] + 2*z_[2,1] - z_[2,2]) / 9\n        b = (-z_[0,0] - z_[0,1] - z_[0,2] + z_[2,0] + z_[2,1] + z_[2,2]) / 6\n        c = (-z_[0,0] + z_[0,2] - z_[1,0] + z_[1,2] - z_[2,0] + z_[2,2]) / 6\n        d = (z_[0,0] + z_[0,1] + z_[0,2] - z_[1,0]*2 - z_[1,1]*2 - z_[1,2]*2 +\n             z_[2,0] + z_[2,1] + z_[2,2])/6\n        e = (z_[0,0] - z_[0,2] - z_[2,0] + z_[2,2]) * .25\n        f = (z_[0,0] - 2 * z_[0,1] + z_[0,2] + z_[1,0] - 2 * z_[1,1] + z_[1,2] +\n             z_[2,0] - 2 * z_[2,1] + z_[2,2]) / 6\n    except IndexError:\n        return (i, j)\n\n    # see https://en.wikipedia.org/wiki/Quadratic_function\n    det = 4 * d * f - e ** 2\n    xm = - (2 * f * b - c * e) / det\n    ym = - (2 * d * c - b * e) / det\n    return (i+xm, j+ym)", "response": "Compute the quadratic estimate of the centroid in a 2d array."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a function that returns the dependencies of the instance definition by its name where insts is a dict of instance definitions.", "response": "def depsOf_of_mirteFile_instance_definition(man, insts):\n    \"\"\" Returns a function that returns the dependencies of\n        an instance definition by its name, where insts is a\n        dictionary of instance definitions from a mirteFile \"\"\"\n    return lambda x: [a[1] for a in six.iteritems(insts[x])\n                      if a[0] in [dn for dn, d in (\n                          six.iteritems(man.modules[insts[x]['module']].deps)\n                          if 'module' in insts[x] else [])]]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef depsOf_of_mirteFile_module_definition(defs):\n    return lambda x: (list(filter(lambda z: z is not None and z in defs,\n                             map(lambda y: y[1].get('type'),\n                                 six.iteritems(defs[x]['settings'])\n                                 if 'settings' in defs[x] else [])))) + \\\n        (list(defs[x]['inherits']) if 'inherits' in defs[x] else [])", "response": "Returns a function that returns the dependencies of a module\n        definition by its name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef module_definition_from_mirteFile_dict(man, d):\n    m = ModuleDefinition()\n    if 'inherits' not in d:\n        d['inherits'] = list()\n    if 'settings' not in d:\n        d['settings'] = dict()\n    if 'implementedBy' in d:\n        m.implementedBy = d['implementedBy']\n    m.inherits = set(d['inherits'])\n    for p in d['inherits']:\n        if p not in man.modules:\n            raise ValueError(\"No such module %s\" % p)\n        m.deps.update(man.modules[p].deps)\n        m.vsettings.update(man.modules[p].vsettings)\n        m.inherits.update(man.modules[p].inherits)\n        m.run = m.run or man.modules[p].run\n    if 'run' in d:\n        m.run = d['run']\n    if len(m.inherits) == 0:\n        m.inherits = set(['module'])\n    for k, v in six.iteritems(d['settings']):\n        if 'type' not in v:\n            if k not in m.vsettings:\n                raise ValueError(\"No such existing vsetting %s\" % k)\n            if 'default' in v:\n                m.vsettings[k] = copy.copy(m.vsettings[k])\n                m.vsettings[k].default = v['default']\n            continue\n        if v['type'] in man.modules:\n            m.deps[k] = DepDefinition(v['type'], v.get('allownull', False))\n        elif v['type'] in man.valueTypes:\n            m.vsettings[k] = VSettingDefinition(\n                v['type'],\n                (man.valueTypes[v['type']](v['default'])\n                 if 'default' in v else None)\n            )\n        else:\n            raise ValueError(\"No such module or valuetype %s\" % v)\n    return m", "response": "Creates a ModuleDefinition instance from the dictionary d."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the mirte - file at path into the manager m.", "response": "def load_mirteFile(path, m, logger=None):\n    \"\"\" Loads the mirte-file at <path> into the manager <m>. \"\"\"\n    l = logging.getLogger('load_mirteFile') if logger is None else logger\n    had = set()\n    for name, path, d in walk_mirteFiles(path, logger):\n        if os.path.realpath(path) in m.loaded_mirteFiles:\n            continue\n        identifier = name\n        if name in had:\n            identifier = path\n        else:\n            had.add(name)\n        l.info('loading %s' % identifier)\n        m.loaded_mirteFiles.add(os.path.realpath(path))\n        _load_mirteFile(d, m)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the dictionary from the mirteFile into the given object.", "response": "def _load_mirteFile(d, m):\n    \"\"\" Loads the dictionary from the mirteFile into <m> \"\"\"\n    defs = d['definitions'] if 'definitions' in d else {}\n    insts = d['instances'] if 'instances' in d else {}\n    # Filter out existing instances\n    insts_to_skip = []\n    for k in insts:\n        if k in m.insts:\n            m.update_instance(k, dict(insts[k]))\n            insts_to_skip.append(k)\n    for k in insts_to_skip:\n        del(insts[k])\n    # Sort module definitions by dependency\n    it = sort_by_successors(\n        six.viewkeys(defs),\n        dual_cover(\n            six.viewkeys(defs),\n            restricted_cover(\n                six.viewkeys(defs),\n                depsOf_of_mirteFile_module_definition(defs)\n            )\n        )\n    )\n    # Add module definitions\n    for k in it:\n        m.add_module_definition(\n            k,\n            module_definition_from_mirteFile_dict(m, defs[k])\n        )\n    # Sort instance declarations by dependency\n    it = sort_by_successors(\n        six.viewkeys(insts),\n        dual_cover(\n            six.viewkeys(insts),\n            restricted_cover(\n                six.viewkeys(insts),\n                depsOf_of_mirteFile_instance_definition(m, insts)\n            )\n        )\n    )\n    # Create instances\n    for k in it:\n        settings = dict(insts[k])\n        del(settings['module'])\n        m.create_instance(k, insts[k]['module'], settings)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nresolving a name to a path. Uses sys. path if no path is given.", "response": "def find_mirteFile(name, extra_path=None):\n    \"\"\" Resolves <name> to a path.  Uses <extra_path> \"\"\"\n    extra_path = () if extra_path is None else extra_path\n    for bp in chain(extra_path, sys.path):\n        pb = os.path.join(bp, name)\n        p = pb + FILE_SUFFIX\n        if os.path.exists(p):\n            return os.path.abspath(p)\n        p = os.path.join(pb, DEFAULT_FILE)\n        if os.path.exists(p):\n            return os.path.abspath(p)\n    raise ValueError(\"Couldn't find mirteFile %s\" % name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield all dependencies of and including the mirte - file at the given path.", "response": "def walk_mirteFiles(name, logger=None):\n    \"\"\" Yields (cpath, d) for all dependencies of and including the\n        mirte-file <name>, where <d> are the dictionaries from\n        the mirte-file at <cpath> \"\"\"\n    stack = [(name, find_mirteFile(name, (os.getcwd(),)))]\n    loadStack = []\n    had = dict()\n    while stack:\n        name, path = stack.pop()\n        if path in had:\n            d = had[path]\n        else:\n            d = _parse_mirteFile(path, logger)\n            had[path] = d\n        loadStack.append((name, path, d))\n        if 'includes' not in d:\n            continue\n        for include in d['includes']:\n            stack.append(\n                (include,\n                 find_mirteFile(include, (os.path.dirname(path),))))\n    had = set()\n    for name, path, d in reversed(loadStack):\n        if path in had:\n            continue\n        had.add(path)\n        yield name, path, d"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_mirteFile(path, logger=None):\n    l = logging.getLogger('_parse_mirteFile') if logger is None else logger\n    cache_path = os.path.join(os.path.dirname(path),\n                              CACHE_FILENAME_TEMPLATE % os.path.basename(path))\n    if (os.path.exists(cache_path) and\n            os.path.getmtime(cache_path) >= os.path.getmtime(path)):\n        with open(cache_path) as f:\n            return msgpack.unpack(f)\n    with open(path) as f:\n        ret = yaml.load(f)\n    try:\n        with open(cache_path, 'w') as f:\n            msgpack.pack(ret, f)\n    except IOError as e:\n        if e.errno == errno.EACCES:\n            l.warn('Not allowed to write %s', path)\n        else:\n            raise\n    return ret", "response": "Open and parses the mirteFile at path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a new word", "response": "def _generate(self, size=None):\n        \"Generates a new word\"\n        corpus_letters = list(self.vectors.keys())\n        current_letter = random.choice(corpus_letters)\n        if size is None:\n            size = int(random.normalvariate(self.avg, self.std_dev))\n\n        letters = [current_letter]\n\n        for _ in range(size):\n            if current_letter not in corpus_letters:\n                # current_letter = random.choice(corpus_letters)\n                break\n            found_letter = self.vectors[current_letter].choose()\n            letters.append(found_letter)\n            current_letter = found_letter\n\n        return ''.join(letters)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints the task information using the environment object.", "response": "def _print_tasks(env, tasks, mark_active=False):\n    \"\"\" Prints task information using io stream.\n\n        `env`\n            ``Environment`` object.\n        `tasks`\n            List of tuples (task_name, options, block_options).\n        `mark_active`\n            Set to ``True`` to mark active task.\n        \"\"\"\n\n    if env.task.active and mark_active:\n        active_task = env.task.name\n    else:\n        active_task = None\n\n    for task, options, blocks in tasks:\n        # print heading\n        invalid = False\n\n        if task == active_task:\n            method = 'success'\n        else:\n            if options is None and blocks is None:\n                method = 'error'\n                invalid = True\n\n            else:\n                method = 'write'\n\n        opts = list(options or [])\n        blks = list(blocks or [])\n\n        write = getattr(env.io, method)\n        write('~' * 80)\n        write(' ' + task)\n        write('~' * 80)\n        env.io.write('')\n\n        # non-block options\n        if opts:\n            for opt, values in opts:\n                env.io.write('    {0}: {1}'.format(opt,\n                             ', '.join(str(v) for v in values)))\n            env.io.write('')\n\n        # block options\n        if blks:\n            had_options = False\n\n            for block, options in blks:\n                if options:\n                    had_options = True\n                    env.io.write('    {{ {0} }}'.format(block))\n\n                    for opt, values in options:\n                        env.io.write('        {0}: {1}'.format(opt,\n                                     ', '.join(str(v) for v in values)))\n                    env.io.write('')\n\n            if not had_options:\n                blks = None\n\n        if not opts and not blks:\n            if invalid:\n                env.io.write('  Invalid task.')\n            else:\n                env.io.write('  Empty task.')\n            env.io.write('')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _edit_task_config(env, task_config, confirm):\n\n    # get editor program\n    if common.IS_MACOSX:\n        def_editor = 'open'\n    else:\n        def_editor = 'vi'\n    editor = os.environ.get('EDITOR', def_editor)\n\n    def _edit_file(filename):\n        \"\"\" Launches editor for given filename.\n            \"\"\"\n        proc = subprocess.Popen('{0} {1}'.format(editor, filename),\n                                shell=True)\n        proc.communicate()\n        if proc.returncode == 0:\n            try:\n                # parse temp configuration file\n                parser_ = parser.parse_config(filename, 'task')\n                registration.run_option_hooks(parser_,\n                                              disable_missing=False)\n\n            except (parser.ParseError, errors.InvalidTaskConfig) as exc:\n                reason = unicode(getattr(exc, 'reason', exc))\n                raise errors.InvalidTaskConfig(task_config, reason=reason)\n\n            return True\n        else:\n            return False\n\n    try:\n        # create temp copy of task config\n        fd, tmpname = tempfile.mkstemp(suffix='.cfg', prefix='focus_')\n        with open(task_config, 'r') as file_:\n            os.write(fd, file_.read())\n            os.close(fd)\n\n        while True:\n            try:\n                # launch editor\n                if not _edit_file(tmpname):\n                    return False\n\n                # overwrite original with temp\n                with open(tmpname, 'r') as temp:\n                    with open(task_config, 'w', 0) as config:\n                        config.write(temp.read())\n\n                return True\n\n            except errors.InvalidTaskConfig as exc:\n                if not confirm:\n                    raise  # reraise\n\n                # prompt to re-edit\n                env.io.error(unicode(exc))\n                while True:\n                    try:\n                        resp = env.io.prompt('Would you like to retry? (y/n) ')\n                        resp = resp.strip().lower()\n                    except KeyboardInterrupt:\n                        return True\n\n                    if resp == 'y':\n                        break\n                    elif resp == 'n':\n                        return True\n\n    except OSError:\n        return False\n    finally:\n        common.safe_remove_file(tmpname)", "response": "Edit task configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstart a new task.", "response": "def execute(self, env, args):\n        \"\"\" Starts a new task.\n\n            `env`\n                Runtime ``Environment`` instance.\n            `args`\n                Arguments object from arg parser.\n            \"\"\"\n\n        # start the task\n        if env.task.start(args.task_name):\n            env.io.success(u'Task Loaded.')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setup_parser(self, parser):\n\n        parser.add_argument('task_name', help='task to create')\n        parser.add_argument('clone_task', nargs='?',\n                            help='existing task to clone')\n        parser.add_argument('--skip-edit', action='store_true',\n                            help='skip editing of task configuration')", "response": "Setup the argument parser."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new task. instance and opens in the task config file in editor.", "response": "def execute(self, env, args):\n        \"\"\" Creates a new task.\n\n            `env`\n                Runtime ``Environment`` instance.\n            `args`\n                Arguments object from arg parser.\n            \"\"\"\n\n        task_name = args.task_name\n        clone_task = args.clone_task\n\n        if not env.task.create(task_name, clone_task):\n            raise errors.FocusError(u'Could not create task \"{0}\"'\n                                    .format(task_name))\n\n        # open in task config in editor\n        if not args.skip_edit:\n            task_config = env.task.get_config_path(task_name)\n\n            if not _edit_task_config(env, task_config, confirm=True):\n                raise errors.FocusError(u'Could not open task config: {0}'\n                                        .format(task_config))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nedit the task configuration.", "response": "def execute(self, env, args):\n        \"\"\" Edits task configuration.\n\n            `env`\n                Runtime ``Environment`` instance.\n            `args`\n                Arguments object from arg parser.\n            \"\"\"\n\n        task_name = args.task_name\n\n        if not env.task.exists(task_name):\n            raise errors.TaskNotFound(task_name)\n\n        if env.task.active and task_name == env.task.name:\n            raise errors.ActiveTask\n\n        # open in task config in editor\n        task_config = env.task.get_config_path(task_name)\n\n        if not _edit_task_config(env, task_config, confirm=True):\n            raise errors.FocusError(u'Could not open task config: {0}'\n                                    .format(task_config))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving a task. from the task.", "response": "def execute(self, env, args):\n        \"\"\" Removes a task.\n\n            `env`\n                Runtime ``Environment`` instance.\n            `args`\n                Arguments object from arg parser.\n            \"\"\"\n\n        # extract args\n        old_task_name = args.old_task_name\n        new_task_name = args.new_task_name\n\n        if old_task_name == new_task_name:\n            raise errors.FocusError(u'Could not rename task to itself')\n\n        if env.task.active and env.task.name == old_task_name:\n            raise errors.ActiveTask\n\n        env.task.rename(old_task_name, new_task_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef execute(self, env, args):\n\n        # extract args\n        task_name = args.task_name\n        force = args.force\n\n        if env.task.active and env.task.name == task_name:\n            raise errors.ActiveTask\n\n        if not env.task.exists(task_name):\n            raise errors.TaskNotFound(task_name)\n\n        if force:\n            env.task.remove(task_name)\n\n        else:\n            try:\n                while True:\n                    prompt = ('Are you sure you want to delete \"{0}\" (y/n)? '\n                              .format(task_name))\n                    resp = env.io.prompt(prompt, newline=False).lower()\n\n                    if resp in ('y', 'n'):\n                        if resp == 'y':\n                            env.task.remove(task_name)\n                        break\n\n            except KeyboardInterrupt:\n                pass", "response": "Remove a task.\n            instance from the task."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlists all valid tasks.", "response": "def execute(self, env, args):\n        \"\"\" Lists all valid tasks.\n\n            `env`\n                Runtime ``Environment`` instance.\n            `args`\n                Arguments object from arg parser.\n            \"\"\"\n\n        tasks = env.task.get_list_info()\n        if not tasks:\n            env.io.write(\"No tasks found.\")\n\n        else:\n            if args.verbose:\n                _print_tasks(env, tasks, mark_active=True)\n\n            else:\n                if env.task.active:\n                    active_task = env.task.name\n                else:\n                    active_task = None\n\n                for task, options, blocks in tasks:\n                    if task == active_task:\n                        env.io.success(task + ' *')\n                    else:\n                        if options is None and blocks is None:\n                            env.io.error(task + ' ~')\n                        else:\n                            env.io.write(task)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprinting the task information.", "response": "def execute(self, env, args):\n        \"\"\" Prints task information.\n\n            `env`\n                Runtime ``Environment`` instance.\n            `args`\n                Arguments object from arg parser.\n            \"\"\"\n\n        task_name = args.task_name\n\n        if task_name is None:\n            if not env.task.active:\n                raise errors.NoActiveTask\n            task_name = env.task.name\n\n        tasks = env.task.get_list_info(task_name)\n        if not tasks:\n            raise errors.TaskNotFound(task_name)\n\n        _print_tasks(env, tasks)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrender and overrides Jinja2 template files", "response": "def render_template_file(file_name, context):\n    \"\"\" Renders and overrides Jinja2 template files \"\"\"\n    with open(file_name, 'r+') as f:\n        template = Template(f.read())\n        output = template.render(context)\n        f.seek(0)\n        f.write(output)\n        f.truncate()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main(name, output, font):\n\n    # The path of the directory where the final files will end up in\n    bootstrapped_directory = os.getcwd() + os.sep + name.lower().replace(' ', '-') +  os.sep\n\n    # Copy the template files to the target directory\n    copy_tree(get_real_path(os.sep + 'my-cool-os-template'), bootstrapped_directory)\n\n    # Create the necessary assembly mov instructions for printing out the output on boot\n    start_byte = int('0xb8000', 16)\n    instructions_list = []\n\n    for c in output:\n        char_as_hex = '0x02'+ c.encode('hex')\n        instructions_list.append('\\tmov word [{0}], {1} ; {2}'.format(hex(start_byte), char_as_hex, c))\n        start_byte += 2\n\n    # Render the ASCII banner to be displayed in the README (A must for any serious hobby OS project!)\n    banner = Figlet(font=font).renderText(name)\n\n    render_template_file(bootstrapped_directory  + 'README.md', {'name' : name, 'banner' : banner})\n    render_template_file(bootstrapped_directory  + 'grub.cfg' , {'name' : name})\n    render_template_file(bootstrapped_directory  + 'boot.asm' , {'instructions_list' : instructions_list})\n\n    print('finished bootstrapping project into directory ' + bootstrapped_directory)", "response": "Bootstrap an OS project into a directory."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dbfreader(f):\n    # See DBF format spec at:\n    #     http://www.pgts.com.au/download/public/xbase.htm#DBF_STRUCT\n\n    numrec, lenheader = struct.unpack('<xxxxLH22x', f.read(32))\n    numfields = (lenheader - 33) // 32\n\n    fields = []\n    for fieldno in xrange(numfields):\n        name, typ, size, deci = struct.unpack('<11sc4xBB14x', f.read(32))\n        name = name.replace('\\0', '')       # eliminate NULs from string\n        fields.append((name, typ, size, deci))\n    yield [field[0] for field in fields]\n    yield [tuple(field[1:]) for field in fields]\n\n    # replacing missing values with np.NaN. trade-off to make integers as\n    # floats. See\n    # http://stackoverflow.com/questions/11548005/numpy-or-pandas-keeping-array-type-as-integer-while-having-a-nan-value\n    # The limitation is not solved it seems. (Numpy).\n\n    terminator = f.read(1)\n    assert terminator == '\\r'\n\n    fields.insert(0, ('DeletionFlag', 'C', 1, 0))\n    fmt = ''.join(['%ds' % fieldinfo[2] for fieldinfo in fields])\n    fmtsiz = struct.calcsize(fmt)\n    for i in xrange(numrec):\n        record = struct.unpack(fmt, f.read(fmtsiz))\n        if record[0] != ' ':\n            continue                        # deleted record\n        result = []\n        for (name, typ, size, deci), value in itertools.izip(fields, record):\n            if name == 'DeletionFlag':\n                continue\n            if typ == \"N\":\n                value = value.replace('\\0', '').lstrip()\n                if value == '':\n                    # value = 0\n                    value = np.NaN  # 0 is a value.\n                elif deci:\n                    value = float(value)\n                    # value = decimal.Decimal(value) Not necessary.\n                else:\n                    value = int(value)\n            elif typ == 'D':\n                y, m, d = int(value[:4]), int(value[4:6]), int(value[6:8])\n                value = datetime.date(y, m, d)\n            elif typ == 'L':\n                value = ((value in 'YyTt' and 'T') or\n                         (value in 'NnFf' and 'F') or '?')\n            elif typ == 'F':    # Can this type not be null?\n                value = float(value)\n            result.append(value)\n        yield result", "response": "Returns an iterator over records in a Xbase DBF file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dbf_asdict(fn, usecols=None, keystyle='ints'):\n\n    if keystyle not in ['ints', 'names']:\n        raise ValueError('Unknown keyword: ' + str(keystyle))\n\n    with open(fn, 'rb') as fo:\n        rit = dbfreader(fo)\n        names = rit.next()\n        specs = rit.next()      # NOQA\n        R = [tuple(r) for r in rit]\n\n    def getkey(i):\n        if keystyle == 'ints':\n            return i\n        else:\n            return names[i]\n\n    R = zip(*R)\n    d = dict()\n    for i in usecols or range(len(names)):\n        # d[getkey(i)] = R['f' + str(i)]  # Default numpy fieldname\n        d[getkey(i)] = np.array(R[i])\n    return d", "response": "Return data from dbf file fn as a dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the field names from dbf file fn. With usecols return only the names corresponding to the integers in usecols.", "response": "def channel_names(fn, usecols=None):\n    \"\"\"Return the field names (channel names) from dbf file fn. With\n    usecols, return only names corresponding to the integers in\n    usecols.\"\"\"\n\n    with open(fn, 'rb') as fo:\n        names = dbfreader(fo).next()\n\n    return usecols and [names[i] for i in usecols] or names"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reverse_byte_order(self, data):\n        # Courtesy Vishal Sapre\n        byte_count = len(hex(data)[2:].replace('L', '')[::2])\n        val = 0\n        for i in range(byte_count):\n            val = (val << 8) | (data & 0xff)\n            data >>= 8\n        return val", "response": "Reverses the byte order of an int or long value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprocesses the command line arguments.", "response": "def process_arguments():\n    \"\"\"\n    Process the command line arguments. The arguments are:\n     * the list of texts to analyse (at least one);\n     * -f (or --flatten) if the table must be flattened;\n     * -o (or --output) the output file (default: stdout).\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"Extract a table from the \"\n                                                 \"given text\")\n    parser.add_argument(\"text\", type=argparse.FileType('r'),\n                        help=\"the text to analyse\")\n    parser.add_argument(\"--prefix\", \"-p\", type=natural, default=0,\n                        dest=\"prefix\", help=\"if not 0, the maximum length of \"\n                                            \"prefixes to consider when \"\n                                            \"choosing the next character \"\n                                            \"(default: 0)\")\n    parser.add_argument(\"--flatten\", \"-f\", action=\"store_true\", default=False,\n                        dest=\"flatten\", help=\"flatten the table\")\n    parser.add_argument(\"--check\", \"-c\", action=\"store_true\", default=False,\n                        dest=\"check\", help=\"also check that the table is \"\n                                           \"complete\")\n    parser.add_argument(\"--output\", \"-o\", type=argparse.FileType('wb'),\n                        default=None, dest=\"output\",\n                        help=\"the output destination; \"\n                             \"if missing, print the table\")\n    return parser.parse_args()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive an iterable of words return the corresponding table.", "response": "def from_words(cls, words, prefix=0, flatten=False):\n        \"\"\"\n        Given an iterable of words, return the corresponding table.\n        The table is built by accumulating, for each word, for each sub-word,\n        the number of occurrences of the corresponding next character.\n        \n        :param words: an iterable of strings made of alphabetic characters;\n        :param prefix: if greater than 0, the maximum length of the prefix to\n                       store in the table;\n        :param flatten: whether to flatten the table or not;\n        :return: the corresponding table.\n        \n        Example:\n        >>> Table.from_words(['abaq'])\n        {'a':{'b': 1, 'q': 1}, 'ab': {'a': 1}, 'aba': {'q': 1}, 'b': {'a': 1},\n         'ba': {'q': 1}}\n        \"\"\"\n        table = defaultdict(lambda: defaultdict(int))\n        for word in words:\n            word = \">\" + word + \"<\"\n            for start in range(len(word) - 1):\n                max_end = ((len(word) - 1) if prefix <= 0\n                           else (min(start + prefix + 1, len(word) - 1)))\n                for end in range(start + 1, max_end + 1):\n                    sub_word = word[start:end]\n                    weight = 1 if flatten else (table[sub_word][word[end]] + 1)\n                    table[sub_word][word[end]] = weight\n        for k, v in table.items():\n            table[k] = dict(v)\n        return cls(dict(table))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check(self):\n        for character, followers in self.items():\n            for follower in followers:\n                if follower not in self:\n                    return False\n        return True", "response": "Check that this table is complete and that every character of thisCOOKIE is followed by a new character."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the weighted choices for the given word from this table.", "response": "def weighted_choices(self, word, exclude=None, flatten=False):\n        \"\"\"\n        Return the weighted choices for word from this table.\n        \n        :param word: the word (as a string);\n        :param exclude: if not None, a set of characters to exclude from the\n                        weighted choices;\n        :param flatten: whether or not consider this table as flattened;\n        :return: the weighted choices for word from this table.\n        \n        The weighted choices are computed such that:\n        * for a given suffix of word, the possible choices are the ones defined\n          by table;\n        * the weights of these possible choices are either 1 if flatten is\n          True, or the weights defined by table otherwise;\n        * the weights are accumulated for each suffix, but longer suffixes have\n          scaled up weights to assure that all shorter suffixes will have less\n          probabilities to be picked.\n        \"\"\"\n        exclude = exclude if exclude is not None else set()\n        weighted_choices = defaultdict(int)\n        total_sum = 1\n        for start in range(len(word) - 1, -1, -1):\n            current_sum = 0\n            sub_word = word[start:]\n            if sub_word in self:\n                for successor, weight in self[sub_word].items():\n                    if successor not in exclude:\n                        weight = 1 if flatten else weight\n                        weight = weight * total_sum\n                        weighted_choices[successor] += weight\n                        current_sum += weight\n            total_sum += current_sum\n        return weighted_choices"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef random_word(self, length, prefix=0, start=False, end=False,\n                    flatten=False):\n        \"\"\"\n        Generate a random word of length from this table.\n\n        :param length: the length of the generated word; >= 1;\n        :param prefix: if greater than 0, the maximum length of the prefix to\n                       consider to choose the next character;\n        :param start: if True, the generated word starts as a word of table;\n        :param end: if True, the generated word ends as a word of table;\n        :param flatten: whether or not consider the table as flattened;\n        :return: a random word of length generated from table.\n        :raises GenerationError: if no word of length can be generated.\n        \"\"\"\n        if start:\n            word = \">\"\n            length += 1\n            return self._extend_word(word, length, prefix=prefix, end=end,\n                                     flatten=flatten)[1:]\n        else:\n            first_letters = list(k for k in self if len(k) == 1 and k != \">\")\n            while True:\n                word = random.choice(first_letters)\n                try:\n                    word = self._extend_word(word, length, prefix=prefix,\n                                             end=end, flatten=flatten)\n                    return word\n                except GenerationError:\n                    first_letters.remove(word[0])", "response": "Generate a random word from this table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextend the given word with a random suffix up to length.", "response": "def _extend_word(self, word, length, prefix=0, end=False, flatten=False):\n        \"\"\"\n        Extend the given word with a random suffix up to length.\n\n        :param length: the length of the extended word; >= len(word);\n        :param prefix: if greater than 0, the maximum length of the prefix to\n                       consider to choose the next character;\n        :param end: if True, the generated word ends as a word of table;\n        :param flatten: whether or not consider the table as flattened;\n        :return: a random word of length generated from table, extending word.\n        :raises GenerationError: if the generated word cannot be extended to\n                                 length.\n        \"\"\"\n        if len(word) == length:\n            if end and \"<\" not in self[word[-1]]:\n                raise GenerationError(word + \" cannot be extended\")\n            else:\n                return word\n        else:  # len(word) < length\n            exclude = {\"<\"}\n            while True:\n                choices = self.weighted_choices(word[-prefix\n                                                     if prefix > 0\n                                                     else 0:],\n                                                exclude=exclude,\n                                                flatten=flatten)\n                if not choices:\n                    raise GenerationError(word + \" cannot be extended\")\n                # Extend with the weighted choice\n                character = random_weighted_choice(choices)\n                word += character\n                try:\n                    word = self._extend_word(word, length, prefix=prefix,\n                                             end=end, flatten=flatten)\n                    return word\n                except GenerationError:\n                    exclude.add(character)\n                    word = word[:-1]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntry to import and return the given module if it exists None if it doesn t exist", "response": "def import_module(module_path):\n    \"\"\"\n    Try to import and return the given module, if it exists, None if it doesn't\n    exist\n\n    :raises ImportError: When imported module contains errors\n    \"\"\"\n    if six.PY2:\n        try:\n            return importlib.import_module(module_path)\n        except ImportError:\n            tb = sys.exc_info()[2]\n            stack = traceback.extract_tb(tb, 3)\n            if len(stack) > 2:\n                raise\n    else:\n        from importlib import find_loader\n        if find_loader(module_path):\n            return importlib.import_module(module_path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating and return a random password", "response": "def make_password(length, chars=string.letters + string.digits + '#$%&!'):\n    \"\"\"\n    Generate and return a random password\n\n    :param length: Desired length\n    :param chars: Character set to use\n    \"\"\"\n    return get_random_string(length, chars)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __load_section(self, section_key):\n        if self._sections[section_key] is not None: return\n\n        articles = []\n        for page in count(1):\n            if page > 50:\n                raise Exception('Last page detection is probably broken')\n\n            url = '{domain}{section}&iMenuID=1&iSubMenuID={page}'.format(\n                domain = DOMAIN,\n                section = SECTIONS[section_key],\n                page = page\n            )\n\n            body = self._session.get(url).content\n\n            # This is a very hacky way of detecting the last page\n            # that will probably break again in the future\n            if \"\uc54c\uc218 \uc5c6\ub294 \uc8fc\uc18c\" in body: # \"Unknown Address\"\n                break\n\n            # Parse out all the article links\n            root = html.fromstring(body)\n            title_lines = root.find_class('ListNewsLineTitle')\n            for title_line in title_lines:\n                title_link = title_line.find('a')\n\n                # The links do a JS open in a new window, so we need to parse\n                # it out using this ugly, brittle junk\n                href = title_link.get('href')\n                match = re.match(\"javascript:article_open\\('(.+)'\\)\", href)\n                if not match:\n                    raise Exception(\"The site's link format has changed and is not compatible\")\n                path = match.group(1).decode('string_escape')\n\n                articles.append(Article(\n                    self._session,\n                    title_link.text_content().strip(),\n                    DOMAIN + '/en/' + path\n                ))\n\n        self._sections[section_key] = articles", "response": "Reads the set of article links for a section."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading the text and photos from the page.", "response": "def __load(self):\n        \"\"\" Loads text and photos if they are not cached. \"\"\"\n        if self._text is not None: return\n\n        body = self._session.get(self.url).content\n        root = html.fromstring(body)\n        self._text = \"\\n\".join((\n            p_tag.text_content()\n                for p_tag in root.findall('.//p[@class=\"ArticleContent\"]')\n                if 'justify' in p_tag.get('style', '')\n        ))\n\n        # TODO fix this\n        self._photos = []"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef filter_factory(global_conf, **local_conf):\n    conf = global_conf.copy()\n    conf.update(local_conf)\n\n    def visible(app):\n        return VisibleFilter(app, conf)\n    return visible", "response": "Returns a WSGI filter app for use with paste. deploy."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _is_whitelisted(self, req):\n\n        if not self.roles_whitelist:\n            return False\n\n        if not hasattr(req, 'context'):\n            self.log.info(\"No context found.\")\n            return False\n\n        if not hasattr(req.context, 'roles'):\n            self.log.info(\"No roles found in context\")\n            return False\n\n        roles = req.context.roles\n        self.log.debug(\"Received request from user with roles: %s\",\n                       ' '.join(roles))\n        for key in self.roles_whitelist:\n            if key in roles:\n                self.log.debug(\"User role (%s) is whitelisted.\", key)\n                return True\n\n        return False", "response": "Return True if role is whitelisted or roles cannot be determined."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a topic to a given forum", "response": "def add_topic(request, forum_slug=None):\n    \"\"\" Adds a topic to a given forum \"\"\"\n    forum = Forum.objects.get(slug=forum_slug)\n    form  = AddTopicForm(request.POST or None, request.FILES or None, initial={'forum': forum})\n\n    current_time   = time.time()\n    user           = request.user\n\n    if form.is_valid():\n        instance = form.save(commit=False)\n        instance.forum           = forum\n        instance.name            = strip_tags(instance.name)\n        instance.slug            = slugify(instance.name)\n        instance.user            = user\n        instance.author          = user.display_name\n        instance.lastpost_author = user.display_name\n        instance.created_int     = current_time\n        instance.modified_int    = current_time\n        instance.save()\n\n        # and now add the child post\n        post = Post(\n            topic            = instance,\n            text             = request.POST['text'],\n            user             = user,\n            post_date_int    = current_time\n        )\n        if request.FILES:\n            post.image = request.FILES['image']\n        post.save()\n\n        return HttpResponseRedirect(\"/forum/%s/?new_topic=%s\" % (forum_slug, instance.id))\n\n    return render(request, 'fretboard/add_edit.html', {\n        'form': form,\n        'form_title': 'Add a topic',\n        'FORUM_BASE_NAME': FORUM_BASE_NAME\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new post and attaches it to a topic.", "response": "def add_post(request, t_slug, t_id, p_id = False):  # topic slug, topic id, post id\n    \"\"\"\n    Creates a new post and attaches it to a topic\n    \"\"\"\n    topic     = get_object_or_404(Topic, id=t_id)\n    topic_url = '{0}page{1}/'.format(topic.get_short_url(), topic.page_count)\n    user      = request.user\n    current_time = time.time()\n    form_title = 'Add a post'\n\n    if topic.is_locked:  # If we mistakenly allowed reply on locked topic, bail with error msg.\n        messages.error(request, 'Sorry, but this topic is closed')\n        return HttpResponseRedirect(topic_url)\n\n    q = None\n    if p_id:  # if there's a post id, it's a quote\n        q = Post.objects.get(id=p_id)\n        form_title = \"Respond to post\"\n\n    form = PostForm(request.POST or None, request.FILES or None)\n\n    if form.is_valid():\n        # we're going to save this inital data now,\n        # rather than on the model save()\n        # because we only want to bother with this stuff one time\n        # and it will never update or change.\n\n        instance = form.save(commit=False)\n        instance.topic  = topic\n        instance.user = user\n        instance.author_name = user.display_name\n        instance.avatar = user.avatar\n        instance.post_date_int = current_time\n        instance.quote = q\n        instance.save()\n\n        update_post_relations(user, topic)\n\n        return HttpResponseRedirect('%s?new_post=%s#post-%s' % (topic_url, t_id, instance.id))\n    return render(request, 'fretboard/add_edit.html', {\n        'form': form,\n        'form_title': form_title,\n        'quote': q,\n        'FORUM_BASE_NAME': FORUM_BASE_NAME\n    })"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef edit_post(request, post_id):\n    post   = get_object_or_404(Post, id=post_id)\n    user   = request.user\n\n    topic  = post.topic\n    # oughta build a get_absolute_url method for this, maybe.\n    post_url = '{0}page{1}/#post{2}'.format(topic.get_short_url(), topic.page_count, post.id)\n\n    if topic.is_locked:\n        messages.error(request, 'Sorry, but this topic is closed')\n        return HttpResponseRedirect(post_url)\n\n    if user.is_staff is False and user.id != post.author.id:\n        messages.error(request, \"Sorry, but you can't edit this post.\")\n        return HttpResponseRedirect(post_url)\n\n    if request.POST and len(request.POST['text']) > 1:\n        if request.is_ajax and 'body' in request.POST:  # AJAX REQUEST\n            post.text = request.POST['body']\n            post.save(update_fields=['text', 'text_formatted'])\n            return HttpResponse(str(post.text))\n        post.text = request.POST['text']\n        post.save(update_fields=['text', 'text_formatted'])\n\n        if 'name' in request.POST:  # updated topic\n            topic.name = request.POST['name']\n            topic.save(update_fields=['name'])\n        return HttpResponseRedirect(post_url)\n    # this is a get request\n    else:\n        if post == topic.post_set.all()[0]:\n            form = AddTopicForm(instance=topic, initial={'text': post.text})\n        else:\n            form = PostForm(instance=post)\n        return render(request, 'fretboard/add_edit.html', {\n            'quote': post.quote,\n            'form' : form,\n            'form_title': 'Edit post',\n        })", "response": "Allows user to edit an existing post."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_post(request, post_id, topic_id):\n    try:\n        topic = Topic.objects.get(id=topic_id)\n        post = Post.objects.get(id=post_id)\n    except:\n        messages.error(request, 'Sorry, but this post can not be found. It may have been deleted already.')\n        raise Http404\n    return_url = \"/forum/%s/%s/%s/\" % (topic.forum.slug, topic.slug, topic_id)\n    if request.user.is_authenticated() and (request.user.is_staff or request.user.id == post.author.id):\n        post.delete()\n        update_post_relations(request.user, topic, deleting=True)\n        topic_posts = topic.post_set.count()\n        pmax = (topic_posts / PAGINATE_BY) + 1\n\n        # if no posts are left, delete topic.\n        if topic_posts == 0:\n            topic.delete()\n            return HttpResponseRedirect(\"/forum/%s/\" % topic.forum.slug)\n\n        return HttpResponseRedirect(\"%spage%s/\" % (return_url, pmax))\n    else:\n        raise Http404", "response": "Deletes a post from the topic."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef memorySearch(self, ip):\n        if not ip.isdigit(): ip = self.ip2Long(ip)\n\n        if self.__dbBinStr == '':\n            self.__dbBinStr = self.__f.read() #read all the contents in file\n            self.__sPtr     = self.getLong(self.__dbBinStr, 0)\n            endPtr          = self.getLong(self.__dbBinStr, 4)\n            self.__indexLen = endPtr - self.__sPtr\n\n        startPtr = self.__sPtr\n        indexLen = self.__indexLen\n        dbBinStr = self.__dbBinStr\n\n        l, h, mixPtr = (0, int(indexLen/12), 0)\n        while l <= h:\n            m   = int((l+h)/2)\n            ptr = startPtr + m*12\n\n            sip = self.getLong(dbBinStr, ptr)\n            eip = self.getLong(dbBinStr, ptr+4)\n\n            if ip >= sip:\n                if ip > eip:\n                    l = m + 1\n                else:\n                    mixPtr = self.getLong(dbBinStr, ptr+8)\n                    break;\n            else:\n                h = m - 1\n\n        if mixPtr == 0: return \"N2\"\n\n        return self.returnData(mixPtr)", "response": "method memory search method\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef binarySearch(self, ip):\n        if not ip.isdigit(): ip = self.ip2Long(ip)\n\n        if self.__indexLen < 1:\n            self.__f.seek(0)\n            b = self.__f.read(8)\n            self.__sPtr = self.getLong(b, 0)\n            endPtr      = self.getLong(b, 4)\n            self.__indexLen = endPtr - self.__sPtr\n\n        startPtr = self.__sPtr\n        indexLen = self.__indexLen\n\n        self.__f.seek(startPtr)\n        b = self.__f.read(indexLen+12)\n\n        l, h, mixPtr = (0, int(indexLen/12), 0)\n        while l <= h:\n            m   = int((l+h)/2)\n            ptr = startPtr + m*12\n            self.__f.seek(ptr)\n\n            b   = self.__f.read(12)\n            sip = self.getLong(b, 0)\n            eip = self.getLong(b, 4)\n\n            if ip >= sip:\n                if ip > eip:\n                    l = m + 1\n                else:\n                    mixPtr = self.getLong(b, 8)\n                    break;\n            else:\n                h = m - 1\n\n        if mixPtr == 0: return \"N2\"\n\n        return self.returnData(mixPtr)", "response": "method binarySearch - Searches the ISO for a specific IP"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef initDatabase(self, db_file):\n        try:\n            self.__f = io.open(db_file, \"rb\")\n        except IOError, e:\n            print \"[Error]: \", e\n            sys.exit()", "response": "initialize the database for search\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef returnData(self, dsptr):\n        dataPtr = dsptr & 0x00FFFFFFL\n        dataLen = (dsptr >> 24) & 0xFF\n\n        self.__f.seek(dataPtr)\n\n        data = self.__f.read(dataLen)\n        result = data[4:].split('|')\n        location = Location(self.getLong(data, 0), result[0], result[1], result[2], result[3], result[4])\n\n        return location", "response": "get ip data from db file by data start ptr\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef emit(self, record):\n\t\tmsg = self.format(record) + '\\000'\n\t\t\"\"\"\n\t\tWe need to convert record level to lowercase, maybe this will\n\t\tchange in the future.\n\t\t\"\"\"\n\t\tprio = '<%d>' % self.encodePriority(self.facility,\n\t\t\t\t\tself.mapPriority(record.levelname))\n\t\tprio = prio.encode('utf-8')\n\t\t# Message is a string. Convert to bytes as required by RFC 5424.\n\t\tmsg = msg.encode('utf-8')\n\t\tif codecs:\n\t\t\tmsg = codecs.BOM_UTF8 + msg\n\t\tmsg = prio + msg\n\t\ttry:\n\t\t\tif self.unixsocket:\n\t\t\t\ttry:\n\t\t\t\t\tself.socket.send(msg)\n\t\t\t\texcept socket.error:\n\t\t\t\t\tself._connect_unixsocket(self.address)\n\t\t\t\t\tself.socket.send(msg)\n\t\t\telif self.socktype == socket.SOCK_DGRAM:\n\t\t\t\tself.socket.sendto(msg, self.address)\n\t\t\telse:\n\t\t\t\tself.socket.sendall(msg)\n\t\texcept (KeyboardInterrupt, SystemExit):\n\t\t\traise\n\t\texcept:\n\t\t\tself.handleError(record)", "response": "Emit a record to the syslog server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef jackknife_loop(func, data, d=1, combolimit=int(1e6)):\n    # load modules\n    import scipy.special\n    import warnings\n    import itertools\n    import numpy as np\n\n    # How many observations contains data?\n    N = data.shape[0]\n\n    # throw a warning!\n    numcombos = scipy.special.comb(N, d, exact=True)  # binocoeff\n    if numcombos > 1e5:\n        warnings.warn((\n            \"N={0:d} and d={1:d} result in {2:d} \"\n            \"combinations to compute\").format(N, d, numcombos))\n    if numcombos > combolimit:\n        raise Exception(\"Number of combinations exceeds 'combolimit'.\")\n\n    # list of tuples that contain all combinations of\n    # row indicies to leave out\n    leaveout = list(itertools.combinations(range(N), d))\n\n    # store all metrics, estimates, model parameters\n    # as list/array or scalar in one list\n    theta_subsample = []\n\n    # loop over all combinations\n    idx = np.arange(0, N)\n\n    for c in range(numcombos):\n        # create true/false index for the c-th subsample\n        # i.e. all true except the d leaveout indicies\n        subidx = np.isin(idx, leaveout[c], assume_unique=True, invert=True)\n\n        # compute metrics and store them\n        theta_subsample.append(func(data[subidx, :]))\n\n    # compute metrics on the full sample\n    theta_fullsample = func(data)\n\n    # done\n    return np.array(theta_subsample), np.array(theta_fullsample)", "response": "Generic Jackknife Subsampling procedure"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreacting to given AMP message.", "response": "def reactToAMQPMessage(message, send_back):\n    \"\"\"\n    React to given (AMQP) message. `message` is expected to be\n    :py:func:`collections.namedtuple` structure from :mod:`.structures` filled\n    with all necessary data.\n\n    Args:\n        message (object): One of the request objects defined in\n                          :mod:`.structures`.\n        send_back (fn reference): Reference to function for responding. This is\n                  useful for progress monitoring for example. Function takes\n                  one parameter, which may be response structure/namedtuple, or\n                  string or whatever would be normally returned.\n\n    Returns:\n        object: Response class from :mod:`structures`.\n\n    Raises:\n        ValueError: if bad type of `message` structure is given.\n    \"\"\"\n    if _instanceof(message, structures.ScanFile):\n        result = antivirus.save_and_scan(\n            message.filename,\n            message.b64_data\n        )\n        return structures.ScanResult(message.filename, result)\n\n    elif _instanceof(message, structures.UpdateDatabase):\n        return structures.DatabaseUpdated(\n            antivirus.update_database()\n        )\n\n    raise ValueError(\n        \"Unknown type of request: '\" + str(type(message)) + \"'!\"\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef search(usr, item, area = \"shop\", scope = \"exact\", min = \"0\", max = \"99999\"):\n        if not usr:\n            raise invalidUser\n        \n        if not item:\n            raise invalidSearch\n            \n        if area != ShopWizard.SHOP and area != ShopWizard.GALLERY:\n            logging.getLogger(\"neolib.shop\").info(\"Invalid area supplied for shop wizard search: \" + area)\n            raise invalidSearch\n            \n        if scope != ShopWizard.CONTAINING and scope != ShopWizard.EXACT:\n            logging.getLogger(\"neolib.shop\").info(\"Invalid scope supplied for shop wizard search: \" + area)\n            raise invalidSearch\n            \n        if int(min) < 0:\n            logging.getLogger(\"neolib.shop\").info(\"Invalid min value supplied for shop wizard search: \" + min)\n            raise invalidSearch\n            \n        if int(max) > 99999:\n            logging.getLogger(\"neolib.shop\").info(\"Invalid max value supplied for shop wizard search: \" + max)\n            raise invalidSearch\n            \n        if isinstance(item, Item):\n            item = item.name\n        \n        pg = usr.getPage(\"http://www.neopets.com/market.phtml?type=wizard\")\n        \n        form = pg.form(action=\"market.phtml\")\n        form.update({'shopwizard': item, 'table': area, 'criteria': scope, 'min_price': str(min), 'max_price': str(max)})\n        pg = form.submit()\n        \n        # Indicates shop wizard banned\n        if \"too many searches\" in pg.content:\n            time = pg.find(\"b\", text = \"Whoa there, too many searches!\").parent.p.b.item\n            e = shopWizBanned()\n            e.time = time\n            raise e\n            \n        # Indicates a faerie quest\n        if \"You're working for a faerie\" in pg.content:\n            logging.getLogger(\"neolib.shop\").info(\"Could not search for \" + item + \". A Faerie quest is active\")\n            raise activeQuest\n            \n        if \"did not find\" in pg.content:\n            if item in pg.content:\n                return False # Indicates UB item\n            elif \"...</span>\" in pg.content:\n                # Probably invalid item\n                raise invalidSearch\n            \n        return ShopWizardResult(pg, usr)", "response": "Search the shop wizard for the given item and returns a ShopWizardResult object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef price(usr, item, searches = 2, method = \"AVERAGE\", deduct = 0):\n        if not method in ShopWizard.methods: raise invalidMethod()\n        \n        if isinstance(item, Item):\n            item = item.name\n        \n        prices = []\n        dets = {}\n        for x in range(0, searches):\n            results = ShopWizard.search(usr, item)\n            \n            # Set to -1 if not found\n            if not results:\n                prices.append(-1)\n                continue\n            \n            prices.append(int(results[0].price))\n            dets[str(results[0].price)] = (results[0].owner, results[0].id)\n            \n            time.sleep(ShopWizard.waitTime)\n            \n        # Determines if item was UB\n        if sum(prices) == len(prices) * -1:\n            return False\n            \n        prices = list(filter(lambda x: x != -1, prices))\n            \n        if method == ShopWizard.RETLOW:\n            price = sorted(prices)[0]\n            return (price, dets[str(price)][0], dets[str(price)][1])\n            \n        return ShopWizard.__determinePrice(prices, method, deduct)", "response": "Searchs the shop wizard for given item and determines the lowest price of the item. Returns False if no price is found."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall documentation: `/credit_card/create <https://www.wepay.com/developer/reference/credit_card#create>`_, plus extra keyword parameter: :keyword bool batch_mode: turn on/off the batch_mode, see :class:`wepay.api.WePay` :keyword str batch_reference_id: `reference_id` param for batch call, see :class:`wepay.api.WePay` :keyword str api_version: WePay API version, see :class:`wepay.api.WePay`", "response": "def __create(self, client_id, cc_number, cvv, expiration_month,\n                 expiration_year, user_name, email, address, **kwargs):\n        \"\"\"Call documentation: `/credit_card/create\n        <https://www.wepay.com/developer/reference/credit_card#create>`_, plus\n        extra keyword parameter:\n        \n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'client_id': client_id,\n            'cc_number': cc_number, \n            'cvv': cvv,\n            'expiration_month': expiration_month,\n            'expiration_year': expiration_year,\n            'user_name': user_name,\n            'email': email,\n            'address': address\n        }\n        return self.make_call(self.__create, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __authorize(self, client_id, client_secret, credit_card_id, **kwargs):\n        params = {\n            'client_id': client_id,\n            'client_secret': client_secret,\n            'credit_card_id': credit_card_id\n        }\n        return self.make_call(self.__authorize, params, kwargs)", "response": "This method is used to authorize a user s account."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __find(self, client_id, client_secret, **kwargs):\n        params = {\n            'client_id': client_id,\n            'client_secret': client_secret\n        }\n        return self.make_call(self.__find, params, kwargs)", "response": "Method to find the current state of a specific resource."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall documentation: `/credit_card/delete <https://www.wepay.com/developer/reference/credit_card#delete>`_, plus extra keyword parameter: :keyword bool batch_mode: turn on/off the batch_mode, see :class:`wepay.api.WePay` :keyword str batch_reference_id: `reference_id` param for batch call, see :class:`wepay.api.WePay` :keyword str api_version: WePay API version, see :class:`wepay.api.WePay`", "response": "def __delete(self, client_id, client_secret, credit_card_id, **kwargs):\n        \"\"\"Call documentation: `/credit_card/delete\n        <https://www.wepay.com/developer/reference/credit_card#delete>`_, plus\n        extra keyword parameter:\n        \n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'client_id': client_id,\n            'client_secret': client_secret,\n            'credit_card_id': credit_card_id\n        }\n        return self.make_call(self.__delete, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __transfer(self, client_id, client_secret, cc_number, expiration_month,\n                   expiration_year, user_name, email, address, **kwargs):\n        \"\"\"Call documentation: `/credit_card/transfer\n        <https://www.wepay.com/developer/reference/credit_card#transfer>`_, plus\n        extra keyword parameter:\n        \n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'client_id': client_id,\n            'client_secret': client_secret,\n            'cc_number': cc_number, \n            'expiration_month': expiration_month,\n            'expiration_year': expiration_year,\n            'user_name': user_name,\n            'email': email,\n            'address': address\n        }\n        return self.make_call(self.__transfer, params, kwargs)", "response": "This method is used to transfer a specific entry in a specific language."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating zone records. Arguments: server: TonicDNS API server token: TonicDNS API authentication token domain: Specify domain name identifier: Template ID dtype: MASTER|SLAVE|NATIVE (default: MASTER) master: master server ip address when dtype is SLAVE (default: None) ContentType: application/json x-authentication-token: token", "response": "def create_zone(server, token, domain, identifier, dtype, master=None):\n    \"\"\"Create zone records.\n\n    Arguments:\n\n        server:     TonicDNS API server\n        token:      TonicDNS API authentication token\n        domain:     Specify domain name\n        identifier: Template ID\n        dtype:      MASTER|SLAVE|NATIVE (default: MASTER)\n        master:     master server ip address when dtype is SLAVE\n                    (default: None)\n\n    ContentType: application/json\n    x-authentication-token: token\n    \"\"\"\n    method = 'PUT'\n    uri = 'https://' + server + '/zone'\n\n    obj = JSONConverter(domain)\n    obj.generate_zone(domain, identifier, dtype, master)\n    connect.tonicdns_client(uri, method, token, obj.zone)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_records(server, token, domain, data):\n    method = 'PUT'\n    uri = 'https://' + server + '/zone/' + domain\n    for i in data:\n        connect.tonicdns_client(uri, method, token, i)", "response": "Create records of specific domain."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting records of specific domain.", "response": "def delete_records(server, token, data):\n    \"\"\"Delete records of specific domain.\n\n    Arguments:\n\n        server: TonicDNS API server\n        token:  TonicDNS API authentication token\n        data:   Delete records\n\n    ContentType: application/json\n    x-authentication-token: token\n    \"\"\"\n    method = 'DELETE'\n    uri = 'https://' + server + '/zone'\n    for i in data:\n        connect.tonicdns_client(uri, method, token, i)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves zone records. Argument: server: TonicDNS API server token: TonicDNS API authentication token domain: Specify domain name keyword: Search keyword x-authentication-token: token", "response": "def get_zone(server, token, domain, keyword='', raw_flag=False):\n    \"\"\"Retrieve zone records.\n\n    Argument:\n\n        server:  TonicDNS API server\n        token:   TonicDNS API authentication token\n        domain:  Specify domain name\n        keyword: Search keyword\n\n    x-authentication-token: token\n    \"\"\"\n    method = 'GET'\n    uri = 'https://' + server + '/zone/' + domain\n    data = connect.tonicdns_client(uri, method, token, data=False,\n                                   keyword=keyword, raw_flag=raw_flag)\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete specific zone. Argument: server: TonicDNS API server token: TonicDNS API authentication token domain: Specify domain name x-authentication-token: token", "response": "def delete_zone(server, token, domain):\n    \"\"\"Delete specific zone.\n\n    Argument:\n\n        server: TonicDNS API server\n        token:  TonicDNS API authentication token\n        domain: Specify domain name\n\n    x-authentication-token: token\n    \"\"\"\n    method = 'DELETE'\n    uri = 'https://' + server + '/zone/' + domain\n    connect.tonicdns_client(uri, method, token, data=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_template(server, token, identifier, template):\n    method = 'PUT'\n    uri = 'https://' + server + '/template/' + identifier\n    connect.tonicdns_client(uri, method, token, data=template)", "response": "Create a new template."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_template(server, token, template):\n    method = 'DELETE'\n    uri = 'https://' + server + '/template/' + template\n    connect.tonicdns_client(uri, method, token, data=False)", "response": "Delete a template from TonicDNS"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_all_templates(server, token):\n    method = 'GET'\n    uri = 'https://' + server + '/template'\n    connect.tonicdns_client(uri, method, token, data=False)", "response": "Retrieve all templates.\n\n    Argument:\n\n        server:   TonicDNS API server\n        token:    TonicDNS API authentication token\n\n    x-authentication-token: token"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_soa_serial(server, token, soa_content):\n    method = 'GET'\n    uri = 'https://' + server + '/zone/' + soa_content.get('domain')\n    cur_soa, new_soa = connect.tonicdns_client(\n        uri, method, token, data=False, keyword='serial', content=soa_content)\n    # set JSON\n\n    domain = soa_content.get('domain')\n    cur_o = JSONConverter(domain)\n    new_o = JSONConverter(domain)\n    cur_o.records = [cur_soa]\n    new_o.records = [new_soa]\n    cur_o.generata_data(False)\n    new_o.generata_data(True)\n\n    # Create new SOA record\n    uri = 'https://' + server + '/zone/' + domain\n    method = 'PUT'\n    connect.tonicdns_client(uri, method, token, new_o.dict_records[0])\n\n    # Delete current SOA record why zone has only one SOA record.\n    method = 'DELETE'\n    uri = 'https://' + server + '/zone'\n    connect.tonicdns_client(uri, method, token, cur_o.dict_records[0])", "response": "Update the SOA record serial in TonicDNS API."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef decompose_seconds_in_day(seconds):\n    if seconds > SECONDS_IN_DAY:\n        seconds = seconds - SECONDS_IN_DAY\n    if seconds < 0:\n        raise ValueError(\"seconds param must be non-negative!\")\n    hour = int(seconds / 3600)\n    leftover = seconds - hour * 3600\n    minute = int(leftover / 60)\n    second = leftover - minute * 60\n    return hour, minute, second", "response": "Decomposes seconds in day into hour minute and second components."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndecomposes atime of day into hour minute and seconds components.", "response": "def seconds_in_day_to_time(seconds):\n    \"\"\"Decomposes atime of day into hour, minute and seconds components.\n\n    Arguments\n    ---------\n    seconds : int\n        A time of day by the number of seconds passed since midnight.\n\n    Returns\n    -------\n    datetime.time\n        The corresponding time of day as a datetime.time object.\n\n    Example\n    -------\n    >>> seconds_in_day_to_time(23430)\n    datetime.time(6, 30, 30)\n    \"\"\"\n    try:\n        return time(*decompose_seconds_in_day(seconds))\n    except ValueError:\n        print(\"Seconds = {}\".format(seconds))\n        print(\"H = {}, M={}, S={}\".format(*decompose_seconds_in_day(seconds)))\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the identity details for the element as XML nodes", "response": "def _as_rdf_xml(self, ns):\n        \"\"\"\n        Return identity details for the element as XML nodes\n        \"\"\"\n        self.rdf_identity = self._get_identity(ns)\n        elements = []\n        elements.append(ET.Element(NS('sbol', 'persistentIdentity'),\n                                   attrib={NS('rdf', 'resource'):\n                                           self._get_persistent_identitity(ns)}))\n        if self.name is not None:\n            name = ET.Element(NS('dcterms', 'title'))\n            name.text = self.name\n            elements.append(name)\n        if self.display_id is not None:\n            display_id = ET.Element(NS('sbol', 'displayId'))\n            display_id.text = self.display_id\n            elements.append(display_id)\n        if self.version is not None:\n            version = ET.Element(NS('sbol', 'version'))\n            version.text = self.version\n            elements.append(version)\n        if self.was_derived_from is not None:\n            elements.append(ET.Element(NS('prov', 'wasDerivedFrom'),\n                                       attrib={NS('rdf', 'resource'): self.was_derived_from}))\n        if self.description is not None:\n            description = ET.Element(NS('dcterms', 'description'))\n            description.text = self.description\n            elements.append(description)\n        for a in self.annotations:\n            elements.append(a._as_rdf_xml(ns))\n        return elements"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_requirement_files(args=None):\n    if args and args.input_filename:\n        return [args.input_filename]\n\n    paths = []\n    for regex in settings.REQUIREMENTS_SOURCE_GLOBS:\n        paths.extend(glob.glob(regex))\n    return paths", "response": "Get the list of requirements files that can be found in the current directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns all domains in the server", "response": "def list_domains(self):\n        \"\"\" Return all domains. Domain is a key, so group by them \"\"\"\n        self.connect()\n        results = self.server.list_domains(self.session_id)\n        return {i['domain']: i['subdomains'] for i in results}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_websites(self):\n        self.connect()\n        results = self.server.list_websites(self.session_id)\n\n        return results", "response": "Return all websites, name is not a key"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef website_exists(self, website, websites=None):\n        if websites is None:\n            websites = self.list_websites()\n        if isinstance(website, str):\n            website = {\"name\": website}\n        ignored_fields = ('id',)  # changes in these fields are ignored\n\n        results = []\n        for other in websites:\n            different = False\n            for key in website:\n                if key in ignored_fields:\n                    continue\n                if other.get(key) != website.get(key):\n                    different = True\n                    break\n            if different is False:\n                results.append(other)\n        return results", "response": "Return list of websites that exist in the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn name as a string based on given date and month.", "response": "def get_nameday(self, month=None, day=None):\n        \"\"\"Return name(s) as a string based on given date and month.\n        If no arguments given, use current date\"\"\"\n        if month is None:\n            month = datetime.now().month\n        if day is None:\n            day = datetime.now().day\n        return self.NAMEDAYS[month-1][day-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns names as a tuple based on given month.", "response": "def get_month_namedays(self, month=None):\n        \"\"\"Return names as a tuple based on given month.\n        If no month given, use current one\"\"\"\n        if month is None:\n            month = datetime.now().month\n        return self.NAMEDAYS[month-1]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if the user has global or per object permission.", "response": "def check_moderator_permissions(self, request):\n        \"\"\"\n        Check if user have global or per object permission (on category \n        instance and on thread instance), finally return a 403 response if no \n        permissions has been finded.\n        \n        If a permission has been finded, return False, then the dispatcher \n        should so return the \"normal\" response from the view.\n        \"\"\"\n        has_perms = self.has_moderator_permissions(request)\n        \n        # Return a forbidden response if no permission has been finded\n        if not has_perms:\n            raise PermissionDenied\n        \n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef has_moderator_permissions(self, request):\n        return any(request.user.has_perm(perm) for perm in self.permission_required)", "response": "Returns True if user has permission to modify the object instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget OPENSHIFT environment variable", "response": "def getvar(key, default=None, template='OPENSHIFT_{key}'):\n    \"\"\"\n    Get OPENSHIFT envvar\n    \"\"\"\n    return os.environ.get(template.format(key=key), default)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextend base table class with additional information.", "response": "def table(*args, **kw):\n    \"\"\"\n    Table function presents the idea of extending tags for simpler generation of some\n    html element groups. Table has several group of tags in well defined structure. Caption\n    header should be right after table and before thead for example. Colgroup, tfoot, tbody, tr, td and\n    th elements has certain order which are handled by extended table class.\n    \n    Same idea could be used to create unordered lists and menu or other custom html widgets.\n    \n    Use in this way:\n    \n    \u00b4from remarkuple import helper as h, table\u00b4\n    \n    \"\"\"\n    class table(type(helper.table())):\n        \"\"\" Extend base table tag class \"\"\"\n        def __init__(self, *args, **kw):\n            super(self.__class__, self).__init__(*args, **kw)\n        \n        def addCaption(self, caption, **kw):\n            if not self.__dict__.has_key('caption'):\n                self.__dict__['caption'] = helper.caption(**kw)\n            self.__dict__['caption'].addContent(caption)\n            return self\n        \n        def addColGroup(self, *cols, **kw):\n            \"\"\"\n            http://www.w3.org/TR/CSS2/tables.html#columns\n            \"\"\"\n            if not self.__dict__.has_key('colgroup'):\n                self.__dict__['colgroup'] = helper.colgroup(**kw)\n            for col in cols:\n                self.__dict__['colgroup'].addContent(col)\n            return self\n        \n        def addHeadRow(self, *trs, **kw):\n            if not self.__dict__.has_key('thead'):\n                self.__dict__['thead'] = helper.thead(**kw)\n            for tr in trs:\n                self.__dict__['thead'].addContent(tr)\n            return self\n        \n        def addFootRow(self, *trs, **kw):\n            if not self.__dict__.has_key('tfoot'):\n                self.__dict__['tfoot'] = helper.tfoot(**kw)\n            for tr in trs:\n                self.__dict__['tfoot'].addContent(tr)\n            return self\n        \n        def addBodyRow(self, *trs, **kw):\n            \"\"\" Body rows can be collected under same element, or under separate body tags via addBodyRows \"\"\"\n            if not self.__dict__.has_key('tbody'):\n                self.__dict__['tbody'] = helper.tbody(**kw)\n            for tr in trs:\n                self.__dict__['tbody'].addContent(tr)\n            return self\n        \n        def addBodyRows(self, *trs, **kw):\n            \"\"\" See above \"\"\"\n            if not self.__dict__.has_key('tbodys'):\n                self.__dict__['tbodys'] = []\n            self.__dict__['tbodys'].append(helper.tbody(*trs, **kw))\n            return self\n        \n        def __str__(self):\n            if self.__dict__.has_key('caption'):\n                self.addContent(self.__dict__['caption'])\n            if self.__dict__.has_key('colgroup'):\n                self.addContent(self.__dict__['colgroup'])\n            if self.__dict__.has_key('thead'):\n                self.addContent(self.__dict__['thead'])\n            if self.__dict__.has_key('tfoot'):\n                self.addContent(self.__dict__['tfoot'])\n            if self.__dict__.has_key('tbody'):\n                self.addContent(self.__dict__['tbody'])\n            if self.__dict__.has_key('tbodys'):\n                map(self.addContent, self.__dict__['tbodys'])\n            return super(self.__class__, self).__str__()\n    \n    return table(*args, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a value to a dict.", "response": "def add(parent, idx, value):\n  \"\"\"Add a value to a dict.\"\"\"\n  if isinstance(parent, dict):\n    if idx in parent:\n      raise JSONPatchError(\"Item already exists\")\n    parent[idx] = value\n  elif isinstance(parent, list):\n    if idx == \"\" or idx == \"~\":\n      parent.append(value)\n    else:\n      parent.insert(int(idx), value)\n  else:\n    raise JSONPathError(\"Invalid path for operation\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove a value from a dict.", "response": "def remove(parent, idx):\n  \"\"\"Remove a value from a dict.\"\"\"\n  if isinstance(parent, dict):\n    del parent[idx]\n  elif isinstance(parent, list):\n    del parent[int(idx)]\n  else:\n    raise JSONPathError(\"Invalid path for operation\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreplacing a value in a dict.", "response": "def replace(parent, idx, value, check_value=_NO_VAL):\n  \"\"\"Replace a value in a dict.\"\"\"\n  if isinstance(parent, dict):\n    if idx not in parent:\n      raise JSONPatchError(\"Item does not exist\")\n  elif isinstance(parent, list):\n    idx = int(idx)\n    if idx < 0 or idx >= len(parent):\n      raise JSONPatchError(\"List index out of range\")\n  if check_value is not _NO_VAL:\n    if parent[idx] != check_value:\n      raise JSONPatchError(\"Check value did not pass\")\n  parent[idx] = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove an item from a list.", "response": "def set_remove(parent, idx, value):\n  \"\"\"Remove an item from a list.\"\"\"\n  lst = get_child(parent, idx)\n  if value in lst:\n    lst.remove(value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd an item to a list if it doesn t exist.", "response": "def set_add(parent, idx, value):\n  \"\"\"Add an item to a list if it doesn't exist.\"\"\"\n  lst = get_child(parent, idx)\n  if value not in lst:\n    lst.append(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the child at parent [ idx or all the children.", "response": "def get_children(parent, idx):\n  \"\"\"Gets the child at parent[idx], or all the children if idx == \"*\".\"\"\"\n  if isinstance(parent, dict):\n    if idx in parent:\n      yield parent[idx]\n    else:\n      raise JSONPathError(\"Invalid path at {0}\".format(idx))\n\n  elif isinstance(parent, list):\n    if idx == \"*\":\n      yield from parent\n    else:\n      is_int, i = try_parse_int(idx)\n\n      if is_int and i >= 0 and i < len(parent):\n        yield parent[i]\n      else:\n        raise JSONPathError(\"Invalid list index: {0}\".format(i))\n\n  else:\n    raise JSONPathError(\"Type {0} does not have children\".format(type(parent).__name__))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a rfc 6901 path.", "response": "def parse_path(path):\n  \"\"\"Parse a rfc 6901 path.\"\"\"\n  if not path:\n    raise ValueError(\"Invalid path\")\n\n  if isinstance(path, str):\n    if path == \"/\":\n      raise ValueError(\"Invalid path\")\n    if path[0] != \"/\":\n      raise ValueError(\"Invalid path\")\n    return path.split(_PATH_SEP)[1:]\n  elif isinstance(path, (tuple, list)):\n    return path\n  else:\n    raise ValueError(\"A path must be a string, tuple or list\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resolve_path(root, path):\n  path = parse_path(path)\n\n  parent = root\n\n  for part in path[:-1]:\n    parent = get_child(parent, rfc_6901_replace(part))\n\n  return (parent, rfc_6901_replace(path[-1]))", "response": "Resolve a rfc 6901 path returning the parent and the last path part."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all children that satisfy the path.", "response": "def find_all(root, path):\n  \"\"\"Get all children that satisfy the path.\"\"\"\n  path = parse_path(path)\n\n  if len(path) == 1:\n    yield from get_children(root, path[0])\n  else:\n    for child in get_children(root, path[0]):\n      yield from find_all(child, path[1:])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef apply_patch(document, patch):\n  # pylint: disable=too-many-return-statements\n  op = patch.op\n  parent, idx = resolve_path(document, patch.path)\n  if op == \"add\":\n    return add(parent, idx, patch.value)\n  elif op == \"remove\":\n    return remove(parent, idx)\n  elif op == \"replace\":\n    return replace(parent, idx, patch.value, patch.src)\n  elif op == \"merge\":\n    return merge(parent, idx, patch.value)\n  elif op == \"copy\":\n    sparent, sidx = resolve_path(document, patch.src)\n    return copy(sparent, sidx, parent, idx)\n  elif op == \"move\":\n    sparent, sidx = resolve_path(document, patch.src)\n    return move(sparent, sidx, parent, idx)\n  elif op == \"test\":\n    return test(parent, idx, patch.value)\n  elif op == \"setremove\":\n    return set_remove(parent, idx, patch.value)\n  elif op == \"setadd\":\n    return set_add(parent, idx, patch.value)\n  else:\n    raise JSONPatchError(\"Invalid operator\")", "response": "Apply a Patch object to a document."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef execute(self, env, args):\n\n        msg = u'Time Left: {0}m' if not args.short else '{0}'\n        mins = max(0, self.total_duration - env.task.duration)\n        env.io.write(msg.format(mins))", "response": "Display task time left in minutes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_option(self, option, block_name, *values):\n\n        try:\n            if len(values) != 1:\n                raise TypeError\n\n            self.total_duration = int(values[0])\n            if self.total_duration <= 0:\n                raise ValueError\n\n        except ValueError:\n            pattern = u'\"{0}\" must be an integer > 0'\n            raise ValueError(pattern.format(option))", "response": "Parse the duration option for timer.\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef color(self, color=None):\n\n        if color is None:\n            return self._color\n        else:\n            if not isinstance(color, str):\n                raise TypeError(\"color must be str, not '%s'\" % str(color))\n            self._color = color", "response": "Returns or sets the series s colour."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef name(self, name=None):\n\n        if name is None:\n            return self._name\n        else:\n            if not isinstance(name, str) and name is not None:\n                raise TypeError(\"name must be str, not '%s'\" % str(name))\n            self._name = name", "response": "Returns or sets the series s name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_data_point(self, x, y):\n\n        if not is_numeric(x):\n            raise TypeError(\"x value must be numeric, not '%s'\" % str(x))\n        if not is_numeric(y):\n            raise TypeError(\"y value must be numeric, not '%s'\" % str(y))\n        current_last_x = self._data[-1][0]\n        self._data.append((x, y))\n        if x < current_last_x:\n            self._data = sorted(self._data, key=lambda k: k[0])", "response": "Adds a data point to the series."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_data_point(self, x, y):\n\n        if len(self._data) == 1:\n            raise ValueError(\"You cannot remove a Series' last data point\")\n        self._data.remove((x, y))", "response": "Removes the given data point from the series."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the coordinates that the data should use to paint itself to its associated axisChart. This is used internally to paint itself to its associated axisChart.", "response": "def canvas_points(self):\n        \"\"\"Calculates the coordinates that the data should use to paint itself\n        to its associated :py:class:`.AxisChart`. This is used internally to\n        create the chart.\n\n        :rtype: ``tuple``\"\"\"\n\n        if self.chart():\n            x_axis_min = self.chart().x_lower_limit()\n            y_axis_min = self.chart().y_lower_limit()\n            x_axis_max = self.chart().x_upper_limit()\n            y_axis_max = self.chart().y_upper_limit()\n            chart_width = self.chart().width()\n            chart_height = self.chart().height()\n            horizontal_padding = self.chart().horizontal_padding()\n            vertical_padding = self.chart().vertical_padding()\n            horizontal_margin_pixels = horizontal_padding * chart_width\n            vertical_margin_pixels = vertical_padding * chart_height\n            x_axis_pixels = chart_width - (2 * horizontal_margin_pixels)\n            y_axis_pixels = chart_height - (2 * vertical_margin_pixels)\n            x_axis_span = x_axis_max - x_axis_min\n            y_axis_span = y_axis_max - y_axis_min\n            x_pixels_per_point = x_axis_pixels / x_axis_span\n            y_pixels_per_point = y_axis_pixels / y_axis_span\n            data = []\n            for x, y in self.data():\n                relative_x, relative_y = x - x_axis_min, y - y_axis_min\n                data.append((\n                 (relative_x * x_pixels_per_point) + horizontal_margin_pixels,\n                 chart_height - ((relative_y * y_pixels_per_point) + vertical_margin_pixels)\n                ))\n            return tuple(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef linestyle(self, linestyle=None):\n\n        if linestyle is None:\n            return self._linestyle\n        else:\n            if not isinstance(linestyle, str):\n                raise TypeError(\n                 \"linestyle must be str, not '%s'\" % str(linestyle)\n                )\n            self._linestyle = linestyle", "response": "Returns or sets the series s linestyle."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef linewidth(self, linewidth=None):\n\n        if linewidth is None:\n            return self._linewidth\n        else:\n            if not is_numeric(linewidth):\n                raise TypeError(\n                 \"linewidth must be number, not '%s'\" % str(linewidth)\n                )\n            self._linewidth = linewidth", "response": "Returns or sets the width of the series '\n        line."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting the series to an OmniCanvas canvas.", "response": "def write_to_canvas(self, canvas, name):\n        \"\"\"Writes the series to an OmniCanvas canvas.\n\n        :param Canvas canvas: The canvas to write to.\n        :param str name: The name to give the line graphic on the canvas.\"\"\"\n\n        points = self.canvas_points()\n        args = []\n        for point in points:\n            args += list(point)\n        canvas.add_polyline(\n         *args, line_color=self.color(), line_style=self.linestyle(),\n         line_width=self.linewidth(), name=name\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef size(self, size=None):\n\n        if size is None:\n            return self._size\n        else:\n            if not is_numeric(size):\n                raise TypeError(\n                 \"size must be number, not '%s'\" % str(size)\n                )\n            self._size = size", "response": "Returns or sets the diameter of the series '\n        data points."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_to_canvas(self, canvas, name):\n\n        points = self.canvas_points()\n        for point in points:\n            canvas.add_oval(\n             point[0] - (self.size() / 2), point[1] - (self.size() / 2),\n             self.size(), self.size(),\n             fill_color=self.color(), line_width=self.linewidth(), name=name\n            )", "response": "Writes the series to an OmniCanvas canvas."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild version number from git repository tag.", "response": "def get_version():\n    \"\"\"Build version number from git repository tag.\"\"\"\n    try:\n        f = open('eztemplate/version.py', 'r')\n    except IOError as e:\n        if e.errno != errno.ENOENT:\n            raise\n        m = None\n    else:\n        m = re.match('^\\s*__version__\\s*=\\s*(?P<version>.*)$', f.read(), re.M)\n        f.close()\n\n    __version__ = ast.literal_eval(m.group('version')) if m else None\n\n    try:\n        git_version = subprocess.check_output(['git', 'describe', '--dirty'])\n    except:\n        if __version__ is None:\n            raise ValueError(\"cannot determine version number\")\n        return __version__\n\n    m = re.match(r'^\\s*'\n                 r'(?P<version>\\S+?)'\n                 r'(-(?P<post>\\d+)-(?P<commit>g[0-9a-f]+))?'\n                 r'(-(?P<dirty>dirty))?'\n                 r'\\s*$', git_version.decode())\n    if not m:\n        raise ValueError(\"cannot parse git describe output\")\n\n    git_version = m.group('version')\n    post = m.group('post')\n    commit = m.group('commit')\n    dirty = m.group('dirty')\n\n    local = []\n\n    if post:\n        post = int(post)\n        if post:\n            git_version += '.post%d' % (post,)\n            if commit:\n                local.append(commit)\n\n    if dirty:\n        local.append(dirty)\n\n    if local:\n        git_version += '+' + '.'.join(local)\n\n    if git_version != __version__:\n        with open('eztemplate/version.py', 'w') as f:\n            f.write(\"__version__ = %r\\n\" % (str(git_version),))\n\n    return git_version"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_long_description():\n    try:\n        with open('README.md', 'r') as f:\n            description = f.read()\n    except OSError as e:\n        if e.errno != errno.ENOENT:\n            raise\n        return None\n\n    try:\n        process = subprocess.Popen([\n                'pandoc',\n                '-f', 'markdown_github',\n                '-t', 'rst',\n            ],\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            universal_newlines=True,\n            )\n    except OSError as e:\n        if e.errno == errno.ENOENT:\n            return None\n        raise\n\n    description, __ = process.communicate(input=description)\n    if process.poll() is None:\n        process.kill()\n        raise Exception(\"pandoc did not terminate\")\n    if process.poll():\n        raise Exception(\"pandoc terminated abnormally\")\n\n    return description", "response": "Provide README. md converted to reStructuredText format."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def get(self):\n\n        context_data = self.get_context_data()\n        context_data.update(getattr(self.request.app, \"stats\", {}))\n\n        response = self.json_response(context_data)\n        return response", "response": "Print runtime statistics in JSON"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking the status of the current object", "response": "def check_status(self):\n        \"\"\" tests both the ext_url and local_url to see if the database is\n            running\n\n            returns:\n                True if a connection can be made\n                False if the connection cannot me made\n        \"\"\"\n        log = logging.getLogger(\"%s.%s\" % (self.log_name,\n                                           inspect.stack()[0][3]))\n        log.setLevel(self.log_level)\n\n        if self.url:\n            return True\n        try:\n            result = requests.get(self.ext_url)\n            self.url = self.ext_url\n            return True\n        except requests.exceptions.ConnectionError:\n            pass\n        try:\n            result = requests.get(self.local_url)\n            log.warning(\"Url '%s' not connecting. Using local_url '%s'\" % \\\n                     (self.ext_url, self.local_url))\n            self.url = self.local_url\n            return True\n        except requests.exceptions.ConnectionError:\n            self.url = None\n            log.warning(\"Unable to connect using urls: %s\" % set([self.ext_url,\n                                                               self.local_url]))\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse arguments returns a tuple of options and args.", "response": "def parse_args(args=None):\n    '''Parses arguments, returns ``(options, args)``.'''\n    if args is None:\n        args = sys.argv\n\n    parser = ArgumentParser(description='Actions related to available '\n                            'MicroDrop Conda package plugin(s).',\n                            parents=[PLUGIN_PARSER])\n\n    return parser.parse_args()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndumps list to output stream optionally encoded as JSON.", "response": "def _dump_list(list_data, jsonify, stream=sys.stdout):\n    '''\n    Dump list to output stream, optionally encoded as JSON.\n\n    Parameters\n    ----------\n    list_data : list\n    jsonify : bool\n    stream : file-like\n    '''\n    if not jsonify and list_data:\n        print >> stream, '\\n'.join(list_data)\n    else:\n        print >> stream, json.dumps(list_data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _threaded(self, *args, **kwargs):\n\n        for target in self.targets:\n            result = target(*args, **kwargs)\n            self.queue.put(result)", "response": "Call the target and put the result in the Queue."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start(self, *args, **kwargs):\n\n        self.queue = Queue()\n        thread = Thread(target=self._threaded, args=args, kwargs=kwargs)\n        thread.start()\n\n        return Asynchronous.Result(self.queue, thread)", "response": "Start execution of the function."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nnotifies observers with parameter calls and information about the current node.", "response": "def notify_observers(self, joinpoint, post=False):\n        \"\"\"Notify observers with parameter calls and information about\n        pre/post call.\n        \"\"\"\n\n        _observers = tuple(self.observers)\n\n        for observer in _observers:\n            observer.notify(joinpoint=joinpoint, post=post)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef title_from_content(content):\n    for end in (\". \", \"?\", \"!\", \"<br />\", \"\\n\", \"</p>\"):\n        if end in content:\n            content = content.split(end)[0] + end\n            break\n    return strip_tags(content)", "response": "Try and extract the first sentence from a block of test to use as a title."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self, conn, tmp, module_name, module_args, inject):\n        ''' run the pause actionmodule '''\n        hosts = ', '.join(self.runner.host_set)\n        args = parse_kv(template(self.runner.basedir, module_args, inject))\n\n        # Are 'minutes' or 'seconds' keys that exist in 'args'?\n        if 'minutes' in args or 'seconds' in args:\n            try:\n                if 'minutes' in args:\n                    self.pause_type = 'minutes'\n                    # The time() command operates in seconds so we need to\n                    # recalculate for minutes=X values.\n                    self.seconds = int(args['minutes']) * 60\n                else:\n                    self.pause_type = 'seconds'\n                    self.seconds = int(args['seconds'])\n                    self.duration_unit = 'seconds'\n            except ValueError, e:\n                raise ae(\"non-integer value given for prompt duration:\\n%s\" % str(e))\n        # Is 'prompt' a key in 'args'?\n        elif 'prompt' in args:\n            self.pause_type = 'prompt'\n            self.prompt = \"[%s]\\n%s: \" % (hosts, args['prompt'])\n        # Is 'args' empty, then this is the default prompted pause\n        elif len(args.keys()) == 0:\n            self.pause_type = 'prompt'\n            self.prompt = \"[%s]\\nPress enter to continue: \" % hosts\n        # I have no idea what you're trying to do. But it's so wrong.\n        else:\n            raise ae(\"invalid pause type given. must be one of: %s\" % \\\n                         \", \".join(self.PAUSE_TYPES))\n\n        vv(\"created 'pause' ActionModule: pause_type=%s, duration_unit=%s, calculated_seconds=%s, prompt=%s\" % \\\n                (self.pause_type, self.duration_unit, self.seconds, self.prompt))\n\n        ########################################################################\n        # Begin the hard work!\n        try:\n            self._start()\n            if not self.pause_type == 'prompt':\n                print \"[%s]\\nPausing for %s seconds\" % (hosts, self.seconds)\n                time.sleep(self.seconds)\n            else:\n                # Clear out any unflushed buffered input which would\n                # otherwise be consumed by raw_input() prematurely.\n                tcflush(sys.stdin, TCIFLUSH)\n                raw_input(self.prompt)\n        except KeyboardInterrupt:\n            while True:\n                print '\\nAction? (a)bort/(c)ontinue: '\n                c = getch()\n                if c == 'c':\n                    # continue playbook evaluation\n                    break\n                elif c == 'a':\n                    # abort further playbook evaluation\n                    raise ae('user requested abort!')\n        finally:\n            self._stop()\n\n        return ReturnData(conn=conn, result=self.result)", "response": "run the pause actionmodule"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _start(self):\n        ''' mark the time of execution for duration calculations later '''\n        self.start = time.time()\n        self.result['start'] = str(datetime.datetime.now())\n        if not self.pause_type == 'prompt':\n            print \"(^C-c = continue early, ^C-a = abort)\"", "response": "start the execution of the process"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _stop(self):\n        ''' calculate the duration we actually paused for and then\n        finish building the task result string '''\n        duration = time.time() - self.start\n        self.result['stop'] = str(datetime.datetime.now())\n        self.result['delta'] = int(duration)\n\n        if self.duration_unit == 'minutes':\n            duration = round(duration / 60.0, 2)\n        else:\n            duration = round(duration, 2)\n\n        self.result['stdout'] = \"Paused for %s %s\" % (duration, self.duration_unit)", "response": "calculate the duration we actually paused for and then\n        finish building the task result string"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(self, data, status_code, status_reason):\n        self.status_code = status_code\n        self.status_reason = status_reason\n\n        self.success = status_code == 200\n\n        if data:\n            if not self.data:\n                self.data = data\n            else:\n                self.data += data", "response": "Add data to the response."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate the CLI arguments for the Templater command line.", "response": "def parse_cli_args_into():\n    \"\"\"\n    Creates the cli argparser for application specifics and AWS credentials.\n    :return: A dict of values from the cli arguments\n    :rtype: TemplaterCommand\n    \"\"\"\n    cli_arg_parser = argparse.ArgumentParser(parents=[\n        AWSArgumentParser(default_role_session_name='aws-autodiscovery-templater')\n    ])\n    main_parser = cli_arg_parser.add_argument_group('AWS Autodiscovery Templater')\n\n    # template_location = main_parser.add_mutually_exclusive_group(required=True)\n    main_parser.add_argument('--template-path', help='Path to the template to fill variables into.', required=True)\n    # template_location.add_argument('--template-s3-uri', help='S3 URI to the template to fill variables into.')\n\n    # output = main_parser.add_mutually_exclusive_group(required=True)\n    # output.add_argument('--destination-path',\n    #                     help='Destination for the source once the template has been rendered.')\n    main_parser.add_argument('--stdout', help='Prints a json object containing the retrieves resources',\n                             action='store_true',\n                             default=False, required=True)\n\n    main_parser.add_argument('--vpc-ids',\n                             help=('Optionally restrict the filtering to a particular list of IPs. '\n                                   'Comma seperated list of vpc-ids.'),\n                             action='store_true', default=None)\n\n    main_parser.add_argument('--filter',\n                             help=('Filter for ec2 instances as defined in http://boto3.readthedocs.org/en/latest/'\n                                   'reference/services/ec2.html#EC2.Client.describe_instances'),\n                             default=None,\n                             nargs='+')\n    main_parser.add_argument('--filter-empty',\n                             help=('By default, missing values are returned as null to keep private/public ip/hostname'\n                                   'sets of equal length. This removes null values from the filter'),\n                             action='store_true', default=False)\n\n    return cli_arg_parser.parse_args(namespace=TemplateCommand())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting the given text using pycolorterm formatting", "response": "def print_pretty(text, **kwargs):\n    '''\n    Prints using pycolorterm formatting\n\n    :param text: Text with formatting\n    :type text: string\n    :param kwargs: Keyword args that will be passed to the print function\n    :type kwargs: dict\n\n    Example::\n\n        print_pretty('Hello {BG_RED}WORLD{END}')\n    '''\n\n    text = _prepare(text)\n    print('{}{}'.format(text.format(**styles).replace(styles['END'], styles['ALL_OFF']), styles['ALL_OFF']))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef all(self, endpoint, *args, **kwargs):\n        # 1. Initialize the pagination parameters.\n        kwargs.setdefault('params', {})['offset'] = 0\n        kwargs.setdefault('params', {})['limit'] = self.limit\n        kwargs['__method__'] = 'get'\n        # 2. Create an initial paginated request.\n        payload = self.request(endpoint, *args, **kwargs)\n        has_next = payload.get('result', {}).setdefault(\n            'meta', {'next': None}\n        )['next']\n        # 3. Loop until the end\n        while has_next:\n            # 4. Increment the offset\n            kwargs['params']['offset'] += self.limit\n            # 5. Query again\n            _payload = self.request(endpoint, *args, **kwargs)\n            # 6. Add the paginated data to the global one\n            payload['result']['data'].extend(_payload['result']['data'])\n            # 7. Compute has_next\n            has_next = _payload['result']['meta']['next']\n        del payload['result']['meta']\n        return payload", "response": "Retrieve all the data of a paginated endpoint using GET."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef any_text_to_fernet_key(self, text):\n        md5 = fingerprint.fingerprint.of_text(text)\n        fernet_key = base64.b64encode(md5.encode(\"utf-8\"))\n        return fernet_key", "response": "Convert any text to a fernet key for encryption."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a PathCall object from a neighbour and element.", "response": "def _neighbour_to_path_call(neig_type, neighbour, element):\n    \"\"\"\n    Get :class:`PathCall` from `neighbour` and `element`.\n\n    Args:\n        neigh_type (str): `left` for left neighbour, `right` for .. This is\n                          used to determine :attr:`PathCall.call_type` of\n                          returned object.\n        neighbour (obj): Reference to `neighbour` object.\n        element (obj): Reference to HTMLElement holding required data.\n\n    Returns:\n        obj: :class:`PathCall` instance with data necessary to find `element` \\\n             by comparing its `neighbour`.\n    \"\"\"\n    params = [None, None, neighbour.getContent().strip()]\n\n    if neighbour.isTag():\n        params = [\n            neighbour.getTagName(),\n            _params_or_none(neighbour.params),\n            neighbour.getContent().strip()\n        ]\n\n    return PathCall(\n        neig_type + \"_neighbour_tag\",\n        0,  # TODO: Dynamic lookup\n        NeighCall(element.getTagName(), _params_or_none(element.params), params)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef neighbours_pattern(element):\n    # check if there are any neighbours\n    if not element.parent:\n        return []\n\n    parent = element.parent\n\n    # filter only visible tags/neighbours\n    neighbours = filter(\n        lambda x: x.isTag() and not x.isEndTag() or x.getContent().strip() \\\n                  or x is element,\n        parent.childs\n    )\n    if len(neighbours) <= 1:\n        return []\n\n    output = []\n    element_index = neighbours.index(element)\n\n    # pick left neighbour\n    if element_index >= 1:\n        output.append(\n            _neighbour_to_path_call(\n                \"left\",\n                neighbours[element_index - 1],\n                element\n            )\n        )\n\n    # pick right neighbour\n    if element_index + 1 < len(neighbours):\n        output.append(\n            _neighbour_to_path_call(\n                \"right\",\n                neighbours[element_index + 1],\n                element\n            )\n        )\n\n    return output", "response": "Returns a list of PathCall instances that match the negihbours of the element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of PathCall objects that match the given element by its predecesors.", "response": "def predecesors_pattern(element, root):\n    \"\"\"\n    Look for `element` by its predecesors.\n\n    Args:\n        element (obj): HTMLElement instance of the object you are looking for.\n        root (obj): Root of the `DOM`.\n\n    Returns:\n        list: ``[PathCall()]`` - list with one :class:`PathCall` object (to \\\n              allow use with ``.extend(predecesors_pattern())``).\n    \"\"\"\n    def is_root_container(el):\n        return el.parent.parent.getTagName() == \"\"\n\n    if not element.parent or not element.parent.parent or \\\n       is_root_container(element):\n        return []\n\n    trail = [\n        [\n            element.parent.parent.getTagName(),\n            _params_or_none(element.parent.parent.params)\n        ],\n        [\n            element.parent.getTagName(),\n            _params_or_none(element.parent.params)\n        ],\n        [element.getTagName(), _params_or_none(element.params)],\n    ]\n\n    match = root.match(*trail)\n    if element in match:\n        return [\n            PathCall(\"match\", match.index(element), trail)\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_document(self, document):\n        '''\n        Add a document to this corpus\n\n        `document' is passed to `requests.post', so it can be a file-like\n        object, a string (that will be sent as the file content) or a tuple\n        containing a filename followed by any of these two options.\n        '''\n\n        documents_url = urljoin(self.base_url, self.DOCUMENTS_PAGE)\n        data = {\"corpus\": self.url}\n        files = {\"blob\": document}\n        result = self.session.post(documents_url, data=data, files=files)\n        if result.status_code == 201:\n            return Document(session=self.session, **result.json())\n        else:\n            raise RuntimeError(\"Document creation failed with status \"\n                               \"{}. The response was: '{}'\".format(result.status_code,\n                                result.text))", "response": "Adds a document to this corpus."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds multiple documents using the same API call", "response": "def add_documents(self, documents):\n        '''\n        Adds more than one document using the same API call\n\n        Returns two lists: the first one contains the successfully uploaded\n        documents, and the second one tuples with documents that failed to be\n        uploaded and the exceptions raised.\n        '''\n        result, errors = [], []\n        for document in documents:\n            try:\n                result.append(self.add_document(document))\n            except RuntimeError as exc:\n                errors.append((document, exc))\n\n        return result, errors"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_corpus(self, name, description):\n        '''Add a corpus to your account'''\n        corpora_url = self.base_url + self.CORPORA_PAGE\n        data = {'name': name, 'description': description}\n        result = self.session.post(corpora_url, data=data)\n        if result.status_code == 201:\n            return Corpus(session=self.session, **result.json())\n        else:\n            raise RuntimeError(\"Corpus creation failed with status \"\n                               \"{}. The response was: '{}'\".format(result.status_code,\n                                result.text))", "response": "Add a corpus to your account"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving HTTP resources return related objects ( with pagination )", "response": "def _retrieve_resources(self, url, class_, full):\n        '''Retrieve HTTP resources, return related objects (with pagination)'''\n        objects_to_return = []\n        response = self.session.get(url)\n        if response.status_code == 200:\n            result = response.json()\n            resources = result['results']\n            objects_to_return.extend([class_(session=self.session, **resource)\n                                      for resource in resources])\n            while full and result['next'] is not None:\n                response = self.session.get(result['next'])\n                if response.status_code == 200:\n                    result = response.json()\n                    resources = result['results']\n                    objects_to_return.extend([class_(session=self.session,\n                                                     **resource)\n                                              for resource in resources])\n                else:\n                    raise RuntimeError(\"Failed downloading data with status {}\"\n                            \". The response was: '{}'\"\n                            .format(response.status_code, response.text))\n            return objects_to_return\n        else:\n            raise RuntimeError(\"Failed downloading data with status {}\"\n                    \". The response was: '{}'\"\n                    .format(response.status_code, response.text))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef corpora(self, full=False):\n        '''Return list of corpora owned by user.\n\n        If `full=True`, it'll download all pages returned by the HTTP server'''\n        url = self.base_url + self.CORPORA_PAGE\n        class_ = Corpus\n        results = self._retrieve_resources(url, class_, full)\n        return results", "response": "Return list of corpora owned by user."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns list of documents owned by user.", "response": "def documents(self, full=False):\n        '''Return list of documents owned by user.\n\n        If `full=True`, it'll download all pages returned by the HTTP server'''\n        url = self.base_url + self.DOCUMENTS_PAGE\n        class_ = Document\n        results = self._retrieve_resources(url, class_, full)\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init_db():\n    with current_app.app_context():\n        for filename in CHILL_CREATE_TABLE_FILES:\n            db.execute(text(fetch_query_string(filename)))", "response": "Initialize a new database with the default tables for chill."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninsert a node with a name and optional value. Return the node id.", "response": "def insert_node(**kw):\n    \"Insert a node with a name and optional value. Return the node id.\"\n    with current_app.app_context():\n        result = db.execute(text(fetch_query_string('insert_node.sql')), **kw)\n        # TODO: support for postgres may require using a RETURNING id; sql\n        # statement and using the inserted_primary_key?\n        #node_id = result.inserted_primary_key\n        node_id = result.lastrowid\n        if (not node_id):\n            result = result.fetchall()\n            node_id = result[0]['id']\n        return node_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef insert_node_node(**kw):\n    with current_app.app_context():\n        insert_query(name='select_link_node_from_node.sql', node_id=kw.get('node_id'))\n        db.execute(text(fetch_query_string('insert_node_node.sql')), **kw)", "response": "Link a node to another node. node_id -> target_node_id."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef select_node(**kw):\n    with current_app.app_context():\n        result = db.execute(text(fetch_query_string('select_node_from_id.sql')), **kw).fetchall()\n        return result", "response": "Select node by id."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninserts a new route into the database.", "response": "def insert_route(**kw):\n    \"\"\"\n    `path` - '/', '/some/other/path/', '/test/<int:index>/'\n    `node_id`\n    `weight` - How this path is selected before other similar paths\n    `method` - 'GET' is default.\n    \"\"\"\n    binding = {\n            'path': None,\n            'node_id': None,\n            'weight': None,\n            'method': \"GET\"\n            }\n    binding.update(kw)\n    with current_app.app_context():\n        db.execute(text(fetch_query_string('insert_route.sql')), **binding)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the template to use to display the node", "response": "def add_template_for_node(name, node_id):\n    \"Set the template to use to display the node\"\n    with current_app.app_context():\n        db.execute(text(fetch_query_string('insert_template.sql')),\n                name=name, node_id=node_id)\n        result = db.execute(text(fetch_query_string('select_template.sql')),\n                          name=name, node_id=node_id).fetchall()\n        if result:\n            template_id = result[0]['id']\n            db.execute(text(fetch_query_string('update_template_node.sql')),\n                    template=template_id, node_id=node_id)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef insert_query(**kw):\n    with current_app.app_context():\n        result = db.execute(text(fetch_query_string('select_query_where_name.sql')), **kw).fetchall()\n        if result:\n            kw['query_id'] = result[0]['id']\n        else:\n            result = db.execute(text(fetch_query_string('insert_query.sql')), **kw)\n            kw['query_id'] = result.lastrowid\n            if (not kw['query_id']):\n                result = result.fetchall()\n                kw['query_id']  = result[0]['id']\n        db.execute(text(fetch_query_string('insert_query_node.sql')), **kw)", "response": "Insert a query name for a node_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a SubjectGuide model for the passed section params", "response": "def get_subject_guide_for_section_params(\n        year, quarter, curriculum_abbr, course_number, section_id=None):\n    \"\"\"\n    Returns a SubjectGuide model for the passed section params:\n\n    year: year for the section term (4-digits)\n    quarter: quarter (AUT, WIN, SPR, or SUM)\n    curriculum_abbr: curriculum abbreviation\n    course_number: course number\n    section_id: course section identifier (optional)\n    \"\"\"\n\n    quarter = quarter.upper()[:3]\n\n    url = \"{}/{}/{}/{}/{}/{}/{}\".format(\n        subject_guide_url_prefix, 'course', year, quarter,\n        quote(curriculum_abbr.upper()), course_number, section_id.upper())\n    headers = {'Accept': 'application/json'}\n\n    response = SubjectGuide_DAO().getURL(url, headers)\n    response_data = str(response.data)\n    if response.status != 200:\n        raise DataFailureException(url, response.status, response_data)\n\n    return _subject_guide_from_json(json.loads(response.data))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a SubjectGuide model for the passed section.", "response": "def get_subject_guide_for_section(section):\n    \"\"\"\n    Returns a SubjectGuide model for the passed SWS section model.\n    \"\"\"\n    return get_subject_guide_for_section_params(\n        section.term.year, section.term.quarter, section.curriculum_abbr,\n        section.course_number, section.section_id)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_subject_guide_for_canvas_course_sis_id(course_sis_id):\n    (year, quarter, curriculum_abbr, course_number,\n        section_id) = course_sis_id.split('-', 4)\n    return get_subject_guide_for_section_params(\n        year, quarter, curriculum_abbr, course_number, section_id)", "response": "Returns a SubjectGuide model for the Canvas course SIS ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a default SubjectGuide model for the passed campus", "response": "def get_default_subject_guide(campus='seattle'):\n    \"\"\"\n    Returns a default SubjectGuide model for the passed campus:\n        seattle, bothell, tacoma\n    \"\"\"\n    url = \"{}/{}/{}\".format(subject_guide_url_prefix, 'defaultGuide', campus)\n    headers = {'Accept': 'application/json'}\n\n    response = SubjectGuide_DAO().getURL(url, headers)\n\n    if response.status != 200:\n        raise DataFailureException(url, response.status, response.data)\n\n    data = json.loads(response.data)\n    return _subject_guide_from_json(data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, value=None, label=None):\n        if label:\n            self.label = label\n\n        super(ProgressBar, self).update(value)", "response": "Update the progress bar with the given value and label."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the internal state of the object based on the current state of the progress bar.", "response": "def update(self, pbar):\n        \"\"\"\n        Handle progress bar updates\n        @type   pbar:   ProgressBar\n        @rtype: str\n        \"\"\"\n        if pbar.label != self._label:\n            self.label = pbar.label\n\n        return self.label"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef label(self, value):\n        # Fixed width label formatting\n        value = value[:self.pad_size] if self.pad_size else value\n        try:\n            padding = ' ' * (self.pad_size - len(value)) if self.pad_size else ''\n        except TypeError:\n            padding = ''\n\n        self._formatted = ' {v}{p} '.format(v=value, p=padding)", "response": "Set the label and generate the formatted value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate widgets on finish", "response": "def finish(self):\n        \"\"\"\n        Update widgets on finish\n        \"\"\"\n        os.system('setterm -cursor on')\n        if self.nl:\n            Echo(self.label).done()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef search(self, start=0, amount=15, order='asc', concise=False, user=True, dependencies=True, comments=True,\n               votes=True, filters=None):\n        \"\"\"\n        Search the LEX\n        :param start: Start at this result number\n        :param amount: Number of results to return\n        :param order: Ordering of the results ('asc' or 'desc')\n        :param concise: Return only concise results (name and id)\n        :param user: Should user (authenticated) information be returned (e.g. last_downloaded)\n        :param dependencies: Should a dependency list be returned\n        :param comments: Should a list of comments be returned\n        :param votes: Should a list of votes be returned\n        :param filters: Extra filters to add to the search. At least one is required. See `the LEX API documentation\n        <https://github.com/caspervg/SC4Devotion-LEX-API/blob/master/documentation/Search.md#filtering-parameters>` for\n        more information about the possibilities. Use a dictionary with the name of the filter as key, and the filter\n        value as value.\n        :return: List of search results. Can be empty, if no results match the requested filters.\n        :rtype: list\n        \"\"\"\n        if not filters or len(filters.keys()) < 1:\n            raise Exception('Need at least one filter in the \"filters\" dict')\n\n        main = {\n            'start': start,\n            'amount': amount,\n            'order': order,\n        }\n\n        if user:\n            main['user'] = 'true'\n        if dependencies:\n            main['dependencies'] = 'true'\n        if comments:\n            main['comments'] = 'true'\n        if votes:\n            main['votes'] = 'true'\n        if concise:\n            main['concise'] = 'true'\n\n        main.update(filters)\n        return self._get_json('search', **main)", "response": "Search the LEX for the given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dispatch(self, request, *args, **kwargs):\n\n        self.return_url = request.GET.get('return_url', None)\n        referrer = request.META.get('HTTP_REFERER', None)\n\n        # leave alone POST and ajax requests and if return_url is explicitly left empty\n        if (request.method != \"GET\" or\n                request.is_ajax() or\n                self.return_url or\n                referrer is None or\n                self.return_url is None and 'return_url' in request.GET):\n            return super().dispatch(request, *args, **kwargs)\n\n        if not self.return_url:\n            url = request.get_full_path()\n            if url.find(\"?\") < 0:\n                url = \"?return_url=\".join((url, referrer))\n            else:\n                url = \"&return_url=\".join((url, referrer))\n            return HttpResponseRedirect(url)", "response": "This method is called by the view class to check if the user has requested a missing entry in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main(argv=None):\n\n    # If we're invoked directly (runwith ...), we'll get None here.\n    if argv is None:\n        argv = sys.argv[1:]\n\n    # Parse command-line arguments.\n    argv = cli.parse_args(argv)\n\n    # Translate CLI arguments to Popen options.\n    options = {}\n    for k in ('stdin', 'stdout', 'stderr', 'cwd'):\n        v = getattr(argv, k, None)\n        if v:\n            options[k] = v\n\n    # Start the child process.\n    try:\n        process = subprocess.Popen(\n            argv.command, **options\n        )\n    except OSError:\n        print('Invalid command %r.' % argv.command)\n        sys.exit(2)\n\n    # Wait for the child process to complete.\n    thread = threading.Thread(target=process.wait)\n    thread.start()\n    if argv.time_limit is None:\n        thread.join()\n    else:\n        thread.join(argv.time_limit.total_seconds())\n    if thread.is_alive() and argv.grace_time:\n        process.send_signal(SIGKILL)\n        thread.join(argv.grace_time.total_seconds())\n    if thread.is_alive():\n        process.terminate()\n        thread.join()\n    status = process.returncode\n    assert status is not None\n\n    # Forward exit code.\n    return status", "response": "Main entry point for the main function."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef insert(self, context):\n\t\n\t\t\"\"\"\n\t\tResolve resoures.\n\t\t\n\t\t:param resort.engine.execution.Context context:\n\t\t   Current execution context.\n\t\t\"\"\"\n\t\t\n\t\tself.__resolve(\n\t\t\tcontext,\n\t\t\tcontext.resolve(self.__source_path),\n\t\t\tcontext.resolve(self.__target_path)\n\t\t)", "response": "Insert a new entry into the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a global registry object with all the information that is not part of the main conf file.", "response": "def global_registry(self):\n        \"\"\"Global Registry\n\n\n        NOTE: Parses main conf files (/etc/fwissr/fwissr.json\n            and ~/.fwissr/fwissr.json)\n\n        then uses 'fwissr_sources' setting to setup additional sources\n\n        Example of /etc/fwissr/fwissr.json file:\n\n         {\n           'fwissr_sources': [\n             { 'filepath': '/mnt/my_app/conf/' },\n             { 'filepath': '/etc/my_app.json' },\n             { 'mongodb': 'mongodb://db1.example.net/my_app',\n                 'collection': 'config', 'refresh': true },\n           ],\n           'fwissr_refresh_period': 30,\n        }\n        access global registry with Fwissr['/foo/bar']\n        \"\"\"\n        if self._global_registry is None:\n            if 'fwissr_refresh_period' in self.main_conf:\n                result = Registry(\n                    refresh_period=self.main_conf['fwissr_refresh_period'])\n            else:\n                result = Registry()\n\n            if (os.path.exists(self.main_conf_path) or\n                    os.path.exists(self.main_user_conf_path)):\n\n                if os.path.exists(self.main_conf_path):\n                    result.add_source(\n                        Source.from_settings(\n                            {'filepath': self.main_conf_path}))\n\n                if os.path.exists(self.main_user_conf_path):\n                    result.add_source(\n                        Source.from_settings(\n                            {'filepath': self.main_user_conf_path}))\n\n                if 'fwissr_sources' in self.main_conf:\n                    for source in self.main_conf['fwissr_sources']:\n                        result.add_source(Source.from_settings(source))\n\n            self._global_registry = result\n        return self._global_registry"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget information about this node", "response": "def get(security_token=None, key=None):\n    \"\"\" Get information about this node \"\"\"\n    if security_token is None:\n        security_token = nago.core.get_my_info()['host_name']\n    data = node_data.get(security_token, {})\n    if not key:\n        return data\n    else:\n        return data.get(key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef post(node_name, key, **kwargs):\n    node = nago.core.get_node(node_name)\n    if not node:\n        raise ValueError(\"Node named %s not found\" % node_name)\n    token = node.token\n    node_data[token] = node_data[token] or {}\n    node_data[token][key] = kwargs\n    return \"thanks!\"", "response": "This function is used to store the server information about this node"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send(node_name):\n    my_data = nago.core.get_my_info()\n    if not node_name:\n        node_name = nago.settings.get('server')\n    node = nago.core.get_node(node_name)\n    json_params = {}\n    json_params['node_name'] = node_name\n    json_params['key'] = \"node_info\"\n    for k, v in my_data.items():\n        nago.core.log(\"sending %s to %s\" % (k, node['host_name']), level=\"notice\")\n        json_params[k] = v\n    return node.send_command('info', 'post', node_name=node.token, key=\"node_info\", **my_data)", "response": "Send our information to a nago instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets an object by name", "response": "def get_obj(self, vimtype, name, folder=None):\n        \"\"\"\n        Return an object by name, if name is None the\n        first found object is returned\n        \"\"\"\n        obj = None\n        content = self.service_instance.RetrieveContent()\n\n        if folder is None:\n            folder = content.rootFolder\n\n        container = content.viewManager.CreateContainerView(folder, [vimtype], True)\n        for c in container.view:\n            if c.name == name:\n                obj = c\n                break\n\n        container.Destroy()\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives the service instance si and tasks, it returns after all the tasks are complete", "response": "def wait_for_tasks(self, tasks):\n        \"\"\"Given the service instance si and tasks, it returns after all the\n       tasks are complete\n       \"\"\"\n        property_collector = self.service_instance.RetrieveContent().propertyCollector\n        task_list = [str(task) for task in tasks]\n        # Create filter\n        obj_specs = [vmodl.query.PropertyCollector.ObjectSpec(obj=task)\n                     for task in tasks]\n        property_spec = vmodl.query.PropertyCollector.PropertySpec(type=vim.Task,\n                                                                   pathSet=[],\n                                                                   all=True)\n        filter_spec = vmodl.query.PropertyCollector.FilterSpec()\n        filter_spec.objectSet = obj_specs\n        filter_spec.propSet = [property_spec]\n        pcfilter = property_collector.CreateFilter(filter_spec, True)\n        try:\n            version, state = None, None\n            # Loop looking for updates till the state moves to a completed state.\n            while len(task_list):\n                update = property_collector.WaitForUpdates(version)\n                for filter_set in update.filterSet:\n                    for obj_set in filter_set.objectSet:\n                        task = obj_set.obj\n                        for change in obj_set.changeSet:\n                            if change.name == 'info':\n                                state = change.val.state\n                            elif change.name == 'info.state':\n                                state = change.val\n                            else:\n                                continue\n\n                            if not str(task) in task_list:\n                                continue\n\n                            if state == vim.TaskInfo.State.success:\n                                # Remove task from taskList\n                                task_list.remove(str(task))\n                            elif state == vim.TaskInfo.State.error:\n                                raise task.info.error\n                # Move to next version\n                version = update.version\n        finally:\n            if pcfilter:\n                pcfilter.Destroy()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _run(self):\n        i = 0\n        try:\n            while i < len(self.program):\n                if self.program[i] == \">\":\n                    self._increment_pointer()\n                elif self.program[i] == \"<\":\n                    self._decrement_pointer()\n                elif self.program[i] == \"+\":\n                    self._increment_current_byte()\n                elif self.program[i] == \"-\":\n                    self._decrement_current_byte()\n                elif self.program[i] == \".\":\n                    self._output_current_byte()\n                elif self.program[i] == \",\":\n                    self._read_byte()\n                elif self.program[i] == \"[\":\n                    \"\"\"\n                    if the byte at the data pointer is zero, then instead of moving the instruction pointer forward to\n                    the next command, jump it forward to the command after the matching ] command\n                    - Wikipedia\n                    \"\"\"\n                    if self.tape[self.pointer] is None or self.tape[self.pointer] == 0:\n                        loop = 1\n                        while loop > 0:\n                            i += 1\n                            current_instruction = self.program[i]\n                            if current_instruction == \"]\":\n                                loop -= 1\n                            elif current_instruction == \"[\":\n                                loop += 1\n                elif self.program[i] == \"]\":\n                    \"\"\"\n                    if the byte at the data pointer is nonzero, then instead of moving the instruction pointer\n                    forward to the next command, jump it back to the command after the matching [ command.\n                    - Wikipedia\n                    \"\"\"\n                    if self.tape[self.pointer] is not None and self.tape[self.pointer] > 0:\n                        loop = 1\n                        while loop > 0:\n                            i -= 1\n                            current_instruction = self.program[i]\n                            if current_instruction == \"[\":\n                                loop -= 1\n                            elif current_instruction == \"]\":\n                                loop += 1\n                i += 1\n        except PointerOutOfProgramRange as e:\n            print e.message\n            sys.exit(1)\n        except IndexError as e:\n            print \"The program went out of bounds of its instructions\"\n            sys.exit(1)", "response": "This function runs the interpreter and returns the current interpreter s version number."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _increment_pointer(self):\n        self.pointer += 1\n        if self.pointer >= len(self.tape):\n            raise PointerOutOfProgramRange(\"Pointer exceeded right-hand bound of tape\")", "response": "Increments the internal tape counter by 1 and raises PointerOutOfProgramRange"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nincrementing the value of the current byte at the pointer.", "response": "def _increment_current_byte(self):\n        \"\"\"\n        Increments the value of the current byte at the pointer. If the result is over 255,\n        then it will overflow to 0\n        \"\"\"\n        # If the current byte is uninitialized, then incrementing it will make it 1\n        if self.tape[self.pointer] is None:\n            self.tape[self.pointer] = 1\n        elif self.tape[self.pointer] == self.MAX_CELL_SIZE:  # If the current byte is already at the max, then overflow\n            self.tape[self.pointer] = self.MIN_CELL_SIZE\n        else:  # increment it\n            self.tape[self.pointer] += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _decrement_current_byte(self):\n        # If the current byte is uninitialized, then decrementing it will make it the max cell size\n        # Otherwise, if it's already at the minimum cell size, then it will also make it the max cell size\n        if self.tape[self.pointer] is None or self.tape[self.pointer] == self.MIN_CELL_SIZE:\n            self.tape[self.pointer] = self.MAX_CELL_SIZE\n        else:  # decrement it\n            self.tape[self.pointer] -= 1", "response": "Decrements the value of the current byte at the pointer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprint out the current byte of the current TAPE.", "response": "def _output_current_byte(self):\n        \"\"\"\n        Prints out the ASCII value of the current byte\n        \"\"\"\n        if self.tape[self.pointer] is None:\n            print \"{}\".format(chr(0)),\n        else:\n            print \"{}\".format(chr(int(self.tape[self.pointer]))),"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading a single byte from the user without waiting for the \\ n character", "response": "def _read_byte(self):\n        \"\"\"\n        Read a single byte from the user without waiting for the \\n character\n        \"\"\"\n        from .getch import _Getch\n        try:\n            g = _Getch()\n            self.tape[self.pointer] = ord(g())\n        except TypeError as e:\n            print \"Here's what _Getch() is giving me {}\".format(g())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_checkerboard_matrix(kernel_width):\n\n    \"\"\"\n    example matrix for width = 2\n\n    -1  -1    1   1\n    -1  -1    1   1\n     1   1   -1  -1\n     1   1   -1  -1\n\n    :param kernel_width:\n    :return:\n    \"\"\"\n\n    return np.vstack((\n        np.hstack((\n            -1 * np.ones((kernel_width, kernel_width)), np.ones((kernel_width, kernel_width))\n        )),\n        np.hstack((\n            np.ones((kernel_width, kernel_width)), -1 * np.ones((kernel_width, kernel_width))\n        ))\n    ))", "response": "example matrix for width = 2\n\n    -1  -1    1   1\n    -1  -1    1   1\n     1   1   -1  -1\n     1   1   -1  -1\n\n    :param kernel_width:\n    :return:"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmoves the checkerboard matrix over the main diagonal of the similarity matrix one sample at a time. :param similarity_matrix: :param peak_range: the number of samples in which the peak detection algorithms finds a peak (TODO:clarify) :param kernel_width: the size of one quarter of the checkerboard matrix :return: peaks and convolution values", "response": "def checkerboard_matrix_filtering(similarity_matrix, kernel_width, peak_range):\n    \"\"\"\n    Moving the checkerboard matrix over the main diagonal of the similarity matrix one sample at a time.\n\n    :param similarity_matrix:\n    :param peak_range: the number of samples in which the peak detection algorithms finds a peak (TODO:clarify)\n    :param kernel_width: the size of one quarter of the checkerboard matrix\n    :return: peaks and convolution values\n    \"\"\"\n\n    checkerboard_matrix = get_checkerboard_matrix(kernel_width)\n\n    # The values calculated in this step are starting from the 'kernel_width' position and ending\n    # at length - kernel_width\n    d = []\n    for i in range(0, similarity_matrix.shape[0] - 2 * kernel_width):\n        base = similarity_matrix[i:i + kernel_width * 2, i:i + kernel_width * 2]\n        d.append(np.sum(np.multiply(base, checkerboard_matrix)))\n\n    # The missing values from 0 to kernel_width are calculated here\n    top_left_d = []\n    for i in range(0, kernel_width):\n        base = similarity_matrix[0:i + kernel_width, 0:i + kernel_width]\n        top_left_d.append(np.sum(np.multiply(base, checkerboard_matrix[kernel_width - i:, kernel_width - i:])))\n\n    # The missing kernel_width values at the bottom right are set to 0\n    convolution_values = top_left_d + d + [0 for i in range(0, kernel_width)]\n\n    peaks = find_peaks_cwt(convolution_values, np.arange(1, peak_range))\n    peaks = [0] + peaks + [len(convolution_values)-1]\n    return peaks, convolution_values"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef decompress(self, value):\n        if hasattr(value, \"select_related\"):\n            keywords = [a.keyword for a in value.select_related(\"keyword\")]\n            if keywords:\n                keywords = [(str(k.id), k.title) for k in keywords]\n                self._ids, words = list(zip(*keywords))\n                return (\",\".join(self._ids), \", \".join(words))\n        return (\"\", \"\")", "response": "Takes the sequence of AssignedKeyword instances and splits them into lists of keyword IDs and titles each mapping to one\n        of the form field widgets."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrap the output HTML with a list of all available Keyword instances that can be clicked on to toggle a keyword.", "response": "def format_output(self, rendered_widgets):\n        \"\"\"\n        Wraps the output HTML with a list of all available ``Keyword``\n        instances that can be clicked on to toggle a keyword.\n        \"\"\"\n        rendered = super(KeywordsWidget, self).format_output(rendered_widgets)\n        links = \"\"\n        for keyword in Keyword.objects.all().order_by(\"title\"):\n            prefix = \"+\" if str(keyword.id) not in self._ids else \"-\"\n            links += (\"<a href='#'>%s%s</a>\" % (prefix, str(keyword)))\n        rendered += mark_safe(\"<p class='keywords-field'>%s</p>\" % links)\n        return rendered"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving a new comment and sends any notification emails.", "response": "def save(self, request):\n        \"\"\"\n        Saves a new comment and sends any notification emails.\n        \"\"\"\n        comment = self.get_comment_object()\n        obj = comment.content_object\n        if request.user.is_authenticated():\n            comment.user = request.user\n        comment.by_author = request.user == getattr(obj, \"user\", None)\n        comment.ip_address = ip_for_request(request)\n        comment.replied_to_id = self.data.get(\"replied_to\")\n\n        # YaCms's duplicate check that also checks `replied_to_id`.\n        lookup = {\n            \"content_type\": comment.content_type,\n            \"object_pk\": comment.object_pk,\n            \"user_name\": comment.user_name,\n            \"user_email\": comment.user_email,\n            \"user_url\": comment.user_url,\n            \"replied_to_id\": comment.replied_to_id,\n        }\n        for duplicate in self.get_comment_model().objects.filter(**lookup):\n            if (duplicate.submit_date.date() == comment.submit_date.date() and\n                    duplicate.comment == comment.comment):\n                return duplicate\n\n        comment.save()\n        comment_was_posted.send(sender=comment.__class__, comment=comment,\n                                request=request)\n        notify_emails = split_addresses(settings.COMMENTS_NOTIFICATION_EMAILS)\n        if notify_emails:\n            subject = ugettext(\"New comment for: \") + str(obj)\n            context = {\n                \"comment\": comment,\n                \"comment_url\": add_cache_bypass(comment.get_absolute_url()),\n                \"request\": request,\n                \"obj\": obj,\n            }\n            send_mail_template(subject, \"email/comment_notification\",\n                               settings.DEFAULT_FROM_EMAIL, notify_emails,\n                               context)\n        return comment"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking unauthenticated user s cookie as a light check to prevent duplicate votes.", "response": "def clean(self):\n        \"\"\"\n        Check unauthenticated user's cookie as a light check to\n        prevent duplicate votes.\n        \"\"\"\n        bits = (self.data[\"content_type\"], self.data[\"object_pk\"])\n        request = self.request\n        self.current = \"%s.%s\" % bits\n        self.previous = request.COOKIES.get(\"yacms-rating\", \"\").split(\",\")\n        already_rated = self.current in self.previous\n        if already_rated and not self.request.user.is_authenticated():\n            raise forms.ValidationError(ugettext(\"Already rated.\"))\n        return self.cleaned_data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving a new rating for the user.", "response": "def save(self):\n        \"\"\"\n        Saves a new rating - authenticated users can update the\n        value if they've previously rated.\n        \"\"\"\n        user = self.request.user\n        self.undoing = False\n        rating_value = self.cleaned_data[\"value\"]\n        manager = self.rating_manager\n\n        if user.is_authenticated():\n            rating_instance, created = manager.get_or_create(user=user,\n                defaults={'value': rating_value})\n            if not created:\n                if rating_instance.value == int(rating_value):\n                    # User submitted the same rating as previously,\n                    # which we treat as undoing the rating (like a toggle).\n                    rating_instance.delete()\n                    self.undoing = True\n                else:\n                    rating_instance.value = rating_value\n                    rating_instance.save()\n        else:\n            rating_instance = manager.create(value=rating_value)\n        return rating_instance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_exceptions():\n    # first set up the variables needed by the _excepthook function\n    global _print_traceback, _drill\n    local_print_traceback = os.getenv(\"PYLOGCONF_PRINT_TRACEBACK\")\n    if local_print_traceback is not None:\n        _print_traceback = _str2bool(local_print_traceback)\n    local_drill = os.getenv(\"PYLOGCONF_DRILL\")\n    if local_drill is not None:\n        _drill = _str2bool(local_drill)\n    # now that everything is ready attach the hook\n    sys.excepthook = _excepthook", "response": "Set up the global variables needed by the excepthook function\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsummarizing scattering patterns and curves for all samples defined by allsamplenames.", "response": "def summarize(reintegrate=True, dist_tolerance=3, qranges=None,\n              samples=None, raw=False, late_radavg=True, graph_ncols=3,\n              std_multiplier=3, graph_extension='png',\n              graph_dpi=80, correlmatrix_colormap='coolwarm',\n              image_colormap='viridis', correlmatrix_logarithmic=True, cormaptest=True):\n    \"\"\"Summarize scattering patterns and curves for all samples defined \n    by the global `allsamplenames`.\n    \n    Inputs:\n        reintegrate (bool, default=True): if the curves are to be obained\n            by reintegrating the patterns. Otherwise 1D curves are loaded.\n        dist_tolerance (float, default=3): sample-to-detector distances\n            nearer than this are considered the same\n        qranges (dict): a dictionary mapping approximate sample-to-detector\n            distances (within dist_tolerance) to one-dimensional np.ndarrays\n            of the desired q-range of the reintegration.\n        samples (list or None): the names of the samples to summarize. If\n            None, all samples defined by ``allsamplenames`` are used.\n        raw (bool, default=False): if raw images are to be treated instead\n            the evaluated ones (default).\n        late_radavg (bool, default=True): if the scattering curves are to\n            be calculated from the summarized scattering pattern. If False,\n            scattering curves are calculated from each pattern and will be\n            averaged.\n        graph_ncols: the number of columns in graphs (2D patterns, \n            correlation matrices)\n        std_multiplier: if the absolute value of the relative discrepancy \n            is larger than this limit, the exposure is deemed an outlier.\n        graph_extension: the extension of the produced hardcopy files.\n        graph_dpi: resolution of the graphs\n        correlmatrix_colormap: name of the colormap to be used for the\n            correlation matrices (resolved by matplotlib.cm.get_cmap())\n        image_colormap: name of the colormap to be used for the scattering\n            patterns (resolved by matplotlib.cm.get_cmap())\n        correlmatrix_logarithmic: if the correlation matrix has to be\n            calculated from the logarithm of the intensity.\n    \"\"\"\n    if qranges is None:\n        qranges = {}\n    ip = get_ipython()\n    data2d = {}\n    data1d = {}\n    headers_tosave = {}\n    rowavg = {}\n    if raw:\n        writemarkdown('# Summarizing RAW images.')\n        headers = ip.user_ns['_headers']['raw']\n        rawpart = '_raw'  # this will be added in the filenames saved\n    else:\n        writemarkdown('# Summarizing CORRECTED images.')\n        headers = ip.user_ns['_headers']['processed']\n        rawpart = ''  # nothing will be added in the filenames saved\n\n    if samples is None:\n        samples = sorted(ip.user_ns['allsamplenames'])\n    for samplename in samples:\n        writemarkdown('## ' + samplename)\n        headers_sample = [h for h in headers if h.title == samplename]\n        data2d[samplename] = {}\n        rowavg[samplename] = {}\n        data1d[samplename] = {}\n        headers_tosave[samplename] = {}\n        dists = get_different_distances([h for h in headers if h.title == samplename], dist_tolerance)\n        if not dists:\n            writemarkdown('No measurements from sample, skipping.')\n            continue\n        fig_2d = plt.figure()\n        fig_curves = plt.figure()\n        fig_correlmatrices = plt.figure()\n        distaxes = {}\n        correlmatrixaxes = {}\n        ncols = min(len(dists), graph_ncols)\n        nrows = int(np.ceil(len(dists) / ncols))\n        onedimaxes = fig_curves.add_axes((0.1, 0.3, 0.8, 0.5))\n        onedimstdaxes = fig_curves.add_axes((0.1, 0.1, 0.8, 0.2))\n        for distidx, dist in enumerate(dists):\n            writemarkdown(\"### Distance \" + str(dist) + \" mm\")\n            headers_narrowed = [h for h in headers_sample if abs(float(h.distance) - dist) < dist_tolerance]\n            distaxes[dist] = fig_2d.add_subplot(\n                nrows, ncols, distidx + 1)\n            correlmatrixaxes[dist] = fig_correlmatrices.add_subplot(\n                nrows, ncols, distidx + 1)\n            # determine the q-range to be used from the qranges argument.\n            try:\n                distkey_min = min([np.abs(k - dist)\n                                   for k in qranges if np.abs(k - dist) < dist_tolerance])\n            except ValueError:\n                # no matching key in qranges dict\n                qrange = None  # request auto-determination of q-range\n            else:\n                distkey = [\n                    k for k in qranges if np.abs(k - dist) == distkey_min][0]\n                qrange = qranges[distkey]\n\n            (data1d[samplename][dist], data2d[samplename][dist], headers_tosave[samplename][dist]) = \\\n                _collect_data_for_summarization(headers_narrowed, raw, reintegrate, qrange)\n\n            badfsns, badfsns_datcmp, tab, rowavg[samplename][dist] = _stabilityassessment(\n                headers_tosave[samplename][dist],\n                data1d[samplename][dist], dist,\n                fig_correlmatrices,\n                correlmatrixaxes[dist], std_multiplier, correlmatrix_colormap,\n                os.path.join(ip.user_ns['saveto_dir'], 'correlmatrix_%s_%s' % (\n                    samplename,\n                    ('%.2f' % dist).replace('.', '_')) +\n                             rawpart + '.npz'),\n                logarithmic_correlmatrix=correlmatrix_logarithmic,\n                cormaptest=cormaptest)\n\n            if 'badfsns' not in ip.user_ns:\n                ip.user_ns['badfsns'] = {}\n            elif 'badfsns_datcmp' not in ip.user_ns:\n                ip.user_ns['badfsns_datcmp'] = {}\n            ip.user_ns['badfsns'] = set(ip.user_ns['badfsns']).union(badfsns)\n            ip.user_ns['badfsns_datcmp'] = set(ip.user_ns['badfsns_datcmp']).union(badfsns_datcmp)\n            display(tab)\n\n            # Plot the image\n            try:\n                data2d[samplename][dist].imshow(axes=distaxes[dist], show_crosshair=False,\n                                                norm=matplotlib.colors.LogNorm(),\n                                                cmap=matplotlib.cm.get_cmap(image_colormap))\n            except ValueError:\n                print('Error plotting 2D image for sample %s, distance %.2f' % (samplename, dist))\n            distaxes[dist].set_xlabel('q (' + qunit() + ')')\n            distaxes[dist].set_ylabel('q (' + qunit() + ')')\n            distaxes[dist].set_title(\n                '%.2f mm (%d curve%s)' % (dist, len(headers_tosave[samplename][dist]),\n                                          ['', 's'][len(headers_tosave[samplename][dist]) > 1]))\n\n            # Plot the curves\n            Istd = np.stack([c.Intensity for c in data1d[samplename][dist]], axis=1)\n            for c, h in zip(data1d[samplename][dist], headers_tosave[samplename][dist]):\n                color = 'green'\n                if h.fsn in badfsns_datcmp:\n                    color = 'magenta'\n                if h.fsn in badfsns:\n                    color = 'red'\n                c.loglog(axes=onedimaxes, color=color)\n            if Istd.shape[1] > 1:\n                onedimstdaxes.loglog(data1d[samplename][dist][0].q, Istd.std(axis=1) / Istd.mean(axis=1) * 100, 'b-')\n            if not late_radavg:\n                data1d[samplename][dist] = Curve.average(\n                    *data1d[samplename][dist])\n            else:\n                data1d[samplename][dist] = (\n                    data2d[samplename][dist].radial_average(\n                        qrange,\n                        errorpropagation=3,\n                        abscissa_errorpropagation=3, raw_result=False))\n            data1d[samplename][dist].loglog(\n                label='Average', lw=2, color='k', axes=onedimaxes)\n\n            ##Saving image, headers, mask and curve\n            # data2d[samplename][dist].write(\n            #    os.path.join(ip.user_ns['saveto_dir'],\n            #                 samplename + '_'+(\n            #                     '%.2f' % dist).replace('.', '_') +\n            #                 rawpart + '.npz'), plugin='CREDO Reduced')\n            # data2d[samplename][dist].header.write(\n            #    os.path.join(ip.user_ns['saveto_dir'],\n            ###                 samplename + '_'+(\n            #                     '%.2f' % dist).replace('.', '_') +\n            #                 rawpart +'.log'), plugin='CREDO Reduced')\n            # data2d[samplename][dist].mask.write_to_mat(\n            #    os.path.join(ip.user_ns['saveto_dir'],\n            #                 data2d[samplename][dist].mask.maskid+'.mat'))\n            data1d[samplename][dist].save(os.path.join(ip.user_ns['saveto_dir'],\n                                                       samplename + '_' + ('%.2f' % dist).replace('.',\n                                                                                                  '_') + rawpart + '.txt'))\n\n            # Report on qrange and flux\n            q_ = data1d[samplename][dist].q\n            qmin = q_[q_ > 0].min()\n            writemarkdown('#### Q-range & flux')\n            writemarkdown(\n                '- $q_{min}$: ' + print_abscissavalue(qmin, headers_tosave[samplename][dist][0].wavelength, dist))\n            writemarkdown('- $q_{max}$: ' + print_abscissavalue(data1d[samplename][dist].q.max(),\n                                                                headers_tosave[samplename][dist][0].wavelength, dist))\n            writemarkdown('- Number of $q$ points: ' + str(len(data1d[samplename][dist])))\n            meastime = sum([h.exposuretime for h in headers_tosave[samplename][dist]])\n            writemarkdown(\"- from %d exposures, total exposure time %.0f sec <=> %.2f hr\" % (\n                len(headers_tosave[samplename][dist]),\n                meastime, meastime / 3600.))\n            try:\n                flux = [h.flux for h in headers_tosave[samplename][dist]]\n                flux = ErrorValue(np.mean(flux), np.std(flux))\n                writemarkdown(\"- beam flux (photon/sec): %s\" % flux)\n            except KeyError:\n                writemarkdown(\"- *No information on beam flux: dealing with raw data.*\")\n        onedimaxes.set_xlabel('')\n        onedimaxes.set_ylabel('$d\\\\Sigma/d\\\\Omega$ (cm$^{-1}$ sr$^{-1}$)')\n        # plt.legend(loc='best')\n        onedimaxes.grid(True, which='both')\n        onedimaxes.axis('tight')\n        onedimaxes.set_title(samplename)\n        onedimstdaxes.set_xlabel('q (' + qunit() + ')')\n        onedimstdaxes.set_ylabel('Rel.std.dev. of intensity (%)')\n        onedimstdaxes.grid(True, which='both')\n        onedimstdaxes.set_xlim(*onedimaxes.get_xlim())\n        onedimstdaxes.set_xscale(onedimaxes.get_xscale())\n        putlogo(fig_curves)\n        putlogo(fig_2d)\n        fig_2d.tight_layout()\n        fig_correlmatrices.suptitle(samplename)\n        fig_correlmatrices.tight_layout()\n        fig_2d.savefig(\n            os.path.join(ip.user_ns['auximages_dir'],\n                         'averaging2D_' +\n                         samplename + rawpart + '.' + graph_extension),\n            dpi=graph_dpi)\n        fig_curves.savefig(\n            os.path.join(ip.user_ns['auximages_dir'],\n                         'averaging1D_' +\n                         samplename + rawpart + '.' + graph_extension),\n            dpi=graph_dpi)\n        putlogo(fig_correlmatrices)\n        fig_correlmatrices.savefig(\n            os.path.join(ip.user_ns['auximages_dir'],\n                         'correlation_' +\n                         samplename + rawpart + '.' + graph_extension),\n            dpi=graph_dpi)\n        writemarkdown(\"### Collected images from all distances\")\n        plt.show()\n    writemarkdown(\"Updated badfsns list:\")\n    writemarkdown('[' + ', '.join(str(f) for f in ip.user_ns['badfsns']) + ']')\n    writemarkdown(\"Updated badfsns list using datcmp:\")\n    writemarkdown('[' + ', '.join(str(f) for f in ip.user_ns['badfsns_datcmp']) + ']')\n    ip.user_ns['_data1d'] = data1d\n    ip.user_ns['_data2d'] = data2d\n    ip.user_ns['_headers_sample'] = headers_tosave\n    ip.user_ns['_rowavg'] = rowavg"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmerges two scattering curves.", "response": "def _merge_two_curves(curve1: Curve, curve2: Curve, qmin, qmax, qsep, use_additive_constant=False):\n    \"\"\"Merge two scattering curves\n\n    :param curve1: the first curve (longer distance)\n    :type curve1: sastool.classes.curve.GeneralCurve\n    :param curve2: the second curve (shorter distance)\n    :type curve2: sastool.classes.curve.GeneralCurve\n    :param qmin: lower bound of the interval for determining the scaling factor\n    :type qmin: float\n    :param qmax: upper bound of the interval for determining the scaling factor\n    :type qmax: float\n    :param qsep: separating (tailoring) point for the merge\n    :type qsep: float\n    :return: merged_curve, factor, background, stat\n    :rtype tuple of a sastool.classes2.curve.Curve and a float\n    \"\"\"\n    curve1=curve1.sanitize()\n    curve2=curve2.sanitize()\n    if len(curve1.trim(qmin, qmax)) > len(curve2.trim(qmin, qmax)):\n        curve2_interp = curve2.trim(qmin, qmax)\n        curve1_interp = curve1.interpolate(curve2_interp.q)\n    else:\n        curve1_interp = curve1.trim(qmin, qmax)\n        curve2_interp = curve2.interpolate(curve1_interp.q)\n    if use_additive_constant:\n        bg_init = 0\n    else:\n        bg_init = FixedParameter(0)\n    factor, bg, stat = nonlinear_odr(curve2_interp.Intensity, curve1_interp.Intensity,\n                                     curve2_interp.Error, curve1_interp.Error,\n                                     lambda x, factor, bg: x * factor + bg, [1.0, bg_init])\n    return Curve.merge(curve1 - bg, curve2 * factor, qsep), factor, bg, stat"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef subtract_bg(samplename, bgname, factor=1, distance=None, disttolerance=2,\n                subname=None, qrange=(), graph_extension='png', graph_dpi=80):\n    \"\"\"Subtract background from measurements.\n\n    Inputs:\n        samplename: the name of the sample\n        bgname: the name of the background measurements. Alternatively, it can\n            be a numeric value (float or ErrorValue), which will be subtracted.\n            If None, this constant will be determined by integrating the\n            scattering curve in the range given by qrange.\n        factor: the background curve will be multiplied by this\n        distance: if None, do the subtraction for all sample-to-detector distances.\n            Otherwise give here the value of the sample-to-detector distance.\n        qrange: a tuple (qmin, qmax)\n        disttolerance: the tolerance in which two distances are considered\n            equal.\n        subname: the sample name of the background-corrected curve. The default\n            is samplename + '-' + bgname\n    \"\"\"\n    ip = get_ipython()\n    data1d = ip.user_ns['_data1d']\n    data2d = ip.user_ns['_data2d']\n    if 'subtractedsamplenames' not in ip.user_ns:\n        ip.user_ns['subtractedsamplenames'] = set()\n    subtractedsamplenames = ip.user_ns['subtractedsamplenames']\n    if subname is None:\n        if isinstance(bgname, str):\n            subname = samplename + '-' + bgname\n        else:\n            subname = samplename + '-const'\n    if distance is None:\n        dists = data1d[samplename]\n    else:\n        dists = [d for d in data1d[samplename] if abs(d - distance) < disttolerance]\n    for dist in dists:\n        if isinstance(bgname, str):\n            if not disttolerance:\n                if dist not in data1d[bgname]:\n                    print(\n                        'Warning: Missing distance %g for background measurement (samplename: %s, background samplename: %s)' % (\n                            dist, samplename, bgname))\n                    continue\n                else:\n                    bgdist = dist\n            else:\n                bgdist = sorted([(d, r) for (d, r) in [(d, np.abs(d - dist)) for d in list(data1d[bgname].keys())] if\n                                 r <= disttolerance], key=lambda x: x[1])[0][0]\n        if subname not in data1d:\n            data1d[subname] = {}\n        if subname not in data2d:\n            data2d[subname] = {}\n        if subname not in ip.user_ns['_headers_sample']:\n            ip.user_ns['_headers_sample'][subname] = {}\n        data1_s = data1d[samplename][dist]\n        data2_s = data2d[samplename][dist]\n        if isinstance(bgname, str):\n            data1_bg = data1d[bgname][bgdist]\n            data2_bg = data2d[bgname][bgdist]\n            if factor is None:\n                factor = data1_s.trim(*qrange).momentum(0) / data1_bg.trim(*qrange).momentum(0)\n        elif bgname is None:\n            data1_bg = data1_s.trim(*qrange).momentum(0)\n            data2_bg = data1_bg\n        else:\n            data1_bg = bgname\n            data2_bg = bgname\n        if factor is None:\n            factor = 1\n        data1d[subname][dist] = data1_s - factor * data1_bg\n        data2d[subname][dist] = data2_s - factor * data2_bg\n        data1d[subname][dist].save(\n            os.path.join(ip.user_ns['saveto_dir'], subname + '_' + ('%.2f' % dist).replace('.', '_') + '.txt'))\n        ip.user_ns['_headers_sample'][subname][dist] = ip.user_ns['_headers_sample'][samplename][\n            dist]  # ugly hack, I have no better idea.\n        plt.figure()\n        plotsascurve(samplename, dist=dist)\n        if isinstance(bgname, str):\n            plotsascurve(bgname, dist=dist, factor=factor)\n        plotsascurve(subname, dist=dist)\n        plt.savefig(os.path.join(ip.user_ns['auximages_dir'],\n                                 'subtractbg_' + samplename + '.' + graph_extension),\n                    dpi=graph_dpi)\n\n        subtractedsamplenames.add(subname)", "response": "Subtracts background from the series of measurements."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write(url, content, **args):\n    with FTPResource(url, **args) as resource:\n        resource.write(content)", "response": "Put an object into a ftp URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the base64 - encoded SHA hash of a file.", "response": "def calc_sha(obj):\n    \"\"\"Calculates the base64-encoded SHA hash of a file.\"\"\"\n    try:\n        pathfile = Path(obj)\n    except UnicodeDecodeError:\n        pathfile = None\n    sha = hashlib.sha256()\n\n    try:\n        if pathfile and pathfile.exists():\n            return base64.b64encode(pathfile.read_hash('SHA256'))\n    except TypeError:\n        # likely a bytestring\n        if isinstance(obj, string_types):\n            pass\n        else:\n            raise\n\n    if isinstance(obj, string_types):\n        sha.update(obj)\n    elif hasattr(obj, 'read'):\n        while True:\n            d = obj.read(8192)\n            if not d:\n                break\n            sha.update(d)\n    else:\n        return None\n\n    r = sha.digest()\n    r = base64.b64encode(r)\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef blog_months(*args):\n    dates = BlogPost.objects.published().values_list(\"publish_date\", flat=True)\n    date_dicts = [{\"date\": datetime(d.year, d.month, 1)} for d in dates]\n    month_dicts = []\n    for date_dict in date_dicts:\n        if date_dict not in month_dicts:\n            month_dicts.append(date_dict)\n    for i, date_dict in enumerate(month_dicts):\n        month_dicts[i][\"post_count\"] = date_dicts.count(date_dict)\n    return month_dicts", "response": "Returns a list of dicts that represents the blog posts in the template context."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef blog_categories(*args):\n    posts = BlogPost.objects.published()\n    categories = BlogCategory.objects.filter(blogposts__in=posts)\n    return list(categories.annotate(post_count=Count(\"blogposts\")))", "response": "Returns a list of blog categories for blog posts."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of authors for blog posts.", "response": "def blog_authors(*args):\n    \"\"\"\n    Put a list of authors (users) for blog posts into the template context.\n    \"\"\"\n    blog_posts = BlogPost.objects.published()\n    authors = User.objects.filter(blogposts__in=blog_posts)\n    return list(authors.annotate(post_count=Count(\"blogposts\")))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef blog_recent_posts(limit=5, tag=None, username=None, category=None):\n    blog_posts = BlogPost.objects.published().select_related(\"user\")\n    title_or_slug = lambda s: Q(title=s) | Q(slug=s)\n    if tag is not None:\n        try:\n            tag = Keyword.objects.get(title_or_slug(tag))\n            blog_posts = blog_posts.filter(keywords__keyword=tag)\n        except Keyword.DoesNotExist:\n            return []\n    if category is not None:\n        try:\n            category = BlogCategory.objects.get(title_or_slug(category))\n            blog_posts = blog_posts.filter(categories=category)\n        except BlogCategory.DoesNotExist:\n            return []\n    if username is not None:\n        try:\n            author = User.objects.get(username=username)\n            blog_posts = blog_posts.filter(user=author)\n        except User.DoesNotExist:\n            return []\n    return list(blog_posts[:limit])", "response": "Returns a list of recently published blog posts in the template\n    context."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_bestfit(self):\n        self.check_important_variables()\n        logx = np.log(self.args[\"x\"])\n        logy = np.log(self.args[\"y\"])\n        self.fit_args_log = np.polyfit(logx, logy, 1)\n        self.fit_args = self.fit_args_log[:]\n        self.fit_args[1] = np.exp(self.fit_args[1])\n        self.done_bestfit = True\n        return self.fit_args", "response": "Method to get fit_args after getting necessary variables\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bestfit_func(self, bestfit_x):\n        if not self.done_bestfit:\n            raise KeyError(\"Do do_bestfit first\")\n        bestfit_y = self.fit_args[1] * (bestfit_x ** self.fit_args[0])\n        return bestfit_y", "response": "Returns bestfit_function\n            args : scalar array_like\n                x value\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef emit_contextually(self, action, payload):\n        self.dump(action, payload)\n        return g.rio_client_contextual.append((action, payload, ))", "response": "Emit on entering request context."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init():\n    \"Initialize the current directory with base starting files and database.\"\n\n    if not os.path.exists('site.cfg'):\n        f = open('site.cfg', 'w')\n        f.write(SITECFG)\n        f.close()\n\n    try:\n        os.mkdir('queries')\n    except OSError:\n        pass\n\n    try:\n        os.mkdir('templates')\n    except OSError:\n        pass\n\n    htmlfile = os.path.join('templates', 'homepage.html')\n    if not os.path.exists(htmlfile):\n        f = open(htmlfile, 'w')\n        f.write(\"\"\"\n<!doctype html>\n<html>\n    <head>\n        <title>Chill</title>\n    </head>\n    <body>\n        <p>{{ homepage_content }}</p>\n    </body>\n</html>\n        \"\"\")\n        f.close()\n\n    app = make_app(config='site.cfg', DEBUG=True)\n\n    with app.app_context():\n        app.logger.info(\"initializing database\")\n        init_db()\n\n        homepage = insert_node(name='homepage', value=None)\n        insert_route(path='/', node_id=homepage)\n        insert_query(name='select_link_node_from_node.sql', node_id=homepage)\n\n        add_template_for_node('homepage.html', homepage)\n\n        homepage_content = insert_node(name='homepage_content', value=\"Cascading, Highly Irrelevant, Lost Llamas\")\n        insert_node_node(node_id=homepage, target_node_id=homepage_content)", "response": "Initialize the current directory with base starting files and database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef operate(config):\n    \"Interface to do simple operations on the database.\"\n\n    app = make_app(config=config)\n\n    print \"Operate Mode\"\n    with app.app_context():\n        operate_menu()", "response": "Interface to do simple operations on the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(config):\n    \"Start the web server in the foreground. Don't use for production.\"\n    app = make_app(config=config)\n\n    app.run(\n            host=app.config.get(\"HOST\", '127.0.0.1'),\n            port=app.config.get(\"PORT\", 5000),\n            use_reloader=True,\n            )", "response": "Start the web server in the foreground. Don t use for production."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef serve(config):\n    \"Serve the app with Gevent\"\n    from gevent.pywsgi import WSGIServer\n\n    app = make_app(config=config)\n\n    host = app.config.get(\"HOST\", '127.0.0.1')\n    port = app.config.get(\"PORT\", 5000)\n    http_server = WSGIServer((host, port), app)\n    http_server.serve_forever()", "response": "Serve the app with Gevent"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfreezing the application by creating a static version of it.", "response": "def freeze(config, urls_file=None):\n    \"\"\"Freeze the application by creating a static version of it.\"\"\"\n    if urls_file:\n        app = make_app(config=config, URLS_FILE=urls_file)\n    else:\n        app = make_app(config=config)\n    app.logger.info('freezing app to directory: %s' % app.config['FREEZER_DESTINATION'])\n    freezer = Freezer(app)\n\n\n    #@freezer.register_generator\n    #def index_page():\n    #    for (dirpath, dirnames, filenames) in os.walk(app.config['DATA_PATH'], topdown=True):\n    #        start = len(os.path.commonprefix((app.config['DATA_PATH'], dirpath)))\n    #        relative_path = dirpath[start+1:]\n    #        for dirname in dirnames:\n    #            yield ('page.index_page', {'uri': os.path.join(relative_path, dirname)})\n\n    #@freezer.register_generator\n    #def page_uri():\n    #    # uri_index will be used so just avoid showing a warning\n    #    return [\n    #            ('public.page_uri', {'uri': ''}),\n    #            ]\n    @freezer.register_generator\n    def uri_index():\n        def cleanup_url(url):\n            url = url.strip()\n            if url.startswith('/'):\n                if url.endswith('/index.html'):\n                    return url\n                elif url.endswith('/'):\n                    url = url.strip('/')\n                    if len(url) == 0:\n                        return ('public.index', {})\n                    return ('public.uri_index', {'uri': url})\n\n        try:\n            result = db.execute(text(fetch_query_string('select_paths_to_freeze.sql'))).fetchall()\n        except (DatabaseError, StatementError) as err:\n            app.logger.error(\"DatabaseError: %s\", err)\n            return []\n        urls = filter(None, map(lambda x:cleanup_url(x[0]), result))\n\n        urls_file = app.config.get('URLS_FILE', None)\n        if urls_file:\n            urls_file = urls_file if urls_file[0] == os.sep else os.path.join(os.getcwd(), urls_file)\n            f = open(urls_file, 'r')\n            urls.extend(filter(None, map(cleanup_url, f.readlines())))\n            f.close()\n\n        return urls\n\n\n    @freezer.register_generator\n    def send_root_file():\n        root_folder = app.config.get('ROOT_FOLDER', None)\n        if root_folder and os.path.isdir( root_folder ):\n            for (dirpath, dirnames, filenames) in os.walk(root_folder, topdown=True):\n                start = len(os.path.commonprefix((root_folder, dirpath)))\n                relative_path = dirpath[start+1:]\n                for filename in filenames:\n                    yield ('send_root_file', {\n                            'filename': os.path.join(relative_path, filename)\n                            })\n\n    @freezer.register_generator\n    def send_media_file():\n        media_folder = app.config.get('MEDIA_FOLDER', None)\n        media_path = app.config.get('MEDIA_PATH', '/media/')\n        freeze_all_files = app.config.get('MEDIA_FREEZE_ALL', False)\n        if media_folder and freeze_all_files and os.path.isdir( media_folder ) and media_path[0] == '/':\n            for (dirpath, dirnames, filenames) in os.walk(media_folder, topdown=True):\n                start = len(os.path.commonprefix((media_folder, dirpath)))\n                relative_path = dirpath[start+1:]\n                for filename in filenames:\n                    yield ('send_media_file', {\n                            'filename': os.path.join(relative_path, filename)\n                            })\n\n    @freezer.register_generator\n    def send_theme_file():\n        theme_static_folder = app.config.get('THEME_STATIC_FOLDER', None)\n        theme_static_path = app.config.get('THEME_STATIC_PATH', '/theme/')\n        if theme_static_folder and os.path.isdir( theme_static_folder ) and theme_static_path[0] == '/':\n            for (dirpath, dirnames, filenames) in os.walk(theme_static_folder, topdown=True):\n                start = len(os.path.commonprefix((theme_static_folder, dirpath)))\n                relative_path = dirpath[start+1:]\n                for filename in filenames:\n                    yield ('send_theme_file', {\n                            'filename': os.path.join(relative_path, filename)\n                            })\n\n\n    freezer.freeze()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert to mIRC color Code", "response": "def to_irc(self) -> int:\n        \"\"\"\n        Convert to mIRC color Code\n        :return: IRC color code\n        \"\"\"\n        d = {\n            (self.BLACK, True): 14,\n            (self.BLACK, False): 1,\n            (self.RED, True): 4,\n            (self.RED, False): 5,\n            (self.GREEN, True): 9,\n            (self.GREEN, False): 3,\n            (self.YELLOW, True): 8,\n            (self.YELLOW, False): 7,\n            (self.BLUE, True): 12,\n            (self.BLUE, False): 2,\n            (self.MAGENTA, True): 13,\n            (self.MAGENTA, False): 6,\n            (self.CYAN, True): 11,\n            (self.CYAN, False): 10,\n            (self.WHITE, True): 0,\n            (self.WHITE, False): 15\n        }\n        return d[(self.color, self.bright)]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert to ANSI color name.", "response": "def to_name(self) -> str:\n        \"\"\"\n        Convert to ANSI color name\n        :return: ANSI color name\n        \"\"\"\n        return {\n            self.BLACK: 'black',\n            self.RED: 'red',\n            self.GREEN: 'green',\n            self.YELLOW: 'yellow',\n            self.BLUE: 'blue',\n            self.MAGENTA: 'magenta',\n            self.CYAN: 'cyan',\n            self.WHITE: 'white'\n        }[self.color]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef scale(self, new_max_value=1):\n        f = new_max_value / self.max\n        return ColorRGB(self.r * f,\n                        self.g * f,\n                        self.b * f,\n                        max_value=new_max_value)", "response": "Scale R G and B parameters."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting the color in the log2 file to 8 - bit color.", "response": "def to_8bit(self):\n        \"\"\"\n        Convert to 8-bit color\n        :return: Color8Bit instance\n        \"\"\"\n        h, s, v = colorsys.rgb_to_hsv(*self.scale(1))\n        # Check if the color is a shade of grey\n        if s * v < 0.3:\n            if v < 0.3:\n                return Color8Bit(Color8Bit.BLACK, False)\n            elif v < 0.66:\n                return Color8Bit(Color8Bit.BLACK, True)\n            elif v < 0.91:\n                return Color8Bit(Color8Bit.WHITE, False)\n            else:\n                return Color8Bit(Color8Bit.WHITE, True)\n        # not grey? What color is it then?\n        if h < 0.041 or h > 0.92:\n            res = Color8Bit.RED\n        elif h < 0.11:\n            # orange = dark yellow\n            return Color8Bit(Color8Bit.YELLOW, False)\n        elif h < 0.2:\n            res = Color8Bit.YELLOW\n        elif h < 0.45:\n            res = Color8Bit.GREEN\n        elif h < 0.6:\n            res = Color8Bit.CYAN\n        elif h < 0.74:\n            res = Color8Bit.BLUE\n        else:\n            res = Color8Bit.MAGENTA\n        return Color8Bit(res, v > 0.6)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_dp(self):\n        text = self.text.replace('^', '^^')\n        return '%s%s' % (self.color.to_dp(), text)", "response": "Convert to darkplaces color format\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_irc(self):\n        ignore_re = re.compile('[\\x03\\x02\\x1D\\x1F\\x16\\x0F]')\n        text = ignore_re.sub('', self.text)\n        if self.color and self.bg_color:\n            return '\\x03%02d,%02d%s' % (self.color.to_8bit().to_irc(),\n                                        self.bg_color.to_8bit().to_irc(),\n                                        text)\n        elif self.color:\n            c = self.color.to_8bit()\n            if c.is_color():\n                return '\\x03%02d%s' % (c.to_irc(), text)\n            else:\n                return '\\x03\\x0f' + text\n        elif self.bg_color:\n            return '\\x0301,%02d%s' % (self.bg_color.to_8bit().to_irc(), text)\n        else:\n            return '\\x03\\x0f' + text", "response": "Convert the log entry to mIRC color format."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_ansi_8bit(self):\n        text = self.text.replace('\\x1b', '')\n        if self.color and self.bg_color:\n            c = self.color.to_8bit()\n            return ansicolor(text,\n                             fg=c.to_name(),\n                             bg=self.bg_color.to_8bit().to_name(),\n                             style=c.bright and 'bold' or None)\n        elif self.color:\n            c = self.color.to_8bit()\n            return ansicolor(text,\n                             fg=c.is_color() and c.to_name(),\n                             style=c.bright and 'bold' or None)\n        elif self.bg_color:\n            return ansicolor(text,\n                             bg=self.bg_color.to_8bit().to_name())\n        else:\n            return text", "response": "Convert the log entry to ANSI 8 - bit color format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_ansi_24bit(self):\n        text = self.text.replace('\\x1b', '')\n        if self.color and self.bg_color:\n            c = self.color.scale(255)\n            bg_c = self.bg_color.scale(255)\n            return ansicolor(text,\n                             fg=(c.r, c.g, c.b),\n                             bg=(bg_c.r, bg_c.g, bg_c.b))\n        elif self.color:\n            c = self.color.scale(255)\n            return ansicolor(text,\n                             fg=(c.r, c.g, c.b))\n        elif self.bg_color:\n            bg_c = self.bg_color.scale(255)\n            return ansicolor(text,\n                             bg=(bg_c.r, bg_c.g, bg_c.b))\n        else:\n            return text", "response": "Convert to ANSI 24 - bit color format."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_dp(cls, text, use_unicode_for_glyphs=True):\n        from .grammars.dp import parse as parse_dp\n        if isinstance(text, bytes):\n            original_bytes = text\n            text = text.decode('utf8')\n        else:\n            original_bytes = text.encode('utf8')\n        instance = parse_dp(text, use_unicode_for_glyphs=use_unicode_for_glyphs)\n        instance.original_type = 'dp'\n        instance.original_bytes = original_bytes\n        return instance", "response": "Create a new instance of ColorString from a darkplaces - formatted text string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_irc(cls, text):\n        from .grammars.irc import parse as parse_irc\n        if isinstance(text, bytes):\n            original_bytes = text\n            text = text.decode('utf8')\n        else:\n            original_bytes = text.encode('utf8')\n        instance = parse_irc(text)\n        instance.original_type = 'irc'\n        instance.original_bytes = original_bytes\n        return instance", "response": "Create a new instance of ColorString from a mIRC - formatted text."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_irc(self, preserve_original=True):\n        if preserve_original and self.original_type == 'irc':\n            return self.original_bytes\n        res = []\n        for i in self.parts:\n            res.append(i.to_irc())\n        s = ''.join(res) + '\\x03\\x0f'\n        return s.encode('utf8')", "response": "Convert the current ColorString instance to mIRC format"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_ansi_8bit(self):\n        res = []\n        for i in self.parts:\n            res.append(i.to_ansi_8bit())\n        return ''.join(res).encode('utf8')", "response": "Convert the log entry to ANSI 8 - bit format."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_ansi_24bit(self):\n        res = []\n        for i in self.parts:\n            res.append(i.to_ansi_24bit())\n        return ''.join(res).encode('utf8')", "response": "Convert the log entry to ANSI 24 - bit format."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dispatch(self, event):\n        if event.is_directory:\n            return\n        paths = []\n        if has_attribute(event, 'dest_path'):\n            paths.append(os.path.realpath(\n                unicode_paths.decode(event.dest_path)))\n        if event.src_path:\n            paths.append(os.path.realpath(\n                unicode_paths.decode(event.src_path)))\n        paths = [p for p in paths\n                 if not p.startswith(os.path.realpath(self.vcs.repository_dir()))\n                 and not self.vcs.path_is_ignored(p)]\n\n        if len(paths) > 0:\n            super(VcsEventHandler, self).dispatch(event)", "response": "Only dispatch if the event does not correspond to an ignored file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a string with a German formated date DD. MM. YYYY to Datetime objects", "response": "def clean_german_date(x):\n    \"\"\"Convert a string with a German date 'DD.MM.YYYY' to Datetime objects\n\n    Parameters\n    ----------\n    x : str, list, tuple, numpy.ndarray, pandas.DataFrame\n        A string with a German formated date,\n        or an array of these strings, e.g. list, ndarray, df.\n\n    Returns\n    -------\n    y : str, list, tuple, numpy.ndarray, pandas.DataFrame\n        A datetime object or array of datetime objects.\n\n    Example\n    -------\n    The function aims to convert a string as follows\n\n        '23.09.2012'  => datetime(2012, 9, 23, 0, 0)\n\n    Code Example\n    ------------\n        print(clean_german_date('23.09.2012'))\n\n    Behavior\n    --------\n    - If it is not a string with date format 'DD.MM.YYYY' then None is returned\n\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n    from datetime import datetime\n\n    def proc_elem(e):\n        try:\n            return datetime.strptime(e, '%d.%m.%Y')\n        except Exception as e:\n            print(e)\n            return None\n\n    def proc_list(x):\n        return [proc_elem(e) for e in x]\n\n    def proc_ndarray(x):\n        tmp = proc_list(list(x.reshape((x.size,))))\n        return np.array(tmp).reshape(x.shape)\n\n    # transform string, list/tuple, numpy array, pandas dataframe\n    if isinstance(x, str):\n        return proc_elem(x)\n    elif isinstance(x, (list, tuple)):\n        return proc_list(x)\n    elif isinstance(x, np.ndarray):\n        return proc_ndarray(x)\n    elif isinstance(x, pd.DataFrame):\n        return pd.DataFrame(proc_ndarray(x.values),\n                            columns=x.columns,\n                            index=x.index)\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mro(*bases):\n    seqs = [list(C.__mro__) for C in bases] + [list(bases)]\n    res = []\n    while True:\n        non_empty = list(filter(None, seqs))\n        if not non_empty:\n            # Nothing left to process, we're done.\n            return tuple(res)\n        for seq in non_empty:  # Find merge candidates among seq heads.\n            candidate = seq[0]\n            not_head = [s for s in non_empty if candidate in s[1:]]\n            if not_head:\n                # Reject the candidate.\n                candidate = None\n            else:\n                break\n        if not candidate:\n            raise TypeError(\"inconsistent hierarchy, no C3 MRO is possible\")\n        res.append(candidate)\n        for seq in non_empty:\n            # Remove candidate.\n            if seq[0] == candidate:\n                del seq[0]", "response": "This function calculates the Method Resolution Order of a class K."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _copy_ancestor_docstring(mro_list, func):  # pylint: disable=W0613\n    if func.__doc__ is not None:\n        raise RuntimeError('Function already has docstring')\n    # Search for docstring in superclass\n    for cls in mro_list:\n        super_fn = getattr(cls, func.__name__, None)\n        if super_fn is None:\n            continue\n        func.__doc__ = super_fn.__doc__\n        break\n    else:\n        raise RuntimeError(\"Can't inherit docstring for %s: method does not \"\n                           \"exist in superclass\" % func.__name__)\n    return func", "response": "Decorator to set docstring for func from mro_list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef printlog(self, string, verbose=None, flush=False):\n        if self.writelog:\n            self.logger.info(string)\n        if verbose or (self.verbose and verbose is None):\n            print(string, flush=flush)", "response": "Prints the given string to a logfile if logging is on and to\n        screen if verbosity is on."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef exception(self, exception):\n        if self.writelog:\n            self.logger.exception(exception)\n        if self.verbose:\n            for line in  traceback.format_exception(\n                    None, exception, exception.__traceback__):\n                print(line, end='', file=sys.stderr, flush=True)", "response": "Prints the stacktrace of the given exception."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tqdm(self, iterable, **kwargs):\n        if 'disable' in kwargs:\n            kwargs.pop('disable')\n        return tqdm(iterable, disable=not self.verbose, **kwargs)", "response": "Wraps the given iterable with a tqdm progress bar."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprocessing data and trigger raw - data - received event", "response": "def process_data(self):\n\n        \"\"\"\n        Process data\n\n        Triggers raw-data-received event\n        \"\"\"\n        self.trigger(\"process-data\", self.received_data)\n        self.received_data = \"\"\n        if self.dispatcher:\n            self.time = self.dispatcher.time"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef respond(self, data):\n\n        self.push(\"%s%s\" % (data, TERMINATOR))\n        if self.temporary:\n            self.close_when_done()", "response": "Respond to the connection accepted in this object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef text(self, text):\n        '''\n        .. seealso:: :attr:`text`\n        '''\n\n        if text:\n            if not isinstance(text, str):\n                text = _pformat(text)\n            text += '\\n\\n'\n            self.m(\n                'add text to mail',\n                more=dict(len=len(text))\n            )\n            self.__message.attach(_MIMEText(text, 'plain', 'UTF-8'))", "response": "add text to the message"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send(self):\n        '''\n        :returns:\n            A dictionary with the following:\n\n            * 'sender': The `sender`\n            * 'recipients': All recipients, compiled from `to`, `cc` and `bcc`\n            * 'result': The :py:meth:`smtplib.SMTP.sendmail`-result\n            * 'exception': The exception message (if any)\n\n        .. note::\n            You need to have a postfix/sendmail running\n            and listening on localhost.\n        '''\n\n        res = dict(sender=self.__sender, recipients=self.__recipients)\n        try:\n            s = _SMTP()\n            s.connect('localhost')\n            res.update(dict(\n                result=s.sendmail(self.__sender, self.__recipients, self.text)\n            ))\n            self.m('mail sent', more=res)\n        except (_SMTPException, _error) as ex:\n            res.update(dict(\n                exception=str(ex)\n            ))\n            self.m('error sending mail', verbose=True, more=res)\n        return res", "response": "Sends the message to the specified recipients and returns a dictionary with the result and exception messages."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef participant_policy(self, value):\n        old_policy = self.participant_policy\n        new_policy = value\n        self._participant_policy = new_policy\n        notify(ParticipationPolicyChangedEvent(self, old_policy, new_policy))", "response": "Changing participation policy fires a\n        ParticipationPolicyChanged event"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef define_constrained_subtype(prefix, base, blockednames, clsdict=None):\n    name = prefix + base.__name__\n\n    clsdict = clsdict or {}\n\n    doc = clsdict.get('__doc__', '')\n    doc = 'An {} extension of {}.\\n{}'.format(prefix, base.__name__, doc)\n    clsdict['__doc__'] = doc\n\n    setitem_without_overwrite(\n        clsdict,\n        'get_blocked_method_names',\n        lambda self: iter(blockednames),\n    )\n\n    for bname in blockednames:\n        setitem_without_overwrite(\n            clsdict,\n            bname,\n            ConstraintError.block(getattr(base, bname)),\n        )\n\n    return type(name, (base,), clsdict)", "response": "Define a subtype which blocks a list of methods."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting a key value pair in a node s node list without overwriting any existing value.", "response": "def setitem_without_overwrite(d, key, value):\n    \"\"\"\n    @param d: An instance of dict, that is: isinstance(d, dict)\n    @param key: a key\n    @param value: a value to associate with the key\n\n    @return: None\n\n    @raise: OverwriteError if the key is already present in d.\n    \"\"\"\n    if key in d:\n        raise OverwriteError(key, value, d[key])\n    else:\n        dict.__setitem__(d, key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef preprocess(string):\n    string = unicode(string, encoding=\"utf-8\")\n    return regex.sub('', string).encode('utf-8')", "response": "Preprocess string to transform all diacritics and remove other special characters than appropriate\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nberry curvature. :param k: Momentum :math:`k`. :type k: float :param n: Band index :math:`n = \u00b11`. :type n: int :param \u03c4: Valley index :math:`\u03c4 = \u00b11`. :type \u03c4: int :param \u03c3: Spin index :math:`\u03c3 = \u00b11`. :type \u03c3: int :return: :math:`\u03a9^n_{\u03c4 \u03c3} (k)` :rtype: float", "response": "def \u03a9(self, k, n, \u03c4, \u03c3):\n        \"\"\"Berry curvature.\n        :param k: Momentum :math:`k`.\n        :type k: float\n\n        :param n: Band index :math:`n = \u00b11`.\n        :type n: int\n\n        :param \u03c4: Valley index :math:`\u03c4 = \u00b11`.\n        :type \u03c4: int\n\n        :param \u03c3: Spin index :math:`\u03c3 = \u00b11`.\n        :type \u03c3: int\n\n        :return: :math:`\u03a9^n_{\u03c4 \u03c3} (k)`\n        :rtype: float\n        \"\"\"\n        d = self._dichalcogenide\n        at, \u0394, \u03bb = d.at, d.\u0394, d.\u03bb\n        x = \u0394 - \u03bb * \u03c4 * \u03c3\n        y = (2 * at * k)**2 + x**2\n        return -2 * (n * \u03c4 * at**2) * x * y**(-3/2)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _step(self):\n        try:\n            new_value = self._device.get(self._channel)\n            if new_value != self._value:\n                self._callback(new_value)\n                self._value = new_value\n            time.sleep(self._polling_time)\n        except:\n            self.spine.log.exception(\"_PollingThread\")", "response": "Private method do not call it directly override it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a post to the list of post objects.", "response": "def add_post(self, title=None, content=None, old_url=None, pub_date=None,\n                 tags=None, categories=None, comments=None):\n        \"\"\"\n        Adds a post to the post list for processing.\n\n        - ``title`` and ``content`` are strings for the post.\n        - ``old_url`` is a string that a redirect will be created for.\n        - ``pub_date`` is assumed to be a ``datetime`` object.\n        - ``tags`` and ``categories`` are sequences of strings.\n        - ``comments`` is a sequence of dicts - each dict should be the\n          return value of ``add_comment``.\n        \"\"\"\n        if not title:\n            title = strip_tags(content).split(\". \")[0]\n        title = decode_entities(title)\n        if categories is None:\n            categories = []\n        if tags is None:\n            tags = []\n        if comments is None:\n            comments = []\n        self.posts.append({\n            \"title\": force_text(title),\n            \"publish_date\": pub_date,\n            \"content\": force_text(content),\n            \"categories\": categories,\n            \"tags\": tags,\n            \"comments\": comments,\n            \"old_url\": old_url,\n        })\n        return self.posts[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a page to the list of pages to be imported.", "response": "def add_page(self, title=None, content=None, old_url=None,\n                 tags=None, old_id=None, old_parent_id=None):\n        \"\"\"\n        Adds a page to the list of pages to be imported - used by the\n        Wordpress importer.\n        \"\"\"\n        if not title:\n            text = decode_entities(strip_tags(content)).replace(\"\\n\", \" \")\n            title = text.split(\". \")[0]\n        if tags is None:\n            tags = []\n        self.pages.append({\n            \"title\": title,\n            \"content\": content,\n            \"tags\": tags,\n            \"old_url\": old_url,\n            \"old_id\": old_id,\n            \"old_parent_id\": old_parent_id,\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a comment to the post provided.", "response": "def add_comment(self, post=None, name=None, email=None, pub_date=None,\n                    website=None, body=None):\n        \"\"\"\n        Adds a comment to the post provided.\n        \"\"\"\n        if post is None:\n            if not self.posts:\n                raise CommandError(\"Cannot add comments without posts\")\n            post = self.posts[-1]\n        post[\"comments\"].append({\n            \"user_name\": name,\n            \"user_email\": email,\n            \"submit_date\": pub_date,\n            \"user_url\": website,\n            \"comment\": body,\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef trunc(self, model, prompt, **fields):\n        for field_name, value in fields.items():\n            field = model._meta.get_field(field_name)\n            max_length = getattr(field, \"max_length\", None)\n            if not max_length:\n                continue\n            elif not prompt:\n                fields[field_name] = value[:max_length]\n                continue\n            while len(value) > max_length:\n                encoded_value = value.encode(\"utf-8\")\n                new_value = input(\"The value for the field %s.%s exceeds \"\n                    \"its maximum length of %s chars: %s\\n\\nEnter a new value \"\n                    \"for it, or press return to have it truncated: \" %\n                    (model.__name__, field_name, max_length, encoded_value))\n                value = new_value if new_value else value[:max_length]\n            fields[field_name] = value\n        return fields", "response": "Truncates fields values for the given model. Prompts for a new value for that value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles the import and save the data into the database correctly.", "response": "def handle(self, *args, **options):\n        \"\"\"\n        Processes the converted data into the yacms database correctly.\n\n        Attributes:\n            yacms_user: the user to put this data in against\n            date_format: the format the dates are in for posts and comments\n        \"\"\"\n\n        yacms_user = options.get(\"yacms_user\")\n        site = Site.objects.get_current()\n        verbosity = int(options.get(\"verbosity\", 1))\n        prompt = options.get(\"interactive\")\n\n        # Validate the yacms user.\n        if yacms_user is None:\n            raise CommandError(\"No yacms user has been specified\")\n        try:\n            yacms_user = User.objects.get(username=yacms_user)\n        except User.DoesNotExist:\n            raise CommandError(\"Invalid yacms user: %s\" % yacms_user)\n\n        # Run the subclassed ``handle_import`` and save posts, tags,\n        # categories, and comments to the DB.\n        self.handle_import(options)\n        for post_data in self.posts:\n            categories = post_data.pop(\"categories\")\n            tags = post_data.pop(\"tags\")\n            comments = post_data.pop(\"comments\")\n            old_url = post_data.pop(\"old_url\")\n            post_data = self.trunc(BlogPost, prompt, **post_data)\n            initial = {\n                \"title\": post_data.pop(\"title\"),\n                \"user\": yacms_user,\n            }\n            if post_data[\"publish_date\"] is None:\n                post_data[\"status\"] = CONTENT_STATUS_DRAFT\n            post, created = BlogPost.objects.get_or_create(**initial)\n            for k, v in post_data.items():\n                setattr(post, k, v)\n            post.save()\n            if created and verbosity >= 1:\n                print(\"Imported post: %s\" % post)\n            for name in categories:\n                cat = self.trunc(BlogCategory, prompt, title=name)\n                if not cat[\"title\"]:\n                    continue\n                cat, created = BlogCategory.objects.get_or_create(**cat)\n                if created and verbosity >= 1:\n                    print(\"Imported category: %s\" % cat)\n                post.categories.add(cat)\n            for comment in comments:\n                comment = self.trunc(ThreadedComment, prompt, **comment)\n                comment[\"site\"] = site\n                post.comments.create(**comment)\n                if verbosity >= 1:\n                    print(\"Imported comment by: %s\" % comment[\"user_name\"])\n            self.add_meta(post, tags, prompt, verbosity, old_url)\n\n        # Create any pages imported (Wordpress can include pages)\n        in_menus = []\n        footer = [menu[0] for menu in settings.PAGE_MENU_TEMPLATES\n                  if menu[-1] == \"pages/menus/footer.html\"]\n        if options[\"in_navigation\"]:\n            in_menus = [menu[0] for menu in settings.PAGE_MENU_TEMPLATES]\n            if footer and not options[\"in_footer\"]:\n                in_menus.remove(footer[0])\n        elif footer and options[\"in_footer\"]:\n            in_menus = footer\n        parents = []\n        for page in self.pages:\n            tags = page.pop(\"tags\")\n            old_url = page.pop(\"old_url\")\n            old_id = page.pop(\"old_id\")\n            old_parent_id = page.pop(\"old_parent_id\")\n            page = self.trunc(RichTextPage, prompt, **page)\n            page[\"status\"] = CONTENT_STATUS_PUBLISHED\n            page[\"in_menus\"] = in_menus\n            page, created = RichTextPage.objects.get_or_create(**page)\n            if created and verbosity >= 1:\n                print(\"Imported page: %s\" % page)\n            self.add_meta(page, tags, prompt, verbosity, old_url)\n            parents.append({\n                'old_id': old_id,\n                'old_parent_id': old_parent_id,\n                'page': page,\n            })\n\n        for obj in parents:\n            if obj['old_parent_id']:\n                for parent in parents:\n                    if parent['old_id'] == obj['old_parent_id']:\n                        obj['page'].parent = parent['page']\n                        obj['page'].save()\n                        break"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_meta(self, obj, tags, prompt, verbosity, old_url=None):\n        for tag in tags:\n            keyword = self.trunc(Keyword, prompt, title=tag)\n            keyword, created = Keyword.objects.get_or_create_iexact(**keyword)\n            obj.keywords.create(keyword=keyword)\n            if created and verbosity >= 1:\n                print(\"Imported tag: %s\" % keyword)\n        if old_url is not None:\n            old_path = urlparse(old_url).path\n            if not old_path.strip(\"/\"):\n                return\n            redirect = self.trunc(Redirect, prompt, old_path=old_path)\n            redirect['site'] = Site.objects.get_current()\n            redirect, created = Redirect.objects.get_or_create(**redirect)\n            redirect.new_path = obj.get_absolute_url()\n            redirect.save()\n            if created and verbosity >= 1:\n                print(\"Created redirect for: %s\" % old_url)", "response": "Adds tags and a redirect for the given obj."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef smart_content_type_for_model(model):\n    try:\n        # noinspection PyPackageRequirements,PyUnresolvedReferences\n        from django.contrib.contenttypes.models import ContentType\n    except ImportError:\n        print(\"Django is required but cannot be imported.\")\n        raise\n\n    if model._meta.proxy:\n        return ContentType.objects.get(app_label=model._meta.app_label,\n                                       model=model._meta.object_name.lower())\n    else:\n        return ContentType.objects.get_for_model(model)", "response": "Returns the Django ContentType for a given model."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the first content of the first element in el_list or alt. Also return alt if the content string of first element is blank.", "response": "def get_first_content(el_list, alt=None, strip=True):\n    \"\"\"\n    Return content of the first element in `el_list` or `alt`. Also return `alt`\n    if the content string of first element is blank.\n\n    Args:\n        el_list (list): List of HTMLElement objects.\n        alt (default None): Value returner when list or content is blank.\n        strip (bool, default True): Call .strip() to content.\n\n    Returns:\n        str or alt: String representation of the content of the first element \\\n                    or `alt` if not found.\n    \"\"\"\n    if not el_list:\n        return alt\n\n    content = el_list[0].getContent()\n\n    if strip:\n        content = content.strip()\n\n    if not content:\n        return alt\n\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests whether url is absolute url.", "response": "def is_absolute_url(url, protocol=\"http\"):\n    \"\"\"\n    Test whether `url` is absolute url (``http://domain.tld/something``) or\n    relative (``../something``).\n\n    Args:\n        url (str): Tested string.\n        protocol (str, default \"http\"): Protocol which will be seek at the\n                 beginning of the `url`.\n\n    Returns:\n        bool: True if url is absolute, False if not.\n    \"\"\"\n    if \":\" not in url:\n        return False\n\n    protocol, rest = url.split(\":\", 1)\n\n    if protocol.startswith(protocol) and rest.startswith(\"//\"):\n        return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nnormalizing the url - from relative create absolute URL.", "response": "def normalize_url(base_url, rel_url):\n    \"\"\"\n    Normalize the `url` - from relative, create absolute URL.\n\n    Args:\n        base_url (str): Domain with ``protocol://`` string\n        rel_url (str): Relative or absolute url.\n\n    Returns:\n        str/None: Normalized URL or None if `url` is blank.\n    \"\"\"\n    if not rel_url:\n        return None\n\n    if not is_absolute_url(rel_url):\n        rel_url = rel_url.replace(\"../\", \"/\")\n\n        if (not base_url.endswith(\"/\")) and (not rel_url.startswith(\"/\")):\n            return base_url + \"/\" + rel_url.replace(\"../\", \"/\")\n\n        return base_url + rel_url.replace(\"../\", \"/\")\n\n    return rel_url"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef has_param(param):\n    def has_param_closure(element):\n        \"\"\"\n        Look for `param` in `element`.\n        \"\"\"\n        if element.params.get(param, \"\").strip():\n            return True\n\n        return False\n\n    return has_param_closure", "response": "Generate function which will check if param is in html element."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates function which checks if given element contains tag_name with tag_content and also another tag named container_tag_name.", "response": "def must_contain(tag_name, tag_content, container_tag_name):\n    \"\"\"\n    Generate function, which checks if given element contains `tag_name` with\n    string content `tag_content` and also another tag named\n    `container_tag_name`.\n\n    This function can be used as parameter for .find() method in HTMLElement.\n    \"\"\"\n    def must_contain_closure(element):\n        # containing in first level of childs <tag_name> tag\n        matching_tags = element.match(tag_name, absolute=True)\n        if not matching_tags:\n            return False\n\n        # which's content match `tag_content`\n        if matching_tags[0].getContent() != tag_content:\n            return False\n\n        # and also contains <container_tag_name> tag\n        if container_tag_name and \\\n           not element.match(container_tag_name, absolute=True):\n            return False\n\n        return True\n\n    return must_contain_closure"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating function which checks whether the content of the tag matches the content of the whole DOM.", "response": "def content_matchs(tag_content, content_transformer=None):\n    \"\"\"\n    Generate function, which checks whether the content of the tag matchs\n    `tag_content`.\n\n    Args:\n        tag_content (str): Content of the tag which will be matched thru whole\n                           DOM.\n        content_transformer (fn, default None): Function used to transform all\n                            tags before matching.\n\n    This function can be used as parameter for .find() method in HTMLElement.\n    \"\"\"\n    def content_matchs_closure(element):\n        if not element.isTag():\n            return False\n\n        cont = element.getContent()\n        if content_transformer:\n            cont = content_transformer(cont)\n\n        return tag_content == cont\n\n    return content_matchs_closure"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _sendPostDict(post_dict):\n    downer = Downloader()\n    downer.headers[\"Referer\"] = settings.EDEPOSIT_EXPORT_REFERER\n    data = downer.download(settings.ALEPH_EXPORT_URL, post=post_dict)\n    rheaders = downer.response_headers\n\n    error_msg = rheaders.get(\"aleph-info\", \"\").lower().strip()\n    if \"aleph-info\" in rheaders and error_msg.startswith(\"error\"):\n        raise ExportRejectedException(\n            \"Export request was rejected by import webform: %s\" %\n            rheaders[\"aleph-info\"]\n        )\n\n    return data", "response": "Send a dictionary to the ALEPH_EXPORT_URL."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _removeSpecialCharacters(epub):\n    special_chars = \"/:,- \"\n\n    epub_dict = epub._asdict()\n\n    for key in epub_dict.keys():\n        if isinstance(epub_dict[key], basestring):\n            epub_dict[key] = epub_dict[key].strip(special_chars)\n\n        elif type(epub_dict[key]) in [tuple, list]:\n            out = []\n            for item in epub_dict[key]:\n                if not isinstance(item, Author):\n                    out.append(item)\n                    continue\n\n                new_item = item._asdict()\n\n                for key in new_item.keys():\n                    new_item[key] = new_item[key].strip(special_chars)\n\n                out.append(Author(**new_item))\n\n            epub_dict[key] = out\n\n    return EPublication(**epub_dict)", "response": "Remove most of the unnecessary interpunction from epublication which is not used properly."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef exportEPublication(epub):\n    epub = _removeSpecialCharacters(epub)\n    post_dict = PostData(epub).get_POST_data()\n    return _sendPostDict(post_dict)", "response": "This function takes an EPublication object and returns Aleph object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nimporting the internal properties from an EPublication object.", "response": "def _import_epublication(self, epub):\n        \"\"\"\n        Fill internal property ._POST dictionary with data from EPublication.\n        \"\"\"\n        # mrs. Svobodov\u00e1 requires that annotation exported by us have this\n        # prefix\n        prefixed_annotation = ANNOTATION_PREFIX + epub.anotace\n\n        self._POST[\"P0501010__a\"] = epub.ISBN\n        self._POST[\"P07012001_a\"] = epub.nazev\n        self._POST[\"P07032001_e\"] = epub.podnazev\n        self._POST[\"P0502010__b\"] = epub.vazba\n        self._POST[\"P0504010__d\"] = epub.cena\n        self._POST[\"P07042001_h\"] = epub.castDil\n        self._POST[\"P07052001_i\"] = epub.nazevCasti\n        self._POST[\"P0902210__c\"] = epub.nakladatelVydavatel\n        self._POST[\"P0903210__d\"] = epub.datumVydani\n        self._POST[\"P0801205__a\"] = epub.poradiVydani\n        self._POST[\"P1502IST1_b\"] = epub.zpracovatelZaznamu\n        self._POST[\"P0503010__x\"] = epub.format\n        self._POST[\"P110185640u\"] = epub.url or \"\"\n        self._POST[\"P0901210__a\"] = epub.mistoVydani\n        self._POST[\"P0601010__a\"] = epub.ISBNSouboruPublikaci\n        self._POST[\"P1801URL__u\"] = epub.internal_url\n        self._POST[\"P1001330__a\"] = prefixed_annotation if epub.anotace else \"\"\n\n        if len(epub.autori) > 3:\n            epub.autori[2] = \", \".join(epub.autori[2:])\n            epub.autori = epub.autori[:3]\n\n        # check whether the autors have required type (string)\n        for author in epub.autori:\n            error_msg = \"Bad type of author (%s) (str is required).\"\n            assert isinstance(author, basestring), (error_msg % type(author))\n\n        authors_fields = (\"P1301ZAK__b\", \"P1302ZAK__c\", \"P1303ZAK__c\")\n        self._POST.update(dict(zip(authors_fields, epub.autori)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\napply a mapping to the internal dictionary.", "response": "def _apply_mapping(self, mapping):\n        \"\"\"\n        Map some case specific data to the fields in internal dictionary.\n        \"\"\"\n        self._POST[\"P0100LDR__\"] = mapping[0]\n        self._POST[\"P0200FMT__\"] = mapping[1]\n        self._POST[\"P0300BAS__a\"] = mapping[2]\n        self._POST[\"P07022001_b\"] = mapping[3]\n        self._POST[\"P1501IST1_a\"] = mapping[4]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _postprocess(self):\n        # validate series ISBN\n        self._POST[\"P0601010__a\"] = self._validate_isbn(\n            self._POST[\"P0601010__a\"],\n            accept_blank=True\n        )\n        if self._POST[\"P0601010__a\"] != \"\":\n            self._POST[\"P0601010__b\"] = \"soubor : \" + self._POST[\"P0601010__a\"]\n\n        # validate ISBN of the book\n        self._POST[\"P0501010__a\"] = self._validate_isbn(\n            self._POST[\"P0501010__a\"],\n            accept_blank=False\n        )\n        self._POST[\"P1601ISB__a\"] = self._POST[\"P0501010__a\"]", "response": "Validate the internal fields and make sure that they are as they are."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_required_fields(self):\n        assert self._POST[\"P0501010__a\"] != \"\", \"ISBN is required!\"\n\n        # export script accepts only czech ISBNs\n        for isbn_field_name in (\"P0501010__a\", \"P1601ISB__a\"):\n            check = PostData._czech_isbn_check(self._POST[isbn_field_name])\n            assert check, \"Only czech ISBN is accepted!\"\n\n        assert self._POST[\"P1601ISB__a\"] != \"\", \"Hidden ISBN field is required!\"\n\n        assert self._POST[\"P07012001_a\"] != \"\", \"Nazev is required!\"\n        assert self._POST[\"P0901210__a\"] != \"\", \"M\u00edsto vyd\u00e1n\u00ed is required!\"\n\n        assert self._POST[\"P0903210__d\"] != \"\", \"Datum vyd\u00e1n\u00ed is required!\"\n        assert self._POST[\"P0801205__a\"] != \"\", \"Po\u0159ad\u00ed vyd\u00e1n\u00ed is required!\"\n\n        # Zpracovatel z\u00e1znamu\n        assert self._POST[\"P1501IST1_a\"] != \"\", \"Zpracovatel is required! (H)\"\n        assert self._POST[\"P1502IST1_b\"] != \"\", \"Zpracovatel is required! (V)\"\n\n        # vazba/forma\n        assert self._POST[\"P0502010__b\"] != \"\", \"Vazba/forma is required!\"\n\n        # assert self._POST[\"P110185640u\"] != \"\", \"URL is required!\"\n\n        # Form\u00e1t (pouze pro epublikace)\n        if self._POST[\"P0502010__b\"] == FormatEnum.ONLINE:\n            assert self._POST[\"P0503010__x\"] != \"\", \"Format is required!\"\n\n        assert self._POST[\"P0902210__c\"] != \"\", \"Nakladatel is required!\"\n\n        def to_unicode(inp):\n            try:\n                return unicode(inp)\n            except UnicodeDecodeError:\n                return unicode(inp, \"utf-8\")\n\n        # check lenght of annotation field - try to convert string to unicode,\n        # to count characters, not combination bytes\n        annotation_length = len(to_unicode(self._POST[\"P1001330__a\"]))\n        annotation_length -= len(to_unicode(ANNOTATION_PREFIX))\n        assert annotation_length <= 500, \"Annotation is too long (> 500).\"", "response": "Check that all required fields are present in the internal dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_POST_data(self):\n        self._postprocess()\n\n        # some fields need to be remapped (depends on type of media)\n        self._apply_mapping(\n            self.mapping.get(self._POST[\"P0502010__b\"], self.mapping[\"else\"])\n        )\n\n        self._check_required_fields()\n\n        return self._POST", "response": "Returns the POST data which can be sent to webform using \\\n                  \\ u2028 \\ u2029 \\ u2029 \\ u2028 \\ u2029 \\ u2029 \\ u2029 \\ u2029 \\ u2028 \\ u2029 \\ u2029 \\ u2029 \\ u2028 \\ u2029 \\ u2029 \\ u2029 \\ u2028 \\ u2029 \\ u2029 \\ u2029 \\ u2029 \\ u"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_parameter(name, datatype, properties):\n    return PARAMETER_CLASSES.get(datatype, Parameter)(name, datatype,\n                                                      properties)", "response": "Build a Parameter object using its name datatype and properties list\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_attributes(self, attributes):\n        # pylint: disable=no-member\n        for attribute in attributes:\n            if attribute.name in self.attributes:\n                set_att_def_value(self.attributes[attribute.name], attribute.value, attribute.name, self.name)\n                try:\n                    set_att_def_value(self.attributes[attribute.name], attribute.value, attribute.name, self.name)\n                except TypeError as terr:\n                    six.print_(\"Error while trying to set value of attribute {0} to {1} in \" \\\n                          \"parameter {2}\" \\\n                          \"\".format(attribute.name, attribute.value, self.name))\n                    raise terr\n            elif attribute.name in self.qualifiers:\n                set_att_def_value(self.qualifiers[attribute.name], attribute.value, attribute.name, self.name)\n                try:\n                    set_att_def_value(self.qualifiers[attribute.name], attribute.value, attribute.name, self.name)\n                except TypeError as terr:\n                    six.print_(\"Error while trying to set value of qualifier {0} to \" \\\n                               \"{1} in parameter {2}\".format(attribute.name,\n                                                             attribute.value,\n                                                             self.name))\n                    raise terr\n            else:\n                raise UnknownAcdPropertyException(attribute.name,\n                                                  attribute.value, self.name)", "response": "Set the values for the attributes of the element based on the existing default values."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprints a string with the given formatting.", "response": "def print_line(s, bold=False, underline=False, blinking=False, color=None, bgcolor=None, end='\\n'):\n    \"\"\"\n    Prints a string with the given formatting.\n\n    \"\"\"\n    s = get_line(s, bold=bold, underline=underline,\n                 blinking=blinking, color=color, bgcolor=bgcolor)\n    print(s, end=end)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_line(s, bold=False, underline=False, blinking=False, color=None,\n             bgcolor=None, update_line=False):\n    \"\"\"\n    Returns a string with the given formatting.\n\n    \"\"\"\n    parts = []\n\n    if update_line:\n        parts.append(_UPDATE_LINE)\n\n    for val in [color, bgcolor]:\n        if val:\n            parts.append(val)\n\n    if bold:\n        parts.append(_TURN_BOLD_MODE_ON)\n    if underline:\n        parts.append(_TURN_UNDERLINE_MODE_ON)\n    if blinking:\n        parts.append(_TURN_BLINKING_MODE_ON)\n\n    parts.append(s)\n    parts.append(_TURN_OFF_CHARACTER_ATTS)\n\n    result = ''.join(parts)\n    return result", "response": "Returns a string with the given formatting."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_line(s, bold=False, underline=False, blinking=False, color=None, bgcolor=None):\n    s = get_line(s, bold=bold, underline=underline, blinking=blinking,\n                 color=color, bgcolor=bgcolor, update_line=True)\n    print(s, end='')", "response": "Updates the current line of the sequence with the given string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef truthy(self):\n        ''' Recognize a Boolean-like string value as a Boolean.\n            Note: the rules are a bit different than string \"truthiness.\"\n\n            '0'             --> False\n            '1'             --> True\n            ('no', 'false') --> False  #\u00a0case-insensitive\n            ('yes', 'true') --> True   #\u00a0case-insensitive\n        '''\n        lower = self.lower()\n        if lower.isdigit():\n            return bool(int(lower))\n        elif lower in ('yes', 'true'):\n            return True\n        elif lower in ('no', 'false'):\n            return False\n        elif self == '':\n            return False\n        else:\n            return None", "response": "Recognize a Boolean - like string value as a Boolean."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn list of Path objects.", "response": "def path_list(self, sep=os.pathsep):\n        ''' Return list of Path objects. '''\n        from pathlib import Path\n        return [ Path(pathstr) for pathstr in self.split(sep) ]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef prefix(self, prefix, lowercase=True):\n        ''' Returns a dictionary of keys with the same prefix.\n            Compat with kr/env, lowercased.\n\n            > xdg = env.prefix('XDG_')\n\n            > for key, value in xdg.items():\n                 print('%-20s' % key, value[:6], '\u2026')\n            config_dirs      /etc/x\u2026\n            current_desktop  MATE\n            data_dirs        /usr/s\u2026\n            \u2026\n        '''\n        env_subset = {}\n        for key in self._envars.keys():\n            if key.startswith(prefix):\n                new_key = key[len(prefix):]  # cut front\n                new_key = new_key.lower() if lowercase else new_key\n                env_subset[new_key] = str(self._envars[key]) # str strips Entry\n\n        return Environment(environ=env_subset,\n                           sensitive=self._sensitive,\n                           blankify=self._blankify,\n                           noneify=self._noneify,\n                           writable=self._writable,\n                          )", "response": "Returns a dictionary of keys with the same prefix."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nchange a name on the fly. Compat with kr / env.", "response": "def map(self, **kwargs):\n        ''' Change a name on the fly.  Compat with kr/env. '''\n        return { key: str(self._envars[kwargs[key]])  # str strips Entry\n                 for key in kwargs }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _filehandler(configurable):\n\n    filename = configurable.log_name.replace('.', sep)\n    path = join(configurable.log_path, '{0}.log'.format(filename))\n\n    return FileHandler(path, mode='a+')", "response": "Default logging file handler."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef post(self, document):\n\n        if type(document) is dict:\n            document = [document]\n\n        return self.make_request(method='POST', uri='updates/', data=document)", "response": "Send to API a document or a list of document."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the status of a job.", "response": "def get(self, key):\n        \"\"\"Return the status from a job.\n\n        :param key: id of job\n        :type document: dict or list\n        :return: message with location of job\n        :rtype: dict\n        :raises Unauthorized: if API returns status 401\n        :raises Forbidden: if API returns status 403\n        :raises NotFound: if API returns status 404\n        :raises ApiError: if API returns other status\n        \"\"\"\n\n        uri = 'updates/job/{}'.format(key)\n        return self.make_request(method='GET', uri=uri)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, image=None):\n        container = self.context\n        new = api.content.create(\n            container=container,\n            type=self.portal_type,\n            title=self.title,\n            safe_id=True,\n        )\n        if image:\n            namedblobimage = NamedBlobImage(\n                data=image.read(),\n                filename=safe_unicode(image.filename))\n            new.image = namedblobimage\n\n        if new:\n            new.description = safe_unicode(self.description)\n            return new.absolute_url()", "response": "Create content and return url. In case of images add the image."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nallow overriding method to allow overriding", "response": "def redirect(self, url):\n        \"\"\"Has its own method to allow overriding\"\"\"\n        url = '{}/view'.format(url)\n        return self.request.response.redirect(url)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ltlfo2mon(formula:Formula, trace:Trace):\n    fl = formula.toLTLFO() if isinstance(formula, Formula) else formula\n    tr = trace.toLTLFO() if isinstance(trace, Trace) else trace\n    cmd = \"echo \\\"%s\\\" | java -jar fodtlmon/tools/ltlfo2mon.jar -p \\\"%s\\\"\" % (tr, fl)\n    p = os.popen(cmd)\n    res = p.readline()[:-1]\n    p.close()\n    return res", "response": "Run ltlfo2mon to get the next line of the next line"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_users(self, entries):\n        ws = IWorkspace(self.context)\n        members = ws.members\n\n        # check user permissions against join policy\n        join_policy = self.context.join_policy\n        if (join_policy == \"admin\"\n            and not checkPermission(\n                \"collective.workspace: Manage roster\",\n                self.context)):\n            raise Unauthorized(\"You are not allowed to add users here\")\n\n        for entry in entries:\n            id = entry.get('id')\n            is_member = bool(entry.get('member'))\n            is_admin = bool(entry.get('admin'))\n\n            # Existing members\n            if id in members:\n                member = members[id]\n                if not is_member:\n                    if checkPermission(\n                            \"ploneintranet.workspace: Manage workspace\",\n                            self.context):\n                        ws.membership_factory(ws, member).remove_from_team()\n                    else:\n                        raise Unauthorized(\n                            \"Only team managers can remove members\")\n                elif not is_admin:\n                    ws.membership_factory(ws, member).groups -= {'Admins'}\n                else:\n                    ws.membership_factory(ws, member).groups |= {'Admins'}\n\n            # New members\n            elif id not in members and (is_member or is_admin):\n                groups = set()\n                if is_admin:\n                    groups.add('Admins')\n                ws.add_to_team(user=id, groups=groups)", "response": "Update user properties on the roster"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef commit(self):\n        '''\n        :param tag:\n            Checks out specified commit.\n            If set to ``None`` the latest commit will be checked out\n        :returns:\n            A list of all commits, descending\n        '''\n\n        commit = self._log(num=-1, format='%H')\n        if commit.get('returncode') == 0:\n            return commit.get('stdout')", "response": "Checks out the specified commit."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef commit(self, commit):\n        '''\n        .. seealso:: :attr:`commit`\n        '''\n\n        c = self.commit\n        if c:\n            if not commit:\n                commit = c[0]\n            if commit in c:\n                self._checkout(treeish=commit)", "response": "Commits the current version of the current version of the current version of the current version of the current version of the current version of the version."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the last 10 commit entries as a list of dictionaries", "response": "def log(self):\n        '''\n        :returns:\n            The last 10 commit entries as dictionary\n\n        * 'commit': The commit-ID\n        * 'message': First line of the commit message\n        '''\n\n        log = self._log(num=10, format='%h::%b').get('stdout')\n        if log:\n            return [\n                dict(commit=c, message=m) for c, m in [\n                    l.split('::') for l in log\n                ]\n            ]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef status(self):\n        '''\n        :returns:\n            Current repository status as dictionary:\n\n        * 'clean': ``True`` if there are no changes ``False`` otherwise\n        * 'untracked': A list of untracked files (if any and not 'clean')\n        * 'modified': A list of modified files (if any and not 'clean')\n        * 'deleted': A list of deleted files (if any and not 'clean')\n        * 'conflicting': A list of conflicting files (if any and not 'clean')\n        '''\n\n        status = self.m(\n            'getting git status',\n            cmdd=dict(cmd='git status --porcelain', cwd=self.local),\n            verbose=False\n        ).get('stdout')\n\n        o, m, f, g = list(), list(), list(), list()\n        if status:\n            for w in status:\n                s, t = w[:2], w[3:]\n                if '?' in s:\n                    o.append(t)\n                if 'M' in s:\n                    m.append(t)\n                if 'D' in s:\n                    f.append(t)\n                if 'U' in s:\n                    g.append(t)\n        clean = False if o + m + f + g else True\n        return dict(\n            untracked=o, modified=m,\n            deleted=f, conflicting=g, clean=clean)", "response": "Returns the current status of the current untracked files modified files and conflicting files."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the current branch of the current node.", "response": "def branch(self):\n        '''\n        :param branch:\n            Checks out specified branch (tracking if it exists on remote).\n            If set to ``None``, 'master' will be checked out\n        :returns:\n            The current branch\n            (This could also be 'master (Detatched-Head)' - Be warned)\n        '''\n\n        branch = self._get_branch().get('stdout')\n        if branch:\n            return ''.join(\n                [b for b in branch if '*' in b]\n            ).replace('*', '').strip()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef branch(self, branch):\n        '''\n        .. seealso:: :attr:`branch`\n        '''\n\n        if not branch:\n            branch = self.__mbranch\n        tracking = (\n            ''\n            if branch in self._get_branch(remotes=True).get('out') else\n            '-B'\n        )\n        self._checkout(treeish='%s %s' % (tracking, branch))", "response": "Sets the branch for the current node."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tag(self):\n        '''\n        :param tag:\n            Checks out specified tag. If set to ``None`` the latest\n            tag will be checked out\n        :returns:\n            A list of all tags, sorted as version numbers, ascending\n        '''\n\n        tag = self.m(\n            'getting git tags',\n            cmdd=dict(\n                cmd='git tag -l --sort=\"version:refname\"',\n                cwd=self.local\n            ),\n            verbose=False,\n        )\n        if tag.get('returncode') == 0:\n            return tag.get('stdout')", "response": "Returns a list of all tags in the local system sorted as version numbers ascending by version number"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntag - tag of the item", "response": "def tag(self, tag):\n        '''\n        .. seealso:: :attr:`tag`\n        '''\n\n        t = self.tag\n        if t:\n            if not tag:\n                tag = t[-1]\n            if tag in t:\n                self._checkout(treeish=tag)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cleanup(self):\n        '''\n        Commits all local changes (if any) into a working branch,\n        merges it with 'master'.\n\n        Checks out your old branch afterwards.\n\n        |appteardown| if conflicts are discovered\n        '''\n\n        hostname = get_hostname()\n        old_branch = self.branch\n\n        changes = self.status\n        if not changes.get('clean'):\n\n            self.branch = hostname\n            utmo = changes.get('untracked', []) + changes.get('modified', [])\n\n            for f in utmo:\n                self.m(\n                    'adding file to repository',\n                    cmdd=(dict(cmd='git add %s' % (f), cwd=self.local)),\n                    more=f,\n                    critical=False\n                )\n            for f in changes.get('deleted', []):\n                self.m(\n                    'deleting file from repository',\n                    cmdd=(dict(cmd='git rm %s' % (f), cwd=self.local)),\n                    more=f,\n                    critical=False\n                )\n            if changes.get('conflicting'):\n                self.m(\n                    'Well done! You have conflicting files in the repository!',\n                    state=True,\n                    more=changes\n                )\n\n            self.m(\n                'auto commiting changes',\n                cmdd=dict(\n                    cmd='git commit -m \"%s %s auto commit\"' % (\n                        hostname, IDENT\n                    ),\n                    cwd=self.local\n                ),\n                more=changes\n            )\n\n            self.branch = None\n\n            self.m(\n                'auto merging branches',\n                cmdd=dict(\n                    cmd='git merge %s -m \"%s %s auto merge\"' % (\n                        hostname, hostname, IDENT\n                    ),\n                    cwd=self.local\n                ),\n                more=dict(\n                    branch=old_branch,\n                    temp_branch=hostname\n                )\n            )\n\n            self.branch = old_branch\n        return dict(changes=changes, pull=self._pull())", "response": "Commits all untracked files into a working branch merges them with master."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npushes changes to the remote.", "response": "def publish(self):\n        '''\n        Runs :func:`cleanup` first,\n        then pushes the changes to the :attr:`remote`.\n        '''\n\n        self.cleanup\n\n        remote = self.remote\n        branch = self.branch\n        return self.m(\n            'pushing changes to %s/%s' % (remote, branch),\n            cmdd=dict(\n                cmd='git push -u %s %s' % (remote, branch),\n                cwd=self.local\n            ),\n            more=dict(remote=remote, branch=branch)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_remote(self, cached=True):\n        '''\n        Helper function to determine remote\n\n        :param cached:\n            Use cached values or query remotes\n        '''\n\n        return self.m(\n            'getting current remote',\n            cmdd=dict(\n                cmd='git remote show %s' % ('-n' if cached else ''),\n                cwd=self.local\n            ),\n            verbose=False\n        )", "response": "Helper function to determine remote version"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a temporary file with contents.", "response": "def _temp_filename(contents):\n    \"\"\"\n    Make a temporary file with `contents`.\n\n    The file will be cleaned up on exit.\n    \"\"\"\n    fp = tempfile.NamedTemporaryFile(\n        prefix='codequalitytmp', delete=False)\n    name = fp.name\n    fp.write(contents)\n    fp.close()\n    _files_to_cleanup.append(name)\n    return name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_options(pool_or_cursor,row_instance):\r\n  \"for connection-level options that need to be set on Row instances\"\r\n  # todo: move around an Options object instead\r\n  for option in ('JSON_READ',): setattr(row_instance,option,getattr(pool_or_cursor,option,None))\r\n  return row_instance", "response": "for connection - level options that need to be set on Row instances"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dirty(field,ttl=None):\r\n  \"decorator to cache the result of a function until a field changes\"\r\n  if ttl is not None: raise NotImplementedError('pg.dirty ttl feature')\r\n  def decorator(f):\r\n    @functools.wraps(f)\r\n    def wrapper(self,*args,**kwargs):\r\n      # warning: not reentrant\r\n      d=self.dirty_cache[field] if field in self.dirty_cache else self.dirty_cache.setdefault(field,{})\r\n      return d[f.__name__] if f.__name__ in d else d.setdefault(f.__name__,f(self,*args,**kwargs))\r\n    return wrapper\r\n  return decorator", "response": "decorator to cache the result of a function until a field changes"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_table(clas,pool_or_cursor):\r\n    \"uses FIELDS, PKEY, INDEXES and TABLE members to create a sql table for the model\"\r\n    def mkfield((name,tp)): return name,(tp if isinstance(tp,basestring) else 'jsonb')\r\n    fields = ','.join(map(' '.join,map(mkfield,clas.FIELDS)))\r\n    base = 'create table if not exists %s (%s'%(clas.TABLE,fields)\r\n    if clas.PKEY: base += ',primary key (%s)'%clas.PKEY\r\n    base += ')'\r\n    commit_or_execute(pool_or_cursor,base)\r\n    clas.create_indexes(pool_or_cursor)", "response": "uses FIELDS PKEY INDEXES and TABLE members to create a sql table for the model"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pkey_get(clas,pool_or_cursor,*vals):\r\n    \"lookup by primary keys in order\"\r\n    pkey = clas.PKEY.split(',')\r\n    if len(vals)!=len(pkey): raise ValueError(\"%i args != %i-len primary key for %s\"%(len(vals),len(pkey),clas.TABLE))\r\n    rows = list(clas.select(pool_or_cursor,**dict(zip(pkey,vals))))\r\n    if not rows: raise Missing\r\n    return set_options(pool_or_cursor,clas(*rows[0]))", "response": "lookup by primary keys in order"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nnoting : This returns a generator not a list. All your expectations will be violated", "response": "def select(clas,pool_or_cursor,**kwargs):\r\n    \"note: This returns a generator, not a list. All your expectations will be violated\"\r\n    columns = kwargs.pop('columns','*')\r\n    # todo(awinter): write a test for whether eqexpr matters; figure out pg behavior and apply to pgmock\r\n    query=\"select %s from %s\"%(columns,clas.TABLE)\r\n    if kwargs: query+=' where %s'%' and '.join('%s=%%s'%k for k in kwargs)\r\n    return select_or_execute(pool_or_cursor,query,tuple(kwargs.values()))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning generator yielding instances of the class", "response": "def select_models(clas,pool_or_cursor,**kwargs):\r\n    \"returns generator yielding instances of the class\"\r\n    if 'columns' in kwargs: raise ValueError(\"don't pass 'columns' to select_models\")\r\n    return (set_options(pool_or_cursor,clas(*row)) for row in clas.select(pool_or_cursor,**kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap for kwinsert that returns a constructed class. use this over kwinsert in most cases", "response": "def kwinsert_mk(clas,pool_or_cursor,**kwargs):\r\n    \"wrapper for kwinsert that returns a constructed class. use this over kwinsert in most cases\"\r\n    if 'returning' in kwargs: raise ValueError(\"don't call kwinsert_mk with 'returning'\")\r\n    return set_options(\r\n      pool_or_cursor,\r\n      clas(*clas.kwinsert(pool_or_cursor,returning='*',**kwargs))\r\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef updatewhere(clas,pool_or_cursor,where_keys,**update_keys):\r\n    \"this doesn't allow raw_keys for now\"\r\n    # if clas.JSONFIELDS: raise NotImplementedError # todo(awinter): do I need to make the same change for SpecialField?\r\n    if not where_keys or not update_keys: raise ValueError\r\n    setclause=','.join(k+'=%s' for k in update_keys)\r\n    whereclause=' and '.join(eqexpr(k,v) for k,v in where_keys.items())\r\n    q='update %s set %s where %s'%(clas.TABLE,setclause,whereclause)\r\n    vals = tuple(update_keys.values()+where_keys.values())\r\n    commit_or_execute(pool_or_cursor,q,vals)", "response": "this doesn t allow raw_keys for now"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning { ModelClass : list_of_pkey_tuples. Don t use this yet.", "response": "def refkeys(self,fields):\r\n    \"returns {ModelClass:list_of_pkey_tuples}. see syncschema.RefKey. Don't use this yet.\"\r\n    # todo doc: better explanation of what refkeys are and how fields plays in\r\n    dd=collections.defaultdict(list)\r\n    if any(f not in self.REFKEYS for f in fields): raise ValueError(fields,'not all in',self.REFKEYS.keys())\r\n    for f in fields:\r\n      rk=self.REFKEYS[f]\r\n      for model in rk.refmodels: dd[model].extend(rk.pkeys(self,f))\r\n    return dd"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts an integer list float or pandas. DataFrame to Decimal object", "response": "def clean_to_decimal(x, prec=28):\n    \"\"\"Convert an string, int or float to Decimal object\n\n    Parameters\n    ----------\n    x : str, list, tuple, numpy.ndarray, pandas.DataFrame\n        A string, int or float number, or a list, array or\n        dataframe of these.\n\n    digits : int\n        (Default prec=None)\n        Set the getcontext precision\n\n    Returns\n    -------\n    y : str, list, tuple, numpy.ndarray, pandas.DataFrame\n        Decimal object or array of Decimal objects\n\n    Example\n    -------\n        clean_to_decimal('12.345')\n            Decimal('12.345')\n\n        clean_to_decimal('12.345', prec=2)\n            Decimal('12')\n\n        clean_to_decimal(12.345)\n            Decimal('12.34500000000000063948846218')\n\n        clean_to_decimal(12.345, prec=5)\n            Decimal('12.345')\n\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n    import decimal\n\n    def proc_elem(e):\n        try:\n            return decimal.Decimal(e) + decimal.Decimal('0.0')\n        except Exception as e:\n            print(e)\n            return None\n\n    def proc_list(x):\n        return [proc_elem(e) for e in x]\n\n    def proc_ndarray(x):\n        tmp = proc_list(list(x.reshape((x.size,))))\n        return np.array(tmp).reshape(x.shape)\n\n    # set precision\n    if prec:\n        decimal.getcontext().prec = prec\n\n    # transform string, list/tuple, numpy array, pandas dataframe\n    if isinstance(x, (str, int, float)):\n        return proc_elem(x)\n    elif isinstance(x, (list, tuple)):\n        return proc_list(x)\n    elif isinstance(x, np.ndarray):\n        return proc_ndarray(x)\n    elif isinstance(x, pd.DataFrame):\n        return pd.DataFrame(proc_ndarray(x.values),\n                            columns=x.columns,\n                            index=x.index)\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rating_for(context, obj):\n    context[\"rating_object\"] = context[\"rating_obj\"] = obj\n    context[\"rating_form\"] = RatingForm(context[\"request\"], obj)\n    ratings = context[\"request\"].COOKIES.get(\"yacms-rating\", \"\")\n    rating_string = \"%s.%s\" % (obj._meta, obj.pk)\n    context[\"rated\"] = (rating_string in ratings)\n    rating_name = obj.get_ratingfield_name()\n    for f in (\"average\", \"count\", \"sum\"):\n        context[\"rating_\" + f] = getattr(obj, \"%s_%s\" % (rating_name, f))\n    return context", "response": "Provides a generic context variable name for the object that ratings are being rendered for and the rating form."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_attr_info(binary_view):\n    '''Gets basic information from a binary stream to allow correct processing of\n    the attribute header.\n\n    This function allows the interpretation of the Attribute type, attribute length\n    and if the attribute is non resident.\n\n    Args:\n        binary_view (memoryview of bytearray) - A binary stream with the\n            information of the attribute\n\n    Returns:\n        An tuple with the attribute type, the attribute length, in bytes, and\n        if the attribute is resident or not.\n    '''\n    global _ATTR_BASIC\n\n    attr_type, attr_len, non_resident = _ATTR_BASIC.unpack(binary_view[:9])\n\n    return (AttrTypes(attr_type), attr_len, bool(non_resident))", "response": "Gets basic information from a binary stream to allow correct processing of\n            the attribute header."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _from_binary_ts(cls, binary_stream):\n    repr = cls._REPR\n\n    if len(binary_stream) != repr.size:\n        raise ContentError(\"Invalid binary stream size\")\n\n    content = repr.unpack(binary_stream)\n    nw_obj = cls()\n    nw_obj.created, nw_obj.changed, nw_obj.mft_changed, nw_obj.accessed = \\\n        convert_filetime(content[0]), convert_filetime(content[1]), \\\n        convert_filetime(content[2]), convert_filetime(content[3])\n\n    _MOD_LOGGER.debug(\"Attempted to unpack Timestamp from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj", "response": "Create a new object from a binary stream."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _astimezone_ts(self, timezone):\n    if self.created.tzinfo is timezone:\n        return self\n    else:\n        nw_obj = Timestamps((None,)*4)\n        nw_obj.created = self.created.astimezone(timezone)\n        nw_obj.changed = self.changed.astimezone(timezone)\n        nw_obj.mft_changed = self.mft_changed.astimezone(timezone)\n        nw_obj.accessed = self.accessed.astimezone(timezone)\n\n        return nw_obj", "response": "Changes the time zones of all timestamps."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new object from binary_stream.", "response": "def _from_binary_stdinfo(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    '''\n        TIMESTAMPS(32)\n            Creation time - 8\n            File altered time - 8\n            MFT/Metadata altered time - 8\n            Accessed time - 8\n        Flags - 4 (FileInfoFlags)\n        Maximum number of versions - 4\n        Version number - 4\n        Class id - 4\n        Owner id - 4 (NTFS 3+)\n        Security id - 4 (NTFS 3+)\n        Quota charged - 8 (NTFS 3+)\n        Update Sequence Number (USN) - 8 (NTFS 3+)\n    '''\n\n    if len(binary_stream) == cls._REPR.size: #check if it is v3 by size of the stram\n        t_created, t_changed, t_mft_changed, t_accessed, flags, m_ver, ver, \\\n            c_id, o_id, s_id, quota_charged, usn = cls._REPR.unpack(binary_stream)\n        nw_obj = cls(\n            (   Timestamps((convert_filetime(t_created), convert_filetime(t_changed),\n                            convert_filetime(t_mft_changed), convert_filetime(t_accessed))\n            ), FileInfoFlags(flags), m_ver, ver, c_id, o_id, s_id, quota_charged, usn))\n    else:\n        #if the content is not using v3 extension, added the missing stuff for consistency\n        t_created, t_changed, t_mft_changed, t_accessed, flags, m_ver, ver, \\\n            c_id  = cls._REPR_NO_NFTS_3_EXTENSION.unpack(binary_stream)\n        nw_obj = cls(\n            (   Timestamps((convert_filetime(t_created), convert_filetime(t_changed),\n                            convert_filetime(t_mft_changed), convert_filetime(t_accessed))\n            ), FileInfoFlags(flags), m_ver, ver, c_id, None, None, None, None))\n\n    _MOD_LOGGER.debug(\"Attempted to unpack STANDARD_INFORMATION from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nunpacking the ATTRIBUTE_LIST Entry from the binary stream.", "response": "def _from_binary_attrlist_e(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    '''\n        Attribute type - 4\n        Length of a particular entry - 2\n        Length of the name - 1 (in characters)\n        Offset to name - 1\n        Starting VCN - 8\n        File reference - 8\n        Attribute ID - 1\n        Name (unicode) - variable\n    '''\n\n    attr_type, entry_len, name_len, name_off, s_vcn, f_tag, attr_id = cls._REPR.unpack(binary_stream[:cls._REPR.size])\n    if name_len:\n        name = binary_stream[name_off:name_off+(2*name_len)].tobytes().decode(\"utf_16_le\")\n    else:\n        name = None\n    file_ref, file_seq = get_file_reference(f_tag)\n    nw_obj = cls((AttrTypes(attr_type), entry_len, name_off, s_vcn, file_ref, file_seq, attr_id, name))\n\n    _MOD_LOGGER.debug(\"Attempted to unpack ATTRIBUTE_LIST Entry from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nunpack the binary stream into a list of AttributeListEntry objects.", "response": "def _from_binary_attrlist(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    _attr_list = []\n    offset = 0\n\n    while True:\n        entry = AttributeListEntry.create_from_binary(binary_stream[offset:])\n        offset += len(entry)\n        _attr_list.append(entry)\n        if offset >= len(binary_stream):\n            break\n        _MOD_LOGGER.debug(\"Next AttributeListEntry offset = %d\", offset)\n    _MOD_LOGGER.debug(\"Attempted to unpack ATTRIBUTE_LIST Entry from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), _attr_list)\n\n    return cls(_attr_list)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _from_binary_objid(cls, binary_stream):\n    uid_size = ObjectID._UUID_SIZE\n\n    #some entries might not have all four ids, this line forces\n    #to always create 4 elements, so contruction is easier\n    uids = [UUID(bytes_le=binary_stream[i*uid_size:(i+1)*uid_size].tobytes()) if i * uid_size < len(binary_stream) else None for i in range(0,4)]\n    _MOD_LOGGER.debug(\"Attempted to unpack OBJECT_ID Entry from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), uids)\n\n    return cls(uids)", "response": "Unpacks a binary OBJECT_ID entry from a binary stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the actual size of the object ID as some attributes have variable sizes", "response": "def _len_objid(self):\n    '''Get the actual size of the content, as some attributes have variable sizes'''\n    try:\n        return self._size\n    except AttributeError:\n        temp = (self.object_id, self.birth_vol_id, self.birth_object_id, self.birth_domain_id)\n        self._size = sum([ObjectID._UUID_SIZE for data in temp if data is not None])\n        return self._size"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nunpack the VOLUME_NAME entry from the binary stream.", "response": "def _from_binary_volname(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    name = binary_stream.tobytes().decode(\"utf_16_le\")\n\n    _MOD_LOGGER.debug(\"Attempted to unpack VOLUME_NAME Entry from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), name)\n\n    return cls(name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new object from a binary volume info entry.", "response": "def _from_binary_volinfo(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    content = cls._REPR.unpack(binary_stream)\n\n    nw_obj = cls(content)\n    nw_obj.vol_flags = VolumeFlags(content[2])\n\n    _MOD_LOGGER.debug(\"Attempted to unpack VOLUME_INFORMATION Entry from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), content)\n\n    return nw_obj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new object from a binary file.", "response": "def _from_binary_filename(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    ''' File reference to parent directory - 8\n        TIMESTAMPS(32)\n            Creation time - 8\n            File altered time - 8\n            MFT/Metadata altered time - 8\n            Accessed time - 8\n        Allocated size of file - 8 (multiple of the cluster size)\n        Real size of file - 8 (actual file size, might also be stored by the directory)\n        Flags - 4\n        Reparse value - 4\n        Name length - 1 (in characters)\n        Name type - 1\n        Name - variable\n    '''\n\n    f_tag, t_created, t_changed, t_mft_changed, t_accessed, alloc_fsize, \\\n        real_fsize, flags, reparse_value, name_len, name_type = cls._REPR.unpack(binary_stream[:cls._REPR.size])\n    name = binary_stream[cls._REPR.size:].tobytes().decode(\"utf_16_le\")\n    file_ref, file_seq = get_file_reference(f_tag)\n\n    nw_obj = cls((file_ref, file_seq,\n           Timestamps((convert_filetime(t_created), convert_filetime(t_changed),\n                        convert_filetime(t_mft_changed), convert_filetime(t_accessed))\n        ), alloc_fsize, real_fsize, FileInfoFlags(flags), reparse_value, NameType(name_type), name))\n\n    _MOD_LOGGER.debug(\"Attempted to unpack FILENAME from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nunpacks the Index Node Header Entry from the binary stream.", "response": "def _from_binary_idx_nh(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    ''' Offset to start of index entry - 4\n        Offset to end of used portion of index entry - 4\n        Offset to end of the allocated index entry - 4\n        Flags - 4\n    '''\n    nw_obj = cls(cls._REPR.unpack(binary_stream[:cls._REPR.size]))\n\n    _MOD_LOGGER.debug(\"Attempted to unpack Index Node Header Entry from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _from_binary_idx_e(cls, binary_stream, content_type=None):\n    #TODO don't save this here and overload later?\n    #TODO confirm if this is really generic or is always a file reference\n    ''' Undefined - 8\n        Length of entry - 2\n        Length of content - 2\n        Flags - 4\n        Content - variable\n        VCN of child node - 8 (exists only if flag is set, aligned to a 8 byte boundary)\n    '''\n    repr_size = cls._REPR.size\n    generic, entry_len, cont_len, flags = cls._REPR.unpack(binary_stream[:repr_size])\n    vcn_child_node = (None,)\n\n    #if content is known (filename), create a new object to represent the content\n    if content_type is AttrTypes.FILE_NAME and cont_len:\n        binary_content = FileName.create_from_binary(binary_stream[repr_size:repr_size+cont_len])\n    else:\n        binary_content = binary_stream[repr_size:repr_size+cont_len].tobytes()\n    #if there is a next entry, we need to pad it to a 8 byte boundary\n    if flags & IndexEntryFlags.CHILD_NODE_EXISTS:\n        temp_size = repr_size + cont_len\n        boundary_fix = (entry_len - temp_size) % 8\n        vcn_child_node = cls._REPR_VCN.unpack(binary_stream[temp_size+boundary_fix:temp_size+boundary_fix+8])\n\n    nw_obj = cls((generic, entry_len, cont_len, IndexEntryFlags(flags), binary_content, vcn_child_node))\n\n    _MOD_LOGGER.debug(\"Attempted to unpack Index Entry from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj", "response": "Create a new object from a binary stream containing an Index Entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate an index root object from a binary stream.", "response": "def _from_binary_idx_root(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    ''' Attribute type - 4\n        Collation rule - 4\n        Bytes per index record - 4\n        Clusters per index record - 1\n        Padding - 3\n    '''\n    attr_type, collation_rule, b_per_idx_r, c_per_idx_r = cls._REPR.unpack(binary_stream[:cls._REPR.size])\n    node_header = IndexNodeHeader.create_from_binary(binary_stream[cls._REPR.size:])\n    attr_type = AttrTypes(attr_type) if attr_type else None\n    index_entry_list = []\n\n    offset = cls._REPR.size + node_header.start_offset\n    #loads all index entries related to the root node\n    while True:\n        entry = IndexEntry.create_from_binary(binary_stream[offset:], attr_type)\n        index_entry_list.append(entry)\n        if entry.flags & IndexEntryFlags.LAST_ENTRY:\n            break\n        else:\n            offset += len(entry)\n\n    nw_obj = cls((attr_type, CollationRule(collation_rule), b_per_idx_r,\n                    c_per_idx_r, node_header, index_entry_list ))\n\n    _MOD_LOGGER.debug(\"Attempted to unpack INDEX_ROOT Entry from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a generator that returns all allocated entries in the the bitmap.", "response": "def _allocated_entries_bitmap(self):\n    '''Creates a generator that returns all allocated entries in the\n    bitmap.\n\n    Yields:\n        int: The bit index of the allocated entries.\n\n    '''\n    for entry_number in range(len(self._bitmap) * 8):\n        if self.entry_allocated(entry_number):\n            yield entry_number"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if a particular entry number is allocated in the internal bitmap.", "response": "def _entry_allocated_bitmap(self, entry_number):\n    \"\"\"Checks if a particular index is allocated.\n\n    Args:\n        entry_number (int): Index to verify\n\n    Returns:\n        bool: True if it is allocated, False otherwise.\n    \"\"\"\n    index, offset = divmod(entry_number, 8)\n    return bool(self._bitmap[index] & (1 << offset))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the next empty entry in the bitmap.", "response": "def _get_next_empty_bitmap(self):\n    \"\"\"Returns the next empty entry.\n\n    Returns:\n        int: The value of the empty entry\n    \"\"\"\n    #TODO probably not the best way, redo\n    for i, byte in enumerate(self._bitmap):\n        if byte != 255:\n            for offset in range(8):\n                if not byte & (1 << offset):\n                    return (i * 8) + offset"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nunpack a binary symbolic link into a new object.", "response": "def _from_binary_syn_link(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    ''' Offset to target name - 2 (relative to 16th byte)\n        Length of target name - 2\n        Offset to print name - 2 (relative to 16th byte)\n        Length of print name - 2\n        Symbolic link flags - 4\n    '''\n    offset_target_name, len_target_name, offset_print_name, \\\n    len_print_name, syn_flags = \\\n        cls._REPR.unpack(binary_stream[:cls._REPR.size])\n\n    offset = cls._REPR.size + offset_target_name\n    target_name = binary_stream[offset:offset+len_target_name].tobytes().decode(\"utf_16_le\")\n    offset = cls._REPR.size + offset_print_name\n    print_name = binary_stream[offset:offset+len_print_name].tobytes().decode(\"utf_16_le\")\n\n    nw_obj = cls((target_name, print_name, SymbolicLinkFlags(syn_flags)))\n\n    _MOD_LOGGER.debug(\"Attempted to unpack Symbolic Link from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _from_binary_reparse(cls, binary_stream):\n    ''' Reparse type flags - 4\n            Reparse tag - 4 bits\n            Reserved - 12 bits\n            Reparse type - 2 bits\n        Reparse data length - 2\n        Padding - 2\n    '''\n    #content = cls._REPR.unpack(binary_view[:cls._REPR.size])\n    reparse_tag, data_len = cls._REPR.unpack(binary_stream[:cls._REPR.size])\n\n    #reparse_tag (type, flags) data_len, guid, data\n    reparse_type = ReparseType(reparse_tag & 0x0000FFFF)\n    reparse_flags = ReparseFlags((reparse_tag & 0xF0000000) >> 28)\n    guid = None #guid exists only in third party reparse points\n    if reparse_flags & ReparseFlags.IS_MICROSOFT:#a microsoft tag\n        if reparse_type is ReparseType.SYMLINK:\n            data = SymbolicLink.create_from_binary(binary_stream[cls._REPR.size:])\n        elif reparse_type is ReparseType.MOUNT_POINT:\n            data = JunctionOrMount.create_from_binary(binary_stream[cls._REPR.size:])\n        else:\n            data = binary_stream[cls._REPR.size:].tobytes()\n    else:\n        guid = UUID(bytes_le=binary_stream[cls._REPR.size:cls._REPR.size+16].tobytes())\n        data = binary_stream[cls._REPR.size+16:].tobytes()\n\n    nw_obj = cls((reparse_type, reparse_flags, data_len, guid, data))\n\n    _MOD_LOGGER.debug(\"Attempted to unpack REPARSE_POINT from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj", "response": "Returns a new object from the binary stream."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _from_binary_ea_info(cls, binary_stream):\n    ''' Size of Extended Attribute entry - 2\n        Number of Extended Attributes which have NEED_EA set - 2\n        Size of extended attribute data - 4\n    '''\n    return cls(cls._REPR.unpack(binary_stream[:cls._REPR.size]))", "response": "Create a new object from the contents of a binary EA header."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nunpacking a binary EA entry into a new object.", "response": "def _from_binary_ea_entry(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    ''' Offset to the next EA  - 4\n        Flags - 1\n        Name length - 1\n        Value length - 2\n    '''\n    offset_next_ea, flags, name_len, value_len = cls._REPR.unpack(binary_stream[:cls._REPR.size])\n\n    name = binary_stream[cls._REPR.size:cls._REPR.size + name_len].tobytes().decode(\"ascii\")\n    #it looks like the value is 8 byte aligned, do some math to compensate\n    #TODO confirm if this is true\n    value_alignment = (_ceil((cls._REPR.size + name_len) / 8) * 8)\n    value = binary_stream[value_alignment:value_alignment + value_len].tobytes()\n\n    nw_obj = cls((offset_next_ea, EAFlags(flags), name, value))\n\n    _MOD_LOGGER.debug(\"Attempted to unpack EA entry from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the size of the entry", "response": "def _len_ea_entry(self):\n    '''Returns the size of the entry'''\n    return EaEntry._REPR.size + len(self.name.encode(\"ascii\")) + self.value_len"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _from_binary_ea(cls, binary_stream):\n    _ea_list = []\n    offset = 0\n\n    #_MOD_LOGGER.debug(f\"Creating Ea object from binary stream {binary_stream.tobytes()}...\")\n    _MOD_LOGGER.debug(\"Creating Ea object from binary '%s'...\", binary_stream.tobytes())\n    while True:\n        entry = EaEntry.create_from_binary(binary_stream[offset:])\n        offset += entry.offset_next_ea\n        _ea_list.append(entry)\n        if offset >= len(binary_stream):\n            break\n    nw_obj = cls(_ea_list)\n\n    _MOD_LOGGER.debug(\"Attempted to unpack EA from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj", "response": "Create a new object from a binary EA."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nunpack a Security Descriptor Header from a binary stream.", "response": "def _from_binary_secd_header(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    ''' Revision number - 1\n        Padding - 1\n        Control flags - 2\n        Reference to the owner SID - 4 (offset relative to the header)\n        Reference to the group SID - 4 (offset relative to the header)\n        Reference to the DACL - 4 (offset relative to the header)\n        Reference to the SACL - 4 (offset relative to the header)\n    '''\n    nw_obj = cls(cls._REPR.unpack(binary_stream))\n    nw_obj.control_flags = SecurityDescriptorFlags(nw_obj.control_flags)\n\n    _MOD_LOGGER.debug(\"Attempted to unpack Security Descriptor Header from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _from_binary_ace_header(cls, binary_stream):\n    ''' ACE Type - 1\n        ACE Control flags - 1\n        Size - 2 (includes header size)\n    '''\n    type, control_flags, size = cls._REPR.unpack(binary_stream)\n    nw_obj = cls((ACEType(type), ACEControlFlags(control_flags), size))\n\n    _MOD_LOGGER.debug(\"Attempted to unpack ACE Header from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj", "response": "Create an ACE object from a binary stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _from_binary_sid(cls, binary_stream):\n    ''' Revision number - 1\n        Number of sub authorities - 1\n        Authority - 6\n        Array of 32 bits with sub authorities - 4 * number of sub authorities\n    '''\n    rev_number, sub_auth_len, auth = cls._REPR.unpack(binary_stream[:cls._REPR.size])\n    if sub_auth_len:\n        sub_auth_repr = struct.Struct(\"<\" + str(sub_auth_len) + \"I\")\n        sub_auth = sub_auth_repr.unpack(binary_stream[cls._REPR.size:cls._REPR.size + sub_auth_repr.size])\n    else:\n        sub_auth = ()\n\n    nw_obj = cls((rev_number, int.from_bytes(auth, byteorder=\"big\"), sub_auth))\n\n    _MOD_LOGGER.debug(\"Attempted to unpack SID from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj", "response": "Create a new object from a binary stream."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _str_sid(self):\n    'Return a nicely formatted representation string'\n    sub_auths = \"-\".join([str(sub) for sub in self.sub_authorities])\n    return f'S-{self.revision_number}-{self.authority}-{sub_auths}'", "response": "Return a nicely formatted representation string"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _from_binary_b_ace(cls, binary_stream):\n    ''' Access rights flags - 4\n        SID - n\n    '''\n    access_flags = cls._REPR.unpack(binary_stream[:cls._REPR.size])[0]\n    sid = SID.create_from_binary(binary_stream[cls._REPR.size:])\n\n    nw_obj = cls((ACEAccessFlags(access_flags), sid))\n\n    return nw_obj", "response": "Create an ACE object from a binary stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates an ACE object from a binary stream.", "response": "def _from_binary_obj_ace(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    ''' Access rights flags - 4\n        Flags - 4\n        Object type class identifier (GUID) - 16\n        Inherited object type class identifier (GUID) - 16\n        SID - n\n    '''\n    #content = cls._REPR.unpack(binary_stream[:cls._REPR.size])\n    access_flags, flags, object_guid, inher_guid = cls._REPR.unpack(binary_stream[:cls._REPR.size])\n    sid = SID.create_from_binary(binary_stream[cls._REPR.size:])\n\n    nw_obj = cls((ACEAccessFlags(access_flags),flags, UUID(bytes_le=object_guid), UUID(bytes_le=inher_guid), sid))\n\n    return nw_obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new object from a binary stream.", "response": "def _from_binary_acl(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    ''' Revision number - 1\n        Padding - 1\n        Size - 2\n        ACE Count - 2\n        Padding - 2\n    '''\n    rev_number, size, ace_len = cls._REPR.unpack(binary_stream[:cls._REPR.size])\n    #content = cls._REPR.unpack(binary_stream[:cls._REPR.size])\n    aces = []\n\n    offset = cls._REPR.size\n    for i in range(ace_len):\n        ace = ACE.create_from_binary(binary_stream[offset:])\n        offset += len(ace)\n        aces.append(ace)\n        _MOD_LOGGER.debug(\"Next ACE offset = %d\", offset)\n    nw_obj = cls((rev_number, size, aces))\n\n    _MOD_LOGGER.debug(\"Attempted to unpack SID from \\\"%s\\\"\\nResult: %s\", binary_stream.tobytes(), nw_obj)\n\n    return nw_obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new object from a binary stream.", "response": "def _from_binary_sec_desc(cls, binary_stream):\n    \"\"\"See base class.\"\"\"\n    header = SecurityDescriptorHeader.create_from_binary(binary_stream[:SecurityDescriptorHeader.get_representation_size()])\n\n    owner_sid = SID.create_from_binary(binary_stream[header.owner_sid_offset:])\n    group_sid = SID.create_from_binary(binary_stream[header.group_sid_offset:])\n    dacl = None\n    sacl = None\n\n    if header.sacl_offset:\n        sacl = ACL.create_from_binary(binary_stream[header.sacl_offset:])\n    if header.dacl_offset:\n        dacl = ACL.create_from_binary(binary_stream[header.dacl_offset:])\n\n    nw_obj = cls((header, owner_sid, group_sid, sacl, dacl))\n    \n    return nw_obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the logical size of the file", "response": "def _len_sec_desc(self):\n    '''Returns the logical size of the file'''\n    return len(self.header) + len(self.owner_sid) + len(self.group_sid) + len(self.sacl) + len(self.dacl)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_from_binary(cls, binary_view):\n        '''Creates a new object AttributeHeader from a binary stream. The binary\n        stream can be represented by a byte string, bytearray or a memoryview of the\n        bytearray.\n\n        Args:\n            binary_view (memoryview of bytearray) - A binary stream with the\n                information of the attribute\n\n        Returns:\n            AttributeHeader: New object using hte binary stream as source\n        '''\n        attr_type, attr_len, non_resident, name_len, name_offset, flags, attr_id, \\\n        content_len, content_offset, indexed_flag = cls._REPR.unpack(binary_view[:cls._REPR.size])\n\n        if name_len:\n            name = binary_view[name_offset:name_offset+(2*name_len)].tobytes().decode(\"utf_16_le\")\n        else:\n            name = None\n\n        nw_obj = cls((AttrTypes(attr_type), attr_len, bool(non_resident), AttrFlags(flags), attr_id, name),\n                        (content_len, content_offset, indexed_flag))\n\n        return nw_obj", "response": "Creates a new object AttributeHeader from a binary stream. The binary stream can be represented by a byte string bytearray or a memoryview of the attribute\n            bytearray."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef interpret(self, msg):\n        slides = msg.get('slides', [])\n        self.cache = msg.get('folder', '.')\n        self.gallery = msg.get('gallery', ['..'])\n        self.finder.interpret(dict(galleries=self.gallery))\n\n        # in case slides is a generator, turn it into a list\n        # since I am going to go through it twice\n        slides = [slide for slide in slides]\n\n        logname = msg.get('logname')\n        if logname:\n            self.write_slide_list(logname, slides)\n\n        # Now spin through slides again\n        for slide in slides:\n\n            image = self.draw_slide(slide)\n\n            heading = slide['heading']['text']\n            filename = self.get_image_name(heading)\n\n            self.cache_image(filename, image)\n\n        # fixme -- just return info in slides.txt as list of dicts\n        return", "response": "Load input and cache the image and slides. txt files."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_slide_list(self, logname, slides):\n        # Write slides.txt with list of slides\n        with open('%s/%s' % (self.cache, logname), 'w') as logfile:\n            for slide in slides:\n                heading = slide['heading']['text']\n                filename = self.get_image_name(heading)\n                \n                print('%s,%d' % (filename, slide.get('time', 0)),\n                      file=logfile)", "response": "Write list of slides to logfile"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndraws a single slide", "response": "def draw_slide(self, slide):\n        \"\"\" Return layout information for slide \"\"\"\n\n        image = Image.new('RGB', (WIDTH, HEIGHT), 'black')\n        draw = ImageDraw.Draw(image)\n        draw.font = self.font\n        \n        self.draw_slide_text(draw, slide)\n\n        self.draw_slide_images(draw, slide, image)\n\n        return image"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rotate(self, img):\n        try:\n            exif = image2exif.get_exif(img)\n        except AttributeError:\n            # image format doesn't support exif\n            return img\n        \n        orientation = exif.get('Orientation', 1)\n\n        landscape = img.height < img.width\n        \n        if orientation == 6 and landscape:\n            print(\"ROTATING\")\n            return img.rotate(-90)\n\n        return img", "response": "Rotate image if exif says it needs it"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndraw an image from the source image.", "response": "def draw_image(self, image, item, source):\n        \"\"\" Add an image to the image \"\"\"\n        top, left = item['top'], item['left']\n        width, height = item['width'], item['height']\n        image_file = item['image']\n\n        img = Image.open(source)\n\n        img = self.rotate(img)\n\n        iwidth, iheight = img.size\n\n        wratio = width / iwidth\n        hratio = height / iheight\n\n        ratio = min(wratio, hratio)\n\n        img = img.resize((int(iwidth * ratio),\n                          int(iheight * ratio)),\n                         Image.ANTIALIAS)\n        \n\n        # get updated image size\n        iwidth, iheight = img.size\n        \n        # Adjust top, left for actual size of image so centre\n        # is in the same place as it would have been\n        \n        top += (height - iheight) // 2\n        left += (width - iwidth) // 2\n        \n        # now paste the image\n        image.paste(img, (left, top))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nturn a name into a slug suitable for an image file name", "response": "def slugify(self, name):\n        \"\"\" Turn name into a slug suitable for an image file name \"\"\"\n        slug = ''\n        last = ''\n        for char in name.replace('#', '').lower().strip():\n            if not char.isalnum():\n                char = '_'\n\n            if last == '_' and char == '_':\n                continue\n\n            slug += char\n            last = char\n\n        return slug"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_keys(self):\n    return [k for k, el in self._keystore.items() if not el.is_expired]", "response": "Returns a list of the available keys in the storage\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets or change a property in the storage", "response": "def set(self, key, value, expire_in=None):\n    \"\"\"\n    Function to set or change particular property in the storage\n\n    :param key: key name\n    :param value:  value to set\n    :param expire_in: seconds to expire key\n    :type key str\n    :type expire_in int\n    \"\"\"\n    if key not in self._keystore:\n      self._keystore[key] = InMemoryItemValue(expire_in=expire_in)\n\n    k = self._keystore[key]\n    \"\"\":type k InMemoryItemValue\"\"\"\n    k.update_expire_time(expire_in)\n    k.value = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, key):\n    if key not in self._keystore:\n      return None\n\n    rec = self._keystore[key]\n    \"\"\":type rec InMemoryItemValue\"\"\"\n\n    if rec.is_expired:\n      self.delete(key)\n      return None\n\n    return rec.value", "response": "Retrieves the value of the item with the given key from the storage."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef exists(self, key):\n    if key in self._keystore and not self._keystore[key].is_expired:\n      return True\n    elif key in self._keystore and self._keystore[key].is_expired:\n      self.delete(key)\n      return False\n\n    return False", "response": "Checks if the particular key exists in the storage"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_data_to_internal(self, include_custom=False):\n        for element in self.data:\n            self.data[element].parse_data_to_internal()\n        if include_custom:\n            for element in self.custom_data:\n                self.custom_data[element].parse_data_to_internal()", "response": "Parse the data to internal data structures."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking a 2D plot of the single object in the current figure and save it in a file.", "response": "def plot_2d_single(x, y, pdffilename, **kwargs):\n        \"\"\"\n        Do make_2d_single_plot and pass all arguments\n\n        args:\n            x: array_like\n                xdata\n            y: array_like\n                ydata\n            filepath: string\n                filepath of pdf to save\n            **kwargs:\n                figure_options: passed to matplotlib.pyplot.figure\n                xlabel_options: dict\n                    kwargs passed in set_xlabel\n                ylabel_options: dict\n                    kwargs passed in set_ylabel\n                suptitle_options: dict\n                    kwargs passed in figure.suptitle\n                title_options: dict\n                    kwargs passed in set_title\n                scilimits: tuple\n                    if number outside this limits, will use scientific notation\n                errors: dictionary, array_like, scalar\n                    dictionary: {\"xerr\": xerr, \"yerr\": yerr}\n                    array_like, scalar: yerr\n                fmt: string, default=\"k.\"\n                    line format\n                bestfitfmt: string, default=\"k-\"\n                    bestfit line format\n                bestfit: BestFit child class\n                    eg. bestfit.polyfit.PolyFit, bestfit.logfit.LogFit\n                bestfitlim: tuple, default=None\n                    xlim for bestfit line\n                suptitle: string, default=xlim\n                    suptitle of pdf plot, formatted with outputdict\n                suptitle_fontsize: int, default=15\n                    font size of suptitle\n                title: string, default=None\n                    title of the pdf plot\n                title_fontsize: int, default=12\n                    font size of title, formatted with outputdict\n                xlabel: string, default=None\n                    label of string xlabel, formatted with outputdict\n                ylabel: string, default=None\n                    label of string ylabel, formatted with outputdict\n                xlim: tuple, default=None\n                    xlim\n                ylim: tuple, default=None\n                    ylim\n                outputdict: dictionary, default=None\n                    pass keys and arguments for formatting and\n                    to output\n        \"\"\"\n        pdffilepath = DataSets.get_pdffilepath(pdffilename)\n        plotsingle2d = PlotSingle2D(x, y, pdffilepath, **kwargs)\n        return plotsingle2d.plot()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the path for the pdf file for the specified pdffilename", "response": "def get_pdffilepath(pdffilename):\n        \"\"\"\n        Returns the path for the pdf file\n\n        args:\n            pdffilename: string\n                returns path for the plots folder / pdffilename.pdf\n        \"\"\"\n        return FILEPATHSTR.format(\n            root_dir=ROOT_DIR, os_sep=os.sep, os_extsep=os.extsep,\n            name=pdffilename,\n            folder=PURPOSE.get(\"plots\").get(\"folder\", \"plots\"),\n            ext=PURPOSE.get(\"plots\").get(\"extension\", \"pdf\")\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmakes a TeX table of the current object.", "response": "def make_tex_table(inputlist, outputfilename, fmt=None, **kwargs):\n        \"\"\"\n        Do make_tex_table and pass all arguments\n\n        args:\n            inputlist: list\n            outputfilename: string\n            fmt: dictionary\n                key: integer\n                    column index starting with 0\n                values: string\n                    format string. eg \"{:g}\"\n            **kwargs:\n                nonestring: string\n                    string when objecttype is None\n        \"\"\"\n        outputfilepath = FILEPATHSTR.format(\n            root_dir=ROOT_DIR, os_sep=os.sep, os_extsep=os.extsep,\n            name=outputfilename,\n            folder=PURPOSE.get(\"tables\").get(\"folder\", \"tables\"),\n            ext=PURPOSE.get(\"tables\").get(\"extension\", \"tex\")\n        )\n        table.make_tex_table(inputlist, open(outputfilepath, 'wb'), fmt=fmt,\n                             close=kwargs.get(\"close\", True), **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_compute_file(self):\n        string = \"\"\n        try:\n            vardict_items = self.vardict.iteritems()\n        except AttributeError:\n            vardict_items = self.vardict.items()\n        for key, val in vardict_items:\n            # get default\n            default_format = get_default_format(val)\n            string_format = \"\\\\newcommand{{\\\\{}}}{{\" + self.vardictformat.get(\n                key, default_format) + \"}}\\n\"\n            string += string_format.format(key, val).replace(\"+\", \"\")\n        # get settings\n        compute_file = open(\n            \"{root_dir}{os_sep}{name}{os_extsep}{ext}\".format(\n                root_dir=ROOT_DIR, os_sep=os.sep, os_extsep=os.extsep,\n                name=SETTINGS[\"COMPUTE\"][\"name\"],\n                ext=SETTINGS[\"COMPUTE\"][\"extension\"]\n            ), \"wb\")\n        compute_file.write(string)\n        compute_file.close()", "response": "Make the compute file from the self. vhostict and self. vhostictformat\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mapping_fields(mapping, parent=[]):\r\n    rtn_obj = {}\r\n    for key, value in mapping.items():\r\n        new_key = parent + [key]\r\n        new_key = \".\".join(new_key)\r\n        rtn_obj.update({new_key: value.get('type')})\r\n        if value.get('properties'):\r\n            rtn_obj.update(mapping_fields(value['properties'], [new_key]))\r\n        elif value.get('fields'):\r\n            rtn_obj.update(mapping_fields(value['fields'], [new_key]))\r\n            rtn_obj[new_key] = [rtn_obj[new_key]] + \\\r\n                    list(value['fields'].keys())\r\n    return rtn_obj", "response": "reads an elasticsearh mapping dictionary and returns a list of fields cojoined with a dot notation"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread a dictionary and returns a list of fields cojoined with a dot notation", "response": "def dict_fields(obj, parent=[]):\r\n    \"\"\"\r\n    reads a dictionary and returns a list of fields cojoined with a dot\r\n    notation\r\n\r\n    args:\r\n        obj: the dictionary to parse\r\n        parent: name for a parent key. used with a recursive call\r\n    \"\"\"\r\n    rtn_obj = {}\r\n    for key, value in obj.items():\r\n        new_key = parent + [key]\r\n        new_key = \".\".join(new_key)\r\n        if isinstance(value, list):\r\n            if value:\r\n                value = value[0]\r\n        if isinstance(value, dict):\r\n            rtn_obj.update(dict_fields(value, [new_key]))\r\n        else:\r\n            rtn_obj.update({new_key: value})\r\n    return rtn_obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns all rdfclasses that have and associated elasticsearch Returns a list of rdfclasses that have and associated elasticsearch Returns None", "response": "def list_mapped_classes():\r\n        \"\"\"\r\n        Returns all the rdfclasses that have and associated elasticsearch\r\n        mapping\r\n\r\n        Args:\r\n            None\r\n\r\n        \"\"\"\r\n        cls_dict = {key: value\r\n                    for key, value in MODULE.rdfclass.__dict__.items()\r\n                    if not isinstance(value, RdfConfigManager)\r\n                    and key not in ['properties']\r\n                    and hasattr(value, 'es_defs')\r\n                    and value.es_defs.get('kds_esIndex')}\r\n        new_dict = {}\r\n        # remove items that are appearing as a subclass of a main mapping class\r\n        # the intersion of the set of the cls_dict values and the a classes\r\n        # individual hierarchy will be >1 if the class is a subclass of another\r\n        # class in the list\r\n        potential_maps = set([cls_.__name__ for cls_ in cls_dict.values()])\r\n        for name, cls_ in cls_dict.items():\r\n            parents = set(cls_.hierarchy)\r\n            if len(parents.intersection(potential_maps)) <= 1:\r\n                new_dict[name] = cls_\r\n        return new_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dictionary with the key as the es_index name and the object is a list of rdfclasses for that index", "response": "def list_indexes(cls):\r\n        \"\"\"\r\n        Returns a dictionary with the key as the es_index name and the\r\n        object is a list of rdfclasses for that index\r\n\r\n        args:\r\n            None\r\n        \"\"\"\r\n\r\n        cls_list = cls.list_mapped_classes()\r\n        rtn_obj = {}\r\n        for key, value in cls_list.items():\r\n            idx = value.es_defs.get('kds_esIndex')[0]\r\n            try:\r\n                rtn_obj[idx].append(value)\r\n            except KeyError:\r\n                rtn_obj[idx] = [value]\r\n        return rtn_obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_rdf_es_idx_map(cls, idx_obj):\r\n        idx_name = list(idx_obj)[0]\r\n\r\n        es_map = {\r\n            \"index\": idx_name,\r\n            \"body\" : {\r\n                \"mappings\": {},\r\n                \"settings\": {\r\n                    # \"read_only_allow_delete\": False,\r\n                    \"index\": {\r\n                        # \"blocks\" : {\r\n                        #     \"read_only_allow_delete\" : \"false\"\r\n                        # },\r\n                        \"analysis\": {\r\n                            \"analyzer\": {\r\n                                \"keylower\": {\r\n                                    \"tokenizer\": \"keyword\",\r\n                                    \"type\": \"custom\",\r\n                                    \"filter\": \"lowercase\",\r\n                                    \"ignore_above\" : 256\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for idx_cls in idx_obj[idx_name]:\r\n            # pdb.set_trace()\r\n            es_map['body']['mappings'][idx_cls.es_defs['kds_esDocType'][0]] = \\\r\n                    {'properties': idx_cls.es_mapping(idx_cls)}\r\n\r\n        return es_map", "response": "Returns an elasticsearch mapping for the specified index based off\r\nose atlas class definitions"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend the mapping to elasticsearch", "response": "def send_es_mapping(self, es_map, **kwargs):\r\n        \"\"\"\r\n        sends the mapping to elasticsearch\r\n\r\n        args:\r\n            es_map: dictionary of the index mapping\r\n\r\n        kwargs:\r\n            reset_idx: WARNING! If True the current referenced es index\r\n                    will be deleted destroying all data in that index in\r\n                    elasticsearch. if False an incremented index will be\r\n                    created and data-migration will start from the old to\r\n                    the new index\r\n        \"\"\"\r\n        log.setLevel(kwargs.get('log_level', self.log_level))\r\n\r\n        def next_es_index_version(curr_alias):\r\n            \"\"\" returns the next number for a new index\r\n\r\n                args:\r\n                    alias_def: the dictionary returned by es for get alias\r\n            \"\"\"\r\n            try:\r\n                alias_def = self.es.indices.get_alias(alias)\r\n            except es_except.NotFoundError:\r\n                alias_def = {alias + \"_v0\":{}}\r\n            old_idx = list(alias_def)[0]\r\n            parts = old_idx.split(\"_v\")\r\n            try:\r\n                parts[1] = str(int(parts[1]) + 1)\r\n            except IndexError:\r\n                parts = [old_idx,'1']\r\n            return {'old': old_idx, 'new': \"_v\".join(parts)}\r\n\r\n        reset_idx= kwargs.get('reset_idx', False)\r\n        alias = es_map.pop('index')\r\n        idx_names = next_es_index_version(alias)\r\n\r\n        # Delete if the index series if reset_idx was passed\r\n        if reset_idx:\r\n            log.warning(\"DELETING Elasticsearch INDEX => %s ******\", alias)\r\n            self.es.indices.delete(index=alias + \"_v*\", ignore=[400, 404])\r\n            idx_names['new'] = alias + \"_v1\"\r\n\r\n        # Create the new index and apply the mapping\r\n        self.es.indices.create(index=idx_names['new'],\r\n                               body=es_map['body'],\r\n                               update_all_types=True)\r\n        # if the index was not deleted transfer documents from old to the\r\n        # new index\r\n        if not reset_idx and self.es.indices.exists(idx_names['old']):\r\n            url = os.path.join(self.es_url,'_reindex').replace('\\\\','/')\r\n            data = {\"source\":{\"index\": idx_names['old']},\r\n                    \"dest\":{\"index\": idx_names['new']}}\r\n            # Python elasticsearch recommends using a direct call to the\r\n            # es 5+ _reindex URL vice using their helper.\r\n            result = requests.post(url,\r\n                    headers={'Content-Type':'application/json'},\r\n                    data = json.dumps(data))\r\n            self.es.indices.delete_alias(index=idx_names['old'],\r\n                                         name=alias,\r\n                                         ignore=[403])\r\n            self.es.indices.delete(index=idx_names['old'], ignore=[400, 404])\r\n        # add the alias to the new index\r\n        self.es.indices.put_alias(index=idx_names['new'], name=alias)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef initialize_indices(self, **kwargs):\r\n        action = kwargs.get('action', 'initialize')\r\n        if action == 'update':\r\n            kwargs['reset_idx'] = False\r\n        elif action =='reset':\r\n            kwargs['reset_idx'] = True\r\n\r\n        idx_list = self.list_indexes()\r\n        for idx, values in idx_list.items():\r\n            if (action == 'initialize' and not self.es.indices.exists(idx)) \\\r\n                or action != 'initialize':\r\n                self.send_es_mapping(self.get_rdf_es_idx_map({idx: values}),\r\n                                     **kwargs)", "response": "Creates all the indices that are defined in the rdf definitions and indexes that are defined in the rdf definitions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the mapping defitions presetn in elasticsearh", "response": "def get_es_mappings(self):\r\n        \"\"\"\r\n        Returns the mapping defitions presetn in elasticsearh\r\n        \"\"\"\r\n\r\n        es_mappings = json.loads(requests.get(self.mapping_url).text)\r\n        es_mappings = {\"_\".join(key.split(\"_\")[:-1]): value['mappings'] \\\r\n                       for key, value in es_mappings.items()}\r\n        return es_mappings"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mapping_ref(self, es_mappings):\r\n\r\n        new_map = {}\r\n        for key, value in es_mappings.items():\r\n            for sub_key, sub_value in value.items():\r\n                new_map[\"/\".join([key, sub_key])] = \\\r\n                        mapping_fields(sub_value['properties'])\r\n        return new_map", "response": "Returns a dictionary of mappings and the fiels names in dot notation"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a number of seconds into a readable days hours and minutes.", "response": "def readable_time_delta(seconds):\n    \"\"\"\n    Convert a number of seconds into readable days, hours, and minutes\n    \"\"\"\n    days = seconds // 86400\n    seconds -= days * 86400\n    hours = seconds // 3600\n    seconds -= hours * 3600\n    minutes = seconds // 60\n\n    m_suffix = 's' if minutes != 1 else ''\n    h_suffix = 's' if hours != 1 else ''\n    d_suffix = 's' if days != 1 else ''\n\n    retval = u'{0} minute{1}'.format(minutes, m_suffix)\n\n    if hours != 0:\n        retval = u'{0} hour{1} and {2}'.format(hours, h_suffix, retval)\n\n    if days != 0:\n        retval = u'{0} day{1}, {2}'.format(days, d_suffix, retval)\n\n    return retval"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the next occurrence of a repeatable reminder", "response": "def next_occurrence(reminder):\n    \"\"\"\n    Calculate the next occurrence of a repeatable reminder\n    \"\"\"\n    now = datetime.datetime.utcnow().replace(tzinfo=pytz.UTC)\n    now_dow = now.weekday()\n\n    # Start/end dow starting from tomorrow\n    start_dow = now_dow + 1\n    end_dow = start_dow + 7\n\n    # Modded range from tomorrow until 1 week from now. Normalizes\n    # wraparound values that span into next week\n    dow_iter = imap(lambda x: x % 7, xrange(start_dow, end_dow))\n\n    # Filter out any days that aren't in the schedule\n    dow_iter = ifilter(lambda x: x in reminder['repeat'], dow_iter)\n\n    # Get the first one. That's the next day of week\n    try:\n        next_dow = next(dow_iter)\n    except StopIteration:  # How?\n        logger.exception(\"Somehow, we didn't get a next day of week?\")\n        _scheduled.discard(reminder['_id'])\n        return\n\n    # Get the real day delta. Take the next day of the week. if that day of\n    # the week is before the current day of the week, add a week. Normalize\n    # this value by subtracting the starting point. Example:\n    # Now = 3, Next = 1, Delta = (1 + 7) - 3 = 5\n    day_delta = next_dow\n    if next_dow <= now_dow:\n        day_delta += 7\n    day_delta -= now_dow\n\n    # Update the record\n    return reminder['when'] + datetime.timedelta(days=day_delta), day_delta"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef in_reminder(client, channel, nick, args):\n    global _scheduled\n\n    amount, quantity = int(args[0][:-1]), args[0][-1]\n\n    # Handle ability to specify the channel\n    if args[1] == 'on':\n        target_channel = args[2]\n        message = ' '.join(args[3:])\n\n        # Make sure channel is formatted correctly\n        if not target_channel.startswith('#'):\n            target_channel = '#{0}'.format(target_channel)\n    else:\n        target_channel = channel\n        message = ' '.join(args[1:])\n\n    if quantity not in in_seconds_map:\n        return u\"Sorry I didn't understand '{0}'. You must specify m,h,d. Ex: 12m\".format(args[0])\n\n    seconds = amount * in_seconds_map[quantity]\n    utcnow = datetime.datetime.utcnow().replace(tzinfo=pytz.UTC)\n    delta = datetime.timedelta(seconds=seconds)\n\n    id = db.reminders.insert({\n        'when': utcnow + delta,\n        'message': message,\n        'channel': target_channel,\n        'creator': nick,\n    })\n\n    _scheduled.add(id)\n    reactor.callLater(seconds, _do_reminder, id, client)\n    return u'Reminder set for {0} from now'.format(readable_time_delta(seconds))", "response": "Create a one - time reminder that occurs at some amount of minutes hours or days."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nschedule a reminder at a specific time.", "response": "def at_reminder(client, channel, nick, args):\n    \"\"\"\n    Schedule a reminder to occur at a specific time. The given time can optionally\n    be specified to occur at a specific timezone, but will default to the value\n    of settings.TIMEZONE if none is specified. Times should be on a 24-hour clock.\n\n    These types of reminders are repeatable, should the last two words of the message\n    be of the form \"repeat <days_of_week>\" where days_of_week is a single string consisting\n    of any of the following days: M, Tu, W, Th, F, Sa, Su. For example, 'repeat MWF'\n    will repeat a reminder at the same time every Monday, Wednesday, and Friday.\n\n    A full example of how one would use this:\n\n        <sduncan> helga at 13:00 EST standup time repeat MTuWThF\n\n    This will create a reminder \"standup time\" to occur at 1:00PM Eastern every weekday.\n\n    Optionally, a specific channel can be specified to receive the reminder message. This\n    is useful if creating several reminders via a private message. To use this, specify\n    \"on <channel>\" between the time amount and the message:\n\n        <sduncan> helga at 13:00 EST on #bots standup time repeat MTuWThF\n        <sduncan> helga at 13:00 EST on bots standup time repeat MTuWThF\n\n    Note that the '#' char for specifying the channel is entirely optional.\n    \"\"\"\n    global _scheduled\n\n    now = datetime.datetime.utcnow().replace(tzinfo=pytz.UTC)\n\n    # Parse the time it should go off, and the minute offset of the day\n    hh, mm = map(int, args[0].split(':'))\n\n    # Strip time from args\n    args = args[1:]\n\n    # Default timezone\n    timezone = pytz.timezone(getattr(settings, 'TIMEZONE', 'US/Eastern'))\n\n    try:\n        # If there was a timezone passed in\n        timezone = pytz.timezone(args[0])\n    except pytz.UnknownTimeZoneError:\n        pass\n    else:\n        # If so, remove it from args\n        args = args[1:]\n\n    local_now = now.astimezone(timezone)\n    local_next = local_now.replace(hour=hh, minute=mm)\n\n    if local_next <= local_now:\n        local_next += datetime.timedelta(days=1)\n\n    reminder = {\n        'when': local_next.astimezone(pytz.UTC),\n        'channel': channel,\n        'message': ' '.join(args),\n        'creator': nick,\n    }\n\n    # Check for 'repeat' arg\n    try:\n        repeat = args[-2] == 'repeat'\n    except IndexError:\n        repeat = False\n\n    if repeat:\n        # If repeating, strip off the last two for the message\n        sched = args[-1]\n        reminder['message'] = ' '.join(args[:-2])\n        repeat_days = sorted([v for k, v in days_of_week.iteritems() if k in sched])\n\n        if not repeat_days:\n            return u\"I didn't understand '{0}'. You must use any of M,Tu,W,Th,F,Sa,Su. Ex: MWF\".format(sched)\n\n        reminder['repeat'] = repeat_days\n\n        for attempt in xrange(7):\n            if reminder['when'].weekday() in repeat_days:\n                break\n            reminder['when'] += datetime.timedelta(days=1)\n\n    # Handle ability to specify the channel\n    if reminder['message'].startswith('on'):\n        parts = reminder['message'].split(' ')\n        chan = parts[1]\n        reminder['message'] = ' '.join(parts[2:])\n\n        # Make sure channel is formatted correctly\n        if not chan.startswith('#'):\n            chan = '#{0}'.format(chan)\n        reminder['channel'] = chan\n\n    id = db.reminders.insert(reminder)\n\n    diff = reminder['when'] - now\n    delay = (diff.days * 24 * 3600) + diff.seconds\n\n    _scheduled.add(id)\n    reactor.callLater(delay, _do_reminder, id, client)\n    return u'Reminder set for {0} from now'.format(readable_time_delta(delay))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef p_information_conversion(self, p):\n        'information : information IN INFORMATION_UNIT'\n        logger.debug(\n            'information = information %s in information unit %s', p[1], p[3])\n        p[0] = '{0: {1}}'.format(p[1], p[3])", "response": "information : information IN INFORMATION_UNIT"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nspeeds : NUMBER speed_unit", "response": "def p_speed_constructor(self, p):\n        'speed : NUMBER speed_unit'\n        logger.debug('speed = number %s, speed unit %s', p[1], p[2])\n        information_unit, duration = p[2]\n        information = Information.from_quantity_unit(p[1], information_unit)\n        p[0] = information.in_duration(duration)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nspeed : information IN duration", "response": "def p_speed_information_duration(self, p):\n        'speed : information IN duration'\n        logger.debug('speed = information %s in duration %s', p[1], p[3])\n        p[0] = p[1].in_duration(p[3])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nspeed : speed IN speed_unit", "response": "def p_speed_conversion(self, p):\n        'speed : speed IN speed_unit'\n        logger.debug('speed = speed %s in speed unit %s', p[1], p[3])\n        information_unit, duration = p[3]\n        p[0] = '{0: {1}}'.format(p[1],\n                                 '{0}/{1}'.format(information_unit, duration))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef p_speed_unit(self, p):\n        'speed_unit : INFORMATION_UNIT PER duration'\n        logger.debug(\n            'speed unit = information unit %s per duration %s', p[1], p[3])\n        p[0] = (p[1], p[3])", "response": "speed_unit : INFORMATION_UNIT PER duration"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninterpreting a string and return a dictionary representation of the object.", "response": "def parse(self, string, lexer=None):\n        \"\"\"\n        Interpret a string.\n        \n        :param string: The input to lex and parse.\n        :param lexer: The lexer to use. A new one will be created if not\n                      provided.\n        :return: An object representation of the input.\n        \"\"\"\n        if not lexer:\n            lexer = Lexer().lexer\n\n        return self.parser.parse(string, lexer=lexer)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_project_directory(self, name, target):\n        # if some directory is given, make sure it's nicely expanded.\n        if target is None:\n            top_dir = os.path.join(os.getcwd(), name)\n        else:\n            top_dir = os.path.abspath(os.path.expanduser(target))\n            if not os.path.exists(top_dir):\n                raise CommandError(\"Destination directory '%s' does not \"\n                                   \"exist, please create it first.\" % top_dir)\n\n        return top_dir", "response": "Returns the project directory for the given name and target."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle_template(self, template, subdir):\n        if template is None:\n            return six.text_type(os.path.join(yacms.__path__[0], subdir))\n        return super(Command, self).handle_template(template, subdir)", "response": "Use yacms s project template by default."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef youtube_id(self):\n        m = re.search(r'/embed/([A-Za-z0-9\\-=_]*)', self.embed)\n        if m:\n            return m.group(1)\n        return ''", "response": "Extract and return Youtube video id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstoring the run parameters inputs and options", "response": "def run_with(self, inputs, options):\n        \"\"\" Store the run parameters (inputs and options)\n        \"\"\"\n        self._inputs = inputs\n        self._options = options"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the meta data as a dictionary.", "response": "def as_dict(self):\n        \"\"\" Pre-serialisation of the meta data \"\"\"\n        drepr = {}\n        drepr[\"name\"] = self.name\n        drepr[\"time\"] = self.time\n        # error pre-serialisation\n        drepr[\"errors\"] = [str(err) for err in self.errors]\n        # warning  pre-serialisation\n        drepr[\"warnings\"] = [str(warn) for warn in self.warnings]\n        return drepr"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef name(self):\n        return \"%s:[%s]\" % (self._name, \", \".join(meta.name for meta in self._metas))", "response": "Compute a name according to sub meta results names\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all the errors", "response": "def errors(self):\n        \"\"\" get all the errors\n\n        >>> gres = PlayMeta(\"operation\")\n        >>> res_plus = BasicPlayMeta(Composable(name=\"plus\"))\n        >>> gres.append(res_plus)\n        >>> res_plus.add_error(ValueError(\"invalid data\"))\n        >>> res_moins = BasicPlayMeta(Composable(name=\"moins\"))\n        >>> gres.append(res_moins)\n        >>> res_plus.add_error(RuntimeError(\"server not anwsering\"))\n        >>> gres.errors\n        [ValueError('invalid data',), RuntimeError('server not anwsering',)]\n        \"\"\"\n        errors = []\n        for meta in self:\n            errors.extend(meta.errors)\n        return errors"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append(self, meta):\n        assert isinstance(meta, BasicPlayMeta)\n        self._metas.append(meta)", "response": "Add a BasicPlayMeta object to the internal list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef as_dict(self):\n        drepr = super(PlayMeta, self).as_dict()\n        drepr[\"details\"] = [meta.as_dict() for meta in self._metas]\n        return drepr", "response": "Return a dictionary representation of the meta data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef defaults(self):\n        default = self._defaults\n        # if require and no default, the first component as default\n        if not len(default) and self.required and len(self._components):\n            default = [six.next(six.itervalues(self._components)).name]\n        return default", "response": "component default component\n\n        .. Note:: default components is just an indication for user and the\n            views, except if the Block is required. If required then default is\n            selected if nothing explisitely selected."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the list of selected component names.", "response": "def selected(self):\n        \"\"\" returns the list of selected component names.\n\n        if no component selected return the one marked as default.\n        If the block is required and no component where indicated as default,\n        then the first component is selected.\n        \"\"\"\n        selected = self._selected\n        if len(self._selected) == 0 and self.required:\n            # nothing has been selected yet BUT the component is required\n            selected = self.defaults\n        return selected"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef as_dict(self):\n        #TODO/FIXME: add selected information\n        if self.hidden:\n            rdict = {}\n        else:\n            def_selected = self.selected()\n            comps = [\n                {\n                    'name': comp.name,\n                    'default': comp.name in self.defaults,\n                    'options': comp.get_ordered_options() if isinstance(comp, Optionable) else None\n                }\n                for comp in self\n            ]\n            rdict = {\n                'name': self.name,\n                'required': self.required,\n                'multiple': self.multiple,\n                'args': self.in_name,\n                'returns': self.out_name,\n                'components': comps\n            }\n        return rdict", "response": "returns a dictionary representation of the block and of all the component options"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresets the component list to the empty list", "response": "def reset(self):\n        \"\"\" Removes all the components of the block\n        \"\"\"\n        self._components = OrderedDict()\n        self.clear_selections()\n        self._logger.info(\"<block: %s> reset component list\" % (self.name))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clear_selections(self):\n        self._selected = []\n        for component in self._components.values():\n            if isinstance(component, Optionable):\n                self._logger.info(\"<block: %s> clear selection an options for '%s'\" % (self.name, component.name))\n                component.clear_options_values()", "response": "Reset the current selections and reset option values to default\n        for all components."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the options of the block.", "response": "def setup(self, in_name=None, out_name=None, required=None, hidden=None,\n                multiple=None, defaults=None):\n        \"\"\" Set the options of the block.\n        Only the not None given options are set\n\n        .. note:: a block may have multiple inputs but have only one output\n\n        :param in_name: name(s) of the block input data\n        :type in_name: str or list of str\n        :param out_name: name of the block output data\n        :type out_name: str\n        :param required: whether the block will be required or not\n        :type required: bool\n        :param hidden: whether the block will be hidden to the user or not\n        :type hidden: bool\n        :param multiple: if True more than one component may be selected/ run) \n        :type multiple: bool\n        :param defaults: names of the selected components\n        :type defaults: list of str, or str\n        \"\"\"\n        if in_name is not None:\n            self.in_name = in_name if isinstance(in_name, list) else [in_name]\n        if out_name is not None:\n            self.out_name = out_name\n        if required is not None:\n            self.required = required\n        if hidden is not None:\n            self.hidden = hidden\n        if multiple is not None:\n            self.multiple = multiple\n        if defaults is not None:\n            #if default is just a 'str' it is managed in setter\n            self.defaults = defaults"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the possible components of the block", "response": "def set(self, *components):\n        \"\"\" Set the possible components of the block\n        \n        :param components: components to append Optionables or Composables\n        \"\"\"\n        self.reset()\n        if len(components) == 1:\n            self.append(components[0])\n        else:\n            for comp in components:\n                self.append(comp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef append(self, component, default=False):\n        if not isinstance(component, Composable):\n            if callable(component):\n                component = Composable(component)\n            else:\n                raise ValueError(\"component '%s' is not Optionable nor Composable and even not callable\" % component)\n        if component.name in self._components:\n            raise ValueError(\"We already have a component with the name '%s'\" % component.name)\n        self._components[component.name] = component\n        if default:\n            if self.multiple:\n                self.defaults = self.defaults + [component.name]\n            else:\n                self.defaults = component.name\n        self._logger.info(\"<block: %s> add component: %s:%s\" % (self.name, component.name, component))", "response": "Adds one component to the block."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nselect the components that will played by played with given options.", "response": "def select(self, comp_name, options=None):\n        \"\"\" Select the components that will by played (with given options).\n\n        `options` will be passed to :func:`.Optionable.parse_options` if the\n        component is a subclass of :class:`Optionable`.\n\n        .. Warning:: this function also setup the options (if given) of the\n            selected component. Use :func:`clear_selections` to restore both\n            selection and component's options.\n\n        This method may be call at play 'time', before to call :func:`play` to\n        run all selected components.\n\n        :param name: name of the component to select\n        :type comp_name: str\n        :param options: options to set to the components\n        :type options: dict\n        \"\"\"\n        self._logger.info(\"select comp '%s' for block '%s' (options: %s)\" % (comp_name, self._name, options))\n        if comp_name not in self._components:\n            raise ValueError(\"'%s' has no component '%s' (components are: %s)\"\\\n                  % (self._name, comp_name, \", \".join(self.component_names())))\n        if options is None:\n            options = {}\n        # get the componsent\n        component = self._components[comp_name]\n        # check options make sens\n        if not isinstance(component, Optionable) and len(options):\n            raise ValueError(\"the component %s is not optionable you can't provide options...\" % comp_name)\n        # add component as selected, aware of multiple\n        if comp_name not in self._selected:\n            if not self.multiple and len(self._selected):\n                assert len(self._selected) == 1\n                self._selected[0] = comp_name\n            else:\n                self._selected.append(comp_name)\n        else:\n            # TODO the component has already been selected\n            pass\n        # component might be a function or any callable\n        # only Optionable will get options\n        if isinstance(component, Optionable):\n            component.set_options_values(options, parse=True, strict=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconfigures the block from a dictionary or list of configuration dictionaries.", "response": "def configure(self, config):\n        \"\"\" Configure the block from an (horible) configuration dictionary (or\n        list) this data are coming from a json client request and has to be\n        parsed. It takes the default value if missing (for component selection\n        and options).\n\n        :param config: component to use and the associated options \n        :type config: `dict` or `list`\n\n        `config` format ::\n\n            {\n                'name': name_of_the_comp_to_use,\n                'options': {\n                    name: value,\n                    name: va...\n                }\n            }\n\n        or for multiple selection ::\n\n            [\n                {\n                    'name': name_of_the_comp_to_use,\n                    'options': {\n                        name: value,\n                        name: va...\n                    }\n                },\n                {...}\n            ]\n\n        .. warning:: values of options in this dictionnary are strings\n\n        \"\"\"\n        self._logger.info(\"configure block <%s>\" % self.name)\n        # normalise input format\n        if isinstance(config, dict):\n            if len(config) == 0:\n                config = []\n            else:\n                config = [config]\n        # check errors\n        if self.hidden and len(config):\n            raise ValueError(\"Component '%s' is hidden you can't change it's configuration from here\" % self.name)\n        if self.required and len(self.defaults) == 0 and len(config) == 0:\n            raise ValueError(\"Component '%s' is required but none given (and no defaults)\" % self.name)\n        # comp is given\n        if not self.multiple and len(config) > 1:\n            raise ValueError(\"Block '%s' allows only one component to be selected\" % self.name)\n        # check input dict\n        for req_comp in config:\n            if 'name' not in req_comp:\n                raise ValueError(\"No 'name' value in config for block '%s' \" % self.name)\n            if req_comp['name'] not in self:\n                raise ValueError(\"Invalid component (%s) for block '%s' \"\n                    % (req_comp['name'], self.name))\n\n        # remove selection and reset to default options\n        self.clear_selections()\n\n        # configure the block\n        # select and set options\n        for req_comp in config:\n            self.select(req_comp['name'], req_comp.get(\"options\", {}))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck that the block can be run", "response": "def validate(self):\n        \"\"\" check that the block can be run\n        \"\"\"\n        if self.required and len(self.selected()) == 0:\n            raise ReliureError(\"No component selected for block '%s'\" % self.name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef play(self, *inputs, **named_inputs):\n        # TODO: multi mode option(False, pipeline, map)\n        self.validate() # TODO what if validate fails ?\n        # intialise run meta data\n        start = time.time()\n        self.meta = PlayMeta(self.name)\n            ### manage inputs\n        if len(inputs) and len(named_inputs):\n            raise ValueError(\"Either `inputs` or `named_inputs` should be provided, not both !\")\n        # default input name (so also the default last_output_name)\n        if len(named_inputs):\n            if self.in_name is None:\n                raise ValueError(\"named inputs given, but the block input's names are unknow\")\n            if set(self.in_name) != set(named_inputs.keys()):\n                raise ValueError(\"Inputs names are not matching with block input's names\")\n            inputs = [named_inputs[in_name] for in_name in self.in_name]\n\n        _break_on_error = True\n        results = {}\n        # run\n        for comp_name in self.selected():\n            # get the component\n            comp = self._components[comp_name]\n            # get the options\n            if isinstance(comp, Optionable):\n                # note: we force the hidden values only if the call is not\n                # decorated by a \"check\" (that already force the hidden values)\n                force_hidden = not (hasattr(comp.__call__, '_checked') and comp.__call__._checked)\n                options = comp.get_options_values(hidden=force_hidden)\n            else:\n                options = {}\n            # prepare the Play meta data\n            comp_meta_res = BasicPlayMeta(comp)\n            # it is register right now to be sur to have the data if there is an exception\n            self.meta.append(comp_meta_res)\n            comp_meta_res.run_with(inputs, options)\n\n            # some logging\n            argstr = [repr(arg)[:100].replace('\\n', '') for arg in inputs]\n            self._logger.debug(\"\"\"'%s' playing: %s\n                component: %s,\n                args=%s,\n                kwargs=%s\"\"\" % (self._name, comp.name, comp, \"\\n\\t\\t\".join(argstr), options))\n\n            # run the component !\n            try:\n                # multi = False or pipeline\n                # given that the input is also the returning value\n                # This behavior allows to modify the data given in input.\n                # actually same arg if given several times \n                # but may be transformed during the process\n                # then finally returned\n                results[self.out_name] = comp(*inputs, **options)\n                #TODO: add validation on inputs name !\n\n                # TODO implements different mode for multiple \n                # another way would be declaring a list var outside the loop,\n                # then append result of each call to the components __call__\n                # and finally returns all computed results\n                #   map( lambda x : x(*arg), *components )\n                # >>> results.append( comp(*args, **options) )\n                # >>> return *results\n\n            # TODO catch warnings TODO\n            # warning may be raised for many reasons like:\n            # * options has been modified\n            # * deprecation\n            # * pipeline inconsistency \n            # * invalid input (graph with no edge ...)\n            except Exception as err:\n                # component error handling\n                comp_meta_res.add_error(err)\n                self._logger.error(\"error in component '%s': %s\\n%s\" % (comp.name, str(err), traceback.format_exc()))\n                if _break_on_error:\n                    raise\n            finally:\n                # store component walltime\n                now = time.time()\n                comp_meta_res.time = now - start\n                start = now\n        #TODO: may return more than one value with multi=map \n        return results", "response": "Run the selected components of the block."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndeclare what blocks are required for this engine.", "response": "def requires(self, *names):\n        \"\"\" Declare what block will be used in this engine.\n\n        It should be call before adding or setting any component.\n        Blocks order will be preserved for runnning task.\n        \"\"\"\n        if len(names) == 0:\n            raise ValueError(\"You should give at least one block name\")\n    \n        if self._blocks is not None and len(self._blocks) > 0:\n            raise ReliureError(\"Method 'requires' should be called only once before adding any composant\")\n        for name in names:\n            if name in self._blocks:\n                raise ValueError(\"Duplicate block name %s\" % name)\n            self._blocks[name] = Block(name)\n        self._logger.info(\" ** requires ** %s\", names)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set(self, name, *components, **parameters):\n        self._logger.info(\" ** SET ** '%s' \"% name)\n\n        if name not in self:\n            raise ValueError(\"'%s' is not a block (%s)\" % (name, \",\".join(self.names())))\n        self[name].set(*components)\n        self[name].setup(**parameters)", "response": "Set available components and options of one block."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconfiguring all the blocks in the database from a dictionary that has to be parsed and parsed.", "response": "def configure(self, config):\n        \"\"\" Configure all the blocks from an (horible) configuration dictionary\n        this data are coming from a json client request and has to be parsed.\n        It takes the default value if missing (for component selection and \n        options).\n\n        :param config: dictionary that give the component to use for each step\n               and the associated options \n        :type config: dict\n\n        `config` format ::\n\n            {\n                block_name: [{\n                    'name': name_of_the_comp_to_use,\n                    'options': {\n                            name: value,\n                            name: va...\n                        }\n                    },\n                    {...}\n                ]\n           }\n           \n        .. warning:: values of options in this dictionnary are strings\n\n        \"\"\"\n        ##TODO use block configuration\n        self._logger.info(\"\\n\\n\\t\\t\\t ** ============= configure engine ============= ** \\n\")\n        # normalise input format\n        for block_name in config.keys():\n            if isinstance(config[block_name], dict):\n                config[block_name] = [config[block_name]]\n        # check errors\n        for block_name, request_comps in config.items():\n            if block_name not in self:\n                raise ValueError(\"Block '%s' doesn't exist !\" % block_name)\n            block = self[block_name]\n            if block.hidden and len(request_comps):\n                raise ValueError(\"Component '%s' is hidden you can't change it's configuration from here\" % block.name)\n            if block.required and len(request_comps) == 0:\n                raise ValueError(\"Component '%s' is required but None given\" % block.name)\n            # comp is given\n            if not block.multiple and isinstance(request_comps, list) and len(request_comps) > 1:\n                raise ValueError(\"Block '%s' allows only one component to be selected\" % block.name)\n            # check input dict\n            for req_comp in request_comps:\n                if 'name' not in req_comp:\n                    raise ValueError(\"Config error in '%s' \" % block.name)\n                if req_comp['name'] not in block:\n                    raise ValueError(\"Invalid component (%s) for block '%s' \"\n                        % (req_comp['name'], block.name))\n\n        # clear the current selection and option\n        for block in self:\n            # remove selection and reset to default options\n            block.clear_selections()\n        # configure the blocks\n        for block_name, request_comps in config.items():\n            block = self[block_name]\n            # select and set options\n            for req_comp in request_comps:\n                block.select(req_comp['name'], req_comp.get(\"options\", {}))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate(self, inputs=None):\n        # if no blocks...\n        if not len(self._blocks):\n            #TODO: find better error than ReliureError ?\n            raise ReliureError(\"There is no block in this engine\")\n        # it block should be ok with it-self\n        for block in self:\n            block.validate()\n        # check the inputs and outputs\n        # note: fornow only the first block can have user given input\n        available = set()       # set of available data\n        maybe_available = set() # data that are produced be not required blocks\n        # add the first block input as available data\n        if inputs is not None:\n            for in_name in inputs:\n                available.add(in_name)\n        else:\n            # no inputs given, then consider that the first block input will be given\n            if self.in_name is not None:\n                for in_name in self.in_name:\n                    available.add(in_name)\n            else:\n                # default input name if nothing specified\n                available.add(Engine.DEFAULT_IN_NAME)\n        needed = self.needed_inputs()\n        miss = needed.difference(available)\n        if len(miss):\n            raise ReliureError(\"The following inputs are needed and not given: %s\" % (\",\".join(\"'%s'\" % in_name for in_name in miss)))\n        no_need = available.difference(needed)\n        if len(no_need):\n            raise ReliureError(\"The following inputs are given but not needed: %s\" % (\",\".join(\"'%s'\" % in_name for in_name in no_need)))\n        return", "response": "Check that the blocks configuration is ok with the current play inputs and outputs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef needed_inputs(self):\n        needed = set()\n        available = set()       # set of available data\n        for bnum, block in enumerate(self):\n            if not block.selected():    # if the block will not be used\n                continue\n            if block.in_name is not None:\n                for in_name in block.in_name:\n                    if not in_name in available:\n                        needed.add(in_name)\n            elif bnum == 0:\n                # if the first block\n                needed.add(Engine.DEFAULT_IN_NAME)\n            # register the output\n            available.add(block.out_name)\n        return needed", "response": "List all the needed inputs of a configured engine"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef all_outputs(self):\n        outputs = set()\n        for block in self:\n            outputs.update(block.in_name or [Engine.DEFAULT_IN_NAME])\n            outputs.update(block.all_outputs())\n        return outputs", "response": "Returns a list of all engine possible outputs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef play(self, *inputs, **named_inputs):\n        self._logger.info(\"\\n\\n\\t\\t\\t ** ============= play engine ============= ** \\n\")\n        #\n        # create data structure for results and metaresults\n        results = OrderedDict()\n        self.meta = PlayMeta(\"engine\")\n        ### manage inputs\n        if len(inputs) and len(named_inputs):\n            raise ValueError(\"Either `inputs` or `named_inputs` should be provided, not both !\")\n        # default input name (so also the default last_output_name)\n        if len(inputs):\n            # prepare the input data\n            first_in_names = self.in_name or [Engine.DEFAULT_IN_NAME]\n            if len(inputs) != len(first_in_names):\n                raise ValueError(\"%d inputs are needed for first block, but %d given\" % (len(first_in_names), len(inputs)))\n            # inputs are store in results dict (then there is no special run for the first block)\n            for input_num, in_name in enumerate(first_in_names):\n                results[in_name] = inputs[input_num]\n        else:\n            results.update(named_inputs)\n        #\n        ## validate\n        self.validate(results.keys())\n        #\n        ### run the blocks\n        last_output_name = Engine.DEFAULT_IN_NAME\n        for block in self:\n            # continue if block is not selected (note: if require the validate should have faild before)\n            if not len(block.selected()):\n                continue\n            # prepare block ipouts\n            in_names = block.in_name or [last_output_name]\n            # ^ note: if the block has no named input then the last block output is used\n            inputs = [results[name] for name in in_names]\n            # run the block\n            try:\n                results.update(block.play(*inputs))\n                # ^ note: le validate par rapport au type est fait dans le run du block\n            finally:\n                # store metadata\n                self.meta.append(block.meta)\n            last_output_name = block.out_name\n        return results", "response": "Run the engine and return the output of the engine."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of all cached instances.", "response": "def all(self):\n        \"\"\"\n        Returns a list of cached instances.\n        \"\"\"\n        class_list = list(self.get_class_list())\n        if not class_list:\n            self.cache = []\n            return []\n\n        if self.cache is not None:\n            return self.cache\n\n        results = []\n        for cls_path in class_list:\n            module_name, class_name = cls_path.rsplit('.', 1)\n            try:\n                module = __import__(module_name, {}, {}, class_name)\n                cls = getattr(module, class_name)\n                if self.instances:\n                    results.append(cls())\n                else:\n                    results.append(cls)\n            except Exception:\n                logger.exception('Unable to import {cls}'.format(cls=cls_path))\n                continue\n        self.cache = results\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a given message and run the command using the connection and the json protocals", "response": "def parse_message(self, message):  \r\n        \"\"\" Parse a given message and run the command using the \r\n            connection and the json protocals \"\"\"      \r\n\r\n        service = None\r\n\r\n        try:\r\n            service = get_service(message)\r\n        except ValueError:\r\n            pass\r\n\r\n        conn = self.connection\r\n\r\n        # check if valid request\r\n        if service is None or service not in requests.keys():\r\n            logging.info('No such request!')\r\n            conn.write_message(create_error('1', 'no such request'))\r\n            return\r\n\r\n        request_name = requests[service]\r\n\r\n        # process requests without data\r\n        if request_name == 'ping':\r\n            conn.write_message(create_pong())\r\n            return\r\n        elif request_name == 'roomlist':\r\n            conn.write_message(create_roomlist(conn.possible_rooms))\r\n            return\r\n\r\n\r\n        data = get_data(message)\r\n\r\n        logging.debug(data)\r\n\r\n        # process requests with data\r\n        \r\n        if request_name == 'join':\r\n            logging.debug(\"Name is \" + conn.id.name)\r\n            logging.debug(\"Name should be \" + data['username'])\r\n            if conn.id.name != data['username']:   \r\n                try:             \r\n                    conn.id.change_name(data['username'])\r\n                except UsernameInUseException:\r\n                    conn.write_message(create_error(2, 'Username was already in use!'))\r\n            conn.join_room(data['room'])\r\n            conn._send_to_all_rooms(create_connect(conn.id.name))\r\n\r\n        elif request_name == 'userlist':\r\n            room = conn.get_room(data['room'])\r\n\r\n            if room is None:\r\n                conn.write_message('No such room as {room}'.format(room=data['room']))\r\n            else:\r\n                conn.write_message(create_userlist(room.user_names))\r\n\r\n        elif request_name == 'send':\r\n            room = conn.get_room(data['room'])\r\n\r\n            if room is not None:\r\n                room.send_message(create_message(data['username'], data['message']))\r\n\r\n        elif request_name == 'get_user_dump':\r\n            username = data['username']\r\n            for room in conn.possible_rooms:\r\n                if room.get_user(username) is not None:\r\n                    conn.write_message(create_user_dump(room.get_user(username).id))\r\n                    break\r\n            else:\r\n                if username == conn.id.name:\r\n                    conn.write_message(create_user_dump(conn.id))\r\n                else:\r\n                    conn.write_message(create_error(3, 'User not found in any active rooms'))\r\n\r\n        elif request_name == 'get_users_dump':\r\n            room = conn.get_room(data['room'])\r\n\r\n            if room is not None: \r\n                conn.write_message(create_users_dump(room.get_users_connected))\r\n\r\n        elif request_name == 'send_dump':\r\n            conn.id._load_from_json(data)\r\n\r\n        elif request_name == 'next_slide':\r\n            room = conn.get_room(data['room'])\r\n            room.send_message(create_next_slide())\r\n       \r\n        elif request_name == 'previous_slide':\r\n            room = conn.get_room(data['room'])\r\n            room.send_message(create_previous_slide())\r\n       \r\n        elif request_name == 'jump_to_slide':\r\n            room = conn.get_room(data['room'])\r\n            room.send_message(create_jump_to(data['slideNumber']))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef convert(url, input, output=None, options={}, id=None, extract=True):\n    input_stream = cStringIO.StringIO()\n    output_defined = output is not None\n    if not output_defined:\n        extract = False\n        output = StringIO.StringIO()\n\n    archive_name = options.get('filename', ARCHIVE_NAME)\n\n    # input is a path, treat is as such\n    if isinstance(input, (str, unicode)):\n        assert os.path.exists(input)\n\n        with tarfile.open(mode='w:gz', fileobj=input_stream) as tar:\n            tar.add(input, arcname=archive_name)\n    elif hasattr(input, 'read'):\n        with tarfile.open(mode='w:gz', fileobj=input_stream) as tar:\n            info = tarfile.TarInfo(archive_name)\n            input.seek(0, os.SEEK_END)\n            info.size = input.tell()\n            input.seek(0)\n            tar.addfile(info, fileobj=input)\n    else:\n        raise ValueError('input is not path or file object!')\n\n    data = {'input': base64.encodestring(input_stream.getvalue()),\n            'options': options}\n\n    if id:\n        data['id'] = id\n\n    r = requests.get(url + '/convert',\n                     data=json.dumps(data),\n                     headers={'Content-type': 'application/json',\n                              'Accept': 'application/x-gzip'})\n\n    error_occurred = False\n    try:\n        tarfile.open('r:gz', fileobj=cStringIO.StringIO(r.content)).close()\n    except tarfile.ReadError:\n        error_occurred = True\n\n    if extract and not error_occurred:\n        if not isinstance(output, (str, unicode)):\n            raise ValueError('if extract=True then output must be path')\n\n        tmp_dir = tempfile.mkdtemp(suffix='hdc')\n        try:\n            with tarfile.open('r:gz', fileobj=cStringIO.StringIO(r.content)) as tar:\n                tar.extractall(tmp_dir)\n            content = os.listdir(tmp_dir)[0]\n            shutil.move(os.path.join(tmp_dir, content), output)\n        finally:\n            shutil.rmtree(tmp_dir, ignore_errors=True)\n    else:\n        if isinstance(output, (str, unicode)):\n            with open(output, 'wb') as f:\n                f.write(r.content)\n        elif hasattr(output, 'write'):\n            output.write(r.content)\n        else:\n            raise ValueError('output is not path or file object')\n\n    if not output_defined:\n        return output.getvalue()\n    elif error_occurred:\n        return False\n    else:\n        return True", "response": "Wrapper function around requests library providing easy way to interact with HEPData."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the initial config.", "response": "def _download_initial_config(self):\n        \"\"\"Loads the initial config.\"\"\"\n        _initial_config = self._download_running_config()  # this is a bit slow!\n        self._last_working_config = _initial_config\n        self._config_history.append(_initial_config)\n        self._config_history.append(_initial_config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_candidate(self, filename=None, config=None):\n\n        configuration = ''\n\n        if filename is None:\n            configuration = config\n        else:\n            with open(filename) as config_file:\n                configuration = config_file.read()\n\n        return self._upload_config_content(configuration)", "response": "Loads a candidate configuration on the device."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef discard(self):  # pylint: disable=no-self-use\n        try:\n            self.rollback(0)\n        except pyPluribus.exceptions.RollbackError as rbackerr:\n            raise pyPluribus.exceptions.ConfigurationDiscardError(\"Cannot discard configuration: {err}.\\\n                \".format(err=rbackerr))", "response": "Clears uncommited changes.\n\n        :raise pyPluribus.exceptions.ConfigurationDiscardError: If the configuration applied cannot be discarded."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute the difference between the candidate config and the running config.", "response": "def compare(self):  # pylint: disable=no-self-use\n        \"\"\"\n        Computes the difference between the candidate config and the running config.\n        \"\"\"\n        # becuase we emulate the configuration history\n        # the difference is between the last committed config and the running-config\n        running_config = self._download_running_config()\n        running_config_lines = running_config.splitlines()\n        last_committed_config = self._last_working_config\n        last_committed_config_lines = last_committed_config.splitlines()\n        difference = difflib.unified_diff(running_config_lines, last_committed_config_lines, n=0)\n        return '\\n'.join(difference)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rollback(self, number=0):\n        if number < 0:\n            raise pyPluribus.exceptions.RollbackError(\"Please provide a positive number to rollback to!\")\n        available_configs = len(self._config_history)\n        max_rollbacks = available_configs - 2\n        if max_rollbacks < 0:\n            raise pyPluribus.exceptions.RollbackError(\"Cannot rollback: \\\n                not enough configration history available!\")\n        if max_rollbacks > 0 and number > max_rollbacks:\n            raise pyPluribus.exceptions.RollbackError(\"Cannot rollback more than {cfgs} configurations!\\\n                \".format(cfgs=max_rollbacks))\n        config_location = 1  # will load the initial config worst case (user never commited, but wants to discard)\n        if max_rollbacks > 0:  # in case of previous commit(s) will be able to load a specific configuration\n            config_location = available_configs - number - 1  # stored in location len() - rollabck_nb - 1\n            # covers also the case of discard uncommitted changes (rollback 0)\n        desired_config = self._config_history[config_location]\n        try:\n            self._upload_config_content(desired_config, rollbacked=True)\n        except pyPluribus.exceptions.ConfigLoadError as loaderr:\n            raise pyPluribus.exceptions.RollbackError(\"Cannot rollback: {err}\".format(err=loaderr))\n        del self._config_history[(config_location+1):]  # delete all newer configurations than the config rolled back\n        self._last_working_config = desired_config\n        self._committed = True\n        self._config_changed = False\n        return True", "response": "Roll back the current state of the current configuration to a previous state."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef draw(self, label, expire):\n        # get next number\n        with self.client.pipeline() as pipe:\n            pipe.msetnx({self.keys.dispenser: 0, self.keys.indicator: 1})\n            pipe.incr(self.keys.dispenser)\n            number = pipe.execute()[-1]\n\n        # publish for humans\n        self.message('{} assigned to \"{}\"'.format(number, label))\n\n        # launch keeper\n        kwargs = {'client': self.client, 'key': self.keys.key(number)}\n        keeper = Keeper(label=label, expire=expire, **kwargs)\n\n        try:\n            yield number\n        except:\n            self.message('{} crashed!'.format(number))\n            raise\n        finally:\n            keeper.close()\n\n        self.message('{} completed by \"{}\"'.format(number, label))\n        number += 1\n        self.client.set(self.keys.indicator, number)\n        self.announce(number)", "response": "Draw a new entry in the resource queue."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wait(self, number, patience):\n        # inspect indicator for our number\n        waiting = int(self.client.get(self.keys.indicator)) != number\n\n        # wait until someone announces our number\n        while waiting:\n            message = self.subscription.listen(patience)\n            if message is None:\n                # timeout beyond patience, bump and try again\n                self.message('{} bumps'.format(number))\n                self.bump()\n                continue\n            if message['type'] != 'message':\n                continue  # a subscribe message\n\n            waiting = self.keys.number(message['data']) != number\n\n        # our turn now\n        self.message('{} started'.format(number))", "response": "Waits and resets if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef announce(self, number):\n        self.client.publish(self.keys.internal, self.keys.key(number))\n        self.message('{} granted'.format(number))", "response": "Announce an indicator change on both channels."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbumping the number of active users and user in case of unnanounced departments.", "response": "def bump(self):\n        \"\"\" Fix indicator in case of unnanounced departments. \"\"\"\n        # read client\n        values = self.client.mget(self.keys.indicator, self.keys.dispenser)\n        indicator, dispenser = map(int, values)\n\n        # determine active users\n        numbers = range(indicator, dispenser + 1)\n        keys = [self.keys.key(n) for n in numbers]\n        pairs = zip(keys, self.client.mget(*keys))\n\n        try:\n            # determine number of first active user\n            number = next(self.keys.number(key)\n                          for key, value in pairs if value is not None)\n        except:\n            # set number to next result of incr on dispenser\n            number = dispenser + 1\n\n        # set indicator to it if necessary\n        if number != indicator:\n            self.client.set(self.keys.indicator, number)\n\n        # announce and return it anyway\n        self.announce(number)\n        return number"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lock(self, resource, label='', expire=60, patience=60):\n        queue = Queue(client=self.client, resource=resource)\n        with queue.draw(label=label, expire=expire) as number:\n            queue.wait(number=number, patience=patience)\n            yield\n        queue.close()", "response": "Lock a resource.\n\n        :param resource: String corresponding to resource type\n        :param label: String label to attach\n        :param expire: int seconds\n        :param patience: int seconds"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates value. Args: value: Returns: A validated value. Raises: UnitError", "response": "def validate(self, value):\n        \"\"\" Validate value.\n        Args:\n          value:\n        Returns:\n          A validated value.\n        Raises:\n          UnitError\n        \"\"\"\n        for validate in self.validates:\n            value = validate(value)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrestructuring / prepare data about refs for output.", "response": "def prepare(data):\n    \"\"\"Restructure/prepare data about refs for output.\"\"\"\n    ref = data.get(\"ref\")\n    obj = data.get(\"object\")\n    sha = obj.get(\"sha\")\n    return {\"ref\": ref, \"head\": {\"sha\": sha}}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_refs(profile, ref_type=None):\n    resource = \"/refs\"\n    if ref_type:\n        resource += \"/\" + ref_type\n    data = api.get_request(profile, resource)\n    result = [prepare(x) for x in data]\n    return result", "response": "List all refs.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        ref_type\n            The type of ref you want. For heads, it's ``heads``. For tags,\n            it's ``tags``. That sort of thing. If you don't specify a type,\n            all refs are returned.\n\n    Returns:\n        A list of dicts with data about each ref."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching a ref. Args: profile A profile generated from ``simplygithub.authentication.profile``. Such profiles tell this module (i) the ``repo`` to connect to, and (ii) the ``token`` to connect with. ref The ref to fetch, e.g., ``heads/my-feature-branch``. Returns A dict with data about the ref.", "response": "def get_ref(profile, ref):\n    \"\"\"Fetch a ref.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        ref\n            The ref to fetch, e.g., ``heads/my-feature-branch``.\n\n    Returns\n        A dict with data about the ref.\n\n    \"\"\"\n    resource = \"/refs/\" + ref\n    data = api.get_request(profile, resource)\n    return prepare(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a ref. Args: profile A profile generated from ``simplygithub.authentication.profile``. Such profiles tell this module (i) the ``repo`` to connect to, and (ii) the ``token`` to connect with. ref The ref to create, e.g., ``heads/my-feature-branch``. sha The SHA of the commit to point the ref to. Returns A dict with data about the ref.", "response": "def create_ref(profile, ref, sha):\n    \"\"\"Create a ref.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        ref\n            The ref to create, e.g., ``heads/my-feature-branch``.\n\n        sha\n            The SHA of the commit to point the ref to.\n\n    Returns\n        A dict with data about the ref.\n\n    \"\"\"\n    resource = \"/refs\"\n    payload = {\"ref\": \"refs/\" + ref, \"sha\": sha}\n    data = api.post_request(profile, resource, payload)\n    return prepare(data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_ref(profile, ref, sha):\n    resource = \"/refs/\" + ref\n    payload = {\"sha\": sha}\n    data = api.patch_request(profile, resource, payload)\n    return prepare(data)", "response": "Point a ref to a new SHA."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconnect the socket to an IRC server.", "response": "def _connect(self, server, port, tls=True, tls_verify=True, proxy=False,\n                 proxy_type='SOCKS5', proxy_server=None,\n                 proxy_port=None, proxy_username=None, proxy_password=None):\n        \"\"\"\n        Connects the socket to an IRC server.\n        Required arguments:\n        * server - Server to connect to.\n        * port - Port to use.\n        Optional arguments:\n        * tls=True - Should we use TLS/SSL?\n        * tls_verify=True - Verify the TLS certificate?\n                Only works with Python 3.\n        * proxy=False - Should we use a proxy?\n        * proxy_type='SOCKS5' - Proxy type: SOCKS5, SOCKS4 or HTTP\n        * proxy_server=None - Proxy server's address\n        * proxy_port=None - Proxy server's port\n        * proxy_username=None - If SOCKS5 is used,\n                a proxy username/password can be specified.\n        * proxy_password=None - If SOCKS5 is used,\n                a proxy username/password can be specified.\n        \"\"\"\n        with self.lock:\n            if proxy:\n                if proxy_type == 'SOCKS5':\n                    proxy_type = self._m_proxy.PROXY_TYPE_SOCKS5\n                elif proxy_type == 'SOCKS4':\n                    proxy_type = self._m_proxy.PROXY_TYPE_SOCKS4\n                elif proxy_type == 'HTTP':\n                    proxy_type = self._m_proxy.PROXY_TYPE_HTTP\n                self._socket = self._m_proxy.socksocket()\n                self._socket.setproxy(proxytype=proxy_type, \\\n                                      addr=proxy_server, \\\n                                      port=proxy_port, \\\n                                      username=proxy_username, \\\n                                      password=proxy_password)\n\n            if tls:\n                if tls_verify:\n                    ca_bundle = self._m_tempfile.NamedTemporaryFile().name\n                    with open(ca_bundle, 'w') as bundle_file:\n                        bundle_file.write(self._ca_bundle)\n                    cert_required = self._m_tls.CERT_REQUIRED\n                    self._socket = \\\n                    self._m_tls.wrap_socket(self._socket, \\\n                                            cert_reqs=cert_required, \\\n                                            ca_certs=ca_bundle)\n                    self._socket.connect((server, port))\n                    self._m_tls.match_hostname(self._socket.getpeercert(), \\\n                                               server)\n                    return None\n                else:\n                    self._socket = self._m_tls.wrap_socket(self._socket)\n            self._socket.connect((server, port))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters the connection with the IRC server.", "response": "def _register(self, nick, user, real_name, password=None):\n        \"\"\"\n        Register the connection with the IRC server.\n        Required arguments:\n        * nick - Nick to use. If a tuple/list is specified -\n            it will try to use the first,\n            and if the first is already used -\n             it will try to use the second and so on.\n        * user - Username to use.\n        * real_name - Real name to use.\n        Optional arguments:\n        * password=None - IRC server password.\n        \"\"\"\n        with self.lock:\n            if password:\n                self._password(password)\n\n            self.nick(nick)\n            self._user(user, real_name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _init(self, server, nick, user, real_name, password, port=None,\n              tls=True, tls_verify=True,\n              proxy=False, proxy_type='SOCKS5', proxy_server=None,\n              proxy_port=None, proxy_username=None, proxy_password=None):\n        \"\"\"\n        Connect and register with the IRC server and -\n            set server-related information variables.\n        Required arguments:\n        * server - Server to connect to.\n        * nick - Nick to use.\n            If a tuple/list is specified it will try to use the first,\n            and if the first is already used -\n            it will try to use the second and so on.\n        * user - Username to use.\n        * real_name - Real name to use.\n        * password=None - IRC server password.\n        Optional arguments:\n        * port - Port to use.\n        * tls=True - Should we use TLS/SSL?\n        * tls_verify=True - Verify the TLS certificate?\n                Only works with Python 3.\n        * proxy=False - Should we use a proxy?\n        * proxy_type='SOCKS5' - Proxy type: SOCKS5, SOCKS4 or HTTP\n        * proxy_server=None - Proxy server's address\n        * proxy_port=None - Proxy server's port\n        * proxy_username=None - If SOCKS5 is used,\n                a proxy username/password can be specified.\n        * proxy_password=None - If SOCKS5 is used,\n                a proxy username/password can be specified.\n        \"\"\"\n        with self.lock:\n            self.current_nick = nick\n            if tls:\n                if not port:\n                    port = 6697\n                self._connect(server, port, tls, tls_verify, proxy, \\\n                              proxy_type, proxy_server, proxy_port, \\\n                              proxy_username, proxy_password)\n            else:\n                if not port:\n                    port = 6667\n\n                self._connect(server, port, tls, tls_verify, proxy, \\\n                              proxy_type, proxy_server, proxy_port, \\\n                              proxy_username, proxy_password)\n            while self.readable(2):\n                data = self.recv()\n                if data[0] == 'NOTICE':\n                        self.server = data[1][0]\n                self.con_msg.append(data)\n\n            self._register(nick, user, real_name, password)\n            while self.readable(timeout=4):\n                rdata = self.recv()\n                if rdata[0] == 'UNKNOWN':\n                    data = rdata[1][3].replace(':', '', 1)\n                    ncode = rdata[1][1]\n\n                    if ncode == '004':\n                        info = data.split()\n                        self.server = info[0]\n                        self.ircd = info[1]\n                        self.umodes = info[2]\n                        self.cmodes = info[3]\n                    elif ncode == '005':\n                        version = rdata[1][3].replace(':are supported' + \\\n                                               'by this server', '')\n                        version = version.split()\n                        for info in version:\n                            try:\n                                info = info.split('=')\n                                name = info[0]\n                                value = info[1]\n                                self.version[name] = value\n\n                                if name == 'CHARSET':\n                                    self.encoding = value\n                            except IndexError:\n                                self.version[info[0]] = True\n                    elif ncode == '376':\n                        self.con_msg.append(rdata)\n                        break\n                    elif ncode == '422':\n                        self.con_msg.append(rdata)\n                        break\n                else:\n                    if rdata[0] == 'NOTICE':\n                        self.server = rdata[1][0]\n                self.con_msg.append(rdata[1])\n            self.motd = tuple(self.motd)\n            self.con_msg = tuple(self.con_msg)\n            self.connected = True\n            self.keep_going = \\\n                True", "response": "Connect and register with the IRC server and -\n            set server - related information variables."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _password(self, password):\n        with self.lock:\n            self.send('PASS :%s' % password, error_check=True)", "response": "Send a PASS command to the IRC server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle the NICK command.", "response": "def _nick(self, nick):\n        \"\"\"\n        Sets your nick.\n        Required arguments:\n        * nick - New nick.\n        \"\"\"\n        with self.lock:\n            self.send('NICK :%s' % nick)\n\n            if self.readable():\n                msg = self._recv(expected_replies='NICK')\n                if msg[0] == 'NICK':\n                    if not self.hide_called_events:\n                        self.stepback()\n\n            for channel in self.channels:\n                if 'USERS' in self.channels[channel]:\n                    priv_level = \\\n                    self.channels[channel]['USERS'][self.current_nick]\n                    del self.channels[channel]['USERS'][self.current_nick]\n                    self.channels[channel]['USERS'][nick] = priv_level\n            self.current_nick = nick"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets your nick. Required arguments: * nick - New nick or a tuple of possible new nicks.", "response": "def nick(self, nick):\n        \"\"\"\n        Sets your nick.\n        Required arguments:\n        * nick - New nick or a tuple of possible new nicks.\n        \"\"\"\n        nick_set_successfully = False\n        try:\n            self._nick(nick)\n            nick_set_successfully = True\n        except TypeError:\n            for nick_ in nick:\n                try:\n                    self._nick(nick_)\n                    nick_set_successfully = True\n                    break\n\n                except self.NicknameInUse:\n                    pass\n        if not nick_set_successfully:\n            self.exception('433')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _user(self, user, real_name):\n        with self.lock:\n            self.send('USER %s 0 * :%s' % (user, real_name))\n            if self.readable():\n                self._recv()\n                self.stepback()", "response": "Sends the USER message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef oper(self, name, password):\n        with self.lock:\n            self.send('OPER %s %s' % (name, password))\n            snomasks = ''\n            new_umodes = ''\n            if self.readable():\n                    msg = self._recv(expected_replies=( \\\n                                                    'MODE', '381', '008'))\n                    if msg[0] == 'MODE':\n                            new_umodes = msg[2].replace(':', '', 1)\n                    elif msg[0] == '381':\n                            return new_umodes, snomasks\n                    elif msg[0] == '008':\n                            snomasks = msg[2].split('(')[1].split(')')[0]", "response": "Opers up.\n        Required arguments:\n        * name - Oper name.\n        * password - Oper password."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef umode(self, nick, modes=''):\n        with self.lock:\n            if not modes:\n                self.send('MODE %s' % nick)\n                if self.readable():\n                    msg = self._recv(expected_replies=('221',))\n                    if msg[0] == '221':\n                        modes = msg[2].replace('+', '').replace(':', '', 1)\n                return modes\n\n            self.send('MODE %s %s' % (nick, modes))\n\n            if self.readable():\n                msg = self._recv(expected_replies=('MODE',))\n                if msg[0] == 'MODE':\n                    if not self.hide_called_events:\n                        self.stepback()\n                    return msg[2].replace(':', '', 1)", "response": "Sets or gets user modes for a user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend a QUIT message to the Lurklib server and closes the connection.", "response": "def quit(self, reason=''):\n        \"\"\"\n        Sends a QUIT message, closes the connection and -\n            ends Lurklib's main loop.\n        Optional arguments:\n        * reason='' - Reason for quitting.\n        \"\"\"\n        with self.lock:\n            self.keep_going = False\n            self._quit(reason)\n            self._socket.shutdown(self._m_socket.SHUT_RDWR)\n            self._socket.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nquitting a server. Required arguments: * server - Server to quit. Optional arguments: * reason='' - Reason for the server quitting.", "response": "def squit(self, server, reason=''):\n        \"\"\"\n        Quits a server.\n        Required arguments:\n        * server - Server to quit.\n        Optional arguments:\n        * reason='' - Reason for the server quitting.\n        \"\"\"\n        with self.lock:\n            self.send('SQUIT %s :%s' % (server, reason))\n\n            while self.readable():\n                msg = self._recv(expected_replies=('SQUIT',))\n                if msg[0] == 'SQUIT':\n                    if not self.hide_called_events:\n                        self.stepback()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking the connection latency.", "response": "def latency(self):\n        \"\"\" Checks the connection latency. \"\"\"\n        with self.lock:\n            self.send('PING %s' % self.server)\n            ctime = self._m_time.time()\n\n            msg = self._recv(expected_replies=('PONG',))\n            if msg[0] == 'PONG':\n                latency = self._m_time.time() - ctime\n                return latency"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrequesting the planner a search plan for a given gp and returns the plan as a graph.", "response": "def __get_gp_plan(self, gp):\n        \"\"\"\n        Request the planner a search plan for a given gp and returns the plan as a graph.\n        :param gp:\n        :return:\n        \"\"\"\n        query = urlencode({'gp': gp})\n        response = requests.get('{}/plan?'.format(self.__planner) + query, headers={'Accept': 'text/turtle'})\n        graph = Graph()\n        try:\n            graph.parse(source=StringIO.StringIO(response.text), format='turtle')\n        except BadSyntax:\n            pass\n        return graph"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a complete fragment for a given pattern", "response": "def get_fragment(self, gp, **kwargs):\n        \"\"\"\n        Return a complete fragment for a given gp.\n        :param gp: A graph pattern\n        :return:\n        \"\"\"\n        collector = FragmentCollector(self.__host, gp)\n        return collector.get_fragment(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a generator for a given gp.", "response": "def get_fragment_generator(self, gp, **kwargs):\n        \"\"\"\n        Return a fragment generator for a given gp.\n        :param gp:\n        :param kwargs:\n        :return:\n        \"\"\"\n        collector = FragmentCollector(self.__host, gp)\n        return collector.get_fragment_generator(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_section_relations(Section):\n    all_rels = (Section._meta.get_all_related_objects() +\n                Section._meta.get_all_related_many_to_many_objects())\n    return filter_item_rels(all_rels)", "response": "Find every relationship between section and the item model."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfilters the publication object using Aleph and Dup filters.", "response": "def filter_publication(publication):\n    \"\"\"\n    Filter :class:`.Publication` objects using settings declared in\n    :mod:`~harvester.settings` submodule.\n\n    Args:\n        publication (obj): :class:`.Publication` instance.\n\n    Returns:\n        obj/None: None if the publication was found in Aleph or `publication` \\\n                  if not.\n    \"\"\"\n    if settings.USE_DUP_FILTER:\n        publication = dup_filter.filter_publication(publication)\n\n    if publication and settings.USE_ALEPH_FILTER:\n        publication = aleph_filter.filter_publication(\n            publication,\n            cmp_authors=settings.ALEPH_FILTER_BY_AUTHOR\n        )\n\n    return publication"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef authorize_url(self):\n        url, self.state = self.oauth.authorization_url(\n            '%sauthorize' % OAUTH_URL)\n        return url", "response": "Build the authorization url and save the state. Return the authorization url"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fetch_token(self, code, state):\n        if self.state != state:\n            raise MismatchingStateError()\n        self.token = self.oauth.fetch_token(\n            '%saccess_token/' % OAUTH_URL, code=code,\n            client_secret=self.client_secret)\n        return self.token['access_token']", "response": "Fetch the token using the verification code."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a new token using the provided refresh token. Returns the new access_token.", "response": "def refresh_token(self, refresh_token):\n        \"\"\"\n        Get a new token, using the provided refresh token. Returns the new\n        access_token.\n        \"\"\"\n\n        response = requests.post('%saccess_token' % OAUTH_URL, {\n                                 'refresh_token': refresh_token,\n                                 'grant_type': 'refresh_token',\n                                 'client_id': self.client_id,\n                                 'client_secret': self.client_secret\n                                 })\n        resp = json.loads(response.content)\n\n        if 'access_token' in resp:\n            self.token = resp['access_token']\n\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef browser_authorize(self):\n        url = self.authorize_url()\n        # Open the web browser in a new thread for command-line browser support\n        threading.Timer(1, webbrowser.open, args=(url,)).start()\n\n        server_config = {\n            'server.socket_host': '0.0.0.0',\n            'server.socket_port': 443,\n\n            'server.ssl_module': 'pyopenssl',\n            'server.ssl_certificate': 'tests/files/certificate.cert',\n            'server.ssl_private_key': 'tests/files/key.key',\n        }\n\n        cherrypy.config.update(server_config)\n        cherrypy.quickstart(self)", "response": "Open a browser to the authorization url and spool up a CherryPy\n            server to accept the response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a response containing a verification code.", "response": "def index(self, state, code=None, error=None):\n        \"\"\"\n        Receive a Exist response containing a verification code. Use the code\n        to fetch the access_token.\n        \"\"\"\n        error = None\n        if code:\n            try:\n                auth_token = self.fetch_token(code, state)\n            except MissingTokenError:\n                error = self._fmt_failure(\n                    'Missing access token parameter.</br>Please check that '\n                    'you are using the correct client_secret')\n            except MismatchingStateError:\n                error = self._fmt_failure('CSRF Warning! Mismatching state')\n        else:\n            error = self._fmt_failure('Unknown error while authenticating')\n        # Use a thread to shutdown cherrypy so we can return HTML first\n        self._shutdown_cherrypy()\n        return error if error else self.success_html % (auth_token)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _shutdown_cherrypy(self):\n        if cherrypy.engine.state == cherrypy.engine.states.STARTED:\n            threading.Timer(1, cherrypy.engine.exit).start()", "response": "Shutdown cherrypy in one second"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrenders the current value of the field as a widget.", "response": "def as_widget(self, widget=None, attrs=None, only_initial=False):\n        \"\"\"\n        Renders the field by rendering the passed widget, adding any HTML\n        attributes passed as attrs.  If no widget is specified, then the\n        field's default widget will be used.\n        \"\"\"\n        if not widget:\n            widget = self.field.widget\n\n        attrs = attrs or {}\n        auto_id = self.auto_id\n        if auto_id and 'id' not in attrs and 'id' not in widget.attrs:\n            if not only_initial:\n                attrs['id'] = auto_id\n            else:\n                attrs['id'] = self.html_initial_id\n\n        name = \"\"\n        return widget.render(name, self.value(), attrs=attrs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_writable_dir(directory, **kwargs):\r\n    try:\r\n        testfile = tempfile.TemporaryFile(dir = directory)\r\n        testfile.close()\r\n    except OSError as e:\r\n        if e.errno == errno.EACCES:  # 13\r\n            return False\r\n        elif e.errno == errno.ENOENT: # 2\r\n            if kwargs.get('mkdir') == True:\r\n                try:\r\n                    os.makedirs(directory)\r\n                except OSError as e2:\r\n                    if e2.errno == errno.EACCES: # 13\r\n                        return False\r\n            else:\r\n                return False\r\n        e.filename = directory\r\n    return True", "response": "tests to see if the directory is writable. If the directory does not exist returns False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of files in a directory and optionally a list of file extensions.", "response": "def list_files(file_directory,\r\n               file_extensions=None,\r\n               include_subfolders=True,\r\n               include_root=True,\r\n               root_dir=None):\r\n    '''Returns a list of files\r\n\r\n    args:\r\n        file_directory: a sting path to the file directory\r\n        file_extensions: a list of file extensions to filter example\r\n                ['xml', 'rdf']. If none include all files\r\n        include_subfolders: as implied\r\n        include_root: whether to include the root in the path\r\n        root_dir: the root directory to remove if include_root is False\r\n\r\n    returns:\r\n        (tuple) (file_name, file_path_with_root_mod, modified_time, full_path)\r\n    '''\r\n\r\n    log = logging.getLogger(\"%s\" % (inspect.stack()[0][3]))\r\n    log.setLevel(__LOG_LEVEL__)\r\n\r\n    rtn_list = []\r\n    if not root_dir:\r\n        root_dir = file_directory\r\n    root_dir = root_dir.strip()\r\n    if root_dir.endswith(os.path.sep):\r\n        root_dir = root_dir.strip()[:-1]\r\n    dir_parts_len = len(root_dir.split(os.path.sep))\r\n    level = 0\r\n    for root, dirnames, filenames in os.walk(file_directory):\r\n        root_str = root\r\n        if level > 0 and not include_subfolders:\r\n            break\r\n        if not include_root:\r\n            root_str = os.path.sep.join(root.split(os.path.sep)[dir_parts_len:])\r\n        if file_extensions:\r\n            files = [(x,\r\n                      os.path.join(root_str, x),\r\n                      os.path.getmtime(os.path.join(root, x)),\r\n                      os.path.join(root, x))\r\n                     for x in filenames \\\r\n                     if \".\" in x \\\r\n                     and x.split(\".\")[len(x.split(\".\"))-1] in file_extensions]\r\n        else:\r\n            files = [(x,\r\n                      os.path.join(root_str, x),\r\n                      os.path.getmtime(os.path.join(root, x)),\r\n                      os.path.join(root, x))\r\n                     for x in filenames]\r\n        rtn_list += files\r\n        level += 1\r\n    rtn_list.sort(key=lambda tup: tup[0], reverse=True)\r\n    return rtn_list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sliced_pagination(parser, token):\n    try:\n        fnctn, paginatorname, max_items, trash, context_name = token.split_contents()\n    except ValueError:\n        raise TemplateSyntaxError, _get_errstr(fnctn)\n    if not trash == 'as':\n        raise TemplateSyntaxError, _get_errstr(fnctn)\n    return _PaginatorSliceNode(context_name, paginatorname, max_items)", "response": "Returns a list of pages that are sliced by the current page."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a full list of pages.", "response": "def _build_full_list(self):\n        \"\"\"Build a full list of pages.\n        \n        Examples:\n        >>> _SlicedPaginator(1, 7, 5)._build_full_list()\n        [1, 2, 3, 4, 5]\n        >>> _SlicedPaginator(6, 7, 5)._build_full_list()\n        [3, 4, 5, 6, 7]\n        >>> _SlicedPaginator(6, 7, 5)._build_full_list()\n        [3, 4, 5, 6, 7]\n        >>> import itertools\n        >>> combinations = itertools.combinations(range(100), 2)\n        >>> combinations = filter(lambda (x,y): x<y, combinations)\n        >>> for page, maxpages in combinations:\n        ...     a = _SlicedPaginator(page + 1, maxpages, 7)\n        ...     b = a._build_full_list()\n        >>> _SlicedPaginator(2, 5, 7)._build_full_list()\n        [1, 2, 3, 4, 5]\n        >>> _SlicedPaginator(5, 5, 7)._build_full_list()\n        [1, 2, 3, 4, 5]\n        \"\"\"\n        if self.npages <= self.maxpages_items:\n            return range(1, self.npages + 1)\n        else:\n            l = range(self.curpage - self.max_prev_items,\n                      self.curpage + self.max_next_items + 1)\n            while l and l[0] < 1:\n                l.append(l[-1] + 1)\n                del l[0]\n            while l and l[-1] > self.npages:\n                l.insert(0, l[0] - 1)\n                del l[-1]\n            return l"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if the next pages where sliced. is hidden", "response": "def hidden_next_pages(self):\n        \"\"\"Check if the next pages where sliced.\n        \n        Example:\n        >>> map(lambda i: _SlicedPaginator(i, 6, 3).hidden_next_pages(), range(1, 7))\n        [True, True, True, True, False, False]\n        >>> map(lambda i: _SlicedPaginator(i, 7, 3).hidden_next_pages(), range(1, 8))\n        [True, True, True, True, True, False, False]\n        >>> map(lambda i: _SlicedPaginator(i, 6, 5).hidden_next_pages(), range(1, 7))\n        [True, True, True, False, False, False]\n        >>> map(lambda i: _SlicedPaginator(i, 7, 5).hidden_next_pages(), range(1, 8))\n        [True, True, True, True, False, False, False]\n        \"\"\"\n        next_pages = self.next_pages()\n        return len(next_pages) > 0 and next_pages[-1] < self.npages"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef roundup(x, order):\n    '''Round a number to the passed order\n\n    Args\n    ----\n    x: float\n        Number to be rounded\n    order: int\n        Order to which `x` should be rounded\n\n    Returns\n    -------\n    x_round: float\n        The passed value rounded to the passed order\n    '''\n    return x if x % 10**order == 0 else x + 10**order - x % 10**order", "response": "Round a number to the passed order\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hourminsec(n_seconds):\n    '''Generate a string of hours and minutes from total number of seconds\n\n    Args\n    ----\n    n_seconds: int\n        Total number of seconds to calculate hours, minutes, and seconds from\n\n    Returns\n    -------\n    hours: int\n        Number of hours in `n_seconds`\n    minutes: int\n        Remaining minutes in `n_seconds` after number of hours\n    seconds: int\n        Remaining seconds in `n_seconds` after number of minutes\n    '''\n\n    hours, remainder = divmod(n_seconds, 3600)\n    minutes, seconds = divmod(remainder, 60)\n\n    return abs(hours), abs(minutes), abs(seconds)", "response": "Generate a string of hours minutes and seconds from total number of seconds."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting axes labels to experiment duration in hours minutes and seconds.", "response": "def nsamples_to_hourminsec(x, pos):\n    '''Convert axes labels to experiment duration in hours/minutes/seconds\n\n    Notes\n    -----\n    Matplotlib FuncFormatter function\n    https://matplotlib.org/examples/pylab_examples/custom_ticker1.html\n    '''\n\n    h, m, s = hourminsec(x/16.0)\n    return '{:.0f}h {:2.0f}\u2032 {:2.1f}\u2033'.format(h, m, s)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting axes labels to experiment duration in hours and minutes.", "response": "def nsamples_to_hourmin(x, pos):\n    '''Convert axes labels to experiment duration in hours/minutes\n\n    Notes\n    -----\n    Matplotlib FuncFormatter function\n    https://matplotlib.org/examples/pylab_examples/custom_ticker1.html\n    '''\n\n    h, m, s = hourminsec(x/16.0)\n    return '{:.0f}h {:2.0f}\u2032'.format(h, m+round(s))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nsamples_to_minsec(x, pos):\n    '''Convert axes labels to experiment duration in minutes/seconds\n\n    Notes\n    -----\n    Matplotlib FuncFormatter function\n    https://matplotlib.org/examples/pylab_examples/custom_ticker1.html\n    '''\n    h, m, s = hourminsec(x/16.0)\n    return '{:2.0f}\u2032 {:2.1f}\u2033'.format(m+(h*60), s)", "response": "Convert axes labels to experiment duration in minutes and seconds."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding sequential alphbet labels to a figure.", "response": "def add_alpha_labels(axes, xpos=0.03, ypos=0.95, suffix='', color=None,\n        fontsize=14, fontweight='normal', boxstyle='square', facecolor='white',\n        edgecolor='white', alpha=1.0):\n    '''Add sequential alphbet labels to subplot axes\n\n    Args\n    ----\n    axes: list of pyplot.ax\n        A list of matplotlib axes to add the label labels to\n    xpos: float or array_like\n        X position(s) of labels in figure coordinates\n    ypos: float or array_like\n        Y position(s) of labels in figure coordinates\n    suffix: str\n        String to append to labels (e.g. '.' or ' name)\n    color: matplotlib color\n        Color of labels\n    fontsize: int\n        Alppa fontsize\n    fontweight: matplotlib fontweight\n        Alpha fontweight\n    boxstyle: matplotlib boxstyle\n        Alpha boxstyle\n    facecolor: matplotlib facecolor\n        Color of box containing label\n    edgecolor: matplotlib edgecolor\n        Color of box'es border containing label\n    alpha: float\n        Transparency of label\n\n    Returns\n    -------\n    axes: list of pyplot.ax\n        A list of matplotlib axes objects with alpha labels added\n    '''\n    import seaborn\n    import string\n    import numpy\n\n    if not numpy.iterable(xpos):\n        xpos = [xpos,]*len(axes)\n        ypos = [ypos,]*len(axes)\n\n    if (len(xpos) > 1) or (len(ypos) > 1):\n        try:\n            assert (len(axes) == len(xpos))\n        except AssertionError as e:\n            e.args += 'xpos iterable must be same length as axes'\n            raise\n        try:\n            assert (len(axes) == len(ypos))\n        except AssertionError as e:\n            e.args += 'ypos iterable must be same length as axes'\n            raise\n    else:\n        xpos = [xpos,]\n        ypos = [ypos,]\n\n    colors = seaborn.color_palette()\n    abc = string.ascii_uppercase\n\n    for i, (label, ax) in enumerate(zip(abc[:len(axes)], axes)):\n        if color is None:\n            color = colors[i]\n        kwargs = dict(color=color,\n                      fontweight=fontweight,)\n\n        bbox = dict(boxstyle=boxstyle,\n                     facecolor=facecolor,\n                     edgecolor=edgecolor,\n                     alpha=alpha)\n\n        ax.text(xpos[i], ypos[i], '{}{}'.format(label, suffix),\n                transform=ax.transAxes, fontsize=fontsize,\n                verticalalignment='top', bbox=bbox, **kwargs)\n    return axes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset maximum and minimum limits from list of axis objects to each axis Returns None if no limits are set", "response": "def merge_limits(axes, xlim=True, ylim=True):\n    '''Set maximum and minimum limits from list of axis objects to each axis\n\n    Args\n    ----\n    axes: iterable\n        list of `matplotlib.pyplot` axis objects whose limits should be modified\n    xlim: bool\n        Flag to set modification of x axis limits\n    ylim: bool\n        Flag to set modification of y axis limits\n    '''\n\n    # Compile lists of all x/y limits\n    xlims = list()\n    ylims = list()\n    for ax in axes:\n        [xlims.append(lim) for lim in ax.get_xlim()]\n        [ylims.append(lim) for lim in ax.get_ylim()]\n\n    # Iterate over axes objects and set limits\n    for ax in axes:\n        if xlim:\n            ax.set_xlim(min(xlims), max(xlims))\n        if ylim:\n            ax.set_ylim(min(ylims), max(ylims))\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nplot a non - contiguous slice of data.", "response": "def plot_noncontiguous(ax, data, ind, color='black', label='', offset=0,\n        linewidth=0.5, linestyle='-'):\n    '''Plot non-contiguous slice of data\n\n    Args\n    ----\n    data: ndarray\n        The data with non continguous regions to plot\n    ind: ndarray\n        indices of data to be plotted\n    color: matplotlib color\n        Color of plotted line\n    label: str\n        Name to be shown in legend\n    offset: int\n        The number of index positions to reset start of data to zero\n    linewidth: float\n        The width of the plotted line\n    linstyle: str\n        The char representation of the plotting style for the line\n\n    Returns\n    -------\n    ax: pyplot.ax\n        Axes object with line glyph added for non-contiguous regions\n    '''\n\n    def slice_with_nans(ind, data, offset):\n        '''Insert nans in indices and data where indices non-contiguous'''\n        import copy\n        import numpy\n\n        ind_nan          = numpy.zeros(len(data))\n        ind_nan[:]       = numpy.nan\n\n        # prevent ind from overwrite with deepcopy\n        ind_nan[ind-offset] = copy.deepcopy(ind)\n        #ind_nan             = ind_nan[ind[0]-offset:ind[-1]-offset]\n\n        # prevent data from overwrite with deepcopy\n        data_nan = copy.deepcopy(data)\n        data_nan[numpy.isnan(ind_nan)] = numpy.nan\n\n        return ind_nan, data_nan\n\n    x, y = slice_with_nans(ind, data, offset)\n    ax.plot(x, y, color=color, linewidth=linewidth, linestyle=linestyle,\n            label=label)\n\n    return ax"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plot_shade_mask(ax, ind, mask, facecolor='gray', alpha=0.5):\n    '''Shade across x values where boolean mask is `True`\n\n    Args\n    ----\n    ax: pyplot.ax\n        Axes object to plot with a shaded region\n    ind: ndarray\n        The indices to use for the x-axis values of the data\n    mask: ndarray\n        Boolean mask array to determine which regions should be shaded\n    facecolor: matplotlib color\n        Color of the shaded area\n\n    Returns\n    -------\n    ax: pyplot.ax\n        Axes object with the shaded region added\n    '''\n    ymin, ymax = ax.get_ylim()\n    ax.fill_between(ind, ymin, ymax, where=mask,\n                    facecolor=facecolor, alpha=alpha)\n    return ax", "response": "Plots a shade across x values where boolean mask is True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write(url, content, **args):\n    with HTTPResource(url, **args) as resource:\n        resource.write(content)", "response": "Put the object into a file URL."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nover-writes all field names with new field names. Mass renaming.", "response": "def fields(self, new_fieldnames):\n        \"\"\"\n        Overwrite all field names with new field names. Mass renaming.\n        \"\"\"\n        if len(new_fieldnames) != len(self.fields):\n            raise Exception(\"Cannot replace fieldnames (len: %s) with list of \"\n                            \"incorrect length (len: %s)\" % (len(new_fieldnames),\n                                                            len(self.fields)))\n        for old_name, new_name in izip(self.fields, new_fieldnames):\n            # use pop instead of `del` in case old_name == new_name\n            self.__data[new_name] = self.__data.pop(old_name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new instance of the DataTable from a CSV string.", "response": "def fromcsvstring(cls, csvstring, delimiter=\",\", quotechar=\"\\\"\"):\n        \"\"\"\n        Takes one string that represents the entire contents of the CSV\n        file, or similar delimited file.\n\n        If you have a list of lists, where the first list is the headers,\n        then use the main constructor.\n\n        If you see an excess of whitespace in the first column of your data,\n        this is probably because you tried to format a triple-quoted string\n        literal nicely. Don't add any padding to the left.\n\n        NOTE: Please prefix your triple-quoted string literal with `u` or `ur`\n        as necessary. For copy-pasting directly from Excel, use `ur`. For\n        copy-pasting from something Python (or similar) printed, use `ur`.\n        For something just dumped from Python via __repr__ or some other\n        text source that displays escape characters used, use `u`.\n\n        ---\n\n        Implementation notes:\n\n        This solution was inspired by UnicodeRW.\n        cStringIO.StringIO turns the passed string into a file-like\n        (readble) object. The string must be encoded so that StringIO\n        presents encoded text.\n\n        In UnicodeRW, codecs.getreader('utf-8') reads an encoded file object\n        to product a decoded file object on the fly. We don't need this.\n\n        We read the StringIO object line by line into csv.reader,\n        which is consumes encoded text and parses the CSV format out of it.\n        Then we decode each cell one by one as we pass it into the data table\n\n        csv.QUOTE_NONE (as well as the r-prefix on r'''string''') are vital\n        since we're copy-pasting directly from Excel. The string should be\n        treated as \"literally\" (\"raw\") as possible.\n        \"\"\"\n        if not isinstance(csvstring, basestring):\n            raise Exception(\"If trying to construct a DataTable with \"\n                            \"a list of lists, just use the main \"\n                            \"constructor. Make sure to include a header row\")\n\n        stringio = StringIO(csvstring.encode('utf-8'))\n        csv_data = csv.reader((line for line in stringio),\n                              delimiter=delimiter,\n                              dialect=csv.excel,\n                              quotechar=quotechar,\n                              quoting=csv.QUOTE_NONE)\n        new_datatable = cls((s.decode('utf-8') for s in row)\n                            for row in csv_data)\n        for field in new_datatable.fields:\n            new_datatable[field] = parse_column(new_datatable[field])\n        return new_datatable"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconstructs a new DataTable from a dictionary.", "response": "def fromdict(cls, datadict):\n        \"\"\"\n        Constructs a new DataTable using a dictionary of the format:\n\n        {field1: [a,b,c],\n         field2: [d,e,f],\n         field3: [g,h,i]}\n\n        ... which most closely matches the internal representation\n        of the DataTable. If it is an OrderedDict, the key order\n        will be preserved.\n        \"\"\"\n        new_datatable = cls()\n        for field, column in datadict.items():\n            new_datatable[field] = column\n        return new_datatable"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fromexcel(cls, path, sheet_name_or_num=0, headers=None):\n        reader = ExcelRW.UnicodeDictReader(path, sheet_name_or_num)\n        return cls(reader, headers=headers)", "response": "Constructs a new DataTable from an Excel file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __print_table(self, row_delim, header_delim=None,\n                      header_pad=u\"\", pad=u\"\"):\n        \"\"\"\n        row_delim         default delimiter inserted between columns of every\n                          row in the table.\n        header_delim      delimiter inserted within the headers. by default\n                          takes the value of `row_delim`\n        header_pad        put on the sides of the row of headers.\n        pad               put on the sides of every row.\n        \"\"\"\n        if header_delim is None:\n            header_delim = row_delim\n        num_cols = len(self.fields)\n        accumulator = ((u\"%s\" + header_delim) * num_cols)[:-len(header_delim)]\n        accumulator = ((header_pad + accumulator + header_pad + u\"\\n\") %\n                       tuple(self.fields))\n        for datarow in self:\n            rowstring = ((u\"%s\" + row_delim) * num_cols)[:-len(row_delim)]\n            rowstring = (pad + rowstring + pad + u\"\\n\") % tuple(datarow)\n            accumulator += rowstring\n        return accumulator[:-1]", "response": "Print a table of entries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a row to the internal data table.", "response": "def append(self, row):\n        \"\"\"\n        Takes a dict, a list/tuple/generator, or a DataRow/namedtuple,\n        and appends it to the \"bottom\" or \"end\" of the DataTable.\n\n        dicts must share the same keys as the DataTable's columns.\n\n        lists/tuples/generators are simply trusted to be in the correct order\n        and of the correct type (if relevant).\n\n        If the table being appended to is empty, the columns are inferred\n        from the row being appended.\n\n        DataRows and namedtuples' `_fields` protected class attribute is\n        checked for the field names. Those are checked against the DataTable\n        and then appended to the relevant columns using those field names.\n        \"\"\"\n        if isinstance(row, dict):\n            if self.fields and not set(row.keys()) == set(self.fields):\n                raise Exception(\"Cannot append a dict to DataTable without \"\n                                \"all keys matching (order being irrelevant).\\n\"\n                                \"dict: %s\\nDataTable: %s\" % (row.keys(),\n                                                             self.fields))\n            if not self.fields:\n                for field in row.keys():\n                    self.__data[field] = [row[field]]\n            else:\n                for field in self.fields:\n                    self.__data[field].append(row[field])\n        elif isinstance(row, (list, tuple, GeneratorType)):\n            if isinstance(row, tuple) and hasattr(row, '_fields'):\n                fieldnames = row._fields\n                if self.fields and not set(fieldnames) == set(self.fields):\n                    raise Exception(\"Cannot append a Datarow or namedtuple to \"\n                                    \"DataTable without all fields matching \"\n                                    \"(order being irrelevant).\\n\"\n                                    \"DataRow/namedtuple: %s\\n\"\n                                    \"DataTable: %s\" % (fieldnames, self.fields))\n                if not self.fields:\n                    for fieldname, value in izip(fieldnames, row):\n                        self.__data[fieldname] = [value]\n                else:\n                    for fieldname, value in izip(fieldnames, row):\n                        self.__data[fieldname].append(value)\n            else:\n                if isinstance(row, GeneratorType):\n                    row = tuple(row)\n                if self.fields and not len(row) == len(self.fields):\n                    raise Exception(\"The row being appended does not have the \"\n                                    \"correct length. It should have a length \"\n                                    \"of %s, but is %s\" % (len(self.fields),\n                                                          len(row)))\n                if not self.fields:\n                    raise Exception(\"Can't append a list/tuple/GeneratorType \"\n                                    \"as a row if the table doesn't have \"\n                                    \"columns defined yet.\")\n                # we're just going to hope that the generator's contents are\n                # provided in the right order, and of the right type.\n                for (_, column), element in izip(self.__data.items(), row):\n                    column.append(element)\n        else:\n            raise Exception(\"Unable to append type `%s` to DataTable\" %\n                            type(row))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef apply(self, func, *fields):\n        results = []\n        for row in self:\n            if not fields:\n                results.append(func(row))\n            else:\n                if any(field not in self for field in fields):\n                    for field in fields:\n                        if field not in self:\n                            raise Exception(\"Column `%s` does not exist \"\n                                            \"in DataTable\" % field)\n                results.append(func(*[row[field] for field in fields]))\n        return results", "response": "Applies the function func to every row in the DataTable."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef col(self, col_name_or_num):\n        if isinstance(col_name_or_num, basestring):\n            return self[col_name_or_num]\n        elif isinstance(col_name_or_num, (int, long)):\n            if col_name_or_num > len(self.fields):\n                raise IndexError(\"Invalid column index `%s` for DataTable\" %\n                                 col_name_or_num)\n            return self.__data[self.fields[col_name_or_num]]", "response": "Returns the column at index colnum or name colnum."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconcatenate two DataTables together and returns a new DataTable with the new data.", "response": "def concat(self, other_datatable, inplace=False):\n        \"\"\"\n        Concatenates two DataTables together, as long as column names\n        are identical (ignoring order). The resulting DataTable's columns\n        are in the order of the table whose `concat` method was called.\n        \"\"\"\n        if not isinstance(other_datatable, DataTable):\n            raise TypeError(\"`concat` requires a DataTable, not a %s\" %\n                            type(other_datatable))\n\n        # if the self table is empty, we can just return the other table\n        # if we need to do it in place, we just copy over the columns\n        if not self.fields:\n            if inplace:\n                for field in other_datatable.fields:\n                    self[field] = other_datatable[field]\n                return self\n            else:\n                return other_datatable\n        if not other_datatable.fields:\n            return self\n\n        if set(self.fields) != set(other_datatable.fields):\n            raise Exception(\"Columns do not match:\\nself: %s\\nother: %s\" %\n                            (self.fields, other_datatable.fields))\n\n        # TODO: this will fail if we're concatenating one table with `arrays`\n        # TODO: to a table with lists, even if everything else is compatible\n        # TODO: a TypeError is thrown\n        # TODO: if we run through and just append, this may be faster and\n        # TODO: more memory-efficient for large lists, as well as compatible\n        # TODO: with arrays\n        if inplace:\n            for field in self.fields:\n                self.__data[field] = self[field] + other_datatable[field]\n            return self\n        else:\n            new_table = DataTable()\n            for field in self.fields:\n                new_table[field] = self[field] + other_datatable[field]\n            return new_table"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef distinct(self, fieldname, key=None):\n        return tuple(unique_everseen(self[fieldname], key=key))", "response": "Returns the unique values seen at fieldname."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a new DataTable with rows that were True or equivalent in the masklist.", "response": "def mask(self, masklist):\n        \"\"\"\n        `masklist` is an array of Bools or equivalent.\n\n        This returns a new DataTable using only the rows that were True\n        (or equivalent) in the mask.\n        \"\"\"\n        if not hasattr(masklist, '__len__'):\n            masklist = tuple(masklist)\n\n        if len(masklist) != len(self):\n            raise Exception(\"Masklist length (%s) must match length \"\n                            \"of DataTable (%s)\" % (len(masklist), len(self)))\n\n        new_datatable = DataTable()\n        for field in self.fields:\n            new_datatable[field] = list(compress(self[field], masklist))\n        return new_datatable"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying function to each element of the column identified by fieldname.", "response": "def mutapply(self, function, fieldname):\n        \"\"\"\n        Applies `function` in-place to the field name specified.\n\n        In other words, `mutapply` overwrites column `fieldname`\n        ith the results of applying `function` to each element of that column.\n        \"\"\"\n        self[fieldname] = self.apply(function, fieldname)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrenaming a specific field and preserves the underlying order.", "response": "def rename(self, old_fieldname, new_fieldname):\n        \"\"\"\n        Renames a specific field, and preserves the underlying order.\n        \"\"\"\n        if old_fieldname not in self:\n            raise Exception(\"DataTable does not have field `%s`\" %\n                            old_fieldname)\n\n        if not isinstance(new_fieldname, basestring):\n            raise ValueError(\"DataTable fields must be strings, not `%s`\" %\n                             type(new_fieldname))\n\n        if old_fieldname == new_fieldname:\n            return\n\n        new_names = self.fields\n        location = new_names.index(old_fieldname)\n        del new_names[location]\n        new_names.insert(location, new_fieldname)\n        self.fields = new_names"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reorder(self, fields_in_new_order):\n        if not len(fields_in_new_order) == len(self.fields):\n            raise Exception(\"Fields to reorder with are not the same length \"\n                            \"(%s) as the original fields (%s)\" %\n                            (len(fields_in_new_order), len(self.fields)))\n        if not set(fields_in_new_order) == set(self.fields):\n            raise Exception(\"Fields to reorder with should be the same \"\n                            \"as the original fields\")\n        new = OrderedDict()\n        for field in fields_in_new_order:\n            new[field] = self.__data[field]\n        self.__data = new", "response": "Reorder the entries in the record in the specified order."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the row at the given index.", "response": "def row(self, rownum):\n        \"\"\"\n        Returns the row at index `rownum`.\n        ---\n        Note that the DataRow object returned that represents the data row\n        is constructed on the fly and is a just a shallow copy of\n        the underlying data that does not update dynamically.\n        \"\"\"\n        if rownum > len(self):\n            raise IndexError(\"Invalid row index `%s` for DataTable\" % rownum)\n        return datarow_constructor(self.fields)([self[field][rownum]\n                                                 for field in self.fields])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sample(self, num):\n        if num > len(self):\n            return self.copy()\n        elif num < 0:\n            raise IndexError(\"Cannot sample a negative number of rows \"\n                             \"from a DataTable\")\n\n        random_row_mask = ([True] * num) + ([False] * (len(self) - num))\n        shuffle(random_row_mask)\n\n        sampled_table = self.mask(random_row_mask)\n        random_col_name = 'random_sorting_column'\n        while random_col_name in sampled_table:\n            random_col_name = '%030x' % randrange(16**30)\n        sampled_table[random_col_name] = [random()\n                                          for _ in xrange(len(sampled_table))]\n        sampled_table.sort(random_col_name, inplace=True)\n        del sampled_table[random_col_name]\n        return sampled_table", "response": "Returns a new table with rows randomly sampled."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new DataTable with a subset of columns in this table", "response": "def select(self, *cols):\n        \"\"\"\n        Returns DataTable with a subset of columns in this table\n        \"\"\"\n        return DataTable([cols] + zip(*[self[col] for col in cols]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sort(self, fieldname, key=lambda x: x, desc=False, inplace=False):\n        try:\n            field_index = tuple(self.fields).index(fieldname)\n        except ValueError:\n            raise ValueError(\"Sorting on a field that doesn't exist: `%s`\" %\n                             fieldname)\n\n        data_cols = izip(*sorted(izip(*[self.__data[field]\n                                        for field in self.fields]),\n                                 key=lambda row: key(row[field_index]),\n                                 reverse=desc))\n\n        target_table = self if inplace else DataTable()\n\n        for field, data_col in izip(self.fields, data_cols):\n            target_table[field] = list(data_col)\n\n        # Note that sorting in-place still returns a reference\n        # to the table being sorted, for convenience.\n        return target_table", "response": "Sort the table by a field name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a new DataTable with rows only where the value at the given fieldname == value.", "response": "def where(self, fieldname, value, negate=False):\n        \"\"\"\n        Returns a new DataTable with rows only where the value at\n        `fieldname` == `value`.\n        \"\"\"\n        if negate:\n            return self.mask([elem != value\n                              for elem in self[fieldname]])\n        else:\n            return self.mask([elem == value\n                              for elem in self[fieldname]])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a new table with rows filtered by a function.", "response": "def wherefunc(self, func, fieldname=None, negate=False):\n        \"\"\"\n        .wherefunc(func, fieldname=None, negate=False)\n\n        Applies a function to an entire row and filters the rows based on the\n        boolean output of that function.\n\n        If you pass in the fieldname, optionally, the function will simply\n        take the value at that fieldname, rather than the whole row.\n        \"\"\"\n        if fieldname is not None:\n            if negate:\n                return self.mask([not func(value) for value in self[fieldname]])\n            else:\n                return self.mask([func(value) for value in self[fieldname]])\n        else:\n            if negate:\n                return self.mask([not func(row) for row in self])\n            else:\n                return self.mask([func(row) for row in self])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wherein(self, fieldname, collection, negate=False):\n        if negate:\n            return self.mask([elem not in collection\n                              for elem in self[fieldname]])\n        else:\n            return self.mask([elem in collection\n                              for elem in self[fieldname]])", "response": "Returns a new DataTable with rows only where the value at fieldname is contained within collection."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef wheregreater(self, fieldname, value):\n        return self.mask([elem > value for elem in self[fieldname]])", "response": "Returns a new DataTable with rows only where the value at fieldname > value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef whereless(self, fieldname, value):\n        return self.mask([elem < value for elem in self[fieldname]])", "response": "Returns a new DataTable with rows only where the value at fieldname < value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wherenotin(self, fieldname, value):\n        return self.wherein(fieldname, value, negate=True)", "response": "Logical opposite of wherein."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef writexlsx(self, path, sheetname=\"default\"):\n        writer = ExcelRW.UnicodeWriter(path)\n        writer.set_active_sheet(sheetname)\n        writer.writerow(self.fields)\n        writer.writerows(self)\n        writer.save()", "response": "Writes this table to an. xlsx file at the specified path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat a namespace and ending value into a python friendly format", "response": "def pyuri_formatter(namespace, value):\n    \"\"\" Formats a namespace and ending value into a python friendly format\n\n    args:\n        namespace: RdfNamespace or tuple in the format of (prefix, uri,)\n        value: end value to attach to the namespace\n    \"\"\"\n    if namespace[0]:\n        return \"%s_%s\" %(namespace[0], value)\n    else:\n        return \"pyuri_%s_%s\" % (base64.b64encode(bytes(namespace[1],\n                                                       \"utf-8\")).decode(),\n                                value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning values for robots html meta key", "response": "def robots(self):\n        \"\"\"Return values for robots html meta key\"\"\"\n        r = 'noindex' if self.is_noindex else 'index'\n        r += ','\n        r += 'nofollow' if self.is_nofollow else 'follow'\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds common arguments to the given parser.", "response": "def _add_common_args(parser, is_create=True):\n    \"\"\"If is_create is True, protocol and action become mandatory arguments.\n\n    CreateCommand = is_create : True\n    UpdateCommand = is_create : False\n    \"\"\"\n    parser.add_argument(\n        '--name',\n        help=_('Name for the firewall rule.'))\n    parser.add_argument(\n        '--description',\n        help=_('Description for the firewall rule.'))\n    parser.add_argument(\n        '--source-ip-address',\n        help=_('Source IP address or subnet.'))\n    parser.add_argument(\n        '--destination-ip-address',\n        help=_('Destination IP address or subnet.'))\n    parser.add_argument(\n        '--source-port',\n        help=_('Source port (integer in [1, 65535] or range in a:b).'))\n    parser.add_argument(\n        '--destination-port',\n        help=_('Destination port (integer in [1, 65535] or range in '\n               'a:b).'))\n    utils.add_boolean_argument(\n        parser, '--enabled', dest='enabled',\n        help=_('Whether to enable or disable this rule.'))\n    parser.add_argument(\n        '--protocol', choices=['tcp', 'udp', 'icmp', 'any'],\n        required=is_create,\n        type=utils.convert_to_lowercase,\n        help=_('Protocol for the firewall rule.'))\n    parser.add_argument(\n        '--action',\n        required=is_create,\n        type=utils.convert_to_lowercase,\n        choices=['allow', 'deny', 'reject'],\n        help=_('Action for the firewall rule.'))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the great circle distance between two points on the earth", "response": "def haversine(self, other):\n        \"\"\"\n        Calculate the great circle distance between two points\n        on the earth (specified in decimal degrees)\n        \"\"\"\n        # convert decimal degrees to radians\n        lon1, lat1, lon2, lat2 = map(radians,\\\n                [self.lon.low, self['lat'].low, other.lon.low,\n                    other['lat'].low])\n        # haversine formula\n        dlon = lon2 - lon1\n        dlat = lat2 - lat1\n        a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2) ** 2\n        c = 2 * asin(sqrt(a))\n        # multiply by radius of the earth\n        # km = 6367 * c\n        miles = 3961 * c\n        return miles"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of relations from object identified by a content type.", "response": "def get_relation_by_type_list(parser, token):\n    \"\"\"Gets list of relations from object identified by a content type.\n\n    Syntax::\n\n        {% get_relation_list [content_type_app_label.content_type_model] for [object] as [varname] [direction] %}\n    \"\"\"\n    tokens = token.contents.split()\n    if len(tokens) not in (6, 7):\n        raise template.TemplateSyntaxError(\n            \"%r tag requires 6 arguments\" % tokens[0]\n        )\n\n    if tokens[2] != 'for':\n        raise template.TemplateSyntaxError(\n            \"Third argument in %r tag must be 'for'\" % tokens[0]\n        )\n\n    if tokens[4] != 'as':\n        raise template.TemplateSyntaxError(\n            \"Fifth argument in %r tag must be 'as'\" % tokens[0]\n        )\n\n    direction = 'forward'\n    if len(tokens) == 7:\n        direction = tokens[6]\n\n    return RelationByTypeListNode(\n        name=tokens[1], obj=tokens[3], as_var=tokens[5], direction=direction\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter(cls, **items):\n        '''\n        Returns multiple Union objects with search params\n        '''\n        client = cls._new_api_client(subpath='/search')\n        items_dict = dict((k, v) for k, v in list(items.items()))\n        json_data = json.dumps(items_dict, sort_keys=True, indent=4)\n        return client.make_request(cls, 'post', post_data=json_data)", "response": "Returns multiple Union objects with search params\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save(self):\n        '''\n        Save an instance of a Union object\n        '''\n        client = self._new_api_client()\n        params = {'id': self.id} if hasattr(self, 'id') else {}\n        action =  'patch' if hasattr(self, 'id') else 'post'\n        saved_model = client.make_request(self, action, url_params=params, post_data=self._to_json)\n        self.__init__(**saved_model._to_dict)", "response": "Save an instance of a Union object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(cls, id):\n        '''\n        Destroy a Union object\n        '''\n        client = cls._new_api_client()\n        return client.make_request(cls, 'delete', url_params={'id': id})", "response": "Destroy a Union object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef publish(self, channel: str, value: Any):\n        self._r.publish(channel, str(value))", "response": "Sends a new value to the data bus"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\napply configuration on input targets.", "response": "def applyconfiguration(targets, conf=None, *args, **kwargs):\n    \"\"\"Apply configuration on input targets.\n\n    If targets are not annotated by a Configurable, a new one is instanciated.\n\n    :param Iterable targets: targets to configurate.\n    :param tuple args: applyconfiguration var args.\n    :param dict kwargs: applyconfiguration keywords.\n    :return: configured targets.\n    :rtype: list\n    \"\"\"\n\n    result = []\n\n    for target in targets:\n\n        configurables = Configurable.get_annotations(target)\n\n        if not configurables:\n            configurables = [Configurable()]\n\n        for configurable in configurables:\n\n            configuredtargets = configurable.applyconfiguration(\n                targets=[target], conf=conf, *args, **kwargs\n            )\n            result += configuredtargets\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the arguments and keywords for a target call.", "response": "def getcallparams(\n            self, target, conf=None, args=None, kwargs=None, exec_ctx=None\n    ):\n        \"\"\"Get target call parameters.\n\n        :param list args: target call arguments.\n        :param dict kwargs: target call keywords.\n        :return: args, kwargs\n        :rtype: tuple\"\"\"\n\n        if args is None:\n            args = []\n\n        if kwargs is None:\n            kwargs = {}\n\n        if conf is None:\n            conf = self.conf\n\n        params = conf.params\n\n        try:\n            argspec = getargspec(target)\n\n        except TypeError as tex:\n            argspec = None\n            callargs = {}\n\n        else:\n            try:\n                callargs = getcallargs(target, *args, **kwargs)\n\n            except TypeError as tex:\n                if tex.args[0].endswith('\\'{0}\\''.format(argspec.args[0])):\n                    args = [None]\n\n                else:\n                    raise\n\n                try:\n                    callargs = getcallargs(target, *args, **kwargs)\n\n                except TypeError as tex:\n                    if tex.args[0].endswith('\\'{0}\\''.format(argspec.args[0])):\n                        args = []\n\n                    else:\n                        raise\n\n                    callargs = getcallargs(target, *args, **kwargs)\n\n                args = []\n\n        pnames = set(params)\n\n        for pname in pnames:\n\n            if argspec and pname in argspec.args and (\n                    (exec_ctx is not None and pname in exec_ctx)\n                    or\n                    callargs.get(pname) is None\n            ):\n\n                kwargs[pname] = params[pname].value\n\n        if exec_ctx is not None:\n            exec_ctx |= pnames\n\n        return args, kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loadmodules(self, modules=None, rel=None):\n\n        result = []\n\n        if rel is None:\n            rel = self.rel\n\n        if modules is None:\n            modules = self._modules\n\n        for module in modules:\n\n            if isinstance(module, string_types):\n                name = module\n                module = lookup(name)\n\n            elif isinstance(module, ModuleType):\n                name = module.__name__\n\n            else:\n                raise TypeError(\n                    'wrong value {0} in {1}. List of str/module expected.'\n                    .format(\n                        module, modules\n                    )\n                )\n\n            if not rel and module in self._loadedmodules:\n                continue\n\n            reload_module(module)\n            result.append(module)\n            self._loadedmodules.add(module)\n\n        return result", "response": "ry to load modules and return loaded modules."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchanges required modules. Reload modules given in the value. :param list value: new modules to use.", "response": "def modules(self, value):\n        \"\"\"Change required modules.\n\n        Reload modules given in the value.\n\n        :param list value: new modules to use.\"\"\"\n\n        modules = [module.__name__ for module in self.loadmodules(value)]\n\n        self._modules = [\n            module for module in self._modules + modules\n            if module not in self._modules\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef conf(self, value):\n\n        self._conf = self._toconf(value)\n\n        if self.autoconf:\n            self.applyconfiguration()", "response": "Change of configuration.\n\n        :param value: new configuration to use.\n        :type value: Category or Configuration"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting input parameter to a Configuration object.", "response": "def _toconf(self, conf):\n        \"\"\"Convert input parameter to a Configuration.\n\n        :param conf: configuration to convert to a Configuration object.\n        :type conf: Configuration, Category or Parameter.\n\n        :rtype: Configuration\"\"\"\n\n        result = conf\n\n        if result is None:\n            result = Configuration()\n\n        elif isinstance(result, Category):\n            result = configuration(result)\n\n        elif isinstance(result, Parameter):\n            result = configuration(category('', result))\n\n        elif isinstance(result, list):\n            result = configuration(category('', *result))\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef paths(self, value):\n\n        if value is None:\n            value = ()\n\n        elif isinstance(value, string_types):\n            value = (value, )\n\n        self._paths = tuple(value)\n\n        if self.autoconf:\n            self.applyconfiguration()", "response": "Change of paths in adding it in watching list."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\napplies conf on a destination in those phases: 1. identify the right driver to use with paths to parse. 2. for all paths, get conf which matches input conf. 3. apply parsing rules on path parameters. 4. fill input conf with resolved parameters. 5. apply filled conf on targets. :param conf: conf from where get conf. :type conf: Configuration, Category or Parameter :param paths: conf files to parse. If paths is a str, it is automatically putted into a list. :type paths: list of str :param Iterable targets: objects to configure. this targets by default. :param dict scope: local variables to use for expression resolution. :param bool callconf: if True (False by default), the configuration is used in the callable target parameters while calling it. :param bool keepstate: if True (default), do not instanciate sub objects if they already exist. :param list modules: modules to load before configure this configurable. :return: configured targets. :rtype: list", "response": "def applyconfiguration(\n            self, conf=None, paths=None, drivers=None, logger=None,\n            targets=None, scope=None, safe=None, besteffort=None,\n            callconf=False, keepstate=None, modules=None\n    ):\n        \"\"\"Apply conf on a destination in those phases:\n\n        1. identify the right driver to use with paths to parse.\n        2. for all paths, get conf which matches input conf.\n        3. apply parsing rules on path parameters.\n        4. fill input conf with resolved parameters.\n        5. apply filled conf on targets.\n\n        :param conf: conf from where get conf.\n        :type conf: Configuration, Category or Parameter\n        :param paths: conf files to parse. If paths is a str, it is\n            automatically putted into a list.\n        :type paths: list of str\n        :param Iterable targets: objects to configure. this targets by default.\n        :param dict scope: local variables to use for expression resolution.\n        :param bool callconf: if True (False by default), the configuration is\n            used in the callable target parameters while calling it.\n        :param bool keepstate: if True (default), do not instanciate sub objects\n            if they already exist.\n        :param list modules: modules to load before configure this configurable.\n        :return: configured targets.\n        :rtype: list\n        \"\"\"\n\n        result = []\n\n        self.loadmodules(modules=modules)\n        modules = []\n\n        if scope is None:\n            scope = self.scope\n\n        if safe is None:\n            safe = self.safe\n\n        if besteffort is None:\n            besteffort = self.besteffort\n\n        if targets is None:\n            targets = self.targets\n\n        if logger is None:\n            logger = self.logger\n\n        if keepstate is None:\n            keepstate = self.keepstate\n\n        # get conf from drivers and paths\n        conf = self.getconf(\n            conf=conf, paths=paths, logger=logger, drivers=drivers,\n            modules=modules\n        )\n        if conf is not None:\n            # resolve all values\n            conf.resolve(\n                configurable=self, scope=scope, safe=safe, besteffort=besteffort\n            )\n            # configure resolved configuration\n            configured = self.configure(\n                conf=conf, targets=targets, callconf=callconf,\n                keepstate=keepstate, modules=modules\n            )\n\n            result += configured\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getconf(\n            self, conf=None, paths=None, drivers=None, logger=None, modules=None\n    ):\n        \"\"\"Get a configuration from paths.\n\n        :param conf: conf to update. Default this conf.\n        :type conf: Configuration, Category or Parameter\n        :param str(s) paths: list of conf files. Default this paths.\n        :param Logger logger: logger to use for logging info/error messages.\n        :param list drivers: ConfDriver to use. Default this drivers.\n        :param list modules: modules to reload before.\n        :return: not resolved configuration.\n        :rtype: Configuration\n        \"\"\"\n\n        result = None\n\n        self.loadmodules(modules=modules)\n        modules = []\n\n        conf = self._toconf(conf)\n\n        # start to initialize input params\n        if conf is None:\n            conf = self.conf.copy()\n\n        else:\n            selfconf = self.conf.copy()\n            selfconf.update(conf)\n            conf = selfconf\n\n        if paths is None:\n            paths = self.paths\n\n        if isinstance(paths, string_types):\n            paths = [paths]\n\n        if drivers is None:\n            drivers = self.drivers\n\n        if logger is None:\n            logger = self.logger\n\n        # iterate on all paths\n        for path in paths:\n\n            rscconf = None\n\n            for driver in drivers:  # find the best driver\n\n                rscconf = driver.getconf(path=path, conf=conf, logger=logger)\n\n                if rscconf is None:\n                    continue\n\n                conf.update(rscconf)\n\n            if rscconf is None:\n                # if no conf found, display a warning log message\n                if logger is not None:\n                    logger.warning(\n                        'No driver found among {0} for processing {1}'.format(\n                            drivers, path\n                        )\n                    )\n\n        result = conf\n\n        return result", "response": "Get a configuration from paths."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\napply input conf on the specified targets.", "response": "def configure(\n            self, conf=None, targets=None, logger=None, callconf=False,\n            keepstate=None, modules=None\n    ):\n        \"\"\"Apply input conf on targets objects.\n\n        Specialization of this method is done in the _configure method.\n\n        :param conf: configuration model to configure. Default is this conf.\n        :type conf: Configuration, Category or Parameter\n        :param Iterable targets: objects to configure. self targets by default.\n        :param Logger logger: specific logger to use.\n        :param bool callconf: if True (False by default), the configuration is\n            used in the callable target parameters while calling it.\n        :param bool keepstate: if True (default), do not instanciate sub objects\n            if they already exist.\n        :param list modules: modules to reload before.\n        :return: configured targets.\n        :rtype: list\n        :raises: Parameter.Error for any raised exception.\n        \"\"\"\n\n        result = []\n\n        self.loadmodules(modules=modules)\n        modules = []\n\n        conf = self._toconf(conf)\n\n        if conf is None:\n            conf = self.conf\n\n        if targets is None:\n            targets = self.targets\n\n        if logger is None:\n            logger = self.logger\n\n        if keepstate is None:\n            keepstate = self.keepstate\n\n        for target in targets:\n\n            try:\n                configured = self._configure(\n                    conf=conf, logger=logger, target=target, callconf=callconf,\n                    keepstate=keepstate, modules=modules\n                )\n\n            except Exception:\n                if logger is not None:\n                    logger.error(\n                        'Error {0} raised while configuring {1}/{2}'.format(\n                            format_exc(), self, targets\n                        )\n                    )\n\n            else:\n                result.append(configured)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconfigure this class with input conf only if auto_conf is True.", "response": "def _configure(\n            self, target, conf=None, logger=None, callconf=None, keepstate=None,\n            modules=None\n    ):\n        \"\"\"Configure this class with input conf only if auto_conf or\n        configure is true.\n\n        This method should be overriden for specific conf\n\n        :param target: object to configure. self targets by default.\n        :param Configuration conf: configuration model to configure. Default is\n            this conf.\n        :param Logger logger: logger to use.\n        :param bool callconf: if True, use conf in target __call__ parameters.\n        :param bool keepstate: if True recreate sub objects if they already\n            exist.\n        :param list modules: modules to reload before.\n        :return: configured target.\n        \"\"\"\n\n        result = target\n\n        self.loadmodules(modules=modules)\n        modules = []\n\n        if conf is None:\n            conf = self.conf\n\n        if logger is None:\n            logger = self.logger\n\n        if callconf is None:\n            callconf = self.callparams\n\n        if keepstate is None:\n            keepstate = self.keepstate\n\n        subcats = {}  # store sub configurable categories\n        params = []  # self parameters\n\n        sub_conf_prefix = Configurable.SUB_CONF_PREFIX\n\n        for cat in conf.values():  # separate sub params and params\n            cname = cat.name\n\n            if cname.startswith(sub_conf_prefix):\n\n                subcnames = cname.split(sub_conf_prefix)\n\n                pname = subcnames[1]\n                fcname = cname[1 + len(pname):]\n\n                if not fcname:\n                    fcname = str(random())\n\n                fcat = cat.copy(name=fcname)\n\n                if pname in subcats:\n                    subcats[pname].append(fcat)\n\n                else:\n                    subcats[pname] = [fcat]\n\n            else:\n                cparams = cat.params\n                params += cparams.values()\n\n        if callconf and callable(target):\n\n            conf = self._toconf(params)\n\n            args, kwargs = self.getcallparams(conf=conf, target=target)\n\n            result = target = target(*args, **kwargs)\n\n        for param in params:\n\n            value, pname = param.value, param.name\n\n            if pname in subcats:  # if sub param\n\n                subcallconf = True\n\n                if keepstate and hasattr(target, pname):\n                    subcallconf = False\n                    value = getattr(target, pname)\n\n                cats = subcats[pname]\n\n                subconf = configuration(*cats)\n\n                targets = applyconfiguration(\n                    targets=[value], conf=subconf, callconf=subcallconf,\n                    keepstate=keepstate, modules=modules\n                )\n                value = targets[0]\n\n            if param.error:\n                continue\n\n            elif self.foreigns or param.local:\n                try:\n                    setattr(target, pname, value)\n\n                except Exception:\n                    if logger is not None:\n                        logger.error(\n                            'Error while setting {0}({1}) on {2}: {3}'.format(\n                                pname, value, target, format_exc()\n                            )\n                        )\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the next possible completion for text.", "response": "def complete(self, text, state):\n        \"\"\"Return the next possible completion for 'text'.\n\n        This is called successively with state == 0, 1, 2, ... until it\n        returns None.  The completion should begin with 'text'.\n\n        \"\"\"\n        if self.use_main_ns:\n            self.namespace = __main__.__dict__\n\n        if not text.strip():\n            if state == 0:\n                if _readline_available:\n                    readline.insert_text('\\t')\n                    readline.redisplay()\n                    return ''\n                else:\n                    return '\\t'\n            else:\n                return None\n\n        if state == 0:\n            if \".\" in text:\n                self.matches = self.attr_matches(text)\n            else:\n                self.matches = self.global_matches(text)\n        try:\n            return self.matches[state]\n        except IndexError:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning candidates matching the text.", "response": "def find_matches(self, text):\n        \"\"\"Return candidates matching the text.\"\"\"\n        if self.use_main_ns:\n            self.namespace = __main__.__dict__\n\n        if \".\" in text:\n            return self.attr_matches(text)\n        else:\n            return self.global_matches(text)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing matches when text is a simple name.", "response": "def global_matches(self, text):\n        \"\"\"Compute matches when text is a simple name.\n\n        Return a list of all keywords, built-in functions and names currently\n        defined in self.namespace that match.\n\n        \"\"\"\n        import keyword\n        matches = []\n        seen = {\"__builtins__\"}\n        n = len(text)\n        for word in keyword.kwlist:\n            if word[:n] == text:\n                seen.add(word)\n                matches.append(word)\n        for nspace in [self.namespace, builtins.__dict__]:\n            for word, val in nspace.items():\n                if word[:n] == text and word not in seen:\n                    seen.add(word)\n                    matches.append(self._callable_postfix(val, word))\n        return matches"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes matches when text contains a dot.", "response": "def attr_matches(self, text):\n        \"\"\"Compute matches when text contains a dot.\n\n        Assuming the text is of the form NAME.NAME....[NAME], and is\n        evaluable in self.namespace, it will be evaluated and its attributes\n        (as revealed by dir()) are used as possible completions.  (For class\n        instances, class members are also considered.)\n\n        WARNING: this can still invoke arbitrary C code, if an object\n        with a __getattr__ hook is evaluated.\n\n        \"\"\"\n        import re\n        m = re.match(r\"(\\w+(\\.\\w+)*)\\.(\\w*)\", text)\n        if not m:\n            return []\n        expr, attr = m.group(1, 3)\n        try:\n            thisobject = eval(expr, self.namespace)\n        except Exception:\n            return []\n\n        # get the content of the object, except __builtins__\n        words = set(dir(thisobject))\n        words.discard(\"__builtins__\")\n\n        if hasattr(thisobject, '__class__'):\n            words.add('__class__')\n            words.update(get_class_members(thisobject.__class__))\n        matches = []\n        n = len(attr)\n        for word in words:\n            if word[:n] == attr:\n                try:\n                    val = getattr(thisobject, word)\n                except Exception:\n                    continue  # Exclude properties that are not set\n                word = self._callable_postfix(val, \"%s.%s\" % (expr, word))\n                matches.append(word)\n        matches.sort()\n        return matches"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef timemeter(msg=None):\n    def _time_meter(fn):\n        @functools.wraps(fn)\n        def _wrapper(*args, **kwargs):\n            mark = timeit.default_timer()\n            result = fn(*args, **kwargs)\n            cost = timeit.default_timer() - mark\n            if msg:\n                logger.info(msg, cost)\n            else:\n                logger.info('Execute <%s.%s> method cost %s seconds.', fn.__module__, fn.__name__, cost)\n            return result\n        return _wrapper\n    return _time_meter", "response": "Decorator for time - metering functions."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dict_camel_to_snake_case(camel_dict, convert_keys=True, convert_subkeys=False):\n\n    converted = {}\n    for key, value in camel_dict.items():\n        if isinstance(value, dict):\n            new_value = dict_camel_to_snake_case(value, convert_keys=convert_subkeys,\n                                                 convert_subkeys=True)\n        elif isinstance(value, list):\n            new_value = []\n            for subvalue in value:\n                new_subvalue = dict_camel_to_snake_case(subvalue, convert_keys=convert_subkeys,\n                                                        convert_subkeys=True) \\\n                    if isinstance(subvalue, dict) else subvalue\n                new_value.append(new_subvalue)\n        else:\n            new_value = value\n        new_key = to_snake_case(key) if convert_keys else key\n        converted[new_key] = new_value\n    return converted", "response": "Recursively convert camelCased keys for a camelCased dict into snake_cased keys"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dict_snake_to_camel_case(snake_dict, convert_keys=True, convert_subkeys=False):\n\n    converted = {}\n    for key, value in snake_dict.items():\n        if isinstance(value, dict):\n            new_value = dict_snake_to_camel_case(value, convert_keys=convert_subkeys,\n                                                 convert_subkeys=True)\n        elif isinstance(value, list):\n            new_value = []\n            for subvalue in value:\n                new_subvalue = dict_snake_to_camel_case(subvalue, convert_keys=convert_subkeys,\n                                                        convert_subkeys=True) \\\n                    if isinstance(subvalue, dict) else subvalue\n                new_value.append(new_subvalue)\n        else:\n            new_value = value\n        new_key = to_camel_case(key) if convert_keys else key\n        converted[new_key] = new_value\n    return converted", "response": "Recursively convert a snake_cased dict into a camelCased dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\noutputting a ul for this set of radio fields.", "response": "def render(self):\n        \"\"\"Outputs a <ul> for this set of radio fields.\"\"\"\n        t = template.loader.get_template('support/forms/profile_picture.html')\n        return t.render(template.Context({'widget': self, 'MEDIA_URL': settings.MEDIA_URL }))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dubstep(client, channel, nick, message, matches):\n    now = time.time()\n\n    if dubstep._last and (now - dubstep._last) > WUB_TIMEOUT:\n        dubstep._counts[channel] = 0\n\n    dubstep._last = now\n    if dubstep._counts[channel] >= MAX_WUBS:\n        dubstep._counts[channel] = 0\n        return u'STOP! MY HEAD IS VIBRATING'\n    else:\n        dubstep._counts[channel] += 1\n        return u'wubwub' * dubstep._counts[channel] * random.randint(1, 4)", "response": "Dubstep is a rapid succession of wow wows and yep wows and yep wows and yep wows."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrestructure / prepare data about trees for output.", "response": "def prepare(data):\n    \"\"\"Restructure/prepare data about trees for output.\"\"\"\n    sha = data.get(\"sha\")\n    tree = data.get(\"tree\")\n    return {\"sha\": sha, \"tree\": tree}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_tree(profile, sha, recursive=True):\n    resource = \"/trees/\" + sha\n    if recursive:\n        resource += \"?recursive=1\"\n    data = api.get_request(profile, resource)\n    return prepare(data)", "response": "Fetch a tree.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        sha\n            The SHA of the tree to fetch.\n\n        recursive\n            If ``True``, traverse all subtrees and their subtrees, all the\n            way down. That will return a list of all objects in the tree,\n            all levels deep.\n\n    Returns:\n        A dict with data about the tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_tree(profile, tree):\n    resource = \"/trees\"\n    payload = {\"tree\": tree}\n    data = api.post_request(profile, resource, payload)\n    return prepare(data)", "response": "Create a new tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nensuring that all fields values are valid and that non - nullable fields are present.", "response": "def validate(self):\n        \"\"\"Ensure that all fields' values are valid and that non-nullable fields are present. \"\"\"\n        for field_name, field_obj in self._fields.items():\n            value = field_obj.__get__(self, self.__class__)\n\n            if value is None and field_obj.null is False:\n                raise ValidationError('Non-nullable field {0} is set to None'.format(field_name))\n            elif value is None and field_obj.null is True:\n                # no further validations are possible on NoneType field\n                continue\n\n            if isinstance(field_obj, NestedDocumentField):\n                value.validate()\n            else:\n                field_obj.validate(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_json(self):\n        json_data = dict()\n\n        for field_name, field_obj in self._fields.items():\n            if isinstance(field_obj, NestedDocumentField):\n                nested_document = field_obj.__get__(self, self.__class__)\n                value = None if nested_document is None else nested_document.to_json()\n            elif isinstance(field_obj, BaseField):\n                value = field_obj.__get__(self, self.__class__)\n                value = field_obj.to_json(value)\n            else:\n                # ignore fields not derived from BaseField or NestedDocument\n                continue\n\n            if value is None:\n                # skip fields with None value \n                continue\n\n            json_data[field_name] = value\n\n        return json_data", "response": "Converts given document to JSON dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_json(cls, json_data):\n        new_instance = cls()\n        for field_name, field_obj in cls._get_fields().items():\n            if isinstance(field_obj, NestedDocumentField):\n                if field_name in json_data:\n                    nested_field = field_obj.__get__(new_instance, new_instance.__class__)\n                    if not nested_field:\n                        # here, we have to create an instance of the nested document,\n                        # since we have a JSON object for it\n                        nested_field = field_obj.nested_klass()\n\n                    nested_document = nested_field.from_json(json_data[field_name])\n                    field_obj.__set__(new_instance, nested_document)\n            elif isinstance(field_obj, BaseField):\n                if field_name in json_data:\n                    value = field_obj.from_json(json_data[field_name])\n                    field_obj.__set__(new_instance, value)\n            else:\n                continue\n\n        return new_instance", "response": "Converts a JSON object to a new document instance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef decompose_dateint(dateint):\n    year = int(dateint / 10000)\n    leftover = dateint - year * 10000\n    month = int(leftover / 100)\n    day = leftover - month * 100\n    return year, month, day", "response": "Decomposes the given dateint into its year month and day components."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dateint_to_datetime(dateint):\n    if len(str(dateint)) != 8:\n        raise ValueError(\n            'Dateints must have exactly 8 digits; the first four representing '\n            'the year, the next two the months, and the last two the days.')\n    year, month, day = decompose_dateint(dateint)\n    return datetime(year=year, month=month, day=day)", "response": "Converts the given dateint into a datetime object in local timezone."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dateint_to_weekday(dateint, first_day='Monday'):\n    weekday_ix = dateint_to_datetime(dateint).weekday()\n    return (weekday_ix - WEEKDAYS.index(first_day)) % 7", "response": "Returns the weekday of the given dateint."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new object shifted by the given dateint.", "response": "def shift_dateint(dateint, day_shift):\n    \"\"\"Shifts the given dateint by the given amount of days.\n\n    Arguments\n    ---------\n    dateint : int\n        An integer object decipting a specific calendaric day; e.g. 20161225.\n    days : int\n        The number of days to shift the given dateint by. A negative number\n        shifts the dateint backwards.\n\n    Returns\n    -------\n    int\n       A dateint corresponding to the given date shifted by the given amount\n       of days.\n\n    Example\n    -------\n    >>> shift_dateint(20170228, 1)\n    20170301\n    >>> shift_dateint(20170301, -1)\n    20170228\n    >>> shift_dateint(20170220, 5)\n    20170225\n    \"\"\"\n    dtime = dateint_to_datetime(dateint)\n    delta = timedelta(days=abs(day_shift))\n    if day_shift > 0:\n        dtime = dtime + delta\n    else:\n        dtime = dtime - delta\n    return datetime_to_dateint(dtime)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning all dateints in the given dateint range.", "response": "def dateint_range(first_dateint, last_dateint):\n    \"\"\"Returns all dateints in the given dateint range.\n\n    Arguments\n    ---------\n    first_dateint : int\n        An integer object decipting a specific calendaric day; e.g. 20161225.\n    last_dateint : int\n        An integer object decipting a specific calendaric day; e.g. 20170108.\n\n    Returns\n    -------\n    iterable\n        An iterable of ints representing all days in the given dateint range.\n\n    Example\n    -------\n    >>> dateint_range(20170228, 20170301)\n    [20170228, 20170301]\n    >>> dateint_range(20170225, 20170301)\n    [20170225, 20170226, 20170227, 20170228, 20170301]\n    \"\"\"\n    first_datetime = dateint_to_datetime(first_dateint)\n    last_datetime = dateint_to_datetime(last_dateint)\n    delta = last_datetime - first_datetime\n    delta_in_hours = math.ceil(delta.total_seconds() / 3600)\n    delta_in_days = math.ceil(delta_in_hours / 24) + 1\n    dateint_set = set()\n    for delta_i in range(0, delta_in_days * 24, 24):\n        datetime_i = first_datetime + timedelta(hours=delta_i)\n        dateint_i = datetime_to_dateint(datetime_i)\n        if dateint_i <= last_dateint:\n            dateint_set.add(dateint_i)\n    return sorted(dateint_set)"}
